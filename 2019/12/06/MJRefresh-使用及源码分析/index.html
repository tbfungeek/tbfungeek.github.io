
 <!DOCTYPE HTML>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
  
    <title>MJRefresh 使用及源码分析 | Edgar&#39;s Blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="Edgar">
    

    
    <meta name="description" content="开源库信息： MJRefresh  MJRefresh是目前用得比较多的下拉刷新，上拉加载开源库了，它支持UIScrollView、UITableView、UICollectionView、UIWebView 整个类结构图如下：  下面是在网上找的比较好的一张图，也附带给大家  在开始讲解MJRefresh源码之前大家最好对UIScrollView的各个尺寸数据有个明确的认识，下面是在网上找的一个">
<meta property="og:type" content="article">
<meta property="og:title" content="MJRefresh 使用及源码分析">
<meta property="og:url" content="http://yoursite.com/2019/12/06/MJRefresh-%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/index.html">
<meta property="og:site_name" content="Edgar&#39;s Blog">
<meta property="og:description" content="开源库信息： MJRefresh  MJRefresh是目前用得比较多的下拉刷新，上拉加载开源库了，它支持UIScrollView、UITableView、UICollectionView、UIWebView 整个类结构图如下：  下面是在网上找的比较好的一张图，也附带给大家  在开始讲解MJRefresh源码之前大家最好对UIScrollView的各个尺寸数据有个明确的认识，下面是在网上找的一个">
<meta property="og:locale">
<meta property="og:image" content="http://yoursite.com/2019/12/06/MJRefresh-%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/0000001.png">
<meta property="og:image" content="http://yoursite.com/2019/12/06/MJRefresh-%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/0000002.png">
<meta property="og:image" content="http://yoursite.com/2019/12/06/MJRefresh-%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/0000003.png">
<meta property="article:published_time" content="2019-12-05T17:23:45.000Z">
<meta property="article:modified_time" content="2019-12-19T13:48:20.000Z">
<meta property="article:author" content="Edgar">
<meta property="article:tag" content="iOS 开源库分析">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/2019/12/06/MJRefresh-%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/0000001.png">

    
    <link rel="alternative" href="atom.xml" title="Edgar&#39;s Blog" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/unnamed4_n_mSY_icon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/profile.png">
    <link rel="apple-touch-icon-precomposed" href="/img/profile.png">
    
    
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 6.2.0"></head>

  <body>
    <header>
      
<div>
		
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="Edgar&#39;s Blog">Edgar&#39;s Blog</a></h1>
				<h2 class="blog-motto"></h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="Menu">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
					<li>
 					
					<form class="search" action="/search/index.html" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" autocomplete="off" name="q" maxlength="20" placeholder="Search" />
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
  
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/12/06/MJRefresh-使用及源码分析/" title="MJRefresh 使用及源码分析" itemprop="url">MJRefresh 使用及源码分析</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Edgar" target="_blank" itemprop="author">Edgar</a>
		
  <p class="article-time">
    <time datetime="2019-12-05T17:23:45.000Z" itemprop="datePublished"> Published 2019-12-06</time>
    
  </p>
</header>
	<div class="article-content">
		
		<h5 id="开源库信息："><a href="#开源库信息：" class="headerlink" title="开源库信息："></a>开源库信息：</h5><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/CoderMJLee/MJRefresh">MJRefresh</a></li>
</ul>
<p>MJRefresh是目前用得比较多的下拉刷新，上拉加载开源库了，它支持<strong><strong>UIScrollView</strong></strong>、<strong><strong>UITableView</strong></strong>、<strong><strong>UICollectionView</strong></strong>、<strong><strong>UIWebView</strong></strong></p>
<p>整个类结构图如下：</p>
<p><img src="/2019/12/06/MJRefresh-%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/0000001.png"></p>
<p>下面是在网上找的比较好的一张图，也附带给大家</p>
<p><img src="/2019/12/06/MJRefresh-%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/0000002.png"></p>
<p>在开始讲解MJRefresh源码之前大家最好对UIScrollView的各个尺寸数据有个明确的认识，下面是在网上找的一个比较好的图大家可以对照着这个来看：</p>
<p><img src="/2019/12/06/MJRefresh-%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/0000003.png"></p>
<p><strong><strong>MJRefreshComponent</strong></strong> </p>
<p>MJRefreshComponent是所有上拉下拉控件的基类，它主要是通过KVO实现对scrollView <strong><strong>contentOffset</strong></strong>，<strong><strong>contentSize</strong></strong>，以及scrollView 手势状态也就是: self.scrollView.panGestureRecognizer <strong><strong>state</strong></strong>的监听，来分别触发下面的对应方法，这些方法在不同的子类都有自己的实现，这个后面会具体展开介绍：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// scrollView ContentOffset改变的时候触发</span></span><br><span class="line">- (<span class="type">void</span>)scrollViewContentOffsetDidChange:(<span class="built_in">NSDictionary</span> *)change&#123;&#125;</span><br><span class="line"><span class="comment">// scrollView ContentSize改变的时候触发</span></span><br><span class="line">- (<span class="type">void</span>)scrollViewContentSizeDidChange:(<span class="built_in">NSDictionary</span> *)change&#123;&#125;</span><br><span class="line"><span class="comment">// scrollView 手势状态改变的时候触发</span></span><br><span class="line">- (<span class="type">void</span>)scrollViewPanStateDidChange:(<span class="built_in">NSDictionary</span> *)change&#123;&#125;</span><br></pre></td></tr></table></figure>

<p><strong><strong>MJRefreshHeader</strong></strong></p>
<p>MJRefreshHeader主要负责通过ContentOffset的变化以及是否正在滑动状态来确定上拉，下滑控件的状态。并负责上一次刷新时间的记录。</p>
<p><strong><strong>MJRefreshStateHeader</strong></strong></p>
<p>MJRefreshStateHeader 负责状态文本以及上一次更新时间文本的显示。</p>
<p><strong><strong>MJRefreshNormalHeader</strong></strong></p>
<p>MJRefreshNormalHeader 负责箭头和加载菊花的状态显示。</p>
<p><strong><strong>MJRefreshGifHeader</strong></strong></p>
<p>MJRefreshGifHeader 负责加载Gif图片的状态控制</p>
<p><strong><strong>MJRefreshFooter</strong></strong></p>
<p>MJRefreshFooter 主要负责上拉控件状态的维护</p>
<p><strong><strong>MJRefreshAutoFooter</strong></strong></p>
<p>MJRefreshAutoFooter 负责维护ContentOffset 与 state的对应关系。</p>
<p><strong><strong>MJRefreshAutoStateFooter</strong></strong></p>
<p>MJRefreshAutoStateFooter 主要负责状态文本的控制。</p>
<p><strong><strong>MJRefreshAutoNormalFooter</strong></strong></p>
<p>MJRefreshAutoNormalFooter 主要负责加载菊花的状态控制</p>
<p><strong><strong>MJRefreshAutoGifFooter</strong></strong></p>
<p>MJRefreshAutoGifFooter 主要负责Gif类型的加载动画控制</p>
<p><strong><strong>MJRefreshBackStateFooter</strong></strong></p>
<p>MJRefreshBackStateFooter 负责自动返回类型上拉控件的状态文本控制。</p>
<p><strong><strong>MJRefreshBackNormalFooter</strong></strong></p>
<p>MJRefreshBackNormalFooter负责自动返回类型上拉控件的加载菊花状态控制。</p>
<p><strong><strong>MJRefreshBackGifFooter</strong></strong></p>
<p>MJRefreshBackGifFooter 负责自动返回类型上拉控件加载Gif动画的播放控制。</p>
<p><strong><strong>MJRefreshConst</strong></strong></p>
<p>MJRefreshConst 里面放置的是整个MJRefresh的常量以及关键宏定义。</p>
<p><strong><strong>UIScrollView+MJExtension</strong></strong></p>
<p>UIScrollView+MJExtension存放的是UIScrollView尺寸位置数据的便捷方法</p>
<p><strong><strong>UIView+MJExtension</strong></strong><br>UIView+MJExtension 和 UIScrollView+MJExtension类似存放的是UIView尺寸位置数据的便捷方法</p>
<p><strong><strong>UIScrollView+MJRefresh</strong></strong></p>
<p>UIScrollView+MJRefresh 中通过关联属性方式为UIScrollView添加了MJRefreshHeader和MJRefreshFooter</p>
<p><strong><strong>NSBundle+MJRefresh</strong></strong></p>
<p>NSBundle+MJRefresh 是 MJRefresh 内的文本以及图片资源获取方法。</p>
<p><strong><strong>MJRefreshConfig</strong></strong><br>用于存放MJRefresh的配置的类，目前只存放languageCode，暂时没多大用处。</p>
<p>其实整个大的方向还是遵循</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">手动滑动S<span class="function"><span class="title">crollView</span> --&gt;</span> S<span class="function"><span class="title">crollView</span> ContentOffset / 滑动状态 发生变化 --&gt;</span> MJR<span class="function"><span class="title">efresh</span> 状态发生变化 --&gt;</span> 触发对应的改变，比如上一次更新时间，状态文本，菊花状态等等。</span><br></pre></td></tr></table></figure>

<p>下面就顺着这个思路来对MJRefresh源码进行解析：</p>
<h5 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h5><p><strong><strong>MJRefreshComponent</strong></strong></p>
<p><strong><strong>状态常量的定义</strong></strong></p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">/** 刷新控件的状态 */</span></span><br><span class="line">typedef NS_ENUM(NSInteger, MJRefreshState) &#123;</span><br><span class="line">    <span class="regexp">/** 普通闲置状态 */</span></span><br><span class="line">    MJRefreshStateIdle = <span class="number">1</span>,</span><br><span class="line">    <span class="regexp">/** 松开就可以进行刷新的状态 */</span></span><br><span class="line">    MJRefreshStatePulling,</span><br><span class="line">    <span class="regexp">/** 正在刷新中的状态 */</span></span><br><span class="line">    MJRefreshStateRefreshing,</span><br><span class="line">    <span class="regexp">/** 即将刷新的状态 */</span></span><br><span class="line">    MJRefreshStateWillRefresh,</span><br><span class="line">    <span class="regexp">/** 所有数据加载完毕，没有更多的数据了 */</span></span><br><span class="line">    MJRefreshStateNoMoreData</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong><strong>状态改变的回调类型定义</strong></strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 进入刷新状态的回调 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">void</span> (^MJRefreshComponentRefreshingBlock)(<span class="built_in">void</span>);</span><br><span class="line"><span class="comment">/** 开始刷新后的回调(进入刷新状态后的回调) */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">void</span> (^MJRefreshComponentBeginRefreshingCompletionBlock)(<span class="built_in">void</span>);</span><br><span class="line"><span class="comment">/** 结束刷新后的回调 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">void</span> (^MJRefreshComponentEndRefreshingCompletionBlock)(<span class="built_in">void</span>);</span><br></pre></td></tr></table></figure>

<p><strong><strong>关键属性</strong></strong></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 刷新状态 一般交给子类内部实现 */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) MJRefreshState state;</span><br><span class="line"><span class="comment">/** 记录scrollView刚开始的inset */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">UIEdgeInsets</span> scrollViewOriginalInset;</span><br><span class="line"><span class="comment">/** 父控件 */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">UIScrollView</span> *scrollView;</span><br><span class="line"><span class="comment">/** 拉拽的百分比(交给子类重写) */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">CGFloat</span> pullingPercent;</span><br><span class="line"><span class="comment">/** 根据拖拽比例自动切换透明度 */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>, <span class="keyword">getter</span>=isAutomaticallyChangeAlpha) <span class="type">BOOL</span> automaticallyChangeAlpha;</span><br><span class="line"><span class="comment">/** 是否正在刷新 */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">getter</span>=isRefreshing) <span class="type">BOOL</span> refreshing;</span><br></pre></td></tr></table></figure>

<p><strong><strong>状态触发，及状态关键节点回调</strong></strong></p>
<p>状态触发：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 进入刷新状态 */</span></span><br><span class="line">- (<span class="built_in">void</span>)beginRefreshing;</span><br><span class="line">- (<span class="built_in">void</span>)beginRefreshingWithCompletionBlock:(<span class="built_in">void</span> (^)(<span class="built_in">void</span>))completionBlock;</span><br><span class="line"><span class="comment">/** 结束刷新状态 */</span></span><br><span class="line">- (<span class="built_in">void</span>)endRefreshing;</span><br><span class="line">- (<span class="built_in">void</span>)endRefreshingWithCompletionBlock:(<span class="built_in">void</span> (^)(<span class="built_in">void</span>))completionBlock;</span><br></pre></td></tr></table></figure>
<p>状态关键节点回调:</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 正在刷新的回调 */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">copy</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nullable</span>) MJRefreshComponentRefreshingBlock refreshingBlock;</span><br><span class="line"><span class="comment">/** 开始刷新后的回调(进入刷新状态后的回调) */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">copy</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nullable</span>) MJRefreshComponentBeginRefreshingCompletionBlock beginRefreshingCompletionBlock;</span><br><span class="line"><span class="comment">/** 带动画的结束刷新的回调 */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">copy</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nullable</span>) MJRefreshComponentEndRefreshingCompletionBlock endRefreshingAnimateCompletionBlock;</span><br><span class="line"><span class="comment">/** 结束刷新的回调 */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">copy</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nullable</span>) MJRefreshComponentEndRefreshingCompletionBlock endRefreshingCompletionBlock;</span><br></pre></td></tr></table></figure>

<p><strong><strong>供给子类实现的方法</strong></strong></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 初始化 */</span></span><br><span class="line">- (<span class="type">void</span>)prepare <span class="built_in">NS_REQUIRES_SUPER</span>;</span><br><span class="line"><span class="comment">/** 摆放子控件frame */</span></span><br><span class="line">- (<span class="type">void</span>)placeSubviews <span class="built_in">NS_REQUIRES_SUPER</span>;</span><br><span class="line"><span class="comment">/** 当scrollView的contentOffset发生改变的时候调用 */</span></span><br><span class="line">- (<span class="type">void</span>)scrollViewContentOffsetDidChange:(<span class="keyword">nullable</span> <span class="built_in">NSDictionary</span> *)change <span class="built_in">NS_REQUIRES_SUPER</span>;</span><br><span class="line"><span class="comment">/** 当scrollView的contentSize发生改变的时候调用 */</span></span><br><span class="line">- (<span class="type">void</span>)scrollViewContentSizeDidChange:(<span class="keyword">nullable</span> <span class="built_in">NSDictionary</span> *)change <span class="built_in">NS_REQUIRES_SUPER</span>;</span><br><span class="line"><span class="comment">/** 当scrollView的拖拽状态发生改变的时候调用 */</span></span><br><span class="line">- (<span class="type">void</span>)scrollViewPanStateDidChange:(<span class="keyword">nullable</span> <span class="built_in">NSDictionary</span> *)change <span class="built_in">NS_REQUIRES_SUPER</span>;</span><br></pre></td></tr></table></figure>


<p>我们截取官方Demo例子作为一个场景来对整个代码解析:</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">__<span class="keyword">unsafe_unretained</span> <span class="built_in">UITableView</span> *tableView = <span class="keyword">self</span>.tableView;</span><br><span class="line">tableView.mj_header= [MJRefreshNormalHeader headerWithRefreshingBlock:^&#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<p>当然我们会先将注意力聚焦在MJRefreshComponent。</p>
<p><strong><strong>1. MJRefreshComponent初始化</strong></strong></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)initWithFrame:(<span class="built_in">CGRect</span>)frame &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="variable language_">super</span> initWithFrame:frame]) &#123;</span><br><span class="line">        <span class="comment">// 准备工作</span></span><br><span class="line">        [<span class="keyword">self</span> prepare];</span><br><span class="line">        <span class="comment">// 默认是普通状态</span></span><br><span class="line">        <span class="keyword">self</span>.state = MJRefreshStateIdle;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="type">void</span>)prepare &#123;</span><br><span class="line">    <span class="comment">// 基本属性</span></span><br><span class="line">    <span class="keyword">self</span>.autoresizingMask = <span class="built_in">UIViewAutoresizingFlexibleWidth</span>;</span><br><span class="line">    <span class="keyword">self</span>.backgroundColor = [<span class="built_in">UIColor</span> clearColor];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这部分的工作主要是初始状态的设置。在设置状态的时候会调用state的setter。这里面会触发布局,这也是为什么autoresizingMask一定要在prepare进行设置的原因：</p>
<figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">- (void)<span class="built_in">set</span>State:(MJRefreshState)<span class="keyword">state</span>&#123;</span><br><span class="line">    _state = <span class="keyword">state</span>;</span><br><span class="line">    // 加入主队列的目的是等<span class="built_in">set</span>State:方法调用完毕、设置完文字后再去布局子控件</span><br><span class="line">    MJRefreshDispatchAsyncOnMainQueue([<span class="literal">self</span> <span class="built_in">set</span>NeedsLayout];)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于MJRefreshComponent这里面，placeSubviews是空的。主要是对子类placeSubviews的触发。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">void</span>)layoutSubviews &#123;</span><br><span class="line"><span class="string">    [self placeSubviews]</span>;</span><br><span class="line"><span class="string">    [super layoutSubviews]</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以初始化过程主要完成如下任务：</p>
<ul>
<li>调用prepare做一些准备工作</li>
<li>设置MJRefresh的状态为Idle状态</li>
<li>触发布局</li>
</ul>
<p><strong><strong>2. MJRefreshComponent添加到父控件：</strong></strong></p>
<p>新建MJRefreshComponent子类成功后会通过<strong><strong>setMj_header</strong></strong>添加到UIScrollView或者它的子类上。</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">- (void)setMj_header:(MJRefreshHeader *)mj_header &#123;</span><br><span class="line">    if (mj_header != self.mj_header) &#123;</span><br><span class="line">        <span class="comment">// 删除旧的，添加新的</span></span><br><span class="line">        <span class="selector-attr">[self.mj_header removeFromSuperview]</span>;</span><br><span class="line">        <span class="selector-attr">[self insertSubview:mj_header atIndex:0]</span>;</span><br><span class="line">        <span class="comment">// 存储新的</span></span><br><span class="line">        <span class="built_in">objc_setAssociatedObject</span>(self, &amp;MJRefreshHeaderKey,</span><br><span class="line">                                 mj_header, OBJC_ASSOCIATION_RETAIN);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在调用insertSubview 的时候 MJRefreshComponent的 willMoveToSuperview:</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">- (void)willMoveToSuperview:<span class="type"></span>(UIView *)<span class="keyword">new</span><span class="type">Superview</span> &#123;</span><br><span class="line">    [<span class="keyword">super</span> willMoveToSuperview:<span class="type">newSuperview</span>];</span><br><span class="line">    <span class="comment">// 如果不是UIScrollView，不做任何事情</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">new</span><span class="type">Superview</span> &amp;&amp; ![<span class="keyword">new</span><span class="type">Superview</span> isKindOfClass:<span class="type"></span>[UIScrollView class]]) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 旧的父控件移除监听</span></span><br><span class="line">    [self removeObservers];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">new</span><span class="type">Superview</span>) &#123; <span class="comment">// 新的父控件</span></span><br><span class="line">        <span class="comment">// 记录UIScrollView</span></span><br><span class="line">        _scrollView = (UIScrollView *)<span class="keyword">new</span><span class="type">Superview</span>;</span><br><span class="line">        <span class="comment">// 设置宽度</span></span><br><span class="line">        self.mj_w = _scrollView.mj_w;</span><br><span class="line">        <span class="comment">// 设置位置</span></span><br><span class="line">        self.mj_x = -_scrollView.mj_insetL;</span><br><span class="line">        <span class="comment">// 设置永远支持垂直弹簧效果</span></span><br><span class="line">        _scrollView.alwaysBounceVertical = YES;</span><br><span class="line">        <span class="comment">// 记录UIScrollView最开始的contentInset</span></span><br><span class="line">        _scrollViewOriginalInset = _scrollView.mj_inset;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 添加监听</span></span><br><span class="line">        [self addObservers];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>willMoveToSuperview 中会先移除对旧父控件的关键事件监听，监听新的父UIScollView的关键事件，并记录下UIScrollView最开始的contentInset。</p>
<p>addObservers 方法中主要通过KVO方式让MJRefreshComponent监听父控件scrollView的ContentOffset，ContentSize 以及<br>scrollView的手势状态。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)addObservers &#123;</span><br><span class="line">    <span class="built_in">NSKeyValueObservingOptions</span> options = <span class="built_in">NSKeyValueObservingOptionNew</span> | <span class="built_in">NSKeyValueObservingOptionOld</span>;</span><br><span class="line">    [<span class="keyword">self</span>.scrollView addObserver:<span class="keyword">self</span> forKeyPath:MJRefreshKeyPathContentOffset options:options context:<span class="literal">nil</span>];</span><br><span class="line">    [<span class="keyword">self</span>.scrollView addObserver:<span class="keyword">self</span> forKeyPath:MJRefreshKeyPathContentSize options:options context:<span class="literal">nil</span>];</span><br><span class="line">    <span class="keyword">self</span>.pan = <span class="keyword">self</span>.scrollView.panGestureRecognizer;</span><br><span class="line">    [<span class="keyword">self</span>.pan addObserver:<span class="keyword">self</span> forKeyPath:MJRefreshKeyPathPanState options:options context:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一旦监听的变量发生变化那么就会到observeValueForKeyPath中进行处理：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="type">id</span>)object change:(<span class="built_in">NSDictionary</span> *)change context:(<span class="type">void</span> *)context &#123;</span><br><span class="line">    <span class="comment">// 遇到这些情况就直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>.userInteractionEnabled) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这个就算看不见也需要处理</span></span><br><span class="line">    <span class="keyword">if</span> ([keyPath isEqualToString:MJRefreshKeyPathContentSize]) &#123;</span><br><span class="line">        [<span class="keyword">self</span> scrollViewContentSizeDidChange:change];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 看不见</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.hidden) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> ([keyPath isEqualToString:MJRefreshKeyPathContentOffset]) &#123;</span><br><span class="line">        [<span class="keyword">self</span> scrollViewContentOffsetDidChange:change];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([keyPath isEqualToString:MJRefreshKeyPathPanState]) &#123;</span><br><span class="line">        [<span class="keyword">self</span> scrollViewPanStateDidChange:change];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)scrollViewContentOffsetDidChange:(<span class="built_in">NSDictionary</span> *)change&#123;&#125;</span><br><span class="line">- (<span class="type">void</span>)scrollViewContentSizeDidChange:(<span class="built_in">NSDictionary</span> *)change&#123;&#125;</span><br><span class="line">- (<span class="type">void</span>)scrollViewPanStateDidChange:(<span class="built_in">NSDictionary</span> *)change&#123;&#125;</span><br><span class="line"></span><br><span class="line">````</span><br><span class="line"></span><br><span class="line">其中ContentOffset 以及scrollView的手势状态 只有在可见的时候才会触发子类对应的方法。</span><br><span class="line"></span><br><span class="line">****<span class="number">3.</span> 状态的管理：****</span><br><span class="line"></span><br><span class="line">MJRefreshComponent 中的setState主要是提供给子类设置的，但是在MJRefreshComponent中的beginRefreshing以及endRefreshing也会触发MJRefresh的状态，beginRefreshing会将状态设置为MJRefreshStateRefreshing，endRefreshing中会将状态设置为MJRefreshStateIdle。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><p>(void)beginRefreshing {<br>  [UIView animateWithDuration:MJRefreshFastAnimationDuration animations:^{<br>  self.alpha &#x3D; 1.0;<br>  }];<br>  self.pullingPercent &#x3D; 1.0;<br>  &#x2F;&#x2F; 只要正在刷新，就完全显示<br>  if (self.window) {<br>  self.state &#x3D; MJRefreshStateRefreshing;<br>  } else {<br>  &#x2F;&#x2F;…..<br>  }<br>}</p>
</li>
<li><p>(void)endRefreshing {<br>  MJRefreshDispatchAsyncOnMainQueue(self.state &#x3D; MJRefreshStateIdle;)<br>}</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="strong">****</span>4. 下拉进度的管理：<span class="strong">****</span></span><br><span class="line"></span><br><span class="line">和setState一样下拉进度也是受contentOffset影响的，所以下拉进度的设置也是提供给子类调用的。下拉进度的改变会导致下拉控件透明度的同步变化。</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>(void)setPullingPercent:(CGFloat)pullingPercent {<br>  _pullingPercent &#x3D; pullingPercent;<br>  if (self.isRefreshing) return;<br>  if (self.isAutomaticallyChangeAlpha) {<br>  self.alpha &#x3D; pullingPercent;<br>  }<br>}</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="strong">****</span>MJRefreshStateHeader<span class="strong">****</span></span><br><span class="line"></span><br><span class="line">MJRefreshComponent像是一个没有灵魂的父类，它只负责监听scrollView的contentOffset，contentSize，以及触摸状态的变化，将这些变化传递给子类。</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>(void)scrollViewContentOffsetDidChange:(NSDictionary *)change {</p>
<p>  [super scrollViewContentOffsetDidChange:change];<br>  &#x2F;&#x2F; 在刷新的refreshing状态<br>  if (self.state &#x3D;&#x3D; MJRefreshStateRefreshing) {<br>  [self resetInset];<br>  return;<br>  }<br>  &#x2F;&#x2F; 跳转到下一个控制器时，contentInset可能会变, 这时候将最初的contentInset保存在_scrollViewOriginalInset<br>  _scrollViewOriginalInset &#x3D; self.scrollView.mj_inset;</p>
<p>  &#x2F;&#x2F; 当前的contentOffset<br>  CGFloat offsetY &#x3D; self.scrollView.mj_offsetY;<br>  &#x2F;&#x2F; 头部控件刚好出现的offsetY，这里由于UIScrollView默认是贴着可见的边缘，也就是导航栏的底部。所以可以用- self.scrollViewOriginalInset.top来表示。<br>  CGFloat happenOffsetY &#x3D; - self.scrollViewOriginalInset.top;</p>
<p>  &#x2F;&#x2F; 如果是向上滚动到看不见头部控件，直接返回<br>  &#x2F;&#x2F; &gt;&#x3D; -&gt; &gt;<br>  if (offsetY &gt; happenOffsetY) return;</p>
<p>  &#x2F;&#x2F; 普通 和 即将刷新 的临界点，normal2pullingOffsetY 表示MJRefreshHeader完全露出来的位置<br>  CGFloat normal2pullingOffsetY &#x3D; happenOffsetY - self.mj_h;<br>  &#x2F;&#x2F; 这个是MJRefreshHeader露出来的百分比<br>  CGFloat pullingPercent &#x3D; (happenOffsetY - offsetY) &#x2F; self.mj_h;</p>
<p>  if (self.scrollView.isDragging) { &#x2F;&#x2F; 如果正在拖拽<br>  self.pullingPercent &#x3D; pullingPercent;<br>  &#x2F;&#x2F; 如果当前是空闲状态，并且偏移量超过了完全露出来的距离，但是由于当前正在处于拖拽状态则状态还是MJRefreshStatePulling<br>  if (self.state &#x3D;&#x3D; MJRefreshStateIdle &amp;&amp; offsetY &lt; normal2pullingOffsetY) {<br>      &#x2F;&#x2F; 转为即将刷新状态<br>      self.state &#x3D; MJRefreshStatePulling;<br>  &#x2F;&#x2F;如果当前处于MJRefreshStatePulling状态，偏移量小于完全露出来的距离，那么状态改为MJRefreshStateIdle<br>  } else if (self.state &#x3D;&#x3D; MJRefreshStatePulling &amp;&amp; offsetY &gt;&#x3D; normal2pullingOffsetY) {<br>      &#x2F;&#x2F; 转为普通状态<br>      self.state &#x3D; MJRefreshStateIdle;<br>  }<br>  &#x2F;&#x2F;如果松收那么就切换到MJRefreshStateRefreshing状态<br>  } else if (self.state &#x3D;&#x3D; MJRefreshStatePulling) {&#x2F;&#x2F; 即将刷新 &amp;&amp; 手松开<br>  &#x2F;&#x2F; 开始刷新<br>  [self beginRefreshing];<br>  } else if (pullingPercent &lt; 1) {<br>  self.pullingPercent &#x3D; pullingPercent;<br>  }</p>
</li>
</ul>
<p>}</p>
<figure class="highlight pf"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">scrollViewContentOffsetDidChange 主要负责设置MJRefreshHeader的<span class="keyword">state</span>。影响到<span class="keyword">state</span>的有两方面原因：</span><br></pre></td></tr></table></figure>
<ol>
<li>是否处于拖拽状态</li>
<li>当前UIScrollView的offset与下拉头完全露出来的位置的关系<figure class="highlight erlang"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">如果当前是空闲状态，并且偏移量超过了下拉头部完全露出来的距离，但是由于当前正在处于拖拽状态则状态还是MJRefreshStatePulling，在处于拖拽状态下，如果当前处于MJRefreshStatePulling状态，偏移量小于完全露出来的距离，那么状态改为MJRefreshStateIdle。如果松手那么就切换到MJRefreshStateRefreshing状态。并触发<span class="keyword">begin</span>Refreshing调用上层业务进行刷新。</span><br><span class="line"></span><br><span class="line">下面我们来看下状态的设置：</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>(void)setState:(MJRefreshState)state {<br>  MJRefreshCheckState<br>  &#x2F;&#x2F; 根据状态做事情<br>  if (state &#x3D;&#x3D; MJRefreshStateIdle) {<br>  if (oldState !&#x3D; MJRefreshStateRefreshing) return;<br><br>  &#x2F;&#x2F; 保存刷新时间<br>  [[NSUserDefaults standardUserDefaults] setObject:[NSDate date] forKey:self.lastUpdatedTimeKey];<br>  [[NSUserDefaults standardUserDefaults] synchronize];<br><br>  &#x2F;&#x2F; 恢复inset和offset<br>  [UIView animateWithDuration:MJRefreshSlowAnimationDuration animations:^{<br>      self.scrollView.mj_insetT +&#x3D; self.insetTDelta;<br>      if (self.endRefreshingAnimateCompletionBlock) {<br>          self.endRefreshingAnimateCompletionBlock();<br>      }<br>      &#x2F;&#x2F; 自动调整透明度<br>      if (self.isAutomaticallyChangeAlpha) self.alpha &#x3D; 0.0;<br>  } completion:^(BOOL finished) {<br>      self.pullingPercent &#x3D; 0.0;<br>      if (self.endRefreshingCompletionBlock) {<br>          self.endRefreshingCompletionBlock();<br>      }<br>  }];<br>  } else if (state &#x3D;&#x3D; MJRefreshStateRefreshing) {<br>  MJRefreshDispatchAsyncOnMainQueue({<br>      [UIView animateWithDuration:MJRefreshFastAnimationDuration animations:^{<br>          if (self.scrollView.panGestureRecognizer.state !&#x3D; UIGestureRecognizerStateCancelled) {<br>              CGFloat top &#x3D; self.scrollViewOriginalInset.top + self.mj_h;<br>              &#x2F;&#x2F; 增加滚动区域top<br>              self.scrollView.mj_insetT &#x3D; top;<br>              &#x2F;&#x2F; 设置滚动位置<br>              CGPoint offset &#x3D; self.scrollView.contentOffset;<br>              offset.y &#x3D; -top;<br>              [self.scrollView setContentOffset:offset animated:NO];<br>          }<br>      } completion:^(BOOL finished) {<br>          [self executeRefreshingCallback];<br>      }];<br>  })<br>  }</li>
</ul>
<p>}</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">如果上一次为MJRefreshStateRefreshing，当前状态为MJRefreshStateIdle，表示一次刷新结束。这时候会将当前时间记录为上一次刷新时间记录在本地。并且以动画的形式将header隐藏，并在动画结束以及完全隐藏的时候调用<span class="strong">****</span>endRefreshingAnimateCompletionBlock<span class="strong">****</span>，<span class="strong">****</span>endRefreshingCompletionBlock<span class="strong">****</span>，如果状态要设置为MJRefreshStateRefreshing，那么需要通过setContentOffset将头部显示出来。并在完成后调用executeRefreshingCallback。</span><br><span class="line"></span><br><span class="line">也就是说在进入refreshing状态的时候会调用refreshingBlock以及beginRefreshingCompletionBlock，在回到idle状态的时候会调用endRefreshingAnimateCompletionBlock以及endRefreshingCompletionBlock。</span><br><span class="line"></span><br><span class="line"><span class="strong">****</span>MJRefreshAutoFooter<span class="strong">****</span></span><br><span class="line"></span><br><span class="line">我们看到MJRefreshFooter有两类MJRefreshAutoFooter以及MJRefreshBackFooter，MJRefreshAutoFooter的特点是在内容超过一个屏幕的时候，不松手的情况下只要footer露出来了就会自动启动刷新，这会持续autoTriggerTimes次，当然我们可以设置autoTriggerTimes为负数来支持无限次自动加载。在松手的情况下则会在指定的条件下触发刷新。</span><br><span class="line">MJRefreshBackFooter的footer只会出现在UIScrollView的底部，并且只有在松手的情况下才会启动刷新。</span><br><span class="line"></span><br><span class="line">我们先来看下MJRefreshAutoFooter，在新建MJRefreshAutoFooter的时候会先调用prepare方法：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><p>(void)prepare {<br>  [super prepare];<br>  &#x2F;&#x2F; 默认底部控件100%出现时才会自动刷新<br>  self.triggerAutomaticallyRefreshPercent &#x3D; 1.0;<br>  &#x2F;&#x2F; 设置为默认状态<br>  self.automaticallyRefresh &#x3D; YES;<br>  &#x2F;&#x2F; 自动刷新的次数<br>  self.autoTriggerTimes &#x3D; 1;<br>}</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">在prepare方法中设置了触发自动刷新的百分比，以及将触发状态设置为自动刷新状态，<span class="built_in">auto</span>TriggerTimes被设置为<span class="number">1</span>次。<span class="built_in">auto</span>TriggerTimes是上拉不松手的情况下触发自动刷新的次数超过这个次数，上拉只有松手的情况下才会触发刷新，如果要自动刷新次数不受限那么将<span class="built_in">auto</span>TriggerTimes设置为<span class="number">-1</span>即可。</span><br><span class="line"></span><br><span class="line">创建好后在我们将MJRefreshAutoFooter添加到UIScrollView上面的时候会调用willMoveToSuperview，这时候ContentInset Bottom会相应地增加mj_h，如果newSuperview = nil 表示从父控件中移除，ContentInset Bottom会减少mj_h。</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>(void)willMoveToSuperview:(UIView *)newSuperview {<br>  [super willMoveToSuperview:newSuperview];<br>  if (newSuperview) { &#x2F;&#x2F; 新的父控件<br>  if (self.hidden &#x3D;&#x3D; NO) {<br>      self.scrollView.mj_insetB +&#x3D; self.mj_h;<br>  }<br>  &#x2F;&#x2F; 设置位置<br>  self.mj_y &#x3D; _scrollView.mj_contentH;<br>  } else { &#x2F;&#x2F; 被移除了<br>  if (self.hidden &#x3D;&#x3D; NO) {<br>      self.scrollView.mj_insetB -&#x3D; self.mj_h;<br>  }<br>  }<br>}</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">mj_h是在MJRefreshFooter prepare方法中设置的。</span><br><span class="line"></span><br><span class="line">一旦<span class="built_in">UIScrollView</span>完成数据的加载就会触发ContentSize发生变化，scrollViewContentSizeDidChange会被调用，这时候MJRefreshAutoFooter的位置就会重新被设置，它会被追加到<span class="built_in">UIScrollView</span> 内容的最底部，注意不是<span class="built_in">UIScrollView</span>的最底部。</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>(void)scrollViewContentSizeDidChange:(NSDictionary *)change {<br>  [super scrollViewContentSizeDidChange:change];<br>  &#x2F;&#x2F; 设置位置<br>  self.mj_y &#x3D; self.scrollView.mj_contentH + self.ignoredScrollViewContentInsetBottom;<br>}</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">在内容超过一个屏幕后，如果我们向上拉页面，拉到<span class="selector-tag">footer</span>显示出triggerAutomaticallyRefreshPercent百分比后即使我们不松手的情况下也会自动触发beginRefreshing进行刷新。</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>(void)scrollViewContentOffsetDidChange:(NSDictionary *)change {<br>  [super scrollViewContentOffsetDidChange:change];</p>
<p>  if (self.state !&#x3D; MJRefreshStateIdle || !self.automaticallyRefresh || self.mj_y &#x3D;&#x3D; 0) return;</p>
<p>  if (_scrollView.mj_insetT + _scrollView.mj_contentH &gt; _scrollView.mj_h) { &#x2F;&#x2F; 内容超过一个屏幕<br>  &#x2F;&#x2F; 这里的_scrollView.mj_contentH替换掉self.mj_y更为合理<br>  if (_scrollView.mj_offsetY &gt;&#x3D; _scrollView.mj_contentH - _scrollView.mj_h + self.mj_h * self.triggerAutomaticallyRefreshPercent + _scrollView.mj_insetB - self.mj_h) {<br>      &#x2F;&#x2F; 防止手松开时连续调用<br>      CGPoint old &#x3D; [change[@”old”] CGPointValue];<br>      CGPoint new &#x3D; [change[@”new”] CGPointValue];<br>      if (new.y &lt;&#x3D; old.y) return;<br><br>      if (_scrollView.isDragging) {<br>          self.triggerByDrag &#x3D; YES;<br>      }<br>      &#x2F;&#x2F; 当底部刷新控件完全出现时，才刷新<br>      [self beginRefreshing];<br>  }<br>  }</p>
</li>
</ul>
<p>}</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">如果我们手松开的时候,如果不够一个屏幕，那么在拉到offsetY超过顶部insetTop的时候开始刷新，如果超出一个屏幕，也会在拉到见到<span class="selector-tag">footer</span>的时候开始刷新。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><p>(void)scrollViewPanStateDidChange:(NSDictionary *)change {<br>  [super scrollViewPanStateDidChange:change];<br>  if (self.state !&#x3D; MJRefreshStateIdle) return;<br>  UIGestureRecognizerState panState &#x3D; _scrollView.panGestureRecognizer.state;<br>  switch (panState) {<br>  &#x2F;&#x2F; 手松开<br>  case UIGestureRecognizerStateEnded: {<br>      if (_scrollView.mj_insetT + _scrollView.mj_contentH &lt;&#x3D; _scrollView.mj_h) {  &#x2F;&#x2F; 不够一个屏幕<br>          if (_scrollView.mj_offsetY &gt;&#x3D; - _scrollView.mj_insetT) { &#x2F;&#x2F; 向上拽<br>              self.triggerByDrag &#x3D; YES;<br>              [self beginRefreshing];<br>          }<br>      } else { &#x2F;&#x2F; 超出一个屏幕<br>          if (_scrollView.mj_offsetY &gt;&#x3D; _scrollView.mj_contentH + _scrollView.mj_insetB - _scrollView.mj_h) {<br>              self.triggerByDrag &#x3D; YES;<br>              [self beginRefreshing];<br>          }<br>      }<br>  } break;<br>  case UIGestureRecognizerStateBegan: {<br>      [self resetTriggerTimes];<br>  } break;<br>  default: break;<br>  }<br>}</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">状态设置：</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>(void)setState:(MJRefreshState)state {<br>  MJRefreshCheckState</p>
<p>  if (state &#x3D;&#x3D; MJRefreshStateRefreshing) {<br>  [self executeRefreshingCallback];<br>  } else if (state &#x3D;&#x3D; MJRefreshStateNoMoreData || state &#x3D;&#x3D; MJRefreshStateIdle) {<br>  if (self.triggerByDrag) {<br>      if (!self.unlimitedTrigger) {<br>          self.leftTriggerTimes -&#x3D; 1;<br>      }<br>      self.triggerByDrag &#x3D; NO;<br>  }<br>  if (MJRefreshStateRefreshing &#x3D;&#x3D; oldState) {<br>      if (self.scrollView.pagingEnabled) {<br>          CGPoint offset &#x3D; self.scrollView.contentOffset;<br>          offset.y -&#x3D; self.scrollView.mj_insetB;<br>          [UIView animateWithDuration:MJRefreshSlowAnimationDuration animations:^{<br>              self.scrollView.contentOffset &#x3D; offset;<br>              if (self.endRefreshingAnimateCompletionBlock) {<br>                  self.endRefreshingAnimateCompletionBlock();<br>              }<br>          } completion:^(BOOL finished) {<br>              if (self.endRefreshingCompletionBlock) {<br>                  self.endRefreshingCompletionBlock();<br>              }<br>          }];<br>          return;<br>      }<br>      if (self.endRefreshingCompletionBlock) {<br>          self.endRefreshingCompletionBlock();<br>      }<br>  }<br>  }</p>
</li>
</ul>
<p>}</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="strong">****</span>MJRefreshBackFooter<span class="strong">****</span></span><br><span class="line"></span><br><span class="line">MJRefreshBackFooter 和 MJRefreshAutoFooter不同的是它会永远出现在UIScrollView的最底部，为啥？我们看下代码：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><p>(void)scrollViewContentSizeDidChange:(NSDictionary *)change {<br>  [super scrollViewContentSizeDidChange:change];<br>  &#x2F;&#x2F; 内容的高度<br>  CGFloat contentHeight &#x3D; self.scrollView.mj_contentH + self.ignoredScrollViewContentInsetBottom;<br>  &#x2F;&#x2F; 表格的高度<br>  CGFloat scrollHeight &#x3D; self.scrollView.mj_h - self.scrollViewOriginalInset.top - self.scrollViewOriginalInset.bottom + self.ignoredScrollViewContentInsetBottom;<br>  &#x2F;&#x2F; 设置位置和尺寸<br>  self.mj_y &#x3D; MAX(contentHeight, scrollHeight);<br>}</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">在内容高度大于<span class="built_in">UIScrollView</span>的时候，它会追加在内容最后面，这时候MJRefreshBackFooter也是在<span class="built_in">UIScrollView</span>的外面，在滑到<span class="built_in">UIScrollView</span>的时候开始加载。如果<span class="built_in">UIScrollView</span>的高度大于内容高度，那么它会被加在<span class="built_in">UIScrollView</span>最底部。</span><br><span class="line"></span><br><span class="line">我们接下来看下MJRefreshBackFooter的状态变化：</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>(void)scrollViewContentOffsetDidChange:(NSDictionary *)change {<br>  [super scrollViewContentOffsetDidChange:change];</p>
<p>  &#x2F;&#x2F; 如果正在刷新，直接返回<br>  if (self.state &#x3D;&#x3D; MJRefreshStateRefreshing) return;</p>
<p>  _scrollViewOriginalInset &#x3D; self.scrollView.mj_inset;</p>
<p>  &#x2F;&#x2F; 当前的contentOffset<br>  CGFloat currentOffsetY &#x3D; self.scrollView.mj_offsetY;<br>  &#x2F;&#x2F; 尾部控件刚好出现的offsetY<br>  CGFloat happenOffsetY &#x3D; [self happenOffsetY];<br>  &#x2F;&#x2F; 如果是向下滚动到看不见尾部控件，直接返回<br>  if (currentOffsetY &lt;&#x3D; happenOffsetY) return;</p>
<p>  CGFloat pullingPercent &#x3D; (currentOffsetY - happenOffsetY) &#x2F; self.mj_h;</p>
<p>  &#x2F;&#x2F; 如果已全部加载，仅设置pullingPercent，然后返回<br>  if (self.state &#x3D;&#x3D; MJRefreshStateNoMoreData) {<br>  self.pullingPercent &#x3D; pullingPercent;<br>  return;<br>  }</p>
<p>  if (self.scrollView.isDragging) {<br>  self.pullingPercent &#x3D; pullingPercent;<br>  &#x2F;&#x2F; 普通 和 即将刷新 的临界点<br>  CGFloat normal2pullingOffsetY &#x3D; happenOffsetY + self.mj_h;<br><br>  if (self.state &#x3D;&#x3D; MJRefreshStateIdle &amp;&amp; currentOffsetY &gt; normal2pullingOffsetY) {<br>      &#x2F;&#x2F; 转为即将刷新状态<br>      self.state &#x3D; MJRefreshStatePulling;<br>  } else if (self.state &#x3D;&#x3D; MJRefreshStatePulling &amp;&amp; currentOffsetY &lt;&#x3D; normal2pullingOffsetY) {<br>      &#x2F;&#x2F; 转为普通状态<br>      self.state &#x3D; MJRefreshStateIdle;<br>  }<br>  } else if (self.state &#x3D;&#x3D; MJRefreshStatePulling) {&#x2F;&#x2F; 即将刷新 &amp;&amp; 手松开<br>  &#x2F;&#x2F; 开始刷新<br>  [self beginRefreshing];<br>  } else if (pullingPercent &lt; 1) {<br>  self.pullingPercent &#x3D; pullingPercent;<br>  }</p>
</li>
</ul>
<p>}</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">这里有两个比较关键的offset:</span><br><span class="line"></span><br><span class="line"><span class="strong">****</span>happenOffsetY<span class="strong">****</span>: 它是MJRefreshBackFooter刚好露出来时候UIScrollView的ContentOffset.</span><br><span class="line"><span class="strong">****</span>normal2pullingOffsetY<span class="strong">****</span>: 它是MJRefreshBackFooter完全露出来时候UIScrollView的ContentOffset.</span><br><span class="line"></span><br><span class="line">所以 currentOffsetY但凡大于happenOffsetY就表示MJRefreshBackFooter已经露出来了，这时候，如果scrollView处于拖拽状态，并且currentOffsetY &gt; normal2pullingOffsetY 表示整个MJRefreshBackFooter已经完全露出来了，这时候会切换到MJRefreshStatePulling状态，如果currentOffsetY &lt;= normal2pullingOffsetY那么当前状态为MJRefreshStateIdle。如果处于MJRefreshStatePulling状态，也就是MJRefreshBackFooter已经完全露出来的情况下，松手的话就会触发刷新。</span><br><span class="line"></span><br><span class="line">下面是状态改变的过程：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>(void)setState:(MJRefreshState)state {<br>  MJRefreshCheckState<br>  &#x2F;&#x2F; 根据状态来设置属性<br>  if (state &#x3D;&#x3D; MJRefreshStateNoMoreData || state &#x3D;&#x3D; MJRefreshStateIdle) {<br>  &#x2F;&#x2F; 刷新完毕<br>  if (MJRefreshStateRefreshing &#x3D;&#x3D; oldState) {<br>      [UIView animateWithDuration:MJRefreshSlowAnimationDuration animations:^{<br>          self.scrollView.mj_insetB -&#x3D; self.lastBottomDelta;<br>          if (self.endRefreshingAnimateCompletionBlock) {<br>              self.endRefreshingAnimateCompletionBlock();<br>          }<br>          &#x2F;&#x2F; 自动调整透明度<br>          if (self.isAutomaticallyChangeAlpha) self.alpha &#x3D; 0.0;<br>      } completion:^(BOOL finished) {<br>          self.pullingPercent &#x3D; 0.0;<br>          if (self.endRefreshingCompletionBlock) {<br>              self.endRefreshingCompletionBlock();<br>          }<br>      }];<br>  }<br>  CGFloat deltaH &#x3D; [self heightForContentBreakView];<br>  &#x2F;&#x2F; 刚刷新完毕<br>  if (MJRefreshStateRefreshing &#x3D;&#x3D; oldState &amp;&amp; deltaH &gt; 0 &amp;&amp; self.scrollView.mj_totalDataCount !&#x3D; self.lastRefreshCount) {<br>      self.scrollView.mj_offsetY &#x3D; self.scrollView.mj_offsetY;<br>  }<br>  } else if (state &#x3D;&#x3D; MJRefreshStateRefreshing) {<br>  &#x2F;&#x2F; 记录刷新前的数量<br>  self.lastRefreshCount &#x3D; self.scrollView.mj_totalDataCount;<br>  [UIView animateWithDuration:MJRefreshFastAnimationDuration animations:^{<br>      CGFloat bottom &#x3D; self.mj_h + self.scrollViewOriginalInset.bottom;<br>      CGFloat deltaH &#x3D; [self heightForContentBreakView];<br>      if (deltaH &lt; 0) { &#x2F;&#x2F; 如果内容高度小于view的高度<br>          bottom -&#x3D; deltaH;<br>      }<br>      self.lastBottomDelta &#x3D; bottom - self.scrollView.mj_insetB;<br>      self.scrollView.mj_insetB &#x3D; bottom;<br>      self.scrollView.mj_offsetY &#x3D; [self happenOffsetY] + self.mj_h;<br>  } completion:^(BOOL finished) {<br>      [self executeRefreshingCallback];<br>  }];<br>  }<br>}<br>&#96;&#96;&#96;</li>
</ul>
<p>MJRefresh最核心的部分代码已经介绍完毕了，后续的一些，比如包含State的Header以及Footer 都是用于处理与状态文本相关的类，包含Normal的Header以及Footer都是用于处理箭头和菊花状态的类，而包含Gif的Header以及Footer都是用于处理Gif动画的类，这些类都是基于state, pullingPercent 这些关键属性的变化而改变的，所以理解上面介绍的如何根据Content Offset 变化 确定state以及pullingPercent是理解MJRefresh的核心。</p>
  
	</div>
		<footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/iOS-%E5%BC%80%E6%BA%90%E5%BA%93%E5%88%86%E6%9E%90/">iOS 开源库分析</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/iOS-开源库分析/">iOS 开源库分析</a>
  </div>

</div>



</footer>

   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2019/12/08/IGKListKit-使用及源码分析/" title="IGKListKit 使用及源码分析">
  <span>
  IGKListKit 使用及源码分析</span>
</a>
</div>


<div class="next">
<a href="/2019/12/05/Tencent-Mars-源码解析/"  title="Tencent Mars 源码解析">
 <span>Tencent Mars 源码解析
</span>
</a>
</div>

</nav>

	
<section id="comments" class="comment">
	<div class="ds-thread" data-thread-key="2019/12/06/MJRefresh-使用及源码分析/" data-title="MJRefresh 使用及源码分析" data-url="http://yoursite.com/2019/12/06/MJRefresh-%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"></div>
</section>


<section id="comments" class="comment">
  <div id="disqus_thread">
    <noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  </div>
</section>

</div>  
      <div class="openaside"><a class="navbutton" href="#" title="Show Sidebar"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">Contents</strong>
 
 <ol class="toc"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%80%E6%BA%90%E5%BA%93%E4%BF%A1%E6%81%AF%EF%BC%9A"><span class="toc-number">1.</span> <span class="toc-text">开源库信息：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90"><span class="toc-number">2.</span> <span class="toc-text">源码解析</span></a></li></ol>
 
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="Hide Sidebar"></a></div>
<aside class="clearfix">
<div id="authorInfo">
	
		<div class="author-img"></div>		
	
	<div class="social-info" class="clearfix">
		
		
		<a href="https://github.com/tbfungeek" target="_blank" class="icon-github" title="github"></a>
		
		
		
		
		
		
		
		
		
		
		<a href="mailto:tbfungeek@163.com" target="_blank" class="icon-email" title="Email Me"></a>
		

	</div>
</div>

  
<div class="categorieslist">
	<p class="asidetitle">Categories</p>
		<ul>
		
		  
			<li><a href="/categories/Android-小经验/" title="Android 小经验">Android 小经验<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Android-源码分析/" title="Android 源码分析">Android 源码分析<sup>21</sup></a></li>
		  
		
		  
			<li><a href="/categories/Android其他/" title="Android其他">Android其他<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Android初步/" title="Android初步">Android初步<sup>21</sup></a></li>
		  
		
		  
			<li><a href="/categories/Android进阶/" title="Android进阶">Android进阶<sup>100</sup></a></li>
		  
		
		  
			<li><a href="/categories/Hexo-使用/" title="Hexo 使用">Hexo 使用<sup>10</sup></a></li>
		  
		
		  
			<li><a href="/categories/JavaScript理论/" title="JavaScript理论">JavaScript理论<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Objective-C-相关/" title="Objective C 相关">Objective C 相关<sup>24</sup></a></li>
		  
		
		  
			<li><a href="/categories/OpenCV/" title="OpenCV">OpenCV<sup>6</sup></a></li>
		  
		
		  
			<li><a href="/categories/ROS/" title="ROS">ROS<sup>9</sup></a></li>
		  
		
		  
			<li><a href="/categories/iOS-工具使用/" title="iOS 工具使用">iOS 工具使用<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/iOS-开源库分析/" title="iOS 开源库分析">iOS 开源库分析<sup>36</sup></a></li>
		  
		
		  
			<li><a href="/categories/iOS-理论基础/" title="iOS 理论基础">iOS 理论基础<sup>14</sup></a></li>
		  
		
		  
			<li><a href="/categories/iOS-进阶/" title="iOS 进阶">iOS 进阶<sup>4</sup></a></li>
		  
		
		  
			<li><a href="/categories/个人收藏/" title="个人收藏">个人收藏<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/代码规范/" title="代码规范">代码规范<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/其他/" title="其他">其他<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/博客分类目录/" title="博客分类目录">博客分类目录<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/叨叨系列/" title="叨叨系列">叨叨系列<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/开源代码分析/" title="开源代码分析">开源代码分析<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/开源库分析/" title="开源库分析">开源库分析<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/树莓派/" title="树莓派">树莓派<sup>4</sup></a></li>
		  
		
		  
			<li><a href="/categories/版本控制/" title="版本控制">版本控制<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/直播/" title="直播">直播<sup>6</sup></a></li>
		  
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">Tags</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/iOS-开源库分析/" title="iOS 开源库分析">iOS 开源库分析<sup>36</sup></a></li>
			
		
			
				<li><a href="/tags/Android-设计模式/" title="Android 设计模式">Android 设计模式<sup>29</sup></a></li>
			
		
			
				<li><a href="/tags/Objective-C-相关/" title="Objective C 相关">Objective C 相关<sup>24</sup></a></li>
			
		
			
				<li><a href="/tags/Android基础/" title="Android基础">Android基础<sup>21</sup></a></li>
			
		
			
				<li><a href="/tags/AOSP-源码/" title="AOSP 源码">AOSP 源码<sup>17</sup></a></li>
			
		
			
				<li><a href="/tags/Android-常用第三方库/" title="Android 常用第三方库">Android 常用第三方库<sup>15</sup></a></li>
			
		
			
				<li><a href="/tags/iOS-理论基础/" title="iOS 理论基础">iOS 理论基础<sup>14</sup></a></li>
			
		
			
				<li><a href="/tags/Hexo-使用/" title="Hexo 使用">Hexo 使用<sup>10</sup></a></li>
			
		
			
				<li><a href="/tags/ROS/" title="ROS">ROS<sup>9</sup></a></li>
			
		
			
				<li><a href="/tags/Android-动画进阶/" title="Android 动画进阶">Android 动画进阶<sup>8</sup></a></li>
			
		
			
				<li><a href="/tags/Android-JNI/" title="Android JNI">Android JNI<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/Android-绘图进阶/" title="Android 绘图进阶">Android 绘图进阶<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/Android性能优化/" title="Android性能优化">Android性能优化<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/Android-自动化测试/" title="Android 自动化测试">Android 自动化测试<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/OpenCV/" title="OpenCV">OpenCV<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/直播/" title="直播">直播<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/Android-开源源码/" title="Android 开源源码">Android 开源源码<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/Android-自定义View进阶/" title="Android 自定义View进阶">Android 自定义View进阶<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/树莓派/" title="树莓派">树莓派<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/iOS-进阶/" title="iOS 进阶">iOS 进阶<sup>4</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">Links</p>
    <ul>
        
          <li>
            
            	<a href="https://hexo.io" target="_blank" title="Hexo">Hexo</a>
            
          </li>
        
          <li>
            
            	<a href="https://pages.github.com/" target="_blank" title="GitHub">GitHub</a>
            
          </li>
        
          <li>
            
            	<a href="http://pf18.github.io/" target="_blank" title="PF18">PF18</a>
            
          </li>
        
          <li>
            
            	<a href="http://toutiao.io/" target="_blank" title="开发者头条">开发者头条</a>
            
          </li>
        
          <li>
            
            	<a href="http://www.jcodecraeer.com/" target="_blank" title="泡在网上的日子">泡在网上的日子</a>
            
          </li>
        
    </ul>
</div>

  


  <div class="rsspart">
	<a href="atom.xml" target="_blank" title="rss">RSS</a>
</div>

  
  <div class="tagcloudlist">
    <p class="asidetitle">Tag Cloud</p>
    <div class="tagcloudlist clearfix">
       <a href="/tags/AOSP-%E6%BA%90%E7%A0%81/" style="font-size: 17.14px;">AOSP 源码</a> <a href="/tags/Android-APK-%E7%AD%BE%E5%90%8D/" style="font-size: 10px;">Android APK 签名</a> <a href="/tags/Android-JNI/" style="font-size: 12.86px;">Android JNI</a> <a href="/tags/Android-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E8%BF%9B%E9%98%B6/" style="font-size: 10.71px;">Android 事件处理进阶</a> <a href="/tags/Android-%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6/" style="font-size: 13.57px;">Android 动画进阶</a> <a href="/tags/Android-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%80%E5%8F%91/" style="font-size: 10px;">Android 多线程开发</a> <a href="/tags/Android-%E5%B0%8F%E7%BB%8F%E9%AA%8C/" style="font-size: 10px;">Android 小经验</a> <a href="/tags/Android-%E5%B8%B8%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/" style="font-size: 16.43px;">Android 常用第三方库</a> <a href="/tags/Android-%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/" style="font-size: 10px;">Android 开发流程</a> <a href="/tags/Android-%E5%BC%80%E6%BA%90%E6%BA%90%E7%A0%81/" style="font-size: 12.14px;">Android 开源源码</a> <a href="/tags/Android-%E7%BB%98%E5%9B%BE%E8%BF%9B%E9%98%B6/" style="font-size: 12.86px;">Android 绘图进阶</a> <a href="/tags/Android-%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/" style="font-size: 12.86px;">Android 自动化测试</a> <a href="/tags/Android-%E8%87%AA%E5%AE%9A%E4%B9%89View%E8%BF%9B%E9%98%B6/" style="font-size: 12.14px;">Android 自定义View进阶</a> <a href="/tags/Android-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 19.29px;">Android 设计模式</a> <a href="/tags/Android%E5%85%B6%E4%BB%96/" style="font-size: 10px;">Android其他</a> <a href="/tags/Android%E5%9F%BA%E7%A1%80/" style="font-size: 17.86px;">Android基础</a> <a href="/tags/Android%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/" style="font-size: 10px;">Android开发流程</a> <a href="/tags/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" style="font-size: 12.86px;">Android性能优化</a> <a href="/tags/Android%E6%B7%B7%E6%B7%86%E6%8A%80%E6%9C%AF/" style="font-size: 10px;">Android混淆技术</a> <a href="/tags/Android%E8%B4%A8%E9%87%8F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/" style="font-size: 11.43px;">Android质量管理工具</a> <a href="/tags/Android%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/" style="font-size: 10px;">Android逆向工程</a> <a href="/tags/Git-github/" style="font-size: 10px;">Git && github</a> <a href="/tags/Hexo-%E4%BD%BF%E7%94%A8/" style="font-size: 15px;">Hexo 使用</a> <a href="/tags/JavaScript/" style="font-size: 10px;">JavaScript</a> <a href="/tags/Linux-%E4%BD%BF%E7%94%A8/" style="font-size: 10px;">Linux 使用</a> <a href="/tags/Objective-C-%E7%9B%B8%E5%85%B3/" style="font-size: 18.57px;">Objective C 相关</a> <a href="/tags/OpenCV/" style="font-size: 12.86px;">OpenCV</a> <a href="/tags/ROS/" style="font-size: 14.29px;">ROS</a> <a href="/tags/iOS-%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/" style="font-size: 10.71px;">iOS 工具使用</a> <a href="/tags/iOS-%E5%BC%80%E6%BA%90%E5%BA%93%E5%88%86%E6%9E%90/" style="font-size: 20px;">iOS 开源库分析</a> <a href="/tags/iOS-%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/" style="font-size: 15.71px;">iOS 理论基础</a> <a href="/tags/iOS-%E8%BF%9B%E9%98%B6/" style="font-size: 12.14px;">iOS 进阶</a> <a href="/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/" style="font-size: 10px;">代码规范</a> <a href="/tags/%E5%8D%9A%E5%AE%A2%E5%88%86%E7%B1%BB%E7%9B%AE%E5%BD%95/" style="font-size: 10.71px;">博客分类目录</a> <a href="/tags/%E5%8F%A8%E5%8F%A8%E7%B3%BB%E5%88%97/" style="font-size: 10px;">叨叨系列</a> <a href="/tags/%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/" style="font-size: 11.43px;">工具的使用</a> <a href="/tags/%E5%BC%80%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/" style="font-size: 10.71px;">开源代码分析</a> <a href="/tags/%E5%BC%80%E6%BA%90%E5%BA%93%E5%88%86%E6%9E%90/" style="font-size: 10px;">开源库分析</a> <a href="/tags/%E6%9D%82%E7%B1%BB/" style="font-size: 10px;">杂类</a> <a href="/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/" style="font-size: 12.14px;">树莓派</a> <a href="/tags/%E7%9B%B4%E6%92%AD/" style="font-size: 12.86px;">直播</a> <a href="/tags/%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/" style="font-size: 10.71px;">编程技巧</a> <a href="/tags/%E7%BD%91%E7%AB%99%E6%94%B6%E8%97%8F/" style="font-size: 10px;">网站收藏</a> <a href="/tags/%E9%87%8D%E8%A6%81%E6%8E%A7%E4%BB%B6/" style="font-size: 11.43px;">重要控件</a>
    </div>
  </div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
		
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/hsihohuang/kiddochan" target="_blank" title="Kiddochan">Kiddochan</a> © 2022 
		
		<a href="/about" target="_blank" title="Edgar">Edgar</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
        getSize();
        if (myWidth >= 1024) {
          c.click();
        }
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  c.click(function(){
    ta.css('display', 'block').addClass('fadeIn');
  });
  o.click(function(){
    ta.css('display', 'none');
  });
  $(window).scroll(function(){
    ta.css("top",Math.max(140,320-$(this).scrollTop()));
  });
});
</script>




<script type="text/javascript">
  var duoshuoQuery = {short_name:"tbfungeek"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script> 


<script type="text/javascript">

var disqus_shortname = 'tbfungeek';

(function(){
  var dsq = document.createElement('script');
  dsq.type = 'text/javascript';
  dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
}());
(function(){
  var dsq = document.createElement('script');
  dsq.type = 'text/javascript';
  dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/count.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
}());
</script>






<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?7c9443b0374f1cf6b1dbb5ab84d939cb";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="Back to Top"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
</html>
