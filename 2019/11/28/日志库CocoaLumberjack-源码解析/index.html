
 <!DOCTYPE HTML>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
  
    <title>日志库CocoaLumberjack 源码解析 | Edgar&#39;s Blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="Edgar">
    

    
    <meta name="description" content="开源库信息CocoaLumberjack 架构概览  1. DDLog 上面是CocoaLumberjack的架构图，从整体来看主要由DDLog这个是总的入口，用于管理DDLogger,下面是DDLog的一些关键方法与属性： @property (class, nonatomic, copy, readonly) NSArray&lt;id&lt;DDLogger&gt;&gt; *allLogg">
<meta property="og:type" content="article">
<meta property="og:title" content="日志库CocoaLumberjack 源码解析">
<meta property="og:url" content="http://yoursite.com/2019/11/28/%E6%97%A5%E5%BF%97%E5%BA%93CocoaLumberjack-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/index.html">
<meta property="og:site_name" content="Edgar&#39;s Blog">
<meta property="og:description" content="开源库信息CocoaLumberjack 架构概览  1. DDLog 上面是CocoaLumberjack的架构图，从整体来看主要由DDLog这个是总的入口，用于管理DDLogger,下面是DDLog的一些关键方法与属性： @property (class, nonatomic, copy, readonly) NSArray&lt;id&lt;DDLogger&gt;&gt; *allLogg">
<meta property="og:locale">
<meta property="og:image" content="http://yoursite.com/2019/11/28/%E6%97%A5%E5%BF%97%E5%BA%93CocoaLumberjack-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/00001.png">
<meta property="article:published_time" content="2019-11-27T18:10:21.000Z">
<meta property="article:modified_time" content="2019-12-19T13:31:22.000Z">
<meta property="article:author" content="Edgar">
<meta property="article:tag" content="iOS 开源库分析">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/2019/11/28/%E6%97%A5%E5%BF%97%E5%BA%93CocoaLumberjack-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/00001.png">

    
    <link rel="alternative" href="atom.xml" title="Edgar&#39;s Blog" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/unnamed4_n_mSY_icon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/profile.png">
    <link rel="apple-touch-icon-precomposed" href="/img/profile.png">
    
    
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 6.2.0"></head>

  <body>
    <header>
      
<div>
		
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="Edgar&#39;s Blog">Edgar&#39;s Blog</a></h1>
				<h2 class="blog-motto"></h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="Menu">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
					<li>
 					
					<form class="search" action="/search/index.html" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" autocomplete="off" name="q" maxlength="20" placeholder="Search" />
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
  
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/11/28/日志库CocoaLumberjack-源码解析/" title="日志库CocoaLumberjack 源码解析" itemprop="url">日志库CocoaLumberjack 源码解析</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Edgar" target="_blank" itemprop="author">Edgar</a>
		
  <p class="article-time">
    <time datetime="2019-11-27T18:10:21.000Z" itemprop="datePublished"> Published 2019-11-28</time>
    
  </p>
</header>
	<div class="article-content">
		
		<h5 id="开源库信息"><a href="#开源库信息" class="headerlink" title="开源库信息"></a>开源库信息</h5><p><a target="_blank" rel="noopener" href="https://github.com/CocoaLumberjack/CocoaLumberjack">CocoaLumberjack</a></p>
<p><strong><strong>架构概览</strong></strong></p>
<p><img src="/2019/11/28/%E6%97%A5%E5%BF%97%E5%BA%93CocoaLumberjack-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/00001.png"></p>
<p><strong><strong>1. DDLog</strong></strong></p>
<p>上面是CocoaLumberjack的架构图，从整体来看主要由<strong><strong>DDLog</strong></strong>这个是总的入口，用于管理DDLogger,下面是DDLog的一些关键方法与属性：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">class</span>, <span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;<span class="type">id</span>&lt;DDLogger&gt;&gt; *allLoggers;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">class</span>, <span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;DDLoggerInformation *&gt; *allLoggersWithLevel;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">class</span>, <span class="keyword">nonatomic</span>, DISPATCH_QUEUE_REFERENCE_TYPE, <span class="keyword">readonly</span>) <span class="built_in">dispatch_queue_t</span> loggingQueue;</span><br><span class="line"></span><br><span class="line">+ (<span class="type">void</span>)addLogger:(<span class="type">id</span> &lt;DDLogger&gt;)logger withLevel:(DDLogLevel)level;</span><br><span class="line">+ (<span class="type">void</span>)removeLogger:(<span class="type">id</span> &lt;DDLogger&gt;)logger;</span><br><span class="line">+ (<span class="type">void</span>)removeAllLoggers;</span><br><span class="line">+ (<span class="type">void</span>)flushLog;</span><br></pre></td></tr></table></figure>

<p><strong><strong>2. DDLogger</strong></strong></p>
<p>DDLogger是所有Logger都需要遵循的协议，我们先来看下DDLogger协议：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">DDLogger</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于格式化输出Log的格式</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="type">id</span> &lt;DDLogFormatter&gt; logFormatter;</span><br><span class="line"></span><br><span class="line"><span class="comment">//每个logger相对于其他的logger都是并行执行的，所以每个logger都有一个专门的分发队列。</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, DISPATCH_QUEUE_REFERENCE_TYPE, <span class="keyword">readonly</span>) <span class="built_in">dispatch_queue_t</span> loggerQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果logger实现方法没有提供它专有的队列，那么我们会自动为它创建一个，队列的名称将会通过这个方法获取</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSString</span> *loggerName;</span><br><span class="line"></span><br><span class="line"><span class="comment">//由于log是异步的，并且添加和删除logger也是异步的，在logger被添加到logger系统之前或者被移除之后都不会收到消息，logger可以通过这些方法做一些初始化，善后操作等</span></span><br><span class="line">- (<span class="type">void</span>)didAddLogger;</span><br><span class="line">- (<span class="type">void</span>)didAddLoggerInQueue:(<span class="built_in">dispatch_queue_t</span>)queue;</span><br><span class="line">- (<span class="type">void</span>)willRemoveLogger;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行Log输出的方法</span></span><br><span class="line">- (<span class="type">void</span>)logMessage:(DDLogMessage *)logMessage <span class="built_in">NS_SWIFT_NAME</span>(log(message:));</span><br><span class="line"></span><br><span class="line"><span class="comment">//一些logger可能为了优化性能会使用缓存，这些缓存必须在退出应用之前进行flush操作将数据写到对应的目标。</span></span><br><span class="line">- (<span class="type">void</span>)flush;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong><strong>2.1 DDAbstractLogger</strong></strong></p>
<p>DDAbstractLogger 是所有Logger 的基类，它为我们提供了默认的logger格式化方法以及默认logger队列的创建，并提供了当前logger所使用队列的情况。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">DDAbstractLogger</span> : <span class="title">NSObject</span> &lt;<span class="title">DDLogger</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">@public</span></span><br><span class="line">    <span class="type">id</span> &lt;DDLogFormatter&gt; _logFormatter;</span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> _loggerQueue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">nullable</span>) <span class="type">id</span> &lt;DDLogFormatter&gt; logFormatter;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, DISPATCH_QUEUE_REFERENCE_TYPE) <span class="built_in">dispatch_queue_t</span> loggerQueue;</span><br><span class="line"><span class="comment">//当前logger使用global queue作为logger输出队列</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">getter</span>=isOnGlobalLoggingQueue)  <span class="type">BOOL</span> onGlobalLoggingQueue;</span><br><span class="line"><span class="comment">//当前logger使用内部设计的queue作为logger输出队列</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">getter</span>=isOnInternalLoggerQueue) <span class="type">BOOL</span> onInternalLoggerQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong><strong>2.2 Loggers</strong></strong></p>
<p><strong><strong>DDASLLogger</strong></strong>:ASL是Apple System Log的缩写，它用于发送日志到苹果的日志系统，以便它们显示在Console.app上。<br><strong><strong>DDTTYLogger</strong></strong>:用于将日志发送到Xcode控制台。<br><strong><strong>DDFileLogger</strong></strong>:用于将日志写入到日志文件下。<br><strong><strong>DDOSLogger</strong></strong>：用于将日志写入到os_log<br><strong><strong>DDAbstractDatabaseLogger</strong></strong>：是数据库日志的基础类，用于方便我们进行扩展。<br>一般我们如果只需要NSLog类似的功能，只需要添加DDASLLogger和DDTTYLogger Logger,只有要生成日志文件的情况下才需要DDFileLogger</p>
<p><strong><strong>2.3 DDLogMessage</strong></strong></p>
<p>Logger消息类封装：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">@interface DDLogMessage : NSObject &lt;NSCopying&gt;</span><br><span class="line">&#123;</span><br><span class="line">    @public</span><br><span class="line">    NSString *_message;                 <span class="regexp">//</span>具体的消息</span><br><span class="line">    DDLogLevel _level;                  <span class="regexp">//</span>消息等级</span><br><span class="line">    DDLogFlag _flag;                    <span class="regexp">//</span>等级flag</span><br><span class="line">    NSInteger _context;                 <span class="regexp">//</span>上下文标记</span><br><span class="line">    NSString *_file;                    <span class="regexp">//</span>文件路径</span><br><span class="line">    NSString *_fileName;                <span class="regexp">//</span>文件名</span><br><span class="line">    NSString *_function;                <span class="regexp">//</span>方法名</span><br><span class="line">    NSUInteger _line;                   <span class="regexp">//</span>logger所在的行数</span><br><span class="line">    id _tag;                            <span class="regexp">//</span>tag标记</span><br><span class="line">    DDLogMessageOptions _options;       <span class="regexp">//</span>消息选项</span><br><span class="line">    NSDate *_timestamp;                 <span class="regexp">//</span>消息时间戳</span><br><span class="line">    NSString *_threadID;                <span class="regexp">//</span>线程id</span><br><span class="line">    NSString *_threadName;              <span class="regexp">//</span>线程名</span><br><span class="line">    NSString *_queueLabel;              <span class="regexp">//</span>队列标记</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><strong>2.4 DDLoggerInformation</strong></strong></p>
<p>DDLoggerInformation用于标示单个logger的信息，包括对应的logger以及对应的level</p>
<p><strong><strong>2.5 DDLogFormatter</strong></strong></p>
<p>DDLogFormatter用于序列化某个logger的输出格式，</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@protocol</span> DDLogFormatter &lt;NSObject&gt;</span><br><span class="line"><span class="variable">@required</span></span><br><span class="line">- (NSString * __nullable)<span class="attribute">formatLogMessage</span>:(DDLogMessage *)logMessage NS_SWIFT_NAME(format(<span class="attribute">message</span>:));</span><br><span class="line"><span class="variable">@optional</span></span><br><span class="line">- (void)<span class="attribute">didAddToLogger</span>:(id &lt;DDLogger&gt;)logger;</span><br><span class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">didAddToLogger</span>:(id &lt;DDLogger&gt;)<span class="selector-tag">logger</span> <span class="selector-tag">inQueue</span>:(dispatch_queue_t)<span class="selector-tag">queue</span>;</span><br><span class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">willRemoveFromLogger</span>:(id &lt;DDLogger&gt;)<span class="selector-tag">logger</span>;</span><br><span class="line">@<span class="selector-tag">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong><strong>DDMultiFormatter</strong></strong>: 链式log格式化器，可以添加多个格式化器，添加后每个DDLogMessage 都需要经过这个链式log格式化器的每个格式化器处理<br><strong><strong>DDContextWhitelistFilterLogFormatter</strong></strong><em>:提供黑白名单处理，只有在白名单中的logger才会被输出<br><strong><strong>DDDispatchQueueLogFormatter</strong></strong></em>:这个序列化器主要用于方便查看dispatch_queue，它会将dispatch_queue label 替代mach_thread_id作为输出。</p>
<h5 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h5><p>我们以官方的样例入手进行源码解析：</p>
<figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="symbol">DDFileLogger</span> *fileLogger = [[<span class="symbol">DDFileLogger</span> alloc] init]; </span><br><span class="line">fileLogger.logFormatter = fileFormatter</span><br><span class="line">[<span class="symbol">DDLog</span> addLogger:fileLogger];</span><br><span class="line"></span><br><span class="line"><span class="symbol">DDLogVerbose</span>(@<span class="string">&quot;Verbose&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>DDLogVerbose其实是一个宏定义，我们先来看下这个宏定义</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">#define <span class="constructor">DDLogVerbose(<span class="params">frmt</span>, <span class="operator">...</span>)</span> <span class="constructor">LOG_OBJC_MAYBE(LOG_ASYNC_VERBOSE, LOG_LEVEL_DEF, LOG_FLAG_VERBOSE, 0, <span class="params">frmt</span>, ##<span class="params">__VA_ARGS__</span>)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">#define <span class="constructor">LOG_OBJC_MAYBE(<span class="params">async</span>, <span class="params">lvl</span>, <span class="params">flg</span>, <span class="params">ctx</span>, <span class="params">frmt</span>, <span class="operator">...</span>)</span> \</span><br><span class="line">        <span class="constructor">LOG_MAYBE(<span class="params">async</span>, <span class="params">lvl</span>, <span class="params">flg</span>, <span class="params">ctx</span>, <span class="params">__PRETTY_FUNCTION__</span>, <span class="params">frmt</span>, ## <span class="params">__VA_ARGS__</span>)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#define <span class="constructor">LOG_MAYBE(<span class="params">async</span>, <span class="params">lvl</span>, <span class="params">flg</span>, <span class="params">ctx</span>, <span class="params">fnct</span>, <span class="params">frmt</span>, <span class="operator">...</span>)</span>                       \</span><br><span class="line">        <span class="keyword">do</span> &#123; <span class="keyword">if</span>(lvl &amp; flg) <span class="constructor">LOG_MACRO(<span class="params">async</span>, <span class="params">lvl</span>, <span class="params">flg</span>, <span class="params">ctx</span>, <span class="params">nil</span>, <span class="params">fnct</span>, <span class="params">frmt</span>, ##<span class="params">__VA_ARGS__</span>)</span>; &#125; <span class="keyword">while</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">#define <span class="constructor">LOG_MACRO(<span class="params">isAsynchronous</span>, <span class="params">lvl</span>, <span class="params">flg</span>, <span class="params">ctx</span>, <span class="params">atag</span>, <span class="params">fnct</span>, <span class="params">frmt</span>, <span class="operator">...</span>)</span> \</span><br><span class="line">        <span class="literal">[DDL<span class="identifier">og</span> <span class="identifier">log</span> : <span class="identifier">isAsynchronous</span>                                     \</span></span><br><span class="line"><span class="literal">             <span class="identifier">level</span> : <span class="identifier">lvl</span>                                                \</span></span><br><span class="line"><span class="literal">              <span class="identifier">flag</span> : <span class="identifier">flg</span>                                                \</span></span><br><span class="line"><span class="literal">           <span class="identifier">context</span> : <span class="identifier">ctx</span>                                                \</span></span><br><span class="line"><span class="literal">              <span class="identifier">file</span> : <span class="identifier">__FILE__</span>                                           \</span></span><br><span class="line"><span class="literal">          <span class="identifier">function</span> : <span class="identifier">fnct</span>                                               \</span></span><br><span class="line"><span class="literal">              <span class="identifier">line</span> : <span class="identifier">__LINE__</span>                                           \</span></span><br><span class="line"><span class="literal">               <span class="identifier">tag</span> : <span class="identifier">atag</span>                                               \</span></span><br><span class="line"><span class="literal">            <span class="identifier">format</span> : (<span class="identifier">frmt</span>), ## <span class="identifier">__VA_ARGS__</span>]</span></span><br></pre></td></tr></table></figure>

<p>我们开始分析上面的宏定义：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_ASYNC_ENABLED YES</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_ASYNC_VERBOSE  (YES &amp;&amp; LOG_ASYNC_ENABLED)</span></span><br></pre></td></tr></table></figure>
<p>根据LOG_ASYNC_ENABLED 以及LOG_ASYNC_VERBOSE的定义我们可以看出默认的LOG_ASYNC_VERBOSE为YES</p>
<p>我们再来看下LOG_OBJC_MAYBE的第二个参数LOG_LEVEL_DEF，我们的等级可以通过两种方式来定义，一种是定义LOG_LEVEL_DEF，这种情况下，就直接使用LOG_LEVEL_DEF的值，一种是不定义LOG_LEVEL_DEF只定义ddLogLevel，这种情况下使用ddLogLevel的值，</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> LOG_LEVEL_DEF</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> LOG_LEVEL_DEF ddLogLevel</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>接下来是第三个参数LOG_FLAG_VERBOSE，它主要用于过滤某个等级的log的消息。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_FLAG_VERBOSE  DDLogFlagVerbose</span></span><br></pre></td></tr></table></figure>

<p>在LOG_MAYBE宏中会对LOG_LEVEL_DEF和LOG_FLAG_VERBOSE进行一个并运算，判断当前的LOG_FLAG 是否在LOG_LEVEL_DEF范围内，如果是的话则调用LOG_MACRO输出log。</p>
<p>我们来看下log方法，我们这里不再去层层看消息是怎么拼接的，我们只看最终调用的那个log方法：</p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line">- (void)log:(BOOL)asynchronous          <span class="comment">//根据上面分析，默认这里为YES</span></span><br><span class="line"><span class="symbol">    message:</span>(NSString *)message         <span class="comment">//这是要输出的log消息</span></span><br><span class="line"><span class="symbol">      level:</span>(DDLogLevel)level           <span class="comment">//消息等级</span></span><br><span class="line"><span class="symbol">       flag:</span>(DDLogFlag)flag             <span class="comment">//消息flag</span></span><br><span class="line"><span class="symbol">    context:</span>(NSInteger)context          <span class="comment">//附加context 这里为0</span></span><br><span class="line"><span class="symbol">       file:</span>(const char *)file          <span class="comment">//当前文件</span></span><br><span class="line"><span class="symbol">   function:</span>(const char *)function      <span class="comment">//方法名</span></span><br><span class="line"><span class="symbol">       line:</span>(NSUInteger)line            <span class="comment">//输出log的行</span></span><br><span class="line"><span class="symbol">        tag:</span>(id)<span class="title class_">tag</span> <span class="punctuation">&#123;</span>                   <span class="comment">//tag标记</span></span><br><span class="line">    DDLogMessage *logM<span class="attr">essage</span> <span class="operator">=</span> [[DDLogMessage alloc] initWithMessage:message</span><br><span class="line"><span class="symbol">                                                               level:</span>level</span><br><span class="line"><span class="symbol">                                                                flag:</span>flag</span><br><span class="line"><span class="symbol">                                                             context:</span>context</span><br><span class="line"><span class="symbol">                                                                file:</span>[NSString stringWithFormat:@<span class="string">&quot;%s&quot;</span>, file]</span><br><span class="line"><span class="symbol">                                                            function:</span>[NSString stringWithFormat:@<span class="string">&quot;%s&quot;</span>, function]</span><br><span class="line"><span class="symbol">                                                                line:</span>line</span><br><span class="line"><span class="symbol">                                                                 tag:</span>tag</span><br><span class="line"><span class="symbol">                                                             options:</span>(DDLogMessageOptions)<span class="number">0</span></span><br><span class="line"><span class="symbol">                                                           timestamp:</span>nil]<span class="punctuation">;</span></span><br><span class="line">    [self queueLogMessage:logMessage asynchronously:asynchronous]<span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>log方法中使用调用方法的参数构建出一个DDLogMessage，然后通过queueLogMessage将消息添加到队列，这里需要注意的是：</p>
<p>在队列尺寸小于maximumQueueSize的时候，只是简单地将消息添加到队列，这时候我们不会使用任何锁来锁住操作，但是如果队列尺寸超过了maximumQueueSize那么就会锁住操作。一旦有有log出队列了，被锁住的操作将会被解锁，CocoaLumberjack,使用计数信号量来作为锁，最大的队列尺寸被定义为DDLOG_MAX_QUEUE_SIZE</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">- (void)queueLogMessage:(DDLogMessage *)logMessage asynchronously:(BOOL)asyncFlag &#123;</span><br><span class="line">  </span><br><span class="line">    dispatch_block_t logBlock = ^&#123;</span><br><span class="line">        dispatch<span class="constructor">_semaphore_wait(<span class="params">_queueSemaphore</span>, DISPATCH_TIME_FOREVER)</span>;</span><br><span class="line">        @autoreleasepool &#123;</span><br><span class="line">            <span class="literal">[<span class="identifier">self</span> <span class="identifier">lt_log</span>:<span class="identifier">logMessage</span>]</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (asyncFlag) &#123;</span><br><span class="line">        dispatch<span class="constructor">_async(<span class="params">_loggingQueue</span>, <span class="params">logBlock</span>)</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dispatch<span class="constructor">_sync(<span class="params">_loggingQueue</span>, <span class="params">logBlock</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line">- (void)lt_log:(DDLogMessage *)logMessage &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">_numProcessors</span> &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (DDLoggerNode *loggerNode <span class="built_in">in</span> self.<span class="variable">_loggers</span>) &#123;</span><br><span class="line">            <span class="comment">// skip the loggers that shouldn&#x27;t write this message based on the log level</span></span><br><span class="line">            <span class="keyword">if</span> (!(logMessage-&gt;<span class="variable">_flag</span> &amp; loggerNode-&gt;<span class="variable">_level</span>)) &#123;</span><br><span class="line">                <span class="built_in">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dispatch_group_async(<span class="variable">_loggingGroup</span>, loggerNode-&gt;<span class="variable">_loggerQueue</span>, ^&#123; @autoreleasepool &#123;</span><br><span class="line">                [loggerNode-&gt;<span class="variable">_logger</span> logMessage:logMessage];</span><br><span class="line">            &#125; &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        dispatch_group_wait(<span class="variable">_loggingGroup</span>, DISPATCH_TIME_FOREVER);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (DDLoggerNode *loggerNode <span class="built_in">in</span> self.<span class="variable">_loggers</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!(logMessage-&gt;<span class="variable">_flag</span> &amp; loggerNode-&gt;<span class="variable">_level</span>)) &#123;</span><br><span class="line">                <span class="built_in">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dispatch_sync(loggerNode-&gt;<span class="variable">_loggerQueue</span>, ^&#123; @autoreleasepool &#123;</span><br><span class="line">                [loggerNode-&gt;<span class="variable">_logger</span> logMessage:logMessage];</span><br><span class="line">            &#125; &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dispatch_semaphore_signal(<span class="variable">_queueSemaphore</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>lt_log 会首先判断当前环境是否是多核环境，如果是多核处理器环境下，每个logger的log任务都会被加到自己的队列中，并行执行，但是在多核处理器的环境下，这些任务还会被加到同一个组中，并且会等到组内所有的log都执行完毕后往下执行。如果在单核环境下每个logger只是简单地将log任务添加到自己的队列中，然后看是否超过最大队列长度，如果超过了就会等待。直到有任务完成并出队列。</p>
<p>我们先回头看下DDLog的初始化以及logger是怎么添加的。</p>
<p><strong><strong>DDLog 初始化</strong></strong></p>
<p>这部分我们先来看下DDLog长啥样：</p>
<p>DDLog有如下几个重要的变量：</p>
<p>有关DDLog所有的操作都放在_loggingQueue，以保证它的所有操作都串行化,后续所有的addLogger，removeLogger，allLoggers等等都放在这个队列中执行，这里需要注意的是这里的_loggingQueue与每个Logger自身的_loggerQueue不是一个东西。要注意区分。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">dispatch_queue_t</span> _loggingQueue;</span><br></pre></td></tr></table></figure>
<p>每个单独的logger都并行得执行在自己的队列，_loggingGroup用于这些并行队列的同步</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">dispatch_group_t</span> _loggingGroup;</span><br></pre></td></tr></table></figure>
<p>为了保证队列不会无限制地增加这里使用了一个信号量来控制队列的长度</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">dispatch_semaphore_t</span> _queueSemaphore;</span><br></pre></td></tr></table></figure>
<p>&#x2F;&#x2F; 处理器的数量</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">NSUInteger</span> _numProcessors;</span><br></pre></td></tr></table></figure>

<p>在第一次初始化DDLog的时候会调用initialize，在这里初始化了_loggingQueue，_loggingGroup，_queueSemaphore，_numProcessors。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">+ (<span class="type">void</span>)initialize &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> DDLogOnceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;DDLogOnceToken, ^&#123;</span><br><span class="line">        _loggingQueue = dispatch_queue_create(<span class="string">&quot;cocoa.lumberjack&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">        _loggingGroup = dispatch_group_create();</span><br><span class="line">        <span class="type">void</span> *nonNullValue = GlobalLoggingQueueIdentityKey; <span class="comment">// Whatever, just not null</span></span><br><span class="line">        dispatch_queue_set_specific(_loggingQueue, GlobalLoggingQueueIdentityKey, nonNullValue, <span class="literal">NULL</span>);</span><br><span class="line">        _queueSemaphore = dispatch_semaphore_create(DDLOG_MAX_QUEUE_SIZE);</span><br><span class="line">        _numProcessors = MAX([<span class="built_in">NSProcessInfo</span> processInfo].processorCount, (<span class="built_in">NSUInteger</span>) <span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每次初始化的时候都会调用init，但是由于DDLog以单例的形式存在所以init也只会调用一次。在这个方法中主要创建了self._loggers数组，后续添加的logger都存放在这个列表中。然后添加通知，监听applicationWillTerminate，也就是在应用快要退出的时候调用flushLog</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="operator">-</span> (id)<span class="keyword">init</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> <span class="operator">=</span> [<span class="keyword">super</span> <span class="keyword">init</span>]) &#123;</span><br><span class="line">        <span class="keyword">self</span>._loggers <span class="operator">=</span> [[<span class="type">NSMutableArray</span> alloc] initWithCapacity:<span class="number">4</span>];</span><br><span class="line">        <span class="type">NSString</span> <span class="operator">*</span>notificationName <span class="operator">=</span> @<span class="string">&quot;UIApplicationWillTerminateNotification&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (notificationName) &#123;</span><br><span class="line">            [[<span class="type">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span></span><br><span class="line">                                                     selector:<span class="meta">@selector</span>(applicationWillTerminate:)</span><br><span class="line">                                                         name:notificationName</span><br><span class="line">                                                       object:<span class="literal">nil</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="operator">-</span> (void)applicationWillTerminate:(<span class="type">NSNotification</span> <span class="operator">*</span> __attribute__((unused)))notification &#123;</span><br><span class="line">    [<span class="keyword">self</span> flushLog];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong><strong>DDLog 添加 Logger</strong></strong></p>
<p>addLogger也是DDLog中的方法所以它跑在_loggingQueue队列上：</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">addLogger</span>:(id &lt;DDLogger&gt;)<span class="selector-tag">logger</span> <span class="selector-tag">withLevel</span>:(DDLogLevel)<span class="selector-tag">level</span> &#123;</span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line">    <span class="selector-tag">dispatch_async</span>(_loggingQueue, ^&#123; <span class="variable">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="selector-attr">[self lt_addLogger:logger level:level]</span>;</span><br><span class="line">    &#125; &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)lt_addLogger:(<span class="type">id</span> &lt;DDLogger&gt;)logger level:(DDLogLevel)level &#123;</span><br><span class="line">    <span class="comment">// Add to loggers array.</span></span><br><span class="line">    <span class="comment">// Need to create loggerQueue if loggerNode doesn&#x27;t provide one.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断是否已经存在了</span></span><br><span class="line">    <span class="keyword">for</span> (DDLoggerNode* node <span class="keyword">in</span> <span class="keyword">self</span>._loggers) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;_logger == logger</span><br><span class="line">            &amp;&amp; node-&gt;_level == level) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSAssert</span>(dispatch_get_specific(GlobalLoggingQueueIdentityKey),</span><br><span class="line">             <span class="string">@&quot;This method should only be run on the logging thread/queue&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> loggerQueue = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断当前logger是否有自己的队列</span></span><br><span class="line">    <span class="keyword">if</span> ([logger respondsToSelector:<span class="keyword">@selector</span>(loggerQueue)]) &#123;</span><br><span class="line">        loggerQueue = [logger loggerQueue];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果没有自己的队列，则使用logger提供的loggerName方法返回的名字，创建队列</span></span><br><span class="line">    <span class="keyword">if</span> (loggerQueue == <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="type">char</span> *loggerQueueName = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span> ([logger respondsToSelector:<span class="keyword">@selector</span>(loggerName)]) &#123;</span><br><span class="line">            loggerQueueName = [[logger loggerName] UTF8String];</span><br><span class="line">        &#125;</span><br><span class="line">        loggerQueue = dispatch_queue_create(loggerQueueName, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将logger，logger队列，等级封装到DDLoggerNode后添加到_loggers</span></span><br><span class="line">    DDLoggerNode *loggerNode = [DDLoggerNode nodeWithLogger:logger loggerQueue:loggerQueue level:level];</span><br><span class="line">    [<span class="keyword">self</span>._loggers addObject:loggerNode];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通知外部当前logger已经被添加了</span></span><br><span class="line">    <span class="keyword">if</span> ([logger respondsToSelector:<span class="keyword">@selector</span>(didAddLoggerInQueue:)]) &#123;</span><br><span class="line">        <span class="built_in">dispatch_async</span>(loggerNode-&gt;_loggerQueue, ^&#123; <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">            [logger didAddLoggerInQueue:loggerNode-&gt;_loggerQueue];</span><br><span class="line">        &#125; &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([logger respondsToSelector:<span class="keyword">@selector</span>(didAddLogger)]) &#123;</span><br><span class="line">        <span class="built_in">dispatch_async</span>(loggerNode-&gt;_loggerQueue, ^&#123; <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">            [logger didAddLogger];</span><br><span class="line">        &#125; &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>lt_addLogger中将会以异步的方式将logger添加到DDLog.由于是异步方式添加，所以每个logger被添加到self._loggers中的时候每个logger的****didAddLoggerInQueue:<strong><strong>，</strong></strong>didAddLogger:****将会被调用，在这里可以做相应的处理。每个logger都拥有一个队列，可以通过两种方式指定:</p>
<p>一种是通过loggerQueue指定：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, DISPATCH_QUEUE_REFERENCE_TYPE, <span class="keyword">readonly</span>) <span class="built_in">dispatch_queue_t</span> loggerQueue;</span><br></pre></td></tr></table></figure>

<p>另一种是指定loggerName,就会将loggerName作为队列名称创建logger队列</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSString</span> *loggerName;</span><br></pre></td></tr></table></figure>

<p>后续当前logger的log都会通过这个队列来完成log的输出。</p>
<p><strong><strong>Logger 结构</strong></strong></p>
<p>我们在介绍架构的时候详细介绍过Logger的组成，这里简单重新介绍下，CocoaLumberjack 总共有 DDASLLogger，DDTTYLogger，DDFileLogger，DDOSLogger这几种Logger,并且提供了一个抽象的DDAbstractDatabaseLogger用于我们自己根据实际的业务需求进行扩展数据库Logger,这些Logger都继承自DDAbstractLogger。DDAbstractLogger比较简单主要负责每个logger Queue的创建，以及提供LoggerFormater的设置。至于log的输出形式都交给具体的Logger子类实现。</p>
<p>我们这里以比较常用的<strong><strong>DDFileLogger</strong></strong>作为重点给大家介绍下Logger的功能。</p>
<p>对于一个文件日志来说它要能够自动管理日志文件，DDFileLogger在日志超过指定时间(age)后删除，大小超过最大日志文件大小的时候将文件打包成achive文件。并且能够自定义日志文件名，以及日志文件log格式：</p>
<p>我们先来看下DDFileLogger的组成：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">DDFileLogger</span> : <span class="title">DDAbstractLogger</span> &lt;<span class="title">DDLogger</span>&gt; </span>&#123;</span><br><span class="line">	DDLogFileInfo *_currentLogFileInfo;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)init;</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithLogFileManager:(<span class="type">id</span> &lt;DDLogFileManager&gt;)logFileManager <span class="built_in">NS_DESIGNATED_INITIALIZER</span>;</span><br><span class="line"><span class="comment">//在将要写日志的时候会被调用</span></span><br><span class="line">- (<span class="type">void</span>)willLogMessage <span class="built_in">NS_REQUIRES_SUPER</span>;</span><br><span class="line"><span class="comment">//当前日志写完后会被调用</span></span><br><span class="line">- (<span class="type">void</span>)didLogMessage <span class="built_in">NS_REQUIRES_SUPER</span>;</span><br><span class="line"><span class="comment">//是否对传进来的日志文件进行打包成achive文件</span></span><br><span class="line">- (<span class="type">BOOL</span>)shouldArchiveRecentLogFileInfo:(DDLogFileInfo *)recentLogFileInfo;</span><br><span class="line"> <span class="comment">//日志文件的最大尺寸，超过这个大小将会被回滚，如果maximumFileSize设置为0则只有rollingFrequency会影响到文件的回滚</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">assign</span>) <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> maximumFileSize;</span><br><span class="line"> <span class="comment">// 回滚的频率，超过这个时间就会被回滚，maximumFileSize设置为0或者任何负数则只有maximumFileSize会影响到文件的回滚</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">assign</span>) <span class="built_in">NSTimeInterval</span> rollingFrequency;</span><br><span class="line"> <span class="comment">// 在每次启动的时候会自动创建新的日志文件，不会重用旧的</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">assign</span>, atomic) <span class="type">BOOL</span> doNotReuseLogFiles;</span><br><span class="line"> <span class="comment">// 日志文件管理类</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="type">id</span> &lt;DDLogFileManager&gt; logFileManager;</span><br><span class="line"> <span class="comment">// 会在每条日志的最后添加\n</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readwrite</span>, <span class="keyword">assign</span>) <span class="type">BOOL</span> automaticallyAppendNewlineForCustomFormatters;</span><br><span class="line"><span class="comment">// 强制roll当前日志</span></span><br><span class="line">- (<span class="type">void</span>)rollLogFileWithCompletionBlock:(<span class="type">void</span> (^)(<span class="type">void</span>))completionBlock <span class="built_in">NS_SWIFT_NAME</span>(rollLogFile(withCompletion:));</span><br><span class="line"><span class="comment">// 日志文件格式化</span></span><br><span class="line">- (<span class="type">id</span> &lt;DDLogFormatter&gt;)logFormatter;</span><br><span class="line"><span class="comment">// 当前日志文件信息</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">strong</span>) DDLogFileInfo *currentLogFileInfo;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>DDFileLogger有两个重要的对象：DDLogFileManagerDefault，以及DDLogFileFormatterDefault.前者负责日志文件的管理，后者负责日志的输出格式，这两者都可以自己实现来达到自定义的目的：</p>
<p>LogFileManager是所有日志文件都必须遵循的协议，它负责日志文件的创建，删除，日志文件命名等所有日志文件的管理,默认情况下每个日志文件的最大尺寸为1M,超过这个大小，日志文件将会被roll，默认情况下每个日志文件的有效期为24小时，超过24小时也会被roll，默认最多保存5个日志文件，整个日志磁盘配额最大为20M.</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="keyword">const</span> kDDDefaultLogMaxFileSize      = <span class="number">1024</span> * <span class="number">1024</span>;      <span class="comment">// 1 MB</span></span><br><span class="line"><span class="built_in">NSTimeInterval</span>     <span class="keyword">const</span> kDDDefaultLogRollingFrequency = <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span>;     <span class="comment">// 24 Hours</span></span><br><span class="line"><span class="built_in">NSUInteger</span>         <span class="keyword">const</span> kDDDefaultLogMaxNumLogFiles   = <span class="number">5</span>;                <span class="comment">// 5 Files</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="keyword">const</span> kDDDefaultLogFilesDiskQuota   = <span class="number">20</span> * <span class="number">1024</span> * <span class="number">1024</span>; <span class="comment">// 20 MB</span></span><br></pre></td></tr></table></figure>

<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">DDLogFileManager</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"><span class="keyword">@required</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Public properties</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 磁盘上能够存储的最多archived log文件数量，</span></span><br><span class="line"><span class="comment">// 比如我们将这个值设置为3，那么LogFileManager只会保存当前日志文件在内的3个日志文件，如果要禁止这个功能可以将这个值设置为0</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">assign</span>, atomic) <span class="built_in">NSUInteger</span> maximumNumberOfLogFiles;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 日志文件所能占用的空间大小</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">assign</span>, atomic) <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> logFilesDiskQuota;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Public methods</span></span><br><span class="line"><span class="comment">// 日志文件目录</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *logsDirectory;</span><br><span class="line"></span><br><span class="line"><span class="comment">//未排序的日志文件信息</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">strong</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *unsortedLogFilePaths;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">strong</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *unsortedLogFileNames;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">strong</span>) <span class="built_in">NSArray</span>&lt;DDLogFileInfo *&gt; *unsortedLogFileInfos;</span><br><span class="line"></span><br><span class="line"><span class="comment">//排序后的日志文件信息</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">strong</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *sortedLogFilePaths;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">strong</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *sortedLogFileNames;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">strong</span>) <span class="built_in">NSArray</span>&lt;DDLogFileInfo *&gt; *sortedLogFileInfos;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Private methods (only to be used by DDFileLogger)</span></span><br><span class="line"><span class="comment">// 创建新的Log文件</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)createNewLogFile;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@optional</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Notifications from DDFileLogger</span></span><br><span class="line"><span class="comment">// 在日志文件被archieved的时候被调用</span></span><br><span class="line">- (<span class="type">void</span>)didArchiveLogFile:(<span class="built_in">NSString</span> *)logFilePath <span class="built_in">NS_SWIFT_NAME</span>(didArchiveLogFile(atPath:));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在日志文件被roll的时候被调用</span></span><br><span class="line">- (<span class="type">void</span>)didRollAndArchiveLogFile:(<span class="built_in">NSString</span> *)logFilePath <span class="built_in">NS_SWIFT_NAME</span>(didRollAndArchiveLogFile(atPath:));</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>我们来看下默认提供的DDLogFileManagerDefault的具体实现：</p>
<p><strong><strong>初始化</strong></strong></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)initWithLogsDirectory:(<span class="built_in">NSString</span> *)aLogsDirectory &#123;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">self</span> = [<span class="variable language_">super</span> init])) &#123;</span><br><span class="line">        _maximumNumberOfLogFiles = kDDDefaultLogMaxNumLogFiles;</span><br><span class="line">        _logFilesDiskQuota = kDDDefaultLogFilesDiskQuota;</span><br><span class="line">        <span class="keyword">if</span> (aLogsDirectory) &#123;</span><br><span class="line">            _logsDirectory = [aLogsDirectory <span class="keyword">copy</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            _logsDirectory = [[<span class="keyword">self</span> defaultLogsDirectory] <span class="keyword">copy</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">NSKeyValueObservingOptions</span> kvoOptions = <span class="built_in">NSKeyValueObservingOptionOld</span> | <span class="built_in">NSKeyValueObservingOptionNew</span>;</span><br><span class="line">        [<span class="keyword">self</span> addObserver:<span class="keyword">self</span> forKeyPath:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(maximumNumberOfLogFiles)) options:kvoOptions context:<span class="literal">nil</span>];</span><br><span class="line">        [<span class="keyword">self</span> addObserver:<span class="keyword">self</span> forKeyPath:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(logFilesDiskQuota)) options:kvoOptions context:<span class="literal">nil</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化方法中会指定日志的最大文件数量以及日志文件所占用的最大空间，以及日志文件存储目录。以及使用KVO检测maximumNumberOfLogFiles，logFilesDiskQuota的设置。一旦我们对这两个值进行设置就会触发下面的方法：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath</span><br><span class="line">                      ofObject:(<span class="type">id</span>)object</span><br><span class="line">                        change:(<span class="built_in">NSDictionary</span> *)change</span><br><span class="line">                       context:(<span class="type">void</span> *)context &#123;</span><br><span class="line">    <span class="built_in">NSNumber</span> *old = change[<span class="built_in">NSKeyValueChangeOldKey</span>];</span><br><span class="line">    <span class="built_in">NSNumber</span> *new = change[<span class="built_in">NSKeyValueChangeNewKey</span>];</span><br><span class="line">    <span class="keyword">if</span> ([old isEqual:new]) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ([keyPath isEqualToString:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(maximumNumberOfLogFiles))] ||</span><br><span class="line">        [keyPath isEqualToString:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(logFilesDiskQuota))]) &#123;</span><br><span class="line">        <span class="built_in">dispatch_async</span>([DDLog loggingQueue], ^&#123; <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">                                                    [<span class="keyword">self</span> deleteOldLogFiles];</span><br><span class="line">                                                &#125; &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在设置最大磁盘空间以及最大文件数的时候会对磁盘空间情况做个扫描，将超过的部分删除。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)deleteOldLogFiles &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将缓存目录下的所有日志进行排序形成sortedLogFileInfos数组</span></span><br><span class="line">    <span class="built_in">NSArray</span> *sortedLogFileInfos = [<span class="keyword">self</span> sortedLogFileInfos];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSUInteger</span> firstIndexToDelete = <span class="built_in">NSNotFound</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> diskQuota = <span class="keyword">self</span>.logFilesDiskQuota;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">NSUInteger</span> maxNumLogFiles = <span class="keyword">self</span>.maximumNumberOfLogFiles;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//先看磁盘占用空间</span></span><br><span class="line">    <span class="keyword">if</span> (diskQuota) &#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> used = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>; i &lt; sortedLogFileInfos.count; i++) &#123;</span><br><span class="line">            DDLogFileInfo *info = sortedLogFileInfos[i];</span><br><span class="line">            used += info.fileSize;</span><br><span class="line">            <span class="keyword">if</span> (used &gt; diskQuota) &#123;</span><br><span class="line">                firstIndexToDelete = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//再看最大日志文件数</span></span><br><span class="line">    <span class="keyword">if</span> (maxNumLogFiles) &#123;</span><br><span class="line">        <span class="keyword">if</span> (firstIndexToDelete == <span class="built_in">NSNotFound</span>) &#123;</span><br><span class="line">            firstIndexToDelete = maxNumLogFiles;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            firstIndexToDelete = MIN(firstIndexToDelete, maxNumLogFiles);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//　删除超过磁盘空间和最大文件数的文件</span></span><br><span class="line">    <span class="keyword">if</span> (firstIndexToDelete != <span class="built_in">NSNotFound</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = firstIndexToDelete; i &lt; sortedLogFileInfos.count; i++) &#123;</span><br><span class="line">            DDLogFileInfo *logFileInfo = sortedLogFileInfos[i];</span><br><span class="line">            [[<span class="built_in">NSFileManager</span> defaultManager] removeItemAtPath:logFileInfo.filePath error:<span class="literal">nil</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们来看下是怎么对文件进行排序的？</p>
<figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line">- (<span class="symbol">NSArray</span> *)sortedLogFileInfos &#123;</span><br><span class="line">    return  [[self unsortedLogFileInfos] sortedArrayUsingComparator:^<span class="symbol">NSComparisonResult</span>(<span class="symbol">DDLogFileInfo</span> * <span class="symbol">_Nonnull</span> obj1, <span class="symbol">DDLogFileInfo</span>   * <span class="symbol">_Nonnull</span> obj2) &#123;</span><br><span class="line">        <span class="symbol">NSDate</span> *date1 = [<span class="symbol">NSDate</span> new];</span><br><span class="line">        <span class="symbol">NSDate</span> *date2 = [<span class="symbol">NSDate</span> new];</span><br><span class="line"></span><br><span class="line">        <span class="symbol">NSArray</span>&lt;<span class="symbol">NSString</span> *&gt; *arrayComponent = [[obj1 fileName] componentsSeparatedByString:@<span class="string">&quot; &quot;</span>];</span><br><span class="line">        if (arrayComponent.count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="symbol">NSString</span> *stringDate = arrayComponent.lastObject;</span><br><span class="line">            stringDate = [stringDate stringByReplacingOccurrencesOfString:@<span class="string">&quot;.log&quot;</span> withString:@<span class="string">&quot;&quot;</span>];</span><br><span class="line">            stringDate = [stringDate stringByReplacingOccurrencesOfString:@<span class="string">&quot;.archived&quot;</span> withString:@<span class="string">&quot;&quot;</span>];</span><br><span class="line">            date1 = [[self logFileDateFormatter] dateFromString:stringDate] ?: [obj1 creationDate];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        arrayComponent = [[obj2 fileName] componentsSeparatedByString:@<span class="string">&quot; &quot;</span>];</span><br><span class="line">        if (arrayComponent.count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="symbol">NSString</span> *stringDate = arrayComponent.lastObject;</span><br><span class="line">            stringDate = [stringDate stringByReplacingOccurrencesOfString:@<span class="string">&quot;.log&quot;</span> withString:@<span class="string">&quot;&quot;</span>];</span><br><span class="line">            stringDate = [stringDate stringByReplacingOccurrencesOfString:@<span class="string">&quot;.archived&quot;</span> withString:@<span class="string">&quot;&quot;</span>];</span><br><span class="line">            date2 = [[self logFileDateFormatter] dateFromString:stringDate] ?: [obj2 creationDate];</span><br><span class="line">        &#125;</span><br><span class="line">        return [date2 compare:date1 ?: [<span class="symbol">NSDate</span> new]];</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">NSArray</span> *)unsortedLogFileInfos &#123;</span><br><span class="line">    <span class="built_in">NSArray</span> *unsortedLogFilePaths = [<span class="keyword">self</span> unsortedLogFilePaths];</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *unsortedLogFileInfos = [<span class="built_in">NSMutableArray</span> arrayWithCapacity:[unsortedLogFilePaths count]];</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSString</span> *filePath <span class="keyword">in</span> unsortedLogFilePaths) &#123;</span><br><span class="line">        DDLogFileInfo *logFileInfo = [[DDLogFileInfo alloc] initWithFilePath:filePath];</span><br><span class="line">        [unsortedLogFileInfos addObject:logFileInfo];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> unsortedLogFileInfos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">NSArray</span> *)unsortedLogFilePaths &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *logsDirectory = [<span class="keyword">self</span> logsDirectory];</span><br><span class="line">    <span class="built_in">NSArray</span> *fileNames = [[<span class="built_in">NSFileManager</span> defaultManager] contentsOfDirectoryAtPath:logsDirectory error:<span class="literal">nil</span>];</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *unsortedLogFilePaths = [<span class="built_in">NSMutableArray</span> arrayWithCapacity:[fileNames count]];</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSString</span> *fileName <span class="keyword">in</span> fileNames) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([<span class="keyword">self</span> isLogFile:fileName]) &#123;</span><br><span class="line">            <span class="built_in">NSString</span> *filePath = [logsDirectory stringByAppendingPathComponent:fileName];</span><br><span class="line">            [unsortedLogFilePaths addObject:filePath];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> unsortedLogFilePaths;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- (<span class="type">BOOL</span>)isLogFile:(<span class="built_in">NSString</span> *)fileName &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *appName = [<span class="keyword">self</span> applicationName];</span><br><span class="line">    <span class="type">BOOL</span> hasProperPrefix = [fileName hasPrefix:[appName stringByAppendingString:<span class="string">@&quot; &quot;</span>]];</span><br><span class="line">    <span class="type">BOOL</span> hasProperSuffix = [fileName hasSuffix:<span class="string">@&quot;.log&quot;</span>];</span><br><span class="line">    <span class="keyword">return</span> (hasProperPrefix &amp;&amp; hasProperSuffix);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先会进入日志目录，对日志目录下对文件进行判断，通过isLogFile判断当前文件是否是日志文件，将日志文件添加到unsortedLogFilePaths,这里的日志文件被定义为”应用名 xxxxxxxx.log”形式的文件，这个定义是可以定制的我们在介绍日志文件的创建的时候会对这部分进行介绍。上面排序就是扫描日志文件夹下的符合日志格式的文件，将其添加到数组，再对数组的文件根据创建时间进行排序。</p>
<p>我们再来看下日志文件的创建：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">NSString</span> *)newLogFileName &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *appName = [<span class="keyword">self</span> applicationName];</span><br><span class="line">    <span class="built_in">NSDateFormatter</span> *dateFormatter = [<span class="keyword">self</span> logFileDateFormatter];</span><br><span class="line">    <span class="built_in">NSString</span> *formattedDate = [dateFormatter stringFromDate:[<span class="built_in">NSDate</span> date]];</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;%@ %@.log&quot;</span>, appName, formattedDate];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSDateFormatter</span> *)logFileDateFormatter &#123;</span><br><span class="line">    <span class="built_in">NSMutableDictionary</span> *dictionary = [[<span class="built_in">NSThread</span> currentThread]</span><br><span class="line">                                       threadDictionary];</span><br><span class="line">    <span class="built_in">NSString</span> *dateFormat = <span class="string">@&quot;yyyy&#x27;-&#x27;MM&#x27;-&#x27;dd&#x27;--&#x27;HH&#x27;-&#x27;mm&#x27;-&#x27;ss&#x27;-&#x27;SSS&#x27;&quot;</span>;</span><br><span class="line">    <span class="built_in">NSString</span> *key = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;logFileDateFormatter.%@&quot;</span>, dateFormat];</span><br><span class="line">    <span class="built_in">NSDateFormatter</span> *dateFormatter = dictionary[key];</span><br><span class="line">    <span class="keyword">if</span> (dateFormatter == <span class="literal">nil</span>) &#123;</span><br><span class="line">        dateFormatter = [[<span class="built_in">NSDateFormatter</span> alloc] init];</span><br><span class="line">        [dateFormatter setLocale:[<span class="built_in">NSLocale</span> localeWithLocaleIdentifier:<span class="string">@&quot;en_US_POSIX&quot;</span>]];</span><br><span class="line">        [dateFormatter setDateFormat:dateFormat];</span><br><span class="line">        [dateFormatter setTimeZone:[<span class="built_in">NSTimeZone</span> timeZoneForSecondsFromGMT:<span class="number">0</span>]];</span><br><span class="line">        dictionary[key] = dateFormatter;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dateFormatter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *)createNewLogFile &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *fileName = [<span class="keyword">self</span> newLogFileName];</span><br><span class="line">    <span class="built_in">NSString</span> *logsDirectory = [<span class="keyword">self</span> logsDirectory];</span><br><span class="line">    <span class="built_in">NSUInteger</span> attempt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="built_in">NSString</span> *actualFileName = fileName;</span><br><span class="line">        <span class="keyword">if</span> (attempt &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">NSString</span> *extension = [actualFileName pathExtension];</span><br><span class="line">            actualFileName = [actualFileName stringByDeletingPathExtension];</span><br><span class="line">            actualFileName = [actualFileName stringByAppendingFormat:<span class="string">@&quot; %lu&quot;</span>, (<span class="type">unsigned</span> <span class="type">long</span>)attempt];</span><br><span class="line">            <span class="keyword">if</span> (extension.length) &#123;</span><br><span class="line">                actualFileName = [actualFileName stringByAppendingPathExtension:extension];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">NSString</span> *filePath = [logsDirectory stringByAppendingPathComponent:actualFileName];</span><br><span class="line">        <span class="keyword">if</span> (![[<span class="built_in">NSFileManager</span> defaultManager] fileExistsAtPath:filePath]) &#123;</span><br><span class="line">            <span class="built_in">NSDictionary</span> *attributes = <span class="literal">nil</span>;</span><br><span class="line">            [[<span class="built_in">NSFileManager</span> defaultManager] createFileAtPath:filePath contents:<span class="literal">nil</span> attributes:attributes];</span><br><span class="line">            [<span class="keyword">self</span> deleteOldLogFiles];</span><br><span class="line">            <span class="keyword">return</span> filePath;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            attempt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="literal">YES</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面可以看出日志文件的格式为“应用名 yyyy-MM-dd–HH-mm-ss-SSS.log”存储在缓存目录下的”Log”目录，再createNewLogFile主要处理同名的情况下会追加一个数字用于避免文件名同名，比如“应用名 yyyy-MM-dd–HH-mm-ss-SSS 1.log”，“应用名 yyyy-MM-dd–HH-mm-ss-SSS 2.log”等。创建一个新的文件之后还会调用deleteOldLogFiles对当前日志文件目录下对文件进行一遍检查。</p>
<p>我们在介绍DDFileLogger之前对<strong><strong>DDLogFileManagerDefault</strong></strong>做个总结，DDLogFileManagerDefault总地来说就是负责日志文件的创建以及根据我们为日志文件设置的存储空间，以及日志文件数量进行管控，一旦超过空间大小，或者日志文件数量大于我们设定的最大数量都会删除掉最旧的那个。DDLogFileManager整体就是为了DDFileLogger服务的所以我们接下来看下DDFileLogger是怎么通过它来管理日志文件的。</p>
<p>初始化：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">    DDLogFileManagerDefault *defaultLogFileManager = [[DDLogFileManagerDefault alloc] init];</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> initWithLogFileManager:defaultLogFileManager];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithLogFileManager:(<span class="type">id</span> &lt;DDLogFileManager&gt;)aLogFileManager &#123;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">self</span> = [<span class="variable language_">super</span> init])) &#123;</span><br><span class="line">        _maximumFileSize = kDDDefaultLogMaxFileSize;</span><br><span class="line">        _rollingFrequency = kDDDefaultLogRollingFrequency;</span><br><span class="line">        _automaticallyAppendNewlineForCustomFormatters = <span class="literal">YES</span>;</span><br><span class="line">        logFileManager = aLogFileManager;</span><br><span class="line">        <span class="keyword">self</span>.logFormatter = [DDLogFileFormatterDefault new];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在初始化方法中主要初始化了logFileManager，logFormatter以及_rollingFrequency，紧接着我们从最核心的日志输出入手看下整个DDFileLogger的细节。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)logMessage:(DDLogMessage *)logMessage &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *message = logMessage-&gt;_message;</span><br><span class="line">    <span class="type">BOOL</span> isFormatted = <span class="literal">NO</span>;</span><br><span class="line">    <span class="keyword">if</span> (_logFormatter) &#123;</span><br><span class="line">        <span class="comment">//使用文件日志格式化器对传入的日志进行输出前格式化</span></span><br><span class="line">        message = [_logFormatter formatLogMessage:logMessage];</span><br><span class="line">        isFormatted = message != logMessage-&gt;_message;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (message) &#123;</span><br><span class="line">        <span class="comment">//如果_automaticallyAppendNewlineForCustomFormatters = YES,就会在格式化日志的后面追加\n</span></span><br><span class="line">        <span class="keyword">if</span> ((!isFormatted || _automaticallyAppendNewlineForCustomFormatters) &amp;&amp;</span><br><span class="line">            (![message hasSuffix:<span class="string">@&quot;\n&quot;</span>])) &#123;</span><br><span class="line">            message = [message stringByAppendingString:<span class="string">@&quot;\n&quot;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将数据转换为NSData</span></span><br><span class="line">        <span class="built_in">NSData</span> *logData = [message dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">        <span class="keyword">@try</span> &#123;</span><br><span class="line">            <span class="comment">//通知外部将要写日志了，这样可以在开始写日志前做一些处理</span></span><br><span class="line">            [<span class="keyword">self</span> willLogMessage];</span><br><span class="line">            <span class="comment">//写入日志</span></span><br><span class="line">            [[<span class="keyword">self</span> currentLogFileHandle] writeData:logData];</span><br><span class="line">            <span class="comment">//通知外部日志写入成功了</span></span><br><span class="line">            [<span class="keyword">self</span> didLogMessage];</span><br><span class="line">        &#125; <span class="keyword">@catch</span> (<span class="built_in">NSException</span> *exception) &#123;</span><br><span class="line">            <span class="comment">//如果出问题则重试10次</span></span><br><span class="line">            exception_count++;</span><br><span class="line">            <span class="keyword">if</span> (exception_count &lt;= <span class="number">10</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (exception_count == <span class="number">10</span>) &#123;</span><br><span class="line">                    <span class="built_in">NSLogError</span>(<span class="string">@&quot;DDFileLogger.logMessage: Too many exceptions -- will not log any more of them.&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们先看下默认的文件日志格式化器是怎么对消息进行格式化的：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">- (NSString *)<span class="symbol">formatLogMessage:</span>(DDLogMessage *)logMessage &#123;</span><br><span class="line">    NSString *dateAndTime = [_dateFormatter <span class="symbol">stringFromDate:</span>(logMessage-&gt;_timestamp)];</span><br><span class="line">    <span class="regexp">//</span>时间格式为yyyy/<span class="variable constant_">MM</span>/dd <span class="variable constant_">HH</span><span class="symbol">:mm</span><span class="symbol">:ss</span><span class="symbol">:SSS</span></span><br><span class="line">    <span class="keyword">return</span> [NSString <span class="symbol">stringWithFormat:</span>@<span class="string">&quot;%@  %@&quot;</span>, dateAndTime, logMessage-&gt;_message];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>formatLogMessage比较简单，就是将日志时间和日志内容进行拼接后返回。没有太大的特别处理，然后根据_automaticallyAppendNewlineForCustomFormatters的值判断是否需要在格式化后的消息尾部添加\n,在日志将要输出以及输出之后会分别调用willLogMessage，以及didLogMessage告诉外界将要开始写文件了，以及日志已经写到日志文件了。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-attr">[[self currentLogFileHandle]</span> writeData:logData];</span><br></pre></td></tr></table></figure>

<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">NSFileHandle</span> *)currentLogFileHandle &#123;</span><br><span class="line">    <span class="keyword">if</span> (_currentLogFileHandle == <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="comment">//获取到当前可用的日志文件</span></span><br><span class="line">        <span class="built_in">NSString</span> *logFilePath = [[<span class="keyword">self</span> currentLogFileInfo] filePath];</span><br><span class="line">        <span class="comment">//创建NSFileHandle</span></span><br><span class="line">        _currentLogFileHandle = [<span class="built_in">NSFileHandle</span> fileHandleForWritingAtPath:logFilePath];</span><br><span class="line">        <span class="comment">//将文件光标移到文件的最后</span></span><br><span class="line">        [_currentLogFileHandle seekToEndOfFile];</span><br><span class="line">        <span class="keyword">if</span> (_currentLogFileHandle) &#123;</span><br><span class="line">            <span class="comment">//开始定时roll</span></span><br><span class="line">            [<span class="keyword">self</span> scheduleTimerToRollLogFileDueToAge];</span><br><span class="line">            _currentLogFileVnode = dispatch_source_create(</span><br><span class="line">                    DISPATCH_SOURCE_TYPE_VNODE,</span><br><span class="line">                    [_currentLogFileHandle fileDescriptor],</span><br><span class="line">                    DISPATCH_VNODE_DELETE | DISPATCH_VNODE_RENAME,</span><br><span class="line">                    <span class="keyword">self</span>.loggerQueue</span><br><span class="line">                    );</span><br><span class="line">            dispatch_source_set_event_handler(_currentLogFileVnode, ^&#123; <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">                                                                          [<span class="keyword">self</span> rollLogFileNow];</span><br><span class="line">                                                                      &#125; &#125;);</span><br><span class="line"></span><br><span class="line">            dispatch_resume(_currentLogFileVnode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _currentLogFileHandle;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (DDLogFileInfo *)currentLogFileInfo &#123;</span><br><span class="line">    <span class="keyword">if</span> (_currentLogFileInfo == <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="comment">//拿到已经排序好的日志文件</span></span><br><span class="line">        <span class="built_in">NSArray</span> *sortedLogFileInfos = [logFileManager sortedLogFileInfos];</span><br><span class="line">        <span class="keyword">if</span> ([sortedLogFileInfos count] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//拿到排序中的第一个文件</span></span><br><span class="line">            DDLogFileInfo *mostRecentLogFileInfo = sortedLogFileInfos[<span class="number">0</span>];</span><br><span class="line">            <span class="type">BOOL</span> shouldArchiveMostRecent = <span class="literal">NO</span>;</span><br><span class="line">            <span class="comment">//如果已经archived则shouldArchiveMostRecent = NO</span></span><br><span class="line">            <span class="keyword">if</span> (mostRecentLogFileInfo.isArchived) &#123;</span><br><span class="line">                shouldArchiveMostRecent = <span class="literal">NO</span>;</span><br><span class="line">            <span class="comment">//通过外部方法拦截判断当前日志文件是否需要archive</span></span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> ([<span class="keyword">self</span> shouldArchiveRecentLogFileInfo:mostRecxentLogFileInfo]) &#123;</span><br><span class="line">				shouldArchiveMostRecent = <span class="literal">YES</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (_maximumFileSize &gt; <span class="number">0</span> &amp;&amp; mostRecentLogFileInfo.fileSize &gt;= _maximumFileSize) &#123;</span><br><span class="line">                <span class="comment">//如果当前文件尺寸大于_maximumFileSize则需要archive</span></span><br><span class="line">                shouldArchiveMostRecent = <span class="literal">YES</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_rollingFrequency &gt; <span class="number">0.0</span> &amp;&amp; mostRecentLogFileInfo.age &gt;= _rollingFrequency) &#123;</span><br><span class="line">                <span class="comment">//如果当前文件age超过了_rollingFrequency则需要archive</span></span><br><span class="line">                shouldArchiveMostRecent = <span class="literal">YES</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//.......</span></span><br><span class="line">            <span class="comment">// 如果是未achive的日志文件表示，当前可用的，将其赋给_currentLogFileInfo</span></span><br><span class="line">            <span class="keyword">if</span> (!_doNotReuseLogFiles &amp;&amp; !mostRecentLogFileInfo.isArchived &amp;&amp; !shouldArchiveMostRecent) &#123;</span><br><span class="line">                _currentLogFileInfo = mostRecentLogFileInfo;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//如果需要achive当前文件则将当前文件设置为achive并通知外部</span></span><br><span class="line">                <span class="keyword">if</span> (shouldArchiveMostRecent) &#123;</span><br><span class="line">                    mostRecentLogFileInfo.isArchived = <span class="literal">YES</span>;</span><br><span class="line">                    <span class="keyword">if</span> ([logFileManager respondsToSelector:<span class="keyword">@selector</span>(didArchiveLogFile:)]) &#123;</span><br><span class="line">                        [logFileManager didArchiveLogFile:(mostRecentLogFileInfo.filePath)];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果到这里还是空则只能新建了</span></span><br><span class="line">        <span class="keyword">if</span> (_currentLogFileInfo == <span class="literal">nil</span>) &#123;</span><br><span class="line">            <span class="built_in">NSString</span> *currentLogFilePath = [logFileManager createNewLogFile];</span><br><span class="line">            _currentLogFileInfo = [[DDLogFileInfo alloc] initWithFilePath:currentLogFilePath];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _currentLogFileInfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整个文件的创建过程都放在currentLogFileHandle中，首先会从日志文件夹中取出最新一个文件，然后判断它是否需要achive了，判断的标准先看它是否已经achive了，然后再调用外部的shouldArchiveRecentLogFileInfo来判断是否需要achive，最后再看日志文件的大小以及age是否超过限制，如果超过限制则achive。achive大家理解吗？比较难解释，就是某个日志文件不用了就要将其归档起来，上传日志的时候就上传这些归档后的日志。如果当前第一个文件不是achive文件，那么就将它赋给_currentLogFileInfo，将文件光标指向文件最后，继续往这个日志文件下写日志。这里还有一个比较重要的方法<strong><strong>scheduleTimerToRollLogFileDueToAge</strong></strong>，它用于定时扫描查看文件是否age过期了，每个日志文件都只能保留指定的时间，默认的情况下是24小时。我们来看下这个方法：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)scheduleTimerToRollLogFileDueToAge &#123;</span><br><span class="line">    <span class="keyword">if</span> (_rollingTimer) &#123;</span><br><span class="line">        dispatch_source_cancel(_rollingTimer);</span><br><span class="line">        _rollingTimer = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_currentLogFileInfo == <span class="literal">nil</span> || _rollingFrequency &lt;= <span class="number">0.0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSDate</span> *logFileCreationDate = [_currentLogFileInfo creationDate];</span><br><span class="line">    <span class="built_in">NSTimeInterval</span> ti = [logFileCreationDate timeIntervalSinceReferenceDate];</span><br><span class="line">    ti += _rollingFrequency;</span><br><span class="line">    <span class="comment">//计算下一次检查的定时时间</span></span><br><span class="line">    <span class="built_in">NSDate</span> *logFileRollingDate = [<span class="built_in">NSDate</span> dateWithTimeIntervalSinceReferenceDate:ti];</span><br><span class="line">    _rollingTimer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, <span class="number">0</span>, <span class="number">0</span>, <span class="keyword">self</span>.loggerQueue);</span><br><span class="line">    dispatch_source_set_event_handler(_rollingTimer, ^&#123; <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">                                                           [<span class="keyword">self</span> maybeRollLogFileDueToAge];</span><br><span class="line">                                                       &#125; &#125;);</span><br><span class="line">    uint64_t delay = (uint64_t)([logFileRollingDate timeIntervalSinceNow] * (<span class="built_in">NSTimeInterval</span>) <span class="built_in">NSEC_PER_SEC</span>);</span><br><span class="line">    dispatch_time_t fireTime = dispatch_time(DISPATCH_TIME_NOW, delay);</span><br><span class="line">    dispatch_source_set_timer(_rollingTimer, fireTime, DISPATCH_TIME_FOREVER, <span class="number">1</span>ull * <span class="built_in">NSEC_PER_SEC</span>);</span><br><span class="line">    dispatch_resume(_rollingTimer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line">- (void)maybeRollLogFileDueToAge &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">_rollingFrequency</span> &gt; <span class="number">0.0</span> &amp;&amp; <span class="variable">_currentLogFileInfo</span>.age &gt;= <span class="variable">_rollingFrequency</span>) &#123;</span><br><span class="line">        [self rollLogFileNow];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        [self scheduleTimerToRollLogFileDueToAge];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)rollLogFileNow &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">_currentLogFileHandle</span> == <span class="literal">nil</span>) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="variable">_currentLogFileHandle</span> synchronizeFile];</span><br><span class="line">    [<span class="variable">_currentLogFileHandle</span> closeFile];</span><br><span class="line">    <span class="variable">_currentLogFileHandle</span> = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">    <span class="variable">_currentLogFileInfo</span>.isArchived = YES;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ([logFileManager respondsToSelector:@selector(didRollAndArchiveLogFile:)]) &#123;</span><br><span class="line">        [logFileManager didRollAndArchiveLogFile:(<span class="variable">_currentLogFileInfo</span>.filePath)];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="variable">_currentLogFileInfo</span> = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">_currentLogFileVnode</span>) &#123;</span><br><span class="line">        dispatch_source_cancel(<span class="variable">_currentLogFileVnode</span>);</span><br><span class="line">        <span class="variable">_currentLogFileVnode</span> = NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">_rollingTimer</span>) &#123;</span><br><span class="line">        dispatch_source_cancel(<span class="variable">_rollingTimer</span>);</span><br><span class="line">        <span class="variable">_rollingTimer</span> = NULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>scheduleTimerToRollLogFileDueToAge会查看文件的创建时间，然后在它的基础上加上_rollingFrequency，将它作为定时器的值定时，在这之后检查当前日志文件是否过期了，如果没有过期则再次进入下一轮。rollLogFileNow就是用于将文件归档。它会关闭文件句柄，_currentLogFileInfo.isArchived其实是这里最为关键的代码。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)setIsArchived:(<span class="type">BOOL</span>)flag &#123;</span><br><span class="line">    <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">        [<span class="keyword">self</span> addExtendedAttributeWithName:kDDXAttrArchivedName];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        [<span class="keyword">self</span> removeExtendedAttributeWithName:kDDXAttrArchivedName];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)addExtensionAttributeWithName:(<span class="built_in">NSString</span> *)attrName &#123;</span><br><span class="line">    <span class="comment">// This method is only used on the iPhone simulator, where normal extended attributes are broken.</span></span><br><span class="line">    <span class="comment">// See full explanation in the header file.</span></span><br><span class="line">    <span class="keyword">if</span> ([attrName length] == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Example:</span></span><br><span class="line">    <span class="comment">// attrName = &quot;archived&quot;</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// &quot;mylog.txt&quot; -&gt; &quot;mylog.archived.txt&quot;</span></span><br><span class="line">    <span class="comment">// &quot;mylog&quot;     -&gt; &quot;mylog.archived&quot;</span></span><br><span class="line">    <span class="built_in">NSArray</span> *components = [[<span class="keyword">self</span> fileName] componentsSeparatedByString:<span class="string">@&quot;.&quot;</span>];</span><br><span class="line">    <span class="built_in">NSUInteger</span> count = [components count];</span><br><span class="line">    <span class="built_in">NSUInteger</span> estimatedNewLength = [[<span class="keyword">self</span> fileName] length] + [attrName length] + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">NSMutableString</span> *newFileName = [<span class="built_in">NSMutableString</span> stringWithCapacity:estimatedNewLength];</span><br><span class="line">    <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        [newFileName appendString:components.firstObject];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSString</span> *lastExt = <span class="string">@&quot;&quot;</span>;</span><br><span class="line">    <span class="built_in">NSUInteger</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="built_in">NSString</span> *attr = components[i];</span><br><span class="line">        <span class="keyword">if</span> ([attr length] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ([attrName isEqualToString:attr]) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ([lastExt length] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            [newFileName appendFormat:<span class="string">@&quot;.%@&quot;</span>, lastExt];</span><br><span class="line">        &#125;</span><br><span class="line">        lastExt = attr;</span><br><span class="line">    &#125;</span><br><span class="line">    [newFileName appendFormat:<span class="string">@&quot;.%@&quot;</span>, attrName];</span><br><span class="line">    <span class="keyword">if</span> ([lastExt length] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        [newFileName appendFormat:<span class="string">@&quot;.%@&quot;</span>, lastExt];</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="keyword">self</span> renameFile:newFileName];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>它就是在文件名的最末尾添加一个archived标记，下一次再次调用currentLogFileInfo的时候就会略过这个文件。</p>
<p>到此为止已经带大家过了一遍CocoaLumberjack的核心源码了，至于DDASLLogger，DDOSLogger，以及DDTTYLogger这里就不再继续展开了，代码都很简单，但是这里还是要简单提下：</p>
<p><strong><strong>DDASLLogger</strong></strong><br>DDASLLogger会在初始化后通过asl_open来建立连接，通过asl_new创建一个新的消息，然后通过asl_set来设置一系列的属性，最后通过asl_send将日志发送出去。</p>
<p><strong><strong>DDOSLogger</strong></strong><br>DDOSLogger则是通过os_log_error，os_log_info，os_log_debug将日志发送出去的。</p>
<p><strong><strong>DDTTYLogger</strong></strong><br>DDTTYLogger是通过writev(STDERR_FILENO,…,….);将日志发送到StdError终端的。</p>
  
	</div>
		<footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/iOS-%E5%BC%80%E6%BA%90%E5%BA%93%E5%88%86%E6%9E%90/">iOS 开源库分析</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/iOS-开源库分析/">iOS 开源库分析</a>
  </div>

</div>



</footer>

   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2019/11/28/YTKNetWork源码解析/" title="YTKNetWork源码解析">
  <span>
  YTKNetWork源码解析</span>
</a>
</div>


<div class="next">
<a href="/2019/11/26/FBRetainCycleDetector-FBAllocationTracker-FBMemoryProfiler-源码解析/"  title=" FBRetainCycleDetector  FBAllocationTracker 源码解析">
 <span> FBRetainCycleDetector  FBAllocationTracker 源码解析
</span>
</a>
</div>

</nav>

	
<section id="comments" class="comment">
	<div class="ds-thread" data-thread-key="2019/11/28/日志库CocoaLumberjack-源码解析/" data-title="日志库CocoaLumberjack 源码解析" data-url="http://yoursite.com/2019/11/28/%E6%97%A5%E5%BF%97%E5%BA%93CocoaLumberjack-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"></div>
</section>


<section id="comments" class="comment">
  <div id="disqus_thread">
    <noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  </div>
</section>

</div>  
      <div class="openaside"><a class="navbutton" href="#" title="Show Sidebar"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">Contents</strong>
 
 <ol class="toc"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%80%E6%BA%90%E5%BA%93%E4%BF%A1%E6%81%AF"><span class="toc-number">1.</span> <span class="toc-text">开源库信息</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90"><span class="toc-number">2.</span> <span class="toc-text">源码解析</span></a></li></ol>
 
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="Hide Sidebar"></a></div>
<aside class="clearfix">
<div id="authorInfo">
	
		<div class="author-img"></div>		
	
	<div class="social-info" class="clearfix">
		
		
		<a href="https://github.com/tbfungeek" target="_blank" class="icon-github" title="github"></a>
		
		
		
		
		
		
		
		
		
		
		<a href="mailto:tbfungeek@163.com" target="_blank" class="icon-email" title="Email Me"></a>
		

	</div>
</div>

  
<div class="categorieslist">
	<p class="asidetitle">Categories</p>
		<ul>
		
		  
			<li><a href="/categories/Android-小经验/" title="Android 小经验">Android 小经验<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Android-源码分析/" title="Android 源码分析">Android 源码分析<sup>21</sup></a></li>
		  
		
		  
			<li><a href="/categories/Android其他/" title="Android其他">Android其他<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Android初步/" title="Android初步">Android初步<sup>21</sup></a></li>
		  
		
		  
			<li><a href="/categories/Android进阶/" title="Android进阶">Android进阶<sup>100</sup></a></li>
		  
		
		  
			<li><a href="/categories/Hexo-使用/" title="Hexo 使用">Hexo 使用<sup>10</sup></a></li>
		  
		
		  
			<li><a href="/categories/JavaScript理论/" title="JavaScript理论">JavaScript理论<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Objective-C-相关/" title="Objective C 相关">Objective C 相关<sup>24</sup></a></li>
		  
		
		  
			<li><a href="/categories/OpenCV/" title="OpenCV">OpenCV<sup>6</sup></a></li>
		  
		
		  
			<li><a href="/categories/ROS/" title="ROS">ROS<sup>9</sup></a></li>
		  
		
		  
			<li><a href="/categories/iOS-工具使用/" title="iOS 工具使用">iOS 工具使用<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/iOS-开源库分析/" title="iOS 开源库分析">iOS 开源库分析<sup>36</sup></a></li>
		  
		
		  
			<li><a href="/categories/iOS-理论基础/" title="iOS 理论基础">iOS 理论基础<sup>14</sup></a></li>
		  
		
		  
			<li><a href="/categories/iOS-进阶/" title="iOS 进阶">iOS 进阶<sup>4</sup></a></li>
		  
		
		  
			<li><a href="/categories/个人收藏/" title="个人收藏">个人收藏<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/代码规范/" title="代码规范">代码规范<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/其他/" title="其他">其他<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/博客分类目录/" title="博客分类目录">博客分类目录<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/叨叨系列/" title="叨叨系列">叨叨系列<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/开源代码分析/" title="开源代码分析">开源代码分析<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/开源库分析/" title="开源库分析">开源库分析<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/树莓派/" title="树莓派">树莓派<sup>4</sup></a></li>
		  
		
		  
			<li><a href="/categories/版本控制/" title="版本控制">版本控制<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/直播/" title="直播">直播<sup>6</sup></a></li>
		  
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">Tags</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/iOS-开源库分析/" title="iOS 开源库分析">iOS 开源库分析<sup>36</sup></a></li>
			
		
			
				<li><a href="/tags/Android-设计模式/" title="Android 设计模式">Android 设计模式<sup>29</sup></a></li>
			
		
			
				<li><a href="/tags/Objective-C-相关/" title="Objective C 相关">Objective C 相关<sup>24</sup></a></li>
			
		
			
				<li><a href="/tags/Android基础/" title="Android基础">Android基础<sup>21</sup></a></li>
			
		
			
				<li><a href="/tags/AOSP-源码/" title="AOSP 源码">AOSP 源码<sup>17</sup></a></li>
			
		
			
				<li><a href="/tags/Android-常用第三方库/" title="Android 常用第三方库">Android 常用第三方库<sup>15</sup></a></li>
			
		
			
				<li><a href="/tags/iOS-理论基础/" title="iOS 理论基础">iOS 理论基础<sup>14</sup></a></li>
			
		
			
				<li><a href="/tags/Hexo-使用/" title="Hexo 使用">Hexo 使用<sup>10</sup></a></li>
			
		
			
				<li><a href="/tags/ROS/" title="ROS">ROS<sup>9</sup></a></li>
			
		
			
				<li><a href="/tags/Android-动画进阶/" title="Android 动画进阶">Android 动画进阶<sup>8</sup></a></li>
			
		
			
				<li><a href="/tags/Android-JNI/" title="Android JNI">Android JNI<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/Android-绘图进阶/" title="Android 绘图进阶">Android 绘图进阶<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/Android性能优化/" title="Android性能优化">Android性能优化<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/Android-自动化测试/" title="Android 自动化测试">Android 自动化测试<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/OpenCV/" title="OpenCV">OpenCV<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/直播/" title="直播">直播<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/Android-开源源码/" title="Android 开源源码">Android 开源源码<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/Android-自定义View进阶/" title="Android 自定义View进阶">Android 自定义View进阶<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/树莓派/" title="树莓派">树莓派<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/iOS-进阶/" title="iOS 进阶">iOS 进阶<sup>4</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">Links</p>
    <ul>
        
          <li>
            
            	<a href="https://hexo.io" target="_blank" title="Hexo">Hexo</a>
            
          </li>
        
          <li>
            
            	<a href="https://pages.github.com/" target="_blank" title="GitHub">GitHub</a>
            
          </li>
        
          <li>
            
            	<a href="http://pf18.github.io/" target="_blank" title="PF18">PF18</a>
            
          </li>
        
          <li>
            
            	<a href="http://toutiao.io/" target="_blank" title="开发者头条">开发者头条</a>
            
          </li>
        
          <li>
            
            	<a href="http://www.jcodecraeer.com/" target="_blank" title="泡在网上的日子">泡在网上的日子</a>
            
          </li>
        
    </ul>
</div>

  


  <div class="rsspart">
	<a href="atom.xml" target="_blank" title="rss">RSS</a>
</div>

  
  <div class="tagcloudlist">
    <p class="asidetitle">Tag Cloud</p>
    <div class="tagcloudlist clearfix">
       <a href="/tags/AOSP-%E6%BA%90%E7%A0%81/" style="font-size: 17.14px;">AOSP 源码</a> <a href="/tags/Android-APK-%E7%AD%BE%E5%90%8D/" style="font-size: 10px;">Android APK 签名</a> <a href="/tags/Android-JNI/" style="font-size: 12.86px;">Android JNI</a> <a href="/tags/Android-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E8%BF%9B%E9%98%B6/" style="font-size: 10.71px;">Android 事件处理进阶</a> <a href="/tags/Android-%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6/" style="font-size: 13.57px;">Android 动画进阶</a> <a href="/tags/Android-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%80%E5%8F%91/" style="font-size: 10px;">Android 多线程开发</a> <a href="/tags/Android-%E5%B0%8F%E7%BB%8F%E9%AA%8C/" style="font-size: 10px;">Android 小经验</a> <a href="/tags/Android-%E5%B8%B8%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/" style="font-size: 16.43px;">Android 常用第三方库</a> <a href="/tags/Android-%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/" style="font-size: 10px;">Android 开发流程</a> <a href="/tags/Android-%E5%BC%80%E6%BA%90%E6%BA%90%E7%A0%81/" style="font-size: 12.14px;">Android 开源源码</a> <a href="/tags/Android-%E7%BB%98%E5%9B%BE%E8%BF%9B%E9%98%B6/" style="font-size: 12.86px;">Android 绘图进阶</a> <a href="/tags/Android-%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/" style="font-size: 12.86px;">Android 自动化测试</a> <a href="/tags/Android-%E8%87%AA%E5%AE%9A%E4%B9%89View%E8%BF%9B%E9%98%B6/" style="font-size: 12.14px;">Android 自定义View进阶</a> <a href="/tags/Android-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 19.29px;">Android 设计模式</a> <a href="/tags/Android%E5%85%B6%E4%BB%96/" style="font-size: 10px;">Android其他</a> <a href="/tags/Android%E5%9F%BA%E7%A1%80/" style="font-size: 17.86px;">Android基础</a> <a href="/tags/Android%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/" style="font-size: 10px;">Android开发流程</a> <a href="/tags/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" style="font-size: 12.86px;">Android性能优化</a> <a href="/tags/Android%E6%B7%B7%E6%B7%86%E6%8A%80%E6%9C%AF/" style="font-size: 10px;">Android混淆技术</a> <a href="/tags/Android%E8%B4%A8%E9%87%8F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/" style="font-size: 11.43px;">Android质量管理工具</a> <a href="/tags/Android%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/" style="font-size: 10px;">Android逆向工程</a> <a href="/tags/Git-github/" style="font-size: 10px;">Git && github</a> <a href="/tags/Hexo-%E4%BD%BF%E7%94%A8/" style="font-size: 15px;">Hexo 使用</a> <a href="/tags/JavaScript/" style="font-size: 10px;">JavaScript</a> <a href="/tags/Linux-%E4%BD%BF%E7%94%A8/" style="font-size: 10px;">Linux 使用</a> <a href="/tags/Objective-C-%E7%9B%B8%E5%85%B3/" style="font-size: 18.57px;">Objective C 相关</a> <a href="/tags/OpenCV/" style="font-size: 12.86px;">OpenCV</a> <a href="/tags/ROS/" style="font-size: 14.29px;">ROS</a> <a href="/tags/iOS-%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/" style="font-size: 10.71px;">iOS 工具使用</a> <a href="/tags/iOS-%E5%BC%80%E6%BA%90%E5%BA%93%E5%88%86%E6%9E%90/" style="font-size: 20px;">iOS 开源库分析</a> <a href="/tags/iOS-%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/" style="font-size: 15.71px;">iOS 理论基础</a> <a href="/tags/iOS-%E8%BF%9B%E9%98%B6/" style="font-size: 12.14px;">iOS 进阶</a> <a href="/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/" style="font-size: 10px;">代码规范</a> <a href="/tags/%E5%8D%9A%E5%AE%A2%E5%88%86%E7%B1%BB%E7%9B%AE%E5%BD%95/" style="font-size: 10.71px;">博客分类目录</a> <a href="/tags/%E5%8F%A8%E5%8F%A8%E7%B3%BB%E5%88%97/" style="font-size: 10px;">叨叨系列</a> <a href="/tags/%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/" style="font-size: 11.43px;">工具的使用</a> <a href="/tags/%E5%BC%80%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/" style="font-size: 10.71px;">开源代码分析</a> <a href="/tags/%E5%BC%80%E6%BA%90%E5%BA%93%E5%88%86%E6%9E%90/" style="font-size: 10px;">开源库分析</a> <a href="/tags/%E6%9D%82%E7%B1%BB/" style="font-size: 10px;">杂类</a> <a href="/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/" style="font-size: 12.14px;">树莓派</a> <a href="/tags/%E7%9B%B4%E6%92%AD/" style="font-size: 12.86px;">直播</a> <a href="/tags/%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/" style="font-size: 10.71px;">编程技巧</a> <a href="/tags/%E7%BD%91%E7%AB%99%E6%94%B6%E8%97%8F/" style="font-size: 10px;">网站收藏</a> <a href="/tags/%E9%87%8D%E8%A6%81%E6%8E%A7%E4%BB%B6/" style="font-size: 11.43px;">重要控件</a>
    </div>
  </div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
		
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/hsihohuang/kiddochan" target="_blank" title="Kiddochan">Kiddochan</a> © 2022 
		
		<a href="/about" target="_blank" title="Edgar">Edgar</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
        getSize();
        if (myWidth >= 1024) {
          c.click();
        }
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  c.click(function(){
    ta.css('display', 'block').addClass('fadeIn');
  });
  o.click(function(){
    ta.css('display', 'none');
  });
  $(window).scroll(function(){
    ta.css("top",Math.max(140,320-$(this).scrollTop()));
  });
});
</script>




<script type="text/javascript">
  var duoshuoQuery = {short_name:"tbfungeek"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script> 


<script type="text/javascript">

var disqus_shortname = 'tbfungeek';

(function(){
  var dsq = document.createElement('script');
  dsq.type = 'text/javascript';
  dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
}());
(function(){
  var dsq = document.createElement('script');
  dsq.type = 'text/javascript';
  dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/count.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
}());
</script>






<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?7c9443b0374f1cf6b1dbb5ab84d939cb";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="Back to Top"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
</html>
