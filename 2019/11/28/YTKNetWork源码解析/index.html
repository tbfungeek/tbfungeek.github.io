
 <!DOCTYPE HTML>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
  
    <title>YTKNetWork源码解析 | Edgar&#39;s Blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="Edgar">
    

    
    <meta name="description" content="开源代码信息开源地址 YTKNetwork是基于AFNetworking封装的iOS网络库，它在AFNetworking的基础上提供了如下的功能：   支持按时间缓存网络请求内容 支持按版本号缓存网络请求内容 支持统一设置服务器和 CDN 的地址 支持检查返回 JSON 内容的合法性 支持文件的断点续传 支持 block 和 delegate 两种模式的回调方式 支持批量的网络请求发送，并统一设置">
<meta property="og:type" content="article">
<meta property="og:title" content="YTKNetWork源码解析">
<meta property="og:url" content="http://yoursite.com/2019/11/28/YTKNetWork%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/index.html">
<meta property="og:site_name" content="Edgar&#39;s Blog">
<meta property="og:description" content="开源代码信息开源地址 YTKNetwork是基于AFNetworking封装的iOS网络库，它在AFNetworking的基础上提供了如下的功能：   支持按时间缓存网络请求内容 支持按版本号缓存网络请求内容 支持统一设置服务器和 CDN 的地址 支持检查返回 JSON 内容的合法性 支持文件的断点续传 支持 block 和 delegate 两种模式的回调方式 支持批量的网络请求发送，并统一设置">
<meta property="og:locale">
<meta property="og:image" content="http://yoursite.com/2019/11/28/YTKNetWork%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/00001.png">
<meta property="article:published_time" content="2019-11-27T18:23:58.000Z">
<meta property="article:modified_time" content="2019-12-19T13:46:08.000Z">
<meta property="article:author" content="Edgar">
<meta property="article:tag" content="iOS 开源库分析">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/2019/11/28/YTKNetWork%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/00001.png">

    
    <link rel="alternative" href="atom.xml" title="Edgar&#39;s Blog" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/unnamed4_n_mSY_icon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/profile.png">
    <link rel="apple-touch-icon-precomposed" href="/img/profile.png">
    
    
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 6.2.0"></head>

  <body>
    <header>
      
<div>
		
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="Edgar&#39;s Blog">Edgar&#39;s Blog</a></h1>
				<h2 class="blog-motto"></h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="Menu">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
					<li>
 					
					<form class="search" action="/search/index.html" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" autocomplete="off" name="q" maxlength="20" placeholder="Search" />
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
  
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/11/28/YTKNetWork源码解析/" title="YTKNetWork源码解析" itemprop="url">YTKNetWork源码解析</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Edgar" target="_blank" itemprop="author">Edgar</a>
		
  <p class="article-time">
    <time datetime="2019-11-27T18:23:58.000Z" itemprop="datePublished"> Published 2019-11-28</time>
    
  </p>
</header>
	<div class="article-content">
		
		<h4 id="开源代码信息"><a href="#开源代码信息" class="headerlink" title="开源代码信息"></a>开源代码信息</h4><p><a target="_blank" rel="noopener" href="https://github.com/yuantiku/YTKNetwork">开源地址</a></p>
<p>YTKNetwork是基于AFNetworking封装的iOS网络库，它在AFNetworking的基础上提供了如下的功能：</p>
<blockquote>
<ul>
<li>支持按时间缓存网络请求内容</li>
<li>支持按版本号缓存网络请求内容</li>
<li>支持统一设置服务器和 CDN 的地址</li>
<li>支持检查返回 JSON 内容的合法性</li>
<li>支持文件的断点续传</li>
<li>支持 block 和 delegate 两种模式的回调方式</li>
<li>支持批量的网络请求发送，并统一设置它们的回调（实现在 YTKBatchRequest 类中）</li>
<li>支持方便地设置有相互依赖的网络请求的发送，例如：发送请求 A，根据请求 A 的结果，选择性的发送请求 B 和 C，再根据 B 和 C 的结果，选择性的发送请求 D。（实现在 YTKChainRequest 类中）</li>
<li>支持网络请求 URL 的 filter，可以统一为网络请求加上一些参数，或者修改一些路径。</li>
<li>定义了一套插件机制，可以很方便地为 YTKNetwork 增加功能。猿题库官方现在提供了一个插件，可以在某些网络请求发起时，在界面上显示“正在加载”的 HUD。</li>
</ul>
</blockquote>
<h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><p>YTKNetWork 整个代码量不是很大，整个代码结构如下所示：<br><img src="/2019/11/28/YTKNetWork%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/00001.png"></p>
<p>在整个请求过程中都是围绕着Request展开，这里需要注意的是YTKBatchRequest以及YTKChainRequest并不继承自YTKBaseRequest，它其实是通过请求数组requestArray来管理请求的形式，所以个人觉得这两个类的命名不是很合理，很容易让人以为它们和YTKRequest一样都是继承自YTKBaseRequest。另一个个人觉得不是很合理的地方是它将全部的数据都放到YTKRequest，会显得庞大且乱。</p>
<p>这篇博客将通过如下几个方面对YTKNetWork源码进行解析：</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="bullet">* </span>YTKRequest &amp;&amp; YTKBaseRequest 的组成</span><br><span class="line"><span class="bullet">* </span>基本请求过程</span><br><span class="line"><span class="bullet">* </span>批量请求</span><br><span class="line"><span class="bullet">* </span>链式请求</span><br><span class="line"><span class="bullet">* </span>缓存机制</span><br><span class="line"><span class="bullet">* </span>断点续传</span><br><span class="line"><span class="bullet">* </span>URL filter</span><br><span class="line"><span class="bullet">* </span>插件机制</span><br></pre></td></tr></table></figure>

<h5 id="1-YTKRequest-amp-amp-YTKBaseRequest-的组成"><a href="#1-YTKRequest-amp-amp-YTKBaseRequest-的组成" class="headerlink" title="1. YTKRequest &amp;&amp; YTKBaseRequest 的组成"></a>1. YTKRequest &amp;&amp; YTKBaseRequest 的组成</h5><p><strong><strong>YTKRequest</strong></strong></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YTKBaseRequest</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> mark - Request and Response Information</span></span><br><span class="line"><span class="comment">///=============================================================================</span></span><br><span class="line"><span class="comment">/// @name Request and Response Information</span></span><br><span class="line"><span class="comment">///=============================================================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">///  当前请求执行所使用的NSURLSessionTask，在请求start之前不应该调用这个值，因为这时候这个值为nil</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="built_in">NSURLSessionTask</span> *requestTask;</span><br><span class="line"><span class="comment">///  requestTask.currentRequest的快捷访问方式</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="built_in">NSURLRequest</span> *currentRequest;</span><br><span class="line"><span class="comment">///  requestTask.originalRequest的快捷访问方式</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="built_in">NSURLRequest</span> *originalRequest;</span><br><span class="line"><span class="comment">///  requestTask.response的快捷访问方式.</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="built_in">NSHTTPURLResponse</span> *response;</span><br><span class="line"><span class="comment">///  返回体状态码</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSInteger</span> responseStatusCode;</span><br><span class="line"><span class="comment">///  头信息</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>, <span class="keyword">nullable</span>) <span class="built_in">NSDictionary</span> *responseHeaders;</span><br><span class="line"><span class="comment">///  response的原始信息，在失败的时候值为nil</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>, <span class="keyword">nullable</span>) <span class="built_in">NSData</span> *responseData;</span><br><span class="line"><span class="comment">///  response的字符串形式信息，在失败的时候值为nil</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>, <span class="keyword">nullable</span>) <span class="built_in">NSString</span> *responseString;</span><br><span class="line"><span class="comment">///  序列化后的结果对象，在下载的情景下并且在使用resumableDownloadPath的时候，这个值代表文件存放的地址</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>, <span class="keyword">nullable</span>) <span class="type">id</span> responseObject;</span><br><span class="line"><span class="comment">///  JSON形式的结果</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>, <span class="keyword">nullable</span>) <span class="type">id</span> responseJSONObject;</span><br><span class="line"><span class="comment">// 错误信息</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>, <span class="keyword">nullable</span>) <span class="built_in">NSError</span> *error;</span><br><span class="line"><span class="comment">///  当前请求是否被取消</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">getter</span>=isCancelled) <span class="type">BOOL</span> cancelled;</span><br><span class="line"><span class="comment">///  当前请求是否正在执行</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">getter</span>=isExecuting) <span class="type">BOOL</span> executing;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> mark - Request Configuration</span></span><br><span class="line"><span class="comment">///=============================================================================</span></span><br><span class="line"><span class="comment">/// @name Request Configuration</span></span><br><span class="line"><span class="comment">///=============================================================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">///  用于标示一个请求的 tag</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">NSInteger</span> tag;</span><br><span class="line"><span class="comment">///  用于存储关于请求的额外信息</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">nullable</span>) <span class="built_in">NSDictionary</span> *userInfo;</span><br><span class="line"><span class="comment">/// 请求代理，如果选择用block方式来交付数据可以忽略这个值</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>, <span class="keyword">nullable</span>) <span class="type">id</span>&lt;YTKRequestDelegate&gt; delegate;</span><br><span class="line"><span class="comment">/// 请求成功后将会调用的Block,如果delegate以及block都指定都话会先调用delegate然后再调用block，并且这个block会在主线程调用</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">nullable</span>) YTKRequestCompletionBlock successCompletionBlock;</span><br><span class="line"><span class="comment">/// 请求失败都时候调用的Block，规则同successCompletionBlock</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">nullable</span>) YTKRequestCompletionBlock failureCompletionBlock;</span><br><span class="line"><span class="comment">/// 当前请求所添加的插件</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">nullable</span>) <span class="built_in">NSMutableArray</span>&lt;<span class="type">id</span>&lt;YTKRequestAccessory&gt;&gt; *requestAccessories;</span><br><span class="line"><span class="comment">///  用于POST形式下组装请求body的block</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">nullable</span>) AFConstructingBlock constructingBodyBlock;</span><br><span class="line"><span class="comment">/// 这个用于断点续传的情况，用于表示下载的临时文件的存放路径。在请求start之前将会删除这些文件，如果下载成功文件将会自动下载到这个路径，否则下载结果将会保存到</span></span><br><span class="line"><span class="comment">/// responseData，responseString。</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">nullable</span>) <span class="built_in">NSString</span> *resumableDownloadPath;</span><br><span class="line"><span class="comment">///  用于跟踪文件的下载进度</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">nullable</span>) AFURLSessionTaskProgressBlock resumableDownloadProgressBlock;</span><br><span class="line"><span class="comment">///  请求优先级</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) YTKRequestPriority requestPriority;</span><br><span class="line"><span class="comment">///  请求完成的回调block</span></span><br><span class="line">- (<span class="type">void</span>)setCompletionBlockWithSuccess:(<span class="keyword">nullable</span> YTKRequestCompletionBlock)success</span><br><span class="line">                              failure:(<span class="keyword">nullable</span> YTKRequestCompletionBlock)failure;</span><br><span class="line"><span class="comment">///  清除回调完成后结果交付block</span></span><br><span class="line">- (<span class="type">void</span>)clearCompletionBlock;</span><br><span class="line"><span class="comment">/// 添加插件</span></span><br><span class="line">- (<span class="type">void</span>)addAccessory:(<span class="type">id</span>&lt;YTKRequestAccessory&gt;)accessory;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> mark - Request Action</span></span><br><span class="line"><span class="comment">///=============================================================================</span></span><br><span class="line"><span class="comment">/// @name Request Action</span></span><br><span class="line"><span class="comment">///=============================================================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">///  开始请求</span></span><br><span class="line">- (<span class="type">void</span>)start;</span><br><span class="line"><span class="comment">///  停止请求</span></span><br><span class="line">- (<span class="type">void</span>)stop;</span><br><span class="line"><span class="comment">///  开始请求</span></span><br><span class="line">- (<span class="type">void</span>)startWithCompletionBlockWithSuccess:(<span class="keyword">nullable</span> YTKRequestCompletionBlock)success</span><br><span class="line">                                    failure:(<span class="keyword">nullable</span> YTKRequestCompletionBlock)failure;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> mark - Subclass Override</span></span><br><span class="line"><span class="comment">///=============================================================================</span></span><br><span class="line"><span class="comment">/// @name Subclass Override</span></span><br><span class="line"><span class="comment">///=============================================================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">///  在后台获得到数据但是尚未切换到主线程之前调用这个方法。</span></span><br><span class="line">- (<span class="type">void</span>)requestCompletePreprocessor;</span><br><span class="line"><span class="comment">///  在请求成功并且切换到主线程后调用这个方法</span></span><br><span class="line">- (<span class="type">void</span>)requestCompleteFilter;</span><br><span class="line"><span class="comment">///  在后台请求失败但是尚未切换到主线程之前调用这个方法。</span></span><br><span class="line">- (<span class="type">void</span>)requestFailedPreprocessor;</span><br><span class="line"><span class="comment">///  请求失败并且切换到主线程后调用这个方法</span></span><br><span class="line">- (<span class="type">void</span>)requestFailedFilter;</span><br><span class="line"><span class="comment">/// URL的host部分 比如 http://www.example.com.</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)baseUrl;</span><br><span class="line"><span class="comment">/// 它可以有两种形式，一种是全路径形式，这时候就会忽略baseUrl直接使用requestUrl，</span></span><br><span class="line"><span class="comment">/// 另一种是这个值只包含url的路径信息比如/v1/user，这时候会将requestUrl与baseUrl进行拼接</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)requestUrl;</span><br><span class="line"><span class="comment">///  cdn地址</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)cdnUrl;</span><br><span class="line"><span class="comment">///  请求的超时时间默认是60s</span></span><br><span class="line">- (<span class="built_in">NSTimeInterval</span>)requestTimeoutInterval;</span><br><span class="line"><span class="comment">///  额外的请求参数，GET的时候添加到路径上,POST的时候添加到body</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="type">id</span>)requestArgument;</span><br><span class="line"><span class="comment">///  HTTP 请求方式</span></span><br><span class="line">- (YTKRequestMethod)requestMethod;</span><br><span class="line"><span class="comment">///  请求序列化类型</span></span><br><span class="line">- (YTKRequestSerializerType)requestSerializerType;</span><br><span class="line"><span class="comment">///  结构体序列化类型</span></span><br><span class="line">- (YTKResponseSerializerType)responseSerializerType;</span><br><span class="line"><span class="comment">///  HTTP 认证参数数组</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *)requestAuthorizationHeaderFieldArray;</span><br><span class="line"><span class="comment">///  额外的请求头</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="built_in">NSString</span> *&gt; *)requestHeaderFieldValueDictionary;</span><br><span class="line"><span class="comment">/// 用于构建自定义请求，如果这个返回值为非空，那么上面所有用于构建请求的就全部被忽略，而统一使用这个请求</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSURLRequest</span> *)buildCustomUrlRequest;</span><br><span class="line"><span class="comment">///  是否使用cdn</span></span><br><span class="line">- (<span class="type">BOOL</span>)useCDN;</span><br><span class="line"><span class="comment">///  是否允许使用蜂窝网络</span></span><br><span class="line">- (<span class="type">BOOL</span>)allowsCellularAccess;</span><br><span class="line"><span class="comment">///  用于校验responseJSONObject结构</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="type">id</span>)jsonValidator;</span><br><span class="line"><span class="comment">///  用于校验responseStatusCode</span></span><br><span class="line">- (<span class="type">BOOL</span>)statusCodeValidator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong><strong>YTKRequest</strong></strong></p>
<p>YTKRequest主要是在YTKBaseRequest添加了缓存的相关管理。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YTKRequest</span> : <span class="title">YTKBaseRequest</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 是否忽略缓存结果，需要注意的是cacheTimeInSeconds默认值为-1所以如果我们没有明确给出一个cacheTimeInSeconds值的话实际上我们还是会忽略缓存</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="type">BOOL</span> ignoreCache;</span><br><span class="line"></span><br><span class="line"><span class="comment">///  判断当前返回的数据是否是从缓存中获取而来</span></span><br><span class="line">- (<span class="type">BOOL</span>)isDataFromCache;</span><br><span class="line"></span><br><span class="line"><span class="comment">///手动从存储中加载缓存</span></span><br><span class="line">- (<span class="type">BOOL</span>)loadCacheWithError:(<span class="built_in">NSError</span> * __autoreleasing *)error;</span><br><span class="line"></span><br><span class="line"><span class="comment">///以忽略缓存的形式启动请求，这个一般用于更新缓存数据</span></span><br><span class="line">- (<span class="type">void</span>)startWithoutCache;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 缓存返回数据到缓存文件</span></span><br><span class="line">- (<span class="type">void</span>)saveResponseDataToCacheFile:(<span class="built_in">NSData</span> *)data;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> mark - Subclass Override</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 缓存时间</span></span><br><span class="line">- (<span class="built_in">NSInteger</span>)cacheTimeInSeconds;</span><br><span class="line"></span><br><span class="line"><span class="comment">///  缓存版本</span></span><br><span class="line">- (<span class="type">long</span> <span class="type">long</span>)cacheVersion;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="type">id</span>)cacheSensitiveData;</span><br><span class="line"></span><br><span class="line"><span class="comment">///  是否异步写缓存</span></span><br><span class="line">- (<span class="type">BOOL</span>)writeCacheAsynchronously;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="2-基本请求过程"><a href="#2-基本请求过程" class="headerlink" title="2. 基本请求过程"></a>2. 基本请求过程</h5><p>基本请求这块代码都放在YTKBaseRequest以及YTKNetworkAgent中，YTKBaseRequest会将实际的处理封装在YTKNetworkAgent，我们就来看下这部分代码：</p>
<p><strong><strong>请求的发起</strong></strong></p>
<p>一般请求我们会通过startWithCompletionBlockWithSuccess来执行：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">- (void)startWithCompletionBlockWithSuccess:(YTKRequestCompletionBlock)success</span><br><span class="line">                                    failure:(YTKRequestCompletionBlock)failure &#123;</span><br><span class="line">    <span class="comment">//设置successBlock 以及failureBlock</span></span><br><span class="line">    <span class="selector-attr">[self setCompletionBlockWithSuccess:success failure:failure]</span>;</span><br><span class="line">    <span class="comment">//启动请求</span></span><br><span class="line">    <span class="selector-attr">[self start]</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)start &#123;</span><br><span class="line">    <span class="comment">//通知插件将要开始请求</span></span><br><span class="line">    <span class="selector-attr">[self toggleAccessoriesWillStartCallBack]</span>;</span><br><span class="line">    <span class="comment">//将请求添加到YTKNetworkAgent</span></span><br><span class="line">    <span class="selector-attr">[[YTKNetworkAgent sharedAgent]</span> addRequest:self];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请求过程中会先设置成功，失败结果返回的block，然后通知插件请求将要开始了，插件可以根据实际需求做对应处理，比如显示加载动画等，然后就将请求传递给YTKNetworkAgent。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)addRequest:(YTKBaseRequest *)request &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSError</span> * __autoreleasing requestSerializationError = <span class="literal">nil</span>;</span><br><span class="line">    <span class="comment">//如果请求中有自定义的url则使用自定义的NSURLRequest创建对应的NSURLSessionDataTask</span></span><br><span class="line">    <span class="built_in">NSURLRequest</span> *customUrlRequest= [request buildCustomUrlRequest];</span><br><span class="line">    <span class="keyword">if</span> (customUrlRequest) &#123;</span><br><span class="line">        __block <span class="built_in">NSURLSessionDataTask</span> *dataTask = <span class="literal">nil</span>;</span><br><span class="line">        dataTask = [_manager dataTaskWithRequest:customUrlRequest completionHandler:^(<span class="built_in">NSURLResponse</span> * _Nonnull response, <span class="type">id</span>  _Nullable responseObject, <span class="built_in">NSError</span> * _Nullable error) &#123;</span><br><span class="line">            [<span class="keyword">self</span> handleRequestResult:dataTask responseObject:responseObject error:error];</span><br><span class="line">        &#125;];</span><br><span class="line">        request.requestTask = dataTask;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//直接通过sessionTaskForRequest获取NSURLSessionDataTask</span></span><br><span class="line">        request.requestTask = [<span class="keyword">self</span> sessionTaskForRequest:request error:&amp;requestSerializationError];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (requestSerializationError) &#123;</span><br><span class="line">        [<span class="keyword">self</span> requestDidFailWithRequest:request error:requestSerializationError];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置请求的优先级</span></span><br><span class="line">    <span class="keyword">if</span> ([request.requestTask respondsToSelector:<span class="keyword">@selector</span>(priority)]) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (request.requestPriority) &#123;</span><br><span class="line">            <span class="keyword">case</span> YTKRequestPriorityHigh:</span><br><span class="line">                request.requestTask.priority = <span class="built_in">NSURLSessionTaskPriorityHigh</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> YTKRequestPriorityLow:</span><br><span class="line">                request.requestTask.priority = <span class="built_in">NSURLSessionTaskPriorityLow</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> YTKRequestPriorityDefault:</span><br><span class="line">                <span class="comment">/*!!fall through*/</span></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                request.requestTask.priority = <span class="built_in">NSURLSessionTaskPriorityDefault</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Retain request</span></span><br><span class="line">    [<span class="keyword">self</span> addRequestToRecord:request];</span><br><span class="line">    <span class="comment">//启动请求</span></span><br><span class="line">    [request.requestTask resume];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在YTKNetworkAgent中我们首先会看下是否开发者在对应等request中重写了<strong><strong>buildCustomUrlRequest</strong></strong>方法，如果是的话则通过这个返回的request 生成NSURLSessionDataTask,否则使用传入的request通过调用sessionTaskForRequest生成NSURLSessionDataTask,紧接着给请求设置优先级，并且保持请求引用。然后开启请求。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="operator">-</span> (<span class="type">NSURLSessionTask</span> <span class="operator">*</span>)sessionTaskForRequest:(<span class="type">YTKBaseRequest</span> <span class="operator">*</span>)request error:(<span class="type">NSError</span> <span class="operator">*</span> _Nullable __autoreleasing <span class="operator">*</span>)error &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 取出请求方法</span></span><br><span class="line">    <span class="type">YTKRequestMethod</span> method <span class="operator">=</span> [request requestMethod];</span><br><span class="line">    <span class="comment">// 构建URL</span></span><br><span class="line">    <span class="type">NSString</span> <span class="operator">*</span>url <span class="operator">=</span> [<span class="keyword">self</span> buildRequestUrl:request];</span><br><span class="line">    <span class="comment">// 准备请求参数</span></span><br><span class="line">    id param <span class="operator">=</span> request.requestArgument;</span><br><span class="line">    <span class="comment">// 构建POST请求体Block</span></span><br><span class="line">    <span class="type">AFConstructingBlock</span> constructingBlock <span class="operator">=</span> [request constructingBodyBlock];</span><br><span class="line">    <span class="comment">// 通过请求来构建请求序列化器</span></span><br><span class="line">    <span class="type">AFHTTPRequestSerializer</span> <span class="operator">*</span>requestSerializer <span class="operator">=</span> [<span class="keyword">self</span> requestSerializerForRequest:request];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过请求方法来构建出不同的NSURLSessionTask</span></span><br><span class="line">    <span class="keyword">switch</span> (method) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="type">YTKRequestMethodGET</span>:</span><br><span class="line">            <span class="keyword">if</span> (request.resumableDownloadPath) &#123;</span><br><span class="line">                <span class="keyword">return</span> [<span class="keyword">self</span> downloadTaskWithDownloadPath:request.resumableDownloadPath</span><br><span class="line">                                        requestSerializer:requestSerializer</span><br><span class="line">                                                <span class="type">URLString</span>:url </span><br><span class="line">                                                parameters:param</span><br><span class="line">                                                 progress:request.resumableDownloadProgressBlock</span><br><span class="line">                                                    error:error];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> [<span class="keyword">self</span> dataTaskWithHTTPMethod:@<span class="string">&quot;GET&quot;</span></span><br><span class="line">                                  requestSerializer:requestSerializer</span><br><span class="line">                                          <span class="type">URLString</span>:url </span><br><span class="line">                                          parameters:param </span><br><span class="line">                                          error:error];</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="type">YTKRequestMethodPOST</span>:</span><br><span class="line">            <span class="keyword">return</span> [<span class="keyword">self</span> dataTaskWithHTTPMethod:@<span class="string">&quot;POST&quot;</span> requestSerializer:requestSerializer <span class="type">URLString</span>:url parameters:param constructingBodyWithBlock:constructingBlock error:error];</span><br><span class="line">        <span class="keyword">case</span> <span class="type">YTKRequestMethodHEAD</span>:</span><br><span class="line">            <span class="keyword">return</span> [<span class="keyword">self</span> dataTaskWithHTTPMethod:@<span class="string">&quot;HEAD&quot;</span> requestSerializer:requestSerializer <span class="type">URLString</span>:url parameters:param error:error];</span><br><span class="line">        <span class="keyword">case</span> <span class="type">YTKRequestMethodPUT</span>:</span><br><span class="line">            <span class="keyword">return</span> [<span class="keyword">self</span> dataTaskWithHTTPMethod:@<span class="string">&quot;PUT&quot;</span> requestSerializer:requestSerializer <span class="type">URLString</span>:url parameters:param error:error];</span><br><span class="line">        <span class="keyword">case</span> <span class="type">YTKRequestMethodDELETE</span>:</span><br><span class="line">            <span class="keyword">return</span> [<span class="keyword">self</span> dataTaskWithHTTPMethod:@<span class="string">&quot;DELETE&quot;</span> requestSerializer:requestSerializer <span class="type">URLString</span>:url parameters:param error:error];</span><br><span class="line">        <span class="keyword">case</span> <span class="type">YTKRequestMethodPATCH</span>:</span><br><span class="line">            <span class="keyword">return</span> [<span class="keyword">self</span> dataTaskWithHTTPMethod:@<span class="string">&quot;PATCH&quot;</span> requestSerializer:requestSerializer <span class="type">URLString</span>:url parameters:param error:error];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在sessionTaskForRequest方法会将YTKBaseRequest中的一系列配置拆开，通过在YTKBaseRequest中的配置来创建不同请求方法下的dataTask。首先看下请求url的构建策略：</p>
<p>请求url的构建是通过<strong><strong>buildRequestUrl</strong></strong>来实现的</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *)buildRequestUrl:(YTKBaseRequest *)request &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取请求的requestUrl使用它来构建出一个NSURL对象</span></span><br><span class="line">    <span class="built_in">NSString</span> *detailUrl = [request requestUrl];</span><br><span class="line">    <span class="built_in">NSURL</span> *temp = [<span class="built_in">NSURL</span> URLWithString:detailUrl];</span><br><span class="line">    <span class="comment">// 检查构建出来的URL是否是完整的URL请求</span></span><br><span class="line">    <span class="keyword">if</span> (temp &amp;&amp; temp.host &amp;&amp; temp.scheme) &#123;</span><br><span class="line">        <span class="keyword">return</span> detailUrl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对构建出来的URL通过Config中预设的urlFilters 一一对它进行处理，比如添加公共字段等</span></span><br><span class="line">    <span class="built_in">NSArray</span> *filters = [_config urlFilters];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">id</span>&lt;YTKUrlFilterProtocol&gt; f <span class="keyword">in</span> filters) &#123;</span><br><span class="line">        detailUrl = [f filterUrl:detailUrl withRequest:request];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构建baseUrl 如果使用CDN，并且cdnUrl有值，则baseUrl为cdnUrl，</span></span><br><span class="line">    <span class="comment">//如果不使用CDN则优先使用当前request的baseUrl否则使用公共配置中的baseUrl</span></span><br><span class="line">    <span class="built_in">NSString</span> *baseUrl;</span><br><span class="line">    <span class="keyword">if</span> ([request useCDN]) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([request cdnUrl].length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            baseUrl = [request cdnUrl];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            baseUrl = [_config cdnUrl];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ([request baseUrl].length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            baseUrl = [request baseUrl];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            baseUrl = [_config baseUrl];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// URL slash compability</span></span><br><span class="line">    <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:baseUrl];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (baseUrl.length &gt; <span class="number">0</span> &amp;&amp; ![baseUrl hasSuffix:<span class="string">@&quot;/&quot;</span>]) &#123;</span><br><span class="line">        url = [url URLByAppendingPathComponent:<span class="string">@&quot;&quot;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将当前的baseUrl与detailUrl进行拼接</span></span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSURL</span> URLWithString:detailUrl relativeToURL:url].absoluteString;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先会先取requestUrl看下是不是一个完整的URL请求，如果是的话就直接将这个作为请求返回，紧接着会从YTKNetWorkConfig中获取预设的urlFilters，一一对它进行处理，比如添加公共字段等。最终形成一个处理后的不包括scheme，host的URL。</p>
<p>接下来就是构建baseUrl的过程，这个顺序如下：</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">request</span> --&gt;</span> <span class="function"><span class="title">cdnUrl</span>  &gt;  _config ---&gt;</span> <span class="function"><span class="title">cdnUrl</span>  &gt; request---&gt;</span> <span class="function"><span class="title">baseUrl</span> &gt; _config ---&gt;</span> baseUrl</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>总结来说就是能使用cdn的优先使用cdn的地址，不能使用的时候再选用baseUrl中的地址，能使用request的优先使用request的，没有的话使用config中的。最后将detailUrl和baseUrl进行拼接形成最终的地址。所以整个地址包含三个部分，一个是baseUrl,一个是requestUrl,然后是各个filter添加的信息。</p>
<p>接下来看下dataTask的创建这里分成三类，一个是GET方式，一个是POST方式，一个是download方式：</p>
<p><strong><strong>GET</strong></strong></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">[<span class="built_in">self</span> dataTaskWithHTTPMethod:@<span class="string">&quot;GET&quot;</span> requestSerializer:requestSerializer URLString:url parameters:param <span class="built_in">error</span>:<span class="built_in">error</span>];</span><br></pre></td></tr></table></figure>

<p><strong><strong>POST</strong></strong></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">[<span class="built_in">self</span> dataTaskWithHTTPMethod:@<span class="string">&quot;POST&quot;</span> requestSerializer:requestSerializer URLString:url parameters:param constructingBodyWithBlock:constructingBlock <span class="built_in">error</span>:<span class="built_in">error</span>];</span><br></pre></td></tr></table></figure>

<p><strong><strong>DOWNLOAD</strong></strong></p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line">[self downloadTaskWithDownloadPath:request.resumableDownloadPath</span><br><span class="line"><span class="symbol">                                        requestSerializer:</span>requestSerializer</span><br><span class="line"><span class="symbol">                                                URLString:</span>url parameters:param</span><br><span class="line"><span class="symbol">                                                 progress:</span>request.resumableDownloadProgressBlock</span><br><span class="line"><span class="symbol">                                                    error:</span>error]<span class="punctuation">;</span></span><br></pre></td></tr></table></figure>


<p>上面GET POST 最终都走到下面的方法中，无非就是constructingBodyWithBlock空与非空的区别，</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">NSURLSessionDataTask</span> *)dataTaskWithHTTPMethod:(<span class="built_in">NSString</span> *)method</span><br><span class="line">                               requestSerializer:(AFHTTPRequestSerializer *)requestSerializer</span><br><span class="line">                                       URLString:(<span class="built_in">NSString</span> *)URLString</span><br><span class="line">                                      parameters:(<span class="type">id</span>)parameters</span><br><span class="line">                       constructingBodyWithBlock:(<span class="keyword">nullable</span> <span class="type">void</span> (^)(<span class="type">id</span> &lt;AFMultipartFormData&gt; formData))block</span><br><span class="line">                                           error:(<span class="built_in">NSError</span> * _Nullable __autoreleasing *)error &#123;</span><br><span class="line">    <span class="built_in">NSMutableURLRequest</span> *request = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果constructingBodyWithBlock非空的话使用multipartFormRequestWithMethod</span></span><br><span class="line">    <span class="keyword">if</span> (block) &#123;</span><br><span class="line">        request = [requestSerializer multipartFormRequestWithMethod:method URLString:URLString parameters:parameters constructingBodyWithBlock:block error:error];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        request = [requestSerializer requestWithMethod:method URLString:URLString parameters:parameters error:error];</span><br><span class="line">    &#125;</span><br><span class="line">    __block <span class="built_in">NSURLSessionDataTask</span> *dataTask = <span class="literal">nil</span>;</span><br><span class="line">    dataTask = [_manager dataTaskWithRequest:request</span><br><span class="line">                           completionHandler:^(<span class="built_in">NSURLResponse</span> * __unused response, <span class="type">id</span> responseObject, <span class="built_in">NSError</span> *_error) &#123;</span><br><span class="line">                               [<span class="keyword">self</span> handleRequestResult:dataTask responseObject:responseObject error:_error];</span><br><span class="line">                           &#125;];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dataTask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>constructingBodyWithBlock有值的时候我们会使用请求序列化中的multipartFormRequestWithMethod进行处理，如果无值的话就会调用请求序列化器中的requestWithMethod进行处理。对请求处理后就可以使用该请求对象生成dataTask了，这部分没什么特殊的地方，我们关键来看下下载的部分：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">NSURLSessionDownloadTask</span> *)downloadTaskWithDownloadPath:(<span class="built_in">NSString</span> *)downloadPath</span><br><span class="line">                                         requestSerializer:(AFHTTPRequestSerializer *)requestSerializer</span><br><span class="line">                                                 URLString:(<span class="built_in">NSString</span> *)URLString</span><br><span class="line">                                                parameters:(<span class="type">id</span>)parameters</span><br><span class="line">                                                  progress:(<span class="keyword">nullable</span> <span class="type">void</span> (^)(<span class="built_in">NSProgress</span> *downloadProgress))downloadProgressBlock</span><br><span class="line">                                                     error:(<span class="built_in">NSError</span> * _Nullable __autoreleasing *)error &#123;</span><br><span class="line">    <span class="comment">// add parameters to URL;</span></span><br><span class="line">    <span class="built_in">NSMutableURLRequest</span> *urlRequest = [requestSerializer requestWithMethod:<span class="string">@&quot;GET&quot;</span> URLString:URLString parameters:parameters error:error];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSString</span> *downloadTargetPath;</span><br><span class="line">    <span class="type">BOOL</span> isDirectory;</span><br><span class="line">    <span class="keyword">if</span>(![[<span class="built_in">NSFileManager</span> defaultManager] fileExistsAtPath:downloadPath isDirectory:&amp;isDirectory]) &#123;</span><br><span class="line">        isDirectory = <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// If targetPath is a directory, use the file name we got from the urlRequest.</span></span><br><span class="line">    <span class="comment">// Make sure downloadTargetPath is always a file, not directory.</span></span><br><span class="line">    <span class="comment">// 构建下载路径downloadTargetPath</span></span><br><span class="line">    <span class="keyword">if</span> (isDirectory) &#123;</span><br><span class="line">        <span class="comment">//如果给定的downloadpath是目录路径，那么将会将下载url下的最后部分作为文件名添加到最后，形成最终的下载文件地址</span></span><br><span class="line">        <span class="built_in">NSString</span> *fileName = [urlRequest.URL lastPathComponent];</span><br><span class="line">        downloadTargetPath = [<span class="built_in">NSString</span> pathWithComponents:@[downloadPath, fileName]];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        downloadTargetPath = downloadPath;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在下载前如果文件存在先直接删除？ 直接删除不先下到缓存再？</span></span><br><span class="line">    <span class="keyword">if</span> ([[<span class="built_in">NSFileManager</span> defaultManager] fileExistsAtPath:downloadTargetPath]) &#123;</span><br><span class="line">        [[<span class="built_in">NSFileManager</span> defaultManager] removeItemAtPath:downloadTargetPath error:<span class="literal">nil</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">BOOL</span> resumeSucceeded = <span class="literal">NO</span>;</span><br><span class="line">    __block <span class="built_in">NSURLSessionDownloadTask</span> *downloadTask = <span class="literal">nil</span>;</span><br><span class="line">    <span class="comment">//未下载完成存储路径</span></span><br><span class="line">    <span class="built_in">NSURL</span> *localUrl = [<span class="keyword">self</span> incompleteDownloadTempPathForDownloadPath:downloadPath];</span><br><span class="line">    <span class="keyword">if</span> (localUrl != <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="comment">// 是否存在未下载完成的文件</span></span><br><span class="line">        <span class="type">BOOL</span> resumeDataFileExists = [[<span class="built_in">NSFileManager</span> defaultManager] fileExistsAtPath:localUrl.path];</span><br><span class="line">        <span class="comment">// 加载数据</span></span><br><span class="line">        <span class="built_in">NSData</span> *data = [<span class="built_in">NSData</span> dataWithContentsOfURL:localUrl];</span><br><span class="line">        <span class="comment">// 数据是否合法</span></span><br><span class="line">        <span class="type">BOOL</span> resumeDataIsValid = [YTKNetworkUtils validateResumeData:data];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//是否可以恢复</span></span><br><span class="line">        <span class="type">BOOL</span> canBeResumed = resumeDataFileExists &amp;&amp; resumeDataIsValid;</span><br><span class="line">        <span class="comment">// Try to resume with resumeData.</span></span><br><span class="line">        <span class="comment">// Even though we try to validate the resumeData, this may still fail and raise excecption.</span></span><br><span class="line">        <span class="keyword">if</span> (canBeResumed) &#123;</span><br><span class="line">            <span class="keyword">@try</span> &#123;</span><br><span class="line">                downloadTask = [_manager downloadTaskWithResumeData:data progress:downloadProgressBlock destination:^<span class="built_in">NSURL</span> * _Nonnull(<span class="built_in">NSURL</span> * _Nonnull targetPath, <span class="built_in">NSURLResponse</span> * _Nonnull response) &#123;</span><br><span class="line">                    <span class="keyword">return</span> [<span class="built_in">NSURL</span> fileURLWithPath:downloadTargetPath isDirectory:<span class="literal">NO</span>];</span><br><span class="line">                &#125; completionHandler:</span><br><span class="line">                                ^(<span class="built_in">NSURLResponse</span> * _Nonnull response, <span class="built_in">NSURL</span> * _Nullable filePath, <span class="built_in">NSError</span> * _Nullable error) &#123;</span><br><span class="line">                                    [<span class="keyword">self</span> handleRequestResult:downloadTask responseObject:filePath error:error];</span><br><span class="line">                                &#125;];</span><br><span class="line">                resumeSucceeded = <span class="literal">YES</span>;</span><br><span class="line">            &#125; <span class="keyword">@catch</span> (<span class="built_in">NSException</span> *exception) &#123;</span><br><span class="line">                YTKLog(<span class="string">@&quot;Resume download failed, reason = %@&quot;</span>, exception.reason);</span><br><span class="line">                resumeSucceeded = <span class="literal">NO</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//重新开始下载</span></span><br><span class="line">    <span class="keyword">if</span> (!resumeSucceeded) &#123;</span><br><span class="line">        downloadTask = [_manager downloadTaskWithRequest:urlRequest progress:downloadProgressBlock destination:^<span class="built_in">NSURL</span> * _Nonnull(<span class="built_in">NSURL</span> * _Nonnull targetPath, <span class="built_in">NSURLResponse</span> * _Nonnull response) &#123;</span><br><span class="line">            <span class="keyword">return</span> [<span class="built_in">NSURL</span> fileURLWithPath:downloadTargetPath isDirectory:<span class="literal">NO</span>];</span><br><span class="line">        &#125; completionHandler:</span><br><span class="line">                        ^(<span class="built_in">NSURLResponse</span> * _Nonnull response, <span class="built_in">NSURL</span> * _Nullable filePath, <span class="built_in">NSError</span> * _Nullable error) &#123;</span><br><span class="line">                            [<span class="keyword">self</span> handleRequestResult:downloadTask responseObject:filePath error:error];</span><br><span class="line">                        &#125;];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> downloadTask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>首先会先通过判断传进来的downloadPath是否是目录名称，如果是则将url最后的部分作为文件名添加到path最后，如果是文件名，则直接作为目标下载地址</li>
<li>紧接着如果要下载的文件已经存在那么在下载之前先删除这个文件</li>
<li>然后再去临时目录去看是否有之前下载一半没有下载结束的缓存文件，临时目录下的这些缓存文件命名规则大家可以看下这部分代码：</li>
</ol>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">NSURL</span> *)incompleteDownloadTempPathForDownloadPath:(<span class="built_in">NSString</span> *)downloadPath &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *tempPath = <span class="literal">nil</span>;</span><br><span class="line">    <span class="comment">//通过下载路径生成MD5字符串 最终生成 temp路径 + Incomplete + MD5[downloadPath]</span></span><br><span class="line">    <span class="built_in">NSString</span> *md5URLString = [YTKNetworkUtils md5StringFromString:downloadPath];</span><br><span class="line">    tempPath = [[<span class="keyword">self</span> incompleteDownloadTempCacheFolder] stringByAppendingPathComponent:md5URLString];</span><br><span class="line">    <span class="keyword">return</span> tempPath == <span class="literal">nil</span> ? <span class="literal">nil</span> : [<span class="built_in">NSURL</span> fileURLWithPath:tempPath];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>如果有上一次下载一半的数据，就先加载到内存，验证数据的合法性，如果数据存在，并且合法，就通过downloadTaskWithResumeData创建dataTask，否则通过downloadTaskWithRequest来创建。</li>
</ol>
<p><strong><strong>请求结束处理</strong></strong></p>
<p>请求结束统一调用handleRequestResult进行处理：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)handleRequestResult:(<span class="built_in">NSURLSessionTask</span> *)task responseObject:(<span class="type">id</span>)responseObject error:(<span class="built_in">NSError</span> *)error &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//取出请求</span></span><br><span class="line">    Lock();</span><br><span class="line">    YTKBaseRequest *request = _requestsRecord[@(task.taskIdentifier)];</span><br><span class="line">    Unlock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// When the request is cancelled and removed from records, the underlying</span></span><br><span class="line">    <span class="comment">// AFNetworking failure callback will still kicks in, resulting in a nil `request`.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Here we choose to completely ignore cancelled tasks. Neither success or failure</span></span><br><span class="line">    <span class="comment">// callback will be called.</span></span><br><span class="line">    <span class="keyword">if</span> (!request) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    YTKLog(<span class="string">@&quot;Finished Request: %@&quot;</span>, <span class="built_in">NSStringFromClass</span>([request <span class="keyword">class</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSError</span> * __autoreleasing serializationError = <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">NSError</span> * __autoreleasing validationError = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSError</span> *requestError = <span class="literal">nil</span>;</span><br><span class="line">    <span class="type">BOOL</span> succeed = <span class="literal">NO</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将结果传递给responseObject</span></span><br><span class="line">    request.responseObject = responseObject;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//通过对应的response序列化器进行处理</span></span><br><span class="line">    <span class="keyword">if</span> ([request.responseObject isKindOfClass:[<span class="built_in">NSData</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        </span><br><span class="line">        request.responseData = responseObject;</span><br><span class="line">        request.responseString = [[<span class="built_in">NSString</span> alloc] initWithData:responseObject encoding:[YTKNetworkUtils stringEncodingWithRequest:request]];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (request.responseSerializerType) &#123;</span><br><span class="line">            <span class="keyword">case</span> YTKResponseSerializerTypeHTTP:</span><br><span class="line">                <span class="comment">// Default serializer. Do nothing.</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> YTKResponseSerializerTypeJSON:</span><br><span class="line">                request.responseObject = [<span class="keyword">self</span>.jsonResponseSerializer responseObjectForResponse:task.response data:request.responseData error:&amp;serializationError];</span><br><span class="line">                request.responseJSONObject = request.responseObject;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> YTKResponseSerializerTypeXMLParser:</span><br><span class="line">                request.responseObject = [<span class="keyword">self</span>.xmlParserResponseSerialzier responseObjectForResponse:task.response data:request.responseData error:&amp;serializationError];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        succeed = <span class="literal">NO</span>;</span><br><span class="line">        requestError = error;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (serializationError) &#123;</span><br><span class="line">        succeed = <span class="literal">NO</span>;</span><br><span class="line">        requestError = serializationError;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        succeed = [<span class="keyword">self</span> validateResult:request error:&amp;validationError];</span><br><span class="line">        requestError = validationError;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//通知到外部</span></span><br><span class="line">    <span class="keyword">if</span> (succeed) &#123;</span><br><span class="line">        [<span class="keyword">self</span> requestDidSucceedWithRequest:request];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        [<span class="keyword">self</span> requestDidFailWithRequest:request error:requestError];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        <span class="comment">//清除成功失败回调</span></span><br><span class="line">        [<span class="keyword">self</span> removeRequestFromRecord:request];</span><br><span class="line">        [request clearCompletionBlock];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据上面加载的请求发起的流程来看，不难猜出下载结束后的工作应该是，将请求数据通过response 序列化器进行处理后存放到YTKBaseRequest中，然后通过对应的block以及delegte将数据交付到应用层，然后将delegate以及block清除，但是我们知道请求返回后AFNetWorking实际上返回的是task，responseOject,这时候并不知道具体是哪个<strong><strong>YTKBaseRequest</strong></strong>，这个问题是怎么解决的呢？我们知道在addRequest的时候会调用****[self addRequestToRecord:request]****</p>
<figure class="highlight erlang"><table><tr><td class="code"><pre><span class="line">- <span class="params">(void)</span>addRequestToRecord:<span class="params">(YTKBaseRequest *)</span>request &#123;</span><br><span class="line">    Lock<span class="params">()</span>;</span><br><span class="line">    _requestsRecord[@<span class="params">(request.requestTask.taskIdentifier)</span>] = request;</span><br><span class="line">    Unlock<span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它会以dataTask的taskIdentifier为key YTKBaseRequest为value建立一个映射表，当请求结束的时候我们得到的是一个dataTask,那么就可以通过它的taskIdentifier作为key，获得对应的YTKBaseRequest，然后将resonse序列化器处理后的结果塞到YTKBaseRequest中。这一切都结束后再将映射关系从映射表中删除。</p>
<p>我们再继续看下请求成功和失败后会怎么处理接下来的流程：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- (void)requestDidSucceedWithRequest:(YTKBaseRequest *)request &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="selector-attr">[request requestCompletePreprocessor]</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//通过外部的插件将要停止请求</span></span><br><span class="line">        <span class="selector-attr">[request toggleAccessoriesWillStopCallBack]</span>;</span><br><span class="line">        <span class="selector-attr">[request requestCompleteFilter]</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过代理通知请求已经结束</span></span><br><span class="line">        if (request.delegate != nil) &#123;</span><br><span class="line">            <span class="selector-attr">[request.delegate requestFinished:request]</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 通过block通知请求已经结束</span></span><br><span class="line">        if (request.successCompletionBlock) &#123;</span><br><span class="line">            request<span class="selector-class">.successCompletionBlock</span>(request);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//通知外部的插件已经结束</span></span><br><span class="line">        <span class="selector-attr">[request toggleAccessoriesDidStopCallBack]</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请求成功后在还没切回主线程之前会先调用requestCompletePreprocessor，在这里相当于埋下一个勾子，外面可以在这里实现类似统计之类的功能，紧接着切换到主线程，通知外部插件请求将要结束了，然后再调用requestCompleteFilter，这个和requestCompletePreprocessor功能类似，区别是一个在后台线程一个在主线程，紧接着就是通过代理和block将数据交付给上层，最后通知插件该请求结束。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)requestDidFailWithRequest:(YTKBaseRequest *)request error:(<span class="built_in">NSError</span> *)error &#123;</span><br><span class="line">    request.error = error;</span><br><span class="line">    YTKLog(<span class="string">@&quot;Request %@ failed, status code = %ld, error = %@&quot;</span>,</span><br><span class="line">           <span class="built_in">NSStringFromClass</span>([request <span class="keyword">class</span>]), (<span class="type">long</span>)request.responseStatusCode, error.localizedDescription);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从userInfo 中取出下载没完成的数据</span></span><br><span class="line">    <span class="built_in">NSData</span> *incompleteDownloadData = error.userInfo[<span class="built_in">NSURLSessionDownloadTaskResumeData</span>];</span><br><span class="line">    <span class="built_in">NSURL</span> *localUrl = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">if</span> (request.resumableDownloadPath) &#123;</span><br><span class="line">        localUrl = [<span class="keyword">self</span> incompleteDownloadTempPathForDownloadPath:request.resumableDownloadPath];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//存放到指定的路径</span></span><br><span class="line">    <span class="keyword">if</span> (incompleteDownloadData &amp;&amp; localUrl != <span class="literal">nil</span>) &#123;</span><br><span class="line">        [incompleteDownloadData writeToURL:localUrl atomically:<span class="literal">YES</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将文件从url中取出，如果是文件的话就删除下载失败的文件</span></span><br><span class="line">    <span class="keyword">if</span> ([request.responseObject isKindOfClass:[<span class="built_in">NSURL</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="built_in">NSURL</span> *url = request.responseObject;</span><br><span class="line">        <span class="keyword">if</span> (url.isFileURL &amp;&amp; [[<span class="built_in">NSFileManager</span> defaultManager] fileExistsAtPath:url.path]) &#123;</span><br><span class="line">            request.responseData = [<span class="built_in">NSData</span> dataWithContentsOfURL:url];</span><br><span class="line">            request.responseString = [[<span class="built_in">NSString</span> alloc] initWithData:request.responseData encoding:[YTKNetworkUtils stringEncodingWithRequest:request]];</span><br><span class="line">            [[<span class="built_in">NSFileManager</span> defaultManager] removeItemAtURL:url error:<span class="literal">nil</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        request.responseObject = <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        [request requestFailedPreprocessor];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//在主线程通过代理，block通知外部下载失败</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        [request toggleAccessoriesWillStopCallBack];</span><br><span class="line">        [request requestFailedFilter];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (request.delegate != <span class="literal">nil</span>) &#123;</span><br><span class="line">            [request.delegate requestFailed:request];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (request.failureCompletionBlock) &#123;</span><br><span class="line">            request.failureCompletionBlock(request);</span><br><span class="line">        &#125;</span><br><span class="line">        [request toggleAccessoriesDidStopCallBack];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>请求失败的话大体上和请求成功在流程上是一致的，只不过会在失败的时候通过****error.userInfo[NSURLSessionDownloadTaskResumeData]****拿到已经获取的数据，这时候就可以将这数据存储起来供下一次继续请求的时候实现断点续传。</p>
<p>最后看下取消请求的流程：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)cancelRequest:(YTKBaseRequest *)request &#123;</span><br><span class="line">    <span class="built_in">NSParameterAssert</span>(request != <span class="literal">nil</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果有指定恢复下载文件的路径则取消后将数据写到恢复下载文件的地方</span></span><br><span class="line">    <span class="keyword">if</span> (request.resumableDownloadPath &amp;&amp; [<span class="keyword">self</span> incompleteDownloadTempPathForDownloadPath:request.resumableDownloadPath] != <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="built_in">NSURLSessionDownloadTask</span> *requestTask = (<span class="built_in">NSURLSessionDownloadTask</span> *)request.requestTask;</span><br><span class="line">        [requestTask cancelByProducingResumeData:^(<span class="built_in">NSData</span> *resumeData) &#123;</span><br><span class="line">            <span class="built_in">NSURL</span> *localUrl = [<span class="keyword">self</span> incompleteDownloadTempPathForDownloadPath:request.resumableDownloadPath];</span><br><span class="line">            [resumeData writeToURL:localUrl atomically:<span class="literal">YES</span>];</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//直接调用NSURLSessionDataTask cancel</span></span><br><span class="line">        [request.requestTask cancel];</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="keyword">self</span> removeRequestFromRecord:request];</span><br><span class="line">    <span class="comment">//清除请求成功失败的block</span></span><br><span class="line">    [request clearCompletionBlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和请求失败处理一样可以做临时数据缓存，只不过需要通过<strong><strong>NSURLSessionDownloadTask 的 cancelByProducingResumeData</strong></strong>方法拿到已经获取的数据。再将数据写到临时目录下。</p>
<h5 id="3-批量请求"><a href="#3-批量请求" class="headerlink" title="3. 批量请求"></a>3. 批量请求</h5><p>批量请求没啥需要介绍的，就是用一个数组将YTKRequst存放起来，在start的时候一个个调用YTKRequest的start方法：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)start &#123;</span><br><span class="line">    <span class="keyword">if</span> (_finishedCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        YTKLog(<span class="string">@&quot;Error! Batch request has already started.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    _failedRequest = nil;</span><br><span class="line">    [[YTKBatchRequestAgent sharedAgent] addBatchRequest:self];</span><br><span class="line">    [<span class="meta">self toggleAccessoriesWillStartCallBack</span>];</span><br><span class="line">    <span class="keyword">for</span> (YTKRequest * req <span class="keyword">in</span> _requestArray) &#123;</span><br><span class="line">        req.<span class="built_in">delegate</span> = self;</span><br><span class="line">        [<span class="meta">req clearCompletionBlock</span>];</span><br><span class="line">        [<span class="meta">req start</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-链式请求"><a href="#4-链式请求" class="headerlink" title="4. 链式请求"></a>4. 链式请求</h5><p>链式请求是一系列有依赖关系的请求，它会在某个请求执行完毕后，进行下一个请求的启动。接下来我们以<strong><strong>添加请求</strong></strong>，<strong><strong>启动请求</strong></strong>，<strong><strong>请求结束后启动下一个请求</strong></strong>三个部分进行简单展开：</p>
<p><strong><strong>1. 添加请求</strong></strong></p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">- (void)addRequest:(YTKBaseRequest *)request callback:(YTKChainCallback)callback &#123;</span><br><span class="line">    <span class="selector-attr">[_requestArray addObject:request]</span>;</span><br><span class="line">    if (callback != nil) &#123;</span><br><span class="line">        <span class="selector-attr">[_requestCallbackArray addObject:callback]</span>;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        <span class="selector-attr">[_requestCallbackArray addObject:_emptyCallback]</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>添加请求是通过addRequest:callback方法来完成的，每个请求与callback是一一对应的，如果外面传进来一个nil callback，那么_requestCallbackArray就会添加一个空请求，作为占位。</p>
<p><strong><strong>2. 启动请求</strong></strong></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)start &#123;</span><br><span class="line">    <span class="keyword">if</span> (_nextRequestIndex &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        YTKLog(<span class="string">@&quot;Error! Chain request has already started.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ([_requestArray count] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        [<span class="keyword">self</span> toggleAccessoriesWillStartCallBack];</span><br><span class="line">        [<span class="keyword">self</span> startNextRequest];</span><br><span class="line">        [[YTKChainRequestAgent sharedAgent] addChainRequest:<span class="keyword">self</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        YTKLog(<span class="string">@&quot;Error! Chain request array is empty.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">BOOL</span>)startNextRequest &#123;</span><br><span class="line">    <span class="keyword">if</span> (_nextRequestIndex &lt; [_requestArray count]) &#123;</span><br><span class="line">        YTKBaseRequest *request = _requestArray[_nextRequestIndex];</span><br><span class="line">        _nextRequestIndex++;</span><br><span class="line">        request.delegate = <span class="keyword">self</span>;</span><br><span class="line">        [request clearCompletionBlock];</span><br><span class="line">        [request start];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个会按照请求数组的顺序一个一个取出来，调用start方法，这个就不做过多介绍了。</p>
<p><strong><strong>请求结束后启动下一个请求</strong></strong></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)requestFinished:(YTKBaseRequest *)request &#123;</span><br><span class="line">    <span class="built_in">NSUInteger</span> currentRequestIndex = _nextRequestIndex - <span class="number">1</span>;</span><br><span class="line">    YTKChainCallback callback = _requestCallbackArray[currentRequestIndex];</span><br><span class="line">    callback(<span class="keyword">self</span>, request);</span><br><span class="line">    <span class="keyword">if</span> (![<span class="keyword">self</span> startNextRequest]) &#123;</span><br><span class="line">        [<span class="keyword">self</span> toggleAccessoriesWillStopCallBack];</span><br><span class="line">        <span class="keyword">if</span> ([_delegate respondsToSelector:<span class="keyword">@selector</span>(chainRequestFinished:)]) &#123;</span><br><span class="line">            [_delegate chainRequestFinished:<span class="keyword">self</span>];</span><br><span class="line">            [[YTKChainRequestAgent sharedAgent] removeChainRequest:<span class="keyword">self</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        [<span class="keyword">self</span> toggleAccessoriesDidStopCallBack];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请求结束后会从_requestCallbackArray中获取对应的YTKChainCallback进行处理，然后调用startNextRequest开启下一个请求。</p>
<h5 id="5-缓存机制"><a href="#5-缓存机制" class="headerlink" title="5. 缓存机制"></a>5. 缓存机制</h5><p>前面已经提到YTKNetWork的缓存机制都保存在YTKRequest中，所以这部分我们来看下YTKReques：</p>
<p>依旧从启动请求开始：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)start &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.ignoreCache) &#123;</span><br><span class="line">        [<span class="keyword">self</span> startWithoutCache];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Do not cache download request.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.resumableDownloadPath) &#123;</span><br><span class="line">        [<span class="keyword">self</span> startWithoutCache];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (![<span class="keyword">self</span> loadCacheWithError:<span class="literal">nil</span>]) &#123;</span><br><span class="line">        [<span class="keyword">self</span> startWithoutCache];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _dataFromCache = <span class="literal">YES</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        [<span class="keyword">self</span> requestCompletePreprocessor];</span><br><span class="line">        [<span class="keyword">self</span> requestCompleteFilter];</span><br><span class="line">        YTKRequest *strongSelf = <span class="keyword">self</span>;</span><br><span class="line">        [strongSelf.delegate requestFinished:strongSelf];</span><br><span class="line">        <span class="keyword">if</span> (strongSelf.successCompletionBlock) &#123;</span><br><span class="line">            strongSelf.successCompletionBlock(strongSelf);</span><br><span class="line">        &#125;</span><br><span class="line">        [strongSelf clearCompletionBlock];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在启动的时候会首先根据当前情况选择是否使用缓存数据，如果我们在YTKRequest中配置了ignoreCache，或者在下载数据的情景中并且配置了resumableDownloadPath，再或者缓存加载失败都会启动无缓存请求模式，<br>除了上述情况会先通过*<em><strong>loadCacheWithError</strong></em>**将缓存再本地的数据加载到内存中：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">BOOL</span>)loadCacheWithError:(<span class="built_in">NSError</span> * _Nullable __autoreleasing *)error &#123;</span><br><span class="line">    <span class="comment">// 检查缓存时间</span></span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span> cacheTimeInSeconds] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (error) &#123;</span><br><span class="line">            *error = [<span class="built_in">NSError</span> errorWithDomain:YTKRequestCacheErrorDomain code:YTKRequestCacheErrorInvalidCacheTime userInfo:@&#123; <span class="built_in">NSLocalizedDescriptionKey</span>:<span class="string">@&quot;Invalid cache time&quot;</span>&#125;];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载缓存信息数据</span></span><br><span class="line">    <span class="keyword">if</span> (![<span class="keyword">self</span> loadCacheMetadata]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (error) &#123;</span><br><span class="line">            *error = [<span class="built_in">NSError</span> errorWithDomain:YTKRequestCacheErrorDomain code:YTKRequestCacheErrorInvalidMetadata userInfo:@&#123; <span class="built_in">NSLocalizedDescriptionKey</span>:<span class="string">@&quot;Invalid metadata. Cache may not exist&quot;</span>&#125;];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查缓存数据</span></span><br><span class="line">    <span class="keyword">if</span> (![<span class="keyword">self</span> validateCacheWithError:error]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载缓存</span></span><br><span class="line">    <span class="keyword">if</span> (![<span class="keyword">self</span> loadCacheData]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (error) &#123;</span><br><span class="line">            *error = [<span class="built_in">NSError</span> errorWithDomain:YTKRequestCacheErrorDomain code:YTKRequestCacheErrorInvalidCacheData userInfo:@&#123; <span class="built_in">NSLocalizedDescriptionKey</span>:<span class="string">@&quot;Invalid cache data&quot;</span>&#125;];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在加载数据之前会先检查下我们配置的缓存时间，如果cacheTimeInSeconds小于0的话就不再继续加载了，这时候会抛出错误。缓存数据加载失败走正常数据请求流程。否则再紧接着缓存加载的流程：</p>
<p>加载缓存信息数据<strong><strong>loadCacheMetadata</strong></strong>，检查缓存数据的合法性<strong><strong>validateCacheWithError</strong></strong>，加载数据<strong><strong>loadCacheData</strong></strong>，下面就针对这些环节进行介绍：</p>
<p><strong><strong>loadCacheMetadata</strong></strong></p>
<p>在加载缓存数据之前会先加载缓存的信息文件</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">BOOL</span>)loadCacheMetadata &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *path = [<span class="keyword">self</span> cacheMetadataFilePath];</span><br><span class="line">    <span class="built_in">NSFileManager</span> * fileManager = [<span class="built_in">NSFileManager</span> defaultManager];</span><br><span class="line">    <span class="keyword">if</span> ([fileManager fileExistsAtPath:path isDirectory:<span class="literal">nil</span>]) &#123;</span><br><span class="line">        <span class="keyword">@try</span> &#123;</span><br><span class="line">            _cacheMetadata = [<span class="built_in">NSKeyedUnarchiver</span> unarchiveObjectWithFile:path];</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">        &#125; <span class="keyword">@catch</span> (<span class="built_in">NSException</span> *exception) &#123;</span><br><span class="line">            YTKLog(<span class="string">@&quot;Load cache metadata failed, reason = %@&quot;</span>, exception.reason);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么缓存信息文件存在哪里呢？我们怎么拿现有的配置取到缓存的信息文件？带着这个疑问继续看下面的代码：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">NSString</span> *)cacheFileName &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *requestUrl = [<span class="keyword">self</span> requestUrl];</span><br><span class="line">    <span class="built_in">NSString</span> *baseUrl = [YTKNetworkConfig sharedConfig].baseUrl;</span><br><span class="line">    <span class="type">id</span> argument = [<span class="keyword">self</span> cacheFileNameFilterForRequestArgument:[<span class="keyword">self</span> requestArgument]];</span><br><span class="line">    <span class="built_in">NSString</span> *requestInfo = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;Method:%ld Host:%@ Url:%@ Argument:%@&quot;</span>,</span><br><span class="line">                             (<span class="type">long</span>)[<span class="keyword">self</span> requestMethod], baseUrl, requestUrl, argument];</span><br><span class="line">    <span class="built_in">NSString</span> *cacheFileName = [YTKNetworkUtils md5StringFromString:requestInfo];</span><br><span class="line">    <span class="keyword">return</span> cacheFileName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *)cacheMetadataFilePath &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *cacheMetadataFileName = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;%@.metadata&quot;</span>, [<span class="keyword">self</span> cacheFileName]];</span><br><span class="line">    <span class="built_in">NSString</span> *path = [<span class="keyword">self</span> cacheBasePath];</span><br><span class="line">    path = [path stringByAppendingPathComponent:cacheMetadataFileName];</span><br><span class="line">    <span class="keyword">return</span> path;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *)cacheBasePath &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *pathOfLibrary = [<span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSLibraryDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">YES</span>) objectAtIndex:<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">NSString</span> *path = [pathOfLibrary stringByAppendingPathComponent:<span class="string">@&quot;LazyRequestCache&quot;</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Filter cache base path</span></span><br><span class="line">    <span class="built_in">NSArray</span>&lt;<span class="type">id</span>&lt;YTKCacheDirPathFilterProtocol&gt;&gt; *filters = [[YTKNetworkConfig sharedConfig] cacheDirPathFilters];</span><br><span class="line">    <span class="keyword">if</span> (filters.count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">id</span>&lt;YTKCacheDirPathFilterProtocol&gt; f <span class="keyword">in</span> filters) &#123;</span><br><span class="line">            path = [f filterCacheDirPath:path withRequest:<span class="keyword">self</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span> createDirectoryIfNeeded:path];</span><br><span class="line">    <span class="keyword">return</span> path;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们先来看下<strong><strong>requestInfo</strong></strong>这个字符串是怎么来的：</p>
<figure class="highlight mel"><table><tr><td class="code"><pre><span class="line">[NSString stringWithFormat:@&quot;Method:%ld Host:%@ Url:%@ Argument:%@<span class="string">&quot;,(long)[self requestMethod], baseUrl, requestUrl, argument];</span></span><br></pre></td></tr></table></figure>
<p>requestInfo包含着Method,URL(Host：Url)，Argument，也就是说缓存文件信息文件名里面包含着一个请求的全部信息。在通过对这个字符串进行md5加密，生成的字符串作为缓存信息文件名。<br>最终文件存放在:</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">/[系统缓存路径]/</span>LazyRequestCache[这个名称会经过cacheDirPathFilters进行处理，默认是LazyRequestCache]/xxxxxxxxxxxx.metadata</span><br></pre></td></tr></table></figure>
<p>可以通过cacheDirPathFilters添加版本信息等公共的处理。</p>
<p>加载出来的对象结构如下：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YTKCacheMetadata</span> : <span class="title">NSObject</span>&lt;<span class="title">NSSecureCoding</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="type">long</span> <span class="type">long</span> version;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *sensitiveDataString;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSStringEncoding</span> stringEncoding;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSDate</span> *creationDate;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *appVersionString;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>包括缓存版本，关键字段，字符编码格式，创建时间，app版本信息。后面将会重点看下怎么利用这些信息来实现缓存策略。</p>
<p><strong><strong>validateCacheWithError</strong></strong></p>
<p>上面已经成功地加载了缓存信息文件，接下来就是对这些进行缓存信息进行校验了：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">BOOL</span>)validateCacheWithError:(<span class="built_in">NSError</span> * _Nullable __autoreleasing *)error &#123;</span><br><span class="line">    <span class="comment">// Date</span></span><br><span class="line">    <span class="built_in">NSDate</span> *creationDate = <span class="keyword">self</span>.cacheMetadata.creationDate;</span><br><span class="line">    <span class="built_in">NSTimeInterval</span> duration = -[creationDate timeIntervalSinceNow];</span><br><span class="line">    <span class="keyword">if</span> (duration &lt; <span class="number">0</span> || duration &gt; [<span class="keyword">self</span> cacheTimeInSeconds]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (error) &#123;</span><br><span class="line">            *error = [<span class="built_in">NSError</span> errorWithDomain:YTKRequestCacheErrorDomain code:YTKRequestCacheErrorExpired userInfo:@&#123; <span class="built_in">NSLocalizedDescriptionKey</span>:<span class="string">@&quot;Cache expired&quot;</span>&#125;];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Version</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> cacheVersionFileContent = <span class="keyword">self</span>.cacheMetadata.version;</span><br><span class="line">    <span class="keyword">if</span> (cacheVersionFileContent != [<span class="keyword">self</span> cacheVersion]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (error) &#123;</span><br><span class="line">            *error = [<span class="built_in">NSError</span> errorWithDomain:YTKRequestCacheErrorDomain code:YTKRequestCacheErrorVersionMismatch userInfo:@&#123; <span class="built_in">NSLocalizedDescriptionKey</span>:<span class="string">@&quot;Cache version mismatch&quot;</span>&#125;];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Sensitive data</span></span><br><span class="line">    <span class="built_in">NSString</span> *sensitiveDataString = <span class="keyword">self</span>.cacheMetadata.sensitiveDataString;</span><br><span class="line">    <span class="built_in">NSString</span> *currentSensitiveDataString = ((<span class="built_in">NSObject</span> *)[<span class="keyword">self</span> cacheSensitiveData]).description;</span><br><span class="line">    <span class="keyword">if</span> (sensitiveDataString || currentSensitiveDataString) &#123;</span><br><span class="line">        <span class="comment">// If one of the strings is nil, short-circuit evaluation will trigger</span></span><br><span class="line">        <span class="keyword">if</span> (sensitiveDataString.length != currentSensitiveDataString.length || ![sensitiveDataString isEqualToString:currentSensitiveDataString]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (error) &#123;</span><br><span class="line">                *error = [<span class="built_in">NSError</span> errorWithDomain:YTKRequestCacheErrorDomain code:YTKRequestCacheErrorSensitiveDataMismatch userInfo:@&#123; <span class="built_in">NSLocalizedDescriptionKey</span>:<span class="string">@&quot;Cache sensitive data mismatch&quot;</span>&#125;];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// App version</span></span><br><span class="line">    <span class="built_in">NSString</span> *appVersionString = <span class="keyword">self</span>.cacheMetadata.appVersionString;</span><br><span class="line">    <span class="built_in">NSString</span> *currentAppVersionString = [YTKNetworkUtils appVersionString];</span><br><span class="line">    <span class="keyword">if</span> (appVersionString || currentAppVersionString) &#123;</span><br><span class="line">        <span class="keyword">if</span> (appVersionString.length != currentAppVersionString.length || ![appVersionString isEqualToString:currentAppVersionString]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (error) &#123;</span><br><span class="line">                *error = [<span class="built_in">NSError</span> errorWithDomain:YTKRequestCacheErrorDomain code:YTKRequestCacheErrorAppVersionMismatch userInfo:@&#123; <span class="built_in">NSLocalizedDescriptionKey</span>:<span class="string">@&quot;App version mismatch&quot;</span>&#125;];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>首先是对缓存是否过期进行校验，这一步主要主要通过YTKCacheMetadata中的creationDate与当前时间计算差值，再与cacheTimeInSeconds对比判断缓存数据是否过期。<br>紧接着看缓存版本和我们request中的cacheVersion是否匹配。紧接着对比缓存的关键信息。然后再是应用版本的匹配，这些信息都匹配的时候才说明缓存是可用的，才会去加载缓存数据。</p>
<p><strong><strong>loadCacheData</strong></strong></p>
<p>紧接着会将本地缓存文件根据序列化形式加载到****_cacheData<strong><strong>，</strong></strong>_cacheString<strong><strong>，</strong></strong>_cacheXML****，</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">BOOL</span>)loadCacheData &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *path = [<span class="keyword">self</span> cacheFilePath];</span><br><span class="line">    <span class="built_in">NSFileManager</span> *fileManager = [<span class="built_in">NSFileManager</span> defaultManager];</span><br><span class="line">    <span class="built_in">NSError</span> *error = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ([fileManager fileExistsAtPath:path isDirectory:<span class="literal">nil</span>]) &#123;</span><br><span class="line">        <span class="built_in">NSData</span> *data = [<span class="built_in">NSData</span> dataWithContentsOfFile:path];</span><br><span class="line">        _cacheData = data;</span><br><span class="line">        _cacheString = [[<span class="built_in">NSString</span> alloc] initWithData:_cacheData encoding:<span class="keyword">self</span>.cacheMetadata.stringEncoding];</span><br><span class="line">        <span class="keyword">switch</span> (<span class="keyword">self</span>.responseSerializerType) &#123;</span><br><span class="line">            <span class="keyword">case</span> YTKResponseSerializerTypeHTTP:</span><br><span class="line">                <span class="comment">// Do nothing.</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">            <span class="keyword">case</span> YTKResponseSerializerTypeJSON:</span><br><span class="line">                _cacheJSON = [<span class="built_in">NSJSONSerialization</span> JSONObjectWithData:_cacheData options:(<span class="built_in">NSJSONReadingOptions</span>)<span class="number">0</span> error:&amp;error];</span><br><span class="line">                <span class="keyword">return</span> error == <span class="literal">nil</span>;</span><br><span class="line">            <span class="keyword">case</span> YTKResponseSerializerTypeXMLParser:</span><br><span class="line">                _cacheXML = [[<span class="built_in">NSXMLParser</span> alloc] initWithData:_cacheData];</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><strong>向应用层交付缓存数据</strong></strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line"><span class="string">    [self requestCompletePreprocessor]</span>;</span><br><span class="line"><span class="string">    [self requestCompleteFilter]</span>;</span><br><span class="line">    YTKRequest *strongSelf = self;</span><br><span class="line"><span class="string">    [strongSelf.delegate requestFinished:strongSelf]</span>;</span><br><span class="line">    <span class="keyword">if</span> (strongSelf.successCompletionBlock) &#123;</span><br><span class="line">        strongSelf.successCompletionBlock(strongSelf);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="string">    [strongSelf clearCompletionBlock]</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这里照样会通过delegate以及block进行交付，但是刚开始会感到奇怪我们刚刚加载数据的时候是加载到****_cacheString<strong><strong>这些地方，但是这里交付却是</strong></strong>strongSelf****，那么我们通过strongSelf的responseString这些对象访问的时候怎么转到_cacheString中的呢？</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">- (NSString *)responseString &#123;</span><br><span class="line">    <span class="keyword">if</span> (_cacheString) &#123;</span><br><span class="line">        <span class="keyword">return</span> _cacheString;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> responseString];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>嗯，就是在getter方法中拦截，所以及时重置_cacheString非常关键。</p>
<p><strong><strong>缓存数据</strong></strong></p>
<p>还有最后一个问题？这些缓存数据是怎么来的呢？</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- (<span class="type">void</span>)requestCompletePreprocessor &#123;</span><br><span class="line"></span><br><span class="line">    [<span class="variable language_">super</span> requestCompletePreprocessor];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.writeCacheAsynchronously) &#123;</span><br><span class="line">        <span class="built_in">dispatch_async</span>(ytkrequest_cache_writing_queue(), ^&#123;</span><br><span class="line">            [<span class="keyword">self</span> saveResponseDataToCacheFile:[<span class="variable language_">super</span> responseData]];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        [<span class="keyword">self</span> saveResponseDataToCacheFile:[<span class="variable language_">super</span> responseData]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们知道请求结束的时候会调用<strong><strong>requestCompletePreprocessor</strong></strong> 这时候会调用 *<em><strong>saveResponseDataToCacheFile</strong></em>**。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)saveResponseDataToCacheFile:(<span class="built_in">NSData</span> *)data &#123;</span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span> cacheTimeInSeconds] &gt; <span class="number">0</span> &amp;&amp; ![<span class="keyword">self</span> isDataFromCache]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (data != <span class="literal">nil</span>) &#123;</span><br><span class="line">            <span class="keyword">@try</span> &#123;</span><br><span class="line">                <span class="comment">// New data will always overwrite old data.</span></span><br><span class="line">                [data writeToFile:[<span class="keyword">self</span> cacheFilePath] atomically:<span class="literal">YES</span>];</span><br><span class="line"></span><br><span class="line">                YTKCacheMetadata *metadata = [[YTKCacheMetadata alloc] init];</span><br><span class="line">                metadata.version = [<span class="keyword">self</span> cacheVersion];</span><br><span class="line">                metadata.sensitiveDataString = ((<span class="built_in">NSObject</span> *)[<span class="keyword">self</span> cacheSensitiveData]).description;</span><br><span class="line">                metadata.stringEncoding = [YTKNetworkUtils stringEncodingWithRequest:<span class="keyword">self</span>];</span><br><span class="line">                metadata.creationDate = [<span class="built_in">NSDate</span> date];</span><br><span class="line">                metadata.appVersionString = [YTKNetworkUtils appVersionString];</span><br><span class="line">                [<span class="built_in">NSKeyedArchiver</span> archiveRootObject:metadata toFile:[<span class="keyword">self</span> cacheMetadataFilePath]];</span><br><span class="line">            &#125; <span class="keyword">@catch</span> (<span class="built_in">NSException</span> *exception) &#123;</span><br><span class="line">                YTKLog(<span class="string">@&quot;Save cache failed, reason = %@&quot;</span>, exception.reason);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在saveResponseDataToCacheFile方法中会将服务端返回的数据写到缓存目录下，然后再更新缓存信息。</p>
<h5 id="6-断点续传"><a href="#6-断点续传" class="headerlink" title="6. 断点续传"></a>6. 断点续传</h5><p>断点续传其实上面已经介绍过了，既然这里已经将它拎出来了，就做个总结把：</p>
<p>这里最关键在于两个方面：<br>请求中断的时候怎么缓存数据，请求开始的时候怎么续传：</p>
<p>YTKNetWork中会在请求失败，以及取消请求的时候对数据进行缓存：</p>
<p><strong><strong>失败时候进行缓存</strong></strong></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)requestDidFailWithRequest:(YTKBaseRequest *)request error:(<span class="built_in">NSError</span> *)error &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSData</span> *incompleteDownloadData = error.userInfo[<span class="built_in">NSURLSessionDownloadTaskResumeData</span>];</span><br><span class="line">    <span class="built_in">NSURL</span> *localUrl = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">if</span> (request.resumableDownloadPath) &#123;</span><br><span class="line">        localUrl = [<span class="keyword">self</span> incompleteDownloadTempPathForDownloadPath:request.resumableDownloadPath];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (incompleteDownloadData &amp;&amp; localUrl != <span class="literal">nil</span>) &#123;</span><br><span class="line">        [incompleteDownloadData writeToURL:localUrl atomically:<span class="literal">YES</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//........</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong><strong>取消请求后的缓存</strong></strong></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- (<span class="type">void</span>)cancelRequest:(YTKBaseRequest *)request &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果有指定恢复下载文件的路径则取消后将数据写到恢复下载文件的地方</span></span><br><span class="line">    <span class="keyword">if</span> (request.resumableDownloadPath &amp;&amp; [<span class="keyword">self</span> incompleteDownloadTempPathForDownloadPath:request.resumableDownloadPath] != <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="built_in">NSURLSessionDownloadTask</span> *requestTask = (<span class="built_in">NSURLSessionDownloadTask</span> *)request.requestTask;</span><br><span class="line">        [requestTask cancelByProducingResumeData:^(<span class="built_in">NSData</span> *resumeData) &#123;</span><br><span class="line">            <span class="built_in">NSURL</span> *localUrl = [<span class="keyword">self</span> incompleteDownloadTempPathForDownloadPath:request.resumableDownloadPath];</span><br><span class="line">            [resumeData writeToURL:localUrl atomically:<span class="literal">YES</span>];</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//直接调用NSURLSessionDataTask cancel</span></span><br><span class="line">        [request.requestTask cancel];</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="keyword">self</span> removeRequestFromRecord:request];</span><br><span class="line">    <span class="comment">//清除请求成功失败的block</span></span><br><span class="line">    [request clearCompletionBlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动请求之前会先查看下载缓存地址，如果有数据则通过<strong><strong>downloadTaskWithResumeData</strong></strong>继续:</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">NSURLSessionDownloadTask</span> *)downloadTaskWithDownloadPath:(<span class="built_in">NSString</span> *)downloadPath</span><br><span class="line">                                         requestSerializer:(AFHTTPRequestSerializer *)requestSerializer</span><br><span class="line">                                                 URLString:(<span class="built_in">NSString</span> *)URLString</span><br><span class="line">                                                parameters:(<span class="type">id</span>)parameters</span><br><span class="line">                                                  progress:(<span class="keyword">nullable</span> <span class="type">void</span> (^)(<span class="built_in">NSProgress</span> *downloadProgress))downloadProgressBlock</span><br><span class="line">                                                     error:(<span class="built_in">NSError</span> * _Nullable __autoreleasing *)error &#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="comment">// 在下载前如果文件存在先直接删除</span></span><br><span class="line">    <span class="keyword">if</span> ([[<span class="built_in">NSFileManager</span> defaultManager] fileExistsAtPath:downloadTargetPath]) &#123;</span><br><span class="line">        [[<span class="built_in">NSFileManager</span> defaultManager] removeItemAtPath:downloadTargetPath error:<span class="literal">nil</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">BOOL</span> resumeSucceeded = <span class="literal">NO</span>;</span><br><span class="line">    __block <span class="built_in">NSURLSessionDownloadTask</span> *downloadTask = <span class="literal">nil</span>;</span><br><span class="line">    <span class="comment">//未下载完成存储路径</span></span><br><span class="line">    <span class="built_in">NSURL</span> *localUrl = [<span class="keyword">self</span> incompleteDownloadTempPathForDownloadPath:downloadPath];</span><br><span class="line">    <span class="keyword">if</span> (localUrl != <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="comment">// 是否存在未下载完成的文件</span></span><br><span class="line">        <span class="type">BOOL</span> resumeDataFileExists = [[<span class="built_in">NSFileManager</span> defaultManager] fileExistsAtPath:localUrl.path];</span><br><span class="line">        <span class="comment">// 加载数据</span></span><br><span class="line">        <span class="built_in">NSData</span> *data = [<span class="built_in">NSData</span> dataWithContentsOfURL:localUrl];</span><br><span class="line">        <span class="comment">// 数据是否合法</span></span><br><span class="line">        <span class="type">BOOL</span> resumeDataIsValid = [YTKNetworkUtils validateResumeData:data];</span><br><span class="line">        <span class="comment">//是否可以恢复</span></span><br><span class="line">        <span class="type">BOOL</span> canBeResumed = resumeDataFileExists &amp;&amp; resumeDataIsValid;</span><br><span class="line">        <span class="comment">// Try to resume with resumeData.</span></span><br><span class="line">        <span class="comment">// Even though we try to validate the resumeData, this may still fail and raise excecption.</span></span><br><span class="line">        <span class="keyword">if</span> (canBeResumed) &#123;</span><br><span class="line">            <span class="keyword">@try</span> &#123;</span><br><span class="line">                downloadTask = [_manager downloadTaskWithResumeData:data progress:downloadProgressBlock destination:^<span class="built_in">NSURL</span> * _Nonnull(<span class="built_in">NSURL</span> * _Nonnull targetPath, <span class="built_in">NSURLResponse</span> * _Nonnull response) &#123;</span><br><span class="line">                    <span class="keyword">return</span> [<span class="built_in">NSURL</span> fileURLWithPath:downloadTargetPath isDirectory:<span class="literal">NO</span>];</span><br><span class="line">                &#125; completionHandler:</span><br><span class="line">                                ^(<span class="built_in">NSURLResponse</span> * _Nonnull response, <span class="built_in">NSURL</span> * _Nullable filePath, <span class="built_in">NSError</span> * _Nullable error) &#123;</span><br><span class="line">                                    [<span class="keyword">self</span> handleRequestResult:downloadTask responseObject:filePath error:error];</span><br><span class="line">                                &#125;];</span><br><span class="line">                resumeSucceeded = <span class="literal">YES</span>;</span><br><span class="line">            &#125; <span class="keyword">@catch</span> (<span class="built_in">NSException</span> *exception) &#123;</span><br><span class="line">                YTKLog(<span class="string">@&quot;Resume download failed, reason = %@&quot;</span>, exception.reason);</span><br><span class="line">                resumeSucceeded = <span class="literal">NO</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> downloadTask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="7-Filter"><a href="#7-Filter" class="headerlink" title="7. Filter"></a>7. Filter</h5><p>在YTKNetworkConfig中有两个Filter，一个是_urlFilters，一个是_cacheDirPathFilters</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="meta">@implementation</span> <span class="type">YTKNetworkConfig</span> &#123;</span><br><span class="line">    <span class="type">NSMutableArray</span>&lt;id&lt;<span class="type">YTKUrlFilterProtocol</span>&gt;<span class="operator">&gt;</span> <span class="operator">*</span>_urlFilters;</span><br><span class="line">    <span class="type">NSMutableArray</span>&lt;id&lt;<span class="type">YTKCacheDirPathFilterProtocol</span>&gt;<span class="operator">&gt;</span> <span class="operator">*</span>_cacheDirPathFilters;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>url filter它会对所有发起请求的requestUrl进行处理：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">- (NSString *)buildRequestUrl:(YTKBaseRequest *)request &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="regexp">//</span>.......</span><br><span class="line">    </span><br><span class="line">    <span class="regexp">//</span> 对构建出来的URL通过Config中预设的urlFilters 一一对它进行处理，比如添加公共字段等</span><br><span class="line">    NSArray *filters = [_config urlFilters];</span><br><span class="line">    <span class="keyword">for</span> (id&lt;YTKUrlFilterProtocol&gt; f <span class="keyword">in</span> filters) &#123;</span><br><span class="line">        detailUrl = [f filterUrl:detailUrl withRequest:request];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="regexp">//</span>......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>cacheDirPathFilters filter会在创建缓存路径的时候调用：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">NSString</span> *)cacheBasePath &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *pathOfLibrary = [<span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSLibraryDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">YES</span>) objectAtIndex:<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">NSString</span> *path = [pathOfLibrary stringByAppendingPathComponent:<span class="string">@&quot;LazyRequestCache&quot;</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Filter cache base path</span></span><br><span class="line">    <span class="built_in">NSArray</span>&lt;<span class="type">id</span>&lt;YTKCacheDirPathFilterProtocol&gt;&gt; *filters = [[YTKNetworkConfig sharedConfig] cacheDirPathFilters];</span><br><span class="line">    <span class="keyword">if</span> (filters.count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">id</span>&lt;YTKCacheDirPathFilterProtocol&gt; f <span class="keyword">in</span> filters) &#123;</span><br><span class="line">            path = [f filterCacheDirPath:path withRequest:<span class="keyword">self</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="keyword">self</span> createDirectoryIfNeeded:path];</span><br><span class="line">    <span class="keyword">return</span> path;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="8-插件机制"><a href="#8-插件机制" class="headerlink" title="8. 插件机制"></a>8. 插件机制</h5><p>插件机制，这个在很多场合都会使用，其实就是一种观察者模式，将观察者添加到要观察对象的通知列表中，一旦某个关键环节发生了，就便利这些观察者，调用他们的方法通知他们。这时候观察者就可以插入自己想要的操作：<br>YTKNetWork中目前有三个类支持插件机制，分别是<strong><strong>YTKBaseRequest</strong></strong>，<strong><strong>YTKBatchRequest</strong></strong>，<strong><strong>YTKChainRequest</strong></strong></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YTKBaseRequest</span> (<span class="title">RequestAccessory</span>)</span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)toggleAccessoriesWillStartCallBack;</span><br><span class="line">- (<span class="type">void</span>)toggleAccessoriesWillStopCallBack;</span><br><span class="line">- (<span class="type">void</span>)toggleAccessoriesDidStopCallBack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YTKBatchRequest</span> (<span class="title">RequestAccessory</span>)</span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)toggleAccessoriesWillStartCallBack;</span><br><span class="line">- (<span class="type">void</span>)toggleAccessoriesWillStopCallBack;</span><br><span class="line">- (<span class="type">void</span>)toggleAccessoriesDidStopCallBack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YTKChainRequest</span> (<span class="title">RequestAccessory</span>)</span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)toggleAccessoriesWillStartCallBack;</span><br><span class="line">- (<span class="type">void</span>)toggleAccessoriesWillStopCallBack;</span><br><span class="line">- (<span class="type">void</span>)toggleAccessoriesDidStopCallBack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>他们都持有requestAccessories:</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">nullable</span>) <span class="built_in">NSMutableArray</span>&lt;<span class="type">id</span>&lt;YTKRequestAccessory&gt;&gt; *requestAccessories;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)addAccessory:(<span class="type">id</span>&lt;YTKRequestAccessory&gt;)accessory;</span><br></pre></td></tr></table></figure>

<p>其实个人认为这里的requestAccessories权限应该限制为readonly比较合适，只是一个小建议。</p>
<p>触发时机，这里以<strong><strong>YTKBaseRequest</strong></strong>为例子，嗯，不解释看代码。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)start &#123;</span><br><span class="line">    [<span class="keyword">self</span> toggleAccessoriesWillStartCallBack];</span><br><span class="line">    [[YTKNetworkAgent sharedAgent] addRequest:<span class="keyword">self</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)stop &#123;</span><br><span class="line">    [<span class="keyword">self</span> toggleAccessoriesWillStopCallBack];</span><br><span class="line">    <span class="keyword">self</span>.delegate = <span class="literal">nil</span>;</span><br><span class="line">    [[YTKNetworkAgent sharedAgent] cancelRequest:<span class="keyword">self</span>];</span><br><span class="line">    [<span class="keyword">self</span> toggleAccessoriesDidStopCallBack];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好了 YTKNetWork的解析就到这里，今天周六，祝大家周末愉快！</p>
  
	</div>
		<footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/iOS-%E5%BC%80%E6%BA%90%E5%BA%93%E5%88%86%E6%9E%90/">iOS 开源库分析</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/iOS-开源库分析/">iOS 开源库分析</a>
  </div>

</div>



</footer>

   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2019/11/30/SDWebImage-源码解析/" title="SDWebImage 源码解析">
  <span>
  SDWebImage 源码解析</span>
</a>
</div>


<div class="next">
<a href="/2019/11/28/日志库CocoaLumberjack-源码解析/"  title="日志库CocoaLumberjack 源码解析">
 <span>日志库CocoaLumberjack 源码解析
</span>
</a>
</div>

</nav>

	
<section id="comments" class="comment">
	<div class="ds-thread" data-thread-key="2019/11/28/YTKNetWork源码解析/" data-title="YTKNetWork源码解析" data-url="http://yoursite.com/2019/11/28/YTKNetWork%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"></div>
</section>


<section id="comments" class="comment">
  <div id="disqus_thread">
    <noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  </div>
</section>

</div>  
      <div class="openaside"><a class="navbutton" href="#" title="Show Sidebar"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">Contents</strong>
 
 <ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%80%E6%BA%90%E4%BB%A3%E7%A0%81%E4%BF%A1%E6%81%AF"><span class="toc-number">1.</span> <span class="toc-text">开源代码信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">2.</span> <span class="toc-text">源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-YTKRequest-amp-amp-YTKBaseRequest-%E7%9A%84%E7%BB%84%E6%88%90"><span class="toc-number">2.1.</span> <span class="toc-text">1. YTKRequest &amp;&amp; YTKBaseRequest 的组成</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%9F%BA%E6%9C%AC%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B"><span class="toc-number">2.2.</span> <span class="toc-text">2. 基本请求过程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E6%89%B9%E9%87%8F%E8%AF%B7%E6%B1%82"><span class="toc-number">2.3.</span> <span class="toc-text">3. 批量请求</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E9%93%BE%E5%BC%8F%E8%AF%B7%E6%B1%82"><span class="toc-number">2.4.</span> <span class="toc-text">4. 链式请求</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6"><span class="toc-number">2.5.</span> <span class="toc-text">5. 缓存机制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-%E6%96%AD%E7%82%B9%E7%BB%AD%E4%BC%A0"><span class="toc-number">2.6.</span> <span class="toc-text">6. 断点续传</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-Filter"><span class="toc-number">2.7.</span> <span class="toc-text">7. Filter</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8-%E6%8F%92%E4%BB%B6%E6%9C%BA%E5%88%B6"><span class="toc-number">2.8.</span> <span class="toc-text">8. 插件机制</span></a></li></ol></li></ol>
 
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="Hide Sidebar"></a></div>
<aside class="clearfix">
<div id="authorInfo">
	
		<div class="author-img"></div>		
	
	<div class="social-info" class="clearfix">
		
		
		<a href="https://github.com/tbfungeek" target="_blank" class="icon-github" title="github"></a>
		
		
		
		
		
		
		
		
		
		
		<a href="mailto:tbfungeek@163.com" target="_blank" class="icon-email" title="Email Me"></a>
		

	</div>
</div>

  
<div class="categorieslist">
	<p class="asidetitle">Categories</p>
		<ul>
		
		  
			<li><a href="/categories/Android-小经验/" title="Android 小经验">Android 小经验<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Android-源码分析/" title="Android 源码分析">Android 源码分析<sup>21</sup></a></li>
		  
		
		  
			<li><a href="/categories/Android其他/" title="Android其他">Android其他<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Android初步/" title="Android初步">Android初步<sup>21</sup></a></li>
		  
		
		  
			<li><a href="/categories/Android进阶/" title="Android进阶">Android进阶<sup>100</sup></a></li>
		  
		
		  
			<li><a href="/categories/Hexo-使用/" title="Hexo 使用">Hexo 使用<sup>10</sup></a></li>
		  
		
		  
			<li><a href="/categories/JavaScript理论/" title="JavaScript理论">JavaScript理论<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Objective-C-相关/" title="Objective C 相关">Objective C 相关<sup>24</sup></a></li>
		  
		
		  
			<li><a href="/categories/OpenCV/" title="OpenCV">OpenCV<sup>6</sup></a></li>
		  
		
		  
			<li><a href="/categories/ROS/" title="ROS">ROS<sup>9</sup></a></li>
		  
		
		  
			<li><a href="/categories/iOS-工具使用/" title="iOS 工具使用">iOS 工具使用<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/iOS-开源库分析/" title="iOS 开源库分析">iOS 开源库分析<sup>36</sup></a></li>
		  
		
		  
			<li><a href="/categories/iOS-理论基础/" title="iOS 理论基础">iOS 理论基础<sup>14</sup></a></li>
		  
		
		  
			<li><a href="/categories/iOS-进阶/" title="iOS 进阶">iOS 进阶<sup>4</sup></a></li>
		  
		
		  
			<li><a href="/categories/个人收藏/" title="个人收藏">个人收藏<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/代码规范/" title="代码规范">代码规范<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/其他/" title="其他">其他<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/博客分类目录/" title="博客分类目录">博客分类目录<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/叨叨系列/" title="叨叨系列">叨叨系列<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/开源代码分析/" title="开源代码分析">开源代码分析<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/开源库分析/" title="开源库分析">开源库分析<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/树莓派/" title="树莓派">树莓派<sup>4</sup></a></li>
		  
		
		  
			<li><a href="/categories/版本控制/" title="版本控制">版本控制<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/直播/" title="直播">直播<sup>6</sup></a></li>
		  
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">Tags</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/iOS-开源库分析/" title="iOS 开源库分析">iOS 开源库分析<sup>36</sup></a></li>
			
		
			
				<li><a href="/tags/Android-设计模式/" title="Android 设计模式">Android 设计模式<sup>29</sup></a></li>
			
		
			
				<li><a href="/tags/Objective-C-相关/" title="Objective C 相关">Objective C 相关<sup>24</sup></a></li>
			
		
			
				<li><a href="/tags/Android基础/" title="Android基础">Android基础<sup>21</sup></a></li>
			
		
			
				<li><a href="/tags/AOSP-源码/" title="AOSP 源码">AOSP 源码<sup>17</sup></a></li>
			
		
			
				<li><a href="/tags/Android-常用第三方库/" title="Android 常用第三方库">Android 常用第三方库<sup>15</sup></a></li>
			
		
			
				<li><a href="/tags/iOS-理论基础/" title="iOS 理论基础">iOS 理论基础<sup>14</sup></a></li>
			
		
			
				<li><a href="/tags/Hexo-使用/" title="Hexo 使用">Hexo 使用<sup>10</sup></a></li>
			
		
			
				<li><a href="/tags/ROS/" title="ROS">ROS<sup>9</sup></a></li>
			
		
			
				<li><a href="/tags/Android-动画进阶/" title="Android 动画进阶">Android 动画进阶<sup>8</sup></a></li>
			
		
			
				<li><a href="/tags/Android-JNI/" title="Android JNI">Android JNI<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/Android-绘图进阶/" title="Android 绘图进阶">Android 绘图进阶<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/Android性能优化/" title="Android性能优化">Android性能优化<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/Android-自动化测试/" title="Android 自动化测试">Android 自动化测试<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/OpenCV/" title="OpenCV">OpenCV<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/直播/" title="直播">直播<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/Android-开源源码/" title="Android 开源源码">Android 开源源码<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/Android-自定义View进阶/" title="Android 自定义View进阶">Android 自定义View进阶<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/树莓派/" title="树莓派">树莓派<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/iOS-进阶/" title="iOS 进阶">iOS 进阶<sup>4</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">Links</p>
    <ul>
        
          <li>
            
            	<a href="https://hexo.io" target="_blank" title="Hexo">Hexo</a>
            
          </li>
        
          <li>
            
            	<a href="https://pages.github.com/" target="_blank" title="GitHub">GitHub</a>
            
          </li>
        
          <li>
            
            	<a href="http://pf18.github.io/" target="_blank" title="PF18">PF18</a>
            
          </li>
        
          <li>
            
            	<a href="http://toutiao.io/" target="_blank" title="开发者头条">开发者头条</a>
            
          </li>
        
          <li>
            
            	<a href="http://www.jcodecraeer.com/" target="_blank" title="泡在网上的日子">泡在网上的日子</a>
            
          </li>
        
    </ul>
</div>

  


  <div class="rsspart">
	<a href="atom.xml" target="_blank" title="rss">RSS</a>
</div>

  
  <div class="tagcloudlist">
    <p class="asidetitle">Tag Cloud</p>
    <div class="tagcloudlist clearfix">
       <a href="/tags/AOSP-%E6%BA%90%E7%A0%81/" style="font-size: 17.14px;">AOSP 源码</a> <a href="/tags/Android-APK-%E7%AD%BE%E5%90%8D/" style="font-size: 10px;">Android APK 签名</a> <a href="/tags/Android-JNI/" style="font-size: 12.86px;">Android JNI</a> <a href="/tags/Android-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E8%BF%9B%E9%98%B6/" style="font-size: 10.71px;">Android 事件处理进阶</a> <a href="/tags/Android-%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6/" style="font-size: 13.57px;">Android 动画进阶</a> <a href="/tags/Android-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%80%E5%8F%91/" style="font-size: 10px;">Android 多线程开发</a> <a href="/tags/Android-%E5%B0%8F%E7%BB%8F%E9%AA%8C/" style="font-size: 10px;">Android 小经验</a> <a href="/tags/Android-%E5%B8%B8%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/" style="font-size: 16.43px;">Android 常用第三方库</a> <a href="/tags/Android-%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/" style="font-size: 10px;">Android 开发流程</a> <a href="/tags/Android-%E5%BC%80%E6%BA%90%E6%BA%90%E7%A0%81/" style="font-size: 12.14px;">Android 开源源码</a> <a href="/tags/Android-%E7%BB%98%E5%9B%BE%E8%BF%9B%E9%98%B6/" style="font-size: 12.86px;">Android 绘图进阶</a> <a href="/tags/Android-%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/" style="font-size: 12.86px;">Android 自动化测试</a> <a href="/tags/Android-%E8%87%AA%E5%AE%9A%E4%B9%89View%E8%BF%9B%E9%98%B6/" style="font-size: 12.14px;">Android 自定义View进阶</a> <a href="/tags/Android-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 19.29px;">Android 设计模式</a> <a href="/tags/Android%E5%85%B6%E4%BB%96/" style="font-size: 10px;">Android其他</a> <a href="/tags/Android%E5%9F%BA%E7%A1%80/" style="font-size: 17.86px;">Android基础</a> <a href="/tags/Android%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/" style="font-size: 10px;">Android开发流程</a> <a href="/tags/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" style="font-size: 12.86px;">Android性能优化</a> <a href="/tags/Android%E6%B7%B7%E6%B7%86%E6%8A%80%E6%9C%AF/" style="font-size: 10px;">Android混淆技术</a> <a href="/tags/Android%E8%B4%A8%E9%87%8F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/" style="font-size: 11.43px;">Android质量管理工具</a> <a href="/tags/Android%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/" style="font-size: 10px;">Android逆向工程</a> <a href="/tags/Git-github/" style="font-size: 10px;">Git && github</a> <a href="/tags/Hexo-%E4%BD%BF%E7%94%A8/" style="font-size: 15px;">Hexo 使用</a> <a href="/tags/JavaScript/" style="font-size: 10px;">JavaScript</a> <a href="/tags/Linux-%E4%BD%BF%E7%94%A8/" style="font-size: 10px;">Linux 使用</a> <a href="/tags/Objective-C-%E7%9B%B8%E5%85%B3/" style="font-size: 18.57px;">Objective C 相关</a> <a href="/tags/OpenCV/" style="font-size: 12.86px;">OpenCV</a> <a href="/tags/ROS/" style="font-size: 14.29px;">ROS</a> <a href="/tags/iOS-%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/" style="font-size: 10.71px;">iOS 工具使用</a> <a href="/tags/iOS-%E5%BC%80%E6%BA%90%E5%BA%93%E5%88%86%E6%9E%90/" style="font-size: 20px;">iOS 开源库分析</a> <a href="/tags/iOS-%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/" style="font-size: 15.71px;">iOS 理论基础</a> <a href="/tags/iOS-%E8%BF%9B%E9%98%B6/" style="font-size: 12.14px;">iOS 进阶</a> <a href="/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/" style="font-size: 10px;">代码规范</a> <a href="/tags/%E5%8D%9A%E5%AE%A2%E5%88%86%E7%B1%BB%E7%9B%AE%E5%BD%95/" style="font-size: 10.71px;">博客分类目录</a> <a href="/tags/%E5%8F%A8%E5%8F%A8%E7%B3%BB%E5%88%97/" style="font-size: 10px;">叨叨系列</a> <a href="/tags/%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/" style="font-size: 11.43px;">工具的使用</a> <a href="/tags/%E5%BC%80%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/" style="font-size: 10.71px;">开源代码分析</a> <a href="/tags/%E5%BC%80%E6%BA%90%E5%BA%93%E5%88%86%E6%9E%90/" style="font-size: 10px;">开源库分析</a> <a href="/tags/%E6%9D%82%E7%B1%BB/" style="font-size: 10px;">杂类</a> <a href="/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/" style="font-size: 12.14px;">树莓派</a> <a href="/tags/%E7%9B%B4%E6%92%AD/" style="font-size: 12.86px;">直播</a> <a href="/tags/%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/" style="font-size: 10.71px;">编程技巧</a> <a href="/tags/%E7%BD%91%E7%AB%99%E6%94%B6%E8%97%8F/" style="font-size: 10px;">网站收藏</a> <a href="/tags/%E9%87%8D%E8%A6%81%E6%8E%A7%E4%BB%B6/" style="font-size: 11.43px;">重要控件</a>
    </div>
  </div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
		
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/hsihohuang/kiddochan" target="_blank" title="Kiddochan">Kiddochan</a> © 2022 
		
		<a href="/about" target="_blank" title="Edgar">Edgar</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
        getSize();
        if (myWidth >= 1024) {
          c.click();
        }
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  c.click(function(){
    ta.css('display', 'block').addClass('fadeIn');
  });
  o.click(function(){
    ta.css('display', 'none');
  });
  $(window).scroll(function(){
    ta.css("top",Math.max(140,320-$(this).scrollTop()));
  });
});
</script>




<script type="text/javascript">
  var duoshuoQuery = {short_name:"tbfungeek"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script> 


<script type="text/javascript">

var disqus_shortname = 'tbfungeek';

(function(){
  var dsq = document.createElement('script');
  dsq.type = 'text/javascript';
  dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
}());
(function(){
  var dsq = document.createElement('script');
  dsq.type = 'text/javascript';
  dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/count.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
}());
</script>






<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?7c9443b0374f1cf6b1dbb5ab84d939cb";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="Back to Top"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
</html>
