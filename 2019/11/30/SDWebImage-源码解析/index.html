
 <!DOCTYPE HTML>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
  
    <title>SDWebImage 源码解析 | Edgar&#39;s Blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="Edgar">
    

    
    <meta name="description" content="1. 开源代码信息 SDWebImage Github 库SDWebImage Main RepoSDWebImage 图片Coder插件列表 想必每个接触过iOS开发的开发者都接触过SDWebImage吧，它是一个带有缓存支持的异步图片下载工具。我们常用的UIImageView, *UIButton, MKAnnotationView，这些UI元素都有它为我们提供的专门分类用于异步图片的加载。">
<meta property="og:type" content="article">
<meta property="og:title" content="SDWebImage 源码解析">
<meta property="og:url" content="http://yoursite.com/2019/11/30/SDWebImage-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/index.html">
<meta property="og:site_name" content="Edgar&#39;s Blog">
<meta property="og:description" content="1. 开源代码信息 SDWebImage Github 库SDWebImage Main RepoSDWebImage 图片Coder插件列表 想必每个接触过iOS开发的开发者都接触过SDWebImage吧，它是一个带有缓存支持的异步图片下载工具。我们常用的UIImageView, *UIButton, MKAnnotationView，这些UI元素都有它为我们提供的专门分类用于异步图片的加载。">
<meta property="og:locale">
<meta property="og:image" content="http://yoursite.com/2019/11/30/SDWebImage-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/00001.png">
<meta property="og:image" content="http://yoursite.com/2019/11/30/SDWebImage-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/00006.png">
<meta property="og:image" content="http://yoursite.com/2019/11/30/SDWebImage-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/00003.png">
<meta property="og:image" content="http://yoursite.com/2019/11/30/SDWebImage-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/00002.jpeg">
<meta property="og:image" content="http://yoursite.com/2019/11/30/SDWebImage-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/00004.png">
<meta property="og:image" content="http://yoursite.com/2019/11/30/SDWebImage-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/00005.png">
<meta property="og:image" content="http://yoursite.com/2019/11/30/SDWebImage-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/00007.png">
<meta property="og:image" content="http://yoursite.com/2019/11/30/SDWebImage-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/00009.png">
<meta property="og:image" content="http://yoursite.com/2019/11/30/SDWebImage-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/000010.png">
<meta property="og:image" content="http://yoursite.com/2019/11/30/SDWebImage-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/00008.png">
<meta property="article:published_time" content="2019-11-29T18:09:33.000Z">
<meta property="article:modified_time" content="2019-12-19T13:31:44.000Z">
<meta property="article:author" content="Edgar">
<meta property="article:tag" content="iOS 开源库分析">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/2019/11/30/SDWebImage-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/00001.png">

    
    <link rel="alternative" href="atom.xml" title="Edgar&#39;s Blog" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/unnamed4_n_mSY_icon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/profile.png">
    <link rel="apple-touch-icon-precomposed" href="/img/profile.png">
    
    
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 6.2.0"></head>

  <body>
    <header>
      
<div>
		
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="Edgar&#39;s Blog">Edgar&#39;s Blog</a></h1>
				<h2 class="blog-motto"></h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="Menu">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
					<li>
 					
					<form class="search" action="/search/index.html" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" autocomplete="off" name="q" maxlength="20" placeholder="Search" />
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
  
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/11/30/SDWebImage-源码解析/" title="SDWebImage 源码解析" itemprop="url">SDWebImage 源码解析</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Edgar" target="_blank" itemprop="author">Edgar</a>
		
  <p class="article-time">
    <time datetime="2019-11-29T18:09:33.000Z" itemprop="datePublished"> Published 2019-11-30</time>
    
  </p>
</header>
	<div class="article-content">
		
		<h5 id="1-开源代码信息"><a href="#1-开源代码信息" class="headerlink" title="1. 开源代码信息"></a>1. 开源代码信息</h5><p><img src="/2019/11/30/SDWebImage-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/00001.png"></p>
<p><a target="_blank" rel="noopener" href="https://github.com/SDWebImage/SDWebImage">SDWebImage Github 库</a><br><a target="_blank" rel="noopener" href="https://github.com/SDWebImage">SDWebImage Main Repo</a><br><a target="_blank" rel="noopener" href="https://github.com/SDWebImage/SDWebImage/wiki/Coder-Plugin-List">SDWebImage 图片Coder插件列表</a></p>
<p>想必每个接触过iOS开发的开发者都接触过<strong><strong>SDWebImage</strong></strong>吧，它是一个带有缓存支持的异步图片下载工具。我们常用的<strong><strong>UIImageView</strong></strong>, *<strong><strong>UIButton</strong></strong>, <strong><strong>MKAnnotationView</strong></strong>，这些UI元素都有它为我们提供的专门分类用于异步图片的加载。</p>
<p><strong><strong>特性</strong></strong></p>
<ul>
<li>为UIImageView, UIButton, MKAnnotationView这些类提供了用于图片加载以及缓存管理的分类。</li>
<li>带有一个异步的图片下载器以及一个缓存过期自动处理的异步内存图片缓存管理。</li>
<li>支持后台图片解压</li>
<li>支持渐进式图片加载功能</li>
<li>可扩展的图像编码器以支持大图片格式，例如WebP</li>
<li>动画图像的全栈解决方案能够做到在CPU和内存之间保持性能平衡</li>
<li>能够支持对下载后图片进行自定义且可组合的转换</li>
<li>可定制的多缓存系统</li>
<li>支持图片加载指示器</li>
<li>支持图片加载过渡动画</li>
<li>同一个URL不会下载多次，虚假的URL不会一直重试</li>
<li>保证主线程不会被阻塞</li>
<li>支持Objective-C 以及 Swift</li>
<li>高性能</li>
<li>支持JPEG, PNG, HEIC图片格式，包含GIF&#x2F;APNG&#x2F;HEIC动画格式</li>
<li>支持WebP，以及动画WebP格式</li>
<li>支持可扩张的图片编码器插件，可以通过它来添加更多新的格式。</li>
</ul>
<h5 id="2-源码解析"><a href="#2-源码解析" class="headerlink" title="2. 源码解析"></a>2. 源码解析</h5><h6 id="2-1-总入口"><a href="#2-1-总入口" class="headerlink" title="2.1 总入口"></a>2.1 总入口</h6><p>我们先来看下给UIImageView设置网络图片的流程的代码，这是我们最常用的一个功能，这部分代码位于：<br><strong><strong>UIView+WebCache.h</strong></strong>其他部分涉及到图片加载的最终都是调用这个方法：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)sd_internalSetImageWithURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url</span><br><span class="line">                  placeholderImage:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)placeholder</span><br><span class="line">                           options:(SDWebImageOptions)options</span><br><span class="line">                           context:(<span class="keyword">nullable</span> SDWebImageContext *)context</span><br><span class="line">                     setImageBlock:(<span class="keyword">nullable</span> SDSetImageBlock)setImageBlock</span><br><span class="line">                          progress:(<span class="keyword">nullable</span> SDImageLoaderProgressBlock)progressBlock</span><br><span class="line">                         completed:(<span class="keyword">nullable</span> SDInternalCompletionBlock)completedBlock &#123;</span><br><span class="line">    </span><br><span class="line">    context = [context <span class="keyword">copy</span>]; <span class="comment">// copy to avoid mutable object</span></span><br><span class="line">    <span class="built_in">NSString</span> *validOperationKey = context[SDWebImageContextSetImageOperationKey];</span><br><span class="line">    <span class="keyword">if</span> (!validOperationKey) &#123;</span><br><span class="line">        validOperationKey = <span class="built_in">NSStringFromClass</span>([<span class="keyword">self</span> <span class="keyword">class</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">self</span>.sd_latestOperationKey = validOperationKey;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//取消当前运行的同样请求</span></span><br><span class="line">    [<span class="keyword">self</span> sd_cancelImageLoadOperationWithKey:validOperationKey];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置本次加载的URL</span></span><br><span class="line">    <span class="keyword">self</span>.sd_imageURL = url;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//立刻设置占位图</span></span><br><span class="line">    <span class="keyword">if</span> (!(options &amp; SDWebImageDelayPlaceholder)) &#123;</span><br><span class="line">        dispatch_main_async_safe(^&#123;</span><br><span class="line">            <span class="comment">//设置占位图</span></span><br><span class="line">            [<span class="keyword">self</span> sd_setImage:placeholder imageData:<span class="literal">nil</span> basedOnClassOrViaCustomSetImageBlock:setImageBlock cacheType:SDImageCacheTypeNone imageURL:url];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (url) &#123;</span><br><span class="line">        <span class="comment">// 重置进度状态</span></span><br><span class="line">        <span class="built_in">NSProgress</span> *imageProgress = objc_getAssociatedObject(<span class="keyword">self</span>, <span class="keyword">@selector</span>(sd_imageProgress));</span><br><span class="line">        <span class="keyword">if</span> (imageProgress) &#123;</span><br><span class="line">            imageProgress.totalUnitCount = <span class="number">0</span>;</span><br><span class="line">            imageProgress.completedUnitCount = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 开始图片加载指示器</span></span><br><span class="line">        [<span class="keyword">self</span> sd_startImageIndicator];</span><br><span class="line">        <span class="comment">// 图片指示器</span></span><br><span class="line">        <span class="type">id</span>&lt;SDWebImageIndicator&gt; imageIndicator = <span class="keyword">self</span>.sd_imageIndicator;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//图片管理器</span></span><br><span class="line">        SDWebImageManager *manager = context[SDWebImageContextCustomManager];</span><br><span class="line">        <span class="keyword">if</span> (!manager) &#123;</span><br><span class="line">            manager = [SDWebImageManager sharedManager];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//更新进度</span></span><br><span class="line">        SDImageLoaderProgressBlock combinedProgressBlock = ^(<span class="built_in">NSInteger</span> receivedSize, <span class="built_in">NSInteger</span> expectedSize, <span class="built_in">NSURL</span> * _Nullable targetURL) &#123;</span><br><span class="line">            <span class="keyword">if</span> (imageProgress) &#123;</span><br><span class="line">                imageProgress.totalUnitCount = expectedSize;</span><br><span class="line">                imageProgress.completedUnitCount = receivedSize;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ([imageIndicator respondsToSelector:<span class="keyword">@selector</span>(updateIndicatorProgress:)]) &#123;</span><br><span class="line">                <span class="type">double</span> progress = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (expectedSize != <span class="number">0</span>) &#123;</span><br><span class="line">                    progress = (<span class="type">double</span>)receivedSize / expectedSize;</span><br><span class="line">                &#125;</span><br><span class="line">                progress = MAX(MIN(progress, <span class="number">1</span>), <span class="number">0</span>); <span class="comment">// 0.0 - 1.0</span></span><br><span class="line">                <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                    [imageIndicator updateIndicatorProgress:progress];</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (progressBlock) &#123;</span><br><span class="line">                progressBlock(receivedSize, expectedSize, targetURL);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//加载图片</span></span><br><span class="line">        @weakify(<span class="keyword">self</span>);</span><br><span class="line">        <span class="type">id</span> &lt;SDWebImageOperation&gt; operation = [manager loadImageWithURL:url</span><br><span class="line">                                                               options:options</span><br><span class="line">                                                               context:context</span><br><span class="line">                                                              progress:combinedProgressBlock</span><br><span class="line">                                                             completed:^(<span class="built_in">UIImage</span> *image, <span class="built_in">NSData</span> *data, <span class="built_in">NSError</span> *error, SDImageCacheType cacheType, <span class="type">BOOL</span> finished, <span class="built_in">NSURL</span> *imageURL) &#123;</span><br><span class="line">            @strongify(<span class="keyword">self</span>);</span><br><span class="line">            <span class="keyword">if</span> (!<span class="keyword">self</span>) &#123; <span class="keyword">return</span>; &#125;</span><br><span class="line">            <span class="comment">// if the progress not been updated, mark it to complete state</span></span><br><span class="line">            <span class="keyword">if</span> (imageProgress &amp;&amp; finished &amp;&amp; !error &amp;&amp; imageProgress.totalUnitCount == <span class="number">0</span> &amp;&amp; imageProgress.completedUnitCount == <span class="number">0</span>) &#123;</span><br><span class="line">                imageProgress.totalUnitCount = SDWebImageProgressUnitCountUnknown;</span><br><span class="line">                imageProgress.completedUnitCount = SDWebImageProgressUnitCountUnknown;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 加载结束后停止图片指示器</span></span><br><span class="line">            <span class="keyword">if</span> (finished) &#123;</span><br><span class="line">                [<span class="keyword">self</span> sd_stopImageIndicator];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 是否自动调用complete Block</span></span><br><span class="line">            <span class="type">BOOL</span> shouldCallCompletedBlock = finished || (options &amp; SDWebImageAvoidAutoSetImage);</span><br><span class="line">            <span class="comment">// 是否不设置Image</span></span><br><span class="line">            <span class="type">BOOL</span> shouldNotSetImage = ((image &amp;&amp; (options &amp; SDWebImageAvoidAutoSetImage)) ||</span><br><span class="line">                                      (!image &amp;&amp; !(options &amp; SDWebImageDelayPlaceholder)));</span><br><span class="line">            </span><br><span class="line">            SDWebImageNoParamsBlock callCompletedBlockClojure = ^&#123;</span><br><span class="line">                <span class="keyword">if</span> (!<span class="keyword">self</span>) &#123; <span class="keyword">return</span>; &#125;</span><br><span class="line">                <span class="keyword">if</span> (!shouldNotSetImage) &#123;</span><br><span class="line">                    [<span class="keyword">self</span> sd_setNeedsLayout];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 是否调用completeBlock</span></span><br><span class="line">                <span class="keyword">if</span> (completedBlock &amp;&amp; shouldCallCompletedBlock) &#123;</span><br><span class="line">                    completedBlock(image, data, error, cacheType, finished, url);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 到这里有两种可能，一种是我们获得到了图片，但是SDWebImageAvoidAutoSetImage = 1 或者 我们没拿到图片，并且SDWebImageDelayPlaceholder = 0</span></span><br><span class="line">            <span class="keyword">if</span> (shouldNotSetImage) &#123;</span><br><span class="line">                dispatch_main_async_safe(callCompletedBlockClojure);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">UIImage</span> *targetImage = <span class="literal">nil</span>;</span><br><span class="line">            <span class="built_in">NSData</span> *targetData = <span class="literal">nil</span>;</span><br><span class="line">            <span class="keyword">if</span> (image) &#123;</span><br><span class="line">                <span class="comment">// 获得到额了图片，SDWebImageAvoidAutoSetImage = 0，这是正常流程。</span></span><br><span class="line">                targetImage = image;</span><br><span class="line">                targetData = data;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (options &amp; SDWebImageDelayPlaceholder) &#123;</span><br><span class="line">                <span class="comment">// 没得到图片，但是设置了SDWebImageDelayPlaceholder</span></span><br><span class="line">                targetImage = placeholder;</span><br><span class="line">                targetData = <span class="literal">nil</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 检查是否使用图片transition</span></span><br><span class="line">            SDWebImageTransition *transition = <span class="literal">nil</span>;</span><br><span class="line">            <span class="keyword">if</span> (finished &amp;&amp; (options &amp; SDWebImageForceTransition || cacheType == SDImageCacheTypeNone)) &#123;</span><br><span class="line">                transition = <span class="keyword">self</span>.sd_imageTransition;</span><br><span class="line">            &#125;</span><br><span class="line">            dispatch_main_async_safe(^&#123;</span><br><span class="line">                [<span class="keyword">self</span> sd_setImage:targetImage</span><br><span class="line">                        imageData:targetData</span><br><span class="line">basedOnClassOrViaCustomSetImageBlock:setImageBlock</span><br><span class="line">                       transition:transition</span><br><span class="line">                        cacheType:cacheType</span><br><span class="line">                         imageURL:imageURL];</span><br><span class="line">                callCompletedBlockClojure();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;];</span><br><span class="line">        <span class="comment">//设置当前的operation</span></span><br><span class="line">        [<span class="keyword">self</span> sd_setImageLoadOperation:operation forKey:validOperationKey];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果url为空则停止加载指示器，并抛出异常。</span></span><br><span class="line">        [<span class="keyword">self</span> sd_stopImageIndicator];</span><br><span class="line">        dispatch_main_async_safe(^&#123;</span><br><span class="line">            <span class="keyword">if</span> (completedBlock) &#123;</span><br><span class="line">                <span class="built_in">NSError</span> *error = [<span class="built_in">NSError</span> errorWithDomain:SDWebImageErrorDomain code:SDWebImageErrorInvalidURL userInfo:@&#123;<span class="built_in">NSLocalizedDescriptionKey</span> : <span class="string">@&quot;Image url is nil&quot;</span>&#125;];</span><br><span class="line">                completedBlock(<span class="literal">nil</span>, <span class="literal">nil</span>, error, SDImageCacheTypeNone, <span class="literal">YES</span>, url);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法主要完成了三大块任务：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1.</span> 图片指示器控制</span><br><span class="line"><span class="bullet">2.</span> 通过图片加载器加载图片</span><br><span class="line"><span class="bullet">3.</span> 下载完成后给控件设置图片</span><br></pre></td></tr></table></figure>

<p>其他包括缓存，后期图片转换的都在第二部分中处理。这里有些需要注意的细节简单过一下，都是一些option：</p>
<p><strong><strong>SDWebImageDelayPlaceholder</strong></strong> :<br>是否延迟加载占位图，默认一旦开始加载就会显示占位图，如果设置成延迟占位图，那么只有在图片没下载成功的时候设置。<br><strong><strong>SDWebImageContextCustomManager</strong></strong>:<br>可以外部注入图片管理器，负责图片的缓存控制和图片的下载。默认是没有注入的。<br><strong><strong>SDWebImageAvoidAutoSetImage</strong></strong>：<br>图片下载成功后是否不自动设置图片</p>
<h6 id="2-2-图片加载"><a href="#2-2-图片加载" class="headerlink" title="2.2 图片加载"></a>2.2 图片加载</h6><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (SDWebImageCombinedOperation *)loadImageWithURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url</span><br><span class="line">                                          options:(SDWebImageOptions)options</span><br><span class="line">                                          context:(<span class="keyword">nullable</span> SDWebImageContext *)context</span><br><span class="line">                                         progress:(<span class="keyword">nullable</span> SDImageLoaderProgressBlock)progressBlock</span><br><span class="line">                                        completed:(<span class="keyword">nonnull</span> SDInternalCompletionBlock)completedBlock &#123;</span><br><span class="line">    <span class="comment">// Invoking this method without a completedBlock is pointless</span></span><br><span class="line">    <span class="built_in">NSAssert</span>(completedBlock != <span class="literal">nil</span>, <span class="string">@&quot;If you mean to prefetch the image, use -[SDWebImagePrefetcher prefetchURLs] instead&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果传入的URL是字符串则将其转换为NSURL</span></span><br><span class="line">    <span class="keyword">if</span> ([url isKindOfClass:<span class="built_in">NSString</span>.class]) &#123;</span><br><span class="line">        url = [<span class="built_in">NSURL</span> URLWithString:(<span class="built_in">NSString</span> *)url];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果不是NSURL则设置url为空，避免崩溃</span></span><br><span class="line">    <span class="keyword">if</span> (![url isKindOfClass:<span class="built_in">NSURL</span>.class]) &#123;</span><br><span class="line">        url = <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SDWebImageCombinedOperation *operation = [SDWebImageCombinedOperation new];</span><br><span class="line">    operation.manager = <span class="keyword">self</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否是失败的URL</span></span><br><span class="line">    <span class="type">BOOL</span> isFailedUrl = <span class="literal">NO</span>;</span><br><span class="line">    <span class="keyword">if</span> (url) &#123;</span><br><span class="line">        SD_LOCK(<span class="keyword">self</span>.failedURLsLock);</span><br><span class="line">        isFailedUrl = [<span class="keyword">self</span>.failedURLs containsObject:url];</span><br><span class="line">        SD_UNLOCK(<span class="keyword">self</span>.failedURLsLock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果地址为空，或者是失败的url则取消请求</span></span><br><span class="line">    <span class="keyword">if</span> (url.absoluteString.length == <span class="number">0</span> || (!(options &amp; SDWebImageRetryFailed) &amp;&amp; isFailedUrl)) &#123;</span><br><span class="line">        [<span class="keyword">self</span> callCompletionBlockForOperation:operation completion:completedBlock error:[<span class="built_in">NSError</span> errorWithDomain:SDWebImageErrorDomain code:SDWebImageErrorInvalidURL userInfo:@&#123;<span class="built_in">NSLocalizedDescriptionKey</span> : <span class="string">@&quot;Image url is nil&quot;</span>&#125;] url:url];</span><br><span class="line">        <span class="keyword">return</span> operation;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将当前的operation添加到self.runningOperations 中表示该请求已经发起</span></span><br><span class="line">    SD_LOCK(<span class="keyword">self</span>.runningOperationsLock);</span><br><span class="line">    [<span class="keyword">self</span>.runningOperations addObject:operation];</span><br><span class="line">    SD_UNLOCK(<span class="keyword">self</span>.runningOperationsLock);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对options和context参数进行预先处理，这些会影响manager加载的最后处理结果</span></span><br><span class="line">    SDWebImageOptionsResult *result = [<span class="keyword">self</span> processedResultForURL:url options:options context:context];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 启动图片加载</span></span><br><span class="line">    [<span class="keyword">self</span> callCacheProcessForOperation:operation url:url options:result.options context:result.context progress:progressBlock completed:completedBlock];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> operation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在图片加载开始的时候会先对传入的url类型进行判断，这里的url可能会有两种类型一种是NSString,一种是NSURL这个阶段会分别对它做一个判断，并最终转换为NSURL,然后判断当前的url是否在failedURLs中，如果在的话会根据<strong><strong>SDWebImageRetryFailed</strong></strong>的配置来进行选择接下来的处理，如果SDWebImageRetryFailed &#x3D; 0的话 就表示不对失败的url进行重新尝试，所以这种情况会取消请求，failedURLs会在每次加载失败的时候添加。</p>
<p>紧接着会调用<strong><strong>processedResultForURL</strong></strong>对options和context参数进行预先处理，这些会影响manager加载的最后处理结果：</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">- (SDWebImageOptionsResult *)processedResultForURL:(NSURL *)url <span class="keyword">options</span>:(SDWebImageOptions)<span class="keyword">options</span> context:(SDWebImageContext *)context &#123;</span><br><span class="line">    SDWebImageOptionsResult *result;</span><br><span class="line">    SDWebImageMutableContext *mutableContext = [SDWebImageMutableContext dictionary];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 用于对下载后的图片进行转换后存储到缓存中</span></span><br><span class="line">    <span class="keyword">if</span> (!context[SDWebImageContextImageTransformer]) &#123;</span><br><span class="line">        id&lt;SDImageTransformer&gt; transformer = self.transformer;</span><br><span class="line">        [mutableContext setValue:transformer forKey:SDWebImageContextImageTransformer];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 用于将URL转换为它对应的缓存key的组件</span></span><br><span class="line">    <span class="keyword">if</span> (!context[SDWebImageContextCacheKeyFilter]) &#123;</span><br><span class="line">        id&lt;SDWebImageCacheKeyFilter&gt; cacheKeyFilter = self.cacheKeyFilter;</span><br><span class="line">        [mutableContext setValue:cacheKeyFilter forKey:SDWebImageContextCacheKeyFilter];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 用于将图片缓存到disk缓存中</span></span><br><span class="line">    <span class="keyword">if</span> (!context[SDWebImageContextCacheSerializer]) &#123;</span><br><span class="line">        id&lt;SDWebImageCacheSerializer&gt; cacheSerializer = self.cacheSerializer;</span><br><span class="line">        [mutableContext setValue:cacheSerializer forKey:SDWebImageContextCacheSerializer];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (mutableContext.<span class="keyword">count</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (context) &#123;</span><br><span class="line">            [mutableContext addEntriesFromDictionary:context];</span><br><span class="line">        &#125;</span><br><span class="line">        context = [mutableContext <span class="keyword">copy</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对当前的options 以及 context 进行进一步处理</span></span><br><span class="line">    <span class="keyword">if</span> (self.optionsProcessor) &#123;</span><br><span class="line">        result = [self.optionsProcessor processedResultForURL:url <span class="keyword">options</span>:<span class="keyword">options</span> context:context];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">        <span class="comment">// 创建默认的SDWebImageOptionsResult</span></span><br><span class="line">        result = [[SDWebImageOptionsResult alloc] initWithOptions:<span class="keyword">options</span> context:context];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它实际上是在context中加入了<strong><strong>SDImageTransformer</strong></strong>，<strong><strong>SDWebImageContextCacheKeyFilter</strong></strong>，以及<strong><strong>SDWebImageContextCacheSerializer</strong></strong>，然后通过<strong><strong>optionsProcessor</strong></strong> 对当前对options 以及 context进行统一处理后返回，这些组件会在加载过程中被提取出来使用。</p>
<h6 id="2-2-1-查询缓存还是从网络下载"><a href="#2-2-1-查询缓存还是从网络下载" class="headerlink" title="2.2.1 查询缓存还是从网络下载"></a>2.2.1 查询缓存还是从网络下载</h6><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)callCacheProcessForOperation:(<span class="keyword">nonnull</span> SDWebImageCombinedOperation *)operation</span><br><span class="line">                                 url:(<span class="keyword">nonnull</span> <span class="built_in">NSURL</span> *)url</span><br><span class="line">                             options:(SDWebImageOptions)options</span><br><span class="line">                             context:(<span class="keyword">nullable</span> SDWebImageContext *)context</span><br><span class="line">                            progress:(<span class="keyword">nullable</span> SDImageLoaderProgressBlock)progressBlock</span><br><span class="line">                           completed:(<span class="keyword">nullable</span> SDInternalCompletionBlock)completedBlock &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查当前是否需要查询缓存内的图片</span></span><br><span class="line">    <span class="type">BOOL</span> shouldQueryCache = !SD_OPTIONS_CONTAINS(options, SDWebImageFromLoaderOnly);</span><br><span class="line">    <span class="keyword">if</span> (shouldQueryCache) &#123;</span><br><span class="line">        <span class="comment">//通过url转缓存key的组件，将url转换为对应的缓存key</span></span><br><span class="line">        <span class="type">id</span>&lt;SDWebImageCacheKeyFilter&gt; cacheKeyFilter = context[SDWebImageContextCacheKeyFilter];</span><br><span class="line">        <span class="built_in">NSString</span> *key = [<span class="keyword">self</span> cacheKeyForURL:url cacheKeyFilter:cacheKeyFilter];</span><br><span class="line">        @weakify(operation);</span><br><span class="line">        <span class="comment">//异步查询，缓存中与当前url对应key的缓存</span></span><br><span class="line">        operation.cacheOperation = [<span class="keyword">self</span>.imageCache queryImageForKey:key options:options context:context completion:^(<span class="built_in">UIImage</span> * _Nullable cachedImage, <span class="built_in">NSData</span> * _Nullable cachedData, SDImageCacheType cacheType) &#123;</span><br><span class="line">            @strongify(operation);</span><br><span class="line">            <span class="comment">//用户取消查找</span></span><br><span class="line">            <span class="keyword">if</span> (!operation || operation.isCancelled) &#123;</span><br><span class="line">                <span class="comment">// Image combined operation cancelled by user</span></span><br><span class="line">                [<span class="keyword">self</span> callCompletionBlockForOperation:operation completion:completedBlock error:[<span class="built_in">NSError</span> errorWithDomain:SDWebImageErrorDomain code:SDWebImageErrorCancelled userInfo:<span class="literal">nil</span>] url:url];</span><br><span class="line">                [<span class="keyword">self</span> safelyRemoveOperationFromRunning:operation];</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 继续开始下载</span></span><br><span class="line">            [<span class="keyword">self</span> callDownloadProcessForOperation:operation url:url options:options context:context cachedImage:cachedImage cachedData:cachedData cacheType:cacheType progress:progressBlock completed:completedBlock];</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 继续开始下载</span></span><br><span class="line">        [<span class="keyword">self</span> callDownloadProcessForOperation:operation url:url options:options context:context cachedImage:<span class="literal">nil</span> cachedData:<span class="literal">nil</span> cacheType:SDImageCacheTypeNone progress:progressBlock completed:completedBlock];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在将下载过程需要的重要组件放置到options和context中后就开始加载图片，这里无外乎两种方式一种是从网络上下载资源，一种是使用本地资源，具体使用哪一种，在加载之前会先根据用户的设置，判断是否只使用缓存的图片，这取决于<strong><strong>SDWebImageFromLoaderOnly</strong></strong>，如果SDWebImageFromLoaderOnly &#x3D; 1 会先将URL转换为缓存的key，再使用这个key调用<strong><strong>self.imageCache queryImageForKey</strong></strong>，异步查询是否有对应的缓存。，如果SDWebImageFromLoaderOnly &#x3D; 0 则会通过callDownloadProcessForOperation从网络上下载资源。我们接下来分别看下这两个分支的代码：</p>
<h6 id="2-2-1-1-使用缓存资源"><a href="#2-2-1-1-使用缓存资源" class="headerlink" title="2.2.1.1 使用缓存资源"></a>2.2.1.1 使用缓存资源</h6><figure class="highlight erlang"><table><tr><td class="code"><pre><span class="line">- <span class="params">(id&lt;SDWebImageOperation&gt;)</span>queryImageForKey:<span class="params">(NSString *)</span>key options:<span class="params">(SDWebImageOptions)</span>options context:<span class="params">(nullable SDWebImageContext *)</span>context completion:<span class="params">(nullable SDImageCacheQueryCompletionBlock)</span>completionBlock &#123;</span><br><span class="line">    //将配置从options搬到cacheOptions</span><br><span class="line">    SDImageCacheOptions cacheOptions = 0;</span><br><span class="line">    if <span class="params">(options &amp; SDWebImageQueryMemoryData)</span> cacheOptions |= SDImageCacheQueryMemoryData;</span><br><span class="line">    if <span class="params">(options &amp; SDWebImageQueryMemoryDataSync)</span> cacheOptions |= SDImageCacheQueryMemoryDataSync;</span><br><span class="line">    if <span class="params">(options &amp; SDWebImageQueryDiskDataSync)</span> cacheOptions |= SDImageCacheQueryDiskDataSync;</span><br><span class="line">    if <span class="params">(options &amp; SDWebImageScaleDownLargeImages)</span> cacheOptions |= SDImageCacheScaleDownLargeImages;</span><br><span class="line">    if <span class="params">(options &amp; SDWebImageAvoidDecodeImage)</span> cacheOptions |= SDImageCacheAvoidDecodeImage;</span><br><span class="line">    if <span class="params">(options &amp; SDWebImageDecodeFirstFrameOnly)</span> cacheOptions |= SDImageCacheDecodeFirstFrameOnly;</span><br><span class="line">    if <span class="params">(options &amp; SDWebImagePreloadAllFrames)</span> cacheOptions |= SDImageCachePreloadAllFrames;</span><br><span class="line">    if <span class="params">(options &amp; SDWebImageMatchAnimatedImageClass)</span> cacheOptions |= SDImageCacheMatchAnimatedImageClass;</span><br><span class="line">    </span><br><span class="line">    return [self queryCacheOperationForKey:key options:cacheOptions context:context done:completionBlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里就不多说了就是将缓存相关的配置添加到cacheOptions中调用<strong><strong>queryCacheOperationForKey</strong></strong>：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSOperation</span> *)queryCacheOperationForKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key options:(SDImageCacheOptions)options context:(<span class="keyword">nullable</span> SDWebImageContext *)context done:(<span class="keyword">nullable</span> SDImageCacheQueryCompletionBlock)doneBlock &#123;</span><br><span class="line">    <span class="comment">//如果key为空则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (!key) &#123;</span><br><span class="line">        <span class="keyword">if</span> (doneBlock) &#123;</span><br><span class="line">            doneBlock(<span class="literal">nil</span>, <span class="literal">nil</span>, SDImageCacheTypeNone);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从context取出图片转换器</span></span><br><span class="line">    <span class="type">id</span>&lt;SDImageTransformer&gt; transformer = context[SDWebImageContextImageTransformer];</span><br><span class="line">    <span class="keyword">if</span> (transformer) &#123;</span><br><span class="line">        <span class="comment">// 取出我们存储在context中的transformer的transformerKey</span></span><br><span class="line">        <span class="built_in">NSString</span> *transformerKey = [transformer transformerKey];</span><br><span class="line">        key = SDTransformedKeyForKey(key, transformerKey);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//首先从内存缓存中查找</span></span><br><span class="line">    <span class="built_in">UIImage</span> *image = [<span class="keyword">self</span> imageFromMemoryCacheForKey:key];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (image) &#123;</span><br><span class="line">        <span class="comment">// 默认情况下我们会对动画图片整个进行解码，SDImageCacheDecodeFirstFrameOnly表示强迫只解码第一帧图片形成一个静态图</span></span><br><span class="line">        <span class="keyword">if</span> (options &amp; SDImageCacheDecodeFirstFrameOnly) &#123;</span><br><span class="line">            <span class="comment">// Ensure static image</span></span><br><span class="line">            Class animatedImageClass = image.class;</span><br><span class="line">            <span class="keyword">if</span> (image.sd_isAnimated || ([animatedImageClass isSubclassOfClass:[<span class="built_in">UIImage</span> <span class="keyword">class</span>]] &amp;&amp; [animatedImageClass conformsToProtocol:<span class="class"><span class="keyword">@protocol</span>(<span class="title">SDAnimatedImage</span>)])) </span>&#123;</span><br><span class="line">                image = [[<span class="built_in">UIImage</span> alloc] initWithCGImage:image.CGImage scale:image.scale orientation:image.imageOrientation];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (options &amp; SDImageCacheMatchAnimatedImageClass) &#123;</span><br><span class="line">            <span class="comment">// Check image class matching</span></span><br><span class="line">            Class animatedImageClass = image.class;</span><br><span class="line">            Class desiredImageClass = context[SDWebImageContextAnimatedImageClass];</span><br><span class="line">            <span class="keyword">if</span> (desiredImageClass &amp;&amp; ![animatedImageClass isSubclassOfClass:desiredImageClass]) &#123;</span><br><span class="line">                image = <span class="literal">nil</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//是否只使用内存缓存的图片</span></span><br><span class="line">    <span class="type">BOOL</span> shouldQueryMemoryOnly = (image &amp;&amp; !(options &amp; SDImageCacheQueryMemoryData));</span><br><span class="line">    <span class="keyword">if</span> (shouldQueryMemoryOnly) &#123;</span><br><span class="line">        <span class="keyword">if</span> (doneBlock) &#123;</span><br><span class="line">            doneBlock(image, <span class="literal">nil</span>, SDImageCacheTypeMemory);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查磁盘缓存中的资源</span></span><br><span class="line">    <span class="built_in">NSOperation</span> *operation = [<span class="built_in">NSOperation</span> new];</span><br><span class="line">    <span class="comment">// Check whether we need to synchronously query disk</span></span><br><span class="line">    <span class="comment">// 1. in-memory cache hit &amp; memoryDataSync</span></span><br><span class="line">    <span class="comment">// 2. in-memory cache miss &amp; diskDataSync</span></span><br><span class="line">    <span class="type">BOOL</span> shouldQueryDiskSync = ((image &amp;&amp; options &amp; SDImageCacheQueryMemoryDataSync) ||</span><br><span class="line">                                (!image &amp;&amp; options &amp; SDImageCacheQueryDiskDataSync));</span><br><span class="line">    </span><br><span class="line">    <span class="type">void</span>(^queryDiskBlock)(<span class="type">void</span>) =  ^&#123;</span><br><span class="line">        <span class="keyword">if</span> (operation.isCancelled) &#123;</span><br><span class="line">            <span class="keyword">if</span> (doneBlock) &#123;</span><br><span class="line">                doneBlock(<span class="literal">nil</span>, <span class="literal">nil</span>, SDImageCacheTypeNone);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">            <span class="comment">//从磁盘中查找对应的缓存图片</span></span><br><span class="line">            <span class="built_in">NSData</span> *diskData = [<span class="keyword">self</span> diskImageDataBySearchingAllPathsForKey:key];</span><br><span class="line">            <span class="built_in">UIImage</span> *diskImage;</span><br><span class="line">            SDImageCacheType cacheType = SDImageCacheTypeNone;</span><br><span class="line">            <span class="keyword">if</span> (image) &#123;</span><br><span class="line">                <span class="comment">// 使用内存缓存中的图片</span></span><br><span class="line">                <span class="comment">// the image is from in-memory cache, but need image data</span></span><br><span class="line">                diskImage = image;</span><br><span class="line">                cacheType = SDImageCacheTypeMemory;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (diskData) &#123;</span><br><span class="line">                <span class="comment">//使用磁盘缓存中的图片</span></span><br><span class="line">                cacheType = SDImageCacheTypeDisk;</span><br><span class="line">                <span class="comment">// decode image data only if in-memory cache missed</span></span><br><span class="line">                <span class="comment">// 在内存缓存没有命中的时候解压从磁盘中获取到的文件</span></span><br><span class="line">                diskImage = [<span class="keyword">self</span> diskImageForKey:key data:diskData options:options context:context];</span><br><span class="line">                <span class="keyword">if</span> (diskImage &amp;&amp; <span class="keyword">self</span>.config.shouldCacheImagesInMemory) &#123;</span><br><span class="line">                    <span class="comment">//是否需要存储到内存缓存中</span></span><br><span class="line">                    <span class="built_in">NSUInteger</span> cost = diskImage.sd_memoryCost;</span><br><span class="line">                    [<span class="keyword">self</span>.memoryCache setObject:diskImage forKey:key cost:cost];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//交付数据</span></span><br><span class="line">            <span class="keyword">if</span> (doneBlock) &#123;</span><br><span class="line">                <span class="keyword">if</span> (shouldQueryDiskSync) &#123;</span><br><span class="line">                    doneBlock(diskImage, diskData, cacheType);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                        doneBlock(diskImage, diskData, cacheType);</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Query in ioQueue to keep IO-safe</span></span><br><span class="line">    <span class="comment">// 开始查询，这里分同步和异步查询两种</span></span><br><span class="line">    <span class="keyword">if</span> (shouldQueryDiskSync) &#123;</span><br><span class="line">        <span class="built_in">dispatch_sync</span>(<span class="keyword">self</span>.ioQueue, queryDiskBlock);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">dispatch_async</span>(<span class="keyword">self</span>.ioQueue, queryDiskBlock);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> operation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<strong><strong>queryCacheOperationForKey</strong></strong>中做的工作和其他图片加载库类似，只不过在细节会有点差异：</p>
<ol>
<li>按照key的规则构建出缓存key</li>
<li>优先从缓存中查找缓存，如果只使用内存缓存的则在这个步骤不论是否能够在内存中找到缓存，都通过block返回结果。</li>
<li>如果在内存缓存中没有找到对应的图片缓存，则继续查找磁盘缓存，如果在磁盘中找到了，再看是否需要同步到内存缓存。</li>
<li>最后交付数据到应用层</li>
</ol>
<p>下面将针对上面几点展开介绍：</p>
<ul>
<li>按照key的规则构建出缓存key</li>
</ul>
<p>SDWebImage中的缓存key和转换器是有关联，所以我们在构建key的时候需要将转换器从context中取出。</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">id&lt;SDImageTransformer&gt; transformer = <span class="built_in">context</span>[SDWebImageContextImageTransformer];</span><br><span class="line"><span class="keyword">if</span> (transformer) &#123;</span><br><span class="line">    // 取出我们存储在<span class="built_in">context</span>中的transformer的transformerKey</span><br><span class="line">    NSString *transformerKey = [transformer transformerKey];</span><br><span class="line">    <span class="built_in">key</span> = SDTransformedKeyForKey(<span class="built_in">key</span>, transformerKey);</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

<p>缓存key的具体构建过程在<strong><strong>SDTransformedKeyForKey</strong></strong>方法中，这里会在原先的缓存key后面添加不同的转换器信息，用于区分同一个url 对应不同转换器的情况，比如我们有一个图片为<strong><strong>image.png</strong></strong>，它经过<strong><strong>flip(YES,NO)</strong></strong> 也就是水平翻转，再经过旋转45度处理，这样最终生成的key就是<strong><strong>image-SDImageFlippingTransformer(1,0)-SDImageRotationTransformer(0.78539816339,1).png</strong></strong>:</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">NSString * _Nullable SDTransformedKeyForKey(NSString * _Nullable key, NSString * _Nonnull transformerKey) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!key || !transformerKey) &#123;</span><br><span class="line">        <span class="keyword">return</span> nil;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Find the file extension</span></span><br><span class="line">    NSURL *keyURL = [NSURL URLWithString:key];</span><br><span class="line">    NSString *ext = keyURL ? keyURL.pathExtension : key.pathExtension;</span><br><span class="line">    <span class="keyword">if</span> (ext.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// For non-file URL</span></span><br><span class="line">        <span class="keyword">if</span> (keyURL &amp;&amp; !keyURL.isFileURL) &#123;</span><br><span class="line">            <span class="comment">// keep anything except path (like URL query)</span></span><br><span class="line">            NSURLComponents *component = [NSURLComponents componentsWithURL:keyURL resolvingAgainstBaseURL:NO];</span><br><span class="line">            component.path = [[[component.path.<span class="built_in">string</span>ByDeletingPathExtension <span class="built_in">string</span>ByAppendingString:SDImageTransformerKeySeparator] <span class="built_in">string</span>ByAppendingString:transformerKey] <span class="built_in">string</span>ByAppendingPathExtension:ext];</span><br><span class="line">            <span class="keyword">return</span> component.URL.absoluteString;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// file URL</span></span><br><span class="line">            <span class="keyword">return</span> [[[key.<span class="built_in">string</span>ByDeletingPathExtension <span class="built_in">string</span>ByAppendingString:SDImageTransformerKeySeparator] <span class="built_in">string</span>ByAppendingString:transformerKey] <span class="built_in">string</span>ByAppendingPathExtension:ext];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> [[key <span class="built_in">string</span>ByAppendingString:SDImageTransformerKeySeparator] <span class="built_in">string</span>ByAppendingString:O];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在拿到key后key后我们会先从内存图片缓存中去查找对与当前key匹配的图片。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">//首先从内存缓存中查找</span></span><br><span class="line"><span class="built_in">UIImage</span> *image = [<span class="keyword">self</span> imageFromMemoryCacheForKey:key];</span><br><span class="line"></span><br><span class="line">---&gt; </span><br><span class="line"></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)imageFromMemoryCacheForKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span>.memoryCache objectForKey:key];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果指定只使用内存中的缓存图片并且内存中有找到对应的图片就直接返回:</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">//是否只使用内存缓存的图片</span></span><br><span class="line"><span class="type">BOOL</span> shouldQueryMemoryOnly = (image &amp;&amp; !(options &amp; SDImageCacheQueryMemoryData));</span><br><span class="line"><span class="keyword">if</span> (shouldQueryMemoryOnly) &#123;</span><br><span class="line">    <span class="keyword">if</span> (doneBlock) &#123;</span><br><span class="line">        doneBlock(image, <span class="literal">nil</span>, SDImageCacheTypeMemory);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果shouldQueryMemoryOnly &#x3D; NO,也就是不单单使用内存的图片缓存，就会调用<strong><strong>diskImageDataBySearchingAllPathsForKey</strong></strong>在磁盘中查找对应的缓存图片，如同内存中有则优先使用内存的，其实这里有个需要优化的地方，如果image不为空的情况下就不需要调用<strong><strong>diskImageDataBySearchingAllPathsForKey</strong></strong>，如果内存没有，那么会将从磁盘缓存中获取到的缓存数据，经过解码后存放到内存缓存，供下次使用。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">BOOL shouldQueryDiskSync = ((image<span class="operator"> &amp;&amp; </span>options &amp; SDImageCacheQueryMemoryDataSync)<span class="operator"> ||</span></span><br><span class="line"><span class="operator">                            </span>(!image<span class="operator"> &amp;&amp; </span>options &amp; SDImageCacheQueryDiskDataSync));</span><br><span class="line"></span><br><span class="line">void(^queryDiskBlock)(void) =  ^&#123;</span><br><span class="line">    <span class="keyword">if</span> (operation.isCancelled) &#123;</span><br><span class="line">        <span class="keyword">if</span> (doneBlock) &#123;</span><br><span class="line">            <span class="keyword">done</span><span class="constructor">Block(<span class="params">nil</span>, <span class="params">nil</span>, SDImageCacheTypeNone)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        <span class="comment">//从磁盘中查找对应的缓存图片</span></span><br><span class="line">        NSData *diskData = <span class="literal">[<span class="identifier">self</span> <span class="identifier">diskImageDataBySearchingAllPathsForKey</span>:<span class="identifier">key</span>]</span>;</span><br><span class="line">        UIImage *diskImage;</span><br><span class="line">        SDImageCacheType cacheType = SDImageCacheTypeNone;</span><br><span class="line">        <span class="keyword">if</span> (image) &#123;</span><br><span class="line">            <span class="comment">// 使用内存缓存中的图片</span></span><br><span class="line">            diskImage = image;</span><br><span class="line">            cacheType = SDImageCacheTypeMemory;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (diskData) &#123;</span><br><span class="line">            <span class="comment">//使用磁盘缓存中的图片</span></span><br><span class="line">            cacheType = SDImageCacheTypeDisk;</span><br><span class="line">            <span class="comment">// 在内存缓存没有命中的时候解压从磁盘中获取到的文件</span></span><br><span class="line">            diskImage = <span class="literal">[<span class="identifier">self</span> <span class="identifier">diskImageForKey</span>:<span class="identifier">key</span> <span class="identifier">data</span>:<span class="identifier">diskData</span> <span class="identifier">options</span>:<span class="identifier">options</span> <span class="identifier">context</span>:<span class="identifier">context</span>]</span>;</span><br><span class="line">            <span class="keyword">if</span> (diskImage<span class="operator"> &amp;&amp; </span>self.config.shouldCacheImagesInMemory) &#123;</span><br><span class="line">                <span class="comment">//是否需要存储到内存缓存中</span></span><br><span class="line">                NSUInteger cost = diskImage.sd_memoryCost;</span><br><span class="line">                <span class="literal">[<span class="identifier">self</span>.<span class="identifier">memoryCache</span> <span class="identifier">setObject</span>:<span class="identifier">diskImage</span> <span class="identifier">forKey</span>:<span class="identifier">key</span> <span class="identifier">cost</span>:<span class="identifier">cost</span>]</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//交付数据</span></span><br><span class="line">        <span class="keyword">if</span> (doneBlock) &#123;</span><br><span class="line">            <span class="keyword">if</span> (shouldQueryDiskSync) &#123;</span><br><span class="line">                <span class="keyword">done</span><span class="constructor">Block(<span class="params">diskImage</span>, <span class="params">diskData</span>, <span class="params">cacheType</span>)</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dispatch<span class="constructor">_async(<span class="params">dispatch_get_main_queue</span>()</span>, ^&#123;</span><br><span class="line">                    <span class="keyword">done</span><span class="constructor">Block(<span class="params">diskImage</span>, <span class="params">diskData</span>, <span class="params">cacheType</span>)</span>;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 开始查询，这里分同步和异步查询两种</span></span><br><span class="line"><span class="keyword">if</span> (shouldQueryDiskSync) &#123;</span><br><span class="line">    dispatch<span class="constructor">_sync(<span class="params">self</span>.<span class="params">ioQueue</span>, <span class="params">queryDiskBlock</span>)</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    dispatch<span class="constructor">_async(<span class="params">self</span>.<span class="params">ioQueue</span>, <span class="params">queryDiskBlock</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="2-2-1-2-使用网络资源"><a href="#2-2-1-2-使用网络资源" class="headerlink" title="2.2.1.2 使用网络资源"></a>2.2.1.2 使用网络资源</h6><p>上面小节我们了解了从缓存中加载图片的流程，接下来我们看下从网络上对图片进行加载的流程:</p>
<p>在SDWebImage默认情况下使用<strong><strong>SDWebImageDownloader</strong></strong>来完成下载任务，我们在分析下载流程之前我们先看下SDWebImageDownloader数据流是怎样的：</p>
<ul>
<li><strong><strong>SDWebImageDownloader初始化阶段</strong></strong></li>
</ul>
<p>在SDWebImageDownloader 第一次调用的时候会调用initialize方法</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">+ (<span class="type">void</span>)initialize &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">NSClassFromString</span>(<span class="string">@&quot;SDNetworkActivityIndicator&quot;</span>)) &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> clang diagnostic push</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> clang diagnostic ignored <span class="string">&quot;-Warc-performSelector-leaks&quot;</span></span></span><br><span class="line">        <span class="type">id</span> activityIndicator = [<span class="built_in">NSClassFromString</span>(<span class="string">@&quot;SDNetworkActivityIndicator&quot;</span>) performSelector:<span class="built_in">NSSelectorFromString</span>(<span class="string">@&quot;sharedActivityIndicator&quot;</span>)];</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> clang diagnostic pop</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Remove observer in case it was previously added.</span></span><br><span class="line">        [[<span class="built_in">NSNotificationCenter</span> defaultCenter] removeObserver:activityIndicator name:SDWebImageDownloadStartNotification object:<span class="literal">nil</span>];</span><br><span class="line">        [[<span class="built_in">NSNotificationCenter</span> defaultCenter] removeObserver:activityIndicator name:SDWebImageDownloadStopNotification object:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line">        [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:activityIndicator</span><br><span class="line">                                                 selector:<span class="built_in">NSSelectorFromString</span>(<span class="string">@&quot;startActivity&quot;</span>)</span><br><span class="line">                                                     name:SDWebImageDownloadStartNotification object:<span class="literal">nil</span>];</span><br><span class="line">        [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:activityIndicator</span><br><span class="line">                                                 selector:<span class="built_in">NSSelectorFromString</span>(<span class="string">@&quot;stopActivity&quot;</span>)</span><br><span class="line">                                                     name:SDWebImageDownloadStopNotification object:<span class="literal">nil</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里主要是对网络状态指示器通知进行监听。</p>
<figure class="highlight elm"><table><tr><td class="code"><pre><span class="line">- (nonnull instance<span class="keyword">type</span>)init &#123;</span><br><span class="line">    return [self initWithConfig:<span class="type">SDWebImageDownloaderConfig</span>.defaultDownloaderConfig];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)initWithConfig:(SDWebImageDownloaderConfig *)config &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="variable language_">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!config) &#123;</span><br><span class="line">            config = SDWebImageDownloaderConfig.defaultDownloaderConfig;</span><br><span class="line">        &#125;</span><br><span class="line">        _config = [config <span class="keyword">copy</span>];</span><br><span class="line">        <span class="comment">//指定并行下载数目</span></span><br><span class="line">        [_config addObserver:<span class="keyword">self</span> forKeyPath:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(maxConcurrentDownloads)) options:<span class="number">0</span> context:SDWebImageDownloaderContext];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//创建下载队列_downloadQueue</span></span><br><span class="line">        _downloadQueue = [<span class="built_in">NSOperationQueue</span> new];</span><br><span class="line">        _downloadQueue.maxConcurrentOperationCount = _config.maxConcurrentDownloads;</span><br><span class="line">        _downloadQueue.name = <span class="string">@&quot;com.hackemist.SDWebImageDownloader&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//创建用于管理NSOperation的字典，key为url，value为对应的NSOperation</span></span><br><span class="line">        _URLOperations = [<span class="built_in">NSMutableDictionary</span> new];</span><br><span class="line">        <span class="built_in">NSMutableDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="built_in">NSString</span> *&gt; *headerDictionary = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">        <span class="built_in">NSString</span> *userAgent = <span class="literal">nil</span>;</span><br><span class="line">        <span class="comment">// User-Agent Header; see http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.43</span></span><br><span class="line">        userAgent = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;%@/%@ (%@; iOS %@; Scale/%0.2f)&quot;</span>, [[<span class="built_in">NSBundle</span> mainBundle] infoDictionary][(__bridge <span class="built_in">NSString</span> *)kCFBundleExecutableKey] ?: [[<span class="built_in">NSBundle</span> mainBundle] infoDictionary][(__bridge <span class="built_in">NSString</span> *)kCFBundleIdentifierKey], [[<span class="built_in">NSBundle</span> mainBundle] infoDictionary][<span class="string">@&quot;CFBundleShortVersionString&quot;</span>] ?: [[<span class="built_in">NSBundle</span> mainBundle] infoDictionary][(__bridge <span class="built_in">NSString</span> *)kCFBundleVersionKey], [[<span class="built_in">UIDevice</span> currentDevice] model], [[<span class="built_in">UIDevice</span> currentDevice] systemVersion], [[<span class="built_in">UIScreen</span> mainScreen] scale]];</span><br><span class="line">        <span class="comment">//UA设置</span></span><br><span class="line">        <span class="keyword">if</span> (userAgent) &#123;</span><br><span class="line">            <span class="keyword">if</span> (![userAgent canBeConvertedToEncoding:<span class="built_in">NSASCIIStringEncoding</span>]) &#123;</span><br><span class="line">                <span class="built_in">NSMutableString</span> *mutableUserAgent = [userAgent mutableCopy];</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">CFStringTransform</span>((__bridge <span class="built_in">CFMutableStringRef</span>)(mutableUserAgent), <span class="literal">NULL</span>, (__bridge <span class="built_in">CFStringRef</span>)<span class="string">@&quot;Any-Latin; Latin-ASCII; [:^ASCII:] Remove&quot;</span>, <span class="literal">false</span>)) &#123;</span><br><span class="line">                    userAgent = mutableUserAgent;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            headerDictionary[<span class="string">@&quot;User-Agent&quot;</span>] = userAgent;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//Accept context设置</span></span><br><span class="line">        headerDictionary[<span class="string">@&quot;Accept&quot;</span>] = <span class="string">@&quot;image/*,*/*;q=0.8&quot;</span>;</span><br><span class="line">        _HTTPHeaders = headerDictionary;</span><br><span class="line">        _HTTPHeadersLock = dispatch_semaphore_create(<span class="number">1</span>);</span><br><span class="line">        _operationsLock = dispatch_semaphore_create(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">NSURLSessionConfiguration</span> *sessionConfiguration = _config.sessionConfiguration;</span><br><span class="line">        <span class="keyword">if</span> (!sessionConfiguration) &#123;</span><br><span class="line">            sessionConfiguration = [<span class="built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *  Create the session for this task</span></span><br><span class="line"><span class="comment">         *  We send nil as delegate queue so that the session creates a serial operation queue for performing all delegate</span></span><br><span class="line"><span class="comment">         *  method calls and completion handler calls.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//创建NSURLSession</span></span><br><span class="line">        _session = [<span class="built_in">NSURLSession</span> sessionWithConfiguration:sessionConfiguration</span><br><span class="line">                                                 delegate:<span class="keyword">self</span></span><br><span class="line">                                            delegateQueue:<span class="literal">nil</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在初始化方法中主要负责重要组件的创建****_downloadQueue<strong><strong>，</strong></strong>_URLOperations<strong><strong>，</strong></strong>_session****。</p>
<ul>
<li><strong><strong>SDWebImageDownloader下载流程</strong></strong></li>
</ul>
<p>SDWebImage的下载是从callDownloadProcessForOperation开始的：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="operator">-</span> (void)callDownloadProcessForOperation:(nonnull <span class="type">SDWebImageCombinedOperation</span> <span class="operator">*</span>)operation</span><br><span class="line">                                    url:(nonnull <span class="type">NSURL</span> <span class="operator">*</span>)url</span><br><span class="line">                                options:(<span class="type">SDWebImageOptions</span>)options</span><br><span class="line">                                context:(<span class="type">SDWebImageContext</span> <span class="operator">*</span>)context</span><br><span class="line">                            cachedImage:(nullable <span class="type">UIImage</span> <span class="operator">*</span>)cachedImage</span><br><span class="line">                             cachedData:(nullable <span class="type">NSData</span> <span class="operator">*</span>)cachedData</span><br><span class="line">                              cacheType:(<span class="type">SDImageCacheType</span>)cacheType</span><br><span class="line">                               progress:(nullable <span class="type">SDImageLoaderProgressBlock</span>)progressBlock</span><br><span class="line">                              completed:(nullable <span class="type">SDInternalCompletionBlock</span>)completedBlock &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">BOOL</span> shouldDownload <span class="operator">=</span> <span class="operator">!</span><span class="type">SD_OPTIONS_CONTAINS</span>(options, <span class="type">SDWebImageFromCacheOnly</span>);</span><br><span class="line">    shouldDownload <span class="operator">&amp;=</span> (<span class="operator">!</span>cachedImage <span class="operator">||</span> options <span class="operator">&amp;</span> <span class="type">SDWebImageRefreshCached</span>);</span><br><span class="line">    shouldDownload <span class="operator">&amp;=</span> (<span class="operator">!</span>[<span class="keyword">self</span>.delegate respondsToSelector:<span class="meta">@selector</span>(imageManager:shouldDownloadImageForURL:)] <span class="operator">||</span> [<span class="keyword">self</span>.delegate imageManager:<span class="keyword">self</span> shouldDownloadImageForURL:url]);</span><br><span class="line">    shouldDownload <span class="operator">&amp;=</span> [<span class="keyword">self</span>.imageLoader canRequestImageForURL:url];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (shouldDownload) &#123;</span><br><span class="line">        <span class="comment">//在需要强制刷新缓存的情况下先调用callCompletionBlockForOperation将缓存图片交给上层，然后继续开始下载</span></span><br><span class="line">        <span class="keyword">if</span> (cachedImage <span class="operator">&amp;&amp;</span> options <span class="operator">&amp;</span> <span class="type">SDWebImageRefreshCached</span>) &#123;</span><br><span class="line">            <span class="comment">// If image was found in the cache but SDWebImageRefreshCached is provided, notify about the cached image</span></span><br><span class="line">            <span class="comment">// AND try to re-download it in order to let a chance to NSURLCache to refresh it from server.</span></span><br><span class="line">            [<span class="keyword">self</span> callCompletionBlockForOperation:operation completion:completedBlock image:cachedImage data:cachedData error:<span class="literal">nil</span> cacheType:cacheType finished:<span class="type">YES</span> url:url];</span><br><span class="line">            <span class="comment">// Pass the cached image to the image loader. The image loader should check whether the remote image is equal to the cached image.</span></span><br><span class="line">            <span class="type">SDWebImageMutableContext</span> <span class="operator">*</span>mutableContext;</span><br><span class="line">            <span class="keyword">if</span> (context) &#123;</span><br><span class="line">                mutableContext <span class="operator">=</span> [context mutableCopy];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mutableContext <span class="operator">=</span> [<span class="type">NSMutableDictionary</span> dictionary];</span><br><span class="line">            &#125;</span><br><span class="line">            mutableContext[<span class="type">SDWebImageContextLoaderCachedImage</span>] <span class="operator">=</span> cachedImage;</span><br><span class="line">            context <span class="operator">=</span> [mutableContext copy];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="meta">@weakify</span>(operation);</span><br><span class="line">        <span class="comment">// 开始发起图片加载的请求</span></span><br><span class="line">        operation.loaderOperation <span class="operator">=</span> [<span class="keyword">self</span>.imageLoader requestImageWithURL:url options:options context:context progress:progressBlock completed:<span class="operator">^</span>(<span class="type">UIImage</span> <span class="operator">*</span>downloadedImage, <span class="type">NSData</span> <span class="operator">*</span>downloadedData, <span class="type">NSError</span> <span class="operator">*</span>error, <span class="type">BOOL</span> finished) &#123;</span><br><span class="line">            <span class="meta">@strongify</span>(operation);</span><br><span class="line">            <span class="comment">//用户取消请求</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="operator">!</span>operation <span class="operator">||</span> operation.isCancelled) &#123;</span><br><span class="line">                [<span class="keyword">self</span> callCompletionBlockForOperation:operation completion:completedBlock error:[<span class="type">NSError</span> errorWithDomain:<span class="type">SDWebImageErrorDomain</span> code:<span class="type">SDWebImageErrorCancelled</span> userInfo:<span class="literal">nil</span>] url:url];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cachedImage <span class="operator">&amp;&amp;</span> options <span class="operator">&amp;</span> <span class="type">SDWebImageRefreshCached</span> <span class="operator">&amp;&amp;</span> [error.domain isEqualToString:<span class="type">SDWebImageErrorDomain</span>] <span class="operator">&amp;&amp;</span> error.code <span class="operator">==</span> <span class="type">SDWebImageErrorCacheNotModified</span>) &#123;</span><br><span class="line">                <span class="comment">// 强制刷新缓存的时候，在前面先将缓存图片通过completeBlock 将数据传递给上层，到这里将数据加载完毕后，不做任何操作</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([error.domain isEqualToString:<span class="type">SDWebImageErrorDomain</span>] <span class="operator">&amp;&amp;</span> error.code <span class="operator">==</span> <span class="type">SDWebImageErrorCancelled</span>) &#123;</span><br><span class="line">                <span class="comment">// 将错误交给上层</span></span><br><span class="line">                [<span class="keyword">self</span> callCompletionBlockForOperation:operation completion:completedBlock error:error url:url];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (error) &#123;</span><br><span class="line">                [<span class="keyword">self</span> callCompletionBlockForOperation:operation completion:completedBlock error:error url:url];</span><br><span class="line">                <span class="comment">//是否需要将错误的URL添加到failedURLs</span></span><br><span class="line">                <span class="type">BOOL</span> shouldBlockFailedURL <span class="operator">=</span> [<span class="keyword">self</span> shouldBlockFailedURLWithURL:url error:error];</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (shouldBlockFailedURL) &#123;</span><br><span class="line">                    <span class="type">SD_LOCK</span>(<span class="keyword">self</span>.failedURLsLock);</span><br><span class="line">                    [<span class="keyword">self</span>.failedURLs addObject:url];</span><br><span class="line">                    <span class="type">SD_UNLOCK</span>(<span class="keyword">self</span>.failedURLsLock);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 成功</span></span><br><span class="line">                <span class="comment">//如果SDWebImageRetryFailed = 1 表示错误的url需要重试，这时候就要将当前的url从failedURLs移除</span></span><br><span class="line">                <span class="keyword">if</span> ((options <span class="operator">&amp;</span> <span class="type">SDWebImageRetryFailed</span>)) &#123;</span><br><span class="line">                    <span class="type">SD_LOCK</span>(<span class="keyword">self</span>.failedURLsLock);</span><br><span class="line">                    [<span class="keyword">self</span>.failedURLs removeObject:url];</span><br><span class="line">                    <span class="type">SD_UNLOCK</span>(<span class="keyword">self</span>.failedURLsLock);</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                [<span class="keyword">self</span> callStoreCacheProcessForOperation:operation url:url options:options context:context downloadedImage:downloadedImage downloadedData:downloadedData finished:finished progress:progressBlock completed:completedBlock];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (finished) &#123;</span><br><span class="line">                <span class="comment">//加载成功后将操作从Running队列中移除</span></span><br><span class="line">                [<span class="keyword">self</span> safelyRemoveOperationFromRunning:operation];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cachedImage) &#123;</span><br><span class="line">        <span class="comment">//使用缓存的情况下将缓存数据传递到上层，并将请求从Running队列中移除</span></span><br><span class="line">        [<span class="keyword">self</span> callCompletionBlockForOperation:operation completion:completedBlock image:cachedImage data:cachedData error:<span class="literal">nil</span> cacheType:cacheType finished:<span class="type">YES</span> url:url];</span><br><span class="line">        [<span class="keyword">self</span> safelyRemoveOperationFromRunning:operation];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//缓存没有图片，并且不允许下载</span></span><br><span class="line">        [<span class="keyword">self</span> callCompletionBlockForOperation:operation completion:completedBlock image:<span class="literal">nil</span> data:<span class="literal">nil</span> error:<span class="literal">nil</span> cacheType:<span class="type">SDImageCacheTypeNone</span> finished:<span class="type">YES</span> url:url];</span><br><span class="line">        [<span class="keyword">self</span> safelyRemoveOperationFromRunning:operation];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>是否需要从网络上下载图片需要根据如下条件进行判断：</p>
<ol>
<li>SDWebImageFromCacheOnly &#x3D; 0，表示不单单只允许使用缓存的数据</li>
<li>上一步没有找到缓存cachedImage </li>
<li>SDWebImageRefreshCached &#x3D; 1 强制刷新缓存</li>
<li>imageManager:shouldDownloadImageForURL:决定当图片在缓存内没有找到的时候是否需要下载</li>
<li>[self.imageLoader canRequestImageForURL:url] 决定是否能够下载,它会在每次imageloader请求到来的时候，对URL进行检查，<br> 如果返回YES,则会开始调用requestImageWithURL发起请求，否则将会将当前的图片加载标记为加载失败。</li>
</ol>
<p>这里需要强调的是如果是需要强制刷新的时候会先将缓存图片通过block上传给业务层，但是会继续下载任务。</p>
<p>下载是调用****self.imageLoader requestImageWithURL:****来执行的，我们来看下：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">- (id&lt;SDWebImageOperation&gt;)requestImageWithURL:(NSURL *)url options:(SDWebImageOptions)options context:(SDWebImageContext *)context progress:(SDImageLoaderProgressBlock)progressBlock completed:(SDImageLoaderCompletedBlock)completedBlock &#123;</span><br><span class="line">    <span class="keyword">if</span> (!url) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    NSArray&lt;id&lt;SDImageLoader&gt;&gt; *<span class="built_in">loaders</span> = <span class="built_in">self</span>.<span class="built_in">loaders</span>;</span><br><span class="line">    <span class="keyword">for</span> (id&lt;SDImageLoader&gt; loader <span class="keyword">in</span> <span class="built_in">loaders</span>.reverseObjectEnumerator) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([loader canRequestImageForURL:url]) &#123;</span><br><span class="line">            <span class="keyword">return</span> [loader requestImageWithURL:url options:options context:context progress:progressBlock completed:completedBlock];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里会遍历每个注册的SDImageLoader，对每个loader调用<strong><strong>canRequestImageForURL</strong></strong> 来判断当前loader能否对当前url请求做处理，如果能就进行请求，这种插件化处理是很多通用库采用的套路。我们看下<strong><strong>SDImageLoadersManager</strong></strong></p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">- (id&lt;SDWebImageOperation&gt;)requestImageWithURL:(NSURL *)url options:(SDWebImageOptions)options context:(SDWebImageContext *)context progress:(SDImageLoaderProgressBlock)progressBlock completed:(SDImageLoaderCompletedBlock)completedBlock &#123;</span><br><span class="line">    UIImage *cachedImage = context[SDWebImageContextLoaderCachedImage];</span><br><span class="line">    </span><br><span class="line">    SDWebImageDownloaderOptions downloaderOptions = <span class="number">0</span>;</span><br><span class="line">    if (options <span class="meta">&amp; SDWebImageLowPriority) downloaderOptions |= SDWebImageDownloaderLowPriority;</span></span><br><span class="line">    if (options <span class="meta">&amp; SDWebImageProgressiveLoad) downloaderOptions |= SDWebImageDownloaderProgressiveLoad;</span></span><br><span class="line">    if (options <span class="meta">&amp; SDWebImageRefreshCached) downloaderOptions |= SDWebImageDownloaderUseNSURLCache;</span></span><br><span class="line">    if (options <span class="meta">&amp; SDWebImageContinueInBackground) downloaderOptions |= SDWebImageDownloaderContinueInBackground;</span></span><br><span class="line">    if (options <span class="meta">&amp; SDWebImageHandleCookies) downloaderOptions |= SDWebImageDownloaderHandleCookies;</span></span><br><span class="line">    if (options <span class="meta">&amp; SDWebImageAllowInvalidSSLCertificates) downloaderOptions |= SDWebImageDownloaderAllowInvalidSSLCertificates;</span></span><br><span class="line">    if (options <span class="meta">&amp; SDWebImageHighPriority) downloaderOptions |= SDWebImageDownloaderHighPriority;</span></span><br><span class="line">    if (options <span class="meta">&amp; SDWebImageScaleDownLargeImages) downloaderOptions |= SDWebImageDownloaderScaleDownLargeImages;</span></span><br><span class="line">    if (options <span class="meta">&amp; SDWebImageAvoidDecodeImage) downloaderOptions |= SDWebImageDownloaderAvoidDecodeImage;</span></span><br><span class="line">    if (options <span class="meta">&amp; SDWebImageDecodeFirstFrameOnly) downloaderOptions |= SDWebImageDownloaderDecodeFirstFrameOnly;</span></span><br><span class="line">    if (options <span class="meta">&amp; SDWebImagePreloadAllFrames) downloaderOptions |= SDWebImageDownloaderPreloadAllFrames;</span></span><br><span class="line">    if (options <span class="meta">&amp; SDWebImageMatchAnimatedImageClass) downloaderOptions |= SDWebImageDownloaderMatchAnimatedImageClass;</span></span><br><span class="line">    </span><br><span class="line">    if (cachedImage <span class="meta">&amp;&amp; options &amp; SDWebImageRefreshCached) &#123;</span></span><br><span class="line">        <span class="comment">// force progressive off if image already cached but forced refreshing</span></span><br><span class="line">        downloaderOptions <span class="meta">&amp;= ~SDWebImageDownloaderProgressiveLoad;</span></span><br><span class="line">        <span class="comment">// ignore image read from NSURLCache if image if cached but force refreshing</span></span><br><span class="line">        downloaderOptions <span class="string">|= SDWebImageDownloaderIgnoreCachedResponse;</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return [self downloadImageWithURL:url options:downloaderOptions context:context progress:progressBlock completed:completedBlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和查找缓存一样在执行真正的下载任务之前，会先重建一份options，然后再开始真正的请求：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="operator">-</span> (nullable <span class="type">SDWebImageDownloadToken</span> <span class="operator">*</span>)downloadImageWithURL:(nullable <span class="type">NSURL</span> <span class="operator">*</span>)url</span><br><span class="line">                                                   options:(<span class="type">SDWebImageDownloaderOptions</span>)options</span><br><span class="line">                                                   context:(nullable <span class="type">SDWebImageContext</span> <span class="operator">*</span>)context</span><br><span class="line">                                                  progress:(nullable <span class="type">SDWebImageDownloaderProgressBlock</span>)progressBlock</span><br><span class="line">                                                 completed:(nullable <span class="type">SDWebImageDownloaderCompletedBlock</span>)completedBlock &#123;</span><br><span class="line">    <span class="comment">//..........</span></span><br><span class="line">    <span class="type">SD_LOCK</span>(<span class="keyword">self</span>.operationsLock);</span><br><span class="line">    id downloadOperationCancelToken;</span><br><span class="line">    <span class="comment">// 通过当前的url去self.URLOperations 中去取NSOperation</span></span><br><span class="line">    <span class="type">NSOperation</span>&lt;<span class="type">SDWebImageDownloaderOperation</span>&gt; <span class="operator">*</span>operation <span class="operator">=</span> [<span class="keyword">self</span>.<span class="type">URLOperations</span> objectForKey:url];</span><br><span class="line">    <span class="comment">// 如果当前url对应的operation为空，并且operation.isFinished = YES 或者 operation.isCancelled = YES,就调用createDownloaderOperationWithUrl新建一个NSOperation。</span></span><br><span class="line">    <span class="comment">// operation.isFinished = YES 或者 operation.isCancelled = YES 会发生在operation被取消或者被标记为结束，但是并没有将它从self.URLOperations移除</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="operator">!</span>operation <span class="operator">||</span> operation.isFinished <span class="operator">||</span> operation.isCancelled) &#123;</span><br><span class="line">        operation <span class="operator">=</span> [<span class="keyword">self</span> createDownloaderOperationWithUrl:url options:options context:context];</span><br><span class="line">        <span class="comment">// .......</span></span><br><span class="line">        <span class="comment">//operation 执行结束后会将当前url对应的operation从URLOperations中移除</span></span><br><span class="line">        <span class="meta">@weakify</span>(<span class="keyword">self</span>);</span><br><span class="line">        operation.completionBlock <span class="operator">=</span> <span class="operator">^</span>&#123;</span><br><span class="line">            <span class="meta">@strongify</span>(<span class="keyword">self</span>);</span><br><span class="line">            <span class="comment">//......</span></span><br><span class="line">            <span class="type">SD_LOCK</span>(<span class="keyword">self</span>.operationsLock);</span><br><span class="line">            [<span class="keyword">self</span>.<span class="type">URLOperations</span> removeObjectForKey:url];</span><br><span class="line">            <span class="type">SD_UNLOCK</span>(<span class="keyword">self</span>.operationsLock);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//添加到self.URLOperations中</span></span><br><span class="line">        <span class="keyword">self</span>.<span class="type">URLOperations</span>[url] <span class="operator">=</span> operation;</span><br><span class="line">        <span class="comment">// 将operation 添加到下载队列</span></span><br><span class="line">        [<span class="keyword">self</span>.downloadQueue addOperation:operation];</span><br><span class="line">        <span class="comment">//为当前的operation添加下载进度block以及下载完成的block</span></span><br><span class="line">        downloadOperationCancelToken <span class="operator">=</span> [operation addHandlersForProgress:progressBlock completed:completedBlock];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// So we lock the operation here, and in `SDWebImageDownloaderOperation`, we use `@synchonzied (self)`, to ensure the thread safe between these two classes.</span></span><br><span class="line">        <span class="comment">// 走到这里表示之前有对应的下载了，我们可以复用已经存在的下载，并添加progressBlock 以及completedBlock，这样在原先的下载任务完成后也会通知到当前的请求</span></span><br><span class="line">        <span class="meta">@synchronized</span> (operation) &#123;</span><br><span class="line">            downloadOperationCancelToken <span class="operator">=</span> [operation addHandlersForProgress:progressBlock completed:completedBlock];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="operator">!</span>operation.isExecuting) &#123;</span><br><span class="line">            <span class="keyword">if</span> (options <span class="operator">&amp;</span> <span class="type">SDWebImageDownloaderHighPriority</span>) &#123;</span><br><span class="line">                operation.queuePriority <span class="operator">=</span> <span class="type">NSOperationQueuePriorityHigh</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (options <span class="operator">&amp;</span> <span class="type">SDWebImageDownloaderLowPriority</span>) &#123;</span><br><span class="line">                operation.queuePriority <span class="operator">=</span> <span class="type">NSOperationQueuePriorityLow</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                operation.queuePriority <span class="operator">=</span> <span class="type">NSOperationQueuePriorityNormal</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">SD_UNLOCK</span>(<span class="keyword">self</span>.operationsLock);</span><br><span class="line">    <span class="comment">//这里返回的是一个SDWebImageDownloadToken，后面可以通过它来取消这个下载任务</span></span><br><span class="line">    <span class="type">SDWebImageDownloadToken</span> <span class="operator">*</span>token <span class="operator">=</span> [[<span class="type">SDWebImageDownloadToken</span> alloc] initWithDownloadOperation:operation];</span><br><span class="line">    token.url <span class="operator">=</span> url;</span><br><span class="line">    token.request <span class="operator">=</span> operation.request;</span><br><span class="line">    token.downloadOperationCancelToken <span class="operator">=</span> downloadOperationCancelToken;</span><br><span class="line">    <span class="keyword">return</span> token;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下载请求是基于NSOperation的，每个url对应一个NSOperation，这些NSOperation放在self.URLOperations 中统一管理，每次发起一个未存在的图片请求的时候就会新建一个NSOperation并添加到self.URLOperations，一旦完成下载这个url对应的NSOperation就会从self.URLOperations中移除。如果发起一个已经存在的url请求，那么就会复用当前已经开始的NSOperation，将当前的<strong><strong>progressBlock</strong></strong>，<strong><strong>completedBlock</strong></strong> 添加到 已经存在的NSOperation中，这样在原先的下载任务完成后也会通知到当前的请求响应的对应block。</p>
<p>我们接下来看下NSOperation的创建方法<strong><strong>createDownloaderOperationWithUrl</strong></strong>，这里主要是构建出NSRequest并通过请求修改器，对请求进行拦截修改，然后将返回体修改器，解密器以及Request 添加到NSOperation中。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSOperation</span>&lt;SDWebImageDownloaderOperation&gt; *)createDownloaderOperationWithUrl:(<span class="keyword">nonnull</span> <span class="built_in">NSURL</span> *)url</span><br><span class="line">                                                                                  options:(SDWebImageDownloaderOptions)options</span><br><span class="line">                                                                                  context:(<span class="keyword">nullable</span> SDWebImageContext *)context &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//配置网络超时时间，缓存策略等</span></span><br><span class="line">    <span class="built_in">NSTimeInterval</span> timeoutInterval = <span class="keyword">self</span>.config.downloadTimeout;</span><br><span class="line">    <span class="keyword">if</span> (timeoutInterval == <span class="number">0.0</span>) &#123;</span><br><span class="line">        timeoutInterval = <span class="number">15.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// In order to prevent from potential duplicate caching (NSURLCache + SDImageCache) we disable the cache for image requests if told otherwise</span></span><br><span class="line">    <span class="built_in">NSURLRequestCachePolicy</span> cachePolicy = options &amp; SDWebImageDownloaderUseNSURLCache ? <span class="built_in">NSURLRequestUseProtocolCachePolicy</span> : <span class="built_in">NSURLRequestReloadIgnoringLocalCacheData</span>;</span><br><span class="line">    <span class="built_in">NSMutableURLRequest</span> *mutableRequest = [[<span class="built_in">NSMutableURLRequest</span> alloc] initWithURL:url cachePolicy:cachePolicy timeoutInterval:timeoutInterval];</span><br><span class="line">    mutableRequest.HTTPShouldHandleCookies = SD_OPTIONS_CONTAINS(options, SDWebImageDownloaderHandleCookies);</span><br><span class="line">    mutableRequest.HTTPShouldUsePipelining = <span class="literal">YES</span>;</span><br><span class="line">    SD_LOCK(<span class="keyword">self</span>.HTTPHeadersLock);</span><br><span class="line">    mutableRequest.allHTTPHeaderFields = <span class="keyword">self</span>.HTTPHeaders;</span><br><span class="line">    SD_UNLOCK(<span class="keyword">self</span>.HTTPHeadersLock);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 取出context</span></span><br><span class="line">    SDWebImageMutableContext *mutableContext;</span><br><span class="line">    <span class="keyword">if</span> (context) &#123;</span><br><span class="line">        mutableContext = [context mutableCopy];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mutableContext = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从context中取出requestModifier，它会对当前的URL进行修改。</span></span><br><span class="line">    <span class="type">id</span>&lt;SDWebImageDownloaderRequestModifier&gt; requestModifier;</span><br><span class="line">    <span class="keyword">if</span> ([context valueForKey:SDWebImageContextDownloadRequestModifier]) &#123;</span><br><span class="line">        requestModifier = [context valueForKey:SDWebImageContextDownloadRequestModifier];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        requestModifier = <span class="keyword">self</span>.requestModifier;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSURLRequest</span> *request;</span><br><span class="line">    <span class="keyword">if</span> (requestModifier) &#123;</span><br><span class="line">        <span class="built_in">NSURLRequest</span> *modifiedRequest = [requestModifier modifiedRequestWithRequest:[mutableRequest <span class="keyword">copy</span>]];</span><br><span class="line">        <span class="comment">// If modified request is nil, early return</span></span><br><span class="line">        <span class="keyword">if</span> (!modifiedRequest) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            request = [modifiedRequest <span class="keyword">copy</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        request = [mutableRequest <span class="keyword">copy</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Response 修改器件</span></span><br><span class="line">    <span class="type">id</span>&lt;SDWebImageDownloaderResponseModifier&gt; responseModifier;</span><br><span class="line">    <span class="keyword">if</span> ([context valueForKey:SDWebImageContextDownloadResponseModifier]) &#123;</span><br><span class="line">        responseModifier = [context valueForKey:SDWebImageContextDownloadResponseModifier];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        responseModifier = <span class="keyword">self</span>.responseModifier;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (responseModifier) &#123;</span><br><span class="line">        mutableContext[SDWebImageContextDownloadResponseModifier] = responseModifier;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 解密器</span></span><br><span class="line">    <span class="type">id</span>&lt;SDWebImageDownloaderDecryptor&gt; decryptor;</span><br><span class="line">    <span class="keyword">if</span> ([context valueForKey:SDWebImageContextDownloadDecryptor]) &#123;</span><br><span class="line">        decryptor = [context valueForKey:SDWebImageContextDownloadDecryptor];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        decryptor = <span class="keyword">self</span>.decryptor;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (decryptor) &#123;</span><br><span class="line">        mutableContext[SDWebImageContextDownloadDecryptor] = decryptor;</span><br><span class="line">    &#125;</span><br><span class="line">    context = [mutableContext <span class="keyword">copy</span>];</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 取出指定的NSOperation class</span></span><br><span class="line">    Class operationClass = <span class="keyword">self</span>.config.operationClass;</span><br><span class="line">    <span class="keyword">if</span> (operationClass &amp;&amp; [operationClass isSubclassOfClass:[<span class="built_in">NSOperation</span> <span class="keyword">class</span>]] &amp;&amp; [operationClass conformsToProtocol:<span class="class"><span class="keyword">@protocol</span>(<span class="title">SDWebImageDownloaderOperation</span>)]) </span>&#123;</span><br><span class="line">        <span class="comment">// Custom operation class</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        operationClass = [SDWebImageDownloaderOperation <span class="keyword">class</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将处理过的request，以及 Response 修改器件，解密器放置到NSOperation</span></span><br><span class="line">    <span class="built_in">NSOperation</span>&lt;SDWebImageDownloaderOperation&gt; *operation = [[operationClass alloc] initWithRequest:request inSession:<span class="keyword">self</span>.session options:options context:context];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置认证信息</span></span><br><span class="line">    <span class="keyword">if</span> ([operation respondsToSelector:<span class="keyword">@selector</span>(setCredential:)]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.config.urlCredential) &#123;</span><br><span class="line">            operation.credential = <span class="keyword">self</span>.config.urlCredential;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">self</span>.config.username &amp;&amp; <span class="keyword">self</span>.config.password) &#123;</span><br><span class="line">            operation.credential = [<span class="built_in">NSURLCredential</span> credentialWithUser:<span class="keyword">self</span>.config.username password:<span class="keyword">self</span>.config.password persistence:<span class="built_in">NSURLCredentialPersistenceForSession</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//设置最小的进度</span></span><br><span class="line">    <span class="keyword">if</span> ([operation respondsToSelector:<span class="keyword">@selector</span>(setMinimumProgressInterval:)]) &#123;</span><br><span class="line">        operation.minimumProgressInterval = MIN(MAX(<span class="keyword">self</span>.config.minimumProgressInterval, <span class="number">0</span>), <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置优先级</span></span><br><span class="line">    <span class="keyword">if</span> (options &amp; SDWebImageDownloaderHighPriority) &#123;</span><br><span class="line">        operation.queuePriority = <span class="built_in">NSOperationQueuePriorityHigh</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (options &amp; SDWebImageDownloaderLowPriority) &#123;</span><br><span class="line">        operation.queuePriority = <span class="built_in">NSOperationQueuePriorityLow</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.config.executionOrder == SDWebImageDownloaderLIFOExecutionOrder) &#123;</span><br><span class="line">        <span class="comment">// Emulate LIFO execution order by systematically, each previous adding operation can dependency the new operation</span></span><br><span class="line">        <span class="comment">// This can gurantee the new operation to be execulated firstly, even if when some operations finished, meanwhile you appending new operations</span></span><br><span class="line">        <span class="comment">// Just make last added operation dependents new operation can not solve this problem. See test case #test15DownloaderLIFOExecutionOrder</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSOperation</span> *pendingOperation <span class="keyword">in</span> <span class="keyword">self</span>.downloadQueue.operations) &#123;</span><br><span class="line">            [pendingOperation addDependency:operation];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> operation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看到这里大家可能会有疑问，上面只是构建NSOperation然后添加到downloadQueue中，那么什么时候开始呢？我们看到了NSOperation创建过程如下：</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">NSOperation&lt;SDWebImageDownloaderOperation&gt; *operation = [[operationClass alloc] initWithRequest:request <span class="keyword">inSession:self.session </span>options:options <span class="built_in">context</span>:<span class="built_in">context</span>];</span><br></pre></td></tr></table></figure>
<p>这里持有了NSSession,我们知道网络数据的下载都是依靠NSSession的，所以下载的触发应该也是在NSOperation中。所以我们带着这个问题来看下<strong><strong>SDWebImageDownloaderOperation</strong></strong>从初始化方法中我们可以看到它包含很多重要的组件，具体的见下面注释。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">nonnull</span> <span class="keyword">instancetype</span>)initWithRequest:(<span class="keyword">nullable</span> <span class="built_in">NSURLRequest</span> *)request</span><br><span class="line">                              inSession:(<span class="keyword">nullable</span> <span class="built_in">NSURLSession</span> *)session</span><br><span class="line">                                options:(SDWebImageDownloaderOptions)options</span><br><span class="line">                                context:(<span class="keyword">nullable</span> SDWebImageContext *)context &#123;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">self</span> = [<span class="variable language_">super</span> init])) &#123;</span><br><span class="line">        _request = [request <span class="keyword">copy</span>]; <span class="comment">//当前下载请求NSURLRequest</span></span><br><span class="line">        _options = options;        <span class="comment">//下载选项</span></span><br><span class="line">        _context = [context <span class="keyword">copy</span>]; <span class="comment">//包含一系列组件的上下文</span></span><br><span class="line">        _callbackBlocks = [<span class="built_in">NSMutableArray</span> new];<span class="comment">//进度通知block和下载完成处理block</span></span><br><span class="line">        _responseModifier = context[SDWebImageContextDownloadResponseModifier];<span class="comment">//返回内容修改器</span></span><br><span class="line">        _decryptor = context[SDWebImageContextDownloadDecryptor];<span class="comment">//解码器</span></span><br><span class="line">        _executing = <span class="literal">NO</span>; <span class="comment">//当前状态</span></span><br><span class="line">        _finished = <span class="literal">NO</span>;   <span class="comment">//当前状态</span></span><br><span class="line">        _expectedSize = <span class="number">0</span>;</span><br><span class="line">        _unownedSession = session; <span class="comment">//NSSession</span></span><br><span class="line">        _coderQueue = dispatch_queue_create(<span class="string">&quot;com.hackemist.SDWebImageDownloaderOperationCoderQueue&quot;</span>, DISPATCH_QUEUE_SERIAL);<span class="comment">//解码队列</span></span><br><span class="line">        _backgroundTaskId = <span class="built_in">UIBackgroundTaskInvalid</span>;<span class="comment">//后台id</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们带着大家来解决如下几个问题：</p>
<ol>
<li>SDWebImageDownloaderOperation是如何使用NSSession发起下载请求的？</li>
<li>请求后通过代理返回的数据怎么传到SDWebImageDownloaderOperation中？在SDWebImageDownloaderOperation又是怎么做处理的。</li>
<li>图片下载后是怎么通知给上层的，下载进度又是如何传递的？</li>
</ol>
<p>我们先来看下第一个问题：</p>
<ul>
<li><strong><strong>SDWebImageDownloaderOperation是如何使用NSSession发起下载请求的？</strong></strong></li>
</ul>
<p>这个比较好回答，我们知道NSOperation运行会调用它的start方法，所以我们要回答这个问题也应该从这个方法入手：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="operator">-</span> (void)start &#123;</span><br><span class="line">    <span class="meta">@synchronized</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//开始之前就已经被取消了</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.isCancelled) &#123;</span><br><span class="line">            <span class="keyword">self</span>.finished <span class="operator">=</span> <span class="type">YES</span>;</span><br><span class="line">            <span class="comment">// Operation cancelled by user before sending the request</span></span><br><span class="line">            [<span class="keyword">self</span> callCompletionBlocksWithError:[<span class="type">NSError</span> errorWithDomain:<span class="type">SDWebImageErrorDomain</span> code:<span class="type">SDWebImageErrorCancelled</span> userInfo:<span class="literal">nil</span>]];</span><br><span class="line">            [<span class="keyword">self</span> reset];</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//退出后台后会停止该下载任务</span></span><br><span class="line">        <span class="type">Class</span> <span class="type">UIApplicationClass</span> <span class="operator">=</span> <span class="type">NSClassFromString</span>(@<span class="string">&quot;UIApplication&quot;</span>);</span><br><span class="line">        <span class="type">BOOL</span> hasApplication <span class="operator">=</span> <span class="type">UIApplicationClass</span> <span class="operator">&amp;&amp;</span> [<span class="type">UIApplicationClass</span> respondsToSelector:<span class="meta">@selector</span>(sharedApplication)];</span><br><span class="line">        <span class="keyword">if</span> (hasApplication <span class="operator">&amp;&amp;</span> [<span class="keyword">self</span> shouldContinueWhenAppEntersBackground]) &#123;</span><br><span class="line">            __weak typeof(<span class="keyword">self</span>) wself <span class="operator">=</span> <span class="keyword">self</span>;</span><br><span class="line">            <span class="type">UIApplication</span> <span class="operator">*</span> app <span class="operator">=</span> [<span class="type">UIApplicationClass</span> performSelector:<span class="meta">@selector</span>(sharedApplication)];</span><br><span class="line">            <span class="keyword">self</span>.backgroundTaskId <span class="operator">=</span> [app beginBackgroundTaskWithExpirationHandler:<span class="operator">^</span>&#123;</span><br><span class="line">                [wself cancel];</span><br><span class="line">            &#125;];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//构建session</span></span><br><span class="line">        <span class="type">NSURLSession</span> <span class="operator">*</span>session <span class="operator">=</span> <span class="keyword">self</span>.unownedSession;</span><br><span class="line">        <span class="comment">//......</span></span><br><span class="line">        <span class="comment">//通过session 以及request 创建出一个 dataTask</span></span><br><span class="line">        <span class="keyword">self</span>.dataTask <span class="operator">=</span> [session dataTaskWithRequest:<span class="keyword">self</span>.request];</span><br><span class="line">        <span class="keyword">self</span>.executing <span class="operator">=</span> <span class="type">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.dataTask) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.options <span class="operator">&amp;</span> <span class="type">SDWebImageDownloaderHighPriority</span>) &#123;</span><br><span class="line">            <span class="keyword">self</span>.dataTask.priority <span class="operator">=</span> <span class="type">NSURLSessionTaskPriorityHigh</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">self</span>.options <span class="operator">&amp;</span> <span class="type">SDWebImageDownloaderLowPriority</span>) &#123;</span><br><span class="line">            <span class="keyword">self</span>.dataTask.priority <span class="operator">=</span> <span class="type">NSURLSessionTaskPriorityLow</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//启动下载任务</span></span><br><span class="line">        [<span class="keyword">self</span>.dataTask resume];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">SDWebImageDownloaderProgressBlock</span> progressBlock <span class="keyword">in</span> [<span class="keyword">self</span> callbacksForKey:kProgressCallbackKey]) &#123;</span><br><span class="line">            progressBlock(<span class="number">0</span>, <span class="type">NSURLResponseUnknownLength</span>, <span class="keyword">self</span>.request.<span class="type">URL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//发出启动下载通知</span></span><br><span class="line">        __block typeof(<span class="keyword">self</span>) strongSelf <span class="operator">=</span> <span class="keyword">self</span>;</span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), <span class="operator">^</span>&#123;</span><br><span class="line">            [[<span class="type">NSNotificationCenter</span> defaultCenter] postNotificationName:<span class="type">SDWebImageDownloadStartNotification</span> object:strongSelf];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//.....</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整个过程还是拿传入的request使用NSSession创建出dataTask，然后调用dataTask的resume方法启动下载。下载后数据会从相应的代理方法中获得，但是代理是SDWebImageDownloader，如何将它传给SDWebImageDownloaderOperation呢？我们接下来就来回答这第二个问题，如果看过AFNetWorking源码的对这个流程会比较熟悉，大致相同。</p>
<ul>
<li>*<strong><strong>请求后通过代理返回的数据怎么传到SDWebImageDownloaderOperation中？在SDWebImageDownloaderOperation又是怎么做处理的</strong></strong></li>
</ul>
<p>我们在delegate中拿到的是task，所以我们要通过task找到它所属的NSOperation:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="operator">-</span> (<span class="type">NSOperation</span>&lt;<span class="type">SDWebImageDownloaderOperation</span>&gt; <span class="operator">*</span>)operationWithTask:(<span class="type">NSURLSessionTask</span> <span class="operator">*</span>)task &#123;</span><br><span class="line">    <span class="type">NSOperation</span>&lt;<span class="type">SDWebImageDownloaderOperation</span>&gt; <span class="operator">*</span>returnOperation <span class="operator">=</span> <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">NSOperation</span>&lt;<span class="type">SDWebImageDownloaderOperation</span>&gt; <span class="operator">*</span>operation <span class="keyword">in</span> <span class="keyword">self</span>.downloadQueue.operations) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([operation respondsToSelector:<span class="meta">@selector</span>(dataTask)]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (operation.dataTask.taskIdentifier <span class="operator">==</span> task.taskIdentifier) &#123;</span><br><span class="line">                returnOperation <span class="operator">=</span> operation;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> returnOperation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>嗯，就是通过遍历NSOperation拿当前的task的taskIdentifier与self.downloadQueue.operations中task的taskIdentifier进行匹配，找到所属的NSOperation。</p>
<p>我们下下面的一个代理方法,它就是通过operationWithTask找到对应的NSOperation，然后再调用NSOperation中相对应的方法处理：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session dataTask:(<span class="built_in">NSURLSessionDataTask</span> *)dataTask didReceiveData:(<span class="built_in">NSData</span> *)data &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Identify the operation that runs this task and pass it the delegate method</span></span><br><span class="line">    <span class="built_in">NSOperation</span>&lt;SDWebImageDownloaderOperation&gt; *dataOperation = [<span class="keyword">self</span> operationWithTask:dataTask];</span><br><span class="line">    <span class="keyword">if</span> ([dataOperation respondsToSelector:<span class="keyword">@selector</span>(URLSession:dataTask:didReceiveData:)]) &#123;</span><br><span class="line">        [dataOperation URLSession:session dataTask:dataTask didReceiveData:data];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们接下来看下具体代理的处理：</p>
<p>收到服务端回复的时候会调用didReceiveResponse代理方法，这里主要是通过使用返回体修改器对返回的请求进行处理，然后再进行状态码进行校验。具体见如下代码注释：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</span><br><span class="line">          dataTask:(<span class="built_in">NSURLSessionDataTask</span> *)dataTask</span><br><span class="line">didReceiveResponse:(<span class="built_in">NSURLResponse</span> *)response</span><br><span class="line"> completionHandler:(<span class="type">void</span> (^)(<span class="built_in">NSURLSessionResponseDisposition</span> disposition))completionHandler &#123;</span><br><span class="line">    <span class="built_in">NSURLSessionResponseDisposition</span> disposition = <span class="built_in">NSURLSessionResponseAllow</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Check response modifier, if return nil, will marked as cancelled.</span></span><br><span class="line">    <span class="type">BOOL</span> valid = <span class="literal">YES</span>;</span><br><span class="line">    <span class="comment">// 使用返回体修改器对返回的请求进行处理</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.responseModifier &amp;&amp; response) &#123;</span><br><span class="line">        response = [<span class="keyword">self</span>.responseModifier modifiedResponseWithResponse:response];</span><br><span class="line">        <span class="keyword">if</span> (!response) &#123;</span><br><span class="line">            valid = <span class="literal">NO</span>;</span><br><span class="line">            <span class="keyword">self</span>.responseError = [<span class="built_in">NSError</span> errorWithDomain:SDWebImageErrorDomain code:SDWebImageErrorInvalidDownloadResponse userInfo:<span class="literal">nil</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSInteger</span> expected = (<span class="built_in">NSInteger</span>)response.expectedContentLength;</span><br><span class="line">    expected = expected &gt; <span class="number">0</span> ? expected : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">self</span>.expectedSize = expected;</span><br><span class="line">    <span class="keyword">self</span>.response = response;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//状态码检查</span></span><br><span class="line">    <span class="built_in">NSInteger</span> statusCode = [response respondsToSelector:<span class="keyword">@selector</span>(statusCode)] ? ((<span class="built_in">NSHTTPURLResponse</span> *)response).statusCode : <span class="number">200</span>;</span><br><span class="line">    <span class="comment">// Status code should between [200,400)</span></span><br><span class="line">    <span class="type">BOOL</span> statusCodeValid = statusCode &gt;= <span class="number">200</span> &amp;&amp; statusCode &lt; <span class="number">400</span>;</span><br><span class="line">    <span class="keyword">if</span> (!statusCodeValid) &#123;</span><br><span class="line">        valid = <span class="literal">NO</span>;</span><br><span class="line">        <span class="keyword">self</span>.responseError = [<span class="built_in">NSError</span> errorWithDomain:SDWebImageErrorDomain code:SDWebImageErrorInvalidDownloadStatusCode userInfo:@&#123;SDWebImageErrorDownloadStatusCodeKey : @(statusCode)&#125;];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="comment">//进度提交给应用层上层</span></span><br><span class="line">    <span class="keyword">if</span> (valid) &#123;</span><br><span class="line">        <span class="keyword">for</span> (SDWebImageDownloaderProgressBlock progressBlock <span class="keyword">in</span> [<span class="keyword">self</span> callbacksForKey:kProgressCallbackKey]) &#123;</span><br><span class="line">            progressBlock(<span class="number">0</span>, expected, <span class="keyword">self</span>.request.URL);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        disposition = <span class="built_in">NSURLSessionResponseCancel</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//发出通知</span></span><br><span class="line">    __block <span class="keyword">typeof</span>(<span class="keyword">self</span>) strongSelf = <span class="keyword">self</span>;</span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:SDWebImageDownloadReceiveResponseNotification object:strongSelf];</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (completionHandler) &#123;</span><br><span class="line">        completionHandler(disposition);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在收到图像数据后会回调didReceiveData代理，在didReceiveData中回将收到的图片数据追加到imageData，这里比较关键的是渐进式图片解码，顾名思义就是拿到多少数据就立刻解码交给上层展示，最后将当前下载进度通知给业务层，对应的关键部分看下面的注解：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="operator">-</span> (void)<span class="type">URLSession</span>:(<span class="type">NSURLSession</span> <span class="operator">*</span>)session dataTask:(<span class="type">NSURLSessionDataTask</span> <span class="operator">*</span>)dataTask didReceiveData:(<span class="type">NSData</span> <span class="operator">*</span>)data &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="operator">!</span><span class="keyword">self</span>.imageData) &#123;</span><br><span class="line">        <span class="keyword">self</span>.imageData <span class="operator">=</span> [[<span class="type">NSMutableData</span> alloc] initWithCapacity:<span class="keyword">self</span>.expectedSize];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将数据追加到self.imageData</span></span><br><span class="line">    [<span class="keyword">self</span>.imageData appendData:data];</span><br><span class="line">    <span class="keyword">self</span>.receivedSize <span class="operator">=</span> <span class="keyword">self</span>.imageData.length;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.expectedSize <span class="operator">==</span> <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Unknown expectedSize, immediately call progressBlock and return</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">SDWebImageDownloaderProgressBlock</span> progressBlock <span class="keyword">in</span> [<span class="keyword">self</span> callbacksForKey:kProgressCallbackKey]) &#123;</span><br><span class="line">            progressBlock(<span class="keyword">self</span>.receivedSize, <span class="keyword">self</span>.expectedSize, <span class="keyword">self</span>.request.<span class="type">URL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取当前的下载状态，是否结束</span></span><br><span class="line">    <span class="type">BOOL</span> finished <span class="operator">=</span> (<span class="keyword">self</span>.receivedSize <span class="operator">&gt;=</span> <span class="keyword">self</span>.expectedSize);</span><br><span class="line">    <span class="comment">// 计算当前下载进度</span></span><br><span class="line">    double currentProgress <span class="operator">=</span> (double)<span class="keyword">self</span>.receivedSize <span class="operator">/</span> (double)<span class="keyword">self</span>.expectedSize;</span><br><span class="line">    double previousProgress <span class="operator">=</span> <span class="keyword">self</span>.previousProgress;</span><br><span class="line">    double progressInterval <span class="operator">=</span> currentProgress <span class="operator">-</span> previousProgress;</span><br><span class="line">    <span class="comment">// 只有在大于最小的进度间隔才会通知上层block</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="operator">!</span>finished <span class="operator">&amp;&amp;</span> (progressInterval <span class="operator">&lt;</span> <span class="keyword">self</span>.minimumProgressInterval)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">self</span>.previousProgress <span class="operator">=</span> currentProgress;</span><br><span class="line">    <span class="comment">//如果使用数据解码器将会禁止渐进式解码，</span></span><br><span class="line">    <span class="type">BOOL</span> supportProgressive <span class="operator">=</span> (<span class="keyword">self</span>.options <span class="operator">&amp;</span> <span class="type">SDWebImageDownloaderProgressiveLoad</span>) <span class="operator">&amp;&amp;</span> <span class="operator">!</span><span class="keyword">self</span>.decryptor;</span><br><span class="line">    <span class="keyword">if</span> (supportProgressive) &#123;</span><br><span class="line">        <span class="comment">//获得当前的图片数据</span></span><br><span class="line">        <span class="type">NSData</span> <span class="operator">*</span>imageData <span class="operator">=</span> [<span class="keyword">self</span>.imageData copy];</span><br><span class="line">        <span class="comment">//在解码队列进行渐进式解码</span></span><br><span class="line">        dispatch_async(<span class="keyword">self</span>.coderQueue, <span class="operator">^</span>&#123;</span><br><span class="line">            <span class="meta">@autoreleasepool</span> &#123;</span><br><span class="line">                <span class="type">UIImage</span> <span class="operator">*</span>image <span class="operator">=</span> <span class="type">SDImageLoaderDecodeProgressiveImageData</span>(imageData, <span class="keyword">self</span>.request.<span class="type">URL</span>, finished, <span class="keyword">self</span>, [[<span class="keyword">self</span> <span class="keyword">class</span>] imageOptionsFromDownloaderOptions:<span class="keyword">self</span>.options], <span class="keyword">self</span>.context);</span><br><span class="line">                <span class="keyword">if</span> (image) &#123;</span><br><span class="line">                    <span class="comment">//将数据交给业务层，注意这里的finished为NO,因为还没下载完</span></span><br><span class="line">                    [<span class="keyword">self</span> callCompletionBlocksWithImage:image imageData:<span class="literal">nil</span> error:<span class="literal">nil</span> finished:<span class="type">NO</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从callbacksForKey中取出对应的进度回调block，将进度上传给业务层</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">SDWebImageDownloaderProgressBlock</span> progressBlock <span class="keyword">in</span> [<span class="keyword">self</span> callbacksForKey:kProgressCallbackKey]) &#123;</span><br><span class="line">        progressBlock(<span class="keyword">self</span>.receivedSize, <span class="keyword">self</span>.expectedSize, <span class="keyword">self</span>.request.<span class="type">URL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们重点看下解码部分：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">UIImage<span class="operator"> * </span>_Nullable <span class="constructor">SDImageLoaderDecodeProgressiveImageData(NSData <span class="operator">*</span> <span class="params">_Nonnull</span> <span class="params">imageData</span>, NSURL <span class="operator">*</span> <span class="params">_Nonnull</span> <span class="params">imageURL</span>, BOOL <span class="params">finished</span>,  <span class="params">id</span>&lt;SDWebImageOperation&gt; <span class="params">_Nonnull</span> <span class="params">operation</span>, SDWebImageOptions <span class="params">options</span>, SDWebImageContext <span class="operator">*</span> <span class="params">_Nullable</span> <span class="params">context</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//.......</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取缓存key</span></span><br><span class="line">    UIImage *image;</span><br><span class="line">    id&lt;SDWebImageCacheKeyFilter&gt; cacheKeyFilter = context<span class="literal">[SDW<span class="identifier">ebImageContextCacheKeyFilter</span>]</span>;</span><br><span class="line">    NSString *cacheKey;</span><br><span class="line">    <span class="keyword">if</span> (cacheKeyFilter) &#123;</span><br><span class="line">        cacheKey = <span class="literal">[<span class="identifier">cacheKeyFilter</span> <span class="identifier">cacheKeyForURL</span>:<span class="identifier">imageURL</span>]</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cacheKey = imageURL.absoluteString;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取scale</span></span><br><span class="line">    BOOL decodeFirstFrame = <span class="constructor">SD_OPTIONS_CONTAINS(<span class="params">options</span>, SDWebImageDecodeFirstFrameOnly)</span>;</span><br><span class="line">    NSNumber *scaleValue = context<span class="literal">[SDW<span class="identifier">ebImageContextImageScaleFactor</span>]</span>;</span><br><span class="line">    CGFloat scale = scaleValue.doubleValue &gt;= <span class="number">1</span> ? scaleValue.doubleValue : <span class="constructor">SDImageScaleFactorForKey(<span class="params">cacheKey</span>)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//构建解码Option</span></span><br><span class="line">    SDImageCoderOptions *coderOptions = @&#123;SDImageCoderDecodeFirstFrameOnly : @(decodeFirstFrame), SDImageCoderDecodeScaleFactor : @(scale)&#125;;</span><br><span class="line">    <span class="keyword">if</span> (context) &#123;</span><br><span class="line">        SDImageCoderMutableOptions *mutableCoderOptions = <span class="literal">[<span class="identifier">coderOptions</span> <span class="identifier">mutableCopy</span>]</span>;</span><br><span class="line">        <span class="literal">[<span class="identifier">mutableCoderOptions</span> <span class="identifier">setValue</span>:<span class="identifier">context</span> <span class="identifier">forKey</span>:SDI<span class="identifier">mageCoderWebImageContext</span>]</span>;</span><br><span class="line">        coderOptions = <span class="literal">[<span class="identifier">mutableCoderOptions</span> <span class="identifier">copy</span>]</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取对应的渐进式解码器</span></span><br><span class="line">    id&lt;SDProgressiveImageCoder&gt; progressiveCoder = objc<span class="constructor">_getAssociatedObject(<span class="params">operation</span>, SDImageLoaderProgressiveCoderKey)</span>;</span><br><span class="line">    <span class="keyword">if</span> (!progressiveCoder) &#123;</span><br><span class="line">        <span class="comment">// We need to create a new instance for progressive decoding to avoid conflicts</span></span><br><span class="line">        <span class="keyword">for</span> (id&lt;SDImageCoder&gt;coder <span class="keyword">in</span> <span class="literal">[SDI<span class="identifier">mageCodersManager</span> <span class="identifier">sharedManager</span>]</span>.coders.reverseObjectEnumerator) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="literal">[<span class="identifier">coder</span> <span class="identifier">conformsToProtocol</span>:@<span class="identifier">protocol</span>(SDP<span class="identifier">rogressiveImageCoder</span>)]</span><span class="operator"> &amp;&amp;</span></span><br><span class="line"><span class="operator">                </span><span class="literal">[((<span class="identifier">id</span>&lt;SDP<span class="identifier">rogressiveImageCoder</span>&gt;)<span class="identifier">coder</span>) <span class="identifier">canIncrementalDecodeFromData</span>:<span class="identifier">imageData</span>]</span>) &#123;</span><br><span class="line">                <span class="comment">//通过Options来创建渐进式解码器</span></span><br><span class="line">                progressiveCoder = <span class="literal">[[[<span class="identifier">coder</span> <span class="identifier">class</span>]</span> alloc] initIncrementalWithOptions:coderOptions];</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        objc<span class="constructor">_setAssociatedObject(<span class="params">operation</span>, SDImageLoaderProgressiveCoderKey, <span class="params">progressiveCoder</span>, OBJC_ASSOCIATION_RETAIN_NONATOMIC)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="comment">//将图片数据更新到渐进式解码器</span></span><br><span class="line">    <span class="literal">[<span class="identifier">progressiveCoder</span> <span class="identifier">updateIncrementalData</span>:<span class="identifier">imageData</span> <span class="identifier">finished</span>:<span class="identifier">finished</span>]</span>;</span><br><span class="line">    <span class="comment">//..........</span></span><br><span class="line">    <span class="keyword">if</span> (!image) &#123;</span><br><span class="line">        <span class="comment">//进行解码</span></span><br><span class="line">        image = <span class="literal">[<span class="identifier">progressiveCoder</span> <span class="identifier">incrementalDecodedImageWithOptions</span>:<span class="identifier">coderOptions</span>]</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (image) &#123;</span><br><span class="line">        <span class="comment">//是否需要解码</span></span><br><span class="line">        BOOL shouldDecode = !<span class="constructor">SD_OPTIONS_CONTAINS(<span class="params">options</span>, SDWebImageAvoidDecodeImage)</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">[<span class="identifier">image</span>.<span class="identifier">class</span> <span class="identifier">conformsToProtocol</span>:@<span class="identifier">protocol</span>(SDA<span class="identifier">nimatedImage</span>)]</span>) &#123;</span><br><span class="line">            <span class="comment">// `SDAnimatedImage` do not decode</span></span><br><span class="line">            shouldDecode = NO;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (image.sd_isAnimated) &#123;</span><br><span class="line">            <span class="comment">// animated image do not decode</span></span><br><span class="line">            shouldDecode = NO;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果需要解码则调用decodedImageWithImage进行解码</span></span><br><span class="line">        <span class="keyword">if</span> (shouldDecode) &#123;</span><br><span class="line">            image = <span class="literal">[SDI<span class="identifier">mageCoderHelper</span> <span class="identifier">decodedImageWithImage</span>:<span class="identifier">image</span>]</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        image.sd_isIncremental = YES;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return image;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面最关键的部分在于：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">[progressiveCoder updateIncrementalData:imageData finished:finished];</span><br><span class="line">image = [progressiveCoder incrementalDecodedImageWithOptions:coderOptions];</span><br><span class="line"><span class="keyword">if</span> (image) &#123;</span><br><span class="line">    <span class="comment">//是否需要解码</span></span><br><span class="line">    BOOL shouldDecode = !<span class="built_in">SD_OPTIONS_CONTAINS</span>(options, SDWebImageAvoidDecodeImage);</span><br><span class="line">    <span class="keyword">if</span> ([image.<span class="keyword">class</span> conformsToProtocol:@<span class="built_in">protocol</span>(SDAnimatedImage)]) &#123;</span><br><span class="line">        <span class="comment">// `SDAnimatedImage` do not decode</span></span><br><span class="line">        shouldDecode = NO;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (image.sd_isAnimated) &#123;</span><br><span class="line">        <span class="comment">// animated image do not decode</span></span><br><span class="line">        shouldDecode = NO;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果需要解码则调用decodedImageWithImage进行解码</span></span><br><span class="line">    <span class="keyword">if</span> (shouldDecode) &#123;</span><br><span class="line">        image = [SDImageCoderHelper decodedImageWithImage:image];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// mark the image as progressive (completionBlock one are not mark as progressive)</span></span><br><span class="line">    image.sd_isIncremental = YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里渐进式解码器也有好多种，我们仅仅以其中的一种<strong><strong>SDImageIOAnimatedCoder</strong></strong>为例子：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)updateIncrementalData:(<span class="built_in">NSData</span> *)data finished:(<span class="type">BOOL</span>)finished &#123;</span><br><span class="line">    <span class="comment">//.......</span></span><br><span class="line">    <span class="comment">//更新数据</span></span><br><span class="line">    _imageData = data;</span><br><span class="line">    _finished = finished;</span><br><span class="line">    <span class="comment">//通过接口更新图片数据</span></span><br><span class="line">    <span class="built_in">CGImageSourceUpdateData</span>(_imageSource, (__bridge <span class="built_in">CFDataRef</span>)data, finished);</span><br><span class="line">    <span class="keyword">if</span> (_width + _height == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//读取图片属性</span></span><br><span class="line">        <span class="built_in">CFDictionaryRef</span> properties = <span class="built_in">CGImageSourceCopyPropertiesAtIndex</span>(_imageSource, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (properties) &#123;</span><br><span class="line">            <span class="comment">//获取到图片的宽高</span></span><br><span class="line">            <span class="built_in">CFTypeRef</span> val = <span class="built_in">CFDictionaryGetValue</span>(properties, kCGImagePropertyPixelHeight);</span><br><span class="line">            <span class="keyword">if</span> (val) <span class="built_in">CFNumberGetValue</span>(val, kCFNumberLongType, &amp;_height);</span><br><span class="line">            val = <span class="built_in">CFDictionaryGetValue</span>(properties, kCGImagePropertyPixelWidth);</span><br><span class="line">            <span class="keyword">if</span> (val) <span class="built_in">CFNumberGetValue</span>(val, kCFNumberLongType, &amp;_width);</span><br><span class="line">            <span class="built_in">CFRelease</span>(properties);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//检查帧的有效性</span></span><br><span class="line">    [<span class="keyword">self</span> scanAndCheckFramesValidWithImageSource:_imageSource];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">BOOL</span>)scanAndCheckFramesValidWithImageSource:(<span class="built_in">CGImageSourceRef</span>)imageSource &#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="comment">//获取图片数据的帧数</span></span><br><span class="line">    <span class="built_in">NSUInteger</span> frameCount = <span class="built_in">CGImageSourceGetCount</span>(imageSource);</span><br><span class="line">    <span class="built_in">NSUInteger</span> loopCount = [<span class="keyword">self</span>.class imageLoopCountWithSource:imageSource];</span><br><span class="line">    <span class="built_in">NSMutableArray</span>&lt;SDImageIOCoderFrame *&gt; *frames = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; frameCount; i++) &#123;</span><br><span class="line">        SDImageIOCoderFrame *frame = [[SDImageIOCoderFrame alloc] init];</span><br><span class="line">        <span class="comment">//获取帧序列</span></span><br><span class="line">        frame.index = i;</span><br><span class="line">        <span class="comment">//获取帧时长</span></span><br><span class="line">        frame.duration = [<span class="keyword">self</span>.class frameDurationAtIndex:i source:imageSource];</span><br><span class="line">        <span class="comment">//将其添加到frames</span></span><br><span class="line">        [frames addObject:frame];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    _frameCount = frameCount;</span><br><span class="line">    _loopCount = loopCount;</span><br><span class="line">    _frames = [frames <span class="keyword">copy</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">UIImage</span> *)incrementalDecodedImageWithOptions:(SDImageCoderOptions *)options &#123;</span><br><span class="line">    <span class="built_in">UIImage</span> *image;</span><br><span class="line">    <span class="keyword">if</span> (_width + _height &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 取出当前的第一帧</span></span><br><span class="line">        <span class="built_in">CGImageRef</span> partialImageRef = <span class="built_in">CGImageSourceCreateImageAtIndex</span>(_imageSource, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (partialImageRef) &#123;</span><br><span class="line">            <span class="built_in">CGFloat</span> scale = _scale;</span><br><span class="line">            <span class="built_in">NSNumber</span> *scaleFactor = options[SDImageCoderDecodeScaleFactor];</span><br><span class="line">            <span class="keyword">if</span> (scaleFactor != <span class="literal">nil</span>) &#123;</span><br><span class="line">                scale = MAX([scaleFactor doubleValue], <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            image = [[<span class="built_in">UIImage</span> alloc] initWithCGImage:partialImageRef scale:scale orientation:<span class="built_in">UIImageOrientationUp</span>];</span><br><span class="line">            <span class="built_in">CGImageRelease</span>(partialImageRef);</span><br><span class="line">            image.sd_imageFormat = <span class="keyword">self</span>.class.imageFormat;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> image;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码主要就是在数据帧来的时候更新数据源，然后解码数据，取出当前帧的第一帧构建后返回。</p>
<p>紧接着就会根据当前的情况除了动图都会对其进行解码，我们来看下解码部分的代码：</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">+ (UIImage *)decodedImageWithImage:(UIImage *)<span class="built_in">image</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (![self shouldDecodeImage:<span class="built_in">image</span>]) &#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="built_in">image</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    CGImageRef imageRef = [self CGImageCreateDecoded:<span class="built_in">image</span>.CGImage];</span><br><span class="line">    <span class="keyword">if</span> (!imageRef) &#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="built_in">image</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    UIImage *decodedImage = [[UIImage alloc] initWithCGImage:imageRef <span class="built_in">scale</span>:<span class="built_in">image</span>.<span class="built_in">scale</span> <span class="built_in">orientation</span>:<span class="built_in">image</span>.imageOrientation];</span><br><span class="line">    CGImageRelease(imageRef);</span><br><span class="line">    decodedImage.sd_isDecoded = YES;</span><br><span class="line">    decodedImage.sd_imageFormat = <span class="built_in">image</span>.sd_imageFormat;</span><br><span class="line">    <span class="built_in">return</span> decodedImage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>嗯，这块不是很难，过一下就可以了。</p>
<p>最后我们看下下载完成后的处理：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="operator">-</span> (void)<span class="type">URLSession</span>:(<span class="type">NSURLSession</span> <span class="operator">*</span>)session task:(<span class="type">NSURLSessionTask</span> <span class="operator">*</span>)task didCompleteWithError:(<span class="type">NSError</span> <span class="operator">*</span>)error &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        <span class="comment">//.........</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> ([<span class="keyword">self</span> callbacksForKey:kCompletedCallbackKey].count <span class="operator">&gt;</span> <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">NSData</span> <span class="operator">*</span>imageData <span class="operator">=</span> [<span class="keyword">self</span>.imageData copy];</span><br><span class="line">            <span class="keyword">self</span>.imageData <span class="operator">=</span> <span class="literal">nil</span>;</span><br><span class="line">            <span class="comment">// 使用数据解密器对图片数据进行解密</span></span><br><span class="line">            <span class="keyword">if</span> (imageData <span class="operator">&amp;&amp;</span> <span class="keyword">self</span>.decryptor) &#123;</span><br><span class="line">                imageData <span class="operator">=</span> [<span class="keyword">self</span>.decryptor decryptedDataWithData:imageData response:<span class="keyword">self</span>.response];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (imageData) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">self</span>.options <span class="operator">&amp;</span> <span class="type">SDWebImageDownloaderIgnoreCachedResponse</span> <span class="operator">&amp;&amp;</span> [<span class="keyword">self</span>.cachedData isEqualToData:imageData]) &#123;</span><br><span class="line">                    <span class="comment">//...........</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 对图像数据进行解码</span></span><br><span class="line">                    dispatch_async(<span class="keyword">self</span>.coderQueue, <span class="operator">^</span>&#123;</span><br><span class="line">                        <span class="meta">@autoreleasepool</span> &#123;</span><br><span class="line">                            <span class="type">UIImage</span> <span class="operator">*</span>image <span class="operator">=</span> <span class="type">SDImageLoaderDecodeImageData</span>(imageData, <span class="keyword">self</span>.request.<span class="type">URL</span>, [[<span class="keyword">self</span> <span class="keyword">class</span>] imageOptionsFromDownloaderOptions:<span class="keyword">self</span>.options], <span class="keyword">self</span>.context);</span><br><span class="line">                            <span class="type">CGSize</span> imageSize <span class="operator">=</span> image.size;</span><br><span class="line">                            <span class="keyword">if</span> (imageSize.width <span class="operator">==</span> <span class="number">0</span> <span class="operator">||</span> imageSize.height <span class="operator">==</span> <span class="number">0</span>) &#123;</span><br><span class="line">                                [<span class="keyword">self</span> callCompletionBlocksWithError:[<span class="type">NSError</span> errorWithDomain:<span class="type">SDWebImageErrorDomain</span> code:<span class="type">SDWebImageErrorBadImageData</span> userInfo:@&#123;NSLocalizedDescriptionKey : @<span class="string">&quot;Downloaded image has 0 pixels&quot;</span>&#125;]];</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                [<span class="keyword">self</span> callCompletionBlocksWithImage:image imageData:imageData error:<span class="literal">nil</span> finished:<span class="type">YES</span>];</span><br><span class="line">                            &#125;</span><br><span class="line">                            [<span class="keyword">self</span> done];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//......</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            [<span class="keyword">self</span> done];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下载完成后首先会对数据进行解密，然后再对解密后的数据进行解码，最后将数据通过block传递到业务层。<br>解密部分是通过<strong><strong>SDImageLoaderDecodeImageData</strong></strong>方法,这部分代码和上面介绍渐进式解码的类似，这里只注重流程，先不对这部分细节进行展开了。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">UIImage<span class="operator"> * </span>_Nullable <span class="constructor">SDImageLoaderDecodeImageData(NSData <span class="operator">*</span> <span class="params">_Nonnull</span> <span class="params">imageData</span>, NSURL <span class="operator">*</span> <span class="params">_Nonnull</span> <span class="params">imageURL</span>, SDWebImageOptions <span class="params">options</span>, SDWebImageContext <span class="operator">*</span> <span class="params">_Nullable</span> <span class="params">context</span>)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="comment">//调用解码器进行解码</span></span><br><span class="line">    <span class="keyword">if</span> (!image) &#123;</span><br><span class="line">        image = <span class="literal">[[SDI<span class="identifier">mageCodersManager</span> <span class="identifier">sharedManager</span>]</span> decodedImageWithData:imageData options:coderOptions];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (image) &#123;</span><br><span class="line">        BOOL shouldDecode = !<span class="constructor">SD_OPTIONS_CONTAINS(<span class="params">options</span>, SDWebImageAvoidDecodeImage)</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">[<span class="identifier">image</span>.<span class="identifier">class</span> <span class="identifier">conformsToProtocol</span>:@<span class="identifier">protocol</span>(SDA<span class="identifier">nimatedImage</span>)]</span>) &#123;</span><br><span class="line">            <span class="comment">// `SDAnimatedImage` do not decode</span></span><br><span class="line">            shouldDecode = NO;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (image.sd_isAnimated) &#123;</span><br><span class="line">            <span class="comment">// animated image do not decode</span></span><br><span class="line">            shouldDecode = NO;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (shouldDecode) &#123;</span><br><span class="line">            BOOL shouldScaleDown = <span class="constructor">SD_OPTIONS_CONTAINS(<span class="params">options</span>, SDWebImageScaleDownLargeImages)</span>;</span><br><span class="line">            <span class="keyword">if</span> (shouldScaleDown) &#123;</span><br><span class="line">                image = <span class="literal">[SDI<span class="identifier">mageCoderHelper</span> <span class="identifier">decodedAndScaledDownImageWithImage</span>:<span class="identifier">image</span> <span class="identifier">limitBytes</span>:<span class="number">0</span>]</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                image = <span class="literal">[SDI<span class="identifier">mageCoderHelper</span> <span class="identifier">decodedImageWithImage</span>:<span class="identifier">image</span>]</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return image;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到目前为止已经带大家过了一遍整个图片下载的流程，在解码结束后通过completeBlock交给上层后还没结束，我们看下completeBlock到底做了啥，让我们回到callDownloadProcessForOperation：</p>
<p>下面是completeBlock代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="meta">@strongify</span>(operation);</span><br><span class="line"><span class="comment">//用户取消请求</span></span><br><span class="line"><span class="keyword">if</span> (<span class="operator">!</span>operation <span class="operator">||</span> operation.isCancelled) &#123;</span><br><span class="line">    [<span class="keyword">self</span> callCompletionBlockForOperation:operation completion:completedBlock error:[<span class="type">NSError</span> errorWithDomain:<span class="type">SDWebImageErrorDomain</span> code:<span class="type">SDWebImageErrorCancelled</span> userInfo:<span class="literal">nil</span>] url:url];</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (cachedImage <span class="operator">&amp;&amp;</span> options <span class="operator">&amp;</span> <span class="type">SDWebImageRefreshCached</span> <span class="operator">&amp;&amp;</span> [error.domain isEqualToString:<span class="type">SDWebImageErrorDomain</span>] <span class="operator">&amp;&amp;</span> error.code <span class="operator">==</span> <span class="type">SDWebImageErrorCacheNotModified</span>) &#123;</span><br><span class="line">    <span class="comment">// 强制刷新缓存的时候，在前面先将缓存图片通过completeBlock 将数据传递给上层，到这里将数据加载完毕后，不做任何操作</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> ([error.domain isEqualToString:<span class="type">SDWebImageErrorDomain</span>] <span class="operator">&amp;&amp;</span> error.code <span class="operator">==</span> <span class="type">SDWebImageErrorCancelled</span>) &#123;</span><br><span class="line">    <span class="comment">// 将错误交给上层</span></span><br><span class="line">    [<span class="keyword">self</span> callCompletionBlockForOperation:operation completion:completedBlock error:error url:url];</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (error) &#123;</span><br><span class="line">    [<span class="keyword">self</span> callCompletionBlockForOperation:operation completion:completedBlock error:error url:url];</span><br><span class="line">    <span class="comment">//是否需要将错误的URL添加到failedURLs</span></span><br><span class="line">    <span class="type">BOOL</span> shouldBlockFailedURL <span class="operator">=</span> [<span class="keyword">self</span> shouldBlockFailedURLWithURL:url error:error];</span><br><span class="line">    <span class="keyword">if</span> (shouldBlockFailedURL) &#123;</span><br><span class="line">        <span class="type">SD_LOCK</span>(<span class="keyword">self</span>.failedURLsLock);</span><br><span class="line">        [<span class="keyword">self</span>.failedURLs addObject:url];</span><br><span class="line">        <span class="type">SD_UNLOCK</span>(<span class="keyword">self</span>.failedURLsLock);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 成功</span></span><br><span class="line">    <span class="comment">//如果SDWebImageRetryFailed = 1 表示错误的url需要重试，这时候就要将当前的url从failedURLs移除</span></span><br><span class="line">    <span class="keyword">if</span> ((options <span class="operator">&amp;</span> <span class="type">SDWebImageRetryFailed</span>)) &#123;</span><br><span class="line">        <span class="type">SD_LOCK</span>(<span class="keyword">self</span>.failedURLsLock);</span><br><span class="line">        [<span class="keyword">self</span>.failedURLs removeObject:url];</span><br><span class="line">        <span class="type">SD_UNLOCK</span>(<span class="keyword">self</span>.failedURLsLock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//成功后会对当前数据进行缓存</span></span><br><span class="line">    [<span class="keyword">self</span> callStoreCacheProcessForOperation:operation url:url options:options context:context downloadedImage:downloadedImage downloadedData:downloadedData finished:finished progress:progressBlock completed:completedBlock];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (finished) &#123;</span><br><span class="line">    <span class="comment">//加载成功后将操作从Running队列中移除</span></span><br><span class="line">    [<span class="keyword">self</span> safelyRemoveOperationFromRunning:operation];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>completeBlock里面有很多的情况会调到，比如NSOperation被取消，发生错误，成功等，下面我们只强调如下几种情况：</p>
<ul>
<li>下载失败的处理方式</li>
</ul>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">[<span class="built_in">self</span> callCompletionBlockForOperation:operation completion:completedBlock <span class="built_in">error</span>:<span class="built_in">error</span> url:url];</span><br><span class="line">//是否需要将错误的URL添加到failedURLs</span><br><span class="line">BOOL shouldBlockFailedURL = [<span class="built_in">self</span> shouldBlockFailedURLWithURL:url <span class="built_in">error</span>:<span class="built_in">error</span>];</span><br><span class="line"><span class="keyword">if</span> (shouldBlockFailedURL) &#123;</span><br><span class="line">    SD_LOCK(<span class="built_in">self</span>.failedURLsLock);</span><br><span class="line">    [<span class="built_in">self</span>.failedURLs addObject:url];</span><br><span class="line">    SD_UNLOCK(<span class="built_in">self</span>.failedURLsLock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果下载失败那么会将错误通过callCompletionBlockForOperation将错误返回给业务层，并且会将错误的url添加到failedURLs，如果我们配置不重试错误的url，那么在failedURLs数组中的url将不会发起请求。</p>
<ul>
<li>下载成功的处理方式</li>
</ul>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如果SDWebImageRetryFailed = 1 表示错误的url需要重试，这时候就要将当前的url从failedURLs移除</span></span><br><span class="line">if ((options &amp; SDWebImageRetryFailed)) &#123;</span><br><span class="line">    <span class="built_in">SD_LOCK</span>(self.failedURLsLock);</span><br><span class="line">    <span class="selector-attr">[self.failedURLs removeObject:url]</span>;</span><br><span class="line">    <span class="built_in">SD_UNLOCK</span>(self.failedURLsLock);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//成功后会对当前数据进行缓存</span></span><br><span class="line"><span class="selector-attr">[self callStoreCacheProcessForOperation:operation url:url options:options context:context downloadedImage:downloadedImage downloadedData:downloadedData finished:finished progress:progressBlock completed:completedBlock]</span>;</span><br></pre></td></tr></table></figure>

<p>和上面相反，如果下载成功后会将之前添加到failedURLs的url移除，然后调用callStoreCacheProcessForOperation将数据添加到缓存中。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)callStoreCacheProcessForOperation:(<span class="keyword">nonnull</span> SDWebImageCombinedOperation *)operation</span><br><span class="line">                                      url:(<span class="keyword">nonnull</span> <span class="built_in">NSURL</span> *)url</span><br><span class="line">                                  options:(SDWebImageOptions)options</span><br><span class="line">                                  context:(SDWebImageContext *)context</span><br><span class="line">                          downloadedImage:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)downloadedImage</span><br><span class="line">                           downloadedData:(<span class="keyword">nullable</span> <span class="built_in">NSData</span> *)downloadedData</span><br><span class="line">                                 finished:(<span class="type">BOOL</span>)finished</span><br><span class="line">                                 progress:(<span class="keyword">nullable</span> SDImageLoaderProgressBlock)progressBlock</span><br><span class="line">                                completed:(<span class="keyword">nullable</span> SDInternalCompletionBlock)completedBlock &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取缓存类型</span></span><br><span class="line">    SDImageCacheType storeCacheType = SDImageCacheTypeAll;</span><br><span class="line">    <span class="keyword">if</span> (context[SDWebImageContextStoreCacheType]) &#123;</span><br><span class="line">        storeCacheType = [context[SDWebImageContextStoreCacheType] integerValue];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    SDImageCacheType originalStoreCacheType = SDImageCacheTypeNone;</span><br><span class="line">    <span class="keyword">if</span> (context[SDWebImageContextOriginalStoreCacheType]) &#123;</span><br><span class="line">        originalStoreCacheType = [context[SDWebImageContextOriginalStoreCacheType] integerValue];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//生成缓存key</span></span><br><span class="line">    <span class="type">id</span>&lt;SDWebImageCacheKeyFilter&gt; cacheKeyFilter = context[SDWebImageContextCacheKeyFilter];</span><br><span class="line">    <span class="built_in">NSString</span> *key = [<span class="keyword">self</span> cacheKeyForURL:url cacheKeyFilter:cacheKeyFilter];</span><br><span class="line">    <span class="comment">//图片转换器</span></span><br><span class="line">    <span class="type">id</span>&lt;SDImageTransformer&gt; transformer = context[SDWebImageContextImageTransformer];</span><br><span class="line">    <span class="comment">//缓存图片处理器</span></span><br><span class="line">    <span class="type">id</span>&lt;SDWebImageCacheSerializer&gt; cacheSerializer = context[SDWebImageContextCacheSerializer];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//是否需要对图片进行处理</span></span><br><span class="line">    <span class="type">BOOL</span> shouldTransformImage = downloadedImage &amp;&amp; (!downloadedImage.sd_isAnimated || (options &amp; SDWebImageTransformAnimatedImage)) &amp;&amp; transformer;</span><br><span class="line">    <span class="comment">//是否缓存原始图片</span></span><br><span class="line">    <span class="type">BOOL</span> shouldCacheOriginal = downloadedImage &amp;&amp; finished;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//原图缓存</span></span><br><span class="line">    <span class="comment">//需要缓存原始图片的情况下</span></span><br><span class="line">    <span class="keyword">if</span> (shouldCacheOriginal) &#123;</span><br><span class="line">        <span class="comment">//正常情况下我们使用cache type，但是如果目标图片是转换过的，我们会使用original 存储缓存类型来缓存</span></span><br><span class="line">        SDImageCacheType targetStoreCacheType = shouldTransformImage ? originalStoreCacheType : storeCacheType;</span><br><span class="line">        <span class="keyword">if</span> (cacheSerializer &amp;&amp; (targetStoreCacheType == SDImageCacheTypeDisk || targetStoreCacheType == SDImageCacheTypeAll)) &#123;</span><br><span class="line">            <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, <span class="number">0</span>), ^&#123;</span><br><span class="line">                <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">                    <span class="comment">//将数据通过cacheSerializer处理后返回</span></span><br><span class="line">                    <span class="built_in">NSData</span> *cacheData = [cacheSerializer cacheDataWithImage:downloadedImage originalData:downloadedData imageURL:url];</span><br><span class="line">                    <span class="comment">//将数据添加到缓存中，具体缓存到哪里根据targetStoreCacheType类型</span></span><br><span class="line">                    [<span class="keyword">self</span>.imageCache storeImage:downloadedImage imageData:cacheData forKey:key cacheType:targetStoreCacheType completion:<span class="literal">nil</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            [<span class="keyword">self</span>.imageCache storeImage:downloadedImage imageData:downloadedData forKey:key cacheType:targetStoreCacheType completion:<span class="literal">nil</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 转换后图片缓存</span></span><br><span class="line">    <span class="keyword">if</span> (shouldTransformImage) &#123;</span><br><span class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, <span class="number">0</span>), ^&#123;</span><br><span class="line">            <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">                <span class="comment">//对数据进行转换</span></span><br><span class="line">                <span class="built_in">UIImage</span> *transformedImage = [transformer transformedImageWithImage:downloadedImage forKey:key];</span><br><span class="line">                <span class="keyword">if</span> (transformedImage &amp;&amp; finished) &#123;</span><br><span class="line">                    <span class="built_in">NSString</span> *transformerKey = [transformer transformerKey];</span><br><span class="line">                    <span class="comment">//缓存的图片带转换信息</span></span><br><span class="line">                    <span class="built_in">NSString</span> *cacheKey = SDTransformedKeyForKey(key, transformerKey);</span><br><span class="line">                    <span class="comment">//判断图片是否被转换成功</span></span><br><span class="line">                    <span class="type">BOOL</span> imageWasTransformed = ![transformedImage isEqual:downloadedImage];</span><br><span class="line">                    <span class="built_in">NSData</span> *cacheData;</span><br><span class="line">                    <span class="comment">// pass nil if the image was transformed, so we can recalculate the data from the image</span></span><br><span class="line">                    <span class="keyword">if</span> (cacheSerializer &amp;&amp; (storeCacheType == SDImageCacheTypeDisk || storeCacheType == SDImageCacheTypeAll)) &#123;</span><br><span class="line">                        <span class="comment">//将数据通过cacheSerializer处理后返回</span></span><br><span class="line">                        cacheData = [cacheSerializer cacheDataWithImage:transformedImage  originalData:(imageWasTransformed ? <span class="literal">nil</span> : downloadedData) imageURL:url];</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        cacheData = (imageWasTransformed ? <span class="literal">nil</span> : downloadedData);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//缓存图片数据</span></span><br><span class="line">                    [<span class="keyword">self</span>.imageCache storeImage:transformedImage imageData:cacheData forKey:cacheKey cacheType:storeCacheType completion:<span class="literal">nil</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//将结果传递到业务层</span></span><br><span class="line">                [<span class="keyword">self</span> callCompletionBlockForOperation:operation completion:completedBlock image:transformedImage data:downloadedData error:<span class="literal">nil</span> cacheType:SDImageCacheTypeNone finished:finished url:url];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        [<span class="keyword">self</span> callCompletionBlockForOperation:operation completion:completedBlock image:downloadedImage data:downloadedData error:<span class="literal">nil</span> cacheType:SDImageCacheTypeNone finished:finished url:url];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="2-3-设置图片"><a href="#2-3-设置图片" class="headerlink" title="2.3 设置图片"></a>2.3 设置图片</h6><p>设置图片环节比较简单就是根据view的类型来设置对应的finalSetImageBlock，然后看是否有过场动画，如果有则播放过场动画后执行finalSetImageBlock。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)sd_setImage:(<span class="built_in">UIImage</span> *)image imageData:(<span class="built_in">NSData</span> *)imageData basedOnClassOrViaCustomSetImageBlock:(SDSetImageBlock)setImageBlock transition:(SDWebImageTransition *)transition cacheType:(SDImageCacheType)cacheType imageURL:(<span class="built_in">NSURL</span> *)imageURL &#123;</span><br><span class="line">    <span class="comment">// 根据view的类型来设置对应的finalSetImageBlock</span></span><br><span class="line">    <span class="built_in">UIView</span> *view = <span class="keyword">self</span>;</span><br><span class="line">    SDSetImageBlock finalSetImageBlock;</span><br><span class="line">    <span class="keyword">if</span> (setImageBlock) &#123;</span><br><span class="line">        finalSetImageBlock = setImageBlock;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([view isKindOfClass:[<span class="built_in">UIImageView</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="built_in">UIImageView</span> *imageView = (<span class="built_in">UIImageView</span> *)view;</span><br><span class="line">        finalSetImageBlock = ^(<span class="built_in">UIImage</span> *setImage, <span class="built_in">NSData</span> *setImageData, SDImageCacheType setCacheType, <span class="built_in">NSURL</span> *setImageURL) &#123;</span><br><span class="line">            imageView.image = setImage;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ([view isKindOfClass:[<span class="built_in">UIButton</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="built_in">UIButton</span> *button = (<span class="built_in">UIButton</span> *)view;</span><br><span class="line">        finalSetImageBlock = ^(<span class="built_in">UIImage</span> *setImage, <span class="built_in">NSData</span> *setImageData, SDImageCacheType setCacheType, <span class="built_in">NSURL</span> *setImageURL) &#123;</span><br><span class="line">            [button setImage:setImage forState:<span class="built_in">UIControlStateNormal</span>];</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//播放过场动画</span></span><br><span class="line">    <span class="keyword">if</span> (transition) &#123;</span><br><span class="line">        [<span class="built_in">UIView</span> transitionWithView:view duration:<span class="number">0</span> options:<span class="number">0</span> animations:^&#123;</span><br><span class="line">            <span class="comment">// 0 duration to let UIKit render placeholder and prepares block</span></span><br><span class="line">            <span class="keyword">if</span> (transition.prepares) &#123;</span><br><span class="line">                transition.prepares(view, image, imageData, cacheType, imageURL);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; completion:^(<span class="type">BOOL</span> finished) &#123;</span><br><span class="line">            [<span class="built_in">UIView</span> transitionWithView:view duration:transition.duration options:transition.animationOptions animations:^&#123;</span><br><span class="line">                <span class="keyword">if</span> (finalSetImageBlock &amp;&amp; !transition.avoidAutoSetImage) &#123;</span><br><span class="line">                    <span class="comment">//执行finalSetImageBlock</span></span><br><span class="line">                    finalSetImageBlock(image, imageData, cacheType, imageURL);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (transition.animations) &#123;</span><br><span class="line">                    transition.animations(view, image);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; completion:transition.completion];</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果没有过场动画直接执行finalSetImageBlock</span></span><br><span class="line">        <span class="keyword">if</span> (finalSetImageBlock) &#123;</span><br><span class="line">            finalSetImageBlock(image, imageData, cacheType, imageURL);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简要流程如下图所示：<br><img src="/2019/11/30/SDWebImage-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/00006.png"></p>
<h6 id="2-4-整体架构总结"><a href="#2-4-整体架构总结" class="headerlink" title="2.4 整体架构总结"></a>2.4 整体架构总结</h6><p>上面几个章节我们将整个流程过了一遍，接下来我们将会从宏观的角度来浏览下整个架构，整个SDWebImage代码量还是蛮庞大的，所以如果没有缕清整个结构的话很容易陷入代码之中，SDWebImage之所以大主要是因为它整个架构可定制的部件多，并且每个部件都可以有不同的选择，这种框架最适合采用Core+Plugin形式，SDWebImage 有个不足的地方就是代码的目录管理做得不好，整个庞大的项目都堆到一个目录下，让刚接触SDWebImage会显得毫无头绪，下面是重新组织的目录结构：</p>
<p><img src="/2019/11/30/SDWebImage-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/00003.png"></p>
<p>下面是SDWebImage官方的架构图，以及关键的类图：</p>
<p><img src="/2019/11/30/SDWebImage-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/00002.jpeg"><br><img src="/2019/11/30/SDWebImage-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/00004.png"><br><img src="/2019/11/30/SDWebImage-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/00005.png"></p>
<p>下面我们结合上面三张图来过一遍整个项目：</p>
<p><strong><strong>1. 常用控件的分类</strong></strong><br>SDWebImage为UIImageView,NSButton,SDAnimatedImageView这些类都创建了对应都分类，方便这些类加载网络图片资源，大家可以通过搜索+WebCache或者+HightlightedWebCache可以找到这些分类。这些分类中除了提供设置网络图片的方法外，还提供了设置下载指示器，以及图片转换处理器等方法。<strong><strong>UIView+WebCache.h</strong></strong>是这些分类的基础。</p>
<p><strong><strong>2. 图片预取器</strong></strong></p>
<p><strong><strong>SDWebImagePrefetcher</strong></strong> 用于图片的预取：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">nullable</span> SDWebImagePrefetchToken *)prefetchURLs:(<span class="keyword">nullable</span> <span class="built_in">NSArray</span>&lt;<span class="built_in">NSURL</span> *&gt; *)urls;</span><br></pre></td></tr></table></figure>
<p>这个是专门供外部使用的，SDWebImageView内部并没有使用到这个类.图片预取顾名思义就是在没使用图片之前就先将图片给下载到缓存中，这样使用的时候加载速度就会块很多，这一般是针对比较常用的图片资源。<strong><strong>SDWebImagePrefetcherDelegate</strong></strong> 会在全部下载结束后，或者单个资源下载完成后进行回调。</p>
<p><strong><strong>3. 图片管理器</strong></strong></p>
<p><img src="/2019/11/30/SDWebImage-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/00007.png"></p>
<p><strong><strong>SDWebImageManager</strong></strong>是整个SDWebImage的核心它持有：</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="bullet">* </span>imageLoader（遵循SDImageLoader）用于从网络上加载图片</span><br><span class="line"><span class="bullet">* </span>mageCache（遵循SDImageCache）用于从缓存中获取图片</span><br><span class="line"><span class="bullet">* </span>cacheKeyFilter（遵循SDWebImageCacheKeyFilter）用于缓存key的生成</span><br><span class="line"><span class="bullet">* </span>cacheSerializer（遵循SDWebImageCacheSerializer）用于对解码后的图片数据进行序列化</span><br><span class="line"><span class="bullet">* </span>transformer（遵循SDImageTransformer）用于图片后期处理</span><br><span class="line"><span class="bullet">* </span>optionsProcessor（遵循SDWebImageOptionsProcessor）用于提供全局的option设置。</span><br></pre></td></tr></table></figure>

<p>它通过：</p>
<figure class="highlight erlang"><table><tr><td class="code"><pre><span class="line">- <span class="params">(nullable SDWebImageCombinedOperation *)</span>loadImageWithURL:<span class="params">(nullable NSURL *)</span>url</span><br><span class="line">                                                   options:<span class="params">(SDWebImageOptions)</span>options</span><br><span class="line">                                                   context:<span class="params">(nullable SDWebImageContext *)</span>context</span><br><span class="line">                                                  progress:<span class="params">(nullable SDImageLoaderProgressBlock)</span>progressBlock</span><br><span class="line">                                                 completed:<span class="params">(nonnull SDInternalCompletionBlock)</span>completedBlock;</span><br></pre></td></tr></table></figure>
<p>加载图片，这里面包含了全部的加载策略，是整个库的核心</p>
<p>还提供了取消下载的接口：</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">- (void)cancelAll<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>以及查询key的接口:</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)cacheKeyForURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url;</span><br></pre></td></tr></table></figure>

<p>代理<strong><strong>SDWebImageManagerDelegate</strong></strong></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">用于判断某个URL是否需要下载</span><br><span class="line">- (<span class="type">BOOL</span>)imageManager:(<span class="keyword">nonnull</span> SDWebImageManager *)imageManager shouldDownloadImageForURL:(<span class="keyword">nonnull</span> <span class="built_in">NSURL</span> *)imageURL;</span><br><span class="line">用于判断某个URL发生某个错误是否将其标记为失败的URL</span><br><span class="line">- (<span class="type">BOOL</span>)imageManager:(<span class="keyword">nonnull</span> SDWebImageManager *)imageManager shouldBlockFailedURL:(<span class="keyword">nonnull</span> <span class="built_in">NSURL</span> *)imageURL withError:(<span class="keyword">nonnull</span> <span class="built_in">NSError</span> *)error;</span><br></pre></td></tr></table></figure>

<p><strong><strong>3.1 图片转换器</strong></strong></p>
<p>图片转换器是存放在context中的，key为<strong><strong>SDWebImageContextImageTransformer</strong></strong>，与图片转换器有关的文件如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">UIImage+Transform.h/.m</span><br><span class="line">SDImageTransformer.h/.m</span><br></pre></td></tr></table></figure>

<p>UIImage+Transform主要是图片转换的实际处理分类，而SDImageTransformer则是负责上层调度的，它会调度UIImage+Transform中的方法对图片进行处理。</p>
<p>我们看下SDWebImage都提供了哪些图片转换器：</p>
<p><strong><strong>SDImagePipelineTransformer 串行流水线图片处理器</strong></strong><br>之前一直有疑问，context中只能存放一个图片处理器，如果我们需要连续应用多个处理呢？这个对图片库来说是很常见的一个功能，SDImagePipelineTransformer就是用于这种用途，我们只要将所有的处理器添加到transformers数组中就会被应用到当前图片上。<br><strong><strong>SDImageRoundCornerTransformer 图片圆角处理器</strong></strong><br>可以指定圆角半径，边界线宽，边界线颜色，圆角位置<br><strong><strong>SDImageResizingTransformer 缩放处理器</strong></strong><br><strong><strong>SDImageCroppingTransformer 裁剪处理器</strong></strong><br><strong><strong>SDImageFlippingTransformer 翻转处理器</strong></strong><br><strong><strong>SDImageRotationTransformer 旋转处理器</strong></strong><br><strong><strong>SDImageTintTransformer     颜色修改处理器</strong></strong><br><strong><strong>SDImageBlurTransformer     模糊处理器</strong></strong><br><strong><strong>SDImageFilterTransformer   滤镜处理器</strong></strong> </p>
<p><strong><strong>3.2 图片加载器</strong></strong></p>
<p>涉及到的类主要有：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">SDImageLoader.h/.m</span><br><span class="line">SDImageLoadersManager.h/.m</span><br></pre></td></tr></table></figure>

<p>SDImageLoader里面主要定义了两个解码相关的静态方法<strong><strong>SDImageLoaderDecodeImageData</strong></strong>，<strong><strong>SDImageLoaderDecodeProgressiveImageData</strong></strong>，以及SDImageLoader协议。而SDImageLoadersManager则负责管理全部的loader，每个SDWebImageManager都只有一个SDImageLoadersManager，但是SDImageLoadersManager里面却管理着一系列的SDImageLoader，所以整个SDWebImage相当于由多个loader构成。<br>我们这里看下SDImageLoader</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断当前url是否需要下载</span></span><br><span class="line">- (<span class="type">BOOL</span>)canRequestImageForURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url;</span><br><span class="line"></span><br><span class="line"><span class="comment">//请求图片下载</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="type">id</span>&lt;SDWebImageOperation&gt;)requestImageWithURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url</span><br><span class="line">                                                options:(SDWebImageOptions)options</span><br><span class="line">                                                context:(<span class="keyword">nullable</span> SDWebImageContext *)context</span><br><span class="line">                                               progress:(<span class="keyword">nullable</span> SDImageLoaderProgressBlock)progressBlock</span><br><span class="line">                                              completed:(<span class="keyword">nullable</span> SDImageLoaderCompletedBlock)completedBlock;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断某个URL发生某个错误的时候是否需要将它判定为失败的url</span></span><br><span class="line">- (<span class="type">BOOL</span>)shouldBlockFailedURLWithURL:(<span class="keyword">nonnull</span> <span class="built_in">NSURL</span> *)url</span><br><span class="line">                              error:(<span class="keyword">nonnull</span> <span class="built_in">NSError</span> *)error;</span><br></pre></td></tr></table></figure>

<p><strong><strong>3.2.1 图片下载器</strong></strong></p>
<p><img src="/2019/11/30/SDWebImage-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/00009.png"></p>
<p>我们知道iOS中图片的下载使用的还是URLSession,而这里的图片下载器就是通过URLSession进行下载的，这个在上面介绍流程源码的时候已经介绍过了，下面将从宏观的角度对这些类进行分析，整个下载器的组成，这里不追究细节。</p>
<p><strong><strong>SDWebImageDownloaderOptions</strong></strong><br>下载全局选项<br><strong><strong>SDWebImageDownloadToken</strong></strong><br>用于指示某个下载的Token,包括url，request，response，以及取消的方法，在启动下载的时候会返回一个DownloadToken，用它可以进行取消任务。<br><strong><strong>SDWebImageDownloaderConfig</strong></strong><br>下载器配置类，包括：</p>
<ul>
<li>最大并发数，默认为6</li>
<li>下载超时时间，默认为15秒</li>
<li>最小进度间隔，指的是上一次进度和本次进度的差值不能小于这个数，如果小于这个数就不通知进度更新</li>
<li>operationClass 下载指定的NSOperation具体实现类</li>
<li>executionOrder operations执行顺序，默认是先入先出</li>
<li>认证需要的username，password</li>
<li>sessionConfiguration</li>
</ul>
<p><strong><strong>SDWebImageDownloaderRequestModifier</strong></strong><br>全局请求拦截修改器，如果返回nil表示某个请求将会被取消，如果requestModifier &#x3D; nil 表示不修改原始的下载请求。<br><strong><strong>SDWebImageDownloaderResponseModifier</strong></strong><br>全局返回体拦截修改器，如果返回nil表示当前下载被取消，如果responseModifier &#x3D; nil 表示不修改原始返回体<br><strong><strong>SDWebImageDownloaderDecryptor</strong></strong><br>解密器，它会在图片解码之前对某些加密的图片进行解密，比如某些图片会进行Base64加密，这时候就需要使用解密器进行解密，如果返回nil表示下载失败<br><strong><strong>SDWebImageDownloaderOperation</strong></strong></p>
<p>除了上面的几个重要类外，还具备了下载器状态查询接口&#x2F;属性：suspended是否暂停下载，当前下载数currentDownloadCount。</p>
<p>以及下载，取消下载接口：</p>
<figure class="highlight erlang"><table><tr><td class="code"><pre><span class="line">- <span class="params">(nullable SDWebImageDownloadToken *)</span>downloadImageWithURL:<span class="params">(nullable NSURL *)</span>url</span><br><span class="line">                                                   options:<span class="params">(SDWebImageDownloaderOptions)</span>options</span><br><span class="line">                                                   context:<span class="params">(nullable SDWebImageContext *)</span>context</span><br><span class="line">                                                  progress:<span class="params">(nullable SDWebImageDownloaderProgressBlock)</span>progressBlock</span><br><span class="line">                                                 completed:<span class="params">(nullable SDWebImageDownloaderCompletedBlock)</span>completedBlock;</span><br><span class="line"></span><br><span class="line">- <span class="params">(void)</span>cancelAllDownloads;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong><strong>SDWebImageDownloaderOperation</strong></strong><br>SDWebImageDownloaderOperation是这里的重头戏，它的输入是NSURLRequest，NSURLSession，SDWebImageDownloaderOptions，SDWebImageContext。<br>NSURLRequest，NSURLSession不用多说它是用于创建NSURLSessionTask，SDWebImageDownloaderOptions是用于下载的配置选项，SDWebImageContext用于存放重要组件。</p>
<p>下面是一些比较重要的属性：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">//请求体</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">nullable</span>) <span class="built_in">NSURLRequest</span> *request; </span><br><span class="line"><span class="comment">//返回体</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">nullable</span>) <span class="built_in">NSURLResponse</span> *response;</span><br><span class="line"><span class="comment">//返回异常</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nullable</span>) <span class="built_in">NSError</span> *responseError;</span><br><span class="line"><span class="comment">//执行下载请求的dataTask</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">nullable</span>) <span class="built_in">NSURLSessionTask</span> *dataTask;</span><br><span class="line"><span class="comment">//urlsession</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nullable</span>) <span class="built_in">NSURLSession</span> *unownedSession;</span><br><span class="line"><span class="comment">//包括进度更新block以及completeblock</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nonnull</span>) <span class="built_in">NSMutableArray</span>&lt;SDCallbacksDictionary *&gt; *callbackBlocks;</span><br><span class="line"><span class="comment">//下载选项</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readwrite</span>) SDWebImageDownloaderOptions options;</span><br><span class="line"><span class="comment">//重要部件上下文</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">copy</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readwrite</span>, <span class="keyword">nullable</span>) SDWebImageContext *context;</span><br><span class="line"><span class="comment">//图片数据</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nullable</span>) <span class="built_in">NSMutableData</span> *imageData;</span><br><span class="line"><span class="comment">//收发数据大小</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSUInteger</span> expectedSize; </span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSUInteger</span> receivedSize;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="type">double</span> previousProgress;</span><br><span class="line"><span class="comment">//code队列</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nonnull</span>) <span class="built_in">dispatch_queue_t</span> coderQueue;</span><br><span class="line"><span class="comment">//当前NSOperation状态</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>, <span class="keyword">getter</span> = isExecuting) <span class="type">BOOL</span> executing;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>, <span class="keyword">getter</span> = isFinished) <span class="type">BOOL</span> finished;</span><br><span class="line"><span class="comment">//返回体修改器</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nullable</span>) <span class="type">id</span>&lt;SDWebImageDownloaderResponseModifier&gt; responseModifier; </span><br><span class="line"><span class="comment">//解密器</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nullable</span>) <span class="type">id</span>&lt;SDWebImageDownloaderDecryptor&gt; decryptor;</span><br></pre></td></tr></table></figure>

<p><strong><strong>3.3 图片下载缓存</strong></strong></p>
<p><img src="/2019/11/30/SDWebImage-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/000010.png"></p>
<p><strong><strong>SDImageCache</strong></strong><br>SDImageCache是管理图片下载缓存的类，最初的时候个人以为是SDImageCachesManager管理全部的缓存，但是实际上是这货，并且SDImageCachesManager从源码上看并没有实际的用途。我们先来看下SDImageCache，它的重要元素包含：<br>缓存配置：SDImageCacheConfig<br>内存缓存：memoryCache<br>磁盘缓存：diskCache，磁盘缓存根路径 diskCachePath</p>
<p><strong><strong>SDMemoryCache</strong></strong></p>
<p>基于NSCache的内存缓存，主要对象包括缓存配置<strong><strong>SDImageCacheConfig</strong></strong>，以及缓存对象的增删改查。</p>
<p><strong><strong>SDDiskCache</strong></strong><br>基于文件的内存缓存，主要对象包括缓存配置<strong><strong>SDImageCacheConfig</strong></strong>，以及缓存对象的增删改查。</p>
<p><strong><strong>SDWebImageCacheKeyFilter</strong></strong></p>
<p>全局根据url映射到缓存key的类。</p>
<p><strong><strong>SDWebImageCacheSerializer</strong></strong></p>
<p>在缓存之前对图像数据进行处理</p>
<p><strong><strong>SDImageCacheConfig</strong></strong><br><strong><strong>SDImageCacheOptions</strong></strong></p>
<p>缓存配置</p>
<p><strong><strong>SDImageCacheDefine</strong></strong></p>
<p>缓存模块相关的定义</p>
<p><strong><strong>SDImageCachesManager</strong></strong></p>
<p>用于管理缓存的管理器，但是目前在项目中没有使用</p>
<p><strong><strong>SDImageCachesManagerOperation</strong></strong><br>用在SDImageCachesManager也是一个NSOperation</p>
<p>同时需要强调的是SDWebImage支持以插件的形式加入YYImage以及YYCache.具体见：<a target="_blank" rel="noopener" href="https://github.com/SDWebImage/SDWebImageYYPlugin">SDWebImageYYPlugin</a><br>后面也会对这个开源库进行分析。</p>
<p><strong><strong>3.4 图片编解码器</strong></strong></p>
<p><img src="/2019/11/30/SDWebImage-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/00008.png"></p>
<p><strong><strong>SDImageCodersManager</strong></strong></p>
<p>SDImageCodersManager 顾名思义就是用于全局得管理编解码器，后面添加的编解码器有最高的优先级</p>
<p><strong><strong>SDImageCoderOption</strong></strong><br>解码器配置选项</p>
<p><strong><strong>SDImageCoder&#x2F;SDProgressiveImageCoder</strong></strong></p>
<p>SDImageCoder 是一个比较重要的协议，是所有编解码器都需要遵循的协议：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">SDImageCoder</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@required</span></span><br><span class="line"><span class="comment">//给定的数据能否被当前编解码器解码</span></span><br><span class="line">- (<span class="type">BOOL</span>)canDecodeFromData:(<span class="keyword">nullable</span> <span class="built_in">NSData</span> *)data;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用当前解码器对图像数据进行解码</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)decodedImageWithData:(<span class="keyword">nullable</span> <span class="built_in">NSData</span> *)data</span><br><span class="line">                                   options:(<span class="keyword">nullable</span> SDImageCoderOptions *)options;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> mark - Encoding</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//当前编解码器是否能够编码到指定的格式</span></span><br><span class="line">- (<span class="type">BOOL</span>)canEncodeToFormat:(SDImageFormat)format <span class="built_in">NS_SWIFT_NAME</span>(canEncode(to:));</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用当前编码器对图像数据进行编码</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSData</span> *)encodedDataWithImage:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)image</span><br><span class="line">                                   format:(SDImageFormat)format</span><br><span class="line">                                  options:(<span class="keyword">nullable</span> SDImageCoderOptions *)options;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">SDProgressiveImageCoder</span> &lt;<span class="title">SDImageCoder</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@required</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//是否能够渐进解码</span></span><br><span class="line">- (<span class="type">BOOL</span>)canIncrementalDecodeFromData:(<span class="keyword">nullable</span> <span class="built_in">NSData</span> *)data;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">nonnull</span> <span class="keyword">instancetype</span>)initIncrementalWithOptions:(<span class="keyword">nullable</span> SDImageCoderOptions *)options;</span><br><span class="line"></span><br><span class="line"><span class="comment">//更新增量图片数据</span></span><br><span class="line">- (<span class="type">void</span>)updateIncrementalData:(<span class="keyword">nullable</span> <span class="built_in">NSData</span> *)data finished:(<span class="type">BOOL</span>)finished;</span><br><span class="line"></span><br><span class="line"><span class="comment">//进行渐进式解码</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)incrementalDecodedImageWithOptions:(<span class="keyword">nullable</span> SDImageCoderOptions *)options;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><strong><strong>SDAnimatedImageProvider</strong></strong><br>用于提供基本动图所需要遵循的协议，目前SDAnimatedImage以及SDAnimatedImageCoder会遵循这个协议。</p>
<p><strong><strong>SDImageIOCoder</strong></strong></p>
<p>用于对PNG, JPEG, TIFF 这些格式进行编解码，它也支持GIF以及HEIC这些动图格式，但是GIF只支持第一帧，HEIC需要看各个系统的支持情况。对于这些动图建议使用SDAnimatedImageView</p>
<p><strong><strong>SDAnimatedImageCoder</strong></strong><br>SDAnimatedImageCoder是所有动图编解码器的基类，下面将要介绍的SDImageAPNGCoder，SDImageGIFCoder，SDImageHEICCoder都是这个类的子类。</p>
<p><strong><strong>SDImageAPNGCoder</strong></strong><br>APNG动画格式编解码器，关于APNG格式介绍，大家可以查看如下文章：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://aotu.io/notes/2016/11/07/apng/index.html">APNG 那些事</a></li>
<li><a target="_blank" rel="noopener" href="http://littlesvr.ca/apng/gif_apng_webp.html">GIF vs APNG vs WebP</a></li>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/27201109">APNG相对于GIF有哪些优势</a><br><strong><strong>SDImageGIFCoder</strong></strong><br>这个就不做介绍了GIF格式的编解码器<br><strong><strong>SDImageHEICCoder</strong></strong></li>
<li><a target="_blank" rel="noopener" href="https://www.hack520.com/788.html">HEIC格式介绍</a></li>
</ul>
<p><strong><strong>SDImageCoderHelper</strong></strong><br>SDImageCoderHelper是上层编解码器的公共方法类。</p>
<p><strong><strong>3.5 动图相关类</strong></strong></p>
<p><strong><strong>SDAnimatedImage</strong></strong><br>SDAnimatedImage 为动图数据类和UIImage对应<br><strong><strong>SDAnimatedImageView</strong></strong><br>SDAnimatedImageView 为动图显示View和UIImageView类对应，内部持有SDAnimatedImagePlayer<br><strong><strong>SDAnimatedImagePlayer</strong></strong><br>SDAnimatedImagePlayer 用于播放动画<br><strong><strong>SDWebImageTransition</strong></strong><br>SDWebImageTransition为图片加载结束后呈现图片时候使用的转场动画，目前支持fadeTransition，flipFromLeftTransition，flipFromRightTransition，flipFromTopTransition，flipFromBottomTransition，curlUpTransition，curlDownTransition几种。</p>
<p>****3.6 SDWebImageOptionsProcessor ****</p>
<p>全局Options处理器，用于针对所有的Options设置进行过滤处理。</p>
<p>****3.7 SDWebImageIndicator ****</p>
<p>进度指示器，目前主要支持两种：SDWebImageActivityIndicator和SDWebImageProgressIndicator</p>
  
	</div>
		<footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/iOS-%E5%BC%80%E6%BA%90%E5%BA%93%E5%88%86%E6%9E%90/">iOS 开源库分析</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/iOS-开源库分析/">iOS 开源库分析</a>
  </div>

</div>



</footer>

   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2019/11/30/AFNetWorking源码解析/" title="AFNetWorking源码解析">
  <span>
  AFNetWorking源码解析</span>
</a>
</div>


<div class="next">
<a href="/2019/11/28/YTKNetWork源码解析/"  title="YTKNetWork源码解析">
 <span>YTKNetWork源码解析
</span>
</a>
</div>

</nav>

	
<section id="comments" class="comment">
	<div class="ds-thread" data-thread-key="2019/11/30/SDWebImage-源码解析/" data-title="SDWebImage 源码解析" data-url="http://yoursite.com/2019/11/30/SDWebImage-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"></div>
</section>


<section id="comments" class="comment">
  <div id="disqus_thread">
    <noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  </div>
</section>

</div>  
      <div class="openaside"><a class="navbutton" href="#" title="Show Sidebar"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">Contents</strong>
 
 <ol class="toc"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%BC%80%E6%BA%90%E4%BB%A3%E7%A0%81%E4%BF%A1%E6%81%AF"><span class="toc-number">1.</span> <span class="toc-text">1. 开源代码信息</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90"><span class="toc-number">2.</span> <span class="toc-text">2. 源码解析</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#2-1-%E6%80%BB%E5%85%A5%E5%8F%A3"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 总入口</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-2-%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 图片加载</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-2-1-%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98%E8%BF%98%E6%98%AF%E4%BB%8E%E7%BD%91%E7%BB%9C%E4%B8%8B%E8%BD%BD"><span class="toc-number">2.3.</span> <span class="toc-text">2.2.1 查询缓存还是从网络下载</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-2-1-1-%E4%BD%BF%E7%94%A8%E7%BC%93%E5%AD%98%E8%B5%84%E6%BA%90"><span class="toc-number">2.4.</span> <span class="toc-text">2.2.1.1 使用缓存资源</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-2-1-2-%E4%BD%BF%E7%94%A8%E7%BD%91%E7%BB%9C%E8%B5%84%E6%BA%90"><span class="toc-number">2.5.</span> <span class="toc-text">2.2.1.2 使用网络资源</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-3-%E8%AE%BE%E7%BD%AE%E5%9B%BE%E7%89%87"><span class="toc-number">2.6.</span> <span class="toc-text">2.3 设置图片</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-4-%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84%E6%80%BB%E7%BB%93"><span class="toc-number">2.7.</span> <span class="toc-text">2.4 整体架构总结</span></a></li></ol></li></ol>
 
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="Hide Sidebar"></a></div>
<aside class="clearfix">
<div id="authorInfo">
	
		<div class="author-img"></div>		
	
	<div class="social-info" class="clearfix">
		
		
		<a href="https://github.com/tbfungeek" target="_blank" class="icon-github" title="github"></a>
		
		
		
		
		
		
		
		
		
		
		<a href="mailto:tbfungeek@163.com" target="_blank" class="icon-email" title="Email Me"></a>
		

	</div>
</div>

  
<div class="categorieslist">
	<p class="asidetitle">Categories</p>
		<ul>
		
		  
			<li><a href="/categories/Android-小经验/" title="Android 小经验">Android 小经验<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Android-源码分析/" title="Android 源码分析">Android 源码分析<sup>21</sup></a></li>
		  
		
		  
			<li><a href="/categories/Android其他/" title="Android其他">Android其他<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Android初步/" title="Android初步">Android初步<sup>21</sup></a></li>
		  
		
		  
			<li><a href="/categories/Android进阶/" title="Android进阶">Android进阶<sup>100</sup></a></li>
		  
		
		  
			<li><a href="/categories/Hexo-使用/" title="Hexo 使用">Hexo 使用<sup>10</sup></a></li>
		  
		
		  
			<li><a href="/categories/JavaScript理论/" title="JavaScript理论">JavaScript理论<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Objective-C-相关/" title="Objective C 相关">Objective C 相关<sup>24</sup></a></li>
		  
		
		  
			<li><a href="/categories/OpenCV/" title="OpenCV">OpenCV<sup>6</sup></a></li>
		  
		
		  
			<li><a href="/categories/ROS/" title="ROS">ROS<sup>9</sup></a></li>
		  
		
		  
			<li><a href="/categories/iOS-工具使用/" title="iOS 工具使用">iOS 工具使用<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/iOS-开源库分析/" title="iOS 开源库分析">iOS 开源库分析<sup>36</sup></a></li>
		  
		
		  
			<li><a href="/categories/iOS-理论基础/" title="iOS 理论基础">iOS 理论基础<sup>14</sup></a></li>
		  
		
		  
			<li><a href="/categories/iOS-进阶/" title="iOS 进阶">iOS 进阶<sup>4</sup></a></li>
		  
		
		  
			<li><a href="/categories/个人收藏/" title="个人收藏">个人收藏<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/代码规范/" title="代码规范">代码规范<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/其他/" title="其他">其他<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/博客分类目录/" title="博客分类目录">博客分类目录<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/叨叨系列/" title="叨叨系列">叨叨系列<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/开源代码分析/" title="开源代码分析">开源代码分析<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/开源库分析/" title="开源库分析">开源库分析<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/树莓派/" title="树莓派">树莓派<sup>4</sup></a></li>
		  
		
		  
			<li><a href="/categories/版本控制/" title="版本控制">版本控制<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/直播/" title="直播">直播<sup>6</sup></a></li>
		  
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">Tags</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/iOS-开源库分析/" title="iOS 开源库分析">iOS 开源库分析<sup>36</sup></a></li>
			
		
			
				<li><a href="/tags/Android-设计模式/" title="Android 设计模式">Android 设计模式<sup>29</sup></a></li>
			
		
			
				<li><a href="/tags/Objective-C-相关/" title="Objective C 相关">Objective C 相关<sup>24</sup></a></li>
			
		
			
				<li><a href="/tags/Android基础/" title="Android基础">Android基础<sup>21</sup></a></li>
			
		
			
				<li><a href="/tags/AOSP-源码/" title="AOSP 源码">AOSP 源码<sup>17</sup></a></li>
			
		
			
				<li><a href="/tags/Android-常用第三方库/" title="Android 常用第三方库">Android 常用第三方库<sup>15</sup></a></li>
			
		
			
				<li><a href="/tags/iOS-理论基础/" title="iOS 理论基础">iOS 理论基础<sup>14</sup></a></li>
			
		
			
				<li><a href="/tags/Hexo-使用/" title="Hexo 使用">Hexo 使用<sup>10</sup></a></li>
			
		
			
				<li><a href="/tags/ROS/" title="ROS">ROS<sup>9</sup></a></li>
			
		
			
				<li><a href="/tags/Android-动画进阶/" title="Android 动画进阶">Android 动画进阶<sup>8</sup></a></li>
			
		
			
				<li><a href="/tags/Android-JNI/" title="Android JNI">Android JNI<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/Android-绘图进阶/" title="Android 绘图进阶">Android 绘图进阶<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/Android性能优化/" title="Android性能优化">Android性能优化<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/Android-自动化测试/" title="Android 自动化测试">Android 自动化测试<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/OpenCV/" title="OpenCV">OpenCV<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/直播/" title="直播">直播<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/Android-开源源码/" title="Android 开源源码">Android 开源源码<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/Android-自定义View进阶/" title="Android 自定义View进阶">Android 自定义View进阶<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/树莓派/" title="树莓派">树莓派<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/iOS-进阶/" title="iOS 进阶">iOS 进阶<sup>4</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">Links</p>
    <ul>
        
          <li>
            
            	<a href="https://hexo.io" target="_blank" title="Hexo">Hexo</a>
            
          </li>
        
          <li>
            
            	<a href="https://pages.github.com/" target="_blank" title="GitHub">GitHub</a>
            
          </li>
        
          <li>
            
            	<a href="http://pf18.github.io/" target="_blank" title="PF18">PF18</a>
            
          </li>
        
          <li>
            
            	<a href="http://toutiao.io/" target="_blank" title="开发者头条">开发者头条</a>
            
          </li>
        
          <li>
            
            	<a href="http://www.jcodecraeer.com/" target="_blank" title="泡在网上的日子">泡在网上的日子</a>
            
          </li>
        
    </ul>
</div>

  


  <div class="rsspart">
	<a href="atom.xml" target="_blank" title="rss">RSS</a>
</div>

  
  <div class="tagcloudlist">
    <p class="asidetitle">Tag Cloud</p>
    <div class="tagcloudlist clearfix">
       <a href="/tags/AOSP-%E6%BA%90%E7%A0%81/" style="font-size: 17.14px;">AOSP 源码</a> <a href="/tags/Android-APK-%E7%AD%BE%E5%90%8D/" style="font-size: 10px;">Android APK 签名</a> <a href="/tags/Android-JNI/" style="font-size: 12.86px;">Android JNI</a> <a href="/tags/Android-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E8%BF%9B%E9%98%B6/" style="font-size: 10.71px;">Android 事件处理进阶</a> <a href="/tags/Android-%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6/" style="font-size: 13.57px;">Android 动画进阶</a> <a href="/tags/Android-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%80%E5%8F%91/" style="font-size: 10px;">Android 多线程开发</a> <a href="/tags/Android-%E5%B0%8F%E7%BB%8F%E9%AA%8C/" style="font-size: 10px;">Android 小经验</a> <a href="/tags/Android-%E5%B8%B8%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/" style="font-size: 16.43px;">Android 常用第三方库</a> <a href="/tags/Android-%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/" style="font-size: 10px;">Android 开发流程</a> <a href="/tags/Android-%E5%BC%80%E6%BA%90%E6%BA%90%E7%A0%81/" style="font-size: 12.14px;">Android 开源源码</a> <a href="/tags/Android-%E7%BB%98%E5%9B%BE%E8%BF%9B%E9%98%B6/" style="font-size: 12.86px;">Android 绘图进阶</a> <a href="/tags/Android-%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/" style="font-size: 12.86px;">Android 自动化测试</a> <a href="/tags/Android-%E8%87%AA%E5%AE%9A%E4%B9%89View%E8%BF%9B%E9%98%B6/" style="font-size: 12.14px;">Android 自定义View进阶</a> <a href="/tags/Android-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 19.29px;">Android 设计模式</a> <a href="/tags/Android%E5%85%B6%E4%BB%96/" style="font-size: 10px;">Android其他</a> <a href="/tags/Android%E5%9F%BA%E7%A1%80/" style="font-size: 17.86px;">Android基础</a> <a href="/tags/Android%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/" style="font-size: 10px;">Android开发流程</a> <a href="/tags/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" style="font-size: 12.86px;">Android性能优化</a> <a href="/tags/Android%E6%B7%B7%E6%B7%86%E6%8A%80%E6%9C%AF/" style="font-size: 10px;">Android混淆技术</a> <a href="/tags/Android%E8%B4%A8%E9%87%8F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/" style="font-size: 11.43px;">Android质量管理工具</a> <a href="/tags/Android%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/" style="font-size: 10px;">Android逆向工程</a> <a href="/tags/Git-github/" style="font-size: 10px;">Git && github</a> <a href="/tags/Hexo-%E4%BD%BF%E7%94%A8/" style="font-size: 15px;">Hexo 使用</a> <a href="/tags/JavaScript/" style="font-size: 10px;">JavaScript</a> <a href="/tags/Linux-%E4%BD%BF%E7%94%A8/" style="font-size: 10px;">Linux 使用</a> <a href="/tags/Objective-C-%E7%9B%B8%E5%85%B3/" style="font-size: 18.57px;">Objective C 相关</a> <a href="/tags/OpenCV/" style="font-size: 12.86px;">OpenCV</a> <a href="/tags/ROS/" style="font-size: 14.29px;">ROS</a> <a href="/tags/iOS-%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/" style="font-size: 10.71px;">iOS 工具使用</a> <a href="/tags/iOS-%E5%BC%80%E6%BA%90%E5%BA%93%E5%88%86%E6%9E%90/" style="font-size: 20px;">iOS 开源库分析</a> <a href="/tags/iOS-%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/" style="font-size: 15.71px;">iOS 理论基础</a> <a href="/tags/iOS-%E8%BF%9B%E9%98%B6/" style="font-size: 12.14px;">iOS 进阶</a> <a href="/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/" style="font-size: 10px;">代码规范</a> <a href="/tags/%E5%8D%9A%E5%AE%A2%E5%88%86%E7%B1%BB%E7%9B%AE%E5%BD%95/" style="font-size: 10.71px;">博客分类目录</a> <a href="/tags/%E5%8F%A8%E5%8F%A8%E7%B3%BB%E5%88%97/" style="font-size: 10px;">叨叨系列</a> <a href="/tags/%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/" style="font-size: 11.43px;">工具的使用</a> <a href="/tags/%E5%BC%80%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/" style="font-size: 10.71px;">开源代码分析</a> <a href="/tags/%E5%BC%80%E6%BA%90%E5%BA%93%E5%88%86%E6%9E%90/" style="font-size: 10px;">开源库分析</a> <a href="/tags/%E6%9D%82%E7%B1%BB/" style="font-size: 10px;">杂类</a> <a href="/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/" style="font-size: 12.14px;">树莓派</a> <a href="/tags/%E7%9B%B4%E6%92%AD/" style="font-size: 12.86px;">直播</a> <a href="/tags/%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/" style="font-size: 10.71px;">编程技巧</a> <a href="/tags/%E7%BD%91%E7%AB%99%E6%94%B6%E8%97%8F/" style="font-size: 10px;">网站收藏</a> <a href="/tags/%E9%87%8D%E8%A6%81%E6%8E%A7%E4%BB%B6/" style="font-size: 11.43px;">重要控件</a>
    </div>
  </div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
		
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/hsihohuang/kiddochan" target="_blank" title="Kiddochan">Kiddochan</a> © 2022 
		
		<a href="/about" target="_blank" title="Edgar">Edgar</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
        getSize();
        if (myWidth >= 1024) {
          c.click();
        }
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  c.click(function(){
    ta.css('display', 'block').addClass('fadeIn');
  });
  o.click(function(){
    ta.css('display', 'none');
  });
  $(window).scroll(function(){
    ta.css("top",Math.max(140,320-$(this).scrollTop()));
  });
});
</script>




<script type="text/javascript">
  var duoshuoQuery = {short_name:"tbfungeek"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script> 


<script type="text/javascript">

var disqus_shortname = 'tbfungeek';

(function(){
  var dsq = document.createElement('script');
  dsq.type = 'text/javascript';
  dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
}());
(function(){
  var dsq = document.createElement('script');
  dsq.type = 'text/javascript';
  dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/count.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
}());
</script>






<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?7c9443b0374f1cf6b1dbb5ab84d939cb";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="Back to Top"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
</html>
