
 <!DOCTYPE HTML>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
  
    <title>iOS 动画总结 | Edgar&#39;s Blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="Edgar">
    

    
    <meta name="description" content="开篇叨叨iOS动画简单说就是在一段时间内CALayer的Animatable Property发生了变化，一个完整动画包括时间成份（时长，时间变化曲线，动画速度），动画内容（哪些属性发生变化），属性变化范围：（fromValue,toValue），iOS的动画是基于Core Animation的，Core Animation将大部分实际的绘图任务交给了图形硬件GPU来处理，GPU会加速图形渲染的速">
<meta property="og:type" content="article">
<meta property="og:title" content="iOS 动画总结">
<meta property="og:url" content="http://yoursite.com/2019/08/08/iOS-%E5%8A%A8%E7%94%BB%E6%80%BB%E7%BB%93/index.html">
<meta property="og:site_name" content="Edgar&#39;s Blog">
<meta property="og:description" content="开篇叨叨iOS动画简单说就是在一段时间内CALayer的Animatable Property发生了变化，一个完整动画包括时间成份（时长，时间变化曲线，动画速度），动画内容（哪些属性发生变化），属性变化范围：（fromValue,toValue），iOS的动画是基于Core Animation的，Core Animation将大部分实际的绘图任务交给了图形硬件GPU来处理，GPU会加速图形渲染的速">
<meta property="og:locale">
<meta property="og:image" content="http://yoursite.com/2019/08/08/iOS-%E5%8A%A8%E7%94%BB%E6%80%BB%E7%BB%93/00001.png">
<meta property="og:image" content="http://yoursite.com/2019/08/08/iOS-%E5%8A%A8%E7%94%BB%E6%80%BB%E7%BB%93/00002.jpeg">
<meta property="og:image" content="http://yoursite.com/2019/08/08/iOS-%E5%8A%A8%E7%94%BB%E6%80%BB%E7%BB%93/00003.jpeg">
<meta property="og:image" content="http://yoursite.com/2019/08/08/iOS-%E5%8A%A8%E7%94%BB%E6%80%BB%E7%BB%93/00004.png">
<meta property="og:image" content="http://yoursite.com/2019/08/08/iOS-%E5%8A%A8%E7%94%BB%E6%80%BB%E7%BB%93/00005.png">
<meta property="article:published_time" content="2019-08-07T17:30:44.000Z">
<meta property="article:modified_time" content="2020-02-20T14:32:59.000Z">
<meta property="article:author" content="Edgar">
<meta property="article:tag" content="iOS 理论基础">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/2019/08/08/iOS-%E5%8A%A8%E7%94%BB%E6%80%BB%E7%BB%93/00001.png">

    
    <link rel="alternative" href="atom.xml" title="Edgar&#39;s Blog" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/unnamed4_n_mSY_icon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/profile.png">
    <link rel="apple-touch-icon-precomposed" href="/img/profile.png">
    
    
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 6.2.0"></head>

  <body>
    <header>
      
<div>
		
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="Edgar&#39;s Blog">Edgar&#39;s Blog</a></h1>
				<h2 class="blog-motto"></h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="Menu">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
					<li>
 					
					<form class="search" action="/search/index.html" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" autocomplete="off" name="q" maxlength="20" placeholder="Search" />
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
  
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/08/08/iOS-动画总结/" title="iOS 动画总结" itemprop="url">iOS 动画总结</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Edgar" target="_blank" itemprop="author">Edgar</a>
		
  <p class="article-time">
    <time datetime="2019-08-07T17:30:44.000Z" itemprop="datePublished"> Published 2019-08-08</time>
    
  </p>
</header>
	<div class="article-content">
		
		<h5 id="开篇叨叨"><a href="#开篇叨叨" class="headerlink" title="开篇叨叨"></a><strong><strong>开篇叨叨</strong></strong></h5><p>iOS动画简单说就是在一段时间内CALayer的Animatable Property发生了变化，一个完整动画包括时间成份（时长，时间变化曲线，动画速度），动画内容（哪些属性发生变化），属性变化范围：（fromValue,toValue），iOS的动画是基于Core Animation的，Core Animation将大部分实际的绘图任务交给了图形硬件GPU来处理，GPU会加速图形渲染的速度。这种加速技术让动画拥有更高的帧率并且显示效果更加平滑，不会加重CPU的负担而影响程序的运行速度。一般我们在项目中除了十分复杂或者比较简单的动画使用CAAnimation外，一般都是使用三方的动画库，比如<a target="_blank" rel="noopener" href="https://github.com/jhurray/JHChainableAnimations">JHChainableAnimations</a>，<a target="_blank" rel="noopener" href="https://github.com/Lision/LSAnimator">LSAnimator</a>,这两种都是支持Objective C 和 Swift, 并且是通过链式调用，用起来还是十分方便的，对了还有Facebook 的 <a target="_blank" rel="noopener" href="https://github.com/facebook/pop">POP</a>,但是对于复杂的动画还是部分需要自己来封装。还有一类帧动画我们一般用lottie-ios，只要设计提供个json文件和资源文件就可以完成十分酷炫的动画。</p>
<p>这篇博客将从如下几个方面对iOS的动画做个总结：</p>
<ul>
<li>CAAnimation的继承结构</li>
<li>动画相关的CALayer</li>
<li>时间系统</li>
<li>动画事务管理</li>
</ul>
<h5 id="CAAnimation的继承结构"><a href="#CAAnimation的继承结构" class="headerlink" title="CAAnimation的继承结构"></a><strong><strong>CAAnimation的继承结构</strong></strong></h5><p>要了解iOS动画最重要的是对整个动画的继承结构，下图是CAAnimation的继承结构图：</p>
<p><img src="/2019/08/08/iOS-%E5%8A%A8%E7%94%BB%E6%80%BB%E7%BB%93/00001.png"></p>
<h6 id="CAAnimation"><a href="#CAAnimation" class="headerlink" title="CAAnimation"></a><strong><strong>CAAnimation</strong></strong></h6><p>CAAnimation 这个是基类，它不是为了创建对象而存在的，它主要用于存放一些通用性的属性和方法，它有两个很重要的属性：timingFunction，delegate。</p>
<ul>
<li>timingFunction 表示的是时间曲线，我们知道并不是所有的动画都是线性变化的，它们可能先快后慢，或者先慢后快，这就是由timingFunction决定的。timingFunction 是 CAMediaTimingFunction类型，它的可能值如下：</li>
</ul>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">kCAMediaTimingFunctionLinear</span></span><br><span class="line"><span class="attribute">kCAMediaTimingFunctionEaseIn</span></span><br><span class="line"><span class="attribute">kCAMediaTimingFunctionEaseOut</span></span><br><span class="line"><span class="attribute">kCAMediaTimingFunctionEaseInEaseOut</span></span><br><span class="line"><span class="attribute">kCAMediaTimingFunctionDefault</span></span><br></pre></td></tr></table></figure>

<ul>
<li>delegate 这个是CAAnimationDelegate类型的代理。CAAnimationDelegate很简单，它只有两个方法：</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)animationDidStart:(<span class="built_in">CAAnimation</span> *)anim;  </span><br><span class="line"><span class="comment">//动画开始</span></span><br><span class="line">- (<span class="type">void</span>)animationDidStop:(<span class="built_in">CAAnimation</span> *)anim finished:(<span class="type">BOOL</span>)flag; </span><br><span class="line"><span class="comment">//动画停止，这种停止可以是因为动画结束，也有可能是因为动画从它的载体上移除，这里可以通过flag来区分。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>同时CAAnimation遵循CAMediaTiming协议，这里包含了动画的很多基本属性：</p>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line"><span class="built_in">duration</span>：动画播放一次所用的时间</span><br></pre></td></tr></table></figure>
<figure class="highlight erlang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">begin</span>Time：动画起始时间</span><br><span class="line">可以使用它来达到延迟执行动画的效果 <span class="keyword">begin</span>Time = CACurrentMediaTime()+<span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight gml"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">speed</span>:</span><br><span class="line">如果把动画的duration设置为<span class="number">3</span>秒，而<span class="variable language_">speed</span>设置为<span class="number">2</span>，动画将会在<span class="number">1.5</span>秒结束,并且动画速度是有层级关系的：一个动画的<span class="variable language_">speed</span>为<span class="number">1.5</span>，它同时是一个<span class="variable language_">speed</span>为<span class="number">2</span>的动画组的一个动画成员，则它将以<span class="number">3</span>倍速度被执行。</span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">timeOffset：</span><br><span class="line">这个属性往往会结合其他属性类来控制动画的“当前时间”，下面是暂停动画的代码，在开发中十分实用，因为动画要么开始要么移除，但是如果只是暂停，后续还要继续就可以通过下面方法来实现。</span><br><span class="line"></span><br><span class="line">-(<span class="type">void</span>)pauseLayer:(<span class="built_in">CALayer</span>*)layer &#123;</span><br><span class="line">   <span class="built_in">CFTimeInterval</span> pausedTime = [layer convertTime:<span class="built_in">CACurrentMediaTime</span>() fromLayer:<span class="literal">nil</span>];</span><br><span class="line">   layer.speed = <span class="number">0.0</span>;</span><br><span class="line">   layer.timeOffset = pausedTime;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">-(<span class="type">void</span>)resumeLayer:(<span class="built_in">CALayer</span>*)layer &#123;</span><br><span class="line">   <span class="built_in">CFTimeInterval</span> pausedTime = [layer timeOffset];</span><br><span class="line">   layer.speed = <span class="number">1.0</span>;</span><br><span class="line">   layer.timeOffset = <span class="number">0.0</span>;</span><br><span class="line">   layer.beginTime = <span class="number">0.0</span>;</span><br><span class="line">   <span class="built_in">CFTimeInterval</span> timeSincePause = [layer convertTime:<span class="built_in">CACurrentMediaTime</span>() fromLayer:<span class="literal">nil</span>] - pausedTime;</span><br><span class="line">   layer.beginTime = timeSincePause;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里简单得对上面的动画暂停恢复方法进行解释下：</p>
<p>在CAMediaTiming协议的timeOffset的注释上，官方给出以下公式： </p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">t</span> = (tp - begin) * speed + <span class="literal">off</span>set</span><br></pre></td></tr></table></figure>

<p>tp是父layer的时间点，为了方便理解，可以认为是绝对时间。<br>暂停的时候speed等于0，t &#x3D; offset.要让t停在此刻，也就是让t &#x3D; [layer convertTime:CACurrentMediaTime() fromLayer:nil]。这时候offset就必须等于[layer convertTime:CACurrentMediaTime() fromLayer:nil]</p>
<p>我们再来看下恢复，恢复的时候speed &#x3D; 1，offset &#x3D; 0, t &#x3D; 上一次停留时间也就是t &#x3D; (tp - begin) &#x3D; pausedTime；<br>所以begin &#x3D; [layer convertTime:CACurrentMediaTime() fromLayer:nil] - pauseTime;</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">repeatCount/repeatDuration：动画的重复执行，二者不可同时使用</span><br><span class="line">repeatCount指定重复的次数</span><br><span class="line">repeatDuration指定重复执行持续的时间，一到时间就停止重复执行。</span><br></pre></td></tr></table></figure>

<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">auto</span>reverses：是否自动翻转动画</span><br><span class="line">将使动画先正常走，完了以后反着从结束值回到起始值，如果指定了<span class="built_in">auto</span>reverse = YES 那么完成一次<span class="built_in">auto</span>reverse就需要 <span class="number">2</span>*duration</span><br></pre></td></tr></table></figure>

<figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">fillMode : 动画填充模式</span><br><span class="line"></span><br><span class="line">fillMode的作用就是决定当前对象过了非Active时间段的行为. 比如动画开始之前,动画结束之后，如果要让动画在开始之前显示<span class="keyword">from</span>Value的状态，设置fillMode为kCAFillModeBackwards。如果想让动画结束后停留在<span class="keyword">to</span>Value的状态，就应该设置为kCAFillModeForwards。如果两种都要有，就设置kCAFillModeBoth。注意必须配合animation.removeOnCompletion = NO才能达到以上效果</span><br></pre></td></tr></table></figure>

<p>CALayer遵循CAMediaTiming协议，每个CALayer都有个时间系统，可以通过CACurrentMediaTime() 来获得当前时间，可以通过CALayer的</p>
<figure class="highlight erlang"><table><tr><td class="code"><pre><span class="line">- <span class="params">(CFTimeInterval)</span>convertTime:<span class="params">(CFTimeInterval)</span>t fromLayer:<span class="params">(CALayer *)</span>l;</span><br><span class="line">- <span class="params">(CFTimeInterval)</span>convertTime:<span class="params">(CFTimeInterval)</span>t toLayer:<span class="params">(CALayer *)</span>l;</span><br></pre></td></tr></table></figure>
<p>在两个不同CALayer中进行转换。</p>
<p>下面是介绍这些属性的一个效果图，可以看这些参数来熟悉这些概念。</p>
<p><img src="/2019/08/08/iOS-%E5%8A%A8%E7%94%BB%E6%80%BB%E7%BB%93/00002.jpeg"></p>
<h6 id="CAPropertyAnimation"><a href="#CAPropertyAnimation" class="headerlink" title="CAPropertyAnimation"></a><strong><strong>CAPropertyAnimation</strong></strong></h6><p>CAPropertyAnimation 是属性动画，它其实也还是一个基类，不能用于创建对象，它有一个很重要的属性keyPath,用于指定哪些属性可以用于动画控制，那么我们怎么知道有哪些属性有属性动画呢？可以打开CALayer.h 搜索 “Animatable” 关键字，这些属性都是具有属性动画：将其罗列如下所示：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="attribute">transform</span><span class="selector-class">.scale</span>     </span><br><span class="line"><span class="attribute">transform</span><span class="selector-class">.scale</span><span class="selector-class">.x</span></span><br><span class="line"><span class="attribute">transform</span><span class="selector-class">.scale</span><span class="selector-class">.y</span></span><br><span class="line"><span class="attribute">transform</span><span class="selector-class">.rotation</span> </span><br><span class="line"><span class="attribute">transform</span><span class="selector-class">.rotation</span><span class="selector-class">.x</span></span><br><span class="line"><span class="attribute">transform</span><span class="selector-class">.rotation</span><span class="selector-class">.y</span></span><br><span class="line"><span class="attribute">transform</span><span class="selector-class">.rotation</span><span class="selector-class">.z</span></span><br><span class="line"><span class="attribute">transform</span><span class="selector-class">.translation</span></span><br><span class="line"><span class="attribute">transform</span><span class="selector-class">.translation</span><span class="selector-class">.x</span></span><br><span class="line"><span class="attribute">transform</span><span class="selector-class">.translation</span><span class="selector-class">.y</span></span><br><span class="line"><span class="attribute">transform</span><span class="selector-class">.translation</span><span class="selector-class">.z</span></span><br><span class="line"><span class="attribute">opacity</span> </span><br><span class="line"><span class="attribute">margin</span></span><br><span class="line">zPosition</span><br><span class="line">backgroundColor </span><br><span class="line">cornerRadius </span><br><span class="line">borderWidth</span><br><span class="line">bounds</span><br><span class="line">contents</span><br><span class="line">contentsRect</span><br><span class="line">cornerRadius</span><br><span class="line">frame</span><br><span class="line">hidden</span><br><span class="line"><span class="attribute">mask</span></span><br><span class="line">masksToBounds</span><br><span class="line"><span class="attribute">opacity</span></span><br><span class="line"><span class="attribute">position</span></span><br><span class="line">shadowColor</span><br><span class="line">shadowOffset</span><br><span class="line">shadowOpacity</span><br><span class="line">shadowRadius</span><br></pre></td></tr></table></figure>
<p>它还有两个很关键的属性：additive&#x2F;cumulative</p>
<ul>
<li>additive为YES时，变化值整体加上layer的当前值,也即是它其实是加性属性。</li>
<li>cumulative 为YES时，每次的值要加上上一次循环的的结束值。需要repeatCount&gt;1的时候才能看出效果。</li>
</ul>
<h6 id="CAAnimationGroup"><a href="#CAAnimationGroup" class="headerlink" title="CAAnimationGroup"></a><strong><strong>CAAnimationGroup</strong></strong></h6><p>CAAnimationGroup 可以保存一组动画对象，将CAAnimationGroup对象加入层后，组中所有动画对象可以同时并发运行，可以通过设置动画对象的beginTime属性来更改动画的开始时间</p>
<h6 id="CATransition"><a href="#CATransition" class="headerlink" title="CATransition"></a><strong><strong>CATransition</strong></strong></h6><p>CATransition用于做转场动画，也就是layer的两种状态之间的过渡。能够为层提供移出屏幕和移入屏幕的动画效果：<br>CATransition有如下关键属性：</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span>：动画过渡类型</span><br><span class="line"><span class="keyword">subtype</span>：动画过渡方向</span><br><span class="line">startProgress：动画起点(在整体动画的百分比)</span><br><span class="line">endProgress：动画终点(在整体动画的百分比)</span><br></pre></td></tr></table></figure>

<p>type的值可以是如下枚举值：</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">kCATransitionFade</span></span><br><span class="line"><span class="attribute">kCATransitionMoveIn</span></span><br><span class="line"><span class="attribute">kCATransitionPush</span></span><br><span class="line"><span class="attribute">kCATransitionReveal</span></span><br></pre></td></tr></table></figure>

<p>subtypes的值可以是如下枚举值：</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">kCATransitionFromRight</span></span><br><span class="line"><span class="attribute">kCATransitionFromLeft</span></span><br><span class="line"><span class="attribute">kCATransitionFromTop</span></span><br><span class="line"><span class="attribute">kCATransitionFromBottom</span></span><br></pre></td></tr></table></figure>

<p>各个属性的说明如下图所示：</p>
<p><img src="/2019/08/08/iOS-%E5%8A%A8%E7%94%BB%E6%80%BB%E7%BB%93/00003.jpeg"></p>
<p>下面是一个简单的例子：</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">CATransition *animation = [CATransition animation];</span><br><span class="line">animation.<span class="keyword">type</span> <span class="type">= </span>kCATransitionPush;//设置动画的类型</span><br><span class="line">animation.<span class="keyword">subtype</span> <span class="type">= </span>kCATransitionFromRight; //设置动画的方向</span><br><span class="line">animation.duration = <span class="number">1.0</span>f;</span><br><span class="line">[testView.layer addAnimation:animation forKey:@<span class="string">&quot;pushAnimation&quot;</span>];</span><br></pre></td></tr></table></figure>

<h6 id="CABasicAnimation"><a href="#CABasicAnimation" class="headerlink" title="CABasicAnimation"></a><strong><strong>CABasicAnimation</strong></strong></h6><p>CABasicAnimation：基础动画，通过属性修改进行动画参数控制，它有三个关键属性fromValue和toValue,还有byValue，当然不要忘记了它也是CAPropertyAnimation，在CAPropertyAnimation中可以指定要变化的keyPath.到这里为止动画内容(keyPath)有了，动画时间(duration和timingFunction)有了,开始和结束状态（fromValue和toValue）有了。通过插值就可以得到任意一个时间点的状态，然后渲染绘制形成一系列关联的图像，形成动画，也就是说到CABasicAnimation为止已经可以创建出一个动画了。</p>
<h6 id="CAKeyframeAnimation"><a href="#CAKeyframeAnimation" class="headerlink" title="CAKeyframeAnimation"></a><strong><strong>CAKeyframeAnimation</strong></strong></h6><p>如果说CABasicAnimation是一帧动画的话，CAKeyframeAnimation就是多个CABasicAnimation组成的帧动画，我们知道动画其实就是一帧帧画面连续变化得到的，我们不可能提供无限的连续的动画帧，我们只需要提供必要的关键帧就可以通过插值来完成了，再加上人眼的视觉暂留效应就可以在大脑中留下连续运动的动画。CAKeyframeAnimation有两个最为关键的属性values和keyTimes，values就是各个关键帧的数据，keyTimes是各个关键帧的时间点。keyTimes这个可选参数,当keyTimes没有设置的时候,各个关键帧的时间是均分的。</p>
<p>除了values和keyTimes属性 CAKeyframeAnimation 还有个path属性也很关键，为什么需要这个属性，大家试想下，如果我们要实现一个沿着心型❤️轨迹运动的动画，那么我们要怎么获得keyTimes和values？为了高度拟合轨迹我们要做很多计算才能得到，这显然不是正确的做法，API应该是以简洁易用为目的，所以这时候就可以通过path来描述运动轨迹。这个值默认是nil当其被设定的时候values属性就会被覆盖.</p>
<p>还有比较重要的属性就是calculationMode和rotationMode</p>
<p>calculationMode 影响着关键帧之间的数据如何进行推算：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">kCAAnimationLinear</span>          通过线性插值</span><br><span class="line">kCAAnimationDiscrete        不进行插值，只显示关键帧的画面，看到的动画会是跳跃的</span><br><span class="line">kCAAnimationPaced           这个也是线性插值，但跟第一个的区别是它是整体考虑的。它会忽略掉keyTimes属性，重新计算keyTimes以达到全局匀速的效果。注意这时候keyTimes和timingFunctions是不起作用的; </span><br><span class="line"><span class="attribute">kCAAnimationCubic</span>           效果就是把转折点变得圆滑</span><br><span class="line">kCAAnimationCubicPaced      kCAAnimationPaced和kCAAnimationCubic两种效果叠加</span><br></pre></td></tr></table></figure>

<p>rotationMode只有帧动画使用path路径的时候才有效果的，当值为kCAAnimationRotateAuto是，会把layer旋转，使得layer自身的x轴是跟路径相切的,并且x轴方向跟运动方向一致，使用kCAAnimationRotateAutoReverse也是相切，但x轴方向跟运动方向相反。</p>
<h6 id="CASpringAnimation"><a href="#CASpringAnimation" class="headerlink" title="CASpringAnimation"></a><strong><strong>CASpringAnimation</strong></strong></h6><p>CASpringAnimation是iOS7.0后新增的,它提供了像弹簧一样的变化规律，它有如下关键的属性：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">mass</span>            弹簧质量，影响弹簧的惯性，质量越大，弹簧惯性越大，运动的幅度越大</span><br><span class="line">stiffness       弹簧弹性系数，弹性系数越大，弹簧的运动越快</span><br><span class="line">damping         弹簧阻尼系数，阻尼系数越大，弹簧的停止越快</span><br><span class="line">initialVelocity 初始速率，弹簧动画的初始速度大小，弹簧运动的初始方向与初始速率的正负一致</span><br></pre></td></tr></table></figure>

<h5 id="CoreAnimation的使用步骤"><a href="#CoreAnimation的使用步骤" class="headerlink" title="CoreAnimation的使用步骤"></a><strong><strong>CoreAnimation的使用步骤</strong></strong></h5><ul>
<li>创建CAAnmation子对象</li>
<li>设置CAAnmation的属性</li>
<li>调用CALayer的addAnimation:forKey：将CAAnimation对象添加到CALayer上，就能执行动画</li>
<li>调用CALayer的removeAnimationForKey方法可以停止CALayer中的动画。</li>
</ul>
<h5 id="CGAffineTransform-仿射变换"><a href="#CGAffineTransform-仿射变换" class="headerlink" title="CGAffineTransform 仿射变换"></a><strong><strong>CGAffineTransform 仿射变换</strong></strong></h5><p>在最初开发Android 的时候接触到仿射变换，一直不理解什么是仿射，其实的仿射变换就是将视图的每个点乘以一个仿射矩阵，得到一个变换后的视图，具体变换过程这里不做展开，这里会涉及到数学的矩阵运算，但是要记住一点：图层中平行的两条线在变换之后任然会保持平行。</p>
<p>可以通过如下方法创建CGAffineTransform：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">CGAffineTransformMakeRotation</span><span class="params">(CGFloat angle)</span></span>             <span class="comment">//旋转变换</span></span><br><span class="line"><span class="function"><span class="title">CGAffineTransformMakeScale</span><span class="params">(CGFloat sx, CGFloat sy)</span></span>       <span class="comment">//缩放变换</span></span><br><span class="line"><span class="function"><span class="title">CGAffineTransformMakeTranslation</span><span class="params">(CGFloat tx, CGFloat ty)</span></span> <span class="comment">//平移变换</span></span><br></pre></td></tr></table></figure>
<p>下面是在一个仿射变换基础上叠加另一个仿射变换的方法。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">CGAffineTransformRotate</span>(<span class="built_in">CGAffineTransform</span> t, <span class="built_in">CGFloat</span> angle)</span><br><span class="line"><span class="built_in">CGAffineTransformScale</span>(<span class="built_in">CGAffineTransform</span> t, <span class="built_in">CGFloat</span> sx, <span class="built_in">CGFloat</span> sy)</span><br><span class="line"><span class="built_in">CGAffineTransformTranslate</span>(<span class="built_in">CGAffineTransform</span> t, <span class="built_in">CGFloat</span> tx, <span class="built_in">CGFloat</span> ty)</span><br></pre></td></tr></table></figure>
<p>如果已经存在了两个仿射变换，现在要将它们合在一起的时候可以调用：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">CGAffineTransformConcat</span>(<span class="built_in">CGAffineTransform</span> t1, <span class="built_in">CGAffineTransform</span> t2);</span><br></pre></td></tr></table></figure>
<p>如果需要一个什么都不变的变换，就可以实用</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">CGAffineTransformIdentity</span></span><br></pre></td></tr></table></figure>

<p>下面是一个简单的例子：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">CGAffineTransform</span> transform = CGAffineTransformIdentity; </span><br><span class="line"><span class="attribute">transform</span> = CGAffineTransformScale(transform, <span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line"><span class="attribute">transform</span> = CGAffineTransformRotate(transform, M_PI / <span class="number">180</span>.<span class="number">0</span> * <span class="number">45</span>.<span class="number">0</span>); </span><br><span class="line"><span class="attribute">transform</span> = CGAffineTransformTranslate(transform, <span class="number">250</span>, <span class="number">0</span>);</span><br><span class="line"><span class="attribute">self</span>.layerView.layer.affineTransform = transform;</span><br></pre></td></tr></table></figure>

<p>UIView可以通过设置transform属性做变换。需要注意的是CALayer同样也有一个transform属性，但它的类型是CATransform3D，不要被误导了，真正用于仿射变换的是affineTransform属性。</p>
<h5 id="CATransform3D-3D变换"><a href="#CATransform3D-3D变换" class="headerlink" title="CATransform3D 3D变换"></a><strong><strong>CATransform3D 3D变换</strong></strong></h5><p>和2D仿射变换类似CATransform3D也提供了对应的旋转，缩放，平移的方法，如下所示：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="constructor">CATransform3DMakeRotation(CGFloat <span class="params">angle</span>, CGFloat <span class="params">x</span>, CGFloat <span class="params">y</span>, CGFloat <span class="params">z</span>)</span></span><br><span class="line"><span class="constructor">CATransform3DMakeScale(CGFloat <span class="params">sx</span>, CGFloat <span class="params">sy</span>, CGFloat <span class="params">sz</span>)</span> </span><br><span class="line"><span class="constructor">CATransform3DMakeTranslation(Gloat <span class="params">tx</span>, CGFloat <span class="params">ty</span>, CGFloat <span class="params">tz</span>)</span></span><br></pre></td></tr></table></figure>

<p>透视投影</p>
<p>上面的变换是没有透视效果的，原先平行的还是保持平行，因此我们需要做透视投影处理，要达到透视效果可以通过设置CATransform3D的m34值来实现，那么m34要怎么设置呢？</p>
<p><img src="/2019/08/08/iOS-%E5%8A%A8%E7%94%BB%E6%80%BB%E7%BB%93/00004.png"><br>一般而言 m34 &#x3D; -1.0 &#x2F; distance  （distance视角相机和屏幕之间的距离，以像素为单位，一般不需要仔细计算，根据实际效果500-1000中选择一个就好）</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">CATransform3D</span> transform = CATransform3DIdentity;</span><br><span class="line"><span class="attribute">transform</span>.m34 = - <span class="number">1</span>.<span class="number">0</span> / <span class="number">500</span>.<span class="number">0</span>;</span><br><span class="line"><span class="attribute">transform</span> = CATransform3DRotate(transform, M_PI_4, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="attribute">self</span>.layerView.layer.transform = transform;</span><br></pre></td></tr></table></figure>
<p>对于一个View,Core Animation定义消失点位于View的anchorPoint，但是这里会有个问题：一个界面可能有多个View要做3D变换，但是一个界面通常只能有一个消失点，所以不能通过设置position来移动，因为当改变一个图层的position，你也改变了它的消失点，因此在做3D变换的时候需要记住：当视图通过调整m34来让它更加有3D效果，应该首先把它放置于屏幕中央，然后通过平移来把它移动到指定位置，而不是直接改变它的position，这样所有的3D图层都共享一个消失点。还有一种方式就是通过sublayerTransform，sublayerTransform和对一个图层的变换不同，它影响到所有的子图层。这意味着你可以一次性对包含这些图层的容器做变换，因此我们可以把消失点设置在容器图层的中点，这样就不需要再对子图层分别设置了。这意味着你可以随意使用position和frame来放置子图层，而不需要把它们放置在屏幕中点，然后为了保证统一的消失点用变换来做平移。</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">CATransform3D</span> perspective = CATransform3DIdentity;</span><br><span class="line"><span class="attribute">perspective</span>.m34 = - <span class="number">1</span>.<span class="number">0</span> / <span class="number">500</span>.<span class="number">0</span>;</span><br><span class="line"><span class="attribute">self</span>.containerView.layer.sublayerTransform = perspective;</span><br><span class="line"><span class="attribute">CATransform3D</span> transform1 = CATransform3DMakeRotation(M_PI_4, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="attribute">self</span>.layerView1.layer.transform = transform1;</span><br><span class="line"><span class="attribute">CATransform3D</span> transform2 = CATransform3DMakeRotation(-M_PI_4, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="attribute">self</span>.layerView2.layer.transform = transform2;</span><br></pre></td></tr></table></figure>

<h5 id="动画的事务管理"><a href="#动画的事务管理" class="headerlink" title="动画的事务管理"></a><strong><strong>动画的事务管理</strong></strong></h5><p>事务这个概念在很多地方都会遇到，比如数据库操作等，在iOS动画中事务实际上是Core Animation用来包含一系列属性动画集合的机制，任何CALayer的Animatable Properties设置都应该属于某个CATransaction（在修改CALayer的Animatable Properties时如果发现当前没有事务，则会自动创建一个事务），在一个CATransaction中可以同时对多个layer的属性进行修改，CATransaction负责对layer的修改的捕获和提交，在事务中的变化并不会立刻生效，而是在事务提交的时候将这些图层树的变化成批包装起来，一次性发送到渲染服务进程，在我们看来就是图层的各个属性会在同一时刻由一个动画过渡到新值。Core Animation在每个Runloop周期中自动开始一次新的事务,事务的提交发生在RunLoop进入休眠或者退出期间,即使不显式的用[CATransaction begin]开始一次事务，任何在一次Runloop循环中属性的改变都会被集中起来，然后做一次0.25秒的动画。事务可以嵌套,当事务嵌套时候,只有当最外层的事务commit了之后,整个动画才开始.在没有RunLoop的地方设置CALayer的Animatable Properties,则必须使用显式的事务，有RunLoop的情况下会自动创建CATransation，CATransaction没有属性或者实例方法，并且也不能用+alloc和-init方法创建它。但是可以用+begin和+commit分别来入栈或者出栈,如下所示：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="string">[CATransaction begin]</span>;</span><br><span class="line"> <span class="comment">//动画内容</span></span><br><span class="line"><span class="string">[CATransaction commit]</span>;</span><br></pre></td></tr></table></figure>
<p>UIView动画中：+beginAnimations:context:和+commitAnimations ，以及UIView基于Block的动画方法：+animateWithDuration:animations:也都是基于CATransaction的封装。</p>
<h5 id="动画相关的CALayer"><a href="#动画相关的CALayer" class="headerlink" title="动画相关的CALayer"></a><strong><strong>动画相关的CALayer</strong></strong></h5><p>在介绍iOS渲染的时候已经对iOS UIView以及CALayer做了较为详细的介绍，UIView 和 CALayer职责十分明确，一个是负责事件响应，一个是负责界面呈现，在介绍iOS渲染的时候主要关注的是CALayer内容显示的部分，而这里将会重点介绍CALayer的动画特性，其实给View加上动画，本质上是对其CALayer进行操作，CALayer有很多Animatable Property，我们可以基于这些属性做动画效果。</p>
<p>在介绍完CALayer后我们还需要了解一些特殊的CALayer,和CALayer基于Core Graphic的CPU渲染方式不同，它们大多数是基于GPU渲染的，下面是这些Layer的特点和作用：</p>
<ul>
<li><p><strong><strong>CAShapeLayer</strong></strong><br>CAShapeLayer是一个通过矢量图形而不是Bitmap来绘制的CALayer子类.<br>CAShapeLayer相对于一般的CALayer有如下特点：</p>
<ol>
<li>CAShapeLayer使用了硬件加速,而CALayer是基于Core Graphics使用的是CPU绘图，因此渲染速度会快很多。</li>
<li>CAShapeLayer不需要像普通CALayer一样创建一个寄宿图形，所以无论有多大，都不会占用太多的内存.</li>
</ol>
</li>
<li><p><strong><strong>CATextLayer</strong></strong><br>UILabel最早其实是通过WebKit来实现绘制的，这样就造成了当有很多文字的时候就会有极大的性能压力。而CATextLayer使用了Core Text，所以渲染性能十分快速。</p>
</li>
<li><p><strong><strong>CAGradientLayer</strong></strong><br>CAGradientLayer是用来生成两种或更多颜色平滑渐变的图层，CAGradientLayer也是基于硬件加速对因此渲染效率也比基于Core Graphic 快很多。</p>
</li>
<li><p><strong><strong>CAGradientLayer</strong></strong><br>CAGradientLayer 用于高效生成许多相似的图层。它会绘制一个或多个图层的子图层，并在每个复制体上应用不同的变换。</p>
</li>
<li><p><strong><strong>CAScrollLayer</strong></strong><br>CAScrollLayer用于显示的是可滚动的图层的一部分，可以指定滑动方向和可视区域面积，限制不滑出区域外。</p>
</li>
<li><p><strong><strong>CATiledLayer</strong></strong><br>有时候我们需要呈现一个很大的，质量很高的图片，这种情况下如果将整个图片加载到内存是不大现实的，一来会占用很大的空间，二来图片加载会很耗时，导致动画卡顿。还有个比较棘手的问题就是，OpenGL对纹理对大小是有限制的，如果超过最大纹理大小，Core Animation将会强制用CPU处理图片而不是GPU。为了解决这些问题，CATiledLayer将大图分解成小片然后将他们单独按需载入。从而减小内存占用和加载耗时。</p>
</li>
<li><p><strong><strong>CAEmitterLayer</strong></strong><br>CAEmitterLayer是一个高性能的粒子引擎，被用来创建实时粒子动画如：烟雾，火，雨等等效果。</p>
</li>
<li><p><strong><strong>CAEAGLLayer</strong></strong><br>CAEAGLLayer是CALayer的一个子类，用来显示任意的OpenGL图形。</p>
</li>
<li><p><strong><strong>AVPlayerLayer</strong></strong><br>AVPlayerLayer是用来在iOS上播放视频的。它是高级接口例如MPMoivePlayer的底层实现，提供了显示视频的底层控制。</p>
</li>
</ul>
<h5 id="隐式动画"><a href="#隐式动画" class="headerlink" title="隐式动画"></a><strong><strong>隐式动画</strong></strong></h5><p>iOS中的动画有显式动画和隐式动画两种类型，上面介绍的动画都属于显式动画，接下来要介绍的是隐式动画，我们上面介绍过每一个View都有其对应的layer，这个layer是Root Layer，而其他通过CALayer或其子类直接创建的CALayer是非Root Layer。所有非Root Layer在我们设置Animatable Properties的时候都会存在duration为0.25s的隐式动画，而对Root Layer则没有这个过渡，这是为什么呢？实际上无论什么时候修改Animatable Properties。CALayer都会去查找并运行合适的action，什么是action呢？action实际上是一些遵循了CAAction协议的对象,用于定义一个动画需要做的事情，不论是否在block里面修改view的属性，都会触发CALayer查找合适的CAAction.</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">CAAction</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)runActionForKey:(<span class="built_in">NSString</span> *)event object:(<span class="type">id</span>)anObject</span><br><span class="line">    arguments:(<span class="keyword">nullable</span> <span class="built_in">NSDictionary</span> *)dict;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>CAAction协议中有个runActionForKey方法，我们可以在这个方法中对layer自定义某些动画效果。下面是一个简单的例子：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="meta">@interface</span> <span class="type">CustomAction</span> : <span class="type">NSObject</span>&lt;<span class="type">CAAction</span>&gt;</span><br><span class="line"><span class="meta">@property</span> (nonatomic) <span class="type">CGColorRef</span> currentColor;</span><br><span class="line"><span class="meta">@end</span></span><br><span class="line"><span class="meta">@implementation</span> <span class="type">CustomAction</span></span><br><span class="line"><span class="operator">-</span> (void)runActionForKey:(<span class="type">NSString</span> <span class="operator">*</span>)key object:(id)anObject arguments:(<span class="type">NSDictionary</span> <span class="operator">*</span>)dict &#123;</span><br><span class="line">    <span class="type">CustomLayer</span> <span class="operator">*</span>layer <span class="operator">=</span> anObject;</span><br><span class="line">    <span class="type">CABasicAnimation</span> <span class="operator">*</span>animation <span class="operator">=</span> [<span class="type">CABasicAnimation</span> animationWithKeyPath:@<span class="string">&quot;backgroundColor&quot;</span>];</span><br><span class="line">    animation.fromValue <span class="operator">=</span> (id)[<span class="type">UIColor</span> greenColor].<span class="type">CGColor</span>;</span><br><span class="line">    animation.toValue <span class="operator">=</span> (id)[<span class="type">UIColor</span> redColor].<span class="type">CGColor</span>;</span><br><span class="line">    animation.duration <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">    [layer addAnimation:animation forKey:@<span class="string">&quot;backgroundColor&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@end</span></span><br></pre></td></tr></table></figure>

<p>除了修改layer属性外，触发搜索action事件的触发点包括如下几个：</p>
<figure class="highlight gml"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">layer</span>的属性被修改。包括<span class="variable language_">layer</span>的任何属性，不仅仅只是会产生动画的部分。</span><br><span class="line"><span class="variable language_">layer</span>被添加到<span class="variable language_">layer</span>阶层。标识符key是kCAOnOrder。</span><br><span class="line"><span class="variable language_">layer</span>被移除<span class="variable language_">layer</span>阶层。标示符key是kCAOnOrderOut。</span><br></pre></td></tr></table></figure>

<p>action的搜索的过程：</p>
<p>layer调用actionForKey:方法搜索需要执行的action对象</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">如果layer设置了代理，layer会向它的delegate发送actionForLayer:forKey:消息来要求返回对应当前属性变化的CAAction。</span><br><span class="line">actionForLayer:forKey:有三种返回情况：</span><br><span class="line"><span class="bullet">1.</span> 返回CAAction的对象，这时候将会使用这个CAAction来实现这个动画</span><br><span class="line"><span class="bullet">2.</span> 返回NSNull,这时候就会停止搜索，并且告诉layer不需要执行任何动画</span><br><span class="line"><span class="bullet">3.</span> 返回nil，这时候layer就会继续往下找</span><br><span class="line"><span class="bullet">4.</span> 查找layer的action属性，看可以是否有对应的值</span><br><span class="line"><span class="bullet">5.</span> 查找layer的style属性。</span><br><span class="line"><span class="bullet">6.</span> 调用defaultActionForKey返回对应key的默认action，一般是CABasicAnimation。</span><br></pre></td></tr></table></figure>

<p>找到action对象后，调用action对象的runActionForLayer:object:arguments:方法执行相关操作。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">id</span>&lt;<span class="built_in">CAAction</span>&gt;)actionForLayer:(<span class="built_in">CALayer</span> *)layer forKey:(<span class="built_in">NSString</span> *)event&#123;</span><br><span class="line">    <span class="keyword">if</span> ([event isEqualToString:<span class="string">@&quot;backgroundColor&quot;</span>]) &#123;</span><br><span class="line">        MyAction *action = [MyAction new];</span><br><span class="line">        <span class="keyword">return</span> action;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyAction</span> : <span class="title">NSObject</span>&lt;<span class="title">CAAction</span>&gt;</span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyAction</span></span></span><br><span class="line">- (<span class="type">void</span>)runActionForKey:(<span class="built_in">NSString</span> *)event object:(<span class="type">id</span>)anObject arguments:(<span class="built_in">NSDictionary</span> *)dict&#123;</span><br><span class="line">    CustomLayer *layer = anObject;</span><br><span class="line">    <span class="built_in">CABasicAnimation</span> *animation = [<span class="built_in">CABasicAnimation</span> animation];</span><br><span class="line">    animation.duration = <span class="number">3.0</span>f;</span><br><span class="line">    [layer addAnimation:animation forKey:<span class="string">@&quot;backgroundColor&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>有了上面的介绍大家应该会对从修改属性到动画执行的整个流程有了比较详细的了解了吧，这里就很好理解为什么Root Layer没有隐式动画而非Root Layer会有隐式动画了，其实最大的玄机在于CALayer的delegate对象，我们知道Root Layer的delegte是对应的UIView，因此可以推测之所以Root Layer没有隐式动画就是因为UIView在一般情况下actionForLayer:forKey返回一个 NSNull，只有当属性改变发生在动画block 中时，view 才会返回实际的动作。而非Root Layer,delegate在不设置的情况下为空，所以返回的是通过defaultActionForKey返回的对应key的默认Action.</p>
<p>但是有时候我们又需要关闭这些隐式动画，这种情况就可以通过如下方式来关闭：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">[<span class="built_in">CATransaction</span> begin];</span><br><span class="line"><span class="comment">// 关闭隐式动画</span></span><br><span class="line">[<span class="built_in">CATransaction</span> setDisableActions:<span class="literal">YES</span>];</span><br><span class="line"><span class="comment">//原本会产生隐式动画的部分</span></span><br><span class="line">[<span class="built_in">CATransaction</span> commit];</span><br></pre></td></tr></table></figure>
<p>设置setDisableActions:为YES后，layer的actionForKey:方法将不会被调用，隐式动画也不会生成。</p>
<h5 id="UIView-过渡动画"><a href="#UIView-过渡动画" class="headerlink" title="UIView 过渡动画"></a><strong><strong>UIView 过渡动画</strong></strong></h5><p>视图过渡动画一般用在比如删除或增加子视图的时候。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">+ (<span class="type">void</span>)transitionWithView:(<span class="built_in">UIView</span> *)view </span><br><span class="line">                  duration:(<span class="built_in">NSTimeInterval</span>)duration </span><br><span class="line">                   options:(<span class="built_in">UIViewAnimationOptions</span>)options </span><br><span class="line">                animations:(<span class="type">void</span> (^)(<span class="type">void</span>))animations </span><br><span class="line">                completion:(<span class="type">void</span> (^)(<span class="type">BOOL</span> finished))completion;</span><br></pre></td></tr></table></figure>

<p>view 就是指定的需要做动画过渡的视图,或者要做动画视图的容器视图。<br>animations 中可以执行比如添加、删除、显示或隐藏指定view 的子视图<br>其他的和UIView的block动画类似。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">+ (<span class="type">void</span>)transitionFromView:(<span class="built_in">UIView</span> *)fromView </span><br><span class="line">                    toView:(<span class="built_in">UIView</span> *)toView </span><br><span class="line">                    duration:(<span class="built_in">NSTimeInterval</span>)duration </span><br><span class="line">                    options:(<span class="built_in">UIViewAnimationOptions</span>)options </span><br><span class="line">                    completion:(<span class="type">void</span> (^ __<span class="keyword">nullable</span>)(<span class="type">BOOL</span> finished))completion</span><br></pre></td></tr></table></figure>
<p>这个动画用于从一个view转变到另一个view过程的动画，在动画过程中，首先将 fromView 从父视图中删除，然后将 toView 添加，就是做了一个替换操作 </p>
<h5 id="UIImageView-帧动画"><a href="#UIImageView-帧动画" class="headerlink" title="UIImageView 帧动画"></a><strong><strong>UIImageView 帧动画</strong></strong></h5><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event&#123;</span><br><span class="line">    <span class="built_in">NSArray</span> *imageArray = [<span class="keyword">self</span> getImageArrayWithGIFNameWit:<span class="string">@&quot;aisi&quot;</span>];</span><br><span class="line">    <span class="keyword">self</span>.imageView.animationImages = imageArray;</span><br><span class="line">    <span class="keyword">self</span>.imageView.animationDuration = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">self</span>.imageView.animationRepeatCount = MAXFLOAT;</span><br><span class="line">    [<span class="keyword">self</span>.imageView startAnimating];</span><br><span class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">5.0</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        [_imageView stopAnimating];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSArray</span>&lt;<span class="built_in">UIImage</span> *&gt; *)getImageArrayWithGIFNameWit:(<span class="built_in">NSString</span> *)imageName &#123;</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *imageArray = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">    <span class="built_in">NSString</span> *path = [[<span class="built_in">NSBundle</span> mainBundle] pathForResource:imageName ofType:<span class="string">@&quot;gif&quot;</span>];</span><br><span class="line">    <span class="built_in">NSData</span> *data = [<span class="built_in">NSData</span> dataWithContentsOfFile:path];</span><br><span class="line">    <span class="keyword">if</span> (!data) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">CGImageSourceRef</span> source = <span class="built_in">CGImageSourceCreateWithData</span>((__bridge <span class="built_in">CFDataRef</span>)data, <span class="literal">NULL</span>);</span><br><span class="line">    size_t count = <span class="built_in">CGImageSourceGetCount</span>(source);</span><br><span class="line">    <span class="keyword">if</span> (count &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        [imageArray addObject:[[<span class="built_in">UIImage</span> alloc] initWithData:data]];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            <span class="built_in">CGImageRef</span> image = <span class="built_in">CGImageSourceCreateImageAtIndex</span>(source, i, <span class="literal">NULL</span>);</span><br><span class="line">            </span><br><span class="line">            [imageArray addObject:[<span class="built_in">UIImage</span> imageWithCGImage:image scale:[<span class="built_in">UIScreen</span> mainScreen].scale orientation:<span class="built_in">UIImageOrientationUp</span>]];</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">CGImageRelease</span>(image);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">CFRelease</span>(source);</span><br><span class="line">    <span class="keyword">return</span> imageArray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="转场动画"><a href="#转场动画" class="headerlink" title="转场动画"></a><strong><strong>转场动画</strong></strong></h5><h6 id="1-UIViewController-容器转场动画"><a href="#1-UIViewController-容器转场动画" class="headerlink" title="1. UIViewController 容器转场动画"></a><strong><strong>1. UIViewController 容器转场动画</strong></strong></h6><p>这个适用于多个子UIViewController在一个容器UIViewController中进行切换的动画,它的好处在没有转换到<strong><strong>toViewController</strong></strong>的时候toViewController没有显示也不会load，这样减少内存的使用。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"> <span class="built_in">UIViewController</span> *firstViewController = [<span class="built_in">UIViewController</span> new];</span><br><span class="line">firstViewController.view.backgroundColor = [<span class="built_in">UIColor</span> redColor];</span><br><span class="line">[<span class="keyword">self</span> addChildrenController:firstViewController</span><br><span class="line">            locateSubViewBlock:^(<span class="built_in">UIView</span> * _Nonnull parentControllerRootView, <span class="built_in">UIView</span> * _Nonnull childControllerRootView) &#123;</span><br><span class="line">    childControllerRootView.frame = parentControllerRootView.frame;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="built_in">UIViewController</span> *secondViewController = [<span class="built_in">UIViewController</span> new];</span><br><span class="line">secondViewController.view.backgroundColor = [<span class="built_in">UIColor</span> yellowColor];</span><br><span class="line">secondViewController.view.frame = <span class="keyword">self</span>.view.frame;</span><br><span class="line"><span class="keyword">self</span>.currentViewController = firstViewController;</span><br></pre></td></tr></table></figure>

<p>要切换的时候调用：</p>
<figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">[<span class="literal">self</span> changeControllerFromOldController:<span class="literal">self</span>.currentViewController <span class="keyword">to</span>NewController:secondViewController];</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)changeControllerFromOldController:(<span class="built_in">UIViewController</span> *)oldController toNewController:(<span class="built_in">UIViewController</span> *)newController &#123;</span><br><span class="line">    [<span class="keyword">self</span> addChildViewController:newController];</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span> transitionFromViewController:oldController toViewController:newController duration:<span class="number">8</span> options:<span class="built_in">UIViewAnimationOptionTransitionCurlUp</span> animations:^&#123;</span><br><span class="line">        </span><br><span class="line">    &#125; completion:^(<span class="type">BOOL</span> finished) &#123;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">if</span> (finished) &#123;</span><br><span class="line">            <span class="comment">//移除oldController，但在removeFromParentViewController：方法前不会调用willMoveToParentViewController:nil 方法，所以需要显示调用</span></span><br><span class="line">            [newController didMoveToParentViewController:<span class="keyword">self</span>];</span><br><span class="line">            [oldController willMoveToParentViewController:<span class="literal">nil</span>];</span><br><span class="line">            [oldController removeFromParentViewController];</span><br><span class="line">            <span class="keyword">self</span>.currentViewController = newController;</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.currentViewController = oldController;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果不是非常理解，大家还可以查看这篇博客:<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1156152">iOS addChildViewController方法</a></p>
<h6 id="2-UIViewController之间跳转的转场动画"><a href="#2-UIViewController之间跳转的转场动画" class="headerlink" title="2. UIViewController之间跳转的转场动画"></a><strong><strong>2. UIViewController之间跳转的转场动画</strong></strong></h6><p>在iOS中一个ViewController又被称为一个场景，转场动画就是两个场景之间切换时候的动画，iOS已经默认为我们提供了四种转场动画，可以通过UIViewController的modalTransitionStyle属性来指定：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, <span class="built_in">UIModalTransitionStyle</span>) &#123;</span><br><span class="line">    <span class="built_in">UIModalTransitionStyleCoverVertical</span> = <span class="number">0</span>,    <span class="comment">//从下向上弹起</span></span><br><span class="line">    <span class="built_in">UIModalTransitionStyleFlipHorizontal</span>,       <span class="comment">//水平翻转</span></span><br><span class="line">    <span class="built_in">UIModalTransitionStyleCrossDissolve</span>,        <span class="comment">//渐隐渐现</span></span><br><span class="line">    <span class="built_in">UIModalTransitionStylePartialCurl</span>,          <span class="comment">//翻页</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>有些情况下这些转场动画并不能满足我们产品的需求这时候就需要我们自定义转场动画来满足了。iOS中的场景切换是一个蛮强大的一个模块，下面是整个模块的关系图，后面会针对这个图进行梳理：</p>
<p><img src="/2019/08/08/iOS-%E5%8A%A8%E7%94%BB%E6%80%BB%E7%BB%93/00005.png"></p>
<h6 id="2-1-Present-x2F-Dismiss-动画"><a href="#2-1-Present-x2F-Dismiss-动画" class="headerlink" title="2.1 Present &#x2F; Dismiss 动画"></a><strong><strong>2.1 Present &#x2F; Dismiss 动画</strong></strong></h6><p>首先我们以最常见的一个ViewController present 另外一个ViewController 为例子：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 代码触发一个presentViewController。</span><br><span class="line"><span class="number">2.</span> UIKit询问要过渡到的target ViewController 是否有自定义的过渡动画代理。如果没有，则UIKit将使用iOS自带的过渡动画</span><br><span class="line"><span class="number">3.</span> 如果有过渡动画代理，UIKit则会通过过渡动画代理transitioningDelegate，获取到动画控制器。比如通过 animation<span class="constructor">ControllerForPresentedController(<span class="params">_</span>:<span class="params">presentingController</span>:<span class="params">sourceController</span>:)</span>方法获取到动画控制器，如果返回空，则使用默认的动画控制器。</span><br><span class="line"><span class="number">4.</span> 一旦找到了动画控制器，UIKit构建上下文对象UIViewControllerContextTransitioning。</span><br><span class="line"><span class="number">5.</span> 接着，UIKit通过动画控制器UIViewControllerContextTransitioning 的 transition<span class="constructor">Duration(<span class="params">_</span>:)</span>方法获取动画执行时长。</span><br><span class="line"><span class="number">6.</span> 再接着调用动画控制器的animate<span class="constructor">Transition(<span class="params">_</span>:)</span>完成过渡动画。</span><br><span class="line"><span class="number">7.</span> 最后动画控制器调用上下文对象的complete<span class="constructor">Transition(<span class="params">_</span>:)</span>方法指示动画完成。</span><br></pre></td></tr></table></figure>

<p>这里也介绍下一个最初困惑我比较久的概念presentingViewController&#x2F;presentedViewController</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">假如我们有两个 VC <span class="selector-tag">A</span>/<span class="selector-tag">B</span>，我们要从<span class="selector-tag">A</span>转换到<span class="selector-tag">B</span>，我们称<span class="selector-tag">A</span>为presentingViewController，称<span class="selector-tag">B</span> presentedViewController，当从 <span class="selector-tag">B</span> 结束转换回到 <span class="selector-tag">A</span> 时，我们仍然称呼 <span class="selector-tag">A</span> 为 presentingViewController，<span class="selector-tag">B</span> 为 presentedViewController。这是让我每次比较懵逼的地方。</span><br></pre></td></tr></table></figure>

<p>再说得详细点：</p>
<ul>
<li><strong><strong>presentingViewController[负责呈现的ViewController]</strong></strong></li>
</ul>
<p>关于presentingViewController 官方的说明如下：</p>
<blockquote>
<p>The view controller that presented this view controller.<br>When you present a view controller modally (either explicitly or implicitly) using the presentViewController:animated:completion: method, the view controller that was presented has this property set to the view controller that presented it. If the view controller was not presented modally, but one of its ancestors was, this property contains the view controller that presented the ancestor. If neither the current view controller or any of its ancestors were presented modally, the value in this property is nil.</p>
</blockquote>
<p>也就是说如果我们沿着viewController堆栈，但凡有一个是通过 <strong><strong>presentViewController:animated:completion:</strong></strong> 方法推出的，那么presentingViewController 的值就是推出的堆栈的起点viewController.也就是说只有在调用<strong><strong>presentViewController:animated:completion:</strong></strong> 的时候才会更改这个值，如果通过push的话，就会继承操作的发起者的presentingViewController值。</p>
<p>举个简单的例子：</p>
<p>有五个控制器 ABCDEF，应用启动首先显示RootViewController A，之后A通过present方式推出带导航栏的B，B再通过push的方式推出C，C再通过push的方式推出D，D再通过push的方式推出E，那么E的 presentingViewController 就是 B。上面例子中只有B是通过present方式推出的，且B是CDE的父级，那么 D 的presentingViewController也将是B。</p>
<ul>
<li><strong><strong>presentedViewController[被呈现的ViewController]</strong></strong></li>
</ul>
<p>关于presentedViewController 官方的说明如下：</p>
<blockquote>
<p>The view controller that is presented by this view controller, or one of its ancestors in the view controller hierarchy.<br>When you present a view controller modally (either explicitly or implicitly) using the presentViewController:animated:completion: method, the view controller that called the method has this property set to the view controller that it presented. If the current view controller did not present another view controller modally, the value in this property is nil.</p>
</blockquote>
<p>也就是你通过present模态推出了谁，你的presentedViewController就是谁.</p>
<p>OK 回到转场动画的解释上来：</p>
<p>下面以一个例子来说明如何自定义一个转场动画：</p>
<p>正常情况下我们跳转页面代码如下：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">IDLTargetViewController * targetViewController = [IDLTargetViewController new];</span><br><span class="line">[<span class="keyword">self</span> presentViewController:targetViewController animated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure>

<p>但是上面由于没有自定transitioningDelegate所以用的是系统的默认转场动画也就是从下往上弹出，我们现在要自定义转场动画，就需要指定一个transitioningDelegate，这样系统在跳转的时候就会从transitioningDelegate获取对应的遵循UIViewControllerAnimatedTransitioning协议的对象。</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">targetViewController.transitioningDelegate</span> = [[IDLTransitionDelegate alloc] init]<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>我们先来看UIViewControllerTransitioningDelegate协议中的几个函数：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这个函数用来设置当执行present方法时 进行的转场动画</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="type">id</span> &lt;<span class="built_in">UIViewControllerAnimatedTransitioning</span>&gt;)animationControllerForPresentedController:(<span class="built_in">UIViewController</span> *)presented presentingController:(<span class="built_in">UIViewController</span> *)presenting sourceController:(<span class="built_in">UIViewController</span> *)source;</span><br><span class="line"><span class="comment">//这个函数用来设置当执行dismiss方法时 进行的转场动画</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="type">id</span> &lt;<span class="built_in">UIViewControllerAnimatedTransitioning</span>&gt;)animationControllerForDismissedController:(<span class="built_in">UIViewController</span> *)dismissed;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个函数用来设置当执行present方法时 进行可交互的转场动画</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="type">id</span> &lt;<span class="built_in">UIViewControllerInteractiveTransitioning</span>&gt;)interactionControllerForPresentation:(<span class="type">id</span> &lt;<span class="built_in">UIViewControllerAnimatedTransitioning</span>&gt;)animator;</span><br><span class="line"><span class="comment">//这个函数用来设置当执行dismiss方法时 进行可交互的转场动画</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="type">id</span> &lt;<span class="built_in">UIViewControllerInteractiveTransitioning</span>&gt;)interactionControllerForDismissal:(<span class="type">id</span> &lt;<span class="built_in">UIViewControllerAnimatedTransitioning</span>&gt;)animator;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回UIPresentationController处理转场</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">UIPresentationController</span> *)presentationControllerForPresentedViewController:(<span class="built_in">UIViewController</span> *)presented presentingViewController:(<span class="keyword">nullable</span> <span class="built_in">UIViewController</span> *)presenting sourceViewController:(<span class="built_in">UIViewController</span> *)source <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">8</span>_0);</span><br></pre></td></tr></table></figure>

<p>这里我们只实现present动画那么只需要在IDLTransitionDelegate中实现animationControllerForPresentedController方法。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">nullable</span> <span class="type">id</span> &lt;<span class="built_in">UIViewControllerAnimatedTransitioning</span>&gt;)animationControllerForPresentedController:(<span class="built_in">UIViewController</span> *)presented presentingController:(<span class="built_in">UIViewController</span> *)presenting sourceController:(<span class="built_in">UIViewController</span> *)source&#123;</span><br><span class="line">    <span class="keyword">return</span> [IDLPresenteContentController new];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>IDLPresenteContentController是一个实现了UIViewControllerAnimatedTransitioning协议的对象。它用于提供动画事件，动画上下文的对象。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这个函数用来设置动画执行的时长</span></span><br><span class="line">- (<span class="built_in">NSTimeInterval</span>)transitionDuration:(<span class="keyword">nullable</span> <span class="type">id</span> &lt;<span class="built_in">UIViewControllerContextTransitioning</span>&gt;)transitionContext&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这个函数用来处理具体的动画</span></span><br><span class="line">- (<span class="type">void</span>)animateTransition:(<span class="type">id</span> &lt;<span class="built_in">UIViewControllerContextTransitioning</span>&gt;)transitionContext &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.获取动画的源控制器和目标控制器</span></span><br><span class="line">    ViewController *fromVC = [transitionContext viewControllerForKey:<span class="built_in">UITransitionContextFromViewControllerKey</span>];</span><br><span class="line">    DetailViewController *toVC = [transitionContext viewControllerForKey:<span class="built_in">UITransitionContextToViewControllerKey</span>];</span><br><span class="line">    <span class="built_in">UIView</span> *container = [transitionContext containerView];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.创建一个imageView 的截图，并把 imageView 隐藏，造成使用户以为移动的就是 imageView 的假象</span></span><br><span class="line">    <span class="built_in">UIView</span> *snapshotView = [fromVC.ImageView snapshotViewAfterScreenUpdates:<span class="literal">NO</span>];</span><br><span class="line">    <span class="comment">//计算fromVC.view上的fromVC.ImageView.frame相对于container的坐标</span></span><br><span class="line">    snapshotView.frame = [container convertRect:fromVC.ImageView.frame fromView:fromVC.view];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3.设置目标控制器的位置，并把透明度设为0，在后面的动画中慢慢显示出来变为1</span></span><br><span class="line">    toVC.view.frame = [transitionContext finalFrameForViewController:toVC];</span><br><span class="line">    toVC.view.alpha = <span class="number">0</span>;</span><br><span class="line">    toVC.bgImageView.hidden = <span class="literal">YES</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//4.都添加到 container 中。注意顺序不能错了</span></span><br><span class="line">    [container addSubview:toVC.view];</span><br><span class="line">    [container addSubview:snapshotView];</span><br><span class="line">    </span><br><span class="line">    [<span class="built_in">UIView</span> animateWithDuration:[<span class="keyword">self</span> transitionDuration:transitionContext] delay:<span class="number">0</span> options:<span class="built_in">UIViewAnimationOptionCurveEaseInOut</span> animations:^&#123;</span><br><span class="line">        snapshotView.frame = [container convertRect:toVC.bgImageView.frame fromView:toVC.view];</span><br><span class="line">        fromVC.view.alpha = <span class="number">0</span>;</span><br><span class="line">        toVC.view.alpha = <span class="number">1</span>;</span><br><span class="line">    &#125; completion:^(<span class="type">BOOL</span> finished) &#123;</span><br><span class="line">        fromVC.ImageView.hidden = <span class="literal">NO</span>;</span><br><span class="line">        toVC.bgImageView.hidden = <span class="literal">NO</span>;</span><br><span class="line">        [snapshotView removeFromSuperview];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//一定要记得动画完成后执行此方法，让系统管理 navigation 如果设置为no。可以自己试试</span></span><br><span class="line">        [transitionContext completeTransition:<span class="literal">YES</span>];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里最重要的就是animateTransition方法，这个方法的参数中transitionContext也是关键中的关键，可以通过viewControllerForKey在transitionContext中取出跳转的ViewController，可以通过viewForKey获取到对应的view，还可以通过它来获得动画事件等。在animateTransition方法中一般是如下步骤实现整个动画的：</p>
<ol>
<li>通过viewControllerForKey&#x2F;viewForKey获取所有需要的 view 以及 VC</li>
<li>设定fromView, toView的初始状态</li>
<li>将toView通过addSubview 添加到 containerView </li>
<li>获取动画时间</li>
<li>设定动画</li>
<li>在动画结束的时候调用[transitionContext completeTransition:YES]来结束动画。</li>
</ol>
<p>从上面可以看出transitionContext是一个十分关键的地方，它用于提供动画过程中所需要的各种数据，我们来看下它的声明：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">//容器视图 用来表现动画</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">UIView</span> *containerView;</span><br><span class="line"><span class="comment">//下面是几个只读属性</span></span><br><span class="line"><span class="comment">//是否应该执行动画</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">getter</span>=isAnimated) <span class="type">BOOL</span> animated;</span><br><span class="line"><span class="comment">//是否是可交互的</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">getter</span>=isInteractive) <span class="type">BOOL</span> interactive; <span class="comment">// This indicates whether the transition is currently interactive.</span></span><br><span class="line"><span class="comment">//是否被取消了</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="type">BOOL</span> transitionWasCancelled;</span><br><span class="line"><span class="comment">//转场风格</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">UIModalPresentationStyle</span> presentationStyle;</span><br><span class="line"><span class="comment">//调用这个函数来更新转场过程的百分比 用于可交互动画的阈值</span></span><br><span class="line">- (<span class="type">void</span>)updateInteractiveTransition:(<span class="built_in">CGFloat</span>)percentComplete;</span><br><span class="line"><span class="comment">//完成可交互的转场交互动作时调用</span></span><br><span class="line">- (<span class="type">void</span>)finishInteractiveTransition;</span><br><span class="line"><span class="comment">//取消可交互的转场交互动作时调用</span></span><br><span class="line">- (<span class="type">void</span>)cancelInteractiveTransition;</span><br><span class="line"><span class="comment">//转场动画被中断  暂停时调用</span></span><br><span class="line">- (<span class="type">void</span>)pauseInteractiveTransition;</span><br><span class="line"><span class="comment">//转场动画完成时调用</span></span><br><span class="line">- (<span class="type">void</span>)completeTransition:(<span class="type">BOOL</span>)didComplete;</span><br><span class="line"><span class="comment">//获取转场中的两个视图控制器</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">UITransitionContextViewControllerKey的定义</span></span><br><span class="line"><span class="comment">UITransitionContextFromViewControllerKey  //原视图控制器</span></span><br><span class="line"><span class="comment">UITransitionContextToViewControllerKey    //跳转的视图控制器</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">- (<span class="keyword">nullable</span> __kindof <span class="built_in">UIViewController</span> *)viewControllerForKey:(<span class="built_in">UITransitionContextViewControllerKey</span>)key;</span><br><span class="line"><span class="comment">//直接获取转场中的视图</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">UITransitionContextFromViewKey  //原视图</span></span><br><span class="line"><span class="comment">UITransitionContextToViewKey    //转场的视图</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">- (<span class="keyword">nullable</span> __kindof <span class="built_in">UIView</span> *)viewForKey:(<span class="built_in">UITransitionContextViewKey</span>)key;</span><br><span class="line"><span class="comment">//获取视图控制器的初识位置</span></span><br><span class="line">- (<span class="built_in">CGRect</span>)initialFrameForViewController:(<span class="built_in">UIViewController</span> *)vc;</span><br><span class="line"><span class="comment">//获取视图控制器转场后的位置</span></span><br><span class="line">- (<span class="built_in">CGRect</span>)finalFrameForViewController:(<span class="built_in">UIViewController</span> *)vc;</span><br></pre></td></tr></table></figure>

<h6 id="2-2-Interactive-交互动画"><a href="#2-2-Interactive-交互动画" class="headerlink" title="2.2 Interactive 交互动画"></a><strong><strong>2.2 Interactive 交互动画</strong></strong></h6><p>上面仅仅介绍的是present动画，但是iOS还支持交互动画，也就是通过手势等界面交互来触发动画。</p>
<p>有了上面的介绍接下来的介绍会稍稍简单点：</p>
<p>首先我们还是先设置transitioningDelegate，并在上面IDLTransitionDelegate中添加如下方法实现：</p>
<figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line"><span class="operator">-</span> (nullable <span class="built_in">id</span> <span class="operator">&lt;</span>UIViewControllerInteractiveTransitioning<span class="operator">&gt;</span>)interactionControllerForDismissal<span class="operator">:</span>(<span class="built_in">id</span> <span class="operator">&lt;</span>UIViewControllerAnimatedTransitioning<span class="operator">&gt;</span>)animator&#123;</span><br><span class="line">    <span class="keyword">return</span> [IDLInteractiveTransition <span class="keyword">new</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来实现 IDLInteractiveTransition</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)startInteractiveTransition:(<span class="type">id</span>&lt;<span class="built_in">UIViewControllerContextTransitioning</span>&gt;)transitionContext &#123;</span><br><span class="line">    <span class="comment">// 把 context 对象保存起来</span></span><br><span class="line">    <span class="keyword">self</span>.transitionContext = transitionContext;</span><br><span class="line">    [<span class="variable language_">super</span> startInteractiveTransition:transitionContext];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据手势的偏移来计算当前动画应该有的完成度</span></span><br><span class="line">- (<span class="built_in">CGFloat</span>)percentForGesture:(<span class="built_in">UIScreenEdgePanGestureRecognizer</span> *)gesture &#123;</span><br><span class="line">    <span class="comment">// 根据 container view 以及 gesture recognizer 计算偏移量</span></span><br><span class="line">    <span class="built_in">UIView</span> *transitionContainerView = <span class="keyword">self</span>.transitionContext.containerView;</span><br><span class="line">    <span class="built_in">CGPoint</span> locationInSourceView = [gesture locationInView:transitionContainerView];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据偏移量得出百分比</span></span><br><span class="line">    <span class="built_in">CGFloat</span> width = <span class="built_in">CGRectGetWidth</span>(transitionContainerView.bounds);</span><br><span class="line">    <span class="keyword">return</span> (width - locationInSourceView.x) / width;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// gesture recognizer 的回调</span></span><br><span class="line">- (<span class="keyword">IBAction</span>)gestureRecognizeDidUpdate:(<span class="built_in">UIScreenEdgePanGestureRecognizer</span> *)gestureRecognizer &#123;</span><br><span class="line">    <span class="keyword">switch</span> (gestureRecognizer.state)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIGestureRecognizerStateBegan</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIGestureRecognizerStateChanged</span>:</span><br><span class="line">            <span class="comment">// 计算百分比，并返回</span></span><br><span class="line">            [<span class="keyword">self</span>.transitionContext updateInteractiveTransition:[<span class="keyword">self</span> percentForGesture:gestureRecognizer]];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIGestureRecognizerStateEnded</span>:</span><br><span class="line">            <span class="comment">// 根据预先设定的阈值决定是结束还是取消，这里我们设定 view 中间是分界线</span></span><br><span class="line">            <span class="keyword">if</span> ([<span class="keyword">self</span> percentForGesture:gestureRecognizer] &gt;= <span class="number">0.5</span>f)</span><br><span class="line">                [<span class="keyword">self</span>.transitionContext finishInteractiveTransition];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                [<span class="keyword">self</span>.transitionContext cancelInteractiveTransition];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="comment">// 其他情况，取消转场</span></span><br><span class="line">            [<span class="keyword">self</span>.transitionContext cancelInteractiveTransition];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面是通过自己实现一个遵循UIViewControllerInteractiveTransitioning协议的对象，当然也可以通过系统为我们提供的UIPercentDrivenInteractiveTransition来简化代码</p>
<h6 id="2-3-UIPresentationController-实现弹窗效果"><a href="#2-3-UIPresentationController-实现弹窗效果" class="headerlink" title="2.3 UIPresentationController 实现弹窗效果"></a><strong><strong>2.3 UIPresentationController 实现弹窗效果</strong></strong></h6><p>UIPresentationController 有很多属性下面将比较重要的给抠出来给大家介绍：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">UIPresentationController</span> : <span class="title">NSObject</span> &lt;<span class="title">UIAppearanceContainer</span>, <span class="title">UITraitEnvironment</span>, <span class="title">UIContentContainer</span>, <span class="title">UIFocusEnvironment</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//这个概念见文章上面介绍</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="built_in">UIViewController</span> *presentingViewController; </span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="built_in">UIViewController</span> *presentedViewController;</span><br><span class="line"><span class="comment">//弹窗的模态形式</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">UIModalPresentationStyle</span> presentationStyle;</span><br><span class="line"><span class="comment">// 转场发生的容器视图</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">strong</span>) <span class="built_in">UIView</span> *containerView;</span><br><span class="line"><span class="comment">// 初始化方法</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithPresentedViewController:(<span class="built_in">UIViewController</span> *)presentedViewController presentingViewController:(<span class="keyword">nullable</span> <span class="built_in">UIViewController</span> *)presentingViewController <span class="built_in">NS_DESIGNATED_INITIALIZER</span>;</span><br><span class="line"><span class="comment">// 动画容器布局，可以在这里布局子元素</span></span><br><span class="line">- (<span class="type">void</span>)containerViewWillLayoutSubviews;</span><br><span class="line">- (<span class="type">void</span>)containerViewDidLayoutSubviews;</span><br><span class="line"><span class="comment">//presentView的位置参数</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">CGRect</span> frameOfPresentedViewInContainerView;</span><br><span class="line"><span class="comment">//呈现动画时机回调</span></span><br><span class="line">- (<span class="type">void</span>)presentationTransitionWillBegin;</span><br><span class="line">- (<span class="type">void</span>)presentationTransitionDidEnd:(<span class="type">BOOL</span>)completed;</span><br><span class="line">- (<span class="type">void</span>)dismissalTransitionWillBegin;</span><br><span class="line">- (<span class="type">void</span>)dismissalTransitionDidEnd:(<span class="type">BOOL</span>)completed;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>下面是一个使用例子：</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@interface</span> <span class="attribute">IDLPopPresentationController </span>: UIPresentationController&lt;UIViewControllerTransitioningDelegate,UIViewControllerAnimatedTransitioning&gt;</span><br><span class="line"></span><br><span class="line"><span class="variable">@property</span> (nonatomic, strong, readonly) RACSubject *dissmissSignal;</span><br><span class="line"></span><br><span class="line"><span class="variable">@end</span></span><br></pre></td></tr></table></figure>

<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="meta">@implementation</span> <span class="type">IDLPopPresentationController</span></span><br><span class="line"></span><br><span class="line">#pragma mark overide <span class="type">UIPresentationController</span></span><br><span class="line"><span class="operator">-</span> (instancetype)initWithPresentedViewController:(<span class="type">UIViewController</span> <span class="operator">*</span>)presentedViewController presentingViewController:(<span class="type">UIViewController</span> <span class="operator">*</span>)presentingViewController &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> <span class="operator">=</span> [<span class="keyword">super</span> initWithPresentedViewController:presentedViewController presentingViewController:presentingViewController]) &#123;</span><br><span class="line">        presentedViewController.modalPresentationStyle <span class="operator">=</span> <span class="type">UIModalPresentationCustom</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="operator">-</span> (void)dealloc &#123;</span><br><span class="line">    [<span class="keyword">self</span>.dissmissSignal sendCompleted];</span><br><span class="line">    <span class="keyword">self</span>.dissmissSignal <span class="operator">=</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="operator">-</span> (void)presentationTransitionWillBegin &#123;</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span>.containerView addSubview:<span class="keyword">self</span>.dimmingView];</span><br><span class="line">    [<span class="keyword">self</span>.dimmingView addSubview:<span class="keyword">self</span>.closeBtn];</span><br><span class="line">    [<span class="keyword">self</span>.closeBtn nm_makeFrame:<span class="operator">^</span>(<span class="type">NMFrameMaker</span> <span class="operator">*</span>make) &#123;</span><br><span class="line">        make.right.equalTo(<span class="keyword">self</span>.dimmingView).margin(<span class="number">25</span>);</span><br><span class="line">        make.top.equalTo(<span class="keyword">self</span>.dimmingView).margin(<span class="number">40</span>);</span><br><span class="line">        make.size.nm_equalTo(<span class="type">CGSizeMake</span>(<span class="number">20</span>, <span class="number">20</span>));</span><br><span class="line">    &#125;];</span><br><span class="line">    <span class="meta">@weakify</span>(<span class="keyword">self</span>);</span><br><span class="line">    [<span class="keyword">self</span>.closeBtn addTapBlock:<span class="operator">^</span>(id obj) &#123;</span><br><span class="line">        <span class="meta">@strongify</span>(<span class="keyword">self</span>);</span><br><span class="line">        [<span class="keyword">self</span>.presentingViewController dismissViewControllerAnimated:<span class="type">YES</span> completion:<span class="literal">nil</span>];</span><br><span class="line">        [<span class="keyword">self</span>.dissmissSignal sendNext:<span class="literal">nil</span>];</span><br><span class="line">        [<span class="keyword">self</span>.dissmissSignal sendCompleted];</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//背景 self.dimmingView 的淡入效果与过渡效果一起执</span></span><br><span class="line">    id<span class="operator">&lt;</span><span class="type">UIViewControllerTransitionCoordinator</span><span class="operator">&gt;</span> transitionCoordinator <span class="operator">=</span> <span class="keyword">self</span>.presentingViewController.transitionCoordinator;</span><br><span class="line">    [transitionCoordinator animateAlongsideTransition:<span class="operator">^</span>(id<span class="operator">&lt;</span><span class="type">UIViewControllerTransitionCoordinatorContext</span><span class="operator">&gt;</span> context) &#123;</span><br><span class="line">        <span class="meta">@strongify</span>(<span class="keyword">self</span>);</span><br><span class="line">        <span class="keyword">self</span>.dimmingView.alpha <span class="operator">=</span> <span class="number">0</span>.65f;</span><br><span class="line">    &#125; completion:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="operator">-</span> (void)presentationTransitionDidEnd:(<span class="type">BOOL</span>)completed &#123;</span><br><span class="line">    <span class="comment">//如果呈现没有完成，那就移除背景 View</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="operator">!</span>completed)&#123;</span><br><span class="line">        [<span class="keyword">self</span>.dimmingView removeFromSuperview];</span><br><span class="line">        <span class="keyword">self</span>.dimmingView <span class="operator">=</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="operator">-</span> (void)dismissalTransitionWillBegin &#123;</span><br><span class="line">    id<span class="operator">&lt;</span><span class="type">UIViewControllerTransitionCoordinator</span><span class="operator">&gt;</span> coordinator <span class="operator">=</span> <span class="keyword">self</span>.presentingViewController.transitionCoordinator;</span><br><span class="line">    <span class="meta">@weakify</span>(<span class="keyword">self</span>);</span><br><span class="line">    [coordinator animateAlongsideTransition:<span class="operator">^</span>(id<span class="operator">&lt;</span><span class="type">UIViewControllerTransitionCoordinatorContext</span><span class="operator">&gt;</span> context) &#123;</span><br><span class="line">        <span class="meta">@strongify</span>(<span class="keyword">self</span>);</span><br><span class="line">        <span class="keyword">self</span>.dimmingView.alpha <span class="operator">=</span> <span class="number">0.0</span>;</span><br><span class="line">    &#125; completion:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="operator">-</span> (void)dismissalTransitionDidEnd:(<span class="type">BOOL</span>)completed &#123;</span><br><span class="line">    <span class="keyword">if</span>(completed) &#123;</span><br><span class="line">        [<span class="keyword">self</span>.dimmingView removeFromSuperview];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Notifies an interested controller that the preferred content size of one of its children changed.</span></span><br><span class="line"><span class="operator">-</span> (void)preferredContentSizeDidChangeForChildContentContainer:(id<span class="operator">&lt;</span><span class="type">UIContentContainer</span><span class="operator">&gt;</span>)container &#123;</span><br><span class="line">    [<span class="keyword">super</span> preferredContentSizeDidChangeForChildContentContainer:container];</span><br><span class="line">    <span class="keyword">if</span> (container <span class="operator">==</span> <span class="keyword">self</span>.presentedViewController) &#123;</span><br><span class="line">        [<span class="keyword">self</span>.containerView setNeedsLayout];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="operator">-</span> (void)containerViewWillLayoutSubviews &#123;</span><br><span class="line">    [<span class="keyword">super</span> containerViewWillLayoutSubviews];</span><br><span class="line">    <span class="keyword">self</span>.dimmingView.frame <span class="operator">=</span> <span class="keyword">self</span>.containerView.bounds;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="operator">-</span> (<span class="type">CGRect</span>)frameOfPresentedViewInContainerView &#123;</span><br><span class="line">    <span class="comment">//要呈现的ViewController区域</span></span><br><span class="line">    <span class="keyword">return</span> <span class="type">CGRectMake</span>(<span class="number">15</span>.f, <span class="number">73</span>.f, <span class="type">SCREEN_MIN_LENGTH</span> <span class="operator">-</span> <span class="number">30</span>.f , <span class="type">SCREEN_MAX_LENGTH</span> <span class="operator">-</span> <span class="number">103</span>.f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark <span class="type">UIViewControllerTransitioningDelegate</span></span><br><span class="line"></span><br><span class="line"><span class="operator">-</span> (<span class="type">UIPresentationController</span><span class="operator">*</span> )presentationControllerForPresentedViewController:(<span class="type">UIViewController</span> <span class="operator">*</span>)presented</span><br><span class="line">                                                      presentingViewController:(<span class="type">UIViewController</span> <span class="operator">*</span>)presenting</span><br><span class="line">                                                          sourceViewController:(<span class="type">UIViewController</span> <span class="operator">*</span>)source &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="operator">-</span> (id<span class="operator">&lt;</span><span class="type">UIViewControllerAnimatedTransitioning</span><span class="operator">&gt;</span>)animationControllerForPresentedController:(<span class="type">UIViewController</span> <span class="operator">*</span>)presented</span><br><span class="line">                                                                  presentingController:(<span class="type">UIViewController</span> <span class="operator">*</span>)presenting</span><br><span class="line">                                                                      sourceController:(<span class="type">UIViewController</span> <span class="operator">*</span>)source &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="operator">-</span> (id<span class="operator">&lt;</span><span class="type">UIViewControllerAnimatedTransitioning</span><span class="operator">&gt;</span>)animationControllerForDismissedController:(<span class="type">UIViewController</span> <span class="operator">*</span>)dismissed &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark <span class="operator">-</span> <span class="type">UIViewControllerAnimatedTransitioning</span></span><br><span class="line"><span class="operator">-</span> (<span class="type">NSTimeInterval</span>)transitionDuration:(id<span class="operator">&lt;</span><span class="type">UIViewControllerContextTransitioning</span><span class="operator">&gt;</span>)transitionContext &#123;</span><br><span class="line">    <span class="keyword">return</span> [transitionContext isAnimated] <span class="operator">?</span> <span class="number">0.3</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="operator">-</span> (void)animateTransition:(id<span class="operator">&lt;</span><span class="type">UIViewControllerContextTransitioning</span><span class="operator">&gt;</span>)transitionContext &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">UIViewController</span> <span class="operator">*</span>fromViewController <span class="operator">=</span> [transitionContext viewControllerForKey:<span class="type">UITransitionContextFromViewControllerKey</span>];</span><br><span class="line">    </span><br><span class="line">    __block <span class="type">UIView</span> <span class="operator">*</span>toView <span class="operator">=</span> [transitionContext viewForKey:<span class="type">UITransitionContextToViewKey</span>];</span><br><span class="line">    __block <span class="type">UIView</span> <span class="operator">*</span>fromView <span class="operator">=</span> [transitionContext viewForKey:<span class="type">UITransitionContextFromViewKey</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="type">UIView</span> <span class="operator">*</span>containerView <span class="operator">=</span> transitionContext.containerView;</span><br><span class="line">    [containerView addSubview:toView];</span><br><span class="line">    </span><br><span class="line">    <span class="type">BOOL</span> isPresenting <span class="operator">=</span> (fromViewController <span class="operator">==</span> <span class="keyword">self</span>.presentingViewController);</span><br><span class="line">    <span class="keyword">if</span> (isPresenting) &#123;</span><br><span class="line">        toView.frame <span class="operator">=</span> [<span class="keyword">self</span> frameOfPresentedViewInContainerView];</span><br><span class="line">        toView.alpha <span class="operator">=</span> <span class="keyword">self</span>.closeBtn.alpha <span class="operator">=</span> <span class="number">0</span>.0f;</span><br><span class="line">        toView.layer.masksToBounds <span class="operator">=</span> <span class="type">YES</span>;</span><br><span class="line">        toView.layer.cornerRadius <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">NSTimeInterval</span> duration <span class="operator">=</span> [<span class="keyword">self</span> transitionDuration:transitionContext];</span><br><span class="line">    [<span class="type">UIView</span> animateWithDuration:duration animations:<span class="operator">^</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isPresenting) &#123;</span><br><span class="line">            toView.alpha <span class="operator">=</span> <span class="keyword">self</span>.closeBtn.alpha <span class="operator">=</span> <span class="number">1</span>.0f;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fromView.alpha <span class="operator">=</span> <span class="keyword">self</span>.closeBtn.alpha <span class="operator">=</span> <span class="number">0</span>.0f;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; completion:<span class="operator">^</span>(<span class="type">BOOL</span> finished) &#123;</span><br><span class="line">        <span class="type">BOOL</span> wasCancelled <span class="operator">=</span> [transitionContext transitionWasCancelled];</span><br><span class="line">        [transitionContext completeTransition:<span class="operator">!</span>wasCancelled];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="operator">-</span> (void)animationEnded:(<span class="type">BOOL</span>) transitionCompleted &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#pragma mark <span class="type">Getter</span><span class="operator">/</span><span class="type">Setters</span></span><br><span class="line"></span><br><span class="line"><span class="operator">-</span> (<span class="type">UIView</span> <span class="operator">*</span>)dimmingView &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="operator">!</span>_dimmingView) &#123;</span><br><span class="line">        _dimmingView <span class="operator">=</span> [[<span class="type">UIView</span> alloc] initWithFrame:<span class="keyword">self</span>.containerView.bounds];</span><br><span class="line">        _dimmingView.alpha <span class="operator">=</span> <span class="number">0</span>.0f;</span><br><span class="line">        _dimmingView.backgroundColor <span class="operator">=</span> [<span class="type">UIColor</span> colorWithWhite:<span class="number">0</span>.0f alpha:<span class="number">0</span>.65f];</span><br><span class="line">        _dimmingView.autoresizingMask <span class="operator">=</span> <span class="type">UIViewAutoresizingFlexibleWidth</span><span class="operator">|</span><span class="type">UIViewAutoresizingFlexibleHeight</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _dimmingView;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="operator">-</span> (<span class="type">NMFocusExpandView</span> <span class="operator">*</span>)closeBtn &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="operator">!</span>_closeBtn) &#123;</span><br><span class="line">        _closeBtn <span class="operator">=</span> [[<span class="type">NMFocusExpandView</span> alloc] initWithFrame:<span class="type">CGRectZero</span>];</span><br><span class="line">        [_closeBtn setImage:<span class="type">NMImage</span>.login_instagram_close_icon];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _closeBtn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="operator">-</span> (<span class="type">RACSubject</span> <span class="operator">*</span>)dissmissSignal &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="operator">!</span>_dissmissSignal) &#123;</span><br><span class="line">        _dissmissSignal <span class="operator">=</span> [<span class="type">RACSubject</span> subject];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _dissmissSignal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用方法</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">IDLPopPresentationController *presentationController = [[IDLPopPresentationController alloc] initWithPresentedViewController:instagramLoginViewController</span><br><span class="line">                                                                                                    presentingViewController:<span class="keyword">self</span>];</span><br><span class="line">instagramLoginViewController.transitioningDelegate = presentationController;</span><br><span class="line">[<span class="keyword">self</span> presentViewController:instagramLoginViewController animated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure>

<h6 id="3-转场动画深入文章推荐"><a href="#3-转场动画深入文章推荐" class="headerlink" title="3 转场动画深入文章推荐"></a><strong><strong>3 转场动画深入文章推荐</strong></strong></h6><p>关于转场动画是一个十分大的一个话题，该博客只是帮大家理清楚转场动画的整个过程，对于细节大家还需要深入去挖掘，这里推荐几个比较好的文章大家可以在后续学习中供大家深入学习：</p>
<ol>
<li><p><a target="_blank" rel="noopener" href="https://github.com/seedante/iOS-Note/wiki/ViewController-Transition">iOS 视图控制器转场详解 Github地址</a> <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/9333c5f983de">iOS 视图控制器转场详解 简书地址</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://my.oschina.net/u/2340880/blog/1839722">玩转iOS转场动画</a></p>
</li>
</ol>
  
	</div>
		<footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/iOS-%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/">iOS 理论基础</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/iOS-理论基础/">iOS 理论基础</a>
  </div>

</div>



</footer>

   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2019/08/10/iOS-KeyChain-总结/" title="iOS KeyChain 总结">
  <span>
  iOS KeyChain 总结</span>
</a>
</div>


<div class="next">
<a href="/2019/08/08/iOS-事件及手势处理流程/"  title="iOS 事件及手势处理流程">
 <span>iOS 事件及手势处理流程
</span>
</a>
</div>

</nav>

	
<section id="comments" class="comment">
	<div class="ds-thread" data-thread-key="2019/08/08/iOS-动画总结/" data-title="iOS 动画总结" data-url="http://yoursite.com/2019/08/08/iOS-%E5%8A%A8%E7%94%BB%E6%80%BB%E7%BB%93/"></div>
</section>


<section id="comments" class="comment">
  <div id="disqus_thread">
    <noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  </div>
</section>

</div>  
      <div class="openaside"><a class="navbutton" href="#" title="Show Sidebar"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">Contents</strong>
 
 <ol class="toc"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%80%E7%AF%87%E5%8F%A8%E5%8F%A8"><span class="toc-number">1.</span> <span class="toc-text">开篇叨叨</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#CAAnimation%E7%9A%84%E7%BB%A7%E6%89%BF%E7%BB%93%E6%9E%84"><span class="toc-number">2.</span> <span class="toc-text">CAAnimation的继承结构</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#CAAnimation"><span class="toc-number">2.1.</span> <span class="toc-text">CAAnimation</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#CAPropertyAnimation"><span class="toc-number">2.2.</span> <span class="toc-text">CAPropertyAnimation</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#CAAnimationGroup"><span class="toc-number">2.3.</span> <span class="toc-text">CAAnimationGroup</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#CATransition"><span class="toc-number">2.4.</span> <span class="toc-text">CATransition</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#CABasicAnimation"><span class="toc-number">2.5.</span> <span class="toc-text">CABasicAnimation</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#CAKeyframeAnimation"><span class="toc-number">2.6.</span> <span class="toc-text">CAKeyframeAnimation</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#CASpringAnimation"><span class="toc-number">2.7.</span> <span class="toc-text">CASpringAnimation</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#CoreAnimation%E7%9A%84%E4%BD%BF%E7%94%A8%E6%AD%A5%E9%AA%A4"><span class="toc-number">3.</span> <span class="toc-text">CoreAnimation的使用步骤</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#CGAffineTransform-%E4%BB%BF%E5%B0%84%E5%8F%98%E6%8D%A2"><span class="toc-number">4.</span> <span class="toc-text">CGAffineTransform 仿射变换</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#CATransform3D-3D%E5%8F%98%E6%8D%A2"><span class="toc-number">5.</span> <span class="toc-text">CATransform3D 3D变换</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8A%A8%E7%94%BB%E7%9A%84%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86"><span class="toc-number">6.</span> <span class="toc-text">动画的事务管理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8A%A8%E7%94%BB%E7%9B%B8%E5%85%B3%E7%9A%84CALayer"><span class="toc-number">7.</span> <span class="toc-text">动画相关的CALayer</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9A%90%E5%BC%8F%E5%8A%A8%E7%94%BB"><span class="toc-number">8.</span> <span class="toc-text">隐式动画</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#UIView-%E8%BF%87%E6%B8%A1%E5%8A%A8%E7%94%BB"><span class="toc-number">9.</span> <span class="toc-text">UIView 过渡动画</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#UIImageView-%E5%B8%A7%E5%8A%A8%E7%94%BB"><span class="toc-number">10.</span> <span class="toc-text">UIImageView 帧动画</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BD%AC%E5%9C%BA%E5%8A%A8%E7%94%BB"><span class="toc-number">11.</span> <span class="toc-text">转场动画</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-UIViewController-%E5%AE%B9%E5%99%A8%E8%BD%AC%E5%9C%BA%E5%8A%A8%E7%94%BB"><span class="toc-number">11.1.</span> <span class="toc-text">1. UIViewController 容器转场动画</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-UIViewController%E4%B9%8B%E9%97%B4%E8%B7%B3%E8%BD%AC%E7%9A%84%E8%BD%AC%E5%9C%BA%E5%8A%A8%E7%94%BB"><span class="toc-number">11.2.</span> <span class="toc-text">2. UIViewController之间跳转的转场动画</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-1-Present-x2F-Dismiss-%E5%8A%A8%E7%94%BB"><span class="toc-number">11.3.</span> <span class="toc-text">2.1 Present &#x2F; Dismiss 动画</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-2-Interactive-%E4%BA%A4%E4%BA%92%E5%8A%A8%E7%94%BB"><span class="toc-number">11.4.</span> <span class="toc-text">2.2 Interactive 交互动画</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-3-UIPresentationController-%E5%AE%9E%E7%8E%B0%E5%BC%B9%E7%AA%97%E6%95%88%E6%9E%9C"><span class="toc-number">11.5.</span> <span class="toc-text">2.3 UIPresentationController 实现弹窗效果</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-%E8%BD%AC%E5%9C%BA%E5%8A%A8%E7%94%BB%E6%B7%B1%E5%85%A5%E6%96%87%E7%AB%A0%E6%8E%A8%E8%8D%90"><span class="toc-number">11.6.</span> <span class="toc-text">3 转场动画深入文章推荐</span></a></li></ol></li></ol>
 
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="Hide Sidebar"></a></div>
<aside class="clearfix">
<div id="authorInfo">
	
		<div class="author-img"></div>		
	
	<div class="social-info" class="clearfix">
		
		
		<a href="https://github.com/tbfungeek" target="_blank" class="icon-github" title="github"></a>
		
		
		
		
		
		
		
		
		
		
		<a href="mailto:tbfungeek@163.com" target="_blank" class="icon-email" title="Email Me"></a>
		

	</div>
</div>

  
<div class="categorieslist">
	<p class="asidetitle">Categories</p>
		<ul>
		
		  
			<li><a href="/categories/Android-小经验/" title="Android 小经验">Android 小经验<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Android-源码分析/" title="Android 源码分析">Android 源码分析<sup>21</sup></a></li>
		  
		
		  
			<li><a href="/categories/Android其他/" title="Android其他">Android其他<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Android初步/" title="Android初步">Android初步<sup>21</sup></a></li>
		  
		
		  
			<li><a href="/categories/Android进阶/" title="Android进阶">Android进阶<sup>100</sup></a></li>
		  
		
		  
			<li><a href="/categories/Hexo-使用/" title="Hexo 使用">Hexo 使用<sup>10</sup></a></li>
		  
		
		  
			<li><a href="/categories/JavaScript理论/" title="JavaScript理论">JavaScript理论<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Objective-C-相关/" title="Objective C 相关">Objective C 相关<sup>24</sup></a></li>
		  
		
		  
			<li><a href="/categories/OpenCV/" title="OpenCV">OpenCV<sup>6</sup></a></li>
		  
		
		  
			<li><a href="/categories/ROS/" title="ROS">ROS<sup>9</sup></a></li>
		  
		
		  
			<li><a href="/categories/iOS-工具使用/" title="iOS 工具使用">iOS 工具使用<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/iOS-开源库分析/" title="iOS 开源库分析">iOS 开源库分析<sup>36</sup></a></li>
		  
		
		  
			<li><a href="/categories/iOS-理论基础/" title="iOS 理论基础">iOS 理论基础<sup>14</sup></a></li>
		  
		
		  
			<li><a href="/categories/iOS-进阶/" title="iOS 进阶">iOS 进阶<sup>4</sup></a></li>
		  
		
		  
			<li><a href="/categories/个人收藏/" title="个人收藏">个人收藏<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/代码规范/" title="代码规范">代码规范<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/其他/" title="其他">其他<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/博客分类目录/" title="博客分类目录">博客分类目录<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/叨叨系列/" title="叨叨系列">叨叨系列<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/开源代码分析/" title="开源代码分析">开源代码分析<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/开源库分析/" title="开源库分析">开源库分析<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/树莓派/" title="树莓派">树莓派<sup>4</sup></a></li>
		  
		
		  
			<li><a href="/categories/版本控制/" title="版本控制">版本控制<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/直播/" title="直播">直播<sup>6</sup></a></li>
		  
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">Tags</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/iOS-开源库分析/" title="iOS 开源库分析">iOS 开源库分析<sup>36</sup></a></li>
			
		
			
				<li><a href="/tags/Android-设计模式/" title="Android 设计模式">Android 设计模式<sup>29</sup></a></li>
			
		
			
				<li><a href="/tags/Objective-C-相关/" title="Objective C 相关">Objective C 相关<sup>24</sup></a></li>
			
		
			
				<li><a href="/tags/Android基础/" title="Android基础">Android基础<sup>21</sup></a></li>
			
		
			
				<li><a href="/tags/AOSP-源码/" title="AOSP 源码">AOSP 源码<sup>17</sup></a></li>
			
		
			
				<li><a href="/tags/Android-常用第三方库/" title="Android 常用第三方库">Android 常用第三方库<sup>15</sup></a></li>
			
		
			
				<li><a href="/tags/iOS-理论基础/" title="iOS 理论基础">iOS 理论基础<sup>14</sup></a></li>
			
		
			
				<li><a href="/tags/Hexo-使用/" title="Hexo 使用">Hexo 使用<sup>10</sup></a></li>
			
		
			
				<li><a href="/tags/ROS/" title="ROS">ROS<sup>9</sup></a></li>
			
		
			
				<li><a href="/tags/Android-动画进阶/" title="Android 动画进阶">Android 动画进阶<sup>8</sup></a></li>
			
		
			
				<li><a href="/tags/Android-JNI/" title="Android JNI">Android JNI<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/Android-绘图进阶/" title="Android 绘图进阶">Android 绘图进阶<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/Android性能优化/" title="Android性能优化">Android性能优化<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/Android-自动化测试/" title="Android 自动化测试">Android 自动化测试<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/OpenCV/" title="OpenCV">OpenCV<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/直播/" title="直播">直播<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/Android-开源源码/" title="Android 开源源码">Android 开源源码<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/Android-自定义View进阶/" title="Android 自定义View进阶">Android 自定义View进阶<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/树莓派/" title="树莓派">树莓派<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/iOS-进阶/" title="iOS 进阶">iOS 进阶<sup>4</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">Links</p>
    <ul>
        
          <li>
            
            	<a href="https://hexo.io" target="_blank" title="Hexo">Hexo</a>
            
          </li>
        
          <li>
            
            	<a href="https://pages.github.com/" target="_blank" title="GitHub">GitHub</a>
            
          </li>
        
          <li>
            
            	<a href="http://pf18.github.io/" target="_blank" title="PF18">PF18</a>
            
          </li>
        
          <li>
            
            	<a href="http://toutiao.io/" target="_blank" title="开发者头条">开发者头条</a>
            
          </li>
        
          <li>
            
            	<a href="http://www.jcodecraeer.com/" target="_blank" title="泡在网上的日子">泡在网上的日子</a>
            
          </li>
        
    </ul>
</div>

  


  <div class="rsspart">
	<a href="atom.xml" target="_blank" title="rss">RSS</a>
</div>

  
  <div class="tagcloudlist">
    <p class="asidetitle">Tag Cloud</p>
    <div class="tagcloudlist clearfix">
       <a href="/tags/AOSP-%E6%BA%90%E7%A0%81/" style="font-size: 17.14px;">AOSP 源码</a> <a href="/tags/Android-APK-%E7%AD%BE%E5%90%8D/" style="font-size: 10px;">Android APK 签名</a> <a href="/tags/Android-JNI/" style="font-size: 12.86px;">Android JNI</a> <a href="/tags/Android-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E8%BF%9B%E9%98%B6/" style="font-size: 10.71px;">Android 事件处理进阶</a> <a href="/tags/Android-%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6/" style="font-size: 13.57px;">Android 动画进阶</a> <a href="/tags/Android-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%80%E5%8F%91/" style="font-size: 10px;">Android 多线程开发</a> <a href="/tags/Android-%E5%B0%8F%E7%BB%8F%E9%AA%8C/" style="font-size: 10px;">Android 小经验</a> <a href="/tags/Android-%E5%B8%B8%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/" style="font-size: 16.43px;">Android 常用第三方库</a> <a href="/tags/Android-%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/" style="font-size: 10px;">Android 开发流程</a> <a href="/tags/Android-%E5%BC%80%E6%BA%90%E6%BA%90%E7%A0%81/" style="font-size: 12.14px;">Android 开源源码</a> <a href="/tags/Android-%E7%BB%98%E5%9B%BE%E8%BF%9B%E9%98%B6/" style="font-size: 12.86px;">Android 绘图进阶</a> <a href="/tags/Android-%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/" style="font-size: 12.86px;">Android 自动化测试</a> <a href="/tags/Android-%E8%87%AA%E5%AE%9A%E4%B9%89View%E8%BF%9B%E9%98%B6/" style="font-size: 12.14px;">Android 自定义View进阶</a> <a href="/tags/Android-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 19.29px;">Android 设计模式</a> <a href="/tags/Android%E5%85%B6%E4%BB%96/" style="font-size: 10px;">Android其他</a> <a href="/tags/Android%E5%9F%BA%E7%A1%80/" style="font-size: 17.86px;">Android基础</a> <a href="/tags/Android%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/" style="font-size: 10px;">Android开发流程</a> <a href="/tags/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" style="font-size: 12.86px;">Android性能优化</a> <a href="/tags/Android%E6%B7%B7%E6%B7%86%E6%8A%80%E6%9C%AF/" style="font-size: 10px;">Android混淆技术</a> <a href="/tags/Android%E8%B4%A8%E9%87%8F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/" style="font-size: 11.43px;">Android质量管理工具</a> <a href="/tags/Android%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/" style="font-size: 10px;">Android逆向工程</a> <a href="/tags/Git-github/" style="font-size: 10px;">Git && github</a> <a href="/tags/Hexo-%E4%BD%BF%E7%94%A8/" style="font-size: 15px;">Hexo 使用</a> <a href="/tags/JavaScript/" style="font-size: 10px;">JavaScript</a> <a href="/tags/Linux-%E4%BD%BF%E7%94%A8/" style="font-size: 10px;">Linux 使用</a> <a href="/tags/Objective-C-%E7%9B%B8%E5%85%B3/" style="font-size: 18.57px;">Objective C 相关</a> <a href="/tags/OpenCV/" style="font-size: 12.86px;">OpenCV</a> <a href="/tags/ROS/" style="font-size: 14.29px;">ROS</a> <a href="/tags/iOS-%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/" style="font-size: 10.71px;">iOS 工具使用</a> <a href="/tags/iOS-%E5%BC%80%E6%BA%90%E5%BA%93%E5%88%86%E6%9E%90/" style="font-size: 20px;">iOS 开源库分析</a> <a href="/tags/iOS-%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/" style="font-size: 15.71px;">iOS 理论基础</a> <a href="/tags/iOS-%E8%BF%9B%E9%98%B6/" style="font-size: 12.14px;">iOS 进阶</a> <a href="/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/" style="font-size: 10px;">代码规范</a> <a href="/tags/%E5%8D%9A%E5%AE%A2%E5%88%86%E7%B1%BB%E7%9B%AE%E5%BD%95/" style="font-size: 10.71px;">博客分类目录</a> <a href="/tags/%E5%8F%A8%E5%8F%A8%E7%B3%BB%E5%88%97/" style="font-size: 10px;">叨叨系列</a> <a href="/tags/%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/" style="font-size: 11.43px;">工具的使用</a> <a href="/tags/%E5%BC%80%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/" style="font-size: 10.71px;">开源代码分析</a> <a href="/tags/%E5%BC%80%E6%BA%90%E5%BA%93%E5%88%86%E6%9E%90/" style="font-size: 10px;">开源库分析</a> <a href="/tags/%E6%9D%82%E7%B1%BB/" style="font-size: 10px;">杂类</a> <a href="/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/" style="font-size: 12.14px;">树莓派</a> <a href="/tags/%E7%9B%B4%E6%92%AD/" style="font-size: 12.86px;">直播</a> <a href="/tags/%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/" style="font-size: 10.71px;">编程技巧</a> <a href="/tags/%E7%BD%91%E7%AB%99%E6%94%B6%E8%97%8F/" style="font-size: 10px;">网站收藏</a> <a href="/tags/%E9%87%8D%E8%A6%81%E6%8E%A7%E4%BB%B6/" style="font-size: 11.43px;">重要控件</a>
    </div>
  </div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
		
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/hsihohuang/kiddochan" target="_blank" title="Kiddochan">Kiddochan</a> © 2022 
		
		<a href="/about" target="_blank" title="Edgar">Edgar</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
        getSize();
        if (myWidth >= 1024) {
          c.click();
        }
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  c.click(function(){
    ta.css('display', 'block').addClass('fadeIn');
  });
  o.click(function(){
    ta.css('display', 'none');
  });
  $(window).scroll(function(){
    ta.css("top",Math.max(140,320-$(this).scrollTop()));
  });
});
</script>




<script type="text/javascript">
  var duoshuoQuery = {short_name:"tbfungeek"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script> 


<script type="text/javascript">

var disqus_shortname = 'tbfungeek';

(function(){
  var dsq = document.createElement('script');
  dsq.type = 'text/javascript';
  dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
}());
(function(){
  var dsq = document.createElement('script');
  dsq.type = 'text/javascript';
  dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/count.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
}());
</script>






<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?7c9443b0374f1cf6b1dbb5ab84d939cb";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="Back to Top"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
</html>
