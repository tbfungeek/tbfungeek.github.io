
 <!DOCTYPE HTML>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
  
    <title>Objective C 代码规范 | Edgar&#39;s Blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="Edgar">
    

    
    <meta name="description" content="该文档的目的在于规范整个项目的代码，使得代码更具可读性，在草拟该文档的时候常照了较多较好的代码规范文档，这些文档将会罗列在该文档参考文献部分。大家如果在使用该文档过程中发现有任何的遗漏或者有更好的规范或者异议都欢迎联系本人(文档末尾有本人的联系邮箱)。    为什么需要有代码规范一般一个项目代码通常是由一个团队共同开发维护的产物，随着业务的不断扩展，功能的快速迭代，代码会变得越来越庞大，如果这个">
<meta property="og:type" content="article">
<meta property="og:title" content="Objective C 代码规范">
<meta property="og:url" content="http://yoursite.com/2019/07/02/Objective-C-%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/index.html">
<meta property="og:site_name" content="Edgar&#39;s Blog">
<meta property="og:description" content="该文档的目的在于规范整个项目的代码，使得代码更具可读性，在草拟该文档的时候常照了较多较好的代码规范文档，这些文档将会罗列在该文档参考文献部分。大家如果在使用该文档过程中发现有任何的遗漏或者有更好的规范或者异议都欢迎联系本人(文档末尾有本人的联系邮箱)。    为什么需要有代码规范一般一个项目代码通常是由一个团队共同开发维护的产物，随着业务的不断扩展，功能的快速迭代，代码会变得越来越庞大，如果这个">
<meta property="og:locale">
<meta property="article:published_time" content="2019-07-01T16:29:36.000Z">
<meta property="article:modified_time" content="2019-12-19T12:29:56.000Z">
<meta property="article:author" content="Edgar">
<meta property="article:tag" content="代码规范">
<meta name="twitter:card" content="summary">

    
    <link rel="alternative" href="atom.xml" title="Edgar&#39;s Blog" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/unnamed4_n_mSY_icon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/profile.png">
    <link rel="apple-touch-icon-precomposed" href="/img/profile.png">
    
    
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 6.2.0"></head>

  <body>
    <header>
      
<div>
		
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="Edgar&#39;s Blog">Edgar&#39;s Blog</a></h1>
				<h2 class="blog-motto"></h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="Menu">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
					<li>
 					
					<form class="search" action="/search/index.html" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" autocomplete="off" name="q" maxlength="20" placeholder="Search" />
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
  
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/07/02/Objective-C-代码规范/" title="Objective C 代码规范" itemprop="url">Objective C 代码规范</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Edgar" target="_blank" itemprop="author">Edgar</a>
		
  <p class="article-time">
    <time datetime="2019-07-01T16:29:36.000Z" itemprop="datePublished"> Published 2019-07-02</time>
    
  </p>
</header>
	<div class="article-content">
		
		<blockquote>
<p>该文档的目的在于规范整个项目的代码，使得代码更具可读性，在草拟该文档的时候常照了较多较好的代码规范文档，这些文档将会罗列在该文档参考文献部分。大家如果在使用该文档过程中发现有任何的遗漏或者有更好的规范或者异议都欢迎联系本人(文档末尾有本人的联系邮箱)。  </p>
</blockquote>
<h3 id="为什么需要有代码规范"><a href="#为什么需要有代码规范" class="headerlink" title="为什么需要有代码规范"></a>为什么需要有代码规范</h3><p>一般一个项目代码通常是由一个团队共同开发维护的产物，随着业务的不断扩展，功能的快速迭代，代码会变得越来越庞大，如果这个时候不同的开发者的code风格千差万别，那么阅读代码将会是一件十分痛苦的事情。代码规范除了一些必须遵守的规则外，大多是没有对错而言，它只是让整个项目的代码看起开风格更加统一，我们知道人对熟悉的东西接受起来会快，对于熟悉的代码风格同样也是这个道理，这就是为每个项目拟定代码规范的意义所在.  </p>
<p>该规范整体分成三类：</p>
<ul>
<li>[命名规范]</li>
<li>[编码规范]</li>
</ul>
<p>所有规范分成两个等级</p>
<ul>
<li>[必须]</li>
<li>[建议]</li>
</ul>
<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><ol>
<li><p>命名规范</p>
<ul>
<li>通用命名规范</li>
<li>文件命名规范</li>
<li>类命名规范</li>
<li>方法命名规范</li>
<li>Getter&#x2F;Setter命名规范</li>
<li>属性，参数命名规范</li>
<li>Delegate 命名规范</li>
<li>Protocol命名规范</li>
<li>Catogries命名规范</li>
<li>常量命名规范</li>
<li>Exception命名规范</li>
<li>Notification命名规范</li>
</ul>
</li>
<li><p>编码规范</p>
<ul>
<li>Initialize 规范</li>
<li>dealloc 规范</li>
<li>Block规范</li>
<li>Notification规范</li>
<li>Collection规范</li>
<li>控制语句规范</li>
<li>对象判等规范</li>
<li>懒加载规范</li>
<li>内存管理规范</li>
</ul>
</li>
<li><p>项目设计规范</p>
<ul>
<li>源码注释规范</li>
<li>文件导入规范</li>
<li>代码布局规范</li>
<li>interface接口文件布局规范</li>
<li>类设计规范</li>
</ul>
</li>
</ol>
<h4 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h4><h5 id="通用命名规范"><a href="#通用命名规范" class="headerlink" title="通用命名规范"></a>通用命名规范</h5><ul>
<li>[必须] 命名必须具备见名知意的效果，禁止中文拼音，过度缩写，以及一切无意义的命名。</li>
<li>[必须] 除了通知和掩码常量外命名禁止自我指涉(在变量的末尾增加类型后缀)</li>
<li>[必须] 参数名、成员变量、局部变量、属性名都要采用小写字母开头的驼峰命名方式。如果方法名以一个众所周知的大写缩略词开始，可以不适用驼峰命名方式。比如FTP、WWW URL等。</li>
<li>[建议] 不同文件中或者不同类中具有相同功能或相似功能的属性的命名应该是相同的或者相似的。比如：count同时定义在NSDictionary、NSArray、NSSet这三个集合类中。且这三个集合类中的count属性都代表同一个意思，即集合中对象的个数。</li>
<li>[建议] 一般情况下，不要缩写或省略单词，建议拼写出来，即使它有点长。</li>
</ul>
<h5 id="文件命名规范"><a href="#文件命名规范" class="headerlink" title="文件命名规范"></a>文件命名规范</h5><p>我们在刚拿到代码的时候首先会先看项目的目录结构，其次就是文件的组织，而了解文件的组织就是从文件名开始，所以文件命名也是一个非常重要的工作。</p>
<ul>
<li>[必须] 分类文件必须使用分类所依附的主类名 + 分类名称的形式 比如:UIImage+NMAddition.h</li>
<li>[必须] 一般建议一个文件中只定义一个类，但是如果定义多个的时候，使用最主要的那个类的名称作为文件名。</li>
<li>[必须] 文件后缀选择：<figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line">Extension    <span class="keyword">Type</span></span><br><span class="line">.h      C/C++/Objective-C header <span class="keyword">file</span></span><br><span class="line">.m      Objective-C <span class="keyword">implementation</span> <span class="keyword">file</span></span><br><span class="line">.mm     Objective-C++ <span class="keyword">implementation</span> <span class="keyword">file</span></span><br><span class="line">.cc     Pure C++ <span class="keyword">implementation</span> <span class="keyword">file</span></span><br><span class="line">.c      C <span class="keyword">implementation</span> <span class="keyword">file</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="类命名规范"><a href="#类命名规范" class="headerlink" title="类命名规范"></a>类命名规范</h5><ul>
<li>[必须] 类的名称应该由两部分组成，前缀+名称，前缀用大写字符，名称用大写开头的驼峰规则命名。</li>
<li>[建议] 前缀一般使用项目产品名的缩写，之所以不使用公司组织的缩写是因为一个公司有多个产品，使用公司名来作为前缀有可能导致重复。对于前缀一般使用多于两位的大写字符，因为苹果默认保留了两位字符的缩写前缀，但是这不是必须的。</li>
</ul>
<h5 id="方法命名规范"><a href="#方法命名规范" class="headerlink" title="方法命名规范"></a>方法命名规范</h5><ul>
<li>[必须] 方法名必须使用小写开头的驼峰命名方式，如果方法名以一个中所周知的大写缩略词开头，该规则可以忽略。</li>
<li>[必须] 一般类方法名不需要使用前缀，因为它们存在于特定类的命名空间中，私有方法可以使用统一的前缀来分组和辨识</li>
<li>[必须] 禁止在方法前面加下划线“ _ ”。Apple官网团队经常在方法前面加下划线”_”。为了避免方法覆盖，导致不可预知的意外，禁止在方法前面加下划线。</li>
<li>[必须] 如果一个方法代表某个名词执行的动作，则该方法应该以一个动词开头。但不要使用“do”或者”does”作为方法名称的一部分，因为这些助动词不能为方法名称增加太多的意义，反而让方法看起来更加臃肿。同时，也请不要在动词前面使用副词或者形容词。</li>
<li>[建议] 方法实现时，如果参数过长，则令每个参数占用一行，以冒号对齐,在分行时，如果第一段名称过短，后续名称可以以Tab的长度（4个空格）为单位进行缩进，<figure class="highlight erlang"><table><tr><td class="code"><pre><span class="line">-<span class="params">(id)</span>initWithModel:<span class="params">(IPCModle)</span>model</span><br><span class="line">       ConnectType:<span class="params">(IPCConnectType)</span>connectType</span><br><span class="line">        Resolution:<span class="params">(IPCResolution)</span>resolution</span><br><span class="line">          AuthName:<span class="params">(NSString *)</span>authName</span><br><span class="line">          Password:<span class="params">(NSString *)</span>password</span><br><span class="line">               MAC:<span class="params">(NSString *)</span>mac</span><br><span class="line">              AzIp:<span class="params">(NSString *)</span>az_ip</span><br><span class="line">             AzDns:<span class="params">(NSString *)</span>az_dns</span><br><span class="line">             Token:<span class="params">(NSString *)</span>token</span><br><span class="line">             Email:<span class="params">(NSString *)</span>email</span><br><span class="line">          Delegate:<span class="params">(id&lt;IPCConnectHandlerDelegate&gt;)</span>delegate;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- <span class="params">(void)</span>short:<span class="params">(GTMFoo *)</span>theFoo</span><br><span class="line">          longKeyword:<span class="params">(NSRect)</span>theRect</span><br><span class="line">    evenLongerKeyword:<span class="params">(float)</span>theInterval</span><br><span class="line">                error:<span class="params">(NSError **)</span>theError &#123;</span><br><span class="line">                ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>[建议] 如果一个方法调用语句太长，需要对参数进行冒号对齐，如果只有一个冒号，但是还是太长了，可以换行，并且第二行与第一行的第二个字符对齐。</li>
<li>[必须] 只有在访问某个属性的时候使用”点访问，其他的使用空格调用。</li>
<li>[建议] 对输入参数的正确性和有效性进行检查，参数错误立即返回</li>
<li>[建议] 对于有返回值的方法，每一个分支都必须有返回值。</li>
<li>[必须] 禁止直接调用NSObject的类方法+new，也不要在子类中重载它。使用alloc和init方法<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">self.productsRequest</span> = [[SKProductsRequest alloc]   </span><br><span class="line">  initWithProductIdentifiers:productIdentifiers]<span class="comment">;</span></span><br></pre></td></tr></table></figure></li>
<li>[必须] 在方法定义的时候需要在-&#x2F;+符号后面添加一个空格<figure class="highlight erlang"><table><tr><td class="code"><pre><span class="line">- <span class="params">(void)</span>invokeWithTarget:<span class="params">(id)</span>target;</span><br><span class="line">- <span class="params">(void)</span>selectTabViewItem:<span class="params">(NSTabViewItem *)</span>tabViewItem</span><br></pre></td></tr></table></figure></li>
<li>[必须] 如果某个方法返回一个对象，那么名字应该使用返回对象的名字来命名</li>
<li>[必须] 如果方法返回接收者的某个属性，那么请直接以属性名作为方法名。如果方法间接的返回一个或多个值，我们可以使用“getxxx”的方式来命名方法。相反，无需额外的在方法名前面添加”get”。<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">- (NSSize)cellSize<span class="comment">;     OK</span></span><br><span class="line">- (NSSize)calcCellSize<span class="comment">; 不OK</span></span><br><span class="line">- (NSSize)getCellSize<span class="comment">;  不OK</span></span><br></pre></td></tr></table></figure></li>
<li>[必须] 所有参数前面都应该添加关键字</li>
<li>[必须] 尽量使用”with”, “from”, and “to”,进行连接，请不要使用“and”连接接收者属性，但是如果方法描述了两个独立的动作，可以考虑使用“and”连接起来。</li>
<li>[必须]  方法定义keyword 和参数之间不能有空格<figure class="highlight arcade"><table><tr><td class="code"><pre><span class="line">可以写成这样</span><br><span class="line">- (<span class="keyword">void</span>)setExample:(NSString *)<span class="built_in">text</span>;</span><br><span class="line">不能写成这样</span><br><span class="line">- (<span class="keyword">void</span>)setExample: (NSString *)<span class="built_in">text</span>;</span><br><span class="line">- (<span class="keyword">void</span>)setExample:(NSString *) <span class="built_in">text</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h6 id="Getter-x2F-Setter命名规范"><a href="#Getter-x2F-Setter命名规范" class="headerlink" title="Getter&#x2F;Setter命名规范"></a>Getter&#x2F;Setter命名规范</h6><ul>
<li>[建议] 如果属性是名词，推荐格式如下：<figure class="highlight erlang"><table><tr><td class="code"><pre><span class="line">- <span class="params">(type)</span>noun;</span><br><span class="line">- <span class="params">(void)</span>setNoun:<span class="params">(type)</span>aNoun;</span><br><span class="line">例如：</span><br><span class="line">- <span class="params">(NSString *)</span>title;</span><br><span class="line">- <span class="params">(void)</span>setTitle:<span class="params">(NSString *)</span>aTitle;</span><br></pre></td></tr></table></figure></li>
<li>[建议] 如果某个属性或者变量的名称是一个形容词，可以省略is前缀，并在属性定义的时候使用getter来指定getter方法的名称。<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">getter</span>=isEditable) <span class="type">BOOL</span> editable;</span><br></pre></td></tr></table></figure></li>
<li>[建议] 如果属性是一个动词，动词使用一般现在时。推荐格式如下：<figure class="highlight erlang"><table><tr><td class="code"><pre><span class="line">- <span class="params">(BOOL)</span>verbObject;</span><br><span class="line">- <span class="params">(void)</span>setVerbObject:<span class="params">(BOOL)</span>flag;</span><br><span class="line">例如：</span><br><span class="line">- <span class="params">(BOOL)</span>showsAlpha;</span><br><span class="line">- <span class="params">(void)</span>setShowsAlpha:<span class="params">(BOOL)</span>flag;</span><br></pre></td></tr></table></figure></li>
<li>[必须] 不要把动词的过去分词形式当做形容词来使用。</li>
<li>[建议] 可以使用情态动词（can、should、will等）明确方法意义，但不要使用do、does这类无意义的情态动词。</li>
<li>[建议] 只有方法间接的返回一个数值，或者需要多个数值需要被返回的时候，才有必要在方法名称中使用“get”。像这种接收多个参数的方法应该能够传入nil，因为调用者未必对每个参数都感兴趣<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)getLineDash:(<span class="keyword">float</span> *)pattern <span class="keyword">count</span>:(<span class="keyword">int</span> *)<span class="keyword">count</span> phase:(<span class="keyword">float</span> *)phase;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="属性，参数命名规范"><a href="#属性，参数命名规范" class="headerlink" title="属性，参数命名规范"></a>属性，参数命名规范</h5><ul>
<li>[建议] 每个属性命名都加上类型后缀,也就是说变量的名称必须同时包含功能与类型，如，按钮就加上Button后缀，模型就加上Model后缀</li>
<li>[建议] 属性的关键字推荐按照 原子性，读写，内存管理的顺序排列。<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readwrite</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *gender;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readwrite</span>, <span class="keyword">strong</span>) <span class="built_in">UIView</span> *headerView;</span><br></pre></td></tr></table></figure></li>
<li>[必须] Block,NSString属性应该使用copy关键字</li>
<li>[必须] delegate 应该使用weak关键字</li>
<li>[必须] 禁止使用synthesize关键词</li>
<li>[建议] 如果是静态常量，仅限本类内使用的，加上前缀s_，如果是整个工程共用，以sg_为前缀。如：<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">s_kMaxHeight<span class="comment">; </span></span><br><span class="line">sg_kMaxHeight<span class="comment">;</span></span><br></pre></td></tr></table></figure></li>
<li>[建议] 对于本地变量，在最靠京它们使用的地方声明，并且在它们声明的同时对其进行初始化</li>
<li>[建议] 由于32位和64位版本的大小不同，请避免使用long类型，NSInteger，NSUInteger和CGFloat，除非匹配系统接口。类型long，NSInteger，NSUInteger和CGFloat在32位和64位版本之间的大小不同。在处理由系统接口公开的值时，使用这些类型是合适的，但对于大多数其他计算应该避免使用它们。</li>
<li>[必须] 在使用整形变量存储ID之类的值时，需要使用uint32 uint64这一类，长度不会随着平台版本不同而不同的变量类型。</li>
<li>[必须] 在遇到遵循某个协议的对象定义的时候，不要在id和协议之间加空格</li>
<li>[必须]  在定义NSArray和NSDictionary时使用泛型，可以保证程序的安全性：</li>
<li>[必须] 当使用属性，对象实例变量，应该使用self.形式访问，这样可以确保调用的是具备Setter&#x2F;Getter方法修饰过的属性值。但是在init和dealloc内建议使用类似_variableName形式的访问方式避免Setter&#x2F;Getter 带来的副作用，更不要在Setter&#x2F;Getter 方法中使用self.这样会导致死循环。</li>
<li>[必须] 在定义属性或者变量的时候指针应该归变量，也就是说建议使用:<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">NSString *<span class="built_in">text</span></span><br><span class="line"></span><br><span class="line">而不是</span><br><span class="line"></span><br><span class="line">NSString* <span class="built_in">text</span></span><br><span class="line">NSString * <span class="built_in">text</span></span><br></pre></td></tr></table></figure></li>
<li>[建议] 私有属性强烈建议写在类的空扩展中<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@interface</span> IDLCodeStylePrivateDemo ()</span><br><span class="line"></span><br><span class="line"><span class="variable">@property</span> (nonatomic, strong, readwrite) NSString *privateProperty;</span><br><span class="line"></span><br><span class="line"><span class="variable">@end</span></span><br></pre></td></tr></table></figure></li>
<li>[必须] 对于对外只读属性仅在.h接口文件中定义并指定其读写属性为readonly，<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@interface</span> IDLCodeStylePrivateDemo</span><br><span class="line"></span><br><span class="line"><span class="variable">@property</span> (nonatomic, strong, readonly) NSString *readonlyProperty;</span><br><span class="line"></span><br><span class="line"><span class="variable">@end</span></span><br></pre></td></tr></table></figure></li>
<li>[必须] 如果在实现内部需要修改该属性需要在空扩展内部添加读写属性为readwrite的同名属性：<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@interface</span> IDLCodeStylePrivateDemo ()</span><br><span class="line"></span><br><span class="line"><span class="variable">@property</span> (nonatomic, strong, readwrite) NSString *readonlyProperty;</span><br><span class="line"></span><br><span class="line"><span class="variable">@end</span></span><br></pre></td></tr></table></figure></li>
<li>[必须] 当变量释放后，需要将变量置为nil,避免因为野指针引起的程序崩溃。</li>
<li>[必须] 变量在使用前应初始化，防止未初始化的变量被引用。</li>
</ul>
<h5 id="Delegate-方法命名规范"><a href="#Delegate-方法命名规范" class="headerlink" title="Delegate 方法命名规范"></a>Delegate 方法命名规范</h5><ul>
<li>[建议] 用delegate做后缀，如<UIScrollViewDelegate> 当你的委托的方法过多, 可以拆分数据部分和其他逻辑部分, 数据部分用dataSource做后缀. 如<UITableViewDataSource></UITableViewDataSource></UIScrollViewDelegate></li>
<li>[建议] 名称以标示发送消息的对象的类名开头,省略类名的前缀并⼩小写第⼀个字⺟<figure class="highlight erlang"><table><tr><td class="code"><pre><span class="line">- <span class="params">(BOOL)</span>tableView:<span class="params">(NSTableView *)</span>tableView shouldSelectRow:<span class="params">(int)</span>row;</span><br><span class="line">- <span class="params">(BOOL)</span>application:<span class="params">(NSApplication *)</span>sender openFile:<span class="params">(NSString *)</span>filename;</span><br></pre></td></tr></table></figure></li>
<li>[建议] 除非delegate方法只有一个参数，即触发delegate方法调用的delegating对象，否则冒号是紧跟在类名后面的。<figure class="highlight erlang"><table><tr><td class="code"><pre><span class="line">- <span class="params">(BOOL)</span>applicationOpenUntitledFile:<span class="params">(NSApplication *)</span>sender;</span><br></pre></td></tr></table></figure></li>
<li>[建议] ⽤于通知委托对象操作即将发生或已经发⽣的方法名中要使⽤did或will</li>
<li>[建议] 用于询问委托对象可否执行某操作的⽅法名中可使⽤did或will,但最好使⽤should<figure class="highlight erlang"><table><tr><td class="code"><pre><span class="line">- <span class="params">(BOOL)</span>windowShouldClose:<span class="params">(id)</span>sender;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="Protocol命名规范"><a href="#Protocol命名规范" class="headerlink" title="Protocol命名规范"></a>Protocol命名规范</h5><ul>
<li>[建议] 有时候protocol只是声明了一堆相关方法，并不关联class。这种不关联class的protocol使用ing形式以和class区分开来。比如NSLocking而非NSLock。</li>
<li>[建议] 如果proctocol不仅声明了一堆相关方法，还关联了某个class。这种关联class的protocol的命名取决于关联的class，然后再后面再加上protocol或delegate用于显示的声明这是一份协议。</li>
<li>[必须] 用optional修饰可以不实现的方法，用required修饰必须实现的方法</li>
</ul>
<h5 id="Catogries命名规范"><a href="#Catogries命名规范" class="headerlink" title="Catogries命名规范"></a>Catogries命名规范</h5><ul>
<li>[必须] category中不要声明属性和成员变量。</li>
<li>[必须] 避免category中的方法覆盖系统方法。可以使用前缀来区分系统方法和category方法。但前缀不要仅仅使用下划线”_“。</li>
<li>[必须] 如果一个类比较复杂，建议使用category的方式组织代码。具体可以参考UIView。</li>
</ul>
<h5 id="常量命名规范"><a href="#常量命名规范" class="headerlink" title="常量命名规范"></a>常量命名规范</h5><ul>
<li>[必须] 在代码中的常量必须抽成宏或者静态常量，避免使用硬编码内容</li>
</ul>
<h5 id="枚举常量"><a href="#枚举常量" class="headerlink" title="枚举常量"></a>枚举常量</h5><ul>
<li>[必须] 使用枚举类型来表示一组相关的整型常量。<figure class="highlight elm"><table><tr><td class="code"><pre><span class="line">typedef <span class="type">NS_ENUM</span>(<span class="type">NSUInteger</span>, <span class="type">VPLeftMenuTopItemType</span>) &#123;</span><br><span class="line">    <span class="type">VPLeftMenuTopItemTypeMain</span> = 0,</span><br><span class="line">    <span class="type">VPLeftMenuTopItemTypeShows</span>,</span><br><span class="line">    <span class="type">VPLeftMenuTopItemTypeSchedule</span>,</span><br><span class="line">    <span class="type">VPLeftMenuTopItemTypeWatchLive</span>,</span><br><span class="line">    <span class="type">VPLeftMenuTopItemTypeMax</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">typedef <span class="type">NS_ENUM</span>(<span class="type">NSInteger</span>, <span class="type">RBKGlobalConstants</span>) &#123;</span><br><span class="line">    <span class="type">RBKPinSizeMin</span> = 1,</span><br><span class="line">    <span class="type">RBKPinSizeMax</span> = 5,</span><br><span class="line">    <span class="type">RBKPinCountMin</span> = 100,</span><br><span class="line">    <span class="type">RBKPinCountMax</span> = 500,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h6 id="const常量"><a href="#const常量" class="headerlink" title="const常量"></a>const常量</h6><ul>
<li>[必须] 使用const关键字创建浮点型常量。如果一个整型常量和其他常量不相关，可以使用const来创建，否则，使用枚举类型表示一组相关的整型常量。<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="type">int</span> kFileCount = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> *<span class="keyword">const</span> kUserKey = <span class="string">@&quot;kUserKey&quot;</span>;</span><br></pre></td></tr></table></figure></li>
<li>[必须] 通常情况下，不要使用#define预处理命令创建常量。</li>
<li>[必须] 对于局限于某编译单元(实现文件)的常量，以字符k开头，例如kAnimationDuration，且需要以static const修饰<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">推荐这样写：</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">NSTimeInterval</span> kFadeOutAnimationDuration = <span class="number">0.4</span>;</span><br><span class="line">不推荐这样写：</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">NSTimeInterval</span> fadeOutTime = <span class="number">0.4</span>;</span><br></pre></td></tr></table></figure></li>
<li>[必须] 对于定义于类头文件的常量，外部可见，则以定义该常量所在类的类名开头，例如EOCViewClassAnimationDuration, 仿照苹果风格，在头文件中进行extern声明，在实现文件中定义其值<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">例如 在头文件中声明如下定义</span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">float</span> EOCViewClassAnimationDuration;</span><br><span class="line">在实现文件中做如下声明</span><br><span class="line"><span class="type">const</span> <span class="type">float</span> EOCViewClassAnimationDuration = <span class="number">18.0</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h6 id="宏常量"><a href="#宏常量" class="headerlink" title="宏常量"></a>宏常量</h6><ul>
<li>[必须] #define 预处理定义的常量全部大写，单词间用 _ 分隔</li>
<li>[必须] 宏定义中如果包含表达式或变量，表达式或变量必须用小括号括起来。</li>
</ul>
<h5 id="Exception命名规范"><a href="#Exception命名规范" class="headerlink" title="Exception命名规范"></a>Exception命名规范</h5><ul>
<li>[必须] 异常是用全局的NSString字符串进行标识。命名方式如下：<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-attr">[Prefix]</span> + <span class="selector-attr">[异常模块]</span> + <span class="selector-attr">[异常简要描述]</span> + Exception</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="Notification命名规范"><a href="#Notification命名规范" class="headerlink" title="Notification命名规范"></a>Notification命名规范</h5><ul>
<li>[必须] notification的命名使用全局的NSString字符串进行标识。命名方式如下： <figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">[Name of associated <span class="keyword">class</span>] + [Did | Will] + [UniquePartOfName] + Notification</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line"><span class="built_in">NSApplicationDidBecomeActiveNotification</span></span><br><span class="line"><span class="built_in">NSWindowDidMiniaturizeNotification</span></span><br><span class="line"><span class="built_in">NSTextViewDidChangeSelectionNotification</span></span><br><span class="line"><span class="built_in">NSColorPanelColorDidChangeNotification</span></span><br></pre></td></tr></table></figure></li>
<li>[必须] object通常是指发出notification的对象，如果在发送notification的同时要传递一些额外的信息，请使用userInfo，而不是object。</li>
<li>[必须] 如果某个通知是为了告知外界某个事件”即将”发生或者”已经”发生，则请在通知名称中使用“will”或者“did”这样的助动词。例<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">如：</span><br><span class="line">UIKeyboardWillChangeFrameNotification<span class="comment">;</span></span><br><span class="line">UIKeyboardDidChangeFrameNotification<span class="comment">;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="编码规范"><a href="#编码规范" class="headerlink" title="编码规范"></a>编码规范</h4><h5 id="Initialize-规范"><a href="#Initialize-规范" class="headerlink" title="Initialize 规范"></a>Initialize 规范</h5><p>initialize类方法先于其他的方法调用。且initialize方法给我们提供了一个让代码once、lazy执行的地方。initialize通常被用于设置class的版本号,initialize方法的调用遵循继承规则(所谓继承规则，简单来讲是指：子类方法中可以调用到父类的同名方法，即使没有调用[super xxx])。如果我们没有实现initialize方法，运行时初次调用这个类的时候，系统会沿着继承链(类继承体系)，先后给继承链上游中的每个超类发送一条initialize消息，直到某个超类实现了initlialize方法，才会停止向上调用。因此，在运行时,某个类的initialize方法可能会被调用多次</p>
<ul>
<li>[必须] 如果我们想要让initialize方法仅仅被调用一次，那么需要借助于GCD的dispatch_once()<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">+ (<span class="type">void</span>)initialize &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        <span class="comment">// the initializing code</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>[建议] 如果我们想在继承体系的某个指定的类的initialize方法中执行一些初始化代码，可以使用类型检查和而非dispatch_once()<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">self</span> == [<span class="built_in">NSFoo</span> <span class="keyword">class</span>]) &#123;</span><br><span class="line">    <span class="comment">// the initializing code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>[必须] initialize是由系统自动调用的方法，我们不应该显示或手动调用initialize方法</li>
</ul>
<h5 id="Init-规范"><a href="#Init-规范" class="headerlink" title="Init 规范"></a>Init 规范</h5><p>Objective-C有designated Initializers和secondary Initializers的概念:<br>指定初始化方法(designated initializer)是提供所有的（最多的）参数的初始化方法，间接初始化方法(secondary initializer)有一个或部分参数的初始化方法。一个类可以有一个或者多个designated Initializers。但是要保证所有的其他secondary initializers都要调用designated Initializers。即：只有designated Initializers才会存储对象的信息。这样的好处是：当这个类底层的某些数据存储机制发生变化时(可能是一些property的变更)，只需要修改这个designated Initializers内部的代码即可。无需改动其他secondary Initializers初始化方法的代码。</p>
<ul>
<li>[必须] 所有secondary 初始化方法都应该调用designated 初始化方法。</li>
<li>[必须] 所有子类的designated初始化方法都要调用父类的designated初始化方法。使这种调用关系沿着类的继承体系形成一条链。</li>
<li>[必须] 如果子类的designated初始化方法与超类的designated初始化方法不同，则子类应该覆写超类的designated初始化方法。（因为开发者很有可能直接调用超类的某个designated方法来初始化一个子类对象，这样也是合情合理的，但使用超类的方法初始化子类，可能会导致子类在初始化时缺失一些必要信息）。</li>
<li>[必须] 如果超类的某个初始化方法不适用于子类，则子类应该覆写这个超类的方法，并在其中抛出异常。</li>
<li>[必须] 禁止子类的designated初始化方法调用父类的secondary初始化方法。否则容易陷入方法调用死循环。<br>如果想在当前类自定义一个新的全能初始化方法，则需要如下几个步骤：</li>
<li>定义新的指定初始化方法，并确保调用了直接父类的初始化方法。</li>
<li>重载直接父类的初始化方法，在内部调用新定义的指定初始化方法。</li>
<li>为新的指定初始化方法写文档。<br>重载父类的初始化方法并在内部调用新定义的指定初始化方法的原因是你不能确定调用者调用的就一定是你定义的这个新的指定初始化方法，而不是原来从父类继承来的指定初始化方法。假设你没有重载父类的指定初始化方法，而调用者却恰恰调用了父类的初始化方法。那么调用者可能永远都调用不到你自己定义的新指定初始化方法了。而如果你成功定义了一个新的指定初始化方法并能保证调用者一定能调用它，你最好要在文档中明确写出哪一个才是你定义的新初始化方法。或者你也可以使用编译器指令__attribute__((objc_designated_initializer))来标记它。<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 超类</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ParentObject</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ParentObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//designated initializer    </span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithURL:(<span class="built_in">NSString</span>*)url title:(<span class="built_in">NSString</span>*)title &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="variable language_">super</span> init]) &#123;</span><br><span class="line">        _url = [url <span class="keyword">copy</span>];</span><br><span class="line">        _title = [title <span class="keyword">copy</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//secondary initializer</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithURL:(<span class="built_in">NSString</span>*)url &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> initWithURL:url title:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ChildObject</span> : <span class="title">ParentObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ChildObject</span></span></span><br><span class="line"><span class="comment">//designated initializer</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithURL:(<span class="built_in">NSString</span>*)url title:(<span class="built_in">NSString</span>*)title &#123;</span><br><span class="line">    <span class="comment">//在designated intializer中调用 secondary initializer，错误的</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="variable language_">super</span> initWithURL:url]) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line">- (<span class="type">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="variable language_">super</span> viewDidLoad];</span><br><span class="line">    <span class="comment">// 这里会死循环</span></span><br><span class="line">    ChildObject* child = [[ChildObject alloc] initWithURL:<span class="string">@&quot;url&quot;</span> title:<span class="string">@&quot;title&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></li>
<li>[必须] 禁止在init方法中使用self.xxx的方式访问属性。如果存在继承的情况下，很有可能导致崩溃。原因见文章<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/3cf3f5007243">为什么不能在init和dealloc函数中使用accessor方法</a></li>
<li>[必须] 校验父类designated初始化方法返回的对象是否为nil。如果初始化当前对象的时候发生了错误，应该给予对应的处理：释放对象，并返回nil。</li>
</ul>
<h5 id="dealloc-规范"><a href="#dealloc-规范" class="headerlink" title="dealloc 规范"></a>dealloc 规范</h5><ul>
<li>[必须] 不要忘记在dealloc方法中移除通知和KVO。</li>
<li>[建议] dealloc 方法应该放在实现文件的最上面，在任何类中，init 都应该直接放在 dealloc 方法的下面，如果有多个初始化方法，应该将指定初始化方法放在最前面，其他初始化方法放在其后。</li>
<li>[必须] 在dealloc方法中，禁止将self作为参数传递出去，如果self被retain住，到下个runloop周期再释放，则会造成多次释放crash。如下：<figure class="highlight monkey"><table><tr><td class="code"><pre><span class="line">- (void)dealloc&#123;</span><br><span class="line">    [<span class="variable language_">self</span> unsafeMethod:<span class="variable language_">self</span>];</span><br><span class="line">    //因为当前已经在<span class="variable language_">self</span>这个指针所指向的对象的销毁阶段，销毁<span class="variable language_">self</span>所指向的对象已经在所难免。如果在unsafeMethod:中把<span class="variable language_">self</span>放到了autorelease poll中，那么<span class="variable language_">self</span>会被retain住，计划下个runloop周期在进行销毁。但是dealloc运行结束后，<span class="variable language_">self</span>所指向的对象的内存空间就直接被回收了，但是<span class="variable language_">self</span>这个指针还没有销毁(即没有被置为nil)，导致<span class="variable language_">self</span>变成了一个名副其实的野指针。</span><br><span class="line">    // 到了下一个runloop周期，因为<span class="variable language_">self</span>所指向的对象已经被销毁，会因为非法访问而造成crash问题。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>[必须] 和init方法一样，禁止在dealloc方法中使用self.xxx的方式访问属性。如果存在继承的情况下，很有可能导致崩溃。</li>
</ul>
<h5 id="Block规范"><a href="#Block规范" class="headerlink" title="Block规范"></a>Block规范</h5><ul>
<li>[必须] 调用block时需要对block判空。</li>
<li>[必须] 注意block潜在的引用循环。</li>
<li>[建议] 较短的block可以写在一行内。</li>
<li>[建议] 如果分行显示的话，block的右括号}应该和调用block那行代码的第一个非空字符对齐。block内的代码采用4个空格的缩进。<br>如果block过于庞大，应该单独声明成一个变量来使用。^和(之间，^和{之间都没有空格，参数列表的右括号)和{之间有一个空格。<figure class="highlight wren"><table><tr><td class="code"><pre><span class="line"><span class="comment">//较短的block写在一行内</span></span><br><span class="line">[<span class="variable">operation</span> <span class="variable">setCompletionBlock</span>:<span class="operator">^</span>&#123; [<span class="variable">self</span> <span class="variable">onOperationDone</span>]; &#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">//分行书写的block，内部使用4空格缩进</span></span><br><span class="line">[<span class="variable">operation</span> <span class="variable">setCompletionBlock</span>:<span class="operator">^</span>&#123;</span><br><span class="line">    [<span class="variable">self</span>.<span class="property">delegate</span> <span class="variable">newDataAvailable</span>];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用C语言API调用的block遵循同样的书写规则</span></span><br><span class="line"><span class="title function_">dispatch_async</span>(_<span class="params">fileIOQueue</span>, ^&#123;</span><br><span class="line">    <span class="params">NSString</span>* <span class="params">path</span> = [<span class="params">self</span> <span class="params">sessionFilePath</span>];</span><br><span class="line">    <span class="params">if</span> (<span class="params">path</span>) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//较长的block关键字可以缩进后在新行书写，注意block的右括号&#x27;&#125;&#x27;和调用block那行代码的第一个非空字符对齐</span></span><br><span class="line">[[<span class="title class_">SessionService</span> <span class="variable">sharedService</span>]</span><br><span class="line">    <span class="variable">loadWindowWithCompletionBlock</span>:<span class="title function_">^</span>(<span class="params">SessionWindow</span> *<span class="params">window</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">window</span>) &#123;</span><br><span class="line">            [<span class="variable">self</span> <span class="variable">windowDidLoad</span>:<span class="variable">window</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            [<span class="variable">self</span> <span class="variable">errorLoadingWindow</span>];</span><br><span class="line">        &#125;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">//较长的block参数列表同样可以缩进后在新行书写</span></span><br><span class="line">[[<span class="title class_">SessionService</span> <span class="variable">sharedService</span>]</span><br><span class="line">    <span class="variable">loadWindowWithCompletionBlock</span>:</span><br><span class="line">        <span class="title function_">^</span>(<span class="params">SessionWindow</span> *<span class="params">window</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="variable">window</span>) &#123;</span><br><span class="line">                [<span class="variable">self</span> <span class="variable">windowDidLoad</span>:<span class="variable">window</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                [<span class="variable">self</span> <span class="variable">errorLoadingWindow</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">//庞大的block应该单独定义成变量使用</span></span><br><span class="line"><span class="title function_">void</span> (<span class="operator">^</span><span class="variable">largeBlock</span>)(<span class="variable">void</span>) <span class="operator">=</span> <span class="operator">^</span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line">[<span class="variable">_operationQueue</span> <span class="variable">addOperationWithBlock</span>:<span class="variable">largeBlock</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//在一个调用中使用多个block，注意到他们不是像方法那样通过&#x27;:&#x27;对齐的，而是同时进行了4个空格的缩进</span></span><br><span class="line">[<span class="variable">myObject</span> <span class="variable">doSomethingWith</span>:<span class="variable">arg1</span></span><br><span class="line">    <span class="variable">firstBlock</span>:<span class="title function_">^</span>(<span class="params">Foo</span> *<span class="params">a</span>) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable">secondBlock</span>:<span class="title function_">^</span>(<span class="params">Bar</span> *<span class="params">b</span>) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;];</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="Notification规范"><a href="#Notification规范" class="headerlink" title="Notification规范"></a>Notification规范</h5><ul>
<li>[必须] 当我们使用通知时，必须要思考，有没有更好的办法来代替这个通知。禁止遇到问题就想到通知，把通知作为备选项而非首选项。</li>
<li>[必须] post通知时，object通常是指发出notification的对象，如果在发送notification的同时要传递一些额外的信息，请使用userInfo，而不是object。</li>
<li>[必须] 在多线程应用中，Notification在哪个线程中post，就在哪个线程中被转发，而不一定是在注册观察者的那个线程中。如果post消息不在主线程，而接受消息的回调里做了UI操作，需要让其在主线程执行。<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">说明：每个进程都会创建一个NotificationCenter，这个<span class="built_in">center</span>通过NSNotificationCenter defaultCenter获取，当然也可以自己创建一个<span class="built_in">center</span>。NoticiationCenter是以同步（非异步，当前线程，会等待，会阻塞）的方式发送请求。即，当post通知时，<span class="built_in">center</span>会一直等待所有的observer都收到并且处理了通知才会返回到poster。如果需要异步发送通知，请使用notificationQueue，在一个多线程的应用中，通知会发送到所有的线程中。</span><br></pre></td></tr></table></figure>
<h5 id="Collection规范"><a href="#Collection规范" class="headerlink" title="Collection规范"></a>Collection规范</h5></li>
<li>[必须] 不要用一个可能为nil的对象初始化集合对象，否则可能会导致crash。</li>
<li>[必须] 对插入到集合对象里面的对象也要进行判空。</li>
<li>[必须] 注意在多线程环境下访问可变集合对象的问题，必要时应该加锁保护。不可变集合(比如NSArray)类默认是线程安全的，而可变集合类(比如NSMutableArray)不是线程安全的。</li>
<li>[必须] 禁止在多线程环境下直接访问可变集合对象中的元素。应该先对其进行copy，然后访问不可变集合对象内的元素。</li>
<li>[必须] 注意使用enumerateObjectsUsingBlock遍历集合对象中的对象时，关键字return的作用域。block中的return代表的是使当前的block返回，而非使当前的整个函数体返回。</li>
<li>[必须] 禁止返回mutable对象，禁止mutable对象作为入参传递。</li>
<li>[必须] 在访问集合的时候需要做内存操作越界判断</li>
<li>[建议] 应该使用可读性更好的字面量来构造NSArray，NSDictionary等数据结构，避免使用冗长的alloc,init方法。</li>
<li>[建议] 如果构造代码写在一行，需要在括号两端留有一个空格，使得被构造的元素于与构造语法区分开来：<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">//正确，在字面量的&quot;[]&quot;或者&quot;&#123;&#125;&quot;两端留有空格</span></span><br><span class="line"><span class="built_in">NSArray</span> *array = @[ [foo description], <span class="string">@&quot;Another String&quot;</span>, [bar description] ];</span><br><span class="line"><span class="built_in">NSDictionary</span> *dict = @&#123; <span class="built_in">NSForegroundColorAttributeName</span> : [<span class="built_in">NSColor</span> redColor] &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不正确，不留有空格降低了可读性</span></span><br><span class="line"><span class="built_in">NSArray</span>* array = @[[foo description], [bar description]];</span><br><span class="line"><span class="built_in">NSDictionary</span>* dict = @&#123;<span class="built_in">NSForegroundColorAttributeName</span>: [<span class="built_in">NSColor</span> redColor]&#125;;</span><br></pre></td></tr></table></figure></li>
<li>[建议] 如果使用NSMutableDictionary作为缓存，建议使用NSCache代替。<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSCache</span>优于<span class="built_in">NSDictionary</span>的几点：</span><br><span class="line">当系统资源将要耗尽时，<span class="built_in">NSCache</span>具备自动删减缓冲的功能。并且还会先删减“最久未使用”的对象。</span><br><span class="line"><span class="built_in">NSCache</span>不拷贝键，而是保留键。因为并不是所有的键都遵从拷贝协议（字典的键是必须要支持拷贝协议的，有局限性）。</span><br><span class="line"><span class="built_in">NSCache</span>是线程安全的：不编写加锁代码的前提下，多个线程可以同时访问<span class="built_in">NSCache</span>。</span><br></pre></td></tr></table></figure></li>
<li>[建议] 集合类使用泛型来指定对象的类型。</li>
<li>[必须] 取下标的时候要判断是否越界。</li>
<li>[建议] 取第一个元素或最后一个元素的时候使用firtstObject和lastObject</li>
<li>[建议] 如果构造代码不写在一行内，构造元素需要使用 两个空格 来进行缩进，右括号]或者}写在新的一行，并且与调用字面量那行代码的第一个非空字符对齐，构造字典时，字典的Key和Value与中间的冒号:都要留有一个空格，多行书写时，也可以冒号对齐：<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *array = @[</span><br><span class="line">  <span class="string">@&quot;This&quot;</span>,</span><br><span class="line">  <span class="string">@&quot;is&quot;</span>,</span><br><span class="line">  <span class="string">@&quot;an&quot;</span>,</span><br><span class="line">  <span class="string">@&quot;array&quot;</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSDictionary</span> *dictionary = @&#123;</span><br><span class="line">             <span class="built_in">NSFontAttributeName</span> : [<span class="built_in">NSFont</span> fontWithName:<span class="string">@&quot;Helvetica-Bold&quot;</span> size:<span class="number">12</span>],</span><br><span class="line">  <span class="built_in">NSForegroundColorAttributeName</span> : fontColor</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="控制语句规范"><a href="#控制语句规范" class="headerlink" title="控制语句规范"></a>控制语句规范</h5><ul>
<li>[建议] 相关的赋值语句等号对齐<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">promotionsEntity.promotionImageStr</span>   = activityItemDict[@<span class="string">&quot;promotion_image&quot;</span>]<span class="comment">;</span></span><br><span class="line"><span class="attr">promotionsEntity.promotionIdNum</span>      = activityItemDict[@<span class="string">&quot;promotion_id&quot;</span>]<span class="comment">;</span></span><br><span class="line"><span class="attr">promotionsEntity.promotionNameStr</span>    = activityItemDict[@<span class="string">&quot;promotion_name&quot;</span>]<span class="comment">;</span></span><br><span class="line"><span class="attr">promotionsEntity.promotionColorStr</span>   = activityItemDict[@<span class="string">&quot;promotion_color&quot;</span>]<span class="comment">;</span></span><br></pre></td></tr></table></figure></li>
<li>[建议] if条件判断语句后面必须要加大括号{}。不然随着业务的发展和代码迭代，极有可能引起逻辑问题。</li>
<li>[必须] 条件过多，过长的时候应该换行。条件表达式如果很长，则需要将他们提取出来赋给一个BOOL值，或者抽取出一个方法</li>
<li>[必须] 不要使用过多的分支，要善于使用return来提前返回错误的情况，把最正确的情况放到最后返回。</li>
<li>[建议] 对于条件语句的真假，因为 nil 解析为 NO，所以没有必要在条件中与它进行比较。永远不要直接和 YES 和 NO进行比较，因为 YES 被定义为 1，而 BOOL 可以多达 8 位。</li>
<li>[必须]使用switch…case…语句的时候，不要丢掉default:。除非switch枚举。</li>
<li>[必须] switch…case…语句的每个case都要添加break关键字，避免出现fall-through。</li>
<li>[必须] 不可在for循环内修改循环变量，防止for循环失去控制。<figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> <span class="keyword">index</span> = <span class="number">0</span>; <span class="keyword">index</span> &lt; <span class="number">10</span>; <span class="keyword">index</span>++)&#123;</span><br><span class="line">    ...</span><br><span class="line">    logicToChange(<span class="keyword">index</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>[建议] 在使用?:的时候不要嵌套多重?: 这里顺便提一个?: 另外一个用得比较多的场景–为某个属性添加默认值：<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">dotImage</span> = [_delegate pageControl:self selectedImageForDotAtIndex:i] ?: _selectedDotImage<span class="comment">;</span></span><br></pre></td></tr></table></figure></li>
<li>[必须] 在访问CGRect 的 x,y,width,height 属性的时候不要直接访问，建议使用CGRectGetxxxx方法。</li>
<li>[必须] 如果某个方法的错误传递方式包括引用和返回两种方式的时候，建议使用返回的那个值：<br>建议：<figure class="highlight monkey"><table><tr><td class="code"><pre><span class="line">NSError *<span class="built_in">error</span>;</span><br><span class="line"><span class="keyword">if</span> (![<span class="variable language_">self</span> trySomethingWithError:&amp;<span class="built_in">error</span>]) &#123;</span><br><span class="line">    // Handle <span class="built_in">Error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">不建议：</span><br><span class="line"></span><br><span class="line">NSError *<span class="built_in">error</span>;</span><br><span class="line">[<span class="variable language_">self</span> trySomethingWithError:&amp;<span class="built_in">error</span>];</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">error</span>) &#123;</span><br><span class="line">    // Handle <span class="built_in">Error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="对象判等规范"><a href="#对象判等规范" class="headerlink" title="对象判等规范"></a>对象判等规范</h5><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"> - (<span class="type">BOOL</span>)isEqual:(<span class="type">id</span>)object &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> == object) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>; <span class="comment">//判断内存地址</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span> (![object isKindOfClass:[ZOCPerson <span class="keyword">class</span>]]) &#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>; <span class="comment">//是否为当前类或派生类 </span></span><br><span class="line">    &#125;                                                                       </span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> isEqualToPerson:(ZOCPerson *)object];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//自定义的判断相等性的方法</span></span><br><span class="line">- (<span class="type">BOOL</span>)isEqualToPerson:(Person *)person &#123; </span><br><span class="line">   <span class="keyword">if</span> (!person) &#123;  </span><br><span class="line">       <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">   &#125; </span><br><span class="line">   <span class="type">BOOL</span> namesMatch = (!<span class="keyword">self</span>.name &amp;&amp; !person.name) || [<span class="keyword">self</span>.name isEqualToString:person.name]; </span><br><span class="line">   <span class="type">BOOL</span> birthdaysMatch = (!<span class="keyword">self</span>.birthday &amp;&amp; !person.birthday) </span><br><span class="line">                           || [<span class="keyword">self</span>.birthday isEqualToDate:person.birthday]; </span><br><span class="line">   <span class="keyword">return</span> haveEqualNames &amp;&amp; haveEqualBirthdays; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> </p>
<h5 id="懒加载规范"><a href="#懒加载规范" class="headerlink" title="懒加载规范"></a>懒加载规范</h5><figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">懒加载适合的场景：</span><br><span class="line">一个对象在整个<span class="keyword">app</span>过程中，可能被使用，也可能不被使用。</span><br><span class="line">一个对象的创建需要经过大量的计算或者比较消耗性能。除以上情形之外，请不要使用懒加载。</span><br></pre></td></tr></table></figure>
<ul>
<li>[建议] 懒加载本质上就是延迟初始化某个对象，所以，懒加载仅仅是初始化一个对象，然后对这个对象的属性赋值。懒加载中不应该有其他的不必要的逻辑性的代码，如果有，请把那些逻辑性代码放到合适的地方。</li>
<li>[必须] 不要滥用懒加载，只对那些真正需要懒加载的对象采用懒加载。</li>
<li>[必须] 如果一个对象在懒加载后，某些场景下又被设置为nil。我们很难保证这个懒加载不被再次触发。<h5 id="内存管理规范"><a href="#内存管理规范" class="headerlink" title="内存管理规范"></a>内存管理规范</h5></li>
<li>[必须] 函数体提前return时，要注意是否有对象没有被释放掉(常见于CF对象)，避免造成内存泄露。</li>
<li>[建议] 请慎重使用单例，避免产生不必要的常驻内存。</li>
<li>[建议] 除非你清除的知道自己在做什么。否则不建议将UIView类的对象加入到NSArray、NSDictionary、NSSet中。如有需要可以添加到NSMapTable 和 NSHashTable。因为NSArray、NSDictionary、NSSet会对加入的对象做strong引用（即使你把加入的对象进行了weak）。而NSMapTable、NSHashTable会对加入的对象做weak引用。说明：简单的说，NSHashTable相当于weak的NSMutableArray；NSMapTable相当于weak的NSMutableDictionary.</li>
</ul>
<h5 id="其他规范"><a href="#其他规范" class="headerlink" title="其他规范"></a>其他规范</h5><ul>
<li>[必须] performSelector:withObject:afterDelay:要在有Runloop的线程里调用，否则调用无法生效。</li>
</ul>
<h4 id="项目设计规范"><a href="#项目设计规范" class="headerlink" title="项目设计规范"></a>项目设计规范</h4><h5 id="文件布局"><a href="#文件布局" class="headerlink" title="文件布局"></a>文件布局</h5><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">-.h</span><br><span class="line">-- 文件注释</span><br><span class="line">-- <span class="meta">#import            <span class="comment">// 导入类</span></span></span><br><span class="line">-- <span class="built_in">NS_ENUM</span>            <span class="comment">// 枚举类</span></span><br><span class="line">-- <span class="class"><span class="keyword">@protocol</span>            // 代理</span></span><br><span class="line">-- <span class="class"><span class="keyword">@interface</span>            // 文件入口</span></span><br><span class="line">-- <span class="keyword">@property</span>            <span class="comment">// 属性</span></span><br><span class="line">-- methods                <span class="comment">// 方法</span></span><br><span class="line"></span><br><span class="line">-.m</span><br><span class="line">-- 文件注释</span><br><span class="line">-- <span class="meta">#import            <span class="comment">// 导入类</span></span></span><br><span class="line">-- <span class="meta">#<span class="keyword">define</span>            <span class="comment">// 宏定义</span></span></span><br><span class="line">-- <span class="keyword">static</span>             <span class="comment">// 静态变量</span></span><br><span class="line">-- <span class="class"><span class="keyword">@interface</span>            // 文件入口</span></span><br><span class="line">-- <span class="keyword">@property</span>            <span class="comment">// 属性</span></span><br><span class="line">-- <span class="class"><span class="keyword">@implementation</span>        // 实现</span></span><br><span class="line">-- methods            <span class="comment">// 方法    </span></span><br></pre></td></tr></table></figure>

<h5 id="源码注释规范"><a href="#源码注释规范" class="headerlink" title="源码注释规范"></a>源码注释规范</h5><p>优秀的代码大部分是可以自描述的，我们完全可以用代码本身来表达它到底在干什么，而不需要注释的辅助。<br>但并不是说一定不能写注释，有以下三种情况比较适合写注释：</p>
<ul>
<li><p>公共接口（注释要告诉阅读代码的人，当前类能实现什么功能）。</p>
</li>
<li><p>涉及到比较深层专业知识的代码（注释要体现出实现原理和思想）。</p>
</li>
<li><p>容易产生歧义的代码（但是严格来说，容易让人产生歧义的代码是不允许存在的）。<br>除了上述这三种情况，如果别人只能依靠注释才能读懂你的代码的时候，就要反思代码出现了什么问题。<br>最后，对于注释的内容，相对于“做了什么”，更应该说明“为什么这么做”。</p>
</li>
<li><p>[建议] 注释符与注释内容之间要用一个空格进行分割。</p>
</li>
</ul>
<p>较好的注释例子</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@class</span> <span class="title">Bar</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 接口，分类，和协议都必须添加块注释用于说明该模块的作用</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Foo</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** 属性定义注释 */</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) Bar *bar;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 方法说明</span></span><br><span class="line"><span class="comment">* See -initWithBar: for details about @c bar.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* @param bar The string for fooing.</span></span><br><span class="line"><span class="comment">* @return An instance of Foo.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)fooWithBar:(Bar *)bar;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Initializes and returns a Foo object using the provided Bar instance.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* @param bar A string that represents a thing that does a thing.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithBar:(Bar *)bar <span class="built_in">NS_DESIGNATED_INITIALIZER</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Does some work with @c blah.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* @param blah</span></span><br><span class="line"><span class="comment">* @return YES if the work was completed; NO otherwise.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">- (<span class="type">BOOL</span>)doWorkWithBlah:(<span class="built_in">NSString</span> *)blah;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>** 方法的注释使用Xcode自带注释快捷键:Commond+option+&#x2F; **</p>
<h5 id="文件导入规范"><a href="#文件导入规范" class="headerlink" title="文件导入规范"></a>文件导入规范</h5><ul>
<li>[建议] 在类的头文件中尽量少引用其他头文件，有时，类A需要将类B的实例变量作为它公共API的属性。这个时候，我们不应该引入类B的头文件，而应该使用向前声明（forward declaring）使用class关键字，并且在A的实现文件引用B的头文件。</li>
<li>[必须] 使用import 导入Objective-C 和 Objective-C++ 头文件，使用include 来导入C&#x2F;C++ 头文件</li>
<li>[建议] 优先导入框架的头文件，再导入自己的头文件，最后导入三方的头文件。每个类别之间使用一个空行隔开，每个类别的头文件导入中使用&#x2F;&#x2F;类别进行分类。</li>
<li>[必须] 务必保持头文件导入没有多余的内容，不需要的头文件导入，切记删除。</li>
<li>[建议] 共同的接口、结构体、常量和数据类型要定义在同一个头文件里</li>
</ul>
<h5 id="代码布局规范"><a href="#代码布局规范" class="headerlink" title="代码布局规范"></a>代码布局规范</h5><p>项目中的代码需要根据每个方法的具体功能使用#pragma mark - 进行分类，#pragma mark - 上空两行，下空一行</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> mark - Life cycle</span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)dealloc &#123;&#125;</span><br><span class="line">- (<span class="keyword">instancetype</span>)init &#123;&#125;</span><br><span class="line">- (<span class="type">void</span>)viewDidLoad &#123;&#125;</span><br><span class="line">- (<span class="type">void</span>)viewWillAppear:(<span class="type">BOOL</span>)animated &#123;&#125;</span><br><span class="line">- (<span class="type">void</span>)didReceiveMemoryWarning &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> mark - Public methods</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> mark - Override methods</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> mark - Getters / Setters</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> mark - Others(Delegate/DataSource等)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> mark - Private methods</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>[建议] 方法和方法之间建议使用一行空行隔开</li>
<li>[建议] 方法内部一类的代码之间不能有空行，一类代码之间需要添加空行来隔开，这样可以比较清晰<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)awakeFromNib &#123;</span><br><span class="line">    <span class="built_in">UIStoryboard</span> *signatureStoryboard = [<span class="built_in">UIStoryboard</span> storyboardWithName:<span class="string">@&quot;BBPopoverSignature&quot;</span> bundle:<span class="literal">nil</span>];</span><br><span class="line">    <span class="keyword">self</span>.signatureViewController = [signatureStoryboard instantiateViewControllerWithIdentifier:<span class="string">@&quot;BBPopoverSignature&quot;</span>];</span><br><span class="line">    <span class="keyword">self</span>.signatureViewController.modalPresentationStyle = <span class="built_in">UIModalPresentationPopover</span>;</span><br><span class="line">    <span class="keyword">self</span>.signatureViewController.preferredContentSize = <span class="built_in">CGSizeMake</span>(BBPopoverSignatureWidth, BBPopoverSignatureHeight);</span><br><span class="line">    <span class="keyword">self</span>.signatureViewController.signatureImageView = <span class="keyword">self</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UITapGestureRecognizer</span> *tapRecognizer = [[<span class="built_in">UITapGestureRecognizer</span> alloc] initWithTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(initiateSignatureCapture)];</span><br><span class="line">    [<span class="keyword">self</span> addGestureRecognizer:tapRecognizer];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>[必须] 代码块换行，建议使用<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (user.isHappy) &#123;</span><br><span class="line">    <span class="regexp">//</span>Do something</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="regexp">//</span>Do something <span class="keyword">else</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">而不是</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (user.isHappy)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="regexp">//</span>Do something</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="regexp">//</span>Do something <span class="keyword">else</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>[必须] 代码块冒号对齐，使用<figure class="highlight wren"><table><tr><td class="code"><pre><span class="line">[<span class="title class_">UIView</span> <span class="variable">animateWithDuration</span>:<span class="number">1.0</span> <span class="variable">animations</span>:<span class="operator">^</span>&#123;</span><br><span class="line">    <span class="comment">// something</span></span><br><span class="line">&#125; <span class="variable">completion</span>:<span class="title function_">^</span>(<span class="params">BOOL</span> <span class="params">finished</span>) &#123;</span><br><span class="line">    <span class="comment">// something</span></span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">而不是</span><br><span class="line"></span><br><span class="line">[<span class="title class_">UIView</span> <span class="variable">animateWithDuration</span>:<span class="number">1.0</span></span><br><span class="line">                 <span class="variable">animations</span>:<span class="operator">^</span>&#123;</span><br><span class="line">                    <span class="comment">// something</span></span><br><span class="line">                 &#125;</span><br><span class="line">                 <span class="variable">completion</span>:<span class="title function_">^</span>(<span class="params">BOOL</span> <span class="params">finished</span>) &#123;</span><br><span class="line">                    <span class="comment">// something</span></span><br><span class="line">                 &#125;];</span><br></pre></td></tr></table></figure></li>
<li>[建议] 在类扩展和实现文件中保证一行的空行<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@interface</span> MyClass ()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Properties - 在这里保证前后行有一个空行</span></span><br><span class="line"></span><br><span class="line"><span class="variable">@end</span></span><br><span class="line"></span><br><span class="line"><span class="variable">@implementation</span> MyClass</span><br><span class="line"></span><br><span class="line"><span class="comment">// Body - 在这里保证前后行有一个空行</span></span><br><span class="line"></span><br><span class="line"><span class="variable">@end</span></span><br><span class="line"><span class="comment">//这里也要留个空行</span></span><br></pre></td></tr></table></figure></li>
<li>[建议] 在类声明中包含多个protocal，每个protocal占用一行并对齐。<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">@<span class="keyword">interface</span> <span class="symbol">CustomBackButtonViewController</span> () &lt;<span class="symbol">UITextFieldDelegate</span>,</span><br><span class="line">                                              <span class="symbol">MyProtocalDelegate</span>,</span><br><span class="line">                                              <span class="symbol">UITabBarControllerDelegate</span>,</span><br><span class="line">                                              <span class="symbol">UITabBarDelegate</span>&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="interface接口文件布局规范"><a href="#interface接口文件布局规范" class="headerlink" title="interface接口文件布局规范"></a>interface接口文件布局规范</h5><ul>
<li>[建议] interface接口的排列顺序建议如下：属性, 类方法, 初始化方法, 实例方法.</li>
</ul>
<h5 id="类设计规范"><a href="#类设计规范" class="headerlink" title="类设计规范"></a>类设计规范</h5><ul>
<li>[建议]  尽量减少继承，类的继承关系不要超过3层。可以考虑使用category、protocol来代替继承。</li>
<li>[建议] 把一些稳定的、公共的变量或者方法抽取到父类中。子类尽量只维持父类所不具备的特性和功能。</li>
<li>[建议] .h文件中的属性尽量声明为只读。</li>
<li>[建议]  .h文件中只暴露出一些必要的类、公开的方法、只读属性；私有类、私有方法和私有属性以及成员变量，尽量写在.m文件中。</li>
<li>[建议] 如果某个类的方法较多可以考虑把类的实现代码分散到便于管理的多个分类中</li>
</ul>
<p>[参考文档]<br><a target="_blank" rel="noopener" href="http://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/ObjectiveC/Introduction/introObjectiveC.html">The Objective-C Programming Language</a><br><a target="_blank" rel="noopener" href="https://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/CocoaFundamentals/Introduction/Introduction.htmll">Cocoa Fundamentals Guide</a><br><a target="_blank" rel="noopener" href="https://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/CodingGuidelines/CodingGuidelines.html">Coding Guidelines for Cocoa</a><br><a target="_blank" rel="noopener" href="http://developer.apple.com/library/ios/#documentation/iphone/conceptual/iphoneosprogrammingguide/Introduction/Introduction.html">iOS App Programming Guide</a><br><a target="_blank" rel="noopener" href="https://github.com/raywenderlich/objective-c-style-guide#languagel">Raywenderlich Objective C Style Guide</a><br><a target="_blank" rel="noopener" href="https://github.com/RobotsAndPencils/objective-c-style-guide">Robots &amp; Pencils</a><br><a target="_blank" rel="noopener" href="https://github.com/NYTimes/objective-c-style-guide">New York Times</a><br><a target="_blank" rel="noopener" href="https://google.github.io/styleguide/objcguide.xml">Google</a><br><a target="_blank" rel="noopener" href="https://github.com/github/objective-c-conventions">GitHub</a><br><a target="_blank" rel="noopener" href="https://trac.adium.im/wiki/CodingStyle">Adium</a><br><a target="_blank" rel="noopener" href="https://gist.github.com/soffes/812796">Sam Soffes</a><br><a target="_blank" rel="noopener" href="http://cocoadevcentral.com/articles/000082.php">CocoaDevCentral</a><br><a target="_blank" rel="noopener" href="http://lukeredpath.co.uk/blog/my-objective-c-style-guide.html">Luke Redpath</a><br><a target="_blank" rel="noopener" href="http://www.cimgf.com/zds-code-style-guide/">Marcus Zarra</a><br><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1143352">一份走心的iOS开发规范前言约定</a><br><a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/CodingGuidelines/CodingGuidelines.html#//apple_ref/doc/uid/10000146-SW1">Coding Guidelines for Cocoa</a></p>
  
	</div>
		<footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/">代码规范</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/代码规范/">代码规范</a>
  </div>

</div>



</footer>

   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2019/07/04/iOS中的宏用法简单总结/" title="iOS中的宏用法简单总结">
  <span>
  iOS中的宏用法简单总结</span>
</a>
</div>


<div class="next">
<a href="/2018/12/05/后端技术栈-Django-1-使用Docker容器来部署Django之一Docker简介/"  title="[后端技术栈-Django]-1-使用Docker容器来部署Django之一Docker简介">
 <span>[后端技术栈-Django]-1-使用Docker容器来部署Django之一Docker简介
</span>
</a>
</div>

</nav>

	
<section id="comments" class="comment">
	<div class="ds-thread" data-thread-key="2019/07/02/Objective-C-代码规范/" data-title="Objective C 代码规范" data-url="http://yoursite.com/2019/07/02/Objective-C-%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"></div>
</section>


<section id="comments" class="comment">
  <div id="disqus_thread">
    <noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  </div>
</section>

</div>  
      <div class="openaside"><a class="navbutton" href="#" title="Show Sidebar"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">Contents</strong>
 
 <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E6%9C%89%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83"><span class="toc-number">1.</span> <span class="toc-text">为什么需要有代码规范</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95"><span class="toc-number">2.</span> <span class="toc-text">目录</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83"><span class="toc-number">2.1.</span> <span class="toc-text">命名规范</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%9A%E7%94%A8%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83"><span class="toc-number">2.1.1.</span> <span class="toc-text">通用命名规范</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83"><span class="toc-number">2.1.2.</span> <span class="toc-text">文件命名规范</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B1%BB%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83"><span class="toc-number">2.1.3.</span> <span class="toc-text">类命名规范</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83"><span class="toc-number">2.1.4.</span> <span class="toc-text">方法命名规范</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#Getter-x2F-Setter%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83"><span class="toc-number">2.1.4.1.</span> <span class="toc-text">Getter&#x2F;Setter命名规范</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%EF%BC%8C%E5%8F%82%E6%95%B0%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83"><span class="toc-number">2.1.5.</span> <span class="toc-text">属性，参数命名规范</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Delegate-%E6%96%B9%E6%B3%95%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83"><span class="toc-number">2.1.6.</span> <span class="toc-text">Delegate 方法命名规范</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Protocol%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83"><span class="toc-number">2.1.7.</span> <span class="toc-text">Protocol命名规范</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Catogries%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83"><span class="toc-number">2.1.8.</span> <span class="toc-text">Catogries命名规范</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83"><span class="toc-number">2.1.9.</span> <span class="toc-text">常量命名规范</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E5%B8%B8%E9%87%8F"><span class="toc-number">2.1.10.</span> <span class="toc-text">枚举常量</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#const%E5%B8%B8%E9%87%8F"><span class="toc-number">2.1.10.1.</span> <span class="toc-text">const常量</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%AE%8F%E5%B8%B8%E9%87%8F"><span class="toc-number">2.1.10.2.</span> <span class="toc-text">宏常量</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Exception%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83"><span class="toc-number">2.1.11.</span> <span class="toc-text">Exception命名规范</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Notification%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83"><span class="toc-number">2.1.12.</span> <span class="toc-text">Notification命名规范</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83"><span class="toc-number">2.2.</span> <span class="toc-text">编码规范</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Initialize-%E8%A7%84%E8%8C%83"><span class="toc-number">2.2.1.</span> <span class="toc-text">Initialize 规范</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Init-%E8%A7%84%E8%8C%83"><span class="toc-number">2.2.2.</span> <span class="toc-text">Init 规范</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#dealloc-%E8%A7%84%E8%8C%83"><span class="toc-number">2.2.3.</span> <span class="toc-text">dealloc 规范</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Block%E8%A7%84%E8%8C%83"><span class="toc-number">2.2.4.</span> <span class="toc-text">Block规范</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Notification%E8%A7%84%E8%8C%83"><span class="toc-number">2.2.5.</span> <span class="toc-text">Notification规范</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Collection%E8%A7%84%E8%8C%83"><span class="toc-number">2.2.6.</span> <span class="toc-text">Collection规范</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5%E8%A7%84%E8%8C%83"><span class="toc-number">2.2.7.</span> <span class="toc-text">控制语句规范</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%88%A4%E7%AD%89%E8%A7%84%E8%8C%83"><span class="toc-number">2.2.8.</span> <span class="toc-text">对象判等规范</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%87%92%E5%8A%A0%E8%BD%BD%E8%A7%84%E8%8C%83"><span class="toc-number">2.2.9.</span> <span class="toc-text">懒加载规范</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E8%A7%84%E8%8C%83"><span class="toc-number">2.2.10.</span> <span class="toc-text">内存管理规范</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E8%A7%84%E8%8C%83"><span class="toc-number">2.2.11.</span> <span class="toc-text">其他规范</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83"><span class="toc-number">2.3.</span> <span class="toc-text">项目设计规范</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%B8%83%E5%B1%80"><span class="toc-number">2.3.1.</span> <span class="toc-text">文件布局</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E6%B3%A8%E9%87%8A%E8%A7%84%E8%8C%83"><span class="toc-number">2.3.2.</span> <span class="toc-text">源码注释规范</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%AF%BC%E5%85%A5%E8%A7%84%E8%8C%83"><span class="toc-number">2.3.3.</span> <span class="toc-text">文件导入规范</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%B8%83%E5%B1%80%E8%A7%84%E8%8C%83"><span class="toc-number">2.3.4.</span> <span class="toc-text">代码布局规范</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#interface%E6%8E%A5%E5%8F%A3%E6%96%87%E4%BB%B6%E5%B8%83%E5%B1%80%E8%A7%84%E8%8C%83"><span class="toc-number">2.3.5.</span> <span class="toc-text">interface接口文件布局规范</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B1%BB%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83"><span class="toc-number">2.3.6.</span> <span class="toc-text">类设计规范</span></a></li></ol></li></ol></li></ol>
 
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="Hide Sidebar"></a></div>
<aside class="clearfix">
<div id="authorInfo">
	
		<div class="author-img"></div>		
	
	<div class="social-info" class="clearfix">
		
		
		<a href="https://github.com/tbfungeek" target="_blank" class="icon-github" title="github"></a>
		
		
		
		
		
		
		
		
		
		
		<a href="mailto:tbfungeek@163.com" target="_blank" class="icon-email" title="Email Me"></a>
		

	</div>
</div>

  
<div class="categorieslist">
	<p class="asidetitle">Categories</p>
		<ul>
		
		  
			<li><a href="/categories/Android-小经验/" title="Android 小经验">Android 小经验<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Android-源码分析/" title="Android 源码分析">Android 源码分析<sup>21</sup></a></li>
		  
		
		  
			<li><a href="/categories/Android其他/" title="Android其他">Android其他<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Android初步/" title="Android初步">Android初步<sup>21</sup></a></li>
		  
		
		  
			<li><a href="/categories/Android进阶/" title="Android进阶">Android进阶<sup>100</sup></a></li>
		  
		
		  
			<li><a href="/categories/Hexo-使用/" title="Hexo 使用">Hexo 使用<sup>10</sup></a></li>
		  
		
		  
			<li><a href="/categories/JavaScript理论/" title="JavaScript理论">JavaScript理论<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Objective-C-相关/" title="Objective C 相关">Objective C 相关<sup>24</sup></a></li>
		  
		
		  
			<li><a href="/categories/OpenCV/" title="OpenCV">OpenCV<sup>6</sup></a></li>
		  
		
		  
			<li><a href="/categories/ROS/" title="ROS">ROS<sup>9</sup></a></li>
		  
		
		  
			<li><a href="/categories/iOS-工具使用/" title="iOS 工具使用">iOS 工具使用<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/iOS-开源库分析/" title="iOS 开源库分析">iOS 开源库分析<sup>36</sup></a></li>
		  
		
		  
			<li><a href="/categories/iOS-理论基础/" title="iOS 理论基础">iOS 理论基础<sup>14</sup></a></li>
		  
		
		  
			<li><a href="/categories/iOS-进阶/" title="iOS 进阶">iOS 进阶<sup>4</sup></a></li>
		  
		
		  
			<li><a href="/categories/个人收藏/" title="个人收藏">个人收藏<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/代码规范/" title="代码规范">代码规范<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/其他/" title="其他">其他<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/博客分类目录/" title="博客分类目录">博客分类目录<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/叨叨系列/" title="叨叨系列">叨叨系列<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/开源代码分析/" title="开源代码分析">开源代码分析<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/开源库分析/" title="开源库分析">开源库分析<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/树莓派/" title="树莓派">树莓派<sup>4</sup></a></li>
		  
		
		  
			<li><a href="/categories/版本控制/" title="版本控制">版本控制<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/直播/" title="直播">直播<sup>6</sup></a></li>
		  
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">Tags</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/iOS-开源库分析/" title="iOS 开源库分析">iOS 开源库分析<sup>36</sup></a></li>
			
		
			
				<li><a href="/tags/Android-设计模式/" title="Android 设计模式">Android 设计模式<sup>29</sup></a></li>
			
		
			
				<li><a href="/tags/Objective-C-相关/" title="Objective C 相关">Objective C 相关<sup>24</sup></a></li>
			
		
			
				<li><a href="/tags/Android基础/" title="Android基础">Android基础<sup>21</sup></a></li>
			
		
			
				<li><a href="/tags/AOSP-源码/" title="AOSP 源码">AOSP 源码<sup>17</sup></a></li>
			
		
			
				<li><a href="/tags/Android-常用第三方库/" title="Android 常用第三方库">Android 常用第三方库<sup>15</sup></a></li>
			
		
			
				<li><a href="/tags/iOS-理论基础/" title="iOS 理论基础">iOS 理论基础<sup>14</sup></a></li>
			
		
			
				<li><a href="/tags/Hexo-使用/" title="Hexo 使用">Hexo 使用<sup>10</sup></a></li>
			
		
			
				<li><a href="/tags/ROS/" title="ROS">ROS<sup>9</sup></a></li>
			
		
			
				<li><a href="/tags/Android-动画进阶/" title="Android 动画进阶">Android 动画进阶<sup>8</sup></a></li>
			
		
			
				<li><a href="/tags/Android-JNI/" title="Android JNI">Android JNI<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/Android-绘图进阶/" title="Android 绘图进阶">Android 绘图进阶<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/Android性能优化/" title="Android性能优化">Android性能优化<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/Android-自动化测试/" title="Android 自动化测试">Android 自动化测试<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/OpenCV/" title="OpenCV">OpenCV<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/直播/" title="直播">直播<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/Android-开源源码/" title="Android 开源源码">Android 开源源码<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/Android-自定义View进阶/" title="Android 自定义View进阶">Android 自定义View进阶<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/树莓派/" title="树莓派">树莓派<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/iOS-进阶/" title="iOS 进阶">iOS 进阶<sup>4</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">Links</p>
    <ul>
        
          <li>
            
            	<a href="https://hexo.io" target="_blank" title="Hexo">Hexo</a>
            
          </li>
        
          <li>
            
            	<a href="https://pages.github.com/" target="_blank" title="GitHub">GitHub</a>
            
          </li>
        
          <li>
            
            	<a href="http://pf18.github.io/" target="_blank" title="PF18">PF18</a>
            
          </li>
        
          <li>
            
            	<a href="http://toutiao.io/" target="_blank" title="开发者头条">开发者头条</a>
            
          </li>
        
          <li>
            
            	<a href="http://www.jcodecraeer.com/" target="_blank" title="泡在网上的日子">泡在网上的日子</a>
            
          </li>
        
    </ul>
</div>

  


  <div class="rsspart">
	<a href="atom.xml" target="_blank" title="rss">RSS</a>
</div>

  
  <div class="tagcloudlist">
    <p class="asidetitle">Tag Cloud</p>
    <div class="tagcloudlist clearfix">
       <a href="/tags/AOSP-%E6%BA%90%E7%A0%81/" style="font-size: 17.14px;">AOSP 源码</a> <a href="/tags/Android-APK-%E7%AD%BE%E5%90%8D/" style="font-size: 10px;">Android APK 签名</a> <a href="/tags/Android-JNI/" style="font-size: 12.86px;">Android JNI</a> <a href="/tags/Android-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E8%BF%9B%E9%98%B6/" style="font-size: 10.71px;">Android 事件处理进阶</a> <a href="/tags/Android-%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6/" style="font-size: 13.57px;">Android 动画进阶</a> <a href="/tags/Android-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%80%E5%8F%91/" style="font-size: 10px;">Android 多线程开发</a> <a href="/tags/Android-%E5%B0%8F%E7%BB%8F%E9%AA%8C/" style="font-size: 10px;">Android 小经验</a> <a href="/tags/Android-%E5%B8%B8%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/" style="font-size: 16.43px;">Android 常用第三方库</a> <a href="/tags/Android-%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/" style="font-size: 10px;">Android 开发流程</a> <a href="/tags/Android-%E5%BC%80%E6%BA%90%E6%BA%90%E7%A0%81/" style="font-size: 12.14px;">Android 开源源码</a> <a href="/tags/Android-%E7%BB%98%E5%9B%BE%E8%BF%9B%E9%98%B6/" style="font-size: 12.86px;">Android 绘图进阶</a> <a href="/tags/Android-%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/" style="font-size: 12.86px;">Android 自动化测试</a> <a href="/tags/Android-%E8%87%AA%E5%AE%9A%E4%B9%89View%E8%BF%9B%E9%98%B6/" style="font-size: 12.14px;">Android 自定义View进阶</a> <a href="/tags/Android-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 19.29px;">Android 设计模式</a> <a href="/tags/Android%E5%85%B6%E4%BB%96/" style="font-size: 10px;">Android其他</a> <a href="/tags/Android%E5%9F%BA%E7%A1%80/" style="font-size: 17.86px;">Android基础</a> <a href="/tags/Android%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/" style="font-size: 10px;">Android开发流程</a> <a href="/tags/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" style="font-size: 12.86px;">Android性能优化</a> <a href="/tags/Android%E6%B7%B7%E6%B7%86%E6%8A%80%E6%9C%AF/" style="font-size: 10px;">Android混淆技术</a> <a href="/tags/Android%E8%B4%A8%E9%87%8F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/" style="font-size: 11.43px;">Android质量管理工具</a> <a href="/tags/Android%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/" style="font-size: 10px;">Android逆向工程</a> <a href="/tags/Git-github/" style="font-size: 10px;">Git && github</a> <a href="/tags/Hexo-%E4%BD%BF%E7%94%A8/" style="font-size: 15px;">Hexo 使用</a> <a href="/tags/JavaScript/" style="font-size: 10px;">JavaScript</a> <a href="/tags/Linux-%E4%BD%BF%E7%94%A8/" style="font-size: 10px;">Linux 使用</a> <a href="/tags/Objective-C-%E7%9B%B8%E5%85%B3/" style="font-size: 18.57px;">Objective C 相关</a> <a href="/tags/OpenCV/" style="font-size: 12.86px;">OpenCV</a> <a href="/tags/ROS/" style="font-size: 14.29px;">ROS</a> <a href="/tags/iOS-%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/" style="font-size: 10.71px;">iOS 工具使用</a> <a href="/tags/iOS-%E5%BC%80%E6%BA%90%E5%BA%93%E5%88%86%E6%9E%90/" style="font-size: 20px;">iOS 开源库分析</a> <a href="/tags/iOS-%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/" style="font-size: 15.71px;">iOS 理论基础</a> <a href="/tags/iOS-%E8%BF%9B%E9%98%B6/" style="font-size: 12.14px;">iOS 进阶</a> <a href="/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/" style="font-size: 10px;">代码规范</a> <a href="/tags/%E5%8D%9A%E5%AE%A2%E5%88%86%E7%B1%BB%E7%9B%AE%E5%BD%95/" style="font-size: 10.71px;">博客分类目录</a> <a href="/tags/%E5%8F%A8%E5%8F%A8%E7%B3%BB%E5%88%97/" style="font-size: 10px;">叨叨系列</a> <a href="/tags/%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/" style="font-size: 11.43px;">工具的使用</a> <a href="/tags/%E5%BC%80%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/" style="font-size: 10.71px;">开源代码分析</a> <a href="/tags/%E5%BC%80%E6%BA%90%E5%BA%93%E5%88%86%E6%9E%90/" style="font-size: 10px;">开源库分析</a> <a href="/tags/%E6%9D%82%E7%B1%BB/" style="font-size: 10px;">杂类</a> <a href="/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/" style="font-size: 12.14px;">树莓派</a> <a href="/tags/%E7%9B%B4%E6%92%AD/" style="font-size: 12.86px;">直播</a> <a href="/tags/%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/" style="font-size: 10.71px;">编程技巧</a> <a href="/tags/%E7%BD%91%E7%AB%99%E6%94%B6%E8%97%8F/" style="font-size: 10px;">网站收藏</a> <a href="/tags/%E9%87%8D%E8%A6%81%E6%8E%A7%E4%BB%B6/" style="font-size: 11.43px;">重要控件</a>
    </div>
  </div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
		
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/hsihohuang/kiddochan" target="_blank" title="Kiddochan">Kiddochan</a> © 2022 
		
		<a href="/about" target="_blank" title="Edgar">Edgar</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
        getSize();
        if (myWidth >= 1024) {
          c.click();
        }
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  c.click(function(){
    ta.css('display', 'block').addClass('fadeIn');
  });
  o.click(function(){
    ta.css('display', 'none');
  });
  $(window).scroll(function(){
    ta.css("top",Math.max(140,320-$(this).scrollTop()));
  });
});
</script>




<script type="text/javascript">
  var duoshuoQuery = {short_name:"tbfungeek"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script> 


<script type="text/javascript">

var disqus_shortname = 'tbfungeek';

(function(){
  var dsq = document.createElement('script');
  dsq.type = 'text/javascript';
  dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
}());
(function(){
  var dsq = document.createElement('script');
  dsq.type = 'text/javascript';
  dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/count.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
}());
</script>






<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?7c9443b0374f1cf6b1dbb5ab84d939cb";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="Back to Top"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
</html>
