
 <!DOCTYPE HTML>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
  
    <title>Edgar&#39;s Blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="Edgar">
    

    
    <meta name="description" content="Android | 全栈工程师">
<meta property="og:type" content="website">
<meta property="og:title" content="Edgar&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/page/7/index.html">
<meta property="og:site_name" content="Edgar&#39;s Blog">
<meta property="og:description" content="Android | 全栈工程师">
<meta property="og:locale">
<meta property="article:author" content="Edgar">
<meta name="twitter:card" content="summary">

    
    <link rel="alternative" href="atom.xml" title="Edgar&#39;s Blog" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/unnamed4_n_mSY_icon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/profile.png">
    <link rel="apple-touch-icon-precomposed" href="/img/profile.png">
    
    
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 6.2.0"></head>

  <body>
    <header>
      
<div>
		
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="Edgar&#39;s Blog">Edgar&#39;s Blog</a></h1>
				<h2 class="blog-motto"></h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="Menu">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
					<li>
 					
					<form class="search" action="/search/index.html" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" autocomplete="off" name="q" maxlength="20" placeholder="Search" />
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main">

   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/09/08/iOS-动态化方案总结/" title="iOS 动态化方案总结" itemprop="url">iOS 动态化方案总结</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Edgar" target="_blank" itemprop="author">Edgar</a>
		
  <p class="article-time">
    <time datetime="2019-09-07T17:58:19.000Z" itemprop="datePublished"> Published 2019-09-08</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p><img src="/2019/09/08/iOS-%E5%8A%A8%E6%80%81%E5%8C%96%E6%96%B9%E6%A1%88%E6%80%BB%E7%BB%93/0012.png"></p>
<h4 id="开篇叨叨"><a href="#开篇叨叨" class="headerlink" title="开篇叨叨"></a>开篇叨叨</h4><p>这一系列博客写到这里基本上是快完成第一阶段的内容了，在规划这一系列博客之前对该篇博客的定位是：综述现有的动态化热更新方案，然后介绍下JavaScriptCore,但是后面思考了下，因为这部分内容更新换代非常快，并且对这部分的选型往往会依照现有的项目实际情况，以及团队的技术栈和个人喜好，所以后续想弄成一个可更新不断迭代的方案对比列表，这里重点介绍JavaScriptCore以及动态化的核心内容。</p>
<p>我理解的动态化包括：应用内容的动态化，比如一些活动页面等经常更换内容的页面，还有一部分是包括热更新在内的通过发布补丁来修复线上bug。当然如果从宽泛角度来讲应用内可配置的内容也属于动态化。在技术选型的时候我们会将跨平台和动态化综合考虑，因为一个项目中不可能跨平台选用Flutter，动态化选用Weex。其实现有的比较流行的跨平台方案主要有ReactNative, Weex, 最基本的WebView + JsBridge,以及目前比较流行的Flutter. 如果动态化内容只是简单的活动展示页的化其实WebView + JsBridge就可以满足需求了。没必要引入三方框架，引入框架会带来整个包的体积增大。但是如果你的动态化页面包含许多交互，以及动态效果，往往这些动态效果需要比较高的性能。这时候就需要通过引入RN，Weex或者Flutter了，但是Flutter的动态化目前比较捉襟见肘，所以个人比较偏向RN 或者 Weex，两者比较还是比较偏向RN,但是Weex比较吸引我的是使用Vue来写前端页面。因为个人只会Vue 不会 React。RN 在后续的专题中会另起一个系列。目前打算是在个人对前端技术进行总结的时候来写这部分博客，哈哈，如果按照老规矩那又得一两年之后。但是说不准，可能会提前。</p>
<p>最后说个大家比较容易犯的误区就是：大家会认为动态化这部分只要配备一个Web开发就可以了，但是实际上项目中往往会遇到各种平台适配问题，所以这部分一般会以一个Web开发为主，然后iOS端和Android端各派出一个人手来进行接入以及支援。</p>
<p>好了叨叨结束就要开始我们的正题了</p>
<p>这篇博客主要从下面三个方面进行介绍:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1.</span> WKWebView</span><br><span class="line"><span class="bullet">2.</span> JavaScriptCore</span><br><span class="line"><span class="bullet">3.</span> Hybird &amp;&amp; JSBridge </span><br></pre></td></tr></table></figure>

<ol>
<li><strong><strong>WKWebView</strong></strong></li>
</ol>
<p>WKWebView是在iOS8的时候推出的，在这之前UIWebview是iOS平台的唯一选择。由于UIWebview存在系统级的内存泄露、极高内存峰值、较差的稳定性、以及Javascript的运行性能及通信限制等问题，反观WKWebView号称拥有60fps滚动刷新率，丰富的手势、高效的Web和Native通信机制，默认进度条采用了和safari相同的Nitro引擎极大提升了Javascript的运行速度，WKWebView独立的进程管理，也降低了内存占用及Crash对主App的影响。目前很多项目已经逐渐弃用UIWebview转向使用WKWebView，但是如果你的项目需要支持iOS7那么就必须要UIWebview和WKWebview混合使用,下面是二者的简单对比：</p>
<p><img src="/2019/09/08/iOS-%E5%8A%A8%E6%80%81%E5%8C%96%E6%96%B9%E6%A1%88%E6%80%BB%E7%BB%93/0008.png"></p>
<p>1.1 <strong><strong>UIWebview</strong></strong></p>
<p>在看WKWebView之前我们先看下UIWebview。UIWebview接口比较简单，它主要有如下几个部分构成：</p>
<p><strong><strong>页面加载</strong></strong>：</p>
<p>页面加载主要有三种方式一种是NSURLRequest，一种是http String格式，还有一种是NSData格式。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)loadRequest:(<span class="built_in">NSURLRequest</span> *)request;</span><br><span class="line">- (<span class="type">void</span>)loadHTMLString:(<span class="built_in">NSString</span> *)string baseURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)baseURL;</span><br><span class="line">- (<span class="type">void</span>)loadData:(<span class="built_in">NSData</span> *)data MIMEType:(<span class="built_in">NSString</span> *)MIMEType textEncodingName:(<span class="built_in">NSString</span> *)textEncodingName baseURL:(<span class="built_in">NSURL</span> *)baseURL;</span><br></pre></td></tr></table></figure>

<p><strong><strong>比较重要的属性</strong></strong>：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// UIWebView代理</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="type">id</span> &lt;<span class="built_in">UIWebViewDelegate</span>&gt; delegate;</span><br><span class="line"></span><br><span class="line"><span class="comment">//只读的scrollView 以及对应的request</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">strong</span>) <span class="built_in">UIScrollView</span> *scrollView API_AVAILABLE(ios(<span class="number">5.0</span>));</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">strong</span>) <span class="built_in">NSURLRequest</span> *request;</span><br><span class="line"></span><br><span class="line"><span class="comment">//一些状态属性</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">getter</span>=canGoBack) <span class="type">BOOL</span> canGoBack;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">getter</span>=canGoForward) <span class="type">BOOL</span> canGoForward;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">getter</span>=isLoading) <span class="type">BOOL</span> loading;</span><br><span class="line"></span><br><span class="line"><span class="comment">//其他控制UIWebView行为的属性</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong><strong>UIWebViewDelegate</strong></strong></p>
<p>我们可以看到iOS 13 上这些代理已经被标记为不支持了，所以一般情况下除非你的应用需要支持iOS 7，否则不再建议使用UIWebView了。</p>
<figure class="highlight erlang"><table><tr><td class="code"><pre><span class="line">- <span class="params">(BOOL)</span>webView:<span class="params">(UIWebView *)</span>webView shouldStartLoadWithRequest:<span class="params">(NSURLRequest *)</span>request navigationType:<span class="params">(UIWebViewNavigationType)</span>navigationType API_DEPRECATED<span class="params">(<span class="string">&quot;No longer supported.&quot;</span>, ios(<span class="number">2.0</span>, <span class="number">12.0</span>))</span>;</span><br><span class="line">- <span class="params">(void)</span>webViewDidStartLoad:<span class="params">(UIWebView *)</span>webView API_DEPRECATED<span class="params">(<span class="string">&quot;No longer supported.&quot;</span>, ios(<span class="number">2.0</span>, <span class="number">12.0</span>))</span>;</span><br><span class="line">- <span class="params">(void)</span>webViewDidFinishLoad:<span class="params">(UIWebView *)</span>webView API_DEPRECATED<span class="params">(<span class="string">&quot;No longer supported.&quot;</span>, ios(<span class="number">2.0</span>, <span class="number">12.0</span>))</span>;</span><br><span class="line">- <span class="params">(void)</span>webView:<span class="params">(UIWebView *)</span>webView didFailLoadWithError:<span class="params">(NSError *)</span>error API_DEPRECATED<span class="params">(<span class="string">&quot;No longer supported.&quot;</span>, ios(<span class="number">2.0</span>, <span class="number">12.0</span>))</span>;</span><br></pre></td></tr></table></figure>

<p><strong><strong>将javascript嵌入页面中</strong></strong></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)stringByEvaluatingJavaScriptFromString:(<span class="built_in">NSString</span> *)script;</span><br></pre></td></tr></table></figure>

<p>下面举几个简单的例子：</p>
<ul>
<li>获取当前页面的url<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)webViewDidFinishLoad:(<span class="built_in">UIWebView</span> *)webView &#123;  </span><br><span class="line">  <span class="built_in">NSString</span> *currentURL = [webView stringByEvaluatingJavaScriptFromString:<span class="string">@&quot;document.location.href&quot;</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>获取页面title<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)webViewDidFinishLoad:(<span class="built_in">UIWebView</span> *)webView &#123;  </span><br><span class="line">   <span class="built_in">NSString</span> *title = [webview stringByEvaluatingJavaScriptFromString:<span class="string">@&quot;document.title&quot;</span>]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>修改界面元素的值。<figure class="highlight mel"><table><tr><td class="code"><pre><span class="line">NSString *js_result = [webView stringByEvaluatingJavaScriptFromString:@&quot;document.getElementsByName(<span class="string">&#x27;q&#x27;</span>)[<span class="number">0</span>].value=<span class="string">&#x27;Hello World&#x27;</span>;<span class="string">&quot;];</span></span><br></pre></td></tr></table></figure></li>
<li>表单提交：<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">NSString *js_result2 = <span class="comment">[webView stringByEvaluatingJavaScriptFromString:@&quot;document.forms<span class="comment">[0]</span>.submit(); &quot;]</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong><strong>调用JavaScript方法</strong></strong></p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">self.context</span> = [self.webView valueForKeyPath:@<span class="string">&quot;documentView.webView.mainFrame.javaScriptContext&quot;</span>]<span class="comment">;</span></span><br><span class="line"><span class="section">[self.context evaluateScript:callScript]</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p><strong><strong>暴露方法给JavaScript调用</strong></strong></p>
<p>构建给JavaScript调用的对象JSObject</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">IDLJSObject *<span class="keyword">object</span> = [[IDLJSObject alloc] initWithViewController:<span class="built_in">self</span>];</span><br><span class="line"><span class="built_in">self</span>.context = [<span class="built_in">self</span>.viewHolder.webView valueForKeyPath:@<span class="string">&quot;documentView.webView.mainFrame.javaScriptContext&quot;</span>];</span><br><span class="line"><span class="built_in">self</span>.context[@<span class="string">&quot;appWebViewFinish&quot;</span>] = <span class="keyword">object</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">IDLJSObject</span>:<span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">IDLJSObject</span>()&lt;<span class="title">IDLOnlineJSExport</span>&gt;</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span> , <span class="keyword">weak</span>) <span class="built_in">UIViewController</span> *viewController;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">IDLJSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> mark - Life Cycle</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithViewController:(<span class="built_in">UIViewController</span> *)viewController &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="variable language_">super</span> init]) &#123;</span><br><span class="line">        _viewController = viewController;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> mark - Protocal IDLOnlineJSExport</span></span><br><span class="line">- (<span class="type">void</span>)finishWebView &#123;</span><br><span class="line">    nm_dispatch_to_main_queue(^&#123;</span><br><span class="line">        [<span class="keyword">self</span>.viewController.navigationController popViewControllerAnimated:<span class="literal">YES</span>];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>暴露出去的方法：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">IDLOnlineJSExport</span> &lt;<span class="title">JSExport</span>&gt;</span></span><br><span class="line">- (<span class="type">void</span>)finishWebView;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>1.2 <strong><strong>WKWebView</strong></strong></p>
<p><img src="/2019/09/08/iOS-%E5%8A%A8%E6%80%81%E5%8C%96%E6%96%B9%E6%A1%88%E6%80%BB%E7%BB%93/0002.png"></p>
<p>UIWebView 在很长一段时间里面由于占用内存大，JavaScript导致的内存泄漏深受诟病，而在iOS 8之后,Apple在它的WebKit库中新增加了WKWebView,WKWebView采用跨进程方案，Nitro JS 解析器，高达 60fps 的刷新率，并且高度支持H5特性，深受开发者的欢迎。在流程上WKWebView多暴露了一些细节给开发者，使得开发者在整个流程的把控上更加灵活了。</p>
<p><img src="/2019/09/08/iOS-%E5%8A%A8%E6%80%81%E5%8C%96%E6%96%B9%E6%A1%88%E6%80%BB%E7%BB%93/0001.png"></p>
<p><strong><strong>重要的属性</strong></strong></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">WKWebView</span>的配置</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">copy</span>) <span class="built_in">WKWebViewConfiguration</span> *configuration;</span><br><span class="line"></span><br><span class="line"><span class="built_in">WKWebView</span>重定位Delegate</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="type">id</span> &lt;<span class="built_in">WKNavigationDelegate</span>&gt; navigationDelegate;</span><br><span class="line"></span><br><span class="line"><span class="built_in">WKWebView</span>交互Delegate</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="type">id</span> &lt;<span class="built_in">WKUIDelegate</span>&gt; <span class="built_in">UIDelegate</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//与WKWebView相关联的ScrollView</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">strong</span>) <span class="built_in">UIScrollView</span> *scrollView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *title;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">copy</span>) <span class="built_in">NSURL</span> *URL;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">getter</span>=isLoading) <span class="type">BOOL</span> loading;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="type">double</span> estimatedProgress;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="type">BOOL</span> hasOnlySecureContent;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="type">BOOL</span> canGoBack;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="type">BOOL</span> canGoForward;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="type">BOOL</span> allowsBackForwardNavigationGestures;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *customUserAgent API_AVAILABLE(macos(<span class="number">10.11</span>), ios(<span class="number">9.0</span>));</span><br></pre></td></tr></table></figure>

<p><strong><strong>加载方法</strong></strong></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">WKNavigation</span> *)loadRequest:(<span class="built_in">NSURLRequest</span> *)request;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">WKNavigation</span> *)loadFileURL:(<span class="built_in">NSURL</span> *)URL allowingReadAccessToURL:(<span class="built_in">NSURL</span> *)readAccessURL API_AVAILABLE(macos(<span class="number">10.11</span>), ios(<span class="number">9.0</span>));</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">WKNavigation</span> *)loadHTMLString:(<span class="built_in">NSString</span> *)string baseURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)baseURL;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">WKNavigation</span> *)loadData:(<span class="built_in">NSData</span> *)data MIMEType:(<span class="built_in">NSString</span> *)MIMEType characterEncodingName:(<span class="built_in">NSString</span> *)characterEncodingName baseURL:(<span class="built_in">NSURL</span> *)baseURL API_AVAILABLE(macos(<span class="number">10.11</span>), ios(<span class="number">9.0</span>));</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong><strong>重要的方法</strong></strong></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">WKNavigation</span> *)goBack;</span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">WKNavigation</span> *)goForward;</span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">WKNavigation</span> *)reload;</span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">WKNavigation</span> *)reloadFromOrigin;</span><br><span class="line">- (<span class="type">void</span>)stopLoading;</span><br></pre></td></tr></table></figure>

<p><strong><strong>执行JavaScript方法</strong></strong></p>
<figure class="highlight erlang"><table><tr><td class="code"><pre><span class="line">- <span class="params">(void)</span>evaluateJavaScript:<span class="params">(NSString *)</span>javaScriptString completionHandler:<span class="params">(void (^ _Nullable)</span><span class="params">(_Nullable id, NSError * _Nullable error)</span>)completionHandler;</span><br></pre></td></tr></table></figure>

<p><strong><strong>WKNavigationDelegate</strong></strong></p>
<p>从上图上看关于UIWebView与WKWebView的代理主要区别在于UIWebView只在加载的时候问询一次，而WKWebView在URL对应的内容加载结束之后还会进行一次问询，下面会对二者的代理进行一一对比。</p>
<p>是否加载的问询</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> mark - UIWebViewDelegate</span></span><br><span class="line">- (<span class="type">BOOL</span>)webView:(<span class="built_in">UIWebView</span> *)webView shouldStartLoadWithRequest:(<span class="built_in">NSURLRequest</span> *)request navigationType:(<span class="built_in">UIWebViewNavigationType</span>)navigationType &#123;<span class="keyword">return</span> <span class="literal">YES</span>;&#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">#<span class="keyword">pragma</span> mark - WKNavigationDelegate</span></span><br><span class="line"> <span class="comment">//加载之前问询</span></span><br><span class="line">- (<span class="type">void</span>)webView:(<span class="built_in">WKWebView</span> *)webView decidePolicyForNavigationAction:(<span class="built_in">WKNavigationAction</span> *)navigationAction decisionHandler:(<span class="type">void</span> (^)(<span class="built_in">WKNavigationActionPolicy</span>))decisionHandler &#123; &#125;</span><br><span class="line"><span class="comment">//加载之后问询</span></span><br><span class="line">- (<span class="type">void</span>)webView:(<span class="built_in">WKWebView</span> *)webView decidePolicyForNavigationResponse:(<span class="built_in">WKNavigationResponse</span> *)navigationResponse decisionHandler:(<span class="type">void</span> (^)(<span class="built_in">WKNavigationResponsePolicy</span>))decisionHandler &#123; &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>同意载入之后，组件就开始下载指定 URL 的内容，在下载之前会调用一次 开始下载 回调，通知开发者 Web 已经开始下载。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> mark - UIWebViewDelegate</span></span><br><span class="line">- (<span class="type">void</span>)webViewDidStartLoad:(<span class="built_in">UIWebView</span> *)webView &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> mark - WKNavigationDelegate</span></span><br><span class="line"><span class="comment">//Invoked when a main frame navigation starts.</span></span><br><span class="line">- (<span class="type">void</span>)webView:(<span class="built_in">WKWebView</span> *)webView didStartProvisionalNavigation:(<span class="keyword">null_unspecified</span> <span class="built_in">WKNavigation</span> *)navigation &#123; &#125;</span><br><span class="line"><span class="comment">//Invoked when content starts arriving for the main frame.</span></span><br><span class="line">- (<span class="type">void</span>)webView:(<span class="built_in">WKWebView</span> *)webView didCommitNavigation:(<span class="keyword">null_unspecified</span> <span class="built_in">WKNavigation</span> *)navigation &#123; &#125;</span><br></pre></td></tr></table></figure>

<p>页面下载完毕之后，UIWebView 会直接载入视图并调用载入成功回调，而WKWebView 会发询问，确定下载的内容被允许之后再载入视图。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> mark - UIWebViewDelegate</span></span><br><span class="line">- (<span class="type">void</span>)webViewDidFinishLoad:(<span class="built_in">UIWebView</span> *)webView &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> mark - WKNavigationDelegate</span></span><br><span class="line">- (<span class="type">void</span>)webView:(<span class="built_in">WKWebView</span> *)webView didFinishNavigation:(<span class="keyword">null_unspecified</span> <span class="built_in">WKNavigation</span> *)navigation &#123; &#125;</span><br></pre></td></tr></table></figure>
<p>如果载入失败则会调用对应的代理进行处理。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> mark - UIWebViewDelegate</span></span><br><span class="line">- (<span class="type">void</span>)webView:(<span class="built_in">UIWebView</span> *)webView didFailLoadWithError:(<span class="built_in">NSError</span> *)error &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> mark - WKNavigationDelegate</span></span><br><span class="line">- (<span class="type">void</span>)webView:(<span class="built_in">WKWebView</span> *)webView didFailProvisionalNavigation:(<span class="keyword">null_unspecified</span> <span class="built_in">WKNavigation</span> *)navigation withError:(<span class="built_in">NSError</span> *)error &#123; &#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)webView:(<span class="built_in">WKWebView</span> *)webView didFailNavigation:(<span class="keyword">null_unspecified</span> <span class="built_in">WKNavigation</span> *)navigation withError:(<span class="built_in">NSError</span> *)error &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>除了上面的差异外WKWebView还多处了几处回调：</p>
<p>重定向回调：</p>
<p>WKWebView 在收到服务器重定向消息并且跳转询问允许之后，会回调重定向方法，这点是 UIWebView 没有的。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> mark - WKNavigationDelegate</span></span><br><span class="line">- (<span class="type">void</span>)webView:(<span class="built_in">WKWebView</span> *)webView didReceiveServerRedirectForProvisionalNavigation:(<span class="keyword">null_unspecified</span> <span class="built_in">WKNavigation</span> *)navigation;</span><br></pre></td></tr></table></figure>

<p>因为 WKWebView 是跨进程的方案，当 WKWebView 进程退出时，会对主进程做一次方法回调。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)<span class="attr">webViewWebContentProcessDidTerminate</span>:(<span class="title class_">WKWebView</span> *)webView <span class="title function_">API_AVAILABLE</span>(<span class="params">macosx(<span class="number">10.11</span>), ios(<span class="number">9.0</span>)</span>) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>HTTPS 证书自定义处理</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)webView:(<span class="built_in">WKWebView</span> *)webView didReceiveAuthenticationChallenge:(<span class="built_in">NSURLAuthenticationChallenge</span> *)challenge completionHandler:(<span class="type">void</span> (^)(<span class="built_in">NSURLSessionAuthChallengeDisposition</span> disposition, <span class="built_in">NSURLCredential</span> * _Nullable credential))completionHandler</span><br></pre></td></tr></table></figure>

<p><strong><strong>WKUIDelegate</strong></strong></p>
<p>WKUIDelegate 包含了一系列UI相关的代理，包括Alert、Confirm、Prompt 等视图，以及WebView的创建以及关闭等。这个是之前UIWebView所不具备的，需要通过JS桥来实现。还有在 iOS 10之后，WKUIDelegate还新增了链接预览的支持，相关方法也在该协议中。</p>
<p><strong><strong>调用JavaScript方法</strong></strong></p>
<p>调用JavaScript方法是通过对应WebView提供的接口实现，但是WKWebView与UIWebView二者在实现上还是有区别的：WKWebView的接口是异步的，而UIWebView是同步的</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> mark - WKWebView</span></span><br><span class="line">[wkWebView evaluateJavaScript:<span class="string">@&quot;document.title&quot;</span></span><br><span class="line">            completionHandler:^(<span class="type">id</span> _Nullable ret, <span class="built_in">NSError</span> * _Nullable error) &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *title = ret;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p><strong><strong>暴露方法给JavaScript调用</strong></strong></p>
<p>创建WKUserContentController，并添加到WKWebViewConfiguration，在初始化的时候传入WKWebView</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">WKUserContentController</span> <span class="operator">*</span>userContent <span class="operator">=</span> [[<span class="type">WKUserContentController</span> alloc] <span class="keyword">init</span>];</span><br><span class="line">[userContent addScriptMessageHandler:id<span class="operator">&lt;</span><span class="type">WKScriptMessageHandler</span><span class="operator">&gt;</span> name:@<span class="string">&quot;MyNative&quot;</span>];</span><br><span class="line">    </span><br><span class="line"><span class="type">WKWebViewConfiguration</span> <span class="operator">*</span>config <span class="operator">=</span> [[<span class="type">WKWebViewConfiguration</span> alloc] <span class="keyword">init</span>];</span><br><span class="line">config.userContentController <span class="operator">=</span> userContent;</span><br><span class="line">    </span><br><span class="line"><span class="type">WKWebView</span> <span class="operator">*</span>webView <span class="operator">=</span> [[<span class="type">WKWebView</span> alloc] initWithFrame:<span class="type">CGRectZero</span> configuration:config];</span><br></pre></td></tr></table></figure>

<p>实现WKScriptMessageHandler，在这里可以接收WKScriptMessage类型的数据。WKScriptMessage类型的数据的body可以存放 NSNumber, NSString, NSDate, NSArray,NSDictionary, 以及 NSNull类型的数据</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> mark - WKScriptMessageHandler</span></span><br><span class="line">-  (<span class="type">void</span>)userContentController:(<span class="built_in">WKUserContentController</span> *)userContentController didReceiveScriptMessage:(<span class="built_in">WKScriptMessage</span> *)message &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完成如下工作后Js中就可以通过如下形式进行调用native方法了：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> call<span class="constructor">Native()</span> &#123;</span><br><span class="line">  window.webkit.messageHandlers.<span class="module-access"><span class="module"><span class="identifier">MyNative</span>.</span></span>post<span class="constructor">Message(&#x27;<span class="params">body</span>&#x27;)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><strong>WKWebView的关键节点</strong></strong></p>
<p>对于Web开发，业务逻辑一般是基于Web容器的关键节点展开的，我们需要很清楚得了解何时注入对应的Js脚本，何时对Web容器进行设置，何时启动加载，都有哪些回调，何时回调，下面两张图很清楚得解释了这部分内容：</p>
<p><img src="/2019/09/08/iOS-%E5%8A%A8%E6%80%81%E5%8C%96%E6%96%B9%E6%A1%88%E6%80%BB%E7%BB%93/0009.png"><br><img src="/2019/09/08/iOS-%E5%8A%A8%E6%80%81%E5%8C%96%E6%96%B9%E6%A1%88%E6%80%BB%E7%BB%93/0010.png"></p>
<p><strong><strong>浏览器组成</strong></strong></p>
<p>整个浏览器的大致结构如下所示：</p>
<p><img src="/2019/09/08/iOS-%E5%8A%A8%E6%80%81%E5%8C%96%E6%96%B9%E6%A1%88%E6%80%BB%E7%BB%93/0003.png"></p>
<p>每个浏览器都有自己的内核，Safari的内核就是WebKit，上图的介于浏览器UI Layer 和 Native Layer的就是浏览器的内核WebKit.WebKit Embedding API负责WebKit与浏览器UI Layer进行交互的部分。Platform API 是为了让WebKit更加方便得移植到各个操作系统而提供的一些与平台无关，但是开放给平台的接口，这个和Android 的 HAL层一个道理，一般像FreeRTOS类似的可移植的跨平台操作系统都会存在一个抽象层来隔离各个底层的差异。这些接口会被各个平台以不同的实现来提供支持，比如上图的渲染层面，在iOS系统中，Safari是交给CoreGraphics处理，而在Android系统中，Webkit则是交给Skia。介绍了WebKit Embedding API,Platform API后接下来介绍WebKit最重要的两个部分WebCore和JavaScriptCore两大部分。</p>
<p>WebKit会有多个版本，但是WebCore这个部件是所有WebKit所共享的，不同版本WebKit之间的差异一般在于JavaScript Core, 各个基于WebKit内核的浏览器厂商一般会对各自浏览器的JS引擎进行性能优化，优化的部分就是针对JavaScript Core。这里我们来介绍下WebCore和JavaScriptCore两大部分的分工，我们在打开一个网页的时候，首先会通过网络去下载对应的HTML,CSS,JavaScript 脚本，其中HTML,CSS会被WebCore的 HTML Parser, CSS 解析成DOM树以及CSSOM树，然后以HTML为骨架，CSS为样式将DOM树以及CSSOM树合并，最终生成渲染树。</p>
<p>这时候JavaScript脚本通过词法分析，生成一个个Token序列，这个过程称为分词，分词是通过Lexer来完成的。这个步骤关注的是Token的提取，而不关注每个Token之间的关系。</p>
<p>将词法提取成功后接下来就是语法分析，这个步骤的任务就是如何将词法分析获得的Token序列通过处理形成一个抽象语法树（AST）.</p>
<p>然后字节码生成器就会根据AST来生成JavaScript Core 字节码。一般的编译型语言会将这些生成的字节编码存放在内存或者硬盘之中，而对于解释型语言会将生成的字节码立即给JavaScript Core这台虚拟机进行逐行解释执行。一般会由低延时LLint(低级解释器)来解释执行生成的字节码，当遇到多次重复调用或者递归调用，以及循环等情况的时候会通过OSR切换成JIT(实时编译)进行解释执行，JIT主要有三种：</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">* <span class="keyword">Baseline </span><span class="keyword">JIT </span>基线<span class="keyword">JIT</span></span><br><span class="line"><span class="keyword"></span>* DFG 低延迟优化的<span class="keyword">JIT</span></span><br><span class="line"><span class="keyword"></span>* FTL 高通量优化的<span class="keyword">JIT</span></span><br></pre></td></tr></table></figure>

<p>我们再次回到WebCore 流程：在JavaScript在 JavaScriptCore中 被解释执行的时候，会对WebCore中生成的渲染树有影响，它有可能添加DOM节点，删除DOM节点，修改DOM节点，最终经过修改后的渲染树会通过调用Native API通过平台的渲染框架渲染到屏幕上。</p>
<p>下图是JavaScriptCore 描述得比较好的一张结构图：</p>
<p><img src="/2019/09/08/iOS-%E5%8A%A8%E6%80%81%E5%8C%96%E6%96%B9%E6%A1%88%E6%80%BB%E7%BB%93/0011.png"></p>
<p>JavaScript Core的单线程机制：</p>
<p>在理解JavaScriptCore 机制的时候需要注意的是它的单线程机制，整个JS代码是执行在一条线程里的，它不具备多线程处理能力，它不像OC语言那样可以在自己的执行环境里面申请到多条线程去处理一些耗时任务，从而避免主线程被阻塞。但是接触过JS的伙伴可能会产生疑问，为什么记得也存在多线程异步的概念。这就得益于强大的事件驱动机制。</p>
<p>在遇到耗时任务的时候，JS会吧这个任务抛给由JS宿主提供的工作线程去处理，工作线程处理完毕之后，会发送一个消息通知JS线程当前任务已经执行完毕了，JS 线程得知这个消息后就会转而响应这个消息。但是这里需要注意的是JS线程和工作线程并不在一个运行环境，所以它们不共享一个作用域，所以工作线程中不能操作DOM.</p>
<p><strong><strong>iOS 中的JavaScript Core</strong></strong></p>
<p>Apple通过将WebKit的JS引擎用OC封装,提供了一套JS运行环境以及Native与JS数据类型之间的转换桥梁.整个架构大致长这样：</p>
<p><img src="/2019/09/08/iOS-%E5%8A%A8%E6%80%81%E5%8C%96%E6%96%B9%E6%A1%88%E6%80%BB%E7%BB%93/0007.jpg"></p>
<p>iOS 中的JavaScript Core 主要由如下类组成：</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="bullet">* </span>JSVirtualMachine</span><br><span class="line"><span class="bullet">* </span>JSContext</span><br><span class="line"><span class="bullet">* </span>JSValue</span><br><span class="line"><span class="bullet">* </span>JSExport</span><br></pre></td></tr></table></figure>

<p>举个例子：</p>
<ul>
<li>在虚拟机中执行某段代码：<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">//</span>创建虚拟机</span><br><span class="line">JSVirtualMachine *vm = [[JSVirtualMachine alloc] init];</span><br><span class="line"><span class="regexp">//</span>创建上下文</span><br><span class="line">JSContext *context = [[JSContext alloc] initWithVirtualMachine:vm];</span><br><span class="line"><span class="regexp">//</span>执行JavaScript代码并获取返回值</span><br><span class="line">JSValue *value = [context evaluateScript:@<span class="string">&quot;1+1&quot;</span>];</span><br><span class="line"><span class="regexp">//</span>转换成OC数据并打印</span><br><span class="line">NSLog(@<span class="string">&quot;value = %d&quot;</span>, [value toInt32]);</span><br></pre></td></tr></table></figure></li>
<li>在Native中运行JS方法</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> nativeCallJS = <span class="keyword">function</span> (<span class="params">parameter</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">alert</span>(parameter);</span></span><br><span class="line"><span class="language-javascript">    &#125;;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">JSContext </span>*<span class="keyword">jsContext </span>= [webView valueForKeyPath:@“documentView.webView.mainFrame.<span class="keyword">javaScriptContext”];</span></span><br><span class="line"><span class="keyword"></span><span class="keyword">JSValue </span>*<span class="keyword">jsMethod </span>= <span class="keyword">jsContext[@&quot;nativeCallJS&quot;];</span></span><br><span class="line"><span class="keyword"></span>[<span class="keyword">jsMethod </span>callWithArguments:@[ @<span class="string">&quot;Hello JS, I am iOS&quot;</span> ]];</span><br></pre></td></tr></table></figure>
<ul>
<li>在JS中运行Native方法</li>
</ul>
<figure class="highlight elm"><table><tr><td class="code"><pre><span class="line">//<span class="type">Html</span>中按钮点击调用一个<span class="type">OC</span>方法</span><br><span class="line">&lt;button <span class="keyword">type</span>=&quot;button&quot; onclick=&quot;jsCallNative(&#x27;<span class="type">Hello</span> iOS&#x27;, &#x27;<span class="type">I</span> am <span class="type">JS</span>&#x27;);&quot;&gt;调用<span class="type">OC</span>代码&lt;/button&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">JSContext </span>*<span class="keyword">jsContext </span>= [webView valueForKeyPath:@<span class="string">&quot;documentView.webView.mainFrame.javaScriptContext&quot;</span>];</span><br><span class="line"><span class="keyword">jsContext[@&quot;jsCallNative&quot;] </span>= ^() &#123;</span><br><span class="line">    NSArray *args = [<span class="keyword">JSContext </span>currentArguments];</span><br><span class="line">    for (<span class="keyword">JSValue </span>*obj in args) &#123;</span><br><span class="line">        NSLog(@<span class="string">&quot;%@&quot;</span>, obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>异常处理:</li>
</ul>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">JSContext </span>*<span class="keyword">jsContext </span>= [[<span class="keyword">JSContext </span>alloc] init];</span><br><span class="line"><span class="keyword">jsContext.exceptionHandler </span>= ^(<span class="keyword">JSContext </span>*<span class="built_in">context</span>, <span class="keyword">JSValue </span> *exception) &#123;</span><br><span class="line">    NSLog(@<span class="string">&quot;JS Error: %@&quot;</span>, exception);</span><br><span class="line">&#125;;</span><br><span class="line">[<span class="keyword">jsContext </span>evaluateScript:@<span class="string">&quot;(function errTest()&#123; return a+1; &#125;)();&quot;</span>];</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><strong>JSVirtualMachine</strong></strong></li>
</ul>
<p>JSVirtualMachine是一个完整独立的JavaScript的执行环境，它主要完成如下两个任务：</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="bullet">* </span>支持并发的JS调用</span><br><span class="line"><span class="bullet">* </span>JS和Native桥接对象的内存管理</span><br></pre></td></tr></table></figure>
<p>上面提到的单线程机制指的是在一个JSVirtualMachine中，只有一条线程可以跑JS代码，所以我们无法在一个JSVirtualMachine中进行多线程处理JS任务，如果需要多线程处理那么就需要创建多个JSVirtualMachine来分别跑这些任务，从而达到多线程处理的目的。</p>
<ul>
<li><strong><strong>JSContext</strong></strong></li>
</ul>
<p>一个JSContext对象代表一个JavaScript执行环境,它支持在Native代码中使用JSContext去执行JS代码，访问JS中定义或者计算的值，并使JavaScript可以访问Native的对象、方法、函数.</p>
<p>每个JSContext都只能属于一个JSVirtualMachine，但是一个JSVirtualMachine可以有多个JSContext。并且这些多个JSContext可以相互传值。由于每个JSVirtualMachine都是独立且完整的，这里的独立指的是独立的堆空间以及垃圾回收器，某个虚拟机中的GC无法处理别的虚拟机堆中的对象。所以JSVirtualMachine之间不允许相互传值。</p>
<p><img src="/2019/09/08/iOS-%E5%8A%A8%E6%80%81%E5%8C%96%E6%96%B9%E6%A1%88%E6%80%BB%E7%BB%93/0004.png"></p>
<ul>
<li><p>JSContext执行JS代码<br>JSContext执行JS代码 是通过调用 evaluateScript函数来完成的，它可以向global对象添加函数和对象定义，它的返回值是JavaScript代码中最后一个生成的值。</p>
</li>
<li><p>JSContext访问JS对象</p>
</li>
</ul>
<p>可以通过三种方式来访问JavaScript对象，以及设置对应的属性。</p>
<ul>
<li>通过context的实例方法objectForKeyedSubscript</li>
<li>通过context.globalObject的objectForKeyedSubscript实例方法</li>
<li>通过下标方式</li>
</ul>
<figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line"><span class="symbol">JSValue</span> *value = [context evaluateScript:@<span class="string">&quot;var a = 1+2*3;&quot;</span>];</span><br><span class="line"><span class="symbol">NSLog</span>(@<span class="string">&quot;a = %@&quot;</span>, [context objectForKeyedSubscript:@<span class="string">&quot;a&quot;</span>]);</span><br><span class="line"><span class="symbol">NSLog</span>(@<span class="string">&quot;a = %@&quot;</span>, [context.globalObject objectForKeyedSubscript:@<span class="string">&quot;a&quot;</span>]);</span><br><span class="line"><span class="symbol">NSLog</span>(@<span class="string">&quot;a = %@&quot;</span>, context[@<span class="string">&quot;a&quot;</span>]);</span><br><span class="line"></span><br><span class="line">context[@<span class="string">&quot;makeColor&quot;</span>] = ^(<span class="symbol">NSDictionary</span> *rgb)&#123;</span><br><span class="line">    float r = [rgb[@<span class="string">&quot;red&quot;</span>] floatValue];</span><br><span class="line">    float g = [rgb[@<span class="string">&quot;green&quot;</span>] floatValue];</span><br><span class="line">    float b = [rgb[@<span class="string">&quot;blue&quot;</span>] floatValue];</span><br><span class="line">    return [<span class="symbol">NSColor</span> colorWithRed:(r / <span class="number">255.</span>f) green:(g / <span class="number">255.</span>f) blue:(b / <span class="number">255.</span>f)         alpha:<span class="number">1.0</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="symbol">JSValue</span> *value = [context evaluateScript:@<span class="string">&quot;makeColor(&#123;red:12, green:23, blue:67&#125;)&quot;</span>];</span><br></pre></td></tr></table></figure>


<p>相关的API:</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">JSContext</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建一个JSContext，同时会创建一个新的JSVirtualMachine */</span></span><br><span class="line">(<span class="keyword">instancetype</span>)init;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在指定虚拟机上创建一个JSContext */</span></span><br><span class="line">(<span class="keyword">instancetype</span>)initWithVirtualMachine:(JSVirtualMachine*)virtualMachine;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 执行一段JS代码，返回最后生成的一个值 */</span></span><br><span class="line">(JSValue *)evaluateScript:(<span class="built_in">NSString</span> *)script;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 执行一段JS代码，并将sourceURL认作其源码URL（仅作标记用） */</span></span><br><span class="line">- (JSValue *)evaluateScript:(<span class="built_in">NSString</span> *)script withSourceURL:(<span class="built_in">NSURL</span>*)sourceURL <span class="built_in">NS_AVAILABLE</span>(<span class="number">10</span>_10, <span class="number">8</span>_0);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取当前执行的JavaScript代码的context */</span></span><br><span class="line">+ (JSContext *)currentContext;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取当前执行的JavaScript function*/</span></span><br><span class="line">+ (JSValue *)currentCallee <span class="built_in">NS_AVAILABLE</span>(<span class="number">10</span>_10, <span class="number">8</span>_0);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取当前执行的JavaScript代码的this */</span></span><br><span class="line">+ (JSValue *)currentThis;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Returns the arguments to the current native callback from JavaScript code.*/</span></span><br><span class="line">+ (<span class="built_in">NSArray</span> *)currentArguments;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取当前context的全局对象。WebKit中的context返回的便是WindowProxy对象*/</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">strong</span>) JSValue *globalObject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>) JSValue *exception;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">copy</span>) <span class="type">void</span>(^exceptionHandler)(JSContext *context, JSValue *exception);</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">strong</span>) JSVirtualMachine *virtualMachine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">copy</span>) <span class="built_in">NSString</span> *name <span class="built_in">NS_AVAILABLE</span>(<span class="number">10</span>_10, <span class="number">8</span>_0);</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">JSContext</span> (<span class="title">SubscriptSupport</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 首先将key转为JSValue对象，然后使用这个值在JavaScript context的全局对象中查找这个名字的属性并返回 */</span></span><br><span class="line">(JSValue *)objectForKeyedSubscript:(<span class="type">id</span>)key;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 首先将key转为JSValue对象，然后用这个值在JavaScript context的全局对象中设置这个属性。</span></span><br><span class="line"><span class="comment">可使用这个方法将native中的对象或者方法桥接给JavaScript调用 */</span></span><br><span class="line">(<span class="type">void</span>)setObject:(<span class="type">id</span>)object forKeyedSubscript:(<span class="built_in">NSObject</span> &lt;<span class="built_in">NSCopying</span>&gt;*)key;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong><strong>JSValue</strong></strong></li>
</ul>
<p>一个JSValue实例就是一个JavaScript值的引用。通过JSValue可以在JavaScript和Native之间进行一些基本类型的数据转换，也可以使用它来创建包裹了自定义Native对象的JavaScript对象。甚至可以创建由Native方法或者block实现的JavaScript函数.</p>
<p>每个JSValue对象都持有其JSContext对象的强引用，只要有任何一个与特定JSContext关联的JSValue被持有,这个JSContext就会一直存活。</p>
<p>同时需要注意的是每个JSValue都通过其JSContext间接关联了一个特定的JSVirtualMachine对象。只能将一个JSValue对象传给由相同虚拟机管理的JSValue或者JSContext的实例方法。如果尝试把一个虚拟机的JSValue传给另一个虚拟机，将会触发Objective-C异常。</p>
<p><img src="/2019/09/08/iOS-%E5%8A%A8%E6%80%81%E5%8C%96%E6%96%B9%E6%A1%88%E6%80%BB%E7%BB%93/0005.png"></p>
<p>Apple提供了JSValue与Native进行相互转换的接口：<br>大家可以查看：<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/javascriptcore/jsvalue?language=objc">JSValue API 苹果官方文档</a></p>
<p><img src="/2019/09/08/iOS-%E5%8A%A8%E6%80%81%E5%8C%96%E6%96%B9%E6%A1%88%E6%80%BB%E7%BB%93/0006.png"></p>
<ul>
<li><strong><strong>JSExport</strong></strong></li>
</ul>
<p>通过实现JSExport协议可以开放OC类和它们的实例方法，类方法，以及属性给JS调用。</p>
<p>这个在介绍之前介绍UIWebView的时候已经介绍过了，例子大家可以查看上面的部分。</p>
<ul>
<li><p><strong><strong>深入阅读</strong></strong></p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://www.starming.com/2017/10/11/deeply-analyse-webkit/">剖析剖析WebKit</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://ming1016.github.io/2018/04/21/deeply-analyse-javascriptcore/">深入剖析 JavaScriptCore</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://webkithacks.github.io/webkit_presentations/architecture/#title-slide">WebKit Architecture</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/34646281">iOS 中的 JS</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1004875">JavaScriptCore全面解析 （上篇）</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1004876">JavaScriptCore全面解析 （下篇）</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/ac534f508fb0">深入浅出 JavaScriptCore</a></p>
</li>
</ul>
<ol start="3">
<li><strong><strong>Hybird</strong></strong></li>
</ol>
<p>为啥要使用Hybird,为解答这个疑问可以看下Hybird有哪些优点：</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="bullet">* </span>能够在不更新应用版本的情况下进行功能的快速更新迭代</span><br><span class="line"><span class="bullet">* </span>多端复用，减少不同平台重复开发的工作量</span><br></pre></td></tr></table></figure>

<p>就目前而言，除了一些小规模的应用外，大部分的应用都会引入混合开发技术，混合开发技术也从简单的基于WebView + JSBridge的实现，到React Native、Weex这些比较成熟的开源库。关于跨平台开发技术的总结大家可以查看我之前写的 《在部门内分享的Flutter材料》那里有对整个跨平台技术进行了比较全面的总结，这里就不详细展开了。</p>
<p>相信通过上面两部分的介绍大家对WKWebView,以及JavaScriptCore技术有了一个比较清楚的了解了,这两部分是接下来介绍Hybird的重要基础，接下来想和大家聊下Hybird框架的设计，这里只是谈论下Hybird设计的一些关键技术以及思想，后续会带大家解析一些较为流行的Hybird框架，后续也会将自己的一套简单的Hybird框架开源出来，所以这里大家先一起来了解一个Hybird框架应该包含哪些部分，具体涉及到哪些技术。各个部分在设计的时候应该注意哪些问题。</p>
<p>一个完整的 Hybrid 框架主要包括 WebView容器、Bridge、预加载、缓存等模块，还需要发布平台、灰度平台、增量更新、CDN 平台等等，这是很庞大的一个平台，并不是简单的 WebView容器 + Bridge. 当然如果只是简单的项目WebView容器 + Bridge已经足够支持。</p>
<p>下面将针对如下几点进行简要介绍一个Hybird的设计：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1.</span>  WebView容器设计</span><br><span class="line"><span class="bullet">2.</span>  JSBridge设计</span><br><span class="line">2.1 Router 设计</span><br><span class="line">2.2 Actions 设计</span><br><span class="line"><span class="bullet">3.</span> 预加载和缓存设计</span><br><span class="line"><span class="bullet">4.</span> 发布 &amp;&amp; 灰度平台设计</span><br><span class="line"><span class="bullet">5.</span> 增量更新设计</span><br></pre></td></tr></table></figure>

<p><strong><strong>WebView容器设计</strong></strong></p>
<p>在前面介绍WebView的时候已经介绍过UIWebView将在iOS 13上废弃使用了，所以除非你的项目需要兼容iOS7版本的话，否则不应该还使用UIWebView。所以剩下的问题就是如何通过WKWebView来设计我们的Hybird框架了。</p>
<p><strong><strong>JSBridge设计</strong></strong></p>
<p>JSBridge是整个Hybird的最重要部分，它是Web与Native交互的核心部分，一般是通过Native与Web商定协议，通过协议告诉对方需要调用哪个方法，使用哪些参数，目前用得比较多的是基于URL的拦截机制，在收到URL请求的时候对URL进行校验提取：</p>
<p>首先校验是否是该项目的Hybird请求，如果是的话从url中提取出请求类别，是Router还是某个对应的Action,具体类别的行为，比如当前请求类别是Action那么具体是调起通话action还是打开通讯录action，请求参数等等。下面将针对如下两点进行展开：</p>
<ul>
<li>如何注入JSBridge功能：</li>
</ul>
<p>就目前方案而言用得较多的就是基于URL的拦截机制，也就是在每次收到请求的时候WebView都会有机会对当前请求做个拦截决定是否继续加载某个页面，通过这个时机如果发现是我们定义的JSBridge请求那么就拦截不进行跳转，转而调用本地的方法。这也是我们项目目前采用的一种方法。它的优点是比较通用Android 和 iOS都有这一套机制。所以实现的时候可以很方便得保持一套思路。有助于框架的统一。</p>
<p>另一种是iOS所独有的是WKWebView引入的上面也介绍过了，它就是基于scriptMessageHandler注入，不通过任何拦截的办法，而是直接将一个Native对象或者函数注入到JS里面，可以由web的js代码直接调用。</p>
<p>注入方式如下：</p>
<figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">[<span class="literal">self</span>.webView.configuration.<span class="keyword">user</span>ContentController addScriptMessageHandler:<span class="literal">self</span> name:@<span class="string">&quot;nativeObj&quot;</span>];</span><br></pre></td></tr></table></figure>

<p>这里有个十分关键的地方：如果当前WKWebView没用了需要销毁，需要先移除这个对象注入，否则会造成内存泄漏，WebView和所在VC循环引用，无法销毁。可以通过如下方式进行移除：</p>
<figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">[<span class="literal">self</span>.webView.configuration.<span class="keyword">user</span>ContentController removeScriptMessageHandlerForName:@<span class="string">&quot;nativeObj&quot;</span>];</span><br></pre></td></tr></table></figure>

<p>相较而言个人还是比较推荐通过scriptMessageHandler方式注入，但是它不如拦截通用，意味着Androd需要另外一套，不过个人还是比较固执得推荐通过scriptMessageHandler来注入，嗯，是的就是固执。</p>
<ul>
<li>如何通过JSBridge进行实现Web与Native的相互调用：</li>
</ul>
<p>在iOS平台上个人比较偏好采用scriptMessageHandler方式实现js调用native。通过evaluatingJavaScript实现native调用js。<br>下面是两者的基本使用方式：</p>
<p>通过 scriptMessageHandler 注入对象：</p>
<p>方法1:</p>
<figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">[<span class="literal">self</span>.webView.configuration.<span class="keyword">user</span>ContentController addScriptMessageHandler:<span class="literal">self</span> name:@<span class="string">&quot;nativeObject&quot;</span>];</span><br></pre></td></tr></table></figure>

<p>方法2:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">WKUserContentController</span> <span class="operator">*</span>userContent <span class="operator">=</span> [[<span class="type">WKUserContentController</span> alloc] <span class="keyword">init</span>];</span><br><span class="line">[userContent addScriptMessageHandler:id<span class="operator">&lt;</span><span class="type">WKScriptMessageHandler</span><span class="operator">&gt;</span> name:@<span class="string">&quot;nativeObject&quot;</span>];</span><br><span class="line">    </span><br><span class="line"><span class="type">WKWebViewConfiguration</span> <span class="operator">*</span>config <span class="operator">=</span> [[<span class="type">WKWebViewConfiguration</span> alloc] <span class="keyword">init</span>];</span><br><span class="line">config.userContentController <span class="operator">=</span> userContent;</span><br><span class="line">    </span><br><span class="line"><span class="type">WKWebView</span> <span class="operator">*</span>webView <span class="operator">=</span> [[<span class="type">WKWebView</span> alloc] initWithFrame:<span class="type">CGRectZero</span> configuration:config];</span><br></pre></td></tr></table></figure>
<p>其实两者是一样的看你个人喜欢，还要时刻牢记在不用的时候及时销毁。</p>
<p>实现WKScriptMessageHandler代理：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">-(void)userContentController:(WKUserContentController *)userContentController </span><br><span class="line">     didReceiveScriptMessage:(WKScriptMessage *)message</span><br><span class="line">&#123;</span><br><span class="line">    NSDictionary *msgBody = message.body;</span><br><span class="line">    <span class="regexp">//</span><span class="number">1</span> 取出协议前缀，通过协议前缀进行校验</span><br><span class="line">    <span class="regexp">//</span><span class="number">2</span> 取出指令类别</span><br><span class="line">    <span class="regexp">//</span><span class="number">3</span> 取出具体指令</span><br><span class="line">    <span class="regexp">//</span><span class="number">4</span> 取出协议版本</span><br><span class="line">    <span class="regexp">//</span><span class="number">5</span> 取出指令参数</span><br><span class="line">    <span class="regexp">//</span><span class="number">6</span> 取出回调</span><br><span class="line">    <span class="regexp">//</span><span class="number">6</span> 根据上述内容调用对应的本地方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JS端调用：</p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line"><span class="built_in">var</span> <span class="built_in">data</span> = &#123;</span><br><span class="line">    module:<span class="string">&#x27;xxxx&#x27;</span>,</span><br><span class="line">    <span class="keyword">type</span>:<span class="string">&#x27;xxxx&#x27;</span>,</span><br><span class="line">    action:<span class="string">&#x27;xxxx&#x27;</span>,</span><br><span class="line">    version:<span class="string">&#x27;xxxx&#x27;</span>,</span><br><span class="line">    <span class="keyword">params</span>:<span class="string">&#x27;xxxx&#x27;</span>,</span><br><span class="line">    callback:<span class="string">&#x27;xxxx&#x27;</span>,</span><br><span class="line">    <span class="comment">//其他通用参数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//传递给客户端</span></span><br><span class="line">window.webkit.messageHandlers.nativeObject.postMessage(<span class="built_in">data</span>);</span><br></pre></td></tr></table></figure>


<p>Native 调用 JS</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSString</span>* javascriptCommand = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;calljs(&#x27;%@&#x27;);&quot;</span>, paramsString];</span><br><span class="line"><span class="keyword">if</span> ([[<span class="built_in">NSThread</span> currentThread] isMainThread]) &#123;</span><br><span class="line">    [<span class="keyword">self</span>.webView evaluateJavaScript:javascriptCommand completionHandler:<span class="literal">nil</span>];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    __<span class="keyword">strong</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>)strongSelf = <span class="keyword">self</span>;</span><br><span class="line">    <span class="built_in">dispatch_sync</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        [strongSelf.webView evaluateJavaScript:javascriptCommand completionHandler:<span class="literal">nil</span>];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里需要注意的是在调用的时候需要对各个请求鉴权，哪些请求需要登录态，哪些请求不能访问某些本地资源，对某些敏感的页面请求甚至需要设置黑白名单。</p>
<p>在加载DOM的时候调用JS:</p>
<p>上面介绍的evaluatingJavaScript是在客户端执行这条代码的时候立刻去执行当条JS代码，而还可以通过WKUserScript预先准备好JS代码，当WKWebView加载Dom的时候，执行当条JS代码下面是一个简单例子：</p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">WKUserScript *script = <span class="comment">[<span class="comment">[WKUserScript alloc]</span>initWithSource:source</span></span><br><span class="line"><span class="comment">                                             injectionTime:time</span></span><br><span class="line"><span class="comment">                                             forMainFrameOnly:mainOnly]</span>;</span><br><span class="line">WKUserContentController *userController = webView.userContentController;</span><br><span class="line"><span class="comment">[userController addUserScript:script]</span></span><br></pre></td></tr></table></figure>


<p>JSBridge 应该包括那些内容：</p>
<p><strong><strong>1.方法的注入:</strong></strong></p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="bullet">* </span>H5注入方法给Native调用</span><br><span class="line"><span class="bullet">* </span>Native注入方法给H5调用</span><br></pre></td></tr></table></figure>

<p><strong><strong>2.H5 与 Native 的相互调用</strong></strong></p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="bullet">* </span>H5主动调用Native</span><br><span class="line"><span class="bullet">* </span>H5主动调用Native后回调</span><br><span class="line"></span><br><span class="line"><span class="bullet">* </span>Native主动调用H5</span><br><span class="line"><span class="bullet">* </span>Native主动调用H5后回调</span><br></pre></td></tr></table></figure>

<p><strong><strong>3.获取当前版本JS桥所支持的的方法列表</strong></strong></p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="bullet">* </span>H5 获取本地可以支持的方法列表</span><br><span class="line"><span class="bullet">* </span>Native 获取H5所支持的方法列表</span><br></pre></td></tr></table></figure>

<p><strong><strong>4.协议设计（包含鉴权)</strong></strong></p>
<p><strong><strong>5.异常处理</strong></strong></p>
<p>下面不会对全部进行介绍只会针对关键环节进行简要说明：</p>
<ul>
<li><strong><strong>启动阶段</strong></strong></li>
</ul>
<p>JS 桥在启动的时候H5会通过JS桥初始化参数来主动向Native获取一些公共参数，比如当前平台名，设备信息，当前应用版本，用户信息，国家区域信息等。然后Native 和 H5通过上面介绍的方法各自往JSBridge 注入各自的方法。</p>
<ul>
<li><strong><strong>协议设计</strong></strong></li>
</ul>
<p>协议主要用于告诉表调用方，我是要使用哪些参数调用哪个模块的哪个方法。下面是我自己实现的一个Hybird的协议，分得比较细，主要是为了将协议归类.待引入组件化后可以根据所属组件分发，整个逻辑会显得更加清晰。</p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="symbol">module:</span>             模块名</span><br><span class="line"><span class="symbol">type:</span>               协议类型，是路由协议还是指令调用协议</span><br><span class="line"><span class="symbol">action:</span>             指令或者路由名</span><br><span class="line"><span class="symbol">version:</span>            JS桥版本</span><br><span class="line"><span class="symbol">params:</span>             协议参数</span><br><span class="line">from：              来源</span><br><span class="line"><span class="symbol">callbackId:</span>         回调id 唯一</span><br><span class="line"><span class="symbol">callbackFunction:</span>   回调处理函数</span><br><span class="line"><span class="comment">//其他通用参数</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>H5 与 Native 的相互调用</li>
</ol>
<ul>
<li>H5主动调用Native</li>
</ul>
<p>H5端调用：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">window.webkit.messageHandlers.<span class="module-access"><span class="module"><span class="identifier">IDLJSBridge</span>.</span></span>post<span class="constructor">Message(<span class="params">data</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>Native端：</p>
<p>实现WKScriptMessageHandler代理，对消息进行处理，为了避免WKScriptMessageHandler过大还可以划分多个WKUserContentController进行处理。或者将处理方法划分到不同对分类中。</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">-(void)userContentController:(WKUserContentController *)userContentController </span><br><span class="line">     didReceiveScriptMessage:(WKScriptMessage *)message</span><br><span class="line">&#123;</span><br><span class="line">    NSDictionary *msgBody = message.body;</span><br><span class="line">    <span class="regexp">//</span><span class="number">1</span> 取出协议前缀，通过协议前缀进行校验</span><br><span class="line">    <span class="regexp">//</span><span class="number">2</span> 取出指令类别</span><br><span class="line">    <span class="regexp">//</span><span class="number">3</span> 取出具体指令</span><br><span class="line">    <span class="regexp">//</span><span class="number">4</span> 取出协议版本</span><br><span class="line">    <span class="regexp">//</span><span class="number">5</span> 取出指令参数</span><br><span class="line">    <span class="regexp">//</span><span class="number">6</span> 取出回调</span><br><span class="line">    <span class="regexp">//</span><span class="number">6</span> 根据上述内容调用对应的本地方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>H5主动调用Native后回调</li>
</ul>
<p>对于有回调的方式和无回调的方式的区别在于在向客户端传递消息的时候不但需要传递必须的数据，还需要传递callbackID以及callbackFunction。callbackId需要保证每次通信都唯一。可以通过“时间戳+随机数”,callbackFunction是回调的统一处理函数。<br>在JSBridge中存在一个map msgCallbackMap用于存放回调的信息，key为callbackId 值为待调用的callback函数。</p>
<p>在发起调用的时候如果需要回调则在下面结构的callbackId填写生成的id以及callbackFunction。</p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="symbol">module:</span>             模块名</span><br><span class="line"><span class="symbol">type:</span>               协议类型，是路由协议还是指令调用协议</span><br><span class="line"><span class="symbol">action:</span>             指令或者路由名</span><br><span class="line"><span class="symbol">version:</span>            JS桥版本</span><br><span class="line"><span class="symbol">params:</span>             协议参数</span><br><span class="line">from：              来源</span><br><span class="line"><span class="symbol">callbackId:</span>         回调id 唯一</span><br><span class="line"><span class="symbol">callbackFunction:</span>   回调处理函数</span><br><span class="line"><span class="comment">//其他通用参数</span></span><br></pre></td></tr></table></figure>

<p>一旦H5发起请求后请求到达Native的userContentController 代理方法中，Native根据协议调用对应的本地方法处理请求后查看callbackId如果有值，就拼接请求：callbackFunction(callbackId,result) 通过evaluateJavaScript来执行。这时候流程回到H5,H5再使用callbackId 从 msgCallbackMap中取出对应的handler，调用handler(result)进行处理。</p>
<ul>
<li>Native主动调用H5</li>
</ul>
<p>这里包括两个部分：</p>
<ol>
<li>JSBridge注册供调用的方法：</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">registerHandlerForNative</span>: <span class="keyword">function</span> (<span class="params">handlerName, handler</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> handlerArr = <span class="variable language_">this</span>.<span class="property">handlerForNativeMap</span>[handlerName];</span><br><span class="line">    <span class="keyword">if</span> (handlerArr === <span class="literal">undefined</span>) &#123;</span><br><span class="line">        handlerArr = [];</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">handlerForNativeMap</span>[handlerName] = handlerArr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (handler !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">        handlerArr.<span class="title function_">push</span>(handler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>这时候就可以通过注册对应的handler进行处理了。比如：</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><span class="line">window.registerHandlerForNative(<span class="string">&#x27;callByNative&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">   <span class="built_in">console</span>.<span class="built_in">log</span>(<span class="string">&#x27;call by native&#x27;</span>)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>native调用中转：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">nativeCallDispatcher</span>: <span class="keyword">function</span> (<span class="params">handlerName, resultjson</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> handlerArr = <span class="variable language_">this</span>.<span class="property">handlerForNativeMap</span>[handlerName];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> handlerArr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (handlerArr.<span class="title function_">hasOwnProperty</span>(key)) &#123;</span><br><span class="line">            <span class="keyword">var</span> handler = handlerArr[key];</span><br><span class="line">            <span class="keyword">if</span> (handler &amp;&amp; <span class="keyword">typeof</span> (handler) === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">var</span> resultObj = resultjson ? <span class="title class_">JSON</span>.<span class="title function_">parse</span>(resultjson) : &#123;&#125;;</span><br><span class="line">                <span class="title function_">handler</span>(resultObj);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>这样本地就可以通过构建window.nativeCallDispatcher(handlerName,resultjson)字符串，然后通过evaluateJavaScript进行调用了。</p>
<ul>
<li>Native主动调用H5后回调</li>
</ul>
<p>这个其实比H5回调Native后回调要简单得多evaluateJavaScript原生支持：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[self.webView evaluateJavaScript:javascriptCommand completionHandler:handler]</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>上面的handler就是在执行完毕后返回被调用的。所以我们只需要在处理函数中return一个结果就可以了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">nativeCallDispatcher</span>: <span class="keyword">function</span> (<span class="params">handlerName, resultjson</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> handlerArr = <span class="variable language_">this</span>.<span class="property">handlerForNativeMap</span>[handlerName];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> handlerArr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (handlerArr.<span class="title function_">hasOwnProperty</span>(key)) &#123;</span><br><span class="line">            <span class="keyword">var</span> handler = handlerArr[key];</span><br><span class="line">            <span class="keyword">if</span> (handler &amp;&amp; <span class="keyword">typeof</span> (handler) === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">var</span> resultObj = resultjson ? <span class="title class_">JSON</span>.<span class="title function_">parse</span>(resultjson) : &#123;&#125;;</span><br><span class="line">                <span class="keyword">var</span> responseObj = <span class="title function_">handler</span>(resultObj);</span><br><span class="line">                <span class="keyword">return</span> responseObj;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p><strong><strong>Router &amp;&amp; Actions 设计</strong></strong><br>这些都需要在本地封装成一个简洁的模块后直接调用,具体开放的接口一般会依照业务而定，不建议一上来就开放很多接口。这里还需要注意的是在调用这些方法之前需要事先鉴权，或者登录态校验，以及针对敏感性资源建立黑白名单等。</p>
<p>换句话说Hybird开放接口需要一套权限分级的逻辑控制相关的接口调用，最常规的做法就是对开放接口建立分级的管理，不同权限的H5页面只能调用各自权限内的接口。同时支持动态拉取权限白名单从而可以灵活得配置H5页面的权限。</p>
<p>下面摘自：<a target="_blank" rel="noopener" href="http://www.cocoachina.com/articles/26617">一文掌握iOS开发中的全部web知识</a></p>
<p><img src="/2019/09/08/iOS-%E5%8A%A8%E6%80%81%E5%8C%96%E6%96%B9%E6%A1%88%E6%80%BB%E7%BB%93/0014.png"></p>
<p><strong><strong>Hybird高阶话题 优化部分</strong></strong></p>
<p>在很多年前刚接触Hybird的时候，我记得问过一个问题，Hybird为啥要将H5页面打包到应用中，不会增大整个包体积吗？因为在当时的印象中Hybird就是一个WebView加载一个Web页面，再由JSBridge提供Web与Native交互的接口。在加载完某个页面后再将当前页面缓存下来供下次调用不就行了，后续接触多了之后发现但是有这个错误的理解是因为当时接触使用Hybird做的业务都是很简单的业务。大部分的业务还都是放在Native 端做，只不过在某些活动页或者说明页的情景下会采用Hybird,但是对于像淘宝，京东那样内容需要快速更新的场景，有可能就需要某个业务的全部页面都要使用Hybird实现。这种情况下就对我们的Hybird框架有很高的要求了。这就涉及到如何优化这部分设计了。</p>
<p><strong><strong>1.离线包机制</strong></strong></p>
<p>对于某个功能一般在应用打包的时候会内置一份全量离线包，以及本地配置文件。在首次打开的时候会先查看本地配置文件是否归属于当前应用版本，以及配置文件的md5值是否和保存在应用中的配置文件md5值相等，如果不相等则拿应用的版本信息从服务端请求一份最新的离线包配置文件保存到本地，如果相等则校验全量包的md5值是否等于本地配置文件中的md5值。如果不相等则删除本地全量包从后台再下载一份。如果相等说明离线包配置和全量包匹配，这时候就可以对全量包进行解压。</p>
<p>在后续访问H5页面的时候，先进行拦截，如果离线包中有对应的内容那么就直接访问本地资源，否则访问线上资源。</p>
<p>接下来就需要考虑一个问题：应用如何感知到某个离线包升级了。这里有两种方式，一种是通过长链接下发，主动通知应用，这种情况可以在每次发布新的离线包的时候，下发配置文件的md5值，客户端在收到这个md5值后和本地配置文件的md5值进行对比，如果不相同则请求最新的配置文件保存到本地。一种是采用轮询的方式比如每10分钟轮询一次，两种都可行，但是个人比较推荐第一种。为了避免App长时间停留在后台而导致无法及时收到更新的通知，我们还需要在App后台进入前台的时候，主动请求一次。</p>
<p>对于单个离线包本地配置文件可以如下设置：</p>
<figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;latestVersion&quot;</span>: <span class="string">&quot;最新版本号&quot;</span>,</span><br><span class="line">    <span class="string">&quot;md5&quot;</span>: <span class="string">&quot;zip包 MD5值&quot;</span>,</span><br><span class="line">    <span class="string">&quot;url&quot;</span>: <span class="string">&quot;zip包下载地址&quot;</span>,</span><br><span class="line">    <span class="string">&quot;packages&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;version&quot;</span>: <span class="string">&quot;某主包版本号&quot;</span>,</span><br><span class="line">            <span class="string">&quot;url&quot;</span>: <span class="string">&quot;差分包下载地址&quot;</span>,</span><br><span class="line">            <span class="string">&quot;md5&quot;</span>: <span class="string">&quot;差分包md5值&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">             <span class="string">&quot;version&quot;</span>: <span class="string">&quot;某主包版本号&quot;</span>,</span><br><span class="line">            <span class="string">&quot;url&quot;</span>: <span class="string">&quot;差分包下载地址&quot;</span>,</span><br><span class="line">            <span class="string">&quot;md5&quot;</span>: <span class="string">&quot;差分包md5值&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每次拿到最新的配置文件后就拿本地的离线包版本号与最新的版本进行比较，如果等于最新版本号那么就什么都不干直接返回，如果不等于最新版本号，就拿着当前的版本号，去packages数组中去找，找到version等于当前本地离线包版本的那个配置，拿到补丁包<br>的下载地址，下载完毕后通过md5校验通过后将其合并到本地包，修改本地包的版本信息。如果在packages中没有找到那么就通过latestVersion对应的URL地址去下载全量包，再解压。</p>
<p><strong><strong>2.差分包制作</strong></strong></p>
<p>客户端在内置了全量包的基础上，为了减少每次下载更新的资源包的体积，一般都采用增量更新策略：每次发布版本的时候，如果此业务线之前已有离线包，则通过离线系统生成差分包发布。增量更新的策略使用的是基于node的 bsdiff&#x2F;bspatch 二进制差量算法工具npm包bsdp。客户端下载差分包后使用bspatch合成更新包。</p>
<p><strong><strong>3.容错机制</strong></strong></p>
<p>由于网络因素，有可能导致包下载过程由于某些原因导致包下载失败，所以我们在设计过程中需要尽量增加整个系统的容错机制。即使使用非最新的包也不能导致页面异常的现象。所以在整个过程中需要注意如下几点：</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="bullet">* </span>在没有下载完成并通过md5校验之前不要删除本地离线包。</span><br><span class="line"><span class="bullet">* </span>在弱网状态下先使用本地离线包，待切换到Wifi或者网络信号强的情况下开始下载。</span><br><span class="line"><span class="bullet">* </span>为了减少网络因素导致的失败，需要增加重试策略.</span><br></pre></td></tr></table></figure>
<p>针对各个业务最后的兜底选择就是每次都使用线上资源。所以如果发现：</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="bullet">* </span>内置的主包解压失败</span><br><span class="line"><span class="bullet">* </span>离线系统接口超时</span><br><span class="line"><span class="bullet">* </span>离线资源下载失败</span><br><span class="line"><span class="bullet">* </span>增量的离线资源合并失败</span><br></pre></td></tr></table></figure>
<p>这些情况先切换到线上资源，再尝试从后台下载离线包恢复。</p>
<p><strong><strong>一般为了避免离线资源使用带来的不可预料的风险，一般对每一个业务都需要加入使用离线资源的开关和灰度放量的控制</strong></strong></p>
<p><strong><strong>4.数据一致性校验与数据安全性</strong></strong></p>
<p>为了防止客户端下载离线资源时数据被篡改，导致下载的离线包无法解压，我们需要从服务端那边获得离线包的md5值，客户端下载后通过计算得到的资源包的md5值与之比较，可以保证数据的一致性。同时为了保证传输过程中，资源文件不被篡改，对于md5值的传输需要通过RSA加密算法进行加密。在服务端和客户端分别使用一对非对称的密钥进行加解密。</p>
<p><strong><strong>5.离线包下载优化</strong></strong></p>
<p>在介绍网络性能优化的时候介绍过如何加快网络的性能，里面的一些建议都可以借鉴，比如我们在可以在存放离线包资源的CDN中使用HTTP&#x2F;2协议，这样客户端与CDN只需要建立一次连接，就可以并行下载所有的资源。 在需要下载离线包个数较多的情况下，会比传统的HTTP1有更快的传输速度。同时，客户端只需要运行一次。减少多次触发下载对手机资源的消耗。</p>
<p>在下载离线包的过程中可以通过离线包下载的断点续传和分块下载的功能来加快整个离线包下载的总进度，在发布离线包的时候可以使用CDN就近存储。</p>
<p><strong><strong>6.打包 &amp;&amp; 发布 &amp;&amp; 离线包管理系统设计</strong></strong></p>
<p>今天写得有点累了，不多说直接贴图，其实图还是蛮直观的：</p>
<p><img src="/2019/09/08/iOS-%E5%8A%A8%E6%80%81%E5%8C%96%E6%96%B9%E6%A1%88%E6%80%BB%E7%BB%93/0013.png"></p>
<p><strong><strong>7.其他</strong></strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">数据，模板分离、预加载内容页数据机制。</span><br></pre></td></tr></table></figure>



<ul>
<li><p><strong><strong>更多资源</strong></strong></p>
</li>
<li><p><strong><strong>源码类</strong></strong></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/marcuswestin/WebViewJavascriptBridge">WebViewJavascriptBridge</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/Tencent/VasSonic">VasSonic</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/wendux/DSBridge-IOS">DSBridge-IOS</a></p>
</li>
<li><p><strong><strong>文章类</strong></strong></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/yexiaochai/p/4921635.html">浅谈Hybrid技术的设计与实现</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/yexiaochai/p/5524783.html">浅谈Hybrid技术的设计与实现第二弹</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/yexiaochai/p/5813248.html">浅谈Hybrid技术的设计与实现第三弹——落地篇</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://awhisper.github.io/2018/01/02/hybrid-jscomunication/">从零收拾一个hybrid框架（一）</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://awhisper.github.io/2018/03/06/hybrid-webcontainer/">从零收拾一个hybrid框架（二)</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/25729725">手机 QQ Hybrid 的架构演进</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://juejin.im/post/5d7705095188250b055dc825">HTML5 容器入门解析：支付宝 Hybrid 方案原理与实战</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://juejin.im/entry/5a542c61f265da3e243b6084">转转hybrid app web静态资源离线系统实践</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/XZBzR3Bj89wQhNH1iqMwHg">QQ空间前端工程师如何做首屏优化</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://awps-assets.meituan.net/mit-x/slide-bundle-2018-2/42/EH%20%E2%80%94%20%E7%94%A8%E9%BB%91%E7%A7%91%E6%8A%80%E6%89%93%E9%80%A0%E5%85%A8%E6%96%B0%E7%9A%84%20Hybrid%20%E4%BD%93%E9%AA%8C.pdf">用黑科技打造全新的Hybrid体验</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://js8.in/2017/04/19/Hybrid%20APP%E5%BC%80%E5%8F%91%EF%BC%9A%E6%A8%A1%E6%9D%BF%E5%8C%85%E7%AE%A1%E7%90%86%E5%B9%B3%E5%8F%B0/">Hybrid APP开发：模板包管理平台</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://js8.in/2017/04/06/Hybrid%20APP%E5%BC%80%E5%8F%91%EF%BC%9A%E6%A8%A1%E6%9D%BF%E6%9C%AC%E5%9C%B0%E5%8C%96/">Hybrid APP开发：模板本地化</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://juejin.im/entry/5a9765e46fb9a0633611883c">携程无线离线包增量更新方案实践</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/214c0b0087d4">Hybrid App 增量&#x2F;全量更新解决方案</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.open-open.com/news/view/1cee25c">阿里巴巴技术文章分享：极致的 Hybrid：航旅离线包再加速</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://www.cocoachina.com/articles/26617">一文掌握iOS开发中的全部web知识</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/34125968">携程无线离线包增量更新方案实践</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/3c58760079d9">iOS 使用bsdiff进行资源文件增量更新</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/karynsong/weex-demo">karynsong&#x2F;weex-demo</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/bmfe/eros-docs">bmfe&#x2F;eros-docs</a></p>
</li>
</ul>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/iOS-%E8%BF%9B%E9%98%B6/">iOS 进阶</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/iOS-进阶/">iOS 进阶</a>
  </div>

</div>



<div class="comments-count">
	
	  	<span></span>
		<a href="/2019/09/08/iOS-动态化方案总结/#comments" class="ds-thread-count comments-count-link" data-thread-key="2019/09/08/iOS-动态化方案总结/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/09/02/iOS-性能优化总结/" title="iOS 性能优化总结" itemprop="url">iOS 性能优化总结</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Edgar" target="_blank" itemprop="author">Edgar</a>
		
  <p class="article-time">
    <time datetime="2019-09-01T18:16:43.000Z" itemprop="datePublished"> Published 2019-09-02</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h5 id="1-开篇叨叨"><a href="#1-开篇叨叨" class="headerlink" title="1.开篇叨叨"></a><strong><strong>1.开篇叨叨</strong></strong></h5><p>这是这个系列的倒数第二篇博客，如果看过我之前总结的Android性能优化的博客，大家可以发现很多适用于Android的性能优化在iOS上也适用，举个例子来说我们需要请求某个接口，如果不成功的需要间隔一段时间进行重试，这部分就可以做个优化，可以将发起重试请求的间隔时间以线性增长的方式递增。到达一定阈值后认定该请求失败。这种优化是属于从需求层面上的性能优化，对于这种性能优化往往是平台无关的可以通用。另一种则是平台相关的，比如渲染方面的优化，但是不管是哪种两个平台的优化思想都可以相互借鉴。性能优化作为初级中级到高级开发的一道门槛，它要求我们不但要吃透需求，还需要对平台底层原理有较为深刻的理解。</p>
<p>在进行性能优化之前要遵循两大原则：</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="bullet">* </span>不要过早优化，也不能过度优化</span><br></pre></td></tr></table></figure>
<p>我个人的理解项目的每个阶段都有它的关键任务，项目初期我们应该关注的是项目框架的搭建，技术的选型，整体方案的确定，代码规范的约定，到了项目中期我们往往是以产品需求为导向，关注的是需求按时保质保量地上线，以及产品数据的收集。性能，质量监控系统的搭建以及数据的收集，那么什么时候才是优化的最好时间点呢？个人认为要在性能采集系统搭建完成并且收集到较为充分数据这之后才介入性能优化工作，并且由于性能优化很难在产品营收层面有所贡献，所以很多以产品为导向的项目中，很难给我们充裕的时间专门进行优化，因此性能优化不应该一步到位，如果我们的项目是按月规划的，在一个月或者一个季度可以抽出一定的时间对这个阶段的需求进行代码层面以及性能层面的优化，个人以为这种是一种比较合理的方式。至于过度优化，指的是在没有实际数据指标的基础上，做一些盲目的优化工作，或者为了优化性能而过度增加系统复杂度和维护成本。虽然可能性能上带来了一定的提升，但是这么做显然是得不偿失的。</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="bullet">* </span>所有的优化都要有数据的支撑，平台底层原理的指导</span><br></pre></td></tr></table></figure>

<p>性能优化其实包含两大部分：一部分是性能检测，另一部分才是性能优化，第一部分往往是人们最容易忽视的，性能优化之所以不能引起产品的兴趣是因为很多的优化是看不见的效果，我们很难说服产品，我们某项优化的必要性，这归根到底是由于我们没有数据的支撑，而性能数据不但有衡量我们优化效果的作用，还能在优化过程中起到指引作用，所以一般大厂都会有自己的一套性能检测系统，也就是常听说的APM。他们对于关键的页面以及关键环节都会进行性能监控。有了数据的情况下，我们不能单纯靠尝试或者经验来优化，还应该从平台底层原理出发，找到问题的关键所在，然后才进行有针对性地优化。</p>
<p>总而言之对于性能优化我们有两大任务一个是性能的检测，性能数据的收集。有了这些数据的支撑后我们再从业务逻辑，以及系统平台两大方面入手分析解决，也就是我们这个博客所涉及的重点 – <strong><strong>性能优化</strong></strong>。<br>简而言之 – “两大任务，两个方面”</p>
<h5 id="2-性能监控与数据收集"><a href="#2-性能监控与数据收集" class="headerlink" title="2.性能监控与数据收集"></a><strong><strong>2.性能监控与数据收集</strong></strong></h5><p>在进行性能监控与数据收集之前需要先明确性能优化的目标有哪些？最常用的几个性能优化点有如下几点，后续也会对这些部分进行展来来介绍：</p>
<ul>
<li><p><strong><strong>内存优化：</strong></strong><br>对于内存优化，衡量的最重要指标就是是否有内存泄漏，是否有在短时间创建和释放大量对象造成内存波动。以及在哪个关键点会消耗较大的内存，最好能够提供一个较为实时的查看内存耗用的途径。</p>
</li>
<li><p><strong><strong>卡顿优化：</strong></strong><br>卡顿是用户最为直观的性能问题，因此一般优先级会设得比较高，衡量卡顿的最总要指标就是FPS(帧率)，如果帧率小于60fps就说明存在卡顿掉帧问题。如果条件允许的话最好还要能够实时呈现CPU和GPU的使用百分比情况。</p>
</li>
<li><p><strong><strong>启动优化：</strong></strong><br>应用启动可以分成两个阶段，两个阶段的分界点是main函数，main之前为动态库以及可执行文件的加载过程，main之后包括runtime环境初始化，load，直到Appdelegate didFinishLaunchingWithOptions为止，这个也是用户十分直观的性能指标之一，衡量的最总要的指标就是两个阶段的耗时时间，一般建议控制在400ms之内。</p>
</li>
<li><p><strong><strong>包体积优化：</strong></strong><br>包体积也是一个很重要的指标，如果包太大会直接影响到用户下载安装的欲望，这部分的指标也很明确就是整个包的大小数据，最好能够精确到各个资源占用的大小。</p>
</li>
<li><p><strong><strong>网络优化：</strong></strong><br>一般现在的应用很少是离线的，所以都会涉及到网络访问，衡量这部分的指标也很明确</p>
</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1.</span> 关键接口的响应速率</span><br><span class="line"><span class="bullet">2.</span> 关键接口的成功率，失败率</span><br><span class="line"><span class="bullet">3.</span> 关键页面的加载速率</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><strong>电量优化：</strong></strong></li>
</ul>
<p>对于电量优化这个没有十分明确的衡量标准，因为电量是多个应用共同享用的，所以很难清楚得说明是否耗电增加了，因此这部分只会对关键的模块进行同等条件下专门对比测试，一般这部分只要遵循一定的规则就不会有太大的问题。如果非要有个衡量指标的话，我个人会去收集关键模块从开始进入到使用完毕退出这个阶段，单位时间的耗电情况，这里不会去设置同等情况下的对比环境，因为如果用户量大的话其实也是很能说明问题的，但是相对于前面几项数据优化点来说这个一般优先级会比较低，当然这也是仅仅相对而言比较低而已，对于直播类或者游戏类的应用，电量的消耗优化还是十分重要的。</p>
<h5 id="3-性能优化"><a href="#3-性能优化" class="headerlink" title="3.性能优化"></a><strong><strong>3.性能优化</strong></strong></h5><p>接下来我们正式开始介绍性能优化的内容，每个内容都包括：底层原理介绍，如何测试和收集性能参数，性能优化Tip三大部分。</p>
<h6 id="3-1-内存优化"><a href="#3-1-内存优化" class="headerlink" title="3.1 内存优化"></a><strong><strong>3.1 内存优化</strong></strong></h6><p>对于iOS的内存管理大家可以参看之前的iOS内存管理总结这篇博客，我们先来了解下这部分的底层原理：</p>
<p><strong><strong>底层原理</strong></strong></p>
<p>对于安装在同一个设备上的应用来说内存是有限的共享资源，如果我们的应用占用的内存过多，那么留给其他应用的内存就更少，在系统内存紧张的时候它会根据每个应用使用内存的实际情况，将内存耗用高的应用先回收 ，因此我们在编码过程中应该尽量注意整个应用的内存使用情况，并在内存不足的时候释放无用的内存空间，以降低我们的应用在系统内存空间不足的情况下被回收的可能性。</p>
<p>要强调的是我们这里谈论的减少内存空间的占用针对的是iOS的的虚拟内存空间，在iOS中采用了虚拟内存技术来突破物理内存容间的限制，系统为每个应用的进程都分配了一定大小的虚拟内存空间，这些虚拟内存空间是由一个个逻辑页构成的，处理器和内存管理单元 MMU管理着由逻辑地址空间到物理地址的映射表。之所以说是虚拟的是因为这些内存空间远大于实际的物理内存空间，在要使用某个虚拟内存空间的时候，MMU会将当前虚拟内存空间所在的page映射到物理内存页面上。当程序访问逻辑内存地址时由 MMU 根据映射表将逻辑地址转换为真实的物理地址。</p>
<p>在早期的iOS设备中，每个page的大小为4KB；基于A7和A8处理器的系统为64位程序提供了16KB的虚拟内存分页和4KB的物理内存分页，而在A9之后虚拟内存和物理内存的分页大小都达到了16KB。</p>
<p>前面提到在内存空间不足的时候应用会被系统回收，在macOS中会将一部分对内存空间占用较多，并且优先级不那么高的应用数据挪到磁盘上，这个操作称为Page Out，之后再次访问这块数据的时候会将它重新搬回内存空间，也就是所谓的Page In操作，但是考虑到太过频繁的磁盘IO操作会降低存储设备的寿命，目前iOS使用的是压缩内存的方式来释放内存空间，它会在内存资源紧张的时候对不使用的内存进行压缩处理，在下次访问的时候再对这部分内容进行解压。</p>
<p>在这种模式下iOS系统有三种类型的内存块：</p>
<ul>
<li><p><strong><strong>Clean Memory</strong></strong></p>
<p>  Clean Memory指的是可以被Page Out的内存，包括已经被加载到内存中的文件，以及应用中使用到的frameworks。</p>
</li>
<li><p><strong><strong>Dirty Memory</strong></strong></p>
<p>  Dirty Memory 指的是那些写入过数据的内存空间，包括Heap区域的对象、图像解码缓冲空间。这里需要强调的是应用所使用的frameworks 不同段类型是不同的，_DATA_CONST段最初是Clean Memory类型，但是一旦在应用使用到了某个framework的时候_DATA_CONST 的内存就会由 Clean 变为 Dirty。而_DATA 段和 _DATA_DIRTY 段，它们的内存类型固定是Dirty Memory。</p>
</li>
<li><p><strong><strong>Compressed Memory</strong></strong></p>
<p>  这就是上面提到的压缩内存，在内存资源不足的时候压缩，在下次访问的时候解压。</p>
</li>
</ul>
<p><img src="/2019/09/02/iOS-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/0001.png"></p>
<p>这部分大家可以看下这篇文章：<a target="_blank" rel="noopener" href="https://juejin.im/post/5b23dafee51d4558e03cbf4f">WWDC 2018：iOS 内存深入研究</a></p>
<p><strong><strong>XCode内存检测工具</strong></strong></p>
<ul>
<li>Memory Report 内存使用报告</li>
</ul>
<p>Memory Report 是可以实时查看整个应用当前应用内存使用情况的工具，但是它只能用于初略得定位哪些页面有可能有内存泄漏，或者哪个时间段有内存抖动问题。具体的定位还是需要Allocations工具</p>
<p><img src="/2019/09/02/iOS-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/0002.png"></p>
<ul>
<li>Analyze 静态分析工具</li>
</ul>
<p>Analyze主要用于从代码层面上进行语义分析，主要可以用于分析如下几类问题:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">逻辑错误：访问空指针或未初始化的变量等；</span><br><span class="line">内存管理错误：如内存泄漏等；</span><br><span class="line">声明错误：从未使用过的变量；</span><br><span class="line">Api调用错误：未包含使用的库和框架</span><br></pre></td></tr></table></figure>
<p>Analyze 分析出的问题并不一定是真正意义上的问题，它只是一个理论上的预测过程，具体是不是需要解决要我们自己去分析排查。</p>
<ul>
<li>Allocations 观察内存的分配情况</li>
</ul>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">X<span class="function"><span class="title">code</span> -&gt;</span> P<span class="function"><span class="title">roduct</span> -&gt;</span> P<span class="function"><span class="title">rofile</span> -&gt;</span> Allocations</span><br></pre></td></tr></table></figure>
<p><img src="/2019/09/02/iOS-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/0003.png"></p>
<p>我们一般会先看下Allocation Summary页面，比较重要的有三行：</p>
<figure class="highlight coq"><table><tr><td class="code"><pre><span class="line"><span class="keyword">All</span> <span class="keyword">Heap</span> &amp; Anonymous VM: 所有堆内存和虚拟内存</span><br><span class="line"><span class="keyword">All</span> <span class="keyword">Heap</span> Allocations: 所有堆内存，堆上malloc分配的内存，不包过虚拟内存区域</span><br><span class="line"><span class="keyword">All</span> Anonymous VM: 所有虚拟内存，就是Allocations不知道是你哪些代码创建的内存，也就是说这里的内存你无法直接控制。像memory mapped file，CALayer back store等都会出现在这里。这里的内存有些是你需要优化的，有些不是。</span><br></pre></td></tr></table></figure>

<p>每行都包含如下几个重要的列：</p>
<figure class="highlight mathematica"><table><tr><td class="code"><pre><span class="line"><span class="variable">Persistent</span> <span class="operator">:</span>未释放的对象个数</span><br><span class="line"><span class="variable">Persistent</span> <span class="built_in">Byte</span> <span class="operator">:</span>未释放的字节数</span><br><span class="line"><span class="variable">Transient</span>       <span class="operator">:</span>已释放的临时对象个数</span><br><span class="line"><span class="built_in">Total</span> <span class="built_in">Byte</span>      <span class="operator">:</span>总使用字节数</span><br><span class="line"><span class="built_in">Total</span>           <span class="operator">:</span>所有对象个数</span><br><span class="line"><span class="variable">Persistent</span><span class="operator">/</span><span class="built_in">Total</span> <span class="variable">Bytes</span> <span class="operator">:</span> 已经使用的内存对象占全部的百分比</span><br></pre></td></tr></table></figure>

<p>当我们看到如下的阶梯的时候就说明有内存泄漏问题：</p>
<p><img src="/2019/09/02/iOS-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/000000000.png"></p>
<p>下面这种就是说明没有内存泄漏，但是存在内存抖动现象。<br><img src="/2019/09/02/iOS-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/111111111.png"></p>
<p>正常的情况下应该是比较平稳的没有尖峰的曲线。</p>
<p>在我们遇到内存问题的时候首先会先看<strong><strong>Statistics</strong></strong>分类：<br><img src="/2019/09/02/iOS-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/0000.png"><br>我们一般会先查看前几项比较主要的。勾选后就会出现在上面的曲线中。<br><img src="/2019/09/02/iOS-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/010101.png"><br>点击你觉得比较有嫌疑的项的箭头处，就可以看到具体的内存分配，以及右边面板上的调用堆栈，这部分堆栈可以隐藏显示系统调用的：<br><img src="/2019/09/02/iOS-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/0.png"><br><img src="/2019/09/02/iOS-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/1.png"><br>点击进去就可以看到具体的代码，代码旁边会以百分比以及占用内存的尺寸等形式标记出来<br><img src="/2019/09/02/iOS-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/2.png"></p>
<p>还可以使用：</p>
<ul>
<li><strong><strong>Generation</strong></strong>：对内存的增量进行分析</li>
</ul>
<p><img src="/2019/09/02/iOS-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/1212.png"></p>
<ul>
<li><strong><strong>Call Tree</strong></strong>：分析代码是如何创建内存的。</li>
</ul>
<p><img src="/2019/09/02/iOS-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/1313.png"></p>
<ul>
<li><strong><strong>Allocations list</strong></strong>：观察内存的分配的列表</li>
</ul>
<p><img src="/2019/09/02/iOS-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/1414.png"></p>
<ul>
<li><strong><strong>Debug Memory Graph 图形化内存表</strong></strong></li>
</ul>
<p>Debug Memory Graph 是Xcode8中增加的调试技能，在App运行调试过程中，点击即可实时看到内存的分配情况以及引用情况，可用于发现部分循环引用问题，为了能看到内存详细信息，需要打开Edit Scheme–&gt;Diagnostics, 勾选 Malloc Scribble 和 Malloc Stack。同时在 Malloc Stack 中选择 Live Allocations Only：</p>
<p><img src="/2019/09/02/iOS-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/0004.png"></p>
<p>运行应用，点击Xcode 如下按钮：</p>
<p><img src="/2019/09/02/iOS-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/0005.png"></p>
<p>整个界面如下图所示：</p>
<p><img src="/2019/09/02/iOS-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/0006.png"></p>
<p>可以先通过左下脚的过滤按钮，筛选出只属于项目的类，以及只显示存在内存泄漏的项，有内存泄漏的项的右边会有感叹号，可以定位到右边的图然后右击跳到生成这个对象的代码。<br><img src="/2019/09/02/iOS-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/0007.png"></p>
<p>这个个人在项目中用得不是很多，主要是生成图的过程太耗时了，很经常卡得不要不要的。</p>
<ul>
<li>Leaks 内存泄漏检测工具</li>
</ul>
<p>Leaks 用起来还是蛮好用的，不过在有了后面介绍的一款工具后也慢慢少用了，至于什么工具先卖个关子，我们这里先给大家介绍下Leaks工具的使用。</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">X<span class="function"><span class="title">code</span> -&gt;</span> P<span class="function"><span class="title">roduct</span> -&gt;</span> P<span class="function"><span class="title">rofile</span> -&gt;</span> Leaks</span><br></pre></td></tr></table></figure>
<p><img src="/2019/09/02/iOS-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/0008.png"></p>
<p>启动 Instruments 操作应用，如果有内存泄漏情况，会打叉提示，我们可以看到到底泄漏了多少内存，以及对应的方法调用栈。可以很快速地定位到内存泄漏点的位置。<br><img src="/2019/09/02/iOS-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/0009.png"><br><img src="/2019/09/02/iOS-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/0010.png"><br><img src="/2019/09/02/iOS-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/0011.png"><br><img src="/2019/09/02/iOS-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/0012.png"></p>
<p>上面介绍的工具虽然是官方推出的工具，但是实际上并不是十分好用，需要我们一个个场景去重复的操作，还有检测不及时，并且Instuments工具永久了不是一般的卡，在开发过程中上面几种工具用得比较多的就是Memory Report，Analyze 以及 Leaks，更多的是结合一些开源库来实时检测内存泄漏，这里推荐的是微信推出的MLeaksFinder，它能较为实时地检测内存泄漏问题，一旦有内存泄漏立刻弹窗提示，这种方式从很大角度上加快了我们发现问题解决问题的速度。</p>
<p><strong><strong>MLeaksFinder</strong></strong> <a target="_blank" rel="noopener" href="https://github.com/Tencent/MLeaksFinder">GitHub地址</a></p>
<p>MLeaksFinder 可以算得上是一个很好的检查内存泄漏的辅助工具，它有如下特点：</p>
<blockquote>
<p>使用简单，不侵入业务逻辑代码，不用打开 Instrument<br>不需要额外的操作，你只需开发你的业务逻辑，在你运行调试时就能帮你检测<br>内存泄露发现及时，更改完代码后一运行即能发现（这点很重要，你马上就能意识到哪里写错了）<br>精准，能准确地告诉你哪个对象没被释放<br>MLeaksFinder 目前能自动检测 UIViewController 和 UIView 对象的内存泄露，而且也可以扩展以检测其它类型的对象</p>
</blockquote>
<p>具体的实现细节可以看官方的博客，由于篇幅原因，这里只提炼一些重要的内容做介绍，后面会针对MLeaksFinder写一篇源码解析的文章来介绍它的实现:</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://wereadteam.github.io/2016/02/22/MLeaksFinder/">MLeaksFinder：精准 iOS 内存泄露检测工具</a></li>
<li><a target="_blank" rel="noopener" href="http://wereadteam.github.io/2016/07/20/MLeaksFinder2/">MLeaksFinder 新特性</a></li>
</ul>
<p>MLeaksFinder 通过AOP技术 hook UIViewController 和 UINavigationController 的 pop 跟 dismiss 方法，这种做法的优点就是不会侵入项目工程。MLeaksFinder会在UIViewController被pop或dismiss一小段时间后，检测该 UIViewController的view，以及view 的 subviews 等等是否还存在，具体的方法是，为基类 NSObject 添加一个方法 -willDealloc 方法，该方法的作用是，先用一个弱指针指向 self，并在一小段时间(2秒)后，通过这个弱指针调用 -assertNotDealloc，而 -assertNotDealloc 主要作用是直接中断言。我们可以在一个 UIViewController被pop或dismiss时遍历该 UIViewController上的所有view依次调 -willDealloc 这样如果2秒后它们被释放成功，weakSelf 就指向 nil，不会调用到 -assertNotDealloc 方法，也就不会中断言，如果它没被释放，-assertNotDealloc 就会被调用中断言。通过这种方式可以找出具体是哪个地方发生了内存泄露。最新版本的MLeaksFinder 还结合了FBRetainCycleDetector通过MLeaksFinder查找可能存在内存泄漏的对象，然后通过FBRetainCycleDetector来查看是否存在循环引用。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">BOOL</span>)willDealloc &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前的类是否再白名单中，如果是的话就不会进行检测是否泄漏</span></span><br><span class="line">    <span class="built_in">NSString</span> *className = <span class="built_in">NSStringFromClass</span>([<span class="keyword">self</span> <span class="keyword">class</span>]);</span><br><span class="line">    <span class="keyword">if</span> ([[<span class="built_in">NSObject</span> classNamesWhitelist] containsObject:className])</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSNumber</span> *senderPtr = objc_getAssociatedObject([<span class="built_in">UIApplication</span> sharedApplication], kLatestSenderKey);</span><br><span class="line">    <span class="keyword">if</span> ([senderPtr isEqualToNumber:@((uintptr_t)<span class="keyword">self</span>)])</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//延迟2秒尝试调用assertNotDealloc</span></span><br><span class="line">    __<span class="keyword">weak</span> <span class="type">id</span> weakSelf = <span class="keyword">self</span>;</span><br><span class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">2</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        __<span class="keyword">strong</span> <span class="type">id</span> strongSelf = weakSelf;</span><br><span class="line">        [strongSelf assertNotDealloc];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)assertNotDealloc &#123;</span><br><span class="line">    <span class="keyword">if</span> ([MLeakedObjectProxy isAnyObjectLeakedAtPtrs:[<span class="keyword">self</span> parentPtrs]]) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    [MLeakedObjectProxy addLeakedObject:<span class="keyword">self</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSString</span> *className = <span class="built_in">NSStringFromClass</span>([<span class="keyword">self</span> <span class="keyword">class</span>]);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;Possibly Memory Leak.\nIn case that %@ should not be dealloced, override -willDealloc in %@ by returning NO.\nView-ViewController stack: %@&quot;</span>, className, className, [<span class="keyword">self</span> viewStack]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是这里的遍历需要遍历基于UIViewController的整棵View-ViewController树，对于某些 ViewController，如 UINavigationController，UISplitViewController 等，还需要遍历 viewControllers 属性。</p>
<p>MLeaksFinder在发现可能的内存泄漏对象并给出 alert 之后，还会进一步地追踪该对象的生命周期，并在该对象释放时给出 Object Deallocated 的 alert，所以有时候你会发现弹出一个内存泄漏的弹窗后，你以为内存泄漏了检查了好久发现没有，重复尝试后你会发现在这个弹窗之后还会出现Object Deallocated弹窗，这种其实是某个对象延迟释放了，并不是发生了内存泄漏。</p>
<p>所以在使用MLeaksFinder的时候一般会有如下几种情况：</p>
<ul>
<li><p>在第一次pop的时候弹出Leak弹窗，在之后的重复push并pop同一个ViewController过程中，即不报 Object Deallocated，也不报 Memory Leak。这种情况下我们可以确定该对象被设计成单例或者缓存起来了。</p>
</li>
<li><p>在第一次pop的时候弹出Leak弹窗，在之后的重复push并pop同一个ViewController过程中，对于同一个类不断地报 Object Deallocated 和 Memory Leak。这种情况属于释放不及时的情况，不算内存泄漏。</p>
</li>
<li><p>在第一次pop的时候弹出Leak弹窗，在之后的重复push并pop同一个ViewController过程中，不报Object Deallocated，但每次 pop 之后又报 Memory Leak，这种才算是真正的内存泄漏。</p>
</li>
</ul>
<p><strong><strong>其他关于内存检测较好的开源库：</strong></strong></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/facebook/FBAllocationTracker">FBAllocationTracker</a> FaceBook推出的用于检测对象分配的开源库</li>
<li><a target="_blank" rel="noopener" href="https://github.com/facebook/FBRetainCycleDetector">FBRetainCycleDetector</a> FaceBook推出的用于检测循环引用的开源库</li>
<li><a target="_blank" rel="noopener" href="https://github.com/facebook/FBMemoryProfiler">FBMemoryProfiler</a> 结合FBAllocationTracker，FBRetainCycleDetector来提供内存问题检测的工具，支持插件开发。</li>
<li><a target="_blank" rel="noopener" href="https://github.com/Tencent/OOMDetector">OOMDetector</a> 腾讯开源的OOM检测器</li>
</ul>
<p><strong><strong>比较常见的内存问题简要总结</strong></strong></p>
<p>该部分见《iOS 内存管理总结》博客一文</p>
<h6 id="3-2-卡顿优化"><a href="#3-2-卡顿优化" class="headerlink" title="3.2 卡顿优化"></a><strong><strong>3.2 卡顿优化</strong></strong></h6><p>在之间的博客中已经介绍过了iOS的布局渲染机制，在介绍卡顿优化之前大家可以通过之前的博客回顾下一个界面是怎样绘制到屏幕上的。然后再针对各个环节考虑优化步骤，一般一个应用都有首页这个关键页面，它是用户最频繁访问的，也是一个应用的门面，因此首页的优化至关重要;列表是一个应用最常用的组件，并且列表是可滑动的它的卡顿往往是最明显的，所以这里也会介绍下怎么针对列表进行卡顿检测和优化。</p>
<p><strong><strong>底层原理</strong></strong></p>
<p>iOS界面的渲染主要由CPU和GPU协同下完成的，CPU一般用于逻辑部分的处理，而GPU由于高性能的并发计算能力和浮点计算能力，所以在渲染方面比CPU来得高效很多，因此我们在代码实现过程中尽量将图形显示相关的工作交给GPU，而将逻辑处理，线程调度工作交给CPU。只有CPU和GPU二者达到性能最优的平衡点才能获得最佳的界面效果，无论过度优化哪一方导致另一方压力过大都会造成整体FPS性能的下降。寻找这个均衡点十分关键，在介绍这部分优化之前我们分别看下二者在整个过程中完成了哪些工作：</p>
<p><strong><strong>CPU 部分</strong></strong></p>
<p>在整个界面显示过程中：对象创建，对象属性调整，对象销毁，Autolayout约束，布局计算，文本计算，文本渲染，图片的解码，图像的绘制，提交纹理数据。这些工作都是在CPU上进行的，所以CPU部分的优化就需要弄清楚这些环节都做了哪些工作，并且哪些是有可能导致性能瓶颈的点。</p>
<p><strong><strong>对象创建</strong></strong></p>
<ul>
<li>首先我们会创建需要添加到界面上的对象，并且设置其属性，以及在整个过程中属性的调整，这些都是在CPU中完成的。</li>
</ul>
<p>优化点 1:<br>对象的创建伴随着内存的分配，会消耗CPU资源，所以这个部分可以使用轻量对象的就不使用重的对象，比如能用CALayer的就不用UIView,但是这也有一个也有个比较坑的地方就是，某个控件初期的时候可能不涉及事件处理所以用Layer会比较轻量，但是后续可能要添加事件处理，这样改起来就比较麻烦了，因此在实际开发中除非可以确定是不涉及事件处理否则还是会用UIView。</p>
<p>优化点 2:<br>在创建对象的时候尽量推迟某个对象的创建时间，可以通过懒加载的方式在使用的时候创建对象，可以通过缓存或者对象池来避免重复频繁创建对象。</p>
<p>优化点 3：</p>
<p>对UIView属性的更改是比较耗费资源的，所以尽量减少不必要的属性修改，避免视图层次的调整以及视图的添加移除，尽量使用hide等属性来代替视图移除添加。</p>
<p><strong><strong>视图布局</strong></strong></p>
<ul>
<li>在创建完对象后会把视图对象添加到界面上，这时候会触发界面的布局，在布局方面目前用得比较多的有两大类，一种是基于frame的，一种是基于AutoLayout的，前者的缺点就是要我们自己计算好各个尺寸数据，但是性能上是最快的，而AutoLayout在使用上对于描述布局来说是十分方便，直观的，但是在性能上随着视图数量的增长，Autolayout 带来的 CPU 消耗会呈指数级上升（在iOS12上这个问题已经有所好转）因此从性能角度上看建议建议使用基于frame的布局。</li>
</ul>
<p>除了布局框架选型外，在布局方面还可以在计算布局的时候放在子线程中计算，在最后设置frame的时候回到主线程，对于某些布局参数还可以适当缓存，特别是列表的cell布局尺寸，往往是可以进行缓存的。</p>
<p><strong><strong>文本计算及渲染</strong></strong></p>
<ul>
<li>常见的文本控件比如UILabel，UITextView，它们的排版和绘制都是在主线程进行的，当需要显示大量文本的时候会给CPU带来很大的压力，所以可以使用TextKit或者CoreText自定义的文本控件来代替，对于宽高计算推荐在后台使用[NSAttributedString boundingRectWithSize:options:context:]，并且适当地缓存某些内容不变的文本尺寸数据。</li>
</ul>
<p>子线程计算文本宽高，文本绘制：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文字计算</span></span><br><span class="line">[<span class="string">@&quot;iOS&quot;</span> boundingRectWithSize:<span class="built_in">CGSizeMake</span>(<span class="number">100</span>, MAXFLOAT) options:<span class="built_in">NSStringDrawingUsesLineFragmentOrigin</span> attributes:<span class="literal">nil</span> context:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文字绘制</span></span><br><span class="line">[<span class="string">@&quot;iOS&quot;</span> drawWithRect:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">100</span>) options:<span class="built_in">NSStringDrawingUsesLineFragmentOrigin</span> attributes:<span class="literal">nil</span> context:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure>

<p><strong><strong>图片解码及绘制</strong></strong></p>
<ul>
<li>当我们创建图片的时候图片数据并不会立刻解码，只有在图片设置到 UIImageView 或者 CALayer.contents 中去，并且 CALayer 被提交到 GPU 前CGImage 中的数据才会得到解码。这是在主线程中由CPU执行的。如果想要绕开这个机制，常见的做法是在后台线程先把图片绘制到CGBitmapContext中，然后从Bitmap直接创建图片。由于 CoreGraphic 方法通常都是线程安全的，所以图像的绘制可以很容易的放到后台线程进行。</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)loadImage &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//.......</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">        <span class="built_in">CGImageRef</span> cgImage = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@&quot;avator&quot;</span>].CGImage;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">CGImageAlphaInfo</span> alphaInfo = <span class="built_in">CGImageGetAlphaInfo</span>(cgImage) &amp; kCGBitmapAlphaInfoMask;</span><br><span class="line">        <span class="type">BOOL</span> hasAlpha = <span class="literal">NO</span>;</span><br><span class="line">        <span class="keyword">if</span> (alphaInfo == kCGImageAlphaPremultipliedLast ||</span><br><span class="line">            alphaInfo == kCGImageAlphaPremultipliedFirst ||</span><br><span class="line">            alphaInfo == kCGImageAlphaLast ||</span><br><span class="line">            alphaInfo == kCGImageAlphaFirst) &#123;</span><br><span class="line">            hasAlpha = <span class="literal">YES</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">CGBitmapInfo</span> bitmapInfo = kCGBitmapByteOrder32Host;</span><br><span class="line">        bitmapInfo |= hasAlpha ? kCGImageAlphaPremultipliedFirst : kCGImageAlphaNoneSkipFirst;</span><br><span class="line"></span><br><span class="line">        size_t width = <span class="built_in">CGImageGetWidth</span>(cgImage);</span><br><span class="line">        size_t height = <span class="built_in">CGImageGetHeight</span>(cgImage);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">CGContextRef</span> context = <span class="built_in">CGBitmapContextCreate</span>(<span class="literal">NULL</span>, width, height, <span class="number">8</span>, <span class="number">0</span>, <span class="built_in">CGColorSpaceCreateDeviceRGB</span>(), bitmapInfo);</span><br><span class="line">        <span class="built_in">CGContextDrawImage</span>(context, <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, width, height), cgImage);</span><br><span class="line">        cgImage = <span class="built_in">CGBitmapContextCreateImage</span>(context);</span><br><span class="line">        <span class="built_in">UIImage</span> *newImage = [<span class="built_in">UIImage</span> imageWithCGImage:cgImage];</span><br><span class="line"></span><br><span class="line">        <span class="built_in">CGContextRelease</span>(context);</span><br><span class="line">        <span class="built_in">CGImageRelease</span>(cgImage);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            <span class="keyword">self</span>.imageView.image = newImage;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在iOS系统中如果GPU不支持某种图片格式这时候就只能通过CPU来渲染，所以我们应该尽量避免这种情况的发生，由于苹果特意为PNG格式做了渲染和压缩算法上的优化，因此尽量使用PNG格式作为图片的默认格式。</p>
<p><strong><strong>提交界面数据</strong></strong></p>
<p>在RunLoop即将进入休眠期间或者即将退出的时候，通过已经注册的通知回调执行_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv函数，在这个函数会递归将待处理的图层进行打包压缩，并通过IPC方式发送到Render Server，这里还需要提到一点：这时候的Core Animation会创建一个OpenGL ES纹理并将CPU绘制位图上传到对应的纹理中。</p>
<p><strong><strong>GPU 部分</strong></strong></p>
<p>Render Server在拿到压缩后的数据的时候，首先对这些数据进行解压，从而拿到图层树，然后根据图层树的层次结构，每个层的alpha值opeue值，RGBA值、以及图层的frame值等对被遮挡的图层进行过滤，最终得到渲染树，渲染树就是指将图层树对应每个图层的信息，比如顶点坐标、顶点颜色这些信息，抽离出来，形成的树状结构。渲染树就是下一步送往GPU进行渲染的数据。</p>
<p><strong><strong>纹理渲染</strong></strong></p>
<p>有时候我们会发现一种现象：在某些包含大量图片的列表页面快速滑动会出现GPU占用率很高但是CPU却相当空闲，规避这种问题的方式就是尽可能得将多张图片合成一张显示，这样可以节省整个纹理渲染的时间。</p>
<p><strong><strong>视图合成</strong></strong></p>
<p>一般我们每个界面都是由多个视图或者CALayer组成，多个视图会一层层得叠在一起,GPU在显示之前会先对这些视图层进行混合，如果视图结构过于复杂就会消耗很多GPU资源，为了解决这个问题就必须在我们界面实现的过程中尽量做到减少视图数量和层次结构，如果顶层的视图的opaque为YES,那么我们在合成的时候就会直接采用最上层的视图，就省去了合成过程，所以这个步骤中可以通过在实现的过程中减少视图的数量和层次，或者将多个视图先渲染为一张图片显示，尽量采用不透明的视图，并将视图opaque设置为YES，避免无用的Alpha通道合成(这里需要注意一点即使UIImageView的alpha是1，只要image含有透明通道，则仍会进行合成操作).</p>
<p><strong><strong>像素对齐</strong></strong></p>
<p>我们知道iOS设备上，有逻辑像素point和物理像素pixel之分。point和pixel的比例是通过[[UIScreen mainScreen] scale]来确定的。在没有视网膜屏之前，1 point&#x3D;1 pixel；但是2x和3x的视网膜屏出来之后，1 point等于2 pixel或3 pixel。设计提供的设计稿标注使用的像素是逻辑像素point而GPU在渲染图形之前，系统会将逻辑像素point换算成物理像素pixel。</p>
<p>如果界面上某个控件的逻辑像素point乘以2（2x的视网膜屏） 或3（3x的视网膜屏）得到整数值或者得到的是浮点数但是小数点后都是0的，这种情况就是像素对齐，否则就是像素不对齐，对于像素不对齐还有一种情况就是图片的size和显示图片的imageView的size以及逻辑像素point不相等。</p>
<p>出现像素不对齐的情况，会导致在GPU渲染时，对没对齐的边缘，需要进行插值计算，这个插值计算的过程会有性能损耗,像素不对称齐的元素一般为UILabel或UIImageView（UILabel宽度不为整数时并没有有像素不对齐，但x、y、height不为整数就会导致像素不对齐）。</p>
<p>解决像素不对齐的问题可以使用如下措施：</p>
<ul>
<li>frame设置时候，使用整数;计算frame时候，计算的结果使用ceil处理一下，避免小数点后有非0数存在。</li>
<li>设置imageView的size要和切图的size(逻辑像素point)相等。</li>
<li>如果图片是从服务端获取到的，这时候要注意图片大小，保证获取的图片的size要缩放成和imageView的size(逻辑像素poin)相等。缩放后的图片的scale和[UIScreen mainScreen].scale要相等，缩放操作放在子线程中做，并且做好缓存，避免每次显示都要缩放。</li>
<li>在使用Group Style的UITableview时，如果tableView:heightForHeaderInSection:回调返回0，系统会认为没有设置header的高度而重新提供一个默认的header高度，导致在UITableview中看到一个空白的header。这个可以通过在回调里返回一个很小的高度，比如0.01，这样能达到隐藏header的效果，但也造成了此处的像素不对齐问题。<br>可以通过如下方法解决：</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">CGFloat</span>)tableView:(<span class="built_in">UITableView</span> *)tableView heightForHeaderInSection:(<span class="built_in">NSInteger</span>)section &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">CGFLOAT_MIN</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>图片缩放方法：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">- (UIImage *)scaleImageWithSize:(CGSize)boxSize&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="constructor">CGSizeEqualToSize(<span class="params">boxSize</span>, <span class="params">self</span>.<span class="params">size</span>)</span>) &#123;</span><br><span class="line">        return self;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    CGFloat screenScale = <span class="literal">[[UIS<span class="identifier">creen</span> <span class="identifier">mainScreen</span>]</span> scale];</span><br><span class="line">    CGFloat rate = <span class="constructor">MAX(<span class="params">boxSize</span>.<span class="params">width</span> <span class="operator">/</span> <span class="params">self</span>.<span class="params">size</span>.<span class="params">width</span>, <span class="params">boxSize</span>.<span class="params">height</span> <span class="operator">/</span> <span class="params">self</span>.<span class="params">size</span>.<span class="params">height</span>)</span>;</span><br><span class="line">    CGSize resize = <span class="constructor">CGSizeMake(<span class="params">self</span>.<span class="params">size</span>.<span class="params">width</span> <span class="operator">*</span> <span class="params">rate</span> , <span class="params">self</span>.<span class="params">size</span>.<span class="params">height</span> <span class="operator">*</span> <span class="params">rate</span> )</span>;</span><br><span class="line">    CGRect drawRect = <span class="constructor">CGRectMake(-(<span class="params">resize</span>.<span class="params">width</span> - <span class="params">boxSize</span>.<span class="params">width</span>)</span><span class="operator"> / </span><span class="number">2.0</span> ,</span><br><span class="line">                                 -(resize.height - boxSize.height)<span class="operator"> / </span><span class="number">2.0</span> ,</span><br><span class="line">                                 resize.width,</span><br><span class="line">                                 resize .height);</span><br><span class="line">    boxSize = <span class="constructor">CGSizeMake(<span class="params">boxSize</span>.<span class="params">width</span>, <span class="params">boxSize</span>.<span class="params">height</span>)</span>;</span><br><span class="line">    <span class="constructor">UIGraphicsBeginImageContextWithOptions(<span class="params">boxSize</span>, YES, <span class="params">screenScale</span>)</span>;</span><br><span class="line">    <span class="literal">[<span class="identifier">self</span> <span class="identifier">drawInRect</span>:<span class="identifier">drawRect</span>]</span>;</span><br><span class="line">    UIImage *image = <span class="constructor">UIGraphicsGetImageFromCurrentImageContext()</span>;</span><br><span class="line">    <span class="constructor">UIGraphicsEndImageContext()</span>;</span><br><span class="line">    return image;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>放在异步缩放后设置到UIImageView上</p>
<figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">    UIImage *<span class="built_in">image</span> = [[UIImage imageNamed:self.cellModel.iconImageName] scaleImageWithSize:<span class="variable">_iconImageView</span>.frame.<span class="built_in">size</span>];</span><br><span class="line">    dispatch_sync(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        <span class="variable">_iconImageView</span>.<span class="built_in">image</span> = <span class="built_in">image</span>;</span><br><span class="line">        <span class="variable">_iconImageView</span>.hidden = (<span class="built_in">image</span> != <span class="literal">nil</span>) ? NO : YES;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>文本计算高度时候使用ceil进行像素对齐</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">CGSize</span>)textSizeWithFont:(<span class="built_in">UIFont</span>*)font&#123;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">CGSize</span> textSize = [<span class="keyword">self</span> sizeWithAttributes:@&#123;<span class="built_in">NSFontAttributeName</span>:font&#125;];</span><br><span class="line">   textSize = <span class="built_in">CGSizeMake</span>((<span class="type">int</span>)ceil(textSize.width), (<span class="type">int</span>)ceil(textSize.height));</span><br><span class="line">   <span class="keyword">return</span> textSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">CGSize</span>)textSizeWithFont:(<span class="built_in">UIFont</span>*)font</span><br><span class="line">                numberOfLines:(<span class="built_in">NSInteger</span>)numberOfLines</span><br><span class="line">                  lineSpacing:(<span class="built_in">CGFloat</span>)lineSpacing</span><br><span class="line">             constrainedWidth:(<span class="built_in">CGFloat</span>)constrainedWidth</span><br><span class="line">            isLimitedToLines:(<span class="type">BOOL</span> *)isLimitedToLines&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">CGSizeZero</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">CGFloat</span> oneLineHeight = font.lineHeight;</span><br><span class="line">    <span class="built_in">CGSize</span> textSize = [<span class="keyword">self</span> boundingRectWithSize:<span class="built_in">CGSizeMake</span>(constrainedWidth, MAXFLOAT) options:<span class="built_in">NSStringDrawingUsesLineFragmentOrigin</span> attributes:@&#123;<span class="built_in">NSFontAttributeName</span>:font&#125; context:<span class="literal">nil</span>].size;</span><br><span class="line">    <span class="built_in">CGFloat</span> rows = textSize.height / oneLineHeight;</span><br><span class="line">    <span class="built_in">CGFloat</span> realHeight = oneLineHeight;</span><br><span class="line">    <span class="keyword">if</span> (numberOfLines == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (rows &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">            realHeight = (rows * oneLineHeight) + (rows - <span class="number">1</span>) * lineSpacing;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (rows &gt; numberOfLines) &#123;</span><br><span class="line">            rows = numberOfLines;</span><br><span class="line">            <span class="keyword">if</span> (isLimitedToLines) &#123;</span><br><span class="line">                *isLimitedToLines = <span class="literal">YES</span>;  <span class="comment">//被限制</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        realHeight = (rows * oneLineHeight) + (rows - <span class="number">1</span>) * lineSpacing;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">CGSizeMake</span>(ceil(constrainedWidth),ceil(realHeight));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p><strong><strong>局部图形的生成</strong></strong></p>
<p>在我们通过CALayer设置视图的border、圆角、阴影、遮罩的时候不会直接在当前屏幕进行渲染，而是会在当前缓冲区以外的控件预先进行渲染，然后再绘制到当前屏幕上，这就是所谓的离屏渲染。离屏渲染之所以会很耗性能是因为它需要创建一个新的缓存区，并且在需要在当前屏幕缓冲区和离屏缓冲区之间进行切换。比较极端的情况:当一个列表视图中出现大量圆角的 CALayer，并且快速滑动时，可以观察到 GPU 资源已经占满，而 CPU 资源消耗很少。这时界面仍然能正常滑动，但平均帧数会降到很低。这种情况下可以通过把需要显示的图形在后台线程绘制为图片，避免使用圆角、阴影、遮罩等属性。</p>
<p><strong><strong>界面渲染</strong></strong></p>
<p>在经过上面处理后GPU会对上面的界面进行渲染，然后将渲染后的结果提交到帧缓冲区去。在VSync信号到来后视频控制器会从当前帧缓冲区中取出数据进行显示。如果在一个VSync时间内CPU 或者 GPU 没有完成内容提交，那么这一帧就会被丢弃，等待下一次机会再显示，而这时显示屏会保留之前的内容不变。这就导致了界面的卡顿。 </p>
<p>所以从上面整个流程来看在16ms时间内不论是CPU还是GPU压力过大导致没有在这段时间内提交界面渲染的数据都会导致界面的掉帧。</p>
<p>这里还需要注意的是iOS使用的是双缓冲机制：GPU会先将渲染好一帧放入当前屏幕帧缓存器供视频控制器读取，当下一帧渲染好后，GPU会直接把视频控制器的指针指向第二个缓冲器。当视频控制器读完一帧，准备读取下一帧的时候，GPU会在显示器的VSync信号发出后，快速切换两个帧缓冲区，这其实算是系统内机制的一种优化，现在大部分系统一般都会采用多缓冲机制。</p>
<p>下面对上面的优化点做个总结罗列：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1.</span>  能用CALayer的就不用UIView。</span><br><span class="line"><span class="bullet">2.</span>  在创建对象的时候尽量推迟某个对象的创建时间，可以通过懒加载的方式在使用的时候创建对象。</span><br><span class="line"><span class="bullet">3.</span>  对UIView属性的更改是比较耗费资源的，所以尽量减少不必要的属性修改，避免视图层次的调整以及视图的添加移除，尽量使用hide等属性来代替视图移除添加。</span><br><span class="line"><span class="bullet">4.</span>  尽量采用frame布局框架</span><br><span class="line"><span class="bullet">5.</span>  在计算布局的时候可以放在后台线程中进行计算，在最后设置frame的时候切换到主线程</span><br><span class="line"><span class="bullet">6.</span>  对布局计算结果进行缓存，可以在获取数据之后，异步计算Cell高度以及各控件高度和位置，并储存在Cell的LayouModel中，当每次Cell需要高度以及内部布局的时候就可以直接调用，不需要进行重复计算。对于自动缓存高度可以考虑使用FDTemplateLayoutCell来解决这个问题。</span><br><span class="line"><span class="bullet">7.</span>  对于大文本可以使用TextKit或者CoreText自定义的文本控件代替UILabel，UITextView</span><br><span class="line"><span class="bullet">8.</span>  对于图片可以在子线程预解码，主线程直接渲染.</span><br><span class="line"><span class="bullet">9.</span>  尽量不要用JPEG的图片，应当使用PNG或者WebP图片。</span><br><span class="line"><span class="bullet">10.</span> 尽量使用不包含透明通道的图片资源</span><br><span class="line"><span class="bullet">11.</span> 尽可能将多张图片合成为一张进行显示，图片的 size 最好刚好跟 UIImageView 的 size 保持一致</span><br><span class="line"><span class="bullet">12.</span> 将opaque设置为YES，减少性能消耗，因为GPU将不会做任何合成，而是进行简单的层拷贝</span><br><span class="line"><span class="bullet">13.</span> 尽量避免圆角（layer.cornerRadius &amp;&amp; layer.masksToBounds = YES || view.clipsToBounds = YES ）、阴影（layer.shadows）、遮罩（layer.mask），layer.allowsGroupOpacity为YES，layer.opacity的值小于1.layer.shouldRasterize = YES，layer.edgeAntialiasingMask，layer.allowsEdgeAntialiasing 这些情况出现,对于圆角可以靠绘制来完成或者直接让美工把图片切成圆角进行显示，这是效率最高的一种方案。</span><br><span class="line"><span class="bullet">14.</span> 合理使用光栅化 shouldRasterize，因为一旦开启光栅化CALayer会被光栅化为bitmap，这时候shadows、cornerRadius等效果会被缓存，所以对于那些不经常改变的界面比较合适，但是对于哪些内容动态改变的界面就不太合适了，因为更新已经光栅话的layer会导致离屏渲染。</span><br><span class="line"><span class="bullet">15.</span> 最小化界面刷新，刷新一个cell就能解决的，坚决不刷新整个 section 或者整个tableView。</span><br><span class="line"><span class="bullet">16.</span> 在滑动停止的时候再加载内容，对于一闪而过的内容没有必要加载，可以使用默认的占位符填充内容。</span><br><span class="line"><span class="bullet">17.</span> 在cellForRowAtIndexPath:回调的时候只创建实例，快速返回cell，不绑定数据。在willDisplayCell:forRowAtIndexPath:的时候绑定数据</span><br><span class="line"><span class="bullet">18.</span> 对于列表来说，在tableView滑动时，会不断调用heightForRowAtIndexPath:当高度需要自适应的时候每次回调都要计算高度，因此在这种情况下要对高度进行缓存，避免无意义的高度计算。</span><br><span class="line"><span class="bullet">19.</span> GPU 能处理的最大纹理尺寸是 4096x4096，一旦超过这个尺寸，就会占用 CPU 资源进行处理，所以纹理尽量不要超过这个尺寸.</span><br><span class="line"><span class="bullet">20.</span> 对于界面上需要频繁从数据库中读取数据进行展示的可以考虑为这些数据增加缓存。</span><br><span class="line"><span class="bullet">21.</span> 如果引入异步绘制框架成本可以接受可以考虑引入Texture或者类似的异步绘制框架。</span><br><span class="line"><span class="bullet">22.</span> 采用预加载机制，在一个列表中，滑动到一个可以设定的位置的时候，如果数据获取比较耗时可以考虑提前获取下载下一页的数据。</span><br><span class="line"><span class="bullet">23.</span> 尽量避免像素不对齐的现象发生。</span><br><span class="line"><span class="bullet">24.</span> 避免使用CGContext在drawRect:方法中绘制，大部分情况下会导致离屏渲染，哪怕仅仅是一个空的实现也会导致离屏渲染。</span><br></pre></td></tr></table></figure>

<p>如何使用XCode进行界面调优：</p>
<p>XCode相关的界面调优项目前都移动到了Debug -&gt; View Debuging -&gt; Rendering下，下面将对这里的每一项功能进行介绍：</p>
<ul>
<li><strong><strong>Color Blended Layers 图层混合检查</strong></strong></li>
</ul>
<p>这个选项是用于检测哪里发生了图层混合，哪块区域显示红色就说明发生了图层混合，所以我们的目的就是将红色区域消减的越少越好。那么如何减少红色区域的出现呢？上面提到了只要设置控件不透明即可。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">（<span class="number">1</span>）设置<span class="type">opaque</span> 属性为YES。</span><br><span class="line">（<span class="number">2</span>）给<span class="keyword">View</span>设置一个不透明的颜色。</span><br></pre></td></tr></table></figure>
<p>这里需要要再强调下UIImageView控件比较特殊，不仅需要自身这个容器是不透明的，并且imageView包含的内容图片也必须是不透明的。</p>
<ul>
<li><strong><strong>Color Hits Green and Misses Red 命中缓存的layer位图检查</strong></strong></li>
</ul>
<p>这个选项主要是检测我们是是否正确使用layer的shouldRasterize属性，shouldRasterize &#x3D; YES开启光栅化，光栅化会将一个layer预先渲染成bitmap，再加入缓存中，成功被缓存的layer会标注为绿色,没有成功缓存的会标注为红色，如果我们在一个界面中使用了光栅化，刚进去这个页面所有使用了光栅化的控件layer都会是红色，因为还没有缓存成功，如果上下滑动你会发现，layer变成了绿色。所以这一项的目标还是减小红色区域。</p>
<p>正确使用光栅化可以得到一定程度的性能提升，但是这只对于内容不变的情况下，也就是上面提到的静态页面，如果内容变更频繁那么就不要打开光栅化，否则会造成性能的浪费，例如我们在使用tableViewCell中，一般不要用光栅化，因为tableViewCell的绘制非常频繁，内容在不断的变化，如果使用了光栅化，会造成大量的离屏渲染降低性能。</p>
<p>对于光栅化需要注意两点<br>(1) 系统给光栅化缓存分配了的空间有限，不要过度使用，如果超出了缓存造成离屏渲染。<br>(2) 如果在100ms内没有使用缓存的对象，则会从缓存中清除。</p>
<ul>
<li><strong><strong>Color Copied Images 检查是否对图片进行格式转换操作</strong></strong></li>
</ul>
<p>如果GPU不支持当前图片的颜色格式，那么就会将图片交给CPU预先进行格式转化，并且将这张图片标记为蓝色，目前苹果的GPU只解析32bit的颜色格式，所以如果使用Color Copied Images去调试发现是蓝色，就可以找设计看下是否图片的颜色格式不对了。</p>
<ul>
<li><strong><strong>Color Misaligned Images</strong></strong></li>
</ul>
<p>这个选项可以帮助我们查看图片大小是否正确显示。如果image size和imageView size不匹配，image会出现黄色。要尽可能的减少黄色的出现。</p>
<ul>
<li><strong><strong>Color Offscreen-Rendered Yellow 离屏渲染</strong></strong></li>
</ul>
<p>这个选项可以帮助我们查看离屏渲染的，开启后会把那些需要离屏渲染的图层高亮成黄色，这就意味着黄色图层可能存在性能问题。关于离屏渲染见上面介绍。</p>
<ul>
<li><strong><strong>Flash Updated Regions 闪烁重绘区域</strong></strong></li>
</ul>
<p>这个选项会对重绘的内容高亮成黄色,绘制会损耗一定的性能，因此重绘区域应该越小越好。</p>
<p>这部分有一个比较好的文章可以供大家学习：<a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000015030561">iOS显示性能优化过程讲解</a></p>
<p>界面卡顿这部分可用的工具有如下几种：</p>
<ol>
<li>Debug –&gt; View Debuging –&gt; 可以用于检测：图层混合，光栅化，图片格式，像素对齐，离屏渲染等</li>
<li>Product –&gt; Profile -&gt; Core Animation :可以用于检测CPU&#x2F;GPU耗时情况，以及帧率等数据，和CPU 的Time Profiler</li>
</ol>
<p><img src="/2019/09/02/iOS-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/000011111.png"></p>
<h6 id="3-3-电量优化"><a href="#3-3-电量优化" class="headerlink" title="3.3 电量优化"></a><strong><strong>3.3 电量优化</strong></strong></h6><p>设备在休眠的情况下几乎不会消耗任何电量，一旦某些硬件设备被唤醒就会开始消耗电量，因此电量优化的目标就是在不影响应用性能的情况下找到消耗电量的大户尽量减少它的功耗消耗。<br>下面是几个耗电量大户:<br><img src="/2019/09/02/iOS-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/000001.png"></p>
<ul>
<li>Processing  包括CPU,GPU在内的处理器件</li>
<li>Location    定位服务</li>
<li>Display     屏幕亮度</li>
<li>Network     网络</li>
<li>Accessories 蓝牙</li>
<li>Multimedia  音视频器件</li>
<li>Camera      摄像头</li>
</ul>
<p>在给出电量优化建议之前我们还需要了解两个概念“固定能耗” “动态能耗”</p>
<ul>
<li><strong><strong>固定能耗</strong></strong>是指在任务执行前后把系统和各种资源调用起来和关闭所消耗的能量。</li>
<li><strong><strong>动态能耗</strong></strong>动态能耗指的是app实际工作消耗的能量。</li>
</ul>
<p>下面是这两个概念的示意图:<br><img src="/2019/09/02/iOS-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/000002.png"></p>
<p><strong><strong>Idle状态</strong></strong>   :这时候应用处于休眠状态几乎不使用电量。<br><strong><strong>Active状态</strong></strong> :这时候应用处于前台用电量比较高。<br><strong><strong>Overhead状态</strong></strong>:唤醒硬件来支持应用某项功能所消耗的电量。即使我们的应用只做了一点点事，Overhead 所带来的电量消耗一点也不会减少。</p>
<p>横线以下所包区域是固定能耗，横线以上区域是动态能耗。</p>
<p>从这个角度触发我们可以通过分批执行，或者降低执行频率来避免产生零散的任务，比如将任务同时放到多个线程中并行执行。这样虽然在给定时间内做了更多的工作，看似消耗了更多的能量，导致了更大的前期动态功耗，但是由于缩短了工作的时间，更早使得CPU回到闲置状态，其他元件也更快地断电，所以固定功耗减少了。从整体上看，这会降低极大地节省功耗消耗。<br><img src="/2019/09/02/iOS-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/000003.png"></p>
<p>下面针对上面介绍的几个耗电大户给出电量优化的建议，供大家在平时开发中参考：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1.</span> 在不需要使用定时器的时候要记得及时关闭重复性的定时器，定时器的时间间隔不宜太短，如果定时器触发太频繁，能耗影响是比较大的。</span><br><span class="line"><span class="bullet">2.</span> 尽量减少数据传输的数据量,可以考虑使用protobuf代替JSON格式，如果允许尽量降低上传或下载的多媒体内容质量和尺寸等。</span><br><span class="line"><span class="bullet">3.</span> 如果不是非常紧急的数据可以考虑延迟将多个数据合并后，统一打包上传，在下载某些数据的时候可以一次性多下载一部分。避免频繁网络请求。比如，下载视频流时，不要传输很小的数据包，直接下载整个文件或者一大块一大块地下载。如果提供广告，一次性多下载一些，然后再慢慢展示。如果要从服务器下载电子邮件，一次下载多条，不要一条一条地下载。网络操作能推迟就推迟。如果通过HTTP上传、下载数据，建议使用NSURLSession中的后台会话，这样系统可以针对整个设备所有的网络操作优化功耗。</span><br><span class="line"><span class="bullet">4.</span> 对于不是非常实时的数据可以考虑使用缓存减少下载相同的数据</span><br><span class="line"><span class="bullet">5.</span> 使用断点续传，避免网络不稳定导致多次传输相同的内容。</span><br><span class="line"><span class="bullet">6.</span> 网络不可用的时候不要发起网络请求，在网络失败的情况下不断增加重试的间隔时间。</span><br><span class="line"><span class="bullet">7.</span> 尽量只在WiFi的情况下联网传输数据</span><br><span class="line"><span class="bullet">8.</span> 设置合适的网络超时时间，及时取消长时间运行或者速度很慢的网络操作</span><br><span class="line"><span class="bullet">9.</span> 将可以推迟的操作尽量推迟到设备充电状态并且连接Wi-Fi时进行，比如同步和备份工作。</span><br><span class="line"><span class="bullet">10.</span> 尽量减少动画，动画尽可能用较低的帧率，在不展示的时候不要更新动画。</span><br><span class="line"><span class="bullet">11.</span> 在定位方面，如果只需要快速确定一下用户位置，而不需要实时更新位置，记得在定位完成后及时关闭定位服务。尽量降低定位精度。如果需要后台更新位置的时候尽量把pausesLocationUpdatesAutomatically设为YES，如果用户不太可能移动的时候系统会自动暂停位置更新。总而言之定位和蓝牙按需取用,定位之后要关闭或降低定位频率。</span><br><span class="line"><span class="bullet">12.</span> 遵守前面提到的界面优化的内容，这会降低CPU和GPU的负担</span><br><span class="line"><span class="bullet">13.</span> 线程适量,不宜过多</span><br><span class="line"><span class="bullet">14.</span> 应用每次执行I/O任务，比如写文件，会导致系统退出闲置模式。而且写入缓存格外耗电，因此尽量不要频繁写入小数据，最好把多个更改攒到一起批量一次性写入,如果只有几个字节的数据改变，不要把整个文件重新写入一次。</span><br><span class="line"><span class="bullet">15.</span> 尽量顺序读写数据,在文件中跳转位置会消耗一些时间,如果数据由随机访问的结构化内容组成，建议将其存储在数据库中.</span><br><span class="line"><span class="bullet">16.</span> 读写大量重要数据时，考虑用 dispatch<span class="emphasis">_io，其提供了基于 GCD 的异步操作文件 I/O 的 API。用 dispatch_</span>io 系统会优化磁盘访问，数据量比较大的，建议使用数据库。</span><br><span class="line"><span class="bullet">17.</span> 用户移动、摇晃、倾斜设备时，会产生动作事件，这些事件由加速计、陀螺仪、磁力计等硬件检测。在不需要检测的场合，应该及时关闭这些硬件。</span><br><span class="line"><span class="bullet">18.</span> 如果某个通知不依赖外部数据，而是需要基于时间的通知，应该用本地通知，这样可以减轻网络模块的耗电。</span><br><span class="line"><span class="bullet">19.</span> 如果不是真的需要即时推送，尽量使用延时推送。</span><br></pre></td></tr></table></figure>

<p>如何检测电量的性能：</p>
<ol>
<li>最直观地观察打开某个应用的时候是否存在耗电特别快，手机特别烫手的现象。</li>
<li>用Xcode Energy impact测量功耗:<br><img src="/2019/09/02/iOS-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/00004.png"></li>
<li>通过设备记录电池Log后导入到Instruments进行分析:<figure class="highlight coq"><table><tr><td class="code"><pre><span class="line">-&gt;在设备上进入设置 </span><br><span class="line">-&gt; 开发者 </span><br><span class="line">-&gt; Logging </span><br><span class="line">-&gt; Enery打开 </span><br><span class="line">-&gt; Networking打开 </span><br><span class="line">-&gt; 点击Start Recording  </span><br><span class="line">-&gt; 然后点开我们想要测试的App，进行测试，定好时间，</span><br><span class="line">-&gt; 时间到了后点击Stop Recording </span><br><span class="line">-&gt; 在Instruments中选择好设备进入Energy Log </span><br><span class="line">-&gt; 选择<span class="keyword">File</span> </span><br><span class="line">-&gt; <span class="keyword">Import</span> Logged Data from Device</span><br></pre></td></tr></table></figure></li>
</ol>
<h6 id="3-4-启动优化"><a href="#3-4-启动优化" class="headerlink" title="3.4 启动优化"></a><strong><strong>3.4 启动优化</strong></strong></h6><p>应用启动有两种类型冷启动和热启动，冷启动指的是应用从无到有，它的进程不在系统里，需要系统新创建一个进程加载镜像，运行程序，再到展现在界面上，而热启动指的是应用还在后台的情况下启动应用。</p>
<p>一般我们的应用需要在400ms内启动完成，如果启动时间大于20s将会被系统杀掉。我们可以使用Edit scheme -&gt; Run -&gt; Arguments -&gt; DYLD_PRINT_STATISTICS设置为1 或者更详细地通过DYLD_PRINT_STATISTICS_DETAILS设置为1。</p>
<p><img src="/2019/09/02/iOS-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/9999.png"><br><img src="/2019/09/02/iOS-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/11111.png"></p>
<p>下面的博客将会介绍</p>
<ul>
<li>Mach-O镜像结构，加载过程</li>
<li>启动的各个阶段</li>
<li>如何优化启动时间</li>
</ul>
<p>首先我们看下Mach-O文件，可能大家比较对ELF会比较熟悉，它是UNIX环境下的可移植二进制文件，而Mach-O是苹果所独有的可执行二进制文件格式。主要包括下面几种类型：</p>
<ul>
<li>Executable：应用的主要可执行文件</li>
<li>Dylib：动态链接库</li>
<li>Bundle：资源包，不能被链接，只能在运行时使用dlopen加载</li>
<li>Image：包含Executable，Dylib和Bundle是上面三者的集合</li>
<li>Framework：包含Dylib、资源文件和头文件的文件夹</li>
</ul>
<p>下面是之前一篇博客的一张图，介绍了整个Mach-O文件的结构以及编译过程与Mach-O文件的关系。<br><img src="/2019/09/02/iOS-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/mach0.png"></p>
<p>我们这里主要接这张图关注下Mach-O文件的结构：每个Mach-O文件一般都由三大部分:Header,loadCommand,Segment构成，每个Segment都包含了一个或者多个Section信息。</p>
<ul>
<li>Header中包含了大小端信息，CPU架构信息，当前二进制文件类型，dyld过程中的一些参数。</li>
<li>LoadCommands用于指示每个Segment的加载方式。</li>
<li>每个Segment定义了虚拟内存中的一块区域，这些区域会被动态链接器链接到程序的具体内存地址。</li>
</ul>
<p>Segment由如下几个部分构成：</p>
<figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line"><span class="variable">__TEXT</span> 用于存放被执行的代码以及只读常量，属于只读可执行区域（r-x）。</span><br><span class="line"><span class="variable">__DATA</span> 包含全局变量，静态变量等。属于可读写区域（rw-）。</span><br><span class="line"><span class="variable">__LINKEDIT</span> 包含了加载程序的元数据，比如函数的名称和地址。属于只读区域（r–）</span><br><span class="line"><span class="variable">__PAGEZERO</span> 用于捕获空指针陷阱段，用于捕捉对NULL指针的引用</span><br><span class="line"><span class="variable">__OBJC</span> 包含一些会被Objective Runtime 使用到的一些数据。</span><br></pre></td></tr></table></figure>

<p>有了上面的介绍我们就可以来介绍应用的加载过程了。整个应用的启动分成两大阶段：<br>Pre-main 阶段和 main 阶段：</p>
<p>先用一张图来概括下这两个阶段的整体流程：</p>
<p><img src="/2019/09/02/iOS-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/001010.png"></p>
<ul>
<li>Pre-main 阶段：</li>
</ul>
<p><img src="/2019/09/02/iOS-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/1000001.png"></p>
<p><strong><strong>fork&#x2F;exec</strong></strong>：</p>
<p>我们知道当启动一个应用的时候系统会调用fork和execve两个方法，前者会创建一个进程，然后让这个新创建的进程去执行execve方法将程序加载到内存并映射到新的地址空间运行，fork新建的进程，父进程与子进程共享同一份代码段，但是数据段是分开的，但是父进程会把自己数据空间的内容copy到子进程中去，还有上下文也会copy到子进程中去。在映射过程中为了防止被黑客注入代码，重写内存，在地址映射阶段会采用ASLR（地址空间布局随机化）技术，在进程每次启动的时候，随机偏移地址空间，并将起始位置到 0x000000 这段范围的进程权限都标记为不可读写不可执行，NULL 指针引用和指针截断误差都会被它捕获。</p>
<p>简而言之这个阶段的任务就是新建进程并根据指定的文件名找到可执行文件，用它来取代进程的内容。</p>
<p><strong><strong>动态库加载</strong></strong>：</p>
<p>在开始介绍这个过程之前需要了解一点：动态链接库和静态链接库的区别：<br>首先，对于动态链接库而言，它们不会在编译的时候打包到应用中，而静态链接库是会和应用一起打包，所以相对而言静态链接库会占用更大的空间，并且在内存和磁盘中动态链接库只保留一份，这样便于集中管理，更新。但是它最大的缺点是加载会耗时，我们就来看下动态链接库是怎么被加载的？</p>
<p>在这个阶段系统会从可执行文件(Mach-O文件)中获取dyld路径，然后加载dyld，dyld会先去初始化运行环境，并开启缓存策略，接着dyld会从主执行文件的Header中获取到需要加载的依赖动态库列表，然后根据这个列表，找到每个dylib文件，对动态库文件进行头部信息校验，保证是Mach-O文件，接着找到代码签名并将其注册到内核。然后在 dylib 文件的每个 segment 上调用 mmap()，应用所依赖的dylib文件可能会再依赖其他dylib，所以这个过程是递归依赖的集合加载过程。这是一个耗时点之一，但是这部分的动态库大部分都是系统dylib，它们会被预先计算和缓存起来（因为操作系统自己要用部分framework所以在操作系统开机后就已经加载到内存了），dyld对这部分动态库加载速度很快，并且dyld在加载一个Mach-O文件的时候动态链接器首先会检查共享缓存看看是否存在，如果存在那么就直接从共享缓存中拿出来使用，这个共享缓存是公用的，每个进程都会将这个共享缓存映射到自己的地址空间。因此我们要优化的是除了系统动态库，以及共享动态链接库外的非系统动态链接库部分，我们在开发过程中尽量减少这部分动态库的数量来减少这部分的运行时间。</p>
<p>下面对每个动态库加载过程做个简单总结：</p>
<p>在每个动态库的加载过程中，dyld都需要：</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="bullet">* </span>分析所依赖的动态库</span><br><span class="line"><span class="bullet">* </span>找到动态库的Mach-O文件</span><br><span class="line"><span class="bullet">* </span>打开文件</span><br><span class="line"><span class="bullet">* </span>验证文件</span><br><span class="line"><span class="bullet">* </span>在系统核心注册文件签名</span><br><span class="line"><span class="bullet">* </span>对动态库的每一个segment调用mmap()</span><br></pre></td></tr></table></figure>

<p><strong><strong>rebase&#x2F;bind</strong></strong>：</p>
<p>由于ASLR机制的存在，可执行文件和动态链接库在虚拟内存中的加载地址每次启动都不固定，所以需要进行重定向；<br>在加载所有的动态链接库之后，它们只是处在相互独立的状态，需要将它们绑定起来，所以需要进行动态库的绑定;</p>
<p>rebase修复的是指向当前镜像内部的资源指针；而bind指向的是镜像外部的资源指针。整个过程会先执行rebase，这个阶段会把镜像读入内存，并以page为单位进行加密验证，保证不会被篡改，而bind阶段需要查询符号表来指向跨镜像的资源，也就是将这个二进制调用的外部符号进行绑定的过程。比如我们objc代码中需要使用到NSObject, 即符号_OBJC_CLASS_$_NSObject，但是这个符号又不在我们的二进制中，在系统库 Foundation.framework中，因此就需要bind这个操作将对应关系绑定到一起，这阶段优化的关键点在于减少__DATA segment中的指针数量。</p>
<blockquote>
<p>在这个阶段验证 Mach-O 文件的签名，并不是每次重复读入整个文件，而是把每页内容都生成一个单独的加密散列值，并存储在 __LINKEDIT 中。从而使得文件每页的内容都能及时被校验确并保不被篡改。</p>
</blockquote>
<blockquote>
<p>虚拟内存的作用：我们开发过程中所接触到的内存均为虚拟内存，虚拟内存使我们认为App拥有一个连续完整的地址空间,而实际上它是分布在多个物理内存碎片组成，系统的虚拟内存空间映射vm_map负责虚拟内存和物理内存的映射关系。</p>
</blockquote>
<p><strong><strong>Objc setup &amp;&amp; Initializers</strong></strong>：</p>
<p>Objc setup主要是在objc_init完成的：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void <span class="constructor">_objc_init(<span class="params">void</span>)</span> &#123;</span><br><span class="line">    static <span class="built_in">bool</span> initialized = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (initialized) return;</span><br><span class="line">    initialized = <span class="literal">true</span>;</span><br><span class="line">    environ<span class="constructor">_init()</span>;</span><br><span class="line">    tls<span class="constructor">_init()</span>;</span><br><span class="line">    static<span class="constructor">_init()</span>;</span><br><span class="line">    lock<span class="constructor">_init()</span>;</span><br><span class="line">    <span class="keyword">exception</span><span class="constructor">_init()</span>;</span><br><span class="line">    <span class="constructor">_dyld_objc_notify_register(&amp;<span class="params">map_2_images</span>, <span class="params">load_images</span>, <span class="params">unmap_image</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在objc_init方法中主要绑定了三个回调函数map_2_images,load_images和unmap_image。在bind阶段完成后会发出dyld_image_state_bound，这时候map_2_images方法就会被调用，进行镜像加载，在这个方法中主要完成如下几件事：</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="bullet">* </span>读取二进制文件的 DATA 段内容，找到与objc相关的信息</span><br><span class="line"><span class="bullet">* </span>注册Objc类ObjC Runtime 需要维护一张映射类名与类的全局表。当加载一个dylib时，其定义的所有的类都需要被注册到这个全局表中</span><br><span class="line"><span class="bullet">* </span>读取protocol以及category的信息，将分类插入到类的方法列表里</span><br><span class="line"><span class="bullet">* </span>确保selector的唯一性</span><br></pre></td></tr></table></figure>

<p>而在镜像加载结束后系统会发出dyld_image_state_dependents_initialize通知，这时候load_images会被调用，在这里类的load方法会被调用。然后调用mapimages做解析和处理，接下来在loadimages中调用callloadmethods方法，遍历所有加载进来的Class，按继承层级依次调用Class的+load方法和其Category的+load方法,并完成C&#x2F;C++静态初始化对象和标记__attribute__(constructor)的方法调用。</p>
<p>这里做个简单总结，整个过程如下：</p>
<p>dyld首先会将程序二进制文件初始化后交给镜像加载器读取程序镜像中的类、方法等各种符号,由于runtime向dyld绑定了回调,所以当image被加载到内存后,dyld会通知runtime对镜像进行处理<br>runtime接手后调用mapimages做解析处理，接下来loadimages中调用callloadmethods方法遍历所有加载进来的Class,按继承层级依次调用Class的+load方法和其Category的+load方法<br>至此可执行文件中和动态库所有的符号(Class，Protocol，Selector，IMP，…)都已经按格式成功加载到内存中，被runtime所管理，再这之后，runtime 的那些方法(如动态添加Class、swizzle等方法）才能生效。所有初始化工作结束后dyld调用真正的main函数。如果程序刚刚被运行过，那么程序的代码会被dyld缓存（操作系统对于动态库有一个共享的空间，在这个空间被填满，或者没有其他机制来清理这一块的内存之前，动态库被加载到内存后就一直存在），因此即使杀掉进程再次重启加载时间也会相对快一点，如果长时间没有启动或者当前dyld的缓存已经被其他应用占据，那么这次启动所花费的时间就要长一点，这就是前面提到的冷启动和热启动两种情况。</p>
<p>在介绍完Pre-main 阶段我们看下有哪些节点可以优化：</p>
<ol>
<li>动态库加载阶段可以通过减少非系统，非共享动态库的依赖或者合并动态库来优化速度(可以借助linkmap来分析)</li>
<li>使用静态库而不是动态库，但是这会带来包体积增加的风险，需要权衡。</li>
<li>Rebase&#x2F;Bind阶段可以通过减少Objc类数量以及selector数量来减少这部分运行时间</li>
<li>将不必须在+load方法中做的事情延迟到+initialize中.能用dispatch_once()来完成的，就尽量不要用__attribute__((constructor))以及load方法(attribute((constructor))的函数调用会在+load函数调用之后)</li>
<li>合并Category和功能类似的类,删除无用的方法和类（可以借助<a target="_blank" rel="noopener" href="https://github.com/dblock/fui">FUI</a>来扫描，但是需要注意的是它处理不了动态库和静态库里提供的类，也处理不了C++的类模板）。</li>
<li>替代部分庞大的库，采用更轻量级的解决方案。</li>
</ol>
<ul>
<li>main 阶段：</li>
</ul>
<p>这个阶段包括:main方法执行之后到AppDelegate类中的didFinishLaunchingWithOptions方法执行结束前这段时间.下面是这个阶段的示意图：<br><img src="/2019/09/02/iOS-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/00000.png"></p>
<ul>
<li>这部分的优化主要是属于业务层面的优化，需要梳理下各个业务初始化的优先级以及依赖关系，能延迟初始化的尽量延迟初始化，不能延迟初始化的尽量放到后台线程中初始化，可以通过启动项自注册来完成启动项解耦。</li>
</ul>
<p>有些启动项是需要刚启动就执行的操作，如Crash监控、统计上报等，否则会导致信息收集的缺失，对于基于位置的服务，需要先拿到定位位置后才能针对区域拿到对应数据，因此定位的优先级也会比较高，针对项目的配置可以拆分成两大类，一类是优先级比较高的，比如首页需要的某些配置，另一类是优先级比较低的比如对某些公共模块配置的项，这种可以延迟到首页加载完成之后加载。还有一些路由配置，网络配置都是一些相对优先级比较高的启动项目。而对于其他模块的初始化以及某些非首页需要的SDK初始化都应该延后到首页加载之后。</p>
<ul>
<li><p>通过instruments的Time Profiler初始化过程中比较耗时的操作并有针对性地优化。比如每次用NSLog方式打印会隐式的创建一个Calendar，因此需要删减启动时各业务方打的log，或者仅仅针对内测版输出log。</p>
</li>
<li><p>在rootViewController加载过程中也存在优化的点：在启动过程中只加载tabbarVC的主VC即可，而且主VC中的ViewDidLoad方法中也只加载需要立即显示出来的view,其他视图均使用懒加载，数据进行异步加载。</p>
</li>
</ul>
<p>如果想深入继续了解这部分可以参阅如下博客：</p>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://everettjf.github.io/2018/08/06/ios-launch-performance-collection/">iOS应用启动性能优化资料</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://everettjf.github.io/2018/12/12/ios-app-launch-perf-coll/">过去一段时间的iOS启动优化文章目录</a></p>
</li>
</ul>
<h6 id="3-5-体积优化"><a href="#3-5-体积优化" class="headerlink" title="3.5 体积优化"></a><strong><strong>3.5 体积优化</strong></strong></h6><p>随着应用功能不断增加，App 的大小也会随着增加，App 的包体积优化的目的就是为了节省用户流量，提高用户的下载速度，以及节省更多空间。另外 App Store 官方规定 App 安装包如果超过 150MB，那么不可以在OTA环境下下载。如果我们的应用 需要适配 iOS7、iOS8 那么官方规定主二进制 text 段的大小不能超过 60MB。如果不能满足这个标准，则无法上架 App Store。</p>
<p><strong><strong>iOS 安装包的组成</strong></strong></p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line">将一个应用程序，后缀由.ipa改为.zip，然后解压，可以看到Payload文件夹，里面有个.app 的文件，右键显示包内容可以看到很多的文件，但是大部分我们就针对这里面重点的几个文件：</span><br><span class="line"></span><br><span class="line">1. 可执行文件：一般应用而言最大的文件应该是可执行文件。</span><br><span class="line">2. Assets.car：我们在开发过程中会将图片放在Assets.xcassets中，在打包后会将这些图片统一压缩成一个Assets.car的文件，大大减小包的大小。car文件可以使用[cartool](<span class="link">https://github.com/steventroughtonsmith/cartool)来获取具体资源。还可以通过</span>[<span class="string">Assets.carTool</span>](https://github.com/yuedong56/Assets.carTool)来以图形化方式解压car文件。</span><br><span class="line">3. Bundle文件</span><br><span class="line">4. _CodeSignature 文件夹，下面包含一个CodeResources文件，里面是一个属性列表，包含bundle中所有其他文件的列表，这个属性列表只有一项files这是一个字典键是文件名值通常是Base64格式的散列值。它的作用是用来判断一个应用程序是否完好无损，能够防止不小心修改或损坏资源文件。</span><br><span class="line">5. XXX.lproj 多语言字符串</span><br><span class="line">6. Frameworks 文件夹</span><br><span class="line">7. info.plist</span><br><span class="line">8. 图片资源，音频资源，数据库资源，本地json配置文件，LaunchImage/AppIcon</span><br></pre></td></tr></table></figure>
<p>通过上面内容可以看出可优化的最大块内容在于可执行文件，Assets.car，图片，音视频文件这几大方面。</p>
<p><strong><strong>资源文件瘦身</strong></strong></p>
<p>对于一个App来说主要的资源文件就是图片，所以资源文件的瘦身主要针对的是图片的瘦身，可以通过删除无用图片、去除重复图片、压缩图片。</p>
<ul>
<li>使用LSUnusedResources删除无用图片资源：</li>
</ul>
<p>通过<a target="_blank" rel="noopener" href="https://github.com/tinymind/LSUnusedResources">LSUnusedResources</a>来扫描项目中无用的图片文件，但是这里会误判所以最终还是要一个个确认是否真的再项目中无用。</p>
<ul>
<li>使用Fdupes去除各模块中的重复图片：</li>
</ul>
<p>Fdupes能够找到给定的目录和子目录集中的重复文件。 它通过比较文件的MD5签名，然后进行字节到字节的比较来识别重复，它依次通过：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">大小比较 &gt; 部分MD5签名比较 &gt; 全MD5签名比较 &gt; 字节到字节的比较</span><br></pre></td></tr></table></figure>
<p>安装：</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">brew </span><span class="keyword">install </span>fdupes </span><br></pre></td></tr></table></figure>

<p>最常用命令：</p>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>fdupes -r path                <span class="comment"># 搜索重复子文件在终端展示</span></span><br><span class="line"><span class="variable">$ </span>fdupes -Sr path               <span class="comment"># 搜索重复子文件&amp;显示每个重复文件的大小在终端展示</span></span><br><span class="line"><span class="variable">$ </span>fdupes -Sr path &gt; log.txt     <span class="comment"># log输出到指定路径文件夹</span></span><br></pre></td></tr></table></figure>

<p>最近还发现一款软件也是可以删除重复点资源文件：<a target="_blank" rel="noopener" href="https://macpaw.com/gemini">Gemini</a></p>
<ul>
<li>使用图片压缩工具压缩图片资源：</li>
</ul>
<p>无损压缩工具: ImageOptim会对每张图片分别应用以上几种压缩算法，然后对比每种压缩算法产出的图片，选取最小的那张作为输出结果。<br><a target="_blank" rel="noopener" href="https://imageoptim.com/mac">ImageOptim</a></p>
<p>有损压缩工具:</p>
<p><a target="_blank" rel="noopener" href="https://pngmini.com/">ImageAlpha</a><br><a target="_blank" rel="noopener" href="https://tinypng.com/">tinypng</a></p>
<p>这里有一篇<a target="_blank" rel="noopener" href="https://juejin.im/entry/587f14378d6d810058a18e1f">PNG 图片压缩对比分析</a>可供大家参考。</p>
<p>使用WebP格式的图片</p>
<p>WebP格式的优点：</p>
<blockquote>
<p>压缩率高。支持有损和无损2种方式，比如将 Gif 图可以转换为 Animated WebP，有损模式下可以减小 64%，无损模式下可以减小 19%<br>WebP 支持 Alpha 透明和 24-bit 颜色数，不会像 PNG8 那样因为色彩不够出现毛边。</p>
</blockquote>
<p>WebP格式的缺点：</p>
<blockquote>
<p>WebP 在 CPU 消耗和解码时间上会比 PNG 高2倍，所以我们做选择的时候需要取舍。</p>
</blockquote>
<p>对单色纯色图标使用矢量图</p>
<p>对于App里面的单色纯色图标都是可以使用矢量图代替，它的好处是不需要添加 @2x、@3x 图标，节省了空间。具体使用可以看<a target="_blank" rel="noopener" href="https://github.com/FantasticLBP/IconFont_Demo">IconFont_Demo</a></p>
<ul>
<li>使用On Demand Resources技术</li>
</ul>
<p>具体见后文介绍，在这方面还可以将一些非必须的资源放在服务端，待需要的时候再进行下载。</p>
<ul>
<li>图片压缩的相关编译选项</li>
</ul>
<p><strong><strong>Compress PNG Files</strong></strong> 打包的时候自动对图片进行无损压缩，使用的工具为 pngcrush<br><strong><strong>Remove Text Medadata From PNG Files</strong></strong> 移除 PNG 资源的文本字符，比如图像名称、作者、版权、创作时间、注释等信息。</p>
<p>这里总结下Bundle 和 Asset Catalog 管理的图片的区别：</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="bullet">* </span>工程中所有使用Asset Catalog 管理的图片，最终输出的时候，都会被放置到 Assets.car内。在编译的时候XCode会对这部分资源进行压缩处理。而Bundle的资源需要我们使用外部压缩工具进行手动压缩处理。</span><br><span class="line"><span class="bullet">* </span>xcassets 里的 2x 和 3x，会根据具体设备分发，不会同时包含。而Bundle会都包含。</span><br><span class="line"><span class="bullet">* </span>xcassets内，可以对图片进行 Slicing。Bundle 不支持</span><br><span class="line"><span class="bullet">* </span>xcassets 里面的图片，只能通过imageNamed加载。Bundle内的资源还可以通过 imageWithContentsOfFile 等方式加载。但是需要注意的是使用 imageNamed 创建的 UIImage，会立即被加入到 NSCache中，在收到内存警告的时候，会自动释放不在使用的 UIImage。而使用imageWithContentsOfFile加载的图片每次加载都会重新申请内存，相同图片不会缓存。这也是我们常说的xcassets内的图片，加载后会产生缓存。</span><br></pre></td></tr></table></figure>

<p>对于图片的压缩个人的习惯是开启Compress PNG Files，再用ImageOptim对Bundle内的图片以及项目中所有JPEG 格式的图像进行压缩（xcassets 里面的 png文件不用压缩，压缩反而会增大包体积），因为 Bundle内的图片以及JPEG 格式的图片是直接拷贝进项目的，并不会被Xcode进行压缩，所以两部分是需要我们手动进行资源压缩处理。一般还有个通识：对于常用的，较小的图片，应该使用Asset Catalog 管理，而对于大的图片，可以选择直接废弃2x尺寸的图片，全部使用3x大小的jpg压缩后放在Bundle内管理。同时还需要注意xcassets 中要避免使用 JPEG 图像，这会导致打包会变大。对于一些比较大体积的背景图片可以压缩成.jpg的格式放在Bundle中。</p>
<p>对于音视频文件的优化可以通过：删除无用的音视频文件，降低音频文件的采样率。</p>
<p><strong><strong>可执行文件瘦身</strong></strong></p>
<ol>
<li>使用Fui(Find Unused Imports)清理不用的类</li>
</ol>
<p>Fui（Find Unused Imports）是分析不再使用的类的一个开源工具，准确率相对较高，但是这种删代码的事情最好要确认后手动一一删除，并且配合Git,SVN等工具，最终还得经过review，整体测试后才能放出版本，它也有比较大的问题：它处理不了动态库和静态库里提供的类，也处理不了C++的类模板。</p>
<ul>
<li>安装Fui</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">gem <span class="keyword">install</span> fui</span><br></pre></td></tr></table></figure>

<ul>
<li>查看帮助</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fui <span class="built_in">help</span></span><br></pre></td></tr></table></figure>

<ul>
<li>最常用的命令形式</li>
</ul>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">fui -v <span class="attribute">--path</span>=./ <span class="attribute">--ignore-path</span>=Pods find</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用LinkMap分析安装包</li>
</ol>
<p>我们编写的源码需要经过编译链接，最终生成一个可执行文件，在编译阶段每个类会生成对应的.o文件（目标文件）。在链接阶段，会把.o文件和动态库链接在一起。但是生成的可执行文件为二进制文件，我们很难看明白它的具体内容，而linkMap 很好得帮我们解决了这个问题。linkMap是一个记录链接相关信息的纯文本文件，里面记录了可执行文件的路径、CPU架构、可执行文件内存分布、类符号，方法符号等信息。</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">(<span class="number">1</span>) 通过LinkMap可以通过Symbols还原出奔溃时候的源码位置</span><br><span class="line">(<span class="number">2</span>) 还可以比较直观得查看整个内存的分段情况</span><br><span class="line">(<span class="number">3</span>) 可以分析可执行文件中哪个类或者库占用的空间比较大，从而为我们这里需要介绍的安装包瘦身做指导</span><br></pre></td></tr></table></figure>

<ul>
<li>生成linkMap文件：</li>
</ul>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">Xcode开启编译选项 Write Link Map File:</span><br><span class="line"></span><br><span class="line">XC<span class="function"><span class="title">ode</span> -&gt;</span> P<span class="function"><span class="title">roject</span> -&gt;</span> B<span class="function"><span class="title">uild</span> Settings -&gt;</span> 搜<span class="function"><span class="title">map</span> -&gt;</span> 把Write Link Map File选项设为YES，并指定好linkMap的存储位置.</span><br></pre></td></tr></table></figure>
<p><img src="/2019/09/02/iOS-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/99999.png"></p>
<p>生成的linkMap文件位于：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">~<span class="regexp">/Library/</span>Developer<span class="regexp">/Xcode/</span>DerivedData<span class="regexp">/IDLFundation-dzjqiskjttzspjcrncvbbssnqtok/</span>Build<span class="regexp">/Intermediates.noindex/</span>IDLFundation.build<span class="regexp">/Debug-iphonesimulator/</span>IDLFundationTest.build/IDLFundationTest-LinkMap-normal-x86_64.txt</span><br></pre></td></tr></table></figure>

<ul>
<li>linkMap文件结构解析:</li>
</ul>
<p>LinkMap 文件分为3部分：Object File、Section、Symbols，如下图所示：</p>
<p><img src="/2019/09/02/iOS-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/909090.png"></p>
<figure class="highlight mathematica"><table><tr><td class="code"><pre><span class="line"><span class="variable">Object</span> <span class="built_in">File</span>：包含了代码工程的所有文件</span><br><span class="line"><span class="variable">Section</span>：描述了代码段在生成的 <span class="variable">Mach</span><span class="operator">-</span><span class="built_in">O</span> 里的偏移位置和大小</span><br><span class="line"><span class="variable">Symbols</span>：会列出每个方法、类、<span class="built_in">Block</span>，以及它们的大小</span><br></pre></td></tr></table></figure>

<p><strong><strong>基础信息</strong></strong>：</p>
<p>包括可执行文件路径，可执行文件架构。</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"># Path: <span class="regexp">/Users/</span>huya<span class="regexp">/Library/</span>Developer<span class="regexp">/Xcode/</span>DerivedData<span class="regexp">/IDLFundation-dzjqiskjttzspjcrncvbbssnqtok/</span>Build<span class="regexp">/Products/</span>Debug-iphonesimulator<span class="regexp">/IDLFundationTest.app/I</span>DLFundationTest</span><br><span class="line"># Arch: x86_64</span><br></pre></td></tr></table></figure>

<p><strong><strong>类表</strong></strong>: 保存了所有用到的类生成的.o文件.<br>这个类表用于在后续类方法，类名查看等用到，后续方括号里面的数字就是对应的类序号。</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Object files:</span></span><br><span class="line">[  <span class="number">0</span>] linker synthesized</span><br><span class="line">[  <span class="number">1</span>] dtrace</span><br><span class="line">[  <span class="number">2</span>] <span class="regexp">/Users/</span>huya<span class="regexp">/Library/</span>Developer<span class="regexp">/Xcode/</span>DerivedData<span class="regexp">/IDLFundation-dzjqiskjttzspjcrncvbbssnqtok/</span>Build<span class="regexp">/Intermediates.noindex/</span>IDLFundation.build<span class="regexp">/Debug-iphonesimulator/</span>IDLFundationTest.build<span class="regexp">/Objects-normal/</span>x86_64/AFURLSessionManager.o</span><br></pre></td></tr></table></figure>

<p><strong><strong>段表</strong></strong>: 描述了不同功能的数据保存的地址，通过这个地址就可以查到对应内存里存储的是什么数据。其中第一列是起始地址，第二列是段占用的大小，第三个是段类型，第四列是段名称。</p>
<figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line"><span class="meta"># Sections:</span></span><br><span class="line"><span class="meta"># Address	Size    	Segment	Section</span></span><br><span class="line"><span class="number">0</span>x100001DC0	<span class="number">0</span>x00A38B42	<span class="variable">__TEXT</span>	<span class="variable">__text</span></span><br><span class="line"><span class="number">0</span>x100A3A902	<span class="number">0</span>x00001C9E	<span class="variable">__TEXT</span>	<span class="variable">__stubs</span></span><br><span class="line"><span class="number">0</span>x100A3C5A0	<span class="number">0</span>x0000204A	<span class="variable">__TEXT</span>	<span class="variable">__stub_helper</span></span><br><span class="line"><span class="number">0</span>x100A3E5EC	<span class="number">0</span>x000231B0	<span class="variable">__TEXT</span>	<span class="variable">__gcc_except_tab</span></span><br><span class="line"><span class="number">0</span>x100A617A0	<span class="number">0</span>x000178D0	<span class="variable">__TEXT</span>	<span class="variable">__const</span></span><br><span class="line"><span class="number">0</span>x100A79070	<span class="number">0</span>x0008A5DA	<span class="variable">__TEXT</span>	<span class="variable">__cstring</span></span><br><span class="line"><span class="number">0</span>x100B0364A	<span class="number">0</span>x0005F462	<span class="variable">__TEXT</span>	<span class="variable">__objc_methname</span></span><br><span class="line"><span class="number">0</span>x100B62AAC	<span class="number">0</span>x00008794	<span class="variable">__TEXT</span>	<span class="variable">__objc_classname</span></span><br><span class="line"><span class="number">0</span>x100B6B240	<span class="number">0</span>x0003B4EB	<span class="variable">__TEXT</span>	<span class="variable">__objc_methtype</span></span><br><span class="line"><span class="number">0</span>x100BA672C	<span class="number">0</span>x00001742	<span class="variable">__TEXT</span>	<span class="variable">__ustring</span></span><br><span class="line"><span class="number">0</span>x100BA7E6E	<span class="number">0</span>x00000172	<span class="variable">__TEXT</span>	<span class="variable">__entitlements</span></span><br><span class="line"><span class="number">0</span>x100BA7FE0	<span class="number">0</span>x0000037B	<span class="variable">__TEXT</span>	<span class="variable">__dof_RACSignal</span></span><br><span class="line"><span class="number">0</span>x100BA835B	<span class="number">0</span>x000002E8	<span class="variable">__TEXT</span>	<span class="variable">__dof_RACCompou</span></span><br><span class="line"><span class="number">0</span>x100BA8644	<span class="number">0</span>x00012964	<span class="variable">__TEXT</span>	<span class="variable">__unwind_info</span></span><br><span class="line"><span class="number">0</span>x100BBAFA8	<span class="number">0</span>x00000058	<span class="variable">__TEXT</span>	<span class="variable">__eh_frame</span></span><br><span class="line"><span class="number">0</span>x100BBB000	<span class="number">0</span>x00000008	<span class="variable">__DATA</span>	<span class="variable">__nl_symbol_ptr</span></span><br><span class="line"><span class="number">0</span>x100BBB008	<span class="number">0</span>x00000BD8	<span class="variable">__DATA</span>	<span class="variable">__got</span></span><br><span class="line"><span class="number">0</span>x100BBBBE0	<span class="number">0</span>x00002628	<span class="variable">__DATA</span>	<span class="variable">__la_symbol_ptr</span></span><br><span class="line"><span class="number">0</span>x100BBE208	<span class="number">0</span>x00000070	<span class="variable">__DATA</span>	<span class="variable">__mod_init_func</span></span><br><span class="line"><span class="number">0</span>x100BBE280	<span class="number">0</span>x0001CEE0	<span class="variable">__DATA</span>	<span class="variable">__const</span></span><br><span class="line"><span class="number">0</span>x100BDB160	<span class="number">0</span>x00039CA0	<span class="variable">__DATA</span>	<span class="variable">__cfstring</span></span><br><span class="line"><span class="number">0</span>x100C14E00	<span class="number">0</span>x00002B00	<span class="variable">__DATA</span>	<span class="variable">__objc_classlist</span></span><br><span class="line"><span class="number">0</span>x100C17900	<span class="number">0</span>x000000A0	<span class="variable">__DATA</span>	<span class="variable">__objc_nlclslist</span></span><br><span class="line"><span class="number">0</span>x100C179A0	<span class="number">0</span>x00000680	<span class="variable">__DATA</span>	<span class="variable">__objc_catlist</span></span><br><span class="line"><span class="number">0</span>x100C18020	<span class="number">0</span>x000000D0	<span class="variable">__DATA</span>	<span class="variable">__objc_nlcatlist</span></span><br><span class="line"><span class="number">0</span>x100C180F0	<span class="number">0</span>x00000638	<span class="variable">__DATA</span>	<span class="variable">__objc_protolist</span></span><br><span class="line"><span class="number">0</span>x100C18728	<span class="number">0</span>x00000008	<span class="variable">__DATA</span>	<span class="variable">__objc_imageinfo</span></span><br><span class="line"><span class="number">0</span>x100C18730	<span class="number">0</span>x001252F8	<span class="variable">__DATA</span>	<span class="variable">__objc_const</span></span><br><span class="line"><span class="number">0</span>x100D3DA28	<span class="number">0</span>x000150B0	<span class="variable">__DATA</span>	<span class="variable">__objc_selrefs</span></span><br><span class="line"><span class="number">0</span>x100D52AD8	<span class="number">0</span>x00000150	<span class="variable">__DATA</span>	<span class="variable">__objc_protorefs</span></span><br><span class="line"><span class="number">0</span>x100D52C28	<span class="number">0</span>x00002A38	<span class="variable">__DATA</span>	<span class="variable">__objc_classrefs</span></span><br><span class="line"><span class="number">0</span>x100D55660	<span class="number">0</span>x000019F8	<span class="variable">__DATA</span>	<span class="variable">__objc_superrefs</span></span><br><span class="line"><span class="number">0</span>x100D57058	<span class="number">0</span>x000085E8	<span class="variable">__DATA</span>	<span class="variable">__objc_ivar</span></span><br><span class="line"><span class="number">0</span>x100D5F640	<span class="number">0</span>x0001AE00	<span class="variable">__DATA</span>	<span class="variable">__objc_data</span></span><br><span class="line"><span class="number">0</span>x100D7A440	<span class="number">0</span>x0000CC70	<span class="variable">__DATA</span>	<span class="variable">__data</span></span><br><span class="line"><span class="number">0</span>x100D870B0	<span class="number">0</span>x00004698	<span class="variable">__DATA</span>	<span class="variable">__bss</span></span><br><span class="line"><span class="number">0</span>x100D8B750	<span class="number">0</span>x00001298	<span class="variable">__DATA</span>	<span class="variable">__common</span></span><br></pre></td></tr></table></figure>

<p>下面是一些重要段名的解释：</p>
<p>__TEXT段</p>
<figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>. <span class="variable">__text</span>: 代码节，存放机器编译后的代码</span><br><span class="line"><span class="number">2</span>. <span class="variable">__stubs</span>: 用于辅助做动态链接代码（dyld）.</span><br><span class="line"><span class="number">3</span>. <span class="variable">__stub_helper</span>:用于辅助做动态链接（dyld）.</span><br><span class="line"><span class="number">4</span>. <span class="variable">__objc_methname</span>:objc的方法名称</span><br><span class="line"><span class="number">5</span>. <span class="variable">__cstring</span>:代码运行中包含的字符串常量,比如代码中定义`<span class="meta">#<span class="keyword">define</span> kGeTuiPushAESKey        @<span class="string">&quot;DWE2#@e2!&quot;</span>`,那DWE2#@e2!会存在这个区里。</span></span><br><span class="line"><span class="number">6</span>. <span class="variable">__objc_classname</span>:objc类名</span><br><span class="line"><span class="number">7</span>. <span class="variable">__objc_methtype</span>:objc方法类型</span><br><span class="line"><span class="number">8</span>. <span class="variable">__ustring</span>:</span><br><span class="line"><span class="number">9</span>. <span class="variable">__gcc_except_tab</span>:</span><br><span class="line"><span class="number">10</span>. <span class="variable">__const</span>:存储const修饰的常量</span><br><span class="line"><span class="number">11</span>. <span class="variable">__dof_RACSignal</span>:</span><br><span class="line"><span class="number">12</span>. <span class="variable">__dof_RACCompou</span>:</span><br><span class="line"><span class="number">13</span>. <span class="variable">__unwind_info</span>:</span><br></pre></td></tr></table></figure>

<p>__DATA段</p>
<figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>. <span class="variable">__got</span>:存储引用符号的实际地址，类似于动态符号表</span><br><span class="line"><span class="number">2</span>. <span class="variable">__la_symbol_ptr</span>:lazy symbol pointers。懒加载的函数指针地址。和<span class="variable">__stubs</span>和stub_helper配合使用。具体原理暂留。</span><br><span class="line"><span class="number">3</span>. <span class="variable">__mod_init_func</span>:模块初始化的方法。</span><br><span class="line"><span class="number">4</span>. <span class="variable">__const</span>:存储constant常量的数据。比如使用extern导出的const修饰的常量。</span><br><span class="line"><span class="number">5</span>. <span class="variable">__cfstring</span>:使用Core Foundation字符串</span><br><span class="line"><span class="number">6</span>. <span class="variable">__objc_classlist</span>:objc类列表,保存类信息，映射了<span class="variable">__objc_data</span>的地址</span><br><span class="line"><span class="number">7</span>. <span class="variable">__objc_nlclslist</span>:Objective-C 的 +<span class="built_in">load</span> 函数列表，比 <span class="variable">__mod_init_func</span> 更早执行。</span><br><span class="line"><span class="number">8</span>. <span class="variable">__objc_catlist</span>: categories</span><br><span class="line"><span class="number">9</span>. <span class="variable">__objc_nlcatlist</span>:Objective-C 的categories的 +<span class="built_in">load</span>函数列表。</span><br><span class="line"><span class="number">10</span>. <span class="variable">__objc_protolist</span>:objc协议列表</span><br><span class="line"><span class="number">11</span>. <span class="variable">__objc_imageinfo</span>:objc镜像信息</span><br><span class="line"><span class="number">12</span>. <span class="variable">__objc_const</span>:objc常量。保存objc_classdata结构体数据。用于映射类相关数据的地址，比如类名，方法名等。</span><br><span class="line"><span class="number">13</span>. <span class="variable">__objc_selrefs</span>:引用到的objc方法</span><br><span class="line"><span class="number">14</span>. <span class="variable">__objc_protorefs</span>:引用到的objc协议</span><br><span class="line"><span class="number">15</span>. <span class="variable">__objc_classrefs</span>:引用到的objc类</span><br><span class="line"><span class="number">16</span>. <span class="variable">__objc_superrefs</span>:objc超类引用</span><br><span class="line"><span class="number">17</span>. <span class="variable">__objc_ivar</span>:objc ivar指针,存储属性。</span><br><span class="line"><span class="number">18</span>. <span class="variable">__objc_data</span>:objc的数据。用于保存类需要的数据。最主要的内容是映射<span class="variable">__objc_const</span>地址，用于找到类的相关数据。</span><br><span class="line"><span class="number">19</span>. <span class="variable">__data</span>:暂时没理解，从日志看存放了协议和一些固定了地址（已经初始化）的静态量。</span><br><span class="line"><span class="number">20</span>. <span class="variable">__bss</span>:存储未初始化的静态量。比如：`static NSThread *<span class="variable">_networkRequestThread</span> = <span class="literal">nil</span>;`其中这里面的<span class="built_in">size</span>表示应用运行占用的内存，不是实际的占用空间。所以计算大小的时候应该去掉这部分数据。</span><br><span class="line"><span class="number">21</span>. <span class="variable">__common</span>:存储导出的全局的数据。类似于static，但是没有用static修饰。比如KSCrash里面`NSDictionary* g_registerOrders;`, g_registerOrders就存储在<span class="variable">__common</span>里面</span><br></pre></td></tr></table></figure>

<p><strong><strong>Symbols 字段</strong></strong>：</p>
<p>Symbols简单来说就是类名，变量名，方法名，这个在Crash信息中很常见：</p>
<p>代码节点</p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line"># Symbols:</span><br><span class="line"># Address	Size    	File  Name</span><br><span class="line"><span class="number">0</span>x100001DC0	<span class="number">0</span>x<span class="number">000007D0</span>	[  <span class="number">2</span>] -[AFURLSessionManagerTaskDelegate initWithTask:]</span><br><span class="line"><span class="number">0x100002590</span>	<span class="number">0x00000040</span>	[  <span class="number">2</span>] ___48-[AFURLSessionManagerTaskDelegate initWithTask:]_block_invoke</span><br><span class="line"><span class="number">0</span>x<span class="number">1000025D0</span>	<span class="number">0x00000030</span>	[  <span class="number">2</span>] ___copy_helper_block_e8_32w</span><br><span class="line"><span class="number">0x100002600</span>	<span class="number">0x00000020</span>	[  <span class="number">2</span>] ___destroy_helper_block_e8_32w</span><br></pre></td></tr></table></figure>

<ul>
<li>第一列是起始地址位置</li>
<li>第二列是大小，通过这个可以算出方法占用的大小</li>
<li>第三列是归属的类（.o文件)</li>
</ul>
<p>方法名节点</p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span>x100B0364A	<span class="number">0x00000005</span>	[  <span class="number">2</span>] literal string: init</span><br><span class="line"><span class="number">0</span>x100B0364F	<span class="number">0x00000005</span>	[  <span class="number">2</span>] literal string: data</span><br><span class="line"><span class="number">0x100B03654</span>	<span class="number">0x00000019</span>	[  <span class="number">2</span>] literal string: initWithParent:userInfo:</span><br><span class="line"><span class="number">0</span>x100B0366D	<span class="number">0x00000018</span>	[  <span class="number">2</span>] literal string: arrayWithObjects:count:</span><br><span class="line"><span class="number">0x100B03685</span>	<span class="number">0</span>x0000002B	[  <span class="number">2</span>] literal string: countByEnumeratingWithState:objects:count:</span><br><span class="line"><span class="number">0</span>x<span class="number">100B036B0</span>	<span class="number">0x00000013</span>	[  <span class="number">2</span>] literal string: setTotalUnitCount:</span><br><span class="line"><span class="number">0</span>x<span class="number">100B036C3</span>	<span class="number">0x00000010</span>	[  <span class="number">2</span>] literal string: setCancellable:</span><br><span class="line"><span class="number">0</span>x<span class="number">100B036D3</span>	<span class="number">0x00000007</span>	[  <span class="number">2</span>] literal string: cancel</span><br><span class="line"><span class="number">0</span>x100B036DA	<span class="number">0x00000018</span>	[  <span class="number">2</span>] literal string: setCancellationHandler:</span><br><span class="line"><span class="number">0</span>x<span class="number">100B036F2</span>	<span class="number">0</span>x0000000D	[  <span class="number">2</span>] literal string: setPausable:</span><br><span class="line"><span class="number">0</span>x100B036FF	<span class="number">0x00000008</span>	[  <span class="number">2</span>] literal string: suspend</span><br><span class="line"><span class="number">0x100B03707</span>	<span class="number">0x00000013</span>	[  <span class="number">2</span>] literal string: setPausingHandler:</span><br><span class="line"><span class="number">0</span>x100B0371A	<span class="number">0x00000007</span>	[  <span class="number">2</span>] literal string: resume</span><br><span class="line"><span class="number">0x100B03721</span>	<span class="number">0x00000014</span>	[  <span class="number">2</span>] literal string: setResumingHandler:</span><br></pre></td></tr></table></figure>

<p><strong><strong>类列表节点</strong></strong></p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line"><span class="number">0x100C14E00</span>	<span class="number">0x00000018</span>	[  <span class="number">2</span>] anon</span><br><span class="line"><span class="number">0x100C14E18</span>	<span class="number">0x00000008</span>	[  <span class="number">3</span>] anon</span><br><span class="line"><span class="number">0x100C14E20</span>	<span class="number">0x00000008</span>	[  <span class="number">4</span>] anon</span><br><span class="line"><span class="number">0x100C14E28</span>	<span class="number">0x00000008</span>	[  <span class="number">5</span>] anon</span><br><span class="line"><span class="number">0x100C14E30</span>	<span class="number">0x00000008</span>	[  <span class="number">6</span>] anon</span><br><span class="line"><span class="number">0x100C14E38</span>	<span class="number">0x00000008</span>	[  <span class="number">7</span>] anon</span><br><span class="line"><span class="number">0x100C14E40</span>	<span class="number">0x00000008</span>	[  <span class="number">9</span>] anon</span><br><span class="line"><span class="number">0x100C14E48</span>	<span class="number">0x00000010</span>	[ <span class="number">10</span>] anon</span><br></pre></td></tr></table></figure>

<p>第一次看这个的时候会比较迷惑到底到哪里找某个数据，其实Sections字段是整个linkMap的目录，通过它的起始地址就可以找到对应区段的位置，所以我们需要做的就是明确各个Session的意义。</p>
<p>通过linkMap找到无用代码的过程大致思路如下：</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="bullet">* </span>找到类和方法的全集</span><br><span class="line"><span class="bullet">* </span>找到使用过的类和方法集合</span><br><span class="line"><span class="bullet">* </span>取2者差集得到无用代码集合</span><br></pre></td></tr></table></figure>

<p>Objective-C 中的方法都会通过 objc_msgSend 来调用，而 objc_msgSend 在 Mach-O 文件里是通过_objc_selrefs 这个 section 来获取 selector 这个参数的。所以，_objc_selrefs 里的方法一定是被调用了的。_objc_classrefs 里是被调用过的类， objc_superrefs 是调用过 super 的类（继承关系）。通过 _objc_classrefs 和 _objc_superrefs,我们就可以找出使用过的类和子类。</p>
<p>Mach-O 文件中的_objc_selrefs、_objc_classrefs、_objc_superrefs 可以通过<a target="_blank" rel="noopener" href="https://github.com/fangshufeng/MachOView">MachOView</a>进行查看。</p>
<p>除了使用linkMap外还可以使用<a target="_blank" rel="noopener" href="https://www.unix.com/man-page/osx/1/otool/">otool</a>，它不需要额外安装，只要你安装了XCode它就顺带安装了Otool。</p>
<p>这里大家可以结合Mach-O文件来了解整个用法，遇到不明白的可以通过otool来输出help信息：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">Usage: /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/otool [-arch arch_type] [-fahlLDtdorSTMRIHGvVcXmqQjCP] [<span class="attribute">-mcpu</span>=arg] [--version] &lt;object file&gt; <span class="built_in">..</span>.</span><br><span class="line">	-f <span class="built_in">print</span> the fat headers</span><br><span class="line">	-a <span class="built_in">print</span> the archive header</span><br><span class="line">	-h <span class="built_in">print</span> the mach header</span><br><span class="line">	-l <span class="built_in">print</span> the load commands</span><br><span class="line">	-L <span class="built_in">print</span> shared libraries used</span><br><span class="line">	-D <span class="built_in">print</span> shared library id name</span><br><span class="line">	-t <span class="built_in">print</span> the text section (disassemble with -v)</span><br><span class="line">	-x <span class="built_in">print</span> all text sections (disassemble with -v)</span><br><span class="line">	-p &lt;routine name&gt;  start dissassemble <span class="keyword">from</span> routine name</span><br><span class="line">	-s &lt;segname&gt; &lt;sectname&gt; <span class="built_in">print</span> contents of section</span><br><span class="line">	-d <span class="built_in">print</span> the data section</span><br><span class="line">	-o <span class="built_in">print</span> the Objective-C segment</span><br><span class="line">	-r <span class="built_in">print</span> the relocation entries</span><br><span class="line">	-S <span class="built_in">print</span> the table of contents of a library (obsolete)</span><br><span class="line">	-T <span class="built_in">print</span> the table of contents of a dynamic shared library (obsolete)</span><br><span class="line">	-M <span class="built_in">print</span> the module table of a dynamic shared library (obsolete)</span><br><span class="line">	-R <span class="built_in">print</span> the reference table of a dynamic shared library (obsolete)</span><br><span class="line">	-I <span class="built_in">print</span> the indirect symbol table</span><br><span class="line">	-H <span class="built_in">print</span> the two-level hints table (obsolete)</span><br><span class="line">	-G <span class="built_in">print</span> the data <span class="keyword">in</span> code table</span><br><span class="line">	-v <span class="built_in">print</span> verbosely (symbolically) when possible</span><br><span class="line">	-V <span class="built_in">print</span> disassembled operands symbolically</span><br><span class="line">	-c <span class="built_in">print</span> argument strings of a core file</span><br><span class="line">	-X <span class="built_in">print</span> <span class="literal">no</span> leading addresses <span class="keyword">or</span> headers</span><br><span class="line">	-m don<span class="string">&#x27;t use archive(member) syntax</span></span><br><span class="line"><span class="string">	-B force Thumb disassembly (ARM objects only)</span></span><br><span class="line"><span class="string">	-q use llvm&#x27;</span>s disassembler (the default)</span><br><span class="line">	-Q use otool(1)<span class="string">&#x27;s disassembler</span></span><br><span class="line"><span class="string">	-mcpu=arg use `arg&#x27;</span> as the cpu <span class="keyword">for</span> disassembly</span><br><span class="line">	-j <span class="built_in">print</span> opcode bytes</span><br><span class="line">	-P <span class="built_in">print</span> the <span class="built_in">info</span> plist section as strings</span><br><span class="line">	-C <span class="built_in">print</span> linker optimization hints</span><br><span class="line">	--version <span class="built_in">print</span> the version of /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/otool</span><br></pre></td></tr></table></figure>
<p>关于Mach-O大家可以查看之前的博客或者<a target="_blank" rel="noopener" href="https://www.desgard.com/iosre-1/#">Mach-O 文件格式探索</a>这篇博客。</p>
<p><strong><strong>3.无用第三方库清理</strong></strong></p>
<p><strong><strong>4.通过 AppCode 查找无用代码</strong></strong></p>
<p>可以借助AppCode提供的Inspect Code来诊断代码，通过它可以查找无用代码的功能。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Unused <span class="keyword">class</span> 无用类</span><br><span class="line"><span class="symbol">Unused</span> <span class="symbol">import</span> <span class="symbol">statement</span> 无用类引入声明</span><br><span class="line"><span class="symbol">Unused</span> <span class="symbol">property</span> 无用的属性</span><br><span class="line"><span class="symbol">Unused</span> <span class="symbol">method</span> 无用的方法</span><br><span class="line"><span class="symbol">Unused</span> <span class="symbol">parameter</span> 无用参数</span><br><span class="line"><span class="symbol">Unused</span> <span class="symbol">instance</span> <span class="symbol">variable</span> 无用的实例变量</span><br><span class="line"><span class="symbol">Unused</span> <span class="symbol">local</span> <span class="symbol">variable</span> 无用的局部变量</span><br><span class="line"><span class="symbol">Unused</span> <span class="symbol">value</span> 无用的值；</span><br><span class="line"><span class="symbol">Unused</span> <span class="symbol">macro</span> 无用的宏。</span><br><span class="line"><span class="symbol">Unused</span> <span class="symbol">global</span> <span class="symbol">declaration</span> 无用全局声明</span><br></pre></td></tr></table></figure>

<p><strong><strong>5.静态库瘦身</strong></strong></p>
<p>对于静态库可以通过lipo 工具来瘦身。</p>
<ul>
<li>静态库指令集信息查看：</li>
</ul>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">lipo</span> -<span class="literal">info</span> libXXXX.a</span><br></pre></td></tr></table></figure>

<ul>
<li>静态库拆分合并</li>
</ul>
<figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line">静态库拆分：lipo 静态库文件路径 -thin CPU架构 -<span class="keyword">output</span> 拆分后的静态库文件路径</span><br><span class="line">静态库合并：lipo -<span class="keyword">create</span> 静态库<span class="number">1</span>文件路径 静态库<span class="number">2</span>文件路径... 静态库n文件路径 -<span class="keyword">output</span> 合并后的静态库文件径</span><br></pre></td></tr></table></figure>

<p>举个例子：</p>
<p>首先我们通过lipo -info 查看libWeiboSDK.a支持的架构类型：</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">lipo</span> -<span class="meta">info</span> libWeiboSDK.a</span><br><span class="line"><span class="comment">//Architectures in the fat file: libWeiboSDK.a are: armv7 arm64 i386 x86_64</span></span><br></pre></td></tr></table></figure>

<p>发现它支持armv7 arm64 i386 x86_64，但是我们只需要 armv7 和 arm64，这时候就需要使用lipo拆分出需要的架构下的静态库后再合并：</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">lipo libWeiboSDK.<span class="keyword">a</span> -thin armv7 -output libWeiboSDK-armv7.<span class="keyword">a</span></span><br><span class="line">lipo libWeiboSDK.<span class="keyword">a</span> -thin arm64 -output libWeiboSDK-arm64.<span class="keyword">a</span></span><br><span class="line">lipo <span class="built_in">create</span> libWeiboSDK-armv7.<span class="keyword">a</span> libWeiboSDK-arm64.<span class="keyword">a</span> -output libWeiboSDK.device.<span class="keyword">a</span></span><br></pre></td></tr></table></figure>

<p>通过上面的操作我们将静态库里面支持模拟器的指令集给去掉了，所以模拟器是无法跑的，所以平时可以使用包含模拟器指令集的静态库，在App发布的时候去掉。如果使用 Cocoapods 管理可以使用2份 Podfile 文件。一份包含指令集一份不包含，发布的时候切换 Podfile 文件即可。或者一份 Podfile 文件，但是配置不同的环境设置.</p>
<p><strong><strong>编译选项优化</strong></strong></p>
<ol>
<li><strong><strong>Generate Debug Symbols</strong></strong> 这个开关如果打开的话，信息的详情可以通过“Level of Debug Symbols”项进行配置，如果设置为NO则ipa中不会生成Symbols文件,虽然可以减少ipa大小。但会影响到崩溃的定位。所以不是非必须的情况下，建议还是打开。万不得已的情况下Release版本设置为NO,Debug版本设置为YES.</li>
</ol>
<p>2.在Build Settings中可以指定工程被编译成支持哪些指令集类型，而支持的指令集越多，就会编译出多个指令集代码的数据包，对应生成二进制包就越大，因此可以根据你的产品的目标对象决定是否可以舍弃一些CPU架构，比如armv7用于支持4s和4，但是这部分用户已经很少，所以一般可以考虑舍弃这部分用户。这里可以通过Valid Architectures里面去选择，如果需要去掉更多大家可以根据下表进行对应删剪：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">armv6</span>: iPhone, iPhone <span class="number">3</span>G, iPod <span class="number">1</span>G/<span class="number">2</span>G</span><br><span class="line"><span class="attribute">armv7</span>: iPhone <span class="number">3</span>GS, iPhone <span class="number">4</span>, iPhone <span class="number">4</span>S, iPod <span class="number">3</span>G/<span class="number">4</span>G/<span class="number">5</span>G, iPad, iPad <span class="number">2</span>, iPad <span class="number">3</span>, iPad Mini</span><br><span class="line"><span class="attribute">armv7s</span>: iPhone <span class="number">5</span>, iPhone <span class="number">5</span>c, iPad <span class="number">4</span></span><br><span class="line"><span class="attribute">arm64</span>:  iPhone X，iPhone <span class="number">8</span>(Plus)，iPhone <span class="number">7</span>(Plus)，iPhone <span class="number">6</span>(Plus)，iPhone <span class="number">6</span>s(Plus), iPhone <span class="number">5</span>s, iPad Air(<span class="number">2</span>), Retina iPad Mini(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="attribute">arm64e</span>: iPhone XS\XR\XS Max</span><br></pre></td></tr></table></figure>

<p>下面顺带介绍下Architectures编译选项：<br><strong><strong>Architectures</strong></strong><br>指定工程被编译成支持哪些指令集类型,默认的情况这里的值为:</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><span class="line">Standard architectures- $(ARCHS-STANDARD)</span><br></pre></td></tr></table></figure>
<p>ARCHS-STANDARD具体的值可以查看：</p>
<p><img src="/2019/09/02/iOS-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/000111.png"></p>
<p><strong><strong>Valid Architectures</strong></strong></p>
<p>该编译项指定可能支持的指令集，该列表和Architectures列表的交集，将是Xcode最终生成二进制包所支持的指令集。举个例子，比如，你的Valid Architectures设置的支持arm指令集版本有：armv7&#x2F;armv7s&#x2F;arm64，对应的Architectures设置的支持arm指令集版本有：arm64，这时Xcode只会生成一个arm64指令集的二进制包。</p>
<p><strong><strong>Build Active Architecture Only</strong></strong><br>指明是否只编译当前连接设备所支持的指令集。默认Debug的时候设置为YES，Release的时候设置为NO。设置为YES是只编译当前的architecture版本，生成的包只包含当前连接设备的指令集代码。设置为NO，则生成的包包含所有的指令集代码（上面的Valid Architectures跟Architectures的交集）。因此为了调试速度更快，则Debug应该设置为YES。</p>
<p><strong><strong>3.Dead Code Stripping</strong></strong></p>
<p>查看 DEAD_CODE_STRIPPING 是否为 YES。设置为YES静态链接的可执行文件中未引用的代码将会被删除。实际上Xcode 默认会开启此选项，C&#x2F;C++&#x2F;Swift 等静态语言编译器会在 link 的时候移除未使用的代码，但是对于 Objective-C 等动态语言是无效的。因为 Objective-C 是建立在运行时上面的，底层暴露给编译器的都是 Runtime 源码编译结果，所有的部分都是会被判别为有效代码。</p>
<p><strong><strong>4.Compress PNG Files</strong></strong> 打包的时候自动对图片进行无损压缩，使用的工具为 pngcrush</p>
<p><strong><strong>5.Remove Text Medadata From PNG Files</strong></strong> 移除 PNG 资源的文本字符，比如图像名称、作者、版权、创作时间、注释等信息。</p>
<p><strong><strong>6.将Asset Catalog Compiler optimization</strong></strong> 选项设置为 space </p>
<p><strong><strong>7.Apple Clang - Code Generation</strong></strong></p>
<p>该选项下的Optimization Level 编译参数决定了程序在编译过程的编译速度以及编译后的可执行文件占用的内存以及编译之后可执行文件运行时候的速度。它有六个级别：</p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">None<span class="comment">[-O0]</span>: Debug 默认级别。不进行任何优化，直接将源代码编译到执行文件中，结果不进行任何重排，编译时比较长。主要用于调试程序，可以进行设置断点,改变变量,计算表达式等调试工作。</span><br><span class="line"></span><br><span class="line">Fast<span class="comment">[-O,O1]</span>。最常用的优化级别，不考虑速度和文件大小权衡问题。与-O0级别相比，它生成的文件更小，可执行的速度更快，编译时间更少。</span><br><span class="line"></span><br><span class="line">Faster<span class="comment">[-O2]</span>。在-O1级别基础上再进行优化，增加指令调度的优化。与-O1级别相，它生成的文件大小没有变大，编译时间变长了，编译期间占用的内存更多了，但程序的运行速度有所提高。</span><br><span class="line"></span><br><span class="line">Fastest<span class="comment">[-O3]</span>。在-O2和-O1级别上进行优化，该级别可能会提高程序的运行速度，但是也会增加文件的大小。</span><br><span class="line"></span><br><span class="line">Fastest Smallest<span class="comment">[-Os]</span>。Release 默认级别。这种级别用于在有限的内存和磁盘空间下生成尽可能小的文件。由于使用了很好的缓存技术，它在某些情况下也会有很快的运行速度。</span><br><span class="line"></span><br><span class="line">Fastest, Aggressive Optimization<span class="comment">[-Ofast]</span>。 它是一种更为激进的编译参数, 它以点浮点数的精度为代价。</span><br></pre></td></tr></table></figure>
<p>默认情况下Debug 设定为 None[-O0] ，Release 设定为 Fastest,Smallest[-Os],所以这里一般会采用默认的设置。这个选项会开启那些不增加代码大小的全部优化，让可执行文件尽可能小</p>
<p><strong><strong>8.Swift Compiler - Code Generation</strong></strong></p>
<p>这个主要是针对Swift语言进行的优化，它有三个级别：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">No optimization<span class="selector-attr">[-Onone]</span>：不进行优化，能保证较快的编译速度。</span><br><span class="line">Optimize for Speed<span class="selector-attr">[-O]</span>：编译器将会对代码的执行效率进行优化，一定程度上会增加包大小。</span><br><span class="line">Optimize for Size<span class="selector-attr">[-Osize]</span>：编译器会尽可能减少包的大小并且最小限度影响代码的执行效率。</span><br></pre></td></tr></table></figure>
<p>关于这些选项的选择可以参考官方的说明：</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">We have seen <span class="keyword">that</span> using -Osize reduces code size <span class="keyword">from</span> <span class="number">5</span>% <span class="keyword">to</span> even <span class="number">30</span>% <span class="keyword">for</span> <span class="keyword">some</span> projects.</span><br><span class="line">But what <span class="keyword">about</span> performance? This completely depends <span class="keyword">on</span> <span class="keyword">the</span> project. For most applications <span class="keyword">the</span> performance hit <span class="keyword">with</span> -Osize will be negligible, i.e. <span class="keyword">below</span> <span class="number">5</span>%. But <span class="keyword">for</span> performance sensitive code -O might still be <span class="keyword">the</span> better choice.</span><br></pre></td></tr></table></figure>
<p>所以如果你的项目对运行速度不是特别敏感，并且可以接受轻微的性能损失，那么 -Osize 是首选，否则建议使用-O</p>
<p><strong><strong>9.Exceptions</strong></strong></p>
<p>可以通过设置Enable C++ Exceptions 和 Enable Objective-C Exceptions 为 NO,并且Other C Flags添加-fno-exceptions 可以去掉异常支持从而减少可行性文件的大小，但是除非非常必要的情况下，这个一般保持打开。</p>
<p><strong><strong>10.Link-Time Optimization</strong></strong></p>
<p>在Link中间代码时，对全局代码进行优化。这个优化是自动完成的，因此不需要修改现有的代码。这项优化主要包括：</p>
<figure class="highlight sas"><table><tr><td class="code"><pre><span class="line">去除多余代码：如果一段代码分布在多个文件中，但是从来没有被使用，普通的 -O3 优化方法不能发现跨中间代码文件的多余代码，因此是一个“局部优化”。但是<span class="keyword">Link</span>-Time Optimization 技术可以在 <span class="keyword">link</span> 时发现跨中间代码文件的多余代码。</span><br><span class="line"></span><br><span class="line">跨过程优化：这是一个相对广泛的概念。举个例子来说，如果一个 <span class="keyword">if</span> 方法的某个分支永不可能执行，那么在最后生成的二进制文件中就不应该有这个分支的代码。</span><br><span class="line"></span><br><span class="line">内联优化：内联优化形象来说，就是在汇编中不使用 “<span class="keyword">call</span> func_name” 语句，直接将外部方法内的语句“复制”到调用者的代码段内。这样做的好处是不用进行调用函数前的压栈、调用函数后的出栈操作，提高运行效率与栈空间利用率。</span><br></pre></td></tr></table></figure>

<p>开启这个优化后，一方面会减少了汇编代码的体积，另一方面还会提高了代码的运行效率，所以建议在项目中开启该优化，并设置为优化方式 Incremental。</p>
<p><strong><strong>11.Framework动态库包空间瘦身</strong></strong><br>Framework 文件夹存放的是动态库。这部分内容会在启动的时候被链接和加载，这里面主要放的是我们引入的其他依赖库，但是需要注意的一点是，如果我们项目中打开了Swift 混编的情况下会多出Swift 标准库，这部分的占用大概在7-8M左右。所以出于这方面考虑，如果非必要的情况下建议只使用Objective-C 开发。目前大多数大项目都采用这种模式。</p>
<p>Swift 标准库和自己引入的其他依赖库</p>
<p><strong><strong>App Thinning技术</strong></strong></p>
<p><a target="_blank" rel="noopener" href="https://developer.apple.com/videos/play/wwdc2015/404/">App Thinning</a> 技术是 iOS9引入的它主要用于解决目前某些地区国家流量费用过高、iOS设备的存储空间有限的问题，但是实际上也是从应用瘦身的角度出发去进行改善。所以也顺带在这里介绍了。iOS 9之前的版本要求用户下载整个app文件，即使用户使用的是iPhone也需要下载他们绝不会使用到的ipad图像文件，这主要出于能够更好得适配各种不同的应用角度出发，但是App Thinning 技术的引进改善了这个问题，App Thinning会自动检测用户的设备类型并且只下载当前设备所适用的内容。</p>
<p>App Thinning 技术主要包括三大方面：App Slicing，Bitcode。</p>
<p><img src="/2019/09/02/iOS-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/00000123.jpg"></p>
<ul>
<li><strong><strong>App Slicing</strong></strong></li>
</ul>
<p><img src="/2019/09/02/iOS-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/0001123.png"></p>
<p><img src="/2019/09/02/iOS-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/0101010.png"></p>
<p>当开发者向App Store Connect 上传 .ipa 后，App Store Connect 构建过程中，会自动分割该 App，创建特定的变体,以适配不同设备。然后用户从 App Store 中下载到的安装包，即这个特定的变体。也就是说App Slicing仅向设备传送与之相关的资源（图片，指令架构相关），需要注意的是：App Slicing对于图片资源的划分，需要要求图片放在 Asset Catalog 中管理，Bundle 内的则还是会同时包含。</p>
<ul>
<li><strong><strong>On Demand Resources</strong></strong></li>
</ul>
<p>On Demand Resources 所管理的资源是托管在 App Store 和 app相关的Bundle包分开下载，这部分资源由操作系统负责下载和存储。它可以是bundle所支持文件类型除了可执行文件以外的任何文件。按需加载资源的总计大小不能超过20GB。它的大小不算在app bundle的大小中。</p>
<p>按需加载资源主要可以带来以下的几种好处：</p>
<blockquote>
<ul>
<li><strong><strong>初始资源的延迟加载:</strong></strong> app有一些资源是主要功能要用到的，但在启动时并不需要。将这些资源标记为“初始需要”。操作系统在app启动时会自动下载这些资源。例如，图片编辑app有许多不常用的滤镜。</li>
<li><strong><strong>app资源的延迟加载:</strong></strong> app有一些只在特定情景下使用的资源，当应用可能要进入这些场景时，会请求这些资源。例如，在一个有很多关卡的游戏中，用户只需要当前关卡和下一关卡的资源。 </li>
<li><strong><strong>不常用资源的远程存储:</strong></strong> app有一些很少使用的资源，当需要这些资源时会去请求它们。例如，当app第一次打开时会展示一个教程，而这个教程之后就可能不会在用到。app在第一次启动时请求教程的资源，这之后只在需要展示教程或者添加了新功能才去请求该资源。</li>
<li><strong><strong>应用内购买资源的远程存储:</strong></strong> app提供包含额外资源的应用内购买。app会在启动完成后请求已购买模块的资源。例如，用户在一个键盘app内购买了SuperGeeky表情包。应用程序会在启动完成后请求表情包的资源。</li>
<li><strong><strong>第一次启动时必需资源的加载:</strong></strong> app有一些资源只在第一次启动时需要，之后的启动不再需要。例如，app有一个只在第一次启动时展示的教程。</li>
</ul>
</blockquote>
<p>我们在开发的时候需要给按需加载资源分配一个字符串标识符tag来区分这些资源在我们的应用中是如何使用的。在运行的时候，通过指定tag来请求访问远程资源。操作系统会下载和这个tag关联的所有资源，然后保留在存储中，直到app不再使用它们。当操作系统需要更多的存储空间，它会清理一个或多个不再使用的tag关联的资源。tag关联的资源在被清理之前可能会在设备中保存一段时间。<br>我们可以为tag设置保存优先级来影响清理的顺序。</p>
<p>On Demand Resources 主要可以分成三类：</p>
<ul>
<li><p><strong><strong>Initial install tags:</strong></strong> 只有在初始安装tag下载到设备后，app才能启动。这些资源会在下载app时一起下载。这部分资源的大小会包括在App Store中app的安装包大小。如果这些资源从来没有被NSBundleResourceRequest对象获取过，就有可能被清理掉。</p>
</li>
<li><p><strong><strong>Prefetch tag order:</strong></strong> 在app安装后会开始下载tag。tag会按照此处指定的顺序来下载。 </p>
</li>
<li><p><strong><strong>Dowloaded only on demand:</strong></strong> 当app请求一个tag，且tag没有缓存时，才会下载该tag</p>
</li>
</ul>
<p><img src="/2019/09/02/iOS-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/999999.png"></p>
<p>开启关闭On Demand Resources</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">在<span class="keyword">project</span> navigator中选择工程文件。</span><br><span class="line">在<span class="keyword">project</span> editor中选择对应的<span class="keyword">target</span>。</span><br><span class="line">选择Build Settings选项卡。</span><br><span class="line">展开Assets分类。</span><br><span class="line">设置Enable <span class="keyword">On</span>-Demand Resources的值。</span><br></pre></td></tr></table></figure>


<p>文章:</p>
<p><a target="_blank" rel="noopener" href="http://www.cocoachina.com/articles/12155">On-Demand Resources Guide中文版 上</a></p>
<p><a target="_blank" rel="noopener" href="http://www.cocoachina.com/articles/12152">On-Demand Resources Guide中文版 下</a></p>
<p>视频:   </p>
<iframe width="1206" height="678" src="https://www.youtube.com/embed/B5RV8p4-9a8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen>
</iframe>


<ul>
<li><em><strong>Bitcode</strong></em></li>
</ul>
<p>Bitcode是一种程序中间码。包含Bitcode配置的程序将会在App Store Connect上被重新编译和链接，进而对可执行文件做优化。这部分都是在苹果服务端自动完成的，所以即使后续Apple推出了新的CPU架构或者以后LLVM推出了一系列优化，我们也不再需要为其发布新的安装包，Apple Store 会为我们自动完成这步，然后提供对应的变体给具体设备。</p>
<p>Bitcode开启：</p>
<p><img src="/2019/09/02/iOS-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/000011gg.png"></p>
<p>采用Bitcode之后需要注意两个方面：</p>
<p>(1) 一旦开启Bitcode那么我们依赖的静态库、动态库，都必须包含 Bitcode，另外用 Cocoapods 管理的第三方库，都需要开启 Pods 工程中的 BitCode。否则会编译失败。</p>
<p>可以将下面的配置添加到主Podfile中：</p>
<figure class="highlight coq"><table><tr><td class="code"><pre><span class="line">post_install <span class="built_in">do</span> |<span class="type">installer</span>|</span><br><span class="line">    <span class="type">installer</span>.pods_project.targets.each <span class="built_in">do</span> |<span class="type">target</span>|</span><br><span class="line">        <span class="type">target</span>.build_configurations.each <span class="built_in">do</span> |<span class="type">config</span>|</span><br><span class="line">            <span class="type">config</span>.build_settings[&#x27;ENABLE_BITCODE&#x27;] = &#x27;YES&#x27;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>(2) 开启 Bitcode 后，最终的可执行文件是 Apple 自动生成的，这就会导致我们无法使用自己包生成的 dSYM 符号化文件来进行符号化。这个问题可以在上传到 App Store 时需要勾选 “Include app symbols for your application…” ，勾选之后 Apple 会自动生成对应的 dSYM，然后可以在 Xcode —&gt; Window —&gt; Organizer 中， 或者 Apple Store Connect 中下载对应的 dSYM 来进行符号化：</p>
<p><img src="/2019/09/02/iOS-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/12121212.png"></p>
<p>这里有一篇比较好的文章介绍了对应的技术以及怎样进行测试<a target="_blank" rel="noopener" href="https://www.appcoda.com.tw/app-thinning/">初探iOS 9的 App 瘦身功能</a></p>
<h6 id="3-6-网络优化"><a href="#3-6-网络优化" class="headerlink" title="3.6 网络优化"></a><strong><strong>3.6 网络优化</strong></strong></h6><p>要对网络进行优化需要先了解一次网络请求的流程：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1.</span> 在开始请求某个地址之前，会先进行DNS解析，通过DNS解析获取到对应域名的IP.</span><br><span class="line"><span class="bullet">2.</span> 使用IP与目标服务器建立连接，这里包括tcp三次握手等流程</span><br><span class="line"><span class="bullet">3.</span> 建立完连接后客户端和服务端交换数据</span><br></pre></td></tr></table></figure>

<p>上述的三个阶段都存在可优化的点，我们一一进行介绍：</p>
<p>首先第一个环节，主要的性能损耗在DNS解析这块,DNS解析的缺点如下：</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="bullet">* </span>DNS解析环节主动权在域名解析方，这就导致容易在域名解析方被解析到第三方IP地址，从而遭受域名劫持，运营商劫持，中间人攻击。</span><br><span class="line"><span class="bullet">* </span>DNS解析过程不受我们控制，无法保证解析到的地址是最快的IP.</span><br><span class="line"><span class="bullet">* </span>一次请求只能解析一个域名，容易达到性能瓶颈。</span><br></pre></td></tr></table></figure>

<p>为了解决这些问题，我们可以考虑自己来管理域名与IP的映射关系，也就是我们常说的HTTPDNS。具体的实现可以看<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzAwMDU1MTE1OQ==&mid=209805123&idx=1&sn=ced8d67c3e2cc3ca38ef722949fa21f8">App域名劫持之DNS高可用 - 开源版HttpDNS方案详解</a>，它的主要思想就是通过HTTP请求后台去拿域名,IP映射表，后续的网络请求就可以通过这个映射表来获得对应的IP地址，这样的好处就是不用在DNS解析上耗费时间，并且域名IP的映射关系可控，不会受到劫持，可以确保根据用户所在地返回就近的 IP 地址，或根据客户端测速结果使用速度最快的 IP。</p>
<p>对于第二个环节主要的性能瓶颈点在于连接的建立。这里可以通过复用连接，从而避免每次请求都重新建立连接。HTTP 协议里有个 keep-alive属性，如果开启的情况下请求完成后不立即释放连接，而是放到连接池中，如果这时候另一个请求发出，并且域名和端口是一致的，这时候就直接使用连接池中已有的连接。从而少了建立连接的耗时。</p>
<p>但是keep-alive也是有明显的缺点的就是，keep-alive连接每次都只能发送接收一个请求，在上一个请求处理完成之前，无法接受新的请求，所以如果同时多个请求被发送，就会有两种现象：</p>
<p>如果请求是串行发送的，那么就可以一直复用同一个连接，每个请求都需要等待上一个请求完成后再进行发送。</p>
<p>如果请求是并行发送的，那么从第二次开始可以复用连接池里的连接，这种情况如果对连接池不加限制，会导致连接池中保留的连接过多，对服务端资源将会带来较大的浪费，如果限制那么超过的部分仍然需要重新建立连接。</p>
<p>但是在别无选择的情况下，还是会采取这种方案。</p>
<p>后续HTTP2的推出，采用多路复用来解决需要频繁建立连接的问题。对于Http2的多路复用机制还是通过复用连接，但是它复用的这条连接同时能够支持同时处理多条请求，所有的请求都可以在这条连接上并发进行，它把在连接里传输的数据都封装成一个个stream，每个stream都有标识，stream的发送和接收可以是乱序的，不依赖顺序，也就不会有阻塞的问题，接收端可以根据stream的标识去区分属于哪个请求，再进行数据拼接，得到最终数据。iOS9 以上 NSURLSession 原生支持 HTTP2，只要服务端也支持就可以直接使用。</p>
<p>但是HTTP2还有一个比较大的问题就是TCP队头阻塞，我们知道TCP 协议为了保证数据的可靠性，若传输过程中一个 TCP 包丢失，会等待这个包重传后，才会处理后续的包。在HTTP2中多路复用的情况下，如果中间有一个包丢失，就会阻塞等待重传，进而阻塞所有请求。这个问题是TCP协议本身的问题，为了解决这个问题，Google提出了QUIC 协议，它是在UDP协议之上再定义一套可靠传输协议来解决队头阻塞问题。</p>
<p>除了采用HTTP2多路复用技术外，还可以通过长连接的手段减少网络服务时间，我们知道每次TCP三次握手连接需要耗费客户端和服务端各一个 RTT时间才能完成，就意味着 需要大致100-300 毫秒的延迟；为了克服这个问题可以使用长连接池的方式来使用长连接，长连接池中维护了多个保持和服务端的 TCP连接，每次网络服务发起后会从长连接池中获取一个空闲长连接，完成网络服务后再将该TCP连接放回长连接池。</p>
<p>介绍完DNS环节优化，以及连接建立的优化后，我们看下从数据交换层面上如何进行优化，这方面主要可以优化的点可以分成两部分，一部分在于对数据的压缩率上，一部分在于解压缩，序列化反序列化的速度上，在数据交换格式的选择上对于数据量比较大的情景下可以使用protobuf替换json 格式，protobuf是基于二进制的所以在整体数据量以及序列化速度上都远胜于json 格式在内的其他格式，但是它有一个不足的地方就是数据不直观。在调试定位问题的时候比较难定位。</p>
<p>在进行数据交换之前可以对body数据进行压缩或者加密处理，<a target="_blank" rel="noopener" href="https://facebook.github.io/zstd/">Z-standard</a>是目前压缩率表现最好的算法。它支持多种开发语言。对于Header协议头数据，Http2已经对其进行了压缩处理。具体的压缩技术可以查看<a target="_blank" rel="noopener" href="https://imququ.com/post/header-compression-in-http2.html">HTTP&#x2F;2 头部压缩技术介绍</a></p>
<p>除了一些敏感数据之外，不建议对数据进行加密，因为加解密是比较耗时的，加解密处理会增加整个请求发送和处理的速度，实际上标准协议 TLS 已经能够很好得保证了网络传输的安全，所以除非是十分敏感的数据加密只会加重性能的负担。</p>
<p>除了上述介绍的网络优化外，还可以引入网络服务优先级机制，高优先级服务优先使用长连接，低优先级服务默认使用短连接以及网络服务依赖机制，主服务失败时，子服务自动取消。</p>
<h5 id="4-较好的文章推荐"><a href="#4-较好的文章推荐" class="headerlink" title="4 较好的文章推荐"></a><strong><strong>4 较好的文章推荐</strong></strong></h5><p><a target="_blank" rel="noopener" href="https://github.com/tbfungeek/iOS-Performance-Optimization">iOS Performance Optimization</a></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/iOS-%E8%BF%9B%E9%98%B6/">iOS 进阶</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/iOS-进阶/">iOS 进阶</a>
  </div>

</div>



<div class="comments-count">
	
	  	<span></span>
		<a href="/2019/09/02/iOS-性能优化总结/#comments" class="ds-thread-count comments-count-link" data-thread-key="2019/09/02/iOS-性能优化总结/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/08/31/iOS-上架流程/" title="iOS 上架流程" itemprop="url">iOS 上架流程</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Edgar" target="_blank" itemprop="author">Edgar</a>
		
  <p class="article-time">
    <time datetime="2019-08-30T17:59:40.000Z" itemprop="datePublished"> Published 2019-08-31</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>这篇博客大家的关键点放在上架需要哪些材料上面，具体的步骤大家理解下就可以了，因为官网随时会变更，这篇博客也没办法实时更新，由于我个人没有开发者账号，用公司账号演示的话担心会泄密，因此这篇文章用了比较多的网络图片，在此也谢谢原作者。OK,我们进入正文：</p>
<h5 id="1-Apple开发者证书类型"><a href="#1-Apple开发者证书类型" class="headerlink" title="1.Apple开发者证书类型"></a>1.Apple开发者证书类型</h5><p>如果你是刚开始接触iOS可能会很疑惑：到底哪种开发者账号服务适合我们？有时候我们会有种假象就是在不明白要什么东西的时候，买同类中最贵的一定是最全的，但是我们要知道最贵的苹果的企业账号是不能发布到AppStore的，到底哪种是我们真正需要的大家在购买前建议大家看下<a target="_blank" rel="noopener" href="https://developer.apple.com/support/compare-memberships/">苹果官网中关于每种服务的介绍</a>，下图是各个账号所提供的服务，这里简单做个总结：</p>
<p><img src="/2019/08/31/iOS-%E4%B8%8A%E6%9E%B6%E6%B5%81%E7%A8%8B/00003.png"></p>
<p>苹果对开发者主要分为4类：免费个人，个人开发者、组织（公司、企业）、教育机构，其中组织又分为公司和企业，下面一一介绍他们的区别：</p>
<ul>
<li>免费个人</li>
</ul>
<p>如果只是个人学习使用，我们可以不用购买任何账号服务，只要有一个Apple ID，我们就可以下载Xcode，文档，样例代码，并且在真机上测试，但是每个手机上安装的测试应用是有限制的，这种归于免费个人用户，免费个人如何使用真机调试，具体可以参照该文章:<a target="_blank" rel="noopener" href="https://www.carsonx.com/xcode-10-%E6%97%A0%E5%BC%80%E5%8F%91%E8%80%85%E8%B4%A6%E5%8F%B7%E9%80%9A%E8%BF%87%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C%E7%9C%9F%E6%9C%BA%E8%B0%83%E8%AF%95/">Xcode 10 无开发者账号真机调试</a>。</p>
<ul>
<li>个人开发者</li>
</ul>
<p>个人开发者账号每年要缴纳99美元，一般我们如果想自己开发应用并上传AppStore的话只需要个人开发者账号就可以了，它的限制在于协作人员只限制1人，最大UUID支持数只有100，也就是说只有100个机器可以添加到设备白名单中，一般来说够用了。</p>
<ul>
<li>公司账户</li>
</ul>
<p>公司账户费用和个人开发者一样也是99美元，并且支持上传AppStore上架，也有最大UUID数100的限制，但是它的好处是可以支持多人协作，比个人开发者账户多一些帐号管理的设置，可设置多个Apple ID。但是比个人开发者证书申请过程麻烦在：需要填写公司的邓白氏编码（DUNS Number），个人开发者可以申请升级到公司账户。</p>
<ul>
<li>企业账户</li>
</ul>
<p>这个是最初让我搞混的一个概念，最早以为要上架只有企业账户才有权限，为啥？因为贵啊，但是恰恰是这种证书不能支持AppStore上架，它的价格是每年299美元，它的好处是最大UUID支持数不受限制，所以一般适用于企业内部应用使用，也可以支持多人协作开发。和公司账户类似的是它也需要填写公司的邓白氏编码（DUNS Number）</p>
<ul>
<li>教育机构</li>
</ul>
<p>只能教育机构或学院内部使用。必须是苹果iOS开发者计划授权机构。不能对外正式发布iOS应用程序。价格也是免费的。</p>
<p>所以如果只是个人学习的话申请免费个人账户就可以了，如果要自己个人开发应用，并且没有成立公司的独立开发者，可以申请个人开发者，公司开发的应用一般需要使用公司账户，如果开发一些不提供给外部使用，只限制在公司内部的应用，则使用企业账户，如果某些学校内部的应用，并且通过了iOS开发者计划授权的，可以使用教育机构账户。</p>
<h5 id="2-注册成为Apple开发者"><a href="#2-注册成为Apple开发者" class="headerlink" title="2.注册成为Apple开发者"></a>2.注册成为Apple开发者</h5><h5 id="2-1-注册Apple-ID"><a href="#2-1-注册Apple-ID" class="headerlink" title="2.1 注册Apple ID"></a>2.1 注册Apple ID</h5><p><a target="_blank" rel="noopener" href="https://appleid.apple.com/account#!&page=create">Apple ID 申请入口</a></p>
<p>Apple ID申请的过程还是蛮简单的，只需要在上面的页面上填写姓名，国家地区，出生日期，邮箱，密码，三个安全提示，联系电话，验证方式等，这时候就会收到验证信息，通过验证就可以成功获得你的Apple ID了。</p>
<p><strong><strong>这里需要注意的是注册Apple Id的邮箱必须是企业邮箱，并且与公司网站的域名保持一致，比如公司网站为abc.com那么公司邮箱就必须长成<a href="mailto:&#x78;&#120;&#x78;&#x78;&#120;&#120;&#x40;&#x61;&#98;&#x63;&#46;&#x63;&#111;&#x6d;">&#x78;&#120;&#x78;&#x78;&#120;&#120;&#x40;&#x61;&#98;&#x63;&#46;&#x63;&#111;&#x6d;</a>。还有公司开发者账号与企业开发者账号不能共用同一个Apple id。</strong></strong></p>
<h5 id="2-2-申请邓白氏码"><a href="#2-2-申请邓白氏码" class="headerlink" title="2.2 申请邓白氏码"></a>2.2 申请邓白氏码</h5><p><a target="_blank" rel="noopener" href="https://developer.apple.com/enroll/duns-lookup/#!/search">邓白氏码申请入口</a></p>
<p>这里需要注意的是不要直接去邓白氏公司直接申请，因为这种途径是需要交钱的，而通过上面的地址申请是免费的。</p>
<p><img src="/2019/08/31/iOS-%E4%B8%8A%E6%9E%B6%E6%B5%81%E7%A8%8B/00004.jpeg"><br><img src="/2019/08/31/iOS-%E4%B8%8A%E6%9E%B6%E6%B5%81%E7%A8%8B/00005.jpeg"><br><img src="/2019/08/31/iOS-%E4%B8%8A%E6%9E%B6%E6%B5%81%E7%A8%8B/00006.jpeg"><br><img src="/2019/08/31/iOS-%E4%B8%8A%E6%9E%B6%E6%B5%81%E7%A8%8B/00007.jpeg"><br><img src="/2019/08/31/iOS-%E4%B8%8A%E6%9E%B6%E6%B5%81%E7%A8%8B/00008.jpeg"><br>上面<strong><strong>Your Contact Information</strong></strong>一栏中的邮箱填成个人的，后续的邮件将会发送到这个邮箱上，并且确保手机号码是正确，这个很重要。</p>
<p>如果申请成功就会在你留的个人邮箱上收到*<em><strong>D-U-N-S Number Request&#x2F;Update Confirmation</strong></em>**邮件，上面会有一个DUNS码请求ID，以及需要在什么时间之前完成申请工作，这个只是请求码而不是邓白氏码，这个用于后续的沟通。</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">Thank you <span class="keyword">for</span> submitting your D-U-<span class="keyword">N</span>-S Number request / <span class="keyword">update</span> <span class="keyword">to</span> D&amp;B. It should <span class="keyword">be</span> completed by xx/xx/xxxx, <span class="built_in">or</span> sooner.</span><br><span class="line">Your request id <span class="keyword">is</span>: xxxxxx-xxxxxx.</span><br><span class="line">A D&amp;B representative may <span class="keyword">be</span> contacting you directly.  Your cooperation will <span class="keyword">help</span> <span class="keyword">to</span> expedite the resolution of this request.</span><br><span class="line">Please contact applecs@dnb.<span class="keyword">com</span> <span class="keyword">if</span> you have any questions.</span><br></pre></td></tr></table></figure>

<p>收到上述的邮件后还需要等待，邓白氏公司发邮件让我们提供公司的资料：</p>
<p><img src="/2019/08/31/iOS-%E4%B8%8A%E6%9E%B6%E6%B5%81%E7%A8%8B/00009.png"></p>
<p>这一步需要注意如下几点：</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="bullet">* </span>营业执行公章最好提供原件的照片</span><br><span class="line"><span class="bullet">* </span>企业类型、主营业务，见公司的营业执照</span><br><span class="line"><span class="bullet">* </span>要记住提供经过盖章签名后的确认咨询函</span><br><span class="line"><span class="bullet">* </span>苹果联系人，一定要填写对公司信息比较了解的领导信息，后面邓白氏公司会通过这个联系方式与该人进行通话，确定一些公司的信息。</span><br><span class="line"><span class="bullet">* </span>申请邓白氏之后，需要时刻注意联系邮箱上面收到的回复邮件，邓白氏要求在规定时间内完成公司信息的填写并回复，所以一般在申请之前就要准备好对应的材料。</span><br></pre></td></tr></table></figure>

<p>材料提供完后就耐心等待，这时候邓白氏公司就会有人与你留下的苹果联系人联系，核对信息，通过后就会收到申请成功的邓白氏码邮件，这里还需要注意的是不能心急，收到邓白氏码后立刻去申请苹果开发者账号，因为这部分信息同步到苹果公司数据库还需要一定时间，否则在苹果数据库更新完成之前申请失败超过3次，就需要重新申请邓白氏码，这个时间在邮件上面已经写明白了是14天，一般都会等上20天后去尝试。</p>
<p><img src="/2019/08/31/iOS-%E4%B8%8A%E6%9E%B6%E6%B5%81%E7%A8%8B/000010.png"></p>
<h5 id="2-3-开发者证书申请"><a href="#2-3-开发者证书申请" class="headerlink" title="2.3 开发者证书申请"></a>2.3 开发者证书申请</h5><p><a target="_blank" rel="noopener" href="https://developer.apple.com/cn/programs/enroll/">个人开发者&#x2F;公司账户申请入口</a></p>
<p><a target="_blank" rel="noopener" href="https://developer.apple.com/cn/programs/enterprise/enroll/">企业开发者账号申请入口</a></p>
<p><img src="/2019/08/31/iOS-%E4%B8%8A%E6%9E%B6%E6%B5%81%E7%A8%8B/000011.jpeg"><br><img src="/2019/08/31/iOS-%E4%B8%8A%E6%9E%B6%E6%B5%81%E7%A8%8B/000012.jpeg"></p>
<p>这个阶段需要注意如下几点：</p>
<ol>
<li>切记一定要等到邓白氏码在苹果网站上生效后去注册</li>
<li>填写申请开发者账号的选项的时候最好选择第二项–公司授权，当然如果是自己公司那就选择第一项，还需要注意的是，这里的联系方式也要写对公司情况比较了解的人的信息，因为苹果审核的时候会和这个联系人联系，不要一问三不知。</li>
</ol>
<p>等到收到下图邮件的时候就可以支付费用了，这里仅支持Visa卡和万事达卡支付，同时支持开普通发票。<br><img src="/2019/08/31/iOS-%E4%B8%8A%E6%9E%B6%E6%B5%81%E7%A8%8B/000015.png"></p>
<p>支付完就完成开发者证书的申请了。</p>
<h5 id="3-开发过程需要的证书申请"><a href="#3-开发过程需要的证书申请" class="headerlink" title="3.开发过程需要的证书申请"></a>3.开发过程需要的证书申请</h5><p>首先我们必须明确到底需要哪些材料：</p>
<ol>
<li><p>开发者证书 （iOS Development 开发者证书,iOS Distribution 发布证书）这个用于证明自己开发者身份的，是一个最基础的证书。</p>
</li>
<li><p>AppID用于标示一个应用，这个AppId绑定了系列的应用信息以及这个应用开通的各个服务，比如常见的应用都会开通Push服务。</p>
</li>
<li><p>推送证书 一般应用都会开通Push服务，推送证书一般也会有两种，一种是开发环境推送证书（APNs Development iOS），一种是正式环境推送证书（APNs Distribution iOS）.</p>
</li>
<li><p>Provisioning Profiles 简称PP证书，该文件将上面的AppID,开发者证书，硬件设备信息，绑定到一块，可以在开发者中心配置好后添加到Xcode,也可以直接在Xcode上连接开发者中心生成，真机调试时需要在PP证书中添加真机的UDID.</p>
</li>
</ol>
<h5 id="3-1-创建开发者证书"><a href="#3-1-创建开发者证书" class="headerlink" title="3.1 创建开发者证书"></a>3.1 创建开发者证书</h5><p>使用已经开通了Apple开发者服务的账号登录苹果官网，进入Certificates, Identifiers &amp; Profiles，我们需要的证书，AppID,PP证书都是在这个地方生成的。<br><img src="/2019/08/31/iOS-%E4%B8%8A%E6%9E%B6%E6%B5%81%E7%A8%8B/000001.png"></p>
<p>如下图所示选择iOS, tvOS, watchOS –&gt; 选择All –&gt; 点击右上角新添加证书<br><img src="/2019/08/31/iOS-%E4%B8%8A%E6%9E%B6%E6%B5%81%E7%A8%8B/000002.png"></p>
<p>然后会让我们选择是开发证书还是生产证书，开发证书用于我们日常开发使用，而生产证书用于我们往AppStore中上传App时使用。</p>
<p><img src="/2019/08/31/iOS-%E4%B8%8A%E6%9E%B6%E6%B5%81%E7%A8%8B/000003.png"></p>
<p>接下来创建CSR（证书签名请求文件）这个是证书申请者在申请数字证书的时候由加密服务提供者在生成私钥的同时也生成证书请求文件，证书申请者只要把CSR文件提交给证书颁发机构后，证书颁发机构使用它的根证书私钥签名就可以生成证书公钥文件也就是颁发给用户的证书。<br> <br><img src="/2019/08/31/iOS-%E4%B8%8A%E6%9E%B6%E6%B5%81%E7%A8%8B/000005.png"><br><img src="/2019/08/31/iOS-%E4%B8%8A%E6%9E%B6%E6%B5%81%E7%A8%8B/000006.png"></p>
<p>下面是在Mac系统上生成CSR文件的过程：点击钥匙串访问 -&gt; 证书助理 -&gt;从证书颁发机构请求证书.</p>
<p><img src="/2019/08/31/iOS-%E4%B8%8A%E6%9E%B6%E6%B5%81%E7%A8%8B/000007.png"><br><img src="/2019/08/31/iOS-%E4%B8%8A%E6%9E%B6%E6%B5%81%E7%A8%8B/000008.png"><br><img src="/2019/08/31/iOS-%E4%B8%8A%E6%9E%B6%E6%B5%81%E7%A8%8B/000009.png"><br><img src="/2019/08/31/iOS-%E4%B8%8A%E6%9E%B6%E6%B5%81%E7%A8%8B/0000010.png"></p>
<p>上传CSR文件</p>
<p><img src="/2019/08/31/iOS-%E4%B8%8A%E6%9E%B6%E6%B5%81%E7%A8%8B/0000011.png"><br><img src="/2019/08/31/iOS-%E4%B8%8A%E6%9E%B6%E6%B5%81%E7%A8%8B/0000012.png"></p>
<p>下载经过签名的发布证书，同理可以创建开发者证书</p>
<p><img src="/2019/08/31/iOS-%E4%B8%8A%E6%9E%B6%E6%B5%81%E7%A8%8B/0000013.png"></p>
<p>运行之后,在钥匙串里生成证书,确保证书有效.</p>
<p>如果你的App Store Ad Hoc 前面的按钮不能选择，则代表你的这个账号无法再创建新的生产证书了，这时候可以有两种方式，一种比较直接：从现有的证书中选择一个删除，但是这个需要注意的是如果删除一个证书，那么正在使用这个证书的人将不能再继续使用了。</p>
<p><img src="/2019/08/31/iOS-%E4%B8%8A%E6%9E%B6%E6%B5%81%E7%A8%8B/000004.png"></p>
<p>还有一种方式是使用P12证书。</p>
<p>双击安装证书后，打开钥匙串访问，选择安装的证书右键单击</p>
<p><img src="/2019/08/31/iOS-%E4%B8%8A%E6%9E%B6%E6%B5%81%E7%A8%8B/0000014.png"></p>
<p>选中导出证书：</p>
<p><img src="/2019/08/31/iOS-%E4%B8%8A%E6%9E%B6%E6%B5%81%E7%A8%8B/0000015.png"></p>
<p>将证书存储为.p12形式：</p>
<p><img src="/2019/08/31/iOS-%E4%B8%8A%E6%9E%B6%E6%B5%81%E7%A8%8B/0000016.png"></p>
<p>可以为该证书设置密码这样会比较安全点，别人在安装这个证书的时候就需要输入密码。</p>
<p><img src="/2019/08/31/iOS-%E4%B8%8A%E6%9E%B6%E6%B5%81%E7%A8%8B/0000017.png"></p>
<p>如果需要在其它电脑上发布App,那么就必须要安装这个发布证书。</p>
<h5 id="3-2-创建APPID"><a href="#3-2-创建APPID" class="headerlink" title="3.2 创建APPID"></a>3.2 创建APPID</h5><p>点击App IDs,点击”+”号.</p>
<p><img src="/2019/08/31/iOS-%E4%B8%8A%E6%9E%B6%E6%B5%81%E7%A8%8B/2000.png"></p>
<p>填写应用描述和Bundle ID,如果后续修改了工程里面的Bundle Identifier的话，需要重新进入到开发者账号里面绑定。</p>
<p><img src="/2019/08/31/iOS-%E4%B8%8A%E6%9E%B6%E6%B5%81%E7%A8%8B/2001.png"></p>
<p>选择开通的服务，默认开通了游戏中心和内购服务</p>
<p><img src="/2019/08/31/iOS-%E4%B8%8A%E6%9E%B6%E6%B5%81%E7%A8%8B/2002.png"><br><img src="/2019/08/31/iOS-%E4%B8%8A%E6%9E%B6%E6%B5%81%E7%A8%8B/2003.png"><br><img src="/2019/08/31/iOS-%E4%B8%8A%E6%9E%B6%E6%B5%81%E7%A8%8B/2004.png"></p>
<h5 id="3-3-创建推送证书"><a href="#3-3-创建推送证书" class="headerlink" title="3.3 创建推送证书"></a>3.3 创建推送证书</h5><p>如果选中开通推送服务还需要完成如下配置：</p>
<p><img src="/2019/08/31/iOS-%E4%B8%8A%E6%9E%B6%E6%B5%81%E7%A8%8B/2005.png"><br><img src="/2019/08/31/iOS-%E4%B8%8A%E6%9E%B6%E6%B5%81%E7%A8%8B/2006.png"><br><img src="/2019/08/31/iOS-%E4%B8%8A%E6%9E%B6%E6%B5%81%E7%A8%8B/2007.png"><br><img src="/2019/08/31/iOS-%E4%B8%8A%E6%9E%B6%E6%B5%81%E7%A8%8B/2008.png"></p>
<h5 id="3-4-创建PP证书"><a href="#3-4-创建PP证书" class="headerlink" title="3.4 创建PP证书"></a>3.4 创建PP证书</h5><p>PP描述文件是描述哪台电脑能对指定Bundle Identifier的工程进行打包测试或发布。</p>
<p><img src="/2019/08/31/iOS-%E4%B8%8A%E6%9E%B6%E6%B5%81%E7%A8%8B/3001.png"><br><img src="/2019/08/31/iOS-%E4%B8%8A%E6%9E%B6%E6%B5%81%E7%A8%8B/3002.png"><br><img src="/2019/08/31/iOS-%E4%B8%8A%E6%9E%B6%E6%B5%81%E7%A8%8B/3003.png"><br><img src="/2019/08/31/iOS-%E4%B8%8A%E6%9E%B6%E6%B5%81%E7%A8%8B/3004.png"><br><img src="/2019/08/31/iOS-%E4%B8%8A%E6%9E%B6%E6%B5%81%E7%A8%8B/3005.png"><br><img src="/2019/08/31/iOS-%E4%B8%8A%E6%9E%B6%E6%B5%81%E7%A8%8B/3006.png"></p>
<h5 id="4-在AppStore创建应用"><a href="#4-在AppStore创建应用" class="headerlink" title="4.在AppStore创建应用"></a>4.在AppStore创建应用</h5><ul>
<li>登陆<a target="_blank" rel="noopener" href="https://itunesconnect.apple.com/login">iTunes Connect</a></li>
</ul>
<p>或者在开发者中心选中iTunes Connect进入：<br><img src="/2019/08/31/iOS-%E4%B8%8A%E6%9E%B6%E6%B5%81%E7%A8%8B/5003.png"></p>
<p>输入账号密码：</p>
<p><img src="/2019/08/31/iOS-%E4%B8%8A%E6%9E%B6%E6%B5%81%E7%A8%8B/5001.png"></p>
<p>选择我的App<br><img src="/2019/08/31/iOS-%E4%B8%8A%E6%9E%B6%E6%B5%81%E7%A8%8B/5002.png"></p>
<p>点击左上角的➕<br><img src="/2019/08/31/iOS-%E4%B8%8A%E6%9E%B6%E6%B5%81%E7%A8%8B/5004.png"></p>
<p>选择平台，名称，主要语言套装ID以及SKU其中SKU和套装ID建议都填Bundle Id<br><img src="/2019/08/31/iOS-%E4%B8%8A%E6%9E%B6%E6%B5%81%E7%A8%8B/5005.png"></p>
<p>选择应用类别和次要类别<br><img src="/2019/08/31/iOS-%E4%B8%8A%E6%9E%B6%E6%B5%81%E7%A8%8B/5007.png"></p>
<p>如果要收费的应用要继续填写价格、销售范围、批量购买计划.<br><img src="/2019/08/31/iOS-%E4%B8%8A%E6%9E%B6%E6%B5%81%E7%A8%8B/5008.png"></p>
<p>选择上传3.5寸、4寸、4.7寸、5.5寸预览图片,每个尺寸都要至少3张.<br><img src="/2019/08/31/iOS-%E4%B8%8A%E6%9E%B6%E6%B5%81%E7%A8%8B/5009.png"></p>
<p>填写应用描述和关键词<br><img src="/2019/08/31/iOS-%E4%B8%8A%E6%9E%B6%E6%B5%81%E7%A8%8B/5010.png"></p>
<p>上传1024 * 1024尺寸的应用图标，填写版权信息和用户等级，以及审核信息<br><img src="/2019/08/31/iOS-%E4%B8%8A%E6%9E%B6%E6%B5%81%E7%A8%8B/5011.png"><br><img src="/2019/08/31/iOS-%E4%B8%8A%E6%9E%B6%E6%B5%81%E7%A8%8B/5013.png"><br><img src="/2019/08/31/iOS-%E4%B8%8A%E6%9E%B6%E6%B5%81%E7%A8%8B/5014.png"></p>
<h5 id="5-使用证书打包上传AppStore提交审核"><a href="#5-使用证书打包上传AppStore提交审核" class="headerlink" title="5.使用证书打包上传AppStore提交审核"></a>5.使用证书打包上传AppStore提交审核</h5><p>在进行打包的之前需要找到刚刚下载的发布证书（后缀为.cer）或者p12文件，和PP文件，双击安装，如果已经安装过就不用执行该操作了。</p>
<p>这里仅仅介绍使用Xcode打包应用的过程，一般公司应用都会使用自动构建系统来打包，这个放在后续介绍。</p>
<p>首先在上传给苹果公司审核之前我们需要事先对照 <a target="_blank" rel="noopener" href="https://developer.apple.com/cn/app-store/review/guidelines/">App Store 审核指南</a>过一遍，避免因为某些低级错误导致审核不通过，第一个版本审核一般时间都比较长，腾讯还推出了<a target="_blank" rel="noopener" href="https://wetest.qq.com/product/ios">iOS预审服务</a>，有需要的可以使用这些三方服务来提高审核通过的概率。但是一般来说第一次会比较久，并且如果有内购功能会更久，后续版本会快很多，当然也有很多旁门左道，大家可以到网上去搜索，这里就不公开了，一般为了保守起见预留个 15~20天是比较靠谱的，但是一般第一个版本7-10天基本上都会过，后续更新的话3-4天就会通过。当然有些是苹果审核人员误解了，我们可以积极得和苹果审核人员进行沟通。</p>
<p>好了我们开始介绍打包上传到AppStore并提交审核的过程：</p>
<p>进入AS后台会有提示可以使用Xcode打包或者通过构建系统打成ipa包后通过Application Loader上传，一般推荐后一种。<br><img src="/2019/08/31/iOS-%E4%B8%8A%E6%9E%B6%E6%B5%81%E7%A8%8B/4000.png"></p>
<p>在打包之前需要检查下一些内容：</p>
<ul>
<li>设备需要选择Generic iOS Device.</li>
<li>检查横竖屏支持情况</li>
<li>检查发布版本以及构建号</li>
<li>iOS最低可运行的版本</li>
<li>应用支持设备类型</li>
<li>签名证书</li>
</ul>
<p><img src="/2019/08/31/iOS-%E4%B8%8A%E6%9E%B6%E6%B5%81%E7%A8%8B/4002.png"><br><img src="/2019/08/31/iOS-%E4%B8%8A%E6%9E%B6%E6%B5%81%E7%A8%8B/4003.png"><br><img src="/2019/08/31/iOS-%E4%B8%8A%E6%9E%B6%E6%B5%81%E7%A8%8B/4004.png"><br><img src="/2019/08/31/iOS-%E4%B8%8A%E6%9E%B6%E6%B5%81%E7%A8%8B/4005.png"><br><img src="/2019/08/31/iOS-%E4%B8%8A%E6%9E%B6%E6%B5%81%E7%A8%8B/4006.png"><br><img src="/2019/08/31/iOS-%E4%B8%8A%E6%9E%B6%E6%B5%81%E7%A8%8B/4007.png"></p>
<p>把Run、Test、Profile、Analyze、Archive中的Build Configuration全部改为Release.之后Close. Control + B 开始构建应用。<br><img src="/2019/08/31/iOS-%E4%B8%8A%E6%9E%B6%E6%B5%81%E7%A8%8B/4008.png"><br><img src="/2019/08/31/iOS-%E4%B8%8A%E6%9E%B6%E6%B5%81%E7%A8%8B/4009.png"><br><img src="/2019/08/31/iOS-%E4%B8%8A%E6%9E%B6%E6%B5%81%E7%A8%8B/4010.png"><br><img src="/2019/08/31/iOS-%E4%B8%8A%E6%9E%B6%E6%B5%81%E7%A8%8B/4011.png"><br><img src="/2019/08/31/iOS-%E4%B8%8A%E6%9E%B6%E6%B5%81%E7%A8%8B/4012.png"><br><img src="/2019/08/31/iOS-%E4%B8%8A%E6%9E%B6%E6%B5%81%E7%A8%8B/4013.png"></p>
<p>编译成功,选择Product -&gt; Archive.进行打包,在进行上传之前最好建议先点击验证，避免因为版本等问题上传过程中失败，这样会更节省时间<br><img src="/2019/08/31/iOS-%E4%B8%8A%E6%9E%B6%E6%B5%81%E7%A8%8B/4014.png"><br><img src="/2019/08/31/iOS-%E4%B8%8A%E6%9E%B6%E6%B5%81%E7%A8%8B/4015.png"><br><img src="/2019/08/31/iOS-%E4%B8%8A%E6%9E%B6%E6%B5%81%E7%A8%8B/4016.png"><br><img src="/2019/08/31/iOS-%E4%B8%8A%E6%9E%B6%E6%B5%81%E7%A8%8B/4017.png"><br><img src="/2019/08/31/iOS-%E4%B8%8A%E6%9E%B6%E6%B5%81%E7%A8%8B/4018.png"><br><img src="/2019/08/31/iOS-%E4%B8%8A%E6%9E%B6%E6%B5%81%E7%A8%8B/4019.png"><br><img src="/2019/08/31/iOS-%E4%B8%8A%E6%9E%B6%E6%B5%81%E7%A8%8B/4020.png"><br><img src="/2019/08/31/iOS-%E4%B8%8A%E6%9E%B6%E6%B5%81%E7%A8%8B/4021.png"><br><img src="/2019/08/31/iOS-%E4%B8%8A%E6%9E%B6%E6%B5%81%E7%A8%8B/4022.png"><br><img src="/2019/08/31/iOS-%E4%B8%8A%E6%9E%B6%E6%B5%81%E7%A8%8B/4023.png"></p>
<p>当然还可以使用Application Loader上传，这种方式主要分成两步：</p>
<ol>
<li>导出ipa包</li>
</ol>
<p><img src="/2019/08/31/iOS-%E4%B8%8A%E6%9E%B6%E6%B5%81%E7%A8%8B/6001.png"><br><img src="/2019/08/31/iOS-%E4%B8%8A%E6%9E%B6%E6%B5%81%E7%A8%8B/6002.png"><br><img src="/2019/08/31/iOS-%E4%B8%8A%E6%9E%B6%E6%B5%81%E7%A8%8B/6003.png"><br><img src="/2019/08/31/iOS-%E4%B8%8A%E6%9E%B6%E6%B5%81%E7%A8%8B/6004.png"><br><img src="/2019/08/31/iOS-%E4%B8%8A%E6%9E%B6%E6%B5%81%E7%A8%8B/6005.png"><br><img src="/2019/08/31/iOS-%E4%B8%8A%E6%9E%B6%E6%B5%81%E7%A8%8B/6006.png"></p>
<ol start="2">
<li>通过Application Loader上传<br><img src="/2019/08/31/iOS-%E4%B8%8A%E6%9E%B6%E6%B5%81%E7%A8%8B/6007.png"></li>
</ol>
<p>如果没有Mac的话还可以使用跨平台的APP开发助手，可能你会疑惑，开发苹果应用的居然没有Mac不可能啊，但是你要想啊，一般这些上传工作不一定是开发上传的哈，往往这些都是由产品或者项目管理者负责上传的，并且AS账号也是他们管理的。</p>
<p><a target="_blank" rel="noopener" href="http://www.appuploader.net/">http://www.appuploader.net/</a></p>
<p>上传到AS后就可以在后台看到刚刚上传的应用了，这时候点击提交以供审核就OK了。</p>
<p><img src="/2019/08/31/iOS-%E4%B8%8A%E6%9E%B6%E6%B5%81%E7%A8%8B/4024.png"><br><img src="/2019/08/31/iOS-%E4%B8%8A%E6%9E%B6%E6%B5%81%E7%A8%8B/4025.png"><br><img src="/2019/08/31/iOS-%E4%B8%8A%E6%9E%B6%E6%B5%81%E7%A8%8B/4026.png"><br><img src="/2019/08/31/iOS-%E4%B8%8A%E6%9E%B6%E6%B5%81%E7%A8%8B/4027.png"></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/iOS-%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/">iOS 理论基础</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/iOS-理论基础/">iOS 理论基础</a>
  </div>

</div>



<div class="comments-count">
	
	  	<span></span>
		<a href="/2019/08/31/iOS-上架流程/#comments" class="ds-thread-count comments-count-link" data-thread-key="2019/08/31/iOS-上架流程/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/08/30/iOS-支付内购/" title="iOS 支付内购" itemprop="url">iOS 支付内购</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Edgar" target="_blank" itemprop="author">Edgar</a>
		
  <p class="article-time">
    <time datetime="2019-08-29T18:00:20.000Z" itemprop="datePublished"> Published 2019-08-30</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h5 id="0-开篇叨叨"><a href="#0-开篇叨叨" class="headerlink" title="0. 开篇叨叨"></a>0. 开篇叨叨</h5><p>一般稍大点的应用都会接入支付功能，对于iOS应用而言，支付渠道主要分成两类：</p>
<ul>
<li>第三方支付：</li>
</ul>
<p>第三方支付包括：支付宝、微信、银联等支付方式，这些一般都需要有公司的形式才能接入，个人是无法接入的。</p>
<ul>
<li>应用内支付</li>
</ul>
<p>应用内支付简称内购,IAP说的都是同一个东西，它是指在应用程序内销售虚拟商品，如果我们在App Store上销售，将收到支付金额的70%，苹果公司会抽走30%。并且需要注意的是在AS上一次性消耗商品，价格不能超过99.99美刀不然会被拒绝的。</p>
<p>这篇博客主要介绍比较常用的支付宝、微信以及AS内购三种支付方式，对于这块的内容大家只要记住这里的原理就可以了，各个渠道的SDK以及部分流程都会时常更新，所以不用太在意具体的差异。接入的时候还是要仔细阅读对应平台的SDK说明文档。</p>
<p>对于内购GitHub上面也有一些比较好的开源项目大家也可以作为借鉴：<a target="_blank" rel="noopener" href="https://github.com/robotmedia/RMStore">RMStore</a> 以及 <a target="_blank" rel="noopener" href="https://github.com/mattt/CargoBay">CargoBay</a></p>
<h5 id="1-第三方支付"><a href="#1-第三方支付" class="headerlink" title="1. 第三方支付"></a>1. 第三方支付</h5><h5 id="1-1-支付宝平台"><a href="#1-1-支付宝平台" class="headerlink" title="1.1 支付宝平台"></a>1.1 支付宝平台</h5><h6 id="1-1-1-简介"><a href="#1-1-1-简介" class="headerlink" title="1.1.1 简介"></a>1.1.1 简介</h6><p>支付宝接入文档地址如下：<br><a target="_blank" rel="noopener" href="https://docs.open.alipay.com/204/105051">https://docs.open.alipay.com/204/105051</a></p>
<p>在我们需要通过支付宝三方支付的时候，我们的应用调用支付宝提供的SDK，如果用户已经安装了支付宝 APP，这时候支付宝APP将会被调起来接管后续的支付流程，支付完成后跳回我们的应用展示支付结果，如果用户没有安装支付宝 APP，这时候将会调起支付宝网页支付收银台，用户登录支付宝账户，支付完后展示支付结果。</p>
<p>但是支付宝只针对企业或者个体户才能申请接入，对于一般的开发者是无法接入的</p>
<p>下面是接入支付宝的条件：</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li>申请前必须拥有经过实名认证的支付宝账户；</li>
<li>企业或个体工商户可申请；</li>
<li>需提供真实有效的营业执照，且支付宝账户名称需与营业执照主体一致；</li>
<li>网站能正常访问且页面显示完整，网站需要明确经营内容且有完整的商品信息；</li>
<li>网站必须通过ICP备案。如为个体工商户，网站备案主体需要与支付宝账户主体名称一致；</li>
<li>如为个体工商户，则团购不开放，且古玩、珠宝等奢侈品、投资类行业无法申请本产品。</li>
</ul>
<h6 id="1-1-2-接入前准备"><a href="#1-1-2-接入前准备" class="headerlink" title="1.1.2 接入前准备"></a>1.1.2 接入前准备</h6><p>在接入前需要在<a href="open.alipay.com">支付宝开放平台</a>创建应用，我们需要提供我们应用的基本信息，以及授权回调，加密公钥等信息，如果创建成功会获得一个APPID，通过 APPID 才能调用开放产品的接口能力。具体查看<br><a target="_blank" rel="noopener" href="https://docs.open.alipay.com/200/105310">开放平台应用创建指南</a> </p>
<p>创建成功后我们就可以往我们注册的应用上<a target="_blank" rel="noopener" href="https://docs.open.alipay.com/common/105366">添加功能</a>，对于某些需要签约功能的应用，要先完成<a target="_blank" rel="noopener" href="https://docs.open.alipay.com/200/105314">签约</a>后才能使用。</p>
<p>为了保证交易双方的身份和数据安全，我们在调用接口前，需要配置双方密钥，并通过双方密钥对交易数据进行双方校验，支付宝使用RSA加解密技术，整个过程我们需要应用私钥（APP_PRIVATE_KEY）、应用公钥（APP_PUBLIC_KEY），以及支付宝公钥（ALIPAY_PUBLIC_KEY），我们首先会在本地生成一对应用私钥（APP_PRIVATE_KEY）、应用公钥（APP_PUBLIC_KEY），并且在上述添加应用的时候把应用公钥（APP_PUBLIC_KEY）通过开放平台给支付宝，这样我们使用应用私钥（APP_PRIVATE_KEY）加密后的数据支付宝就可以通过我们给它的应用公钥解开了。同理，支付宝那边的返回数据也可能是加密的，对于这些数据我们可以使用支付宝公钥（ALIPAY_PUBLIC_KEY）进行解密，这部分可以查看<a target="_blank" rel="noopener" href="https://docs.open.alipay.com/291/106103/">签名专区</a>。</p>
<h6 id="1-1-3-支付流程"><a href="#1-1-3-支付流程" class="headerlink" title="1.1.3 支付流程"></a>1.1.3 支付流程</h6><p><img src="/2019/08/30/iOS-%E6%94%AF%E4%BB%98%E5%86%85%E8%B4%AD/0001.png"></p>
<h6 id="1-1-4-iOS-支付宝SDK集成"><a href="#1-1-4-iOS-支付宝SDK集成" class="headerlink" title="1.1.4 iOS 支付宝SDK集成"></a>1.1.4 iOS 支付宝SDK集成</h6><p>具体的集成过程可以查看<a target="_blank" rel="noopener" href="https://docs.open.alipay.com/204/105295">集成文档</a></p>
<p>首先我们点击购买某个商品的时候会发送信息告诉我们业务服务端我们需要购买的商品信息，比如商品id等。服务端后台会生成订单ID，并将包括订单ID，订单价格等信息打包起来，在服务端使用应用私钥对这些信息加密后传递给客户端，客户端收到这个请求后直接传递给支付宝SDK发起请求，这里之所以将加密放在服务端是为了避免公私钥数据泄露，在使用的时候一定要注意构造交易数据并签名必须在商户服务端完成，商户的应用私钥绝对不能保存在商户 APP 客户端中，也不能从服务端下发。</p>
<p>下面是来自支付宝官网的Demo,在该Demo中为了简单它将加密放在了客户端，在实际应用的时候需要注意这一点。</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">//</span>将商品信息赋予AlixPayOrder的成员变量</span><br><span class="line">Order* order = [Order new];</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span> NOTE: app_id设置</span><br><span class="line">order.app_id = appID;</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span> NOTE: 支付接口名称</span><br><span class="line">order.method = @<span class="string">&quot;alipay.trade.app.pay&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span> NOTE: 参数编码格式</span><br><span class="line">order.charset = @<span class="string">&quot;utf-8&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span> NOTE: 当前时间点</span><br><span class="line">NSDateFormatter* formatter = [NSDateFormatter new];</span><br><span class="line">[formatter setDateFormat:@<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>];</span><br><span class="line">order.timestamp = [formatter stringFromDate:[NSDate date]];</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span> NOTE: 支付版本</span><br><span class="line">order.version = @<span class="string">&quot;1.0&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span> NOTE: sign_type设置</span><br><span class="line">order.sign_type = @<span class="string">&quot;RSA&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span> NOTE: 商品数据</span><br><span class="line">order.biz_content = [BizContent new];</span><br><span class="line">order.biz_content.body = @<span class="string">&quot;我是测试数据&quot;</span>;</span><br><span class="line">order.biz_content.subject = @<span class="string">&quot;1&quot;</span>;</span><br><span class="line">order.biz_content.out_trade_no = [self generateTradeNO]; <span class="regexp">//</span>订单ID（由商家自行制定）</span><br><span class="line">order.biz_content.timeout_express = @<span class="string">&quot;30m&quot;</span>; <span class="regexp">//</span>超时时间设置</span><br><span class="line">order.biz_content.total_amount = [NSString stringWithFormat:@<span class="string">&quot;%.2f&quot;</span>, <span class="number">0.01</span>]; <span class="regexp">//</span>商品价格</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span>将商品信息拼接成字符串</span><br><span class="line">NSString *orderInfo = [order orderInfoEncoded:NO];</span><br><span class="line">NSString *orderInfoEncoded = [order orderInfoEncoded:YES];</span><br><span class="line">NSLog(@<span class="string">&quot;orderSpec = %@&quot;</span>,orderInfo);</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span> NOTE: 获取私钥并将商户信息签名，外部商户的加签过程请务必放在服务端，防止公私钥数据泄露；</span><br><span class="line"><span class="regexp">//</span>       需要遵循RSA签名规范，并将签名字符串base64编码和UrlEncode</span><br><span class="line">id&lt;DataSigner&gt; signer = CreateRSADataSigner(privateKey);</span><br><span class="line">NSString *signedString = [signer signString:orderInfo];</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span> NOTE: 如果加签成功，则继续执行支付</span><br><span class="line"><span class="keyword">if</span> (signedString != nil) &#123;</span><br><span class="line">    <span class="regexp">//</span>应用注册scheme,在AliSDKDemo-Info.plist定义URL types</span><br><span class="line">    NSString *appScheme = @<span class="string">&quot;alisdkdemo&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="regexp">//</span> NOTE: 将签名成功字符串格式化为订单字符串,请严格按照该格式</span><br><span class="line">    NSString *orderString = [NSString stringWithFormat:@<span class="string">&quot;%@&amp;sign=%@&quot;</span>,</span><br><span class="line">                             orderInfoEncoded, signedString];</span><br><span class="line">    </span><br><span class="line">    <span class="regexp">//</span> NOTE: 调用支付结果开始支付</span><br><span class="line">    [[AlipaySDK defaultService] payOrder:orderString fromScheme:appScheme callback:^(NSDictionary *resultDic) &#123;</span><br><span class="line">        NSLog(@<span class="string">&quot;reslut = %@&quot;</span>,resultDic);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>处理的结果分成两种方式返回：</p>
<ul>
<li>同步通知：同步通知指的是支付宝SDK对支付请求处理完毕后将结果返回给商户App端</li>
<li>异步通知：异步通知指的是支付宝SDK处理完结果后将结果通过异步通知地址notify_url，通过POST方式将结果回传给我们业务后台。</li>
</ul>
<p>同步返回的数据，只是一个简单的结果通知，商户确定该笔交易付款是否成功需要依赖服务端收到支付宝异步通知的结果进行判断。具体返回的结果可以查看<a target="_blank" rel="noopener" href="https://docs.open.alipay.com/204/105301/">通知参数说明</a></p>
<p>同时不要忘记在info.plist 注册的 scheme。接下来就是在AppDelegate中处理支付宝返回的处理结果，这个回调会在这笔交易被买家支付成功后支付宝收银台上显示该笔交易成功，并提示用户“返回”的时候被调用。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application</span><br><span class="line">            openURL:(<span class="built_in">NSURL</span> *)url</span><br><span class="line">  sourceApplication:(<span class="built_in">NSString</span> *)sourceApplication</span><br><span class="line">         annotation:(<span class="type">id</span>)annotation &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ([url.host isEqualToString:<span class="string">@&quot;safepay&quot;</span>]) &#123;</span><br><span class="line">        <span class="comment">//跳转支付宝钱包进行支付，处理支付结果</span></span><br><span class="line">        [[AlipaySDK defaultService] processOrderWithPaymentResult:url standbyCallback:^(<span class="built_in">NSDictionary</span> *resultDic) &#123;</span><br><span class="line">            <span class="comment">//在这里处理对应的支付结果</span></span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> 9.0以后使用新API接口</span></span><br><span class="line">- (<span class="type">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)app openURL:(<span class="built_in">NSURL</span> *)url options:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span>*, <span class="type">id</span>&gt; *)options</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ([url.host isEqualToString:<span class="string">@&quot;safepay&quot;</span>]) &#123;</span><br><span class="line">        <span class="comment">//跳转支付宝钱包进行支付，处理支付结果</span></span><br><span class="line">        [[AlipaySDK defaultService] processOrderWithPaymentResult:url standbyCallback:^(<span class="built_in">NSDictionary</span> *resultDic) &#123;</span><br><span class="line">            <span class="comment">//在这里处理对应的支付结果</span></span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>resultDic整个结构如下所示：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;memo&quot;</span> : <span class="string">&quot;xxxxx&quot;</span>,</span><br><span class="line">    <span class="string">&quot;result&quot;</span> : <span class="string">&quot;&#123;</span></span><br><span class="line"><span class="string">                    <span class="subst">\&quot;</span>alipay_trade_app_pay_response<span class="subst">\&quot;</span>:&#123;</span></span><br><span class="line"><span class="string">                        <span class="subst">\&quot;</span>code<span class="subst">\&quot;</span>:<span class="subst">\&quot;</span>10000<span class="subst">\&quot;</span>,</span></span><br><span class="line"><span class="string">                        <span class="subst">\&quot;</span>msg<span class="subst">\&quot;</span>:<span class="subst">\&quot;</span>Success<span class="subst">\&quot;</span>,</span></span><br><span class="line"><span class="string">                        <span class="subst">\&quot;</span>app_id<span class="subst">\&quot;</span>:<span class="subst">\&quot;</span>2014072300007148<span class="subst">\&quot;</span>,</span></span><br><span class="line"><span class="string">                        <span class="subst">\&quot;</span>out_trade_no<span class="subst">\&quot;</span>:<span class="subst">\&quot;</span>081622560194853<span class="subst">\&quot;</span>,</span></span><br><span class="line"><span class="string">                        <span class="subst">\&quot;</span>trade_no<span class="subst">\&quot;</span>:<span class="subst">\&quot;</span>2016081621001004400236957647<span class="subst">\&quot;</span>,</span></span><br><span class="line"><span class="string">                        <span class="subst">\&quot;</span>total_amount<span class="subst">\&quot;</span>:<span class="subst">\&quot;</span>0.01<span class="subst">\&quot;</span>,</span></span><br><span class="line"><span class="string">                        <span class="subst">\&quot;</span>seller_id<span class="subst">\&quot;</span>:<span class="subst">\&quot;</span>2088702849871851<span class="subst">\&quot;</span>,</span></span><br><span class="line"><span class="string">                        <span class="subst">\&quot;</span>charset<span class="subst">\&quot;</span>:<span class="subst">\&quot;</span>utf-8<span class="subst">\&quot;</span>,</span></span><br><span class="line"><span class="string">                        <span class="subst">\&quot;</span>timestamp<span class="subst">\&quot;</span>:<span class="subst">\&quot;</span>2016-10-11 17:43:36<span class="subst">\&quot;</span></span></span><br><span class="line"><span class="string">                    &#125;,</span></span><br><span class="line"><span class="string">                    <span class="subst">\&quot;</span>sign<span class="subst">\&quot;</span>:<span class="subst">\&quot;</span>NGfStJf3i3ooWBuCDIQSumOpaGBcQz+aoAqyGh3W6EqA/gmyPYwLJ2REFijY9XPTApI9YglZyMw+ZMhd3kb0mh4RAXMrb6mekX4Zu8Nf6geOwIa9kLOnw0IMCjxi4abDIfXhxrXyj********<span class="subst">\&quot;</span>,</span></span><br><span class="line"><span class="string">                    <span class="subst">\&quot;</span>sign_type<span class="subst">\&quot;</span>:<span class="subst">\&quot;</span>RSA2<span class="subst">\&quot;</span></span></span><br><span class="line"><span class="string">                &#125;&quot;</span>,</span><br><span class="line">    <span class="string">&quot;resultStatus&quot;</span> : <span class="string">&quot;9000&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整个交互流程如下图所示：</p>
<p><img src="/2019/08/30/iOS-%E6%94%AF%E4%BB%98%E5%86%85%E8%B4%AD/0002.png"></p>
<p>下图是支付失败时候的交互流程图：</p>
<p><img src="/2019/08/30/iOS-%E6%94%AF%E4%BB%98%E5%86%85%E8%B4%AD/0003.png"></p>
<p>对应的错误码可以查看官方的<a target="_blank" rel="noopener" href="https://docs.open.alipay.com/common/105806">错误文档</a></p>
<p>商户系统接收到通知以后，必须通过验签来确保支付通知是由支付宝发送的。<br>除了正常的支付交易流程外，支付宝也提供交易查询、关闭、退款、退款查询以及对账等配套API详细可以查看官方文档。 </p>
<h6 id="1-1-5-调试上线"><a href="#1-1-5-调试上线" class="headerlink" title="1.1.5 调试上线"></a>1.1.5 调试上线</h6><p>在上线之前可以在<a target="_blank" rel="noopener" href="https://docs.open.alipay.com/200/105311">沙箱环境</a>开发联调,联调通过后就可以在支付宝<a target="_blank" rel="noopener" href="https://docs.open.alipay.com/common/105313">上线</a>应用了，只有上线状态下的应用才能够调用生产环境的接口，在申请上线之前建议认真对照[开放平台第三方应用安全开发指南]（<a target="_blank" rel="noopener" href="https://docs.open.alipay.com/common/105912%EF%BC%89%EF%BC%8C%E9%81%BF%E5%85%8D%E5%AE%A1%E6%A0%B8%E4%B8%8D%E9%80%9A%E8%BF%87%E8%A2%AB%E6%89%93%E5%9B%9E%E6%9D%A5%E3%80%82">https://docs.open.alipay.com/common/105912），避免审核不通过被打回来。</a></p>
<h5 id="1-2-微信支付"><a href="#1-2-微信支付" class="headerlink" title="1.2 微信支付"></a>1.2 微信支付</h5><p>微信支付目前也是仅接受公司主体的移动应用申请微信APP支付权限，目前手续费和支付宝一样都是0.6%到1%。具体的概述见<a target="_blank" rel="noopener" href="https://open.weixin.qq.com/cgi-bin/showdocument?action=dir_list&t=resource/res_list&verify=1&id=open1419317780&token=&lang=zh_CN">微信APP支付接入商户服务中心</a></p>
<p>下面是微信支付的整个交互时序图：</p>
<p><img src="/2019/08/30/iOS-%E6%94%AF%E4%BB%98%E5%86%85%E8%B4%AD/0004.png"></p>
<h5 id="1-2-1"><a href="#1-2-1" class="headerlink" title="1.2.1"></a>1.2.1</h5><ul>
<li>申请Appid</li>
</ul>
<p>和支付宝支付类似在接入SDK之前需要到微信开放平台申请开发APP应用之后会返回一个唯一标识APPID：</p>
<p><img src="/2019/08/30/iOS-%E6%94%AF%E4%BB%98%E5%86%85%E8%B4%AD/0006.png"></p>
<p>在URL Types中中添加一项URL Schemes为刚刚申请的Appid的项。</p>
<p><img src="/2019/08/30/iOS-%E6%94%AF%E4%BB%98%E5%86%85%E8%B4%AD/0005.png"></p>
<ul>
<li>导入WechatOpenSDK</li>
</ul>
<p>通过CocoaPods导入SDK</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">pod</span> <span class="string">&#x27;WechatOpenSDK&#x27;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>导入WXApi</li>
</ul>
<p>import WXApi.h 头文件，并增加 WXApiDelegate 协议。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#import <span class="string">&lt;UIKit/UIKit.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="string">&quot;WXApi.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AppDelegate</span> : <span class="title">UIResponder</span>&lt;<span class="title">UIApplicationDelegate</span>, <span class="title">WXApiDelegate</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">UIWindow</span> *window;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>向微信注册应用</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions &#123;    </span><br><span class="line">    <span class="comment">//向微信注册</span></span><br><span class="line">    [WXApi registerApp:<span class="string">@&quot;wxd930ea5d5a258f4f&quot;</span>]; </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>重写AppDelegate的handleOpenURL和openURL方法：</p>
</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application handleOpenURL:(<span class="built_in">NSURL</span> *)url &#123;   </span><br><span class="line">    <span class="keyword">return</span>  [WXApi handleOpenURL:url delegate:<span class="keyword">self</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application openURL:(<span class="built_in">NSURL</span> *)url sourceApplication:(<span class="built_in">NSString</span> *)sourceApplication annotation:(<span class="type">id</span>)annotation &#123;</span><br><span class="line">    <span class="keyword">return</span> [WXApi handleOpenURL:url delegate:<span class="keyword">self</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>接下来需要实现WXApiDelegate协议的两个方法：</li>
</ul>
<figure class="highlight erlang"><table><tr><td class="code"><pre><span class="line">-<span class="params">(void)</span> onReq:<span class="params">(BaseReq*)</span>reqonReq</span><br></pre></td></tr></table></figure>

<p>这个是是微信终端向我们应用发起请求的回调，我们调用完后必须调用sendRsp返回。</p>
<figure class="highlight erlang"><table><tr><td class="code"><pre><span class="line">-<span class="params">(void)</span> onResp:<span class="params">(BaseResp*)</span>resp</span><br></pre></td></tr></table></figure>

<p>如果我们应用向微信发送了sendReq的请求，那么onResp会被回调。&#96;</p>
<p>如果我们的应用需要发送消息给微信，那么需要调用<br>[4] 如果你的程序要发消息给微信，那么需要调用WXApi的sendReq函数：</p>
<p>调用WXApi的sendReq函数</p>
<figure class="highlight erlang"><table><tr><td class="code"><pre><span class="line">-<span class="params">(BOOL)</span> sendReq:<span class="params">(BaseReq*)</span>req</span><br></pre></td></tr></table></figure>

<p>下面是接入微信支付的文档，遇到问题的时候可以查阅相关文档。</p>
<p><a target="_blank" rel="noopener" href="https://pay.weixin.qq.com/wiki/doc/api/app/app.php?chapter=8_1#">微信支付开发文档</a></p>
<p><a target="_blank" rel="noopener" href="https://open.weixin.qq.com/cgi-bin/showdocument?action=dir_list&t=resource/res_list&verify=1&id=open1419317782&token=&lang=zh_CN">微信支付开放平台</a></p>
<h5 id="2-应用内购-IAP"><a href="#2-应用内购-IAP" class="headerlink" title="2. 应用内购 IAP"></a>2. 应用内购 IAP</h5><p>在介绍应用内购之前需要明确下哪些商品是属于内购范围，应用内购主要是指购买应用内需要付费使用的产品功能或虚拟商品&#x2F;服务，但是那些实体商品或者购买来不是在应用内部使用的虚拟商品都不是IAP所涵盖的范围，苹果有明确规定在应用内适用的虚拟商品或者服务必须使用IAP进行购买支付，不允许使用包括Apple Pay在内的其它第三方支付，也不允许以任何方式引导用户通过应用外渠道购买。</p>
<p>应用内购准备工作主要包括三个部分：</p>
<ul>
<li>配置内购商品</li>
<li>填写银行卡信息</li>
<li>配置沙盒账号</li>
</ul>
<h6 id="2-1-App，商品信息，银行卡信息，测试账号配置"><a href="#2-1-App，商品信息，银行卡信息，测试账号配置" class="headerlink" title="2.1 App，商品信息，银行卡信息，测试账号配置"></a>2.1 App，商品信息，银行卡信息，测试账号配置</h6><p>首先进入<a target="_blank" rel="noopener" href="https://itunesconnect.apple.com/">Itunes Connect</a>网站,在这之前需要确保你已经拥有了个人开发者账号，公司开发者账号，但是不能是企业级开发者账号，并且公司开发者账号下的Member权限不能进入。</p>
<p><img src="/2019/08/30/iOS-%E6%94%AF%E4%BB%98%E5%86%85%E8%B4%AD/0007.png"></p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="bullet">* </span>我的App主要用于管理自己的应用比如应用信息编辑，上架，下架操作。</span><br><span class="line"><span class="bullet">* </span>销售和趋势主要是来查看App在各个平台的下载量,收入等方面数据。</span><br><span class="line"><span class="bullet">* </span>付款和财务报告显示的是我们的收入以及付款等相关信息。</span><br><span class="line"><span class="bullet">* </span>用户和职能用于生成相应账号，例如苹果沙河测试账号。</span><br><span class="line"><span class="bullet">* </span>协议，税务和银行业务则是我们银行相关账户的信息设置。</span><br></pre></td></tr></table></figure>

<p><strong><strong>商品信息配置</strong></strong></p>
<p>创建应用在之前的《iOS 上架流程》中已经介绍过了，这里就不重复了，在创建完应用后进入下面的页面：</p>
<p><img src="/2019/08/30/iOS-%E6%94%AF%E4%BB%98%E5%86%85%E8%B4%AD/00011.png"></p>
<p>点击加号就可以准备添加内购商品了。</p>
<p>在AppStore中售卖的商品可以分成如下几类：消耗型，非消耗型，自动续期订购，非续期订购这几种，详细说明可以见下图：<br><img src="/2019/08/30/iOS-%E6%94%AF%E4%BB%98%E5%86%85%E8%B4%AD/0009.png"></p>
<p>填写对应的内购项目信息：</p>
<p><img src="/2019/08/30/iOS-%E6%94%AF%E4%BB%98%E5%86%85%E8%B4%AD/00012.png"></p>
<p>产品 ID 必须具有唯一性，通常我们使用Bundle Identidier作为前缀，后面拼接上唯一的商品名或者 ID，这里需要注意的是一旦建立一个内购商品，那么它的产品ID将永远被占用，即使产品被删除也会一直存在，所以配置的时候要格外慎重。另外还需要注意价格等级这个概念，内购商品的定价只能从苹果提供的价格等级去选择，这个价格等级是固定的，同一价格等级会对应各个国家的货币，内购商品的价格是根据 Apple ID 所在区域的货币进行结算。</p>
<p>最后还可以配置App Store推广的功能。这样用户就可以在App Store 内 App 的下载页面内直接购买应用的内购商品<br><img src="/2019/08/30/iOS-%E6%94%AF%E4%BB%98%E5%86%85%E8%B4%AD/00013.png"></p>
<p><strong><strong>银行卡信息配置</strong></strong></p>
<p>点击协议，税务和银行业务,进行银行卡信息配置。这里我们需要申请的是iOS Paid Application合同，这里主要有Contract Info(联系信息),Bank Info（银行信息）,Tax Info（税务信息）三大块。这部分配置可以参照<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/4f5f0b45b083">iOS内购一条龙——账户信息填写</a>来配置。</p>
<p><strong><strong>沙盒测试账号配置</strong></strong></p>
<p>沙盒在之前的支付宝，微信支付也提到过，为什么需要沙盒测试？因为如果我们用正式账号进行测试的话，即便是自己购买自己的东西，也会有30%的利润进入苹果的口袋，这对于测试那些比较贵的商品是很致命的，苹果为了解决这个问题，提供了一套沙盒体系，在沙盒里面，用户用的是沙盒账号，走的是沙盒接口，购买后的费用会原样退回。</p>
<p>从用户和职能入口进入添加沙盒测试的入口。</p>
<p><img src="/2019/08/30/iOS-%E6%94%AF%E4%BB%98%E5%86%85%E8%B4%AD/00014.png"><br><img src="/2019/08/30/iOS-%E6%94%AF%E4%BB%98%E5%86%85%E8%B4%AD/00015.png"></p>
<p>这里需要注意的是，电子邮件不能是已经注册过AppleId的邮箱，选择的地区会影响到结算的价格，如果需要测试多个不同地区的情况，可以申请多个不同地区的账号测试。沙盒测试不支持直接从AS下载的安装包，必须使用发布测试的ad hoc 证书或者Develop 证书签名过后的包，并且使用真机环境下进行测试。</p>
<p>在开始测试的时候先退出真机的App Store的真实Apple ID 账号，退出之后不需要在App Store 里面登录沙箱测试账号，然后去 App 里面测试购买商品，会弹出登录框，选择“使用现有的 Apple ID”然后登录沙箱测试账号，登录成功之后会弹出购买提示框，点击购买，然后会弹出提示框完成购买，弹窗上面有表明当前的环境是沙盒环境。</p>
<p><strong><strong>Xcode设置相关</strong></strong></p>
<p><img src="/2019/08/30/iOS-%E6%94%AF%E4%BB%98%E5%86%85%E8%B4%AD/0000012.png"><br><img src="/2019/08/30/iOS-%E6%94%AF%E4%BB%98%E5%86%85%E8%B4%AD/0000134.png"></p>
<h6 id="2-2-IAP-流程"><a href="#2-2-IAP-流程" class="headerlink" title="2.2 IAP 流程"></a>2.2 IAP 流程</h6><p>上面介绍了支付宝的交易流程，这里来看下IAP 流程。</p>
<p><img src="/2019/08/30/iOS-%E6%94%AF%E4%BB%98%E5%86%85%E8%B4%AD/000011.png"></p>
<ol>
<li>首先我们进入购买页面的时候会从我们自己的服务器那边拉取Product ID列表。 </li>
<li>拿到服务器返回的Product ID列表后会将这个列表发送到App Store获取用于展示的商品信息。</li>
<li>用户选中要购买的物品，这时候会向App Store发送一个交易请求。</li>
<li>App Store 查询该交易的有效性后会通过delegte回调应用的方法，在这个方法中，应用将交易添加到交易队列从而发起交易，同时由于添加了交易Observer所以App Store交易状态改变的时候会通过Observer通知应用。</li>
<li>App Store 调起弹窗让用户确认购买，输入密码，苹果服务器验证用户请求并从用户帐号扣款，一旦交易成功就会回调App, 通知购买成功，并把收据数据（里面记录了本次交易的证书和签名信息）写入到APP沙盒中。</li>
<li>APP从沙盒中获取服务器下发的收据信息，并将收据信息上传给业务服务器。（其实这里既可以直接在 App 端验证也可以让服务器去验证，但是现在大多数是放在后台去做这一步校验）</li>
<li>业务服务器在收到客户端上传上来的收据数据后，会去App Store检查收据的有效性，验证成功之后在后台收据需要和自己的订单号进行映射并且记录在数据库，之后每次验证之前都需要先判断收据是否存在，防止App端重复上传相同的收据，重复发放内购商品，这之后通知客户端，同时发放商品，客户端收到结果后将该交易从支付队列中移除。</li>
</ol>
<p>在获取商品列表的时候如果遇到获取不到商品信息的情况的话，可以从如下几个方面进行排查：</p>
<ol>
<li>确定内购商品是否添加到正确的App中，虽然很少会犯这个错误，但是还是需要检查下。</li>
<li>使用非越狱的真机进行测试，看下是否能够拉取到。</li>
<li>后台配置的App Bundle ID是否和当前应用的App Bundle ID 一致。</li>
</ol>
<h6 id="2-3-相关代码"><a href="#2-3-相关代码" class="headerlink" title="2.3 相关代码"></a>2.3 相关代码</h6><h6 id="2-3-1-导入相关库"><a href="#2-3-1-导入相关库" class="headerlink" title="2.3.1 导入相关库"></a>2.3.1 导入相关库</h6><p>支付需要用到StoreKit.framework，在开始的时候需要导入到项目中。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;</span><br><span class="line">    IDLIAPPurchSuccess    = <span class="number">0</span>,    <span class="comment">// 购买成功</span></span><br><span class="line">    IDLIAPPurchFailed     = <span class="number">1</span>,    <span class="comment">// 购买失败</span></span><br><span class="line">    IDLIAPPurchCancle     = <span class="number">2</span>,    <span class="comment">// 取消购买</span></span><br><span class="line">    IDLIAPPurchVerFailed  = <span class="number">3</span>,    <span class="comment">// 订单校验失败</span></span><br><span class="line">    IDLIAPPurchVerSuccess = <span class="number">4</span>,    <span class="comment">// 订单校验成功</span></span><br><span class="line">    IDLIAPPurchNotArrow   = <span class="number">5</span>,    <span class="comment">// 不允许内购</span></span><br><span class="line">&#125; IDLIAPPurchStatus;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="type">void</span> (^IDLIAPCompletionHandle)(IDLIAPPurchStatus status, <span class="built_in">NSData</span> *data);</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">IDLIAPManager</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">instancetype</span>)shareManager;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)purchWithID:(<span class="built_in">NSString</span> *)purchID completeHandle:(IDLIAPCompletionHandle)handle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#import <span class="string">&quot;IDLIAPManager.h&quot;</span></span></span><br><span class="line"><span class="meta">#import <span class="string">&lt;StoreKit/StoreKit.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">IDLIAPManager</span>()&lt; <span class="title">SKPaymentTransactionObserver</span> , <span class="title">SKProductsRequestDelegate</span> &gt; </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>  , <span class="keyword">readwrite</span>) IDLIAPCompletionHandle  completeHandler;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readwrite</span>) <span class="built_in">NSString</span>                *purchID;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">IDLIAPManager</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> mark - Singleton</span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)shareManager&#123;</span><br><span class="line">    <span class="keyword">static</span> IDLIAPManager *manager = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken,^&#123;</span><br><span class="line">        manager = [[IDLIAPManager alloc] init];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> manager;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> mark - Initializer</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)init&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="variable language_">super</span> init]) &#123;</span><br><span class="line">        [[<span class="built_in">SKPaymentQueue</span> defaultQueue] addTransactionObserver:<span class="keyword">self</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> mark - Dealloc</span></span><br><span class="line">- (<span class="type">void</span>)dealloc&#123;</span><br><span class="line">    [[<span class="built_in">SKPaymentQueue</span> defaultQueue] removeTransactionObserver:<span class="keyword">self</span>];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> mark - Public</span></span><br><span class="line">- (<span class="type">void</span>)purchWithID:(<span class="built_in">NSString</span> *)purchID completeHandle:(IDLIAPCompletionHandle)handle&#123;</span><br><span class="line">    <span class="keyword">if</span> (purchID) &#123;</span><br><span class="line">        <span class="comment">//先检查是否有付款权限</span></span><br><span class="line">        <span class="keyword">if</span> ([<span class="built_in">SKPaymentQueue</span> canMakePayments]) &#123;</span><br><span class="line">            <span class="keyword">self</span>.purchID = purchID;</span><br><span class="line">            <span class="keyword">self</span>.completeHandler = handle;</span><br><span class="line">            <span class="comment">//使用productIdentifiers 生成 SKProductsRequest</span></span><br><span class="line">            <span class="built_in">NSSet</span> *productIdentifiers = [<span class="built_in">NSSet</span> setWithArray:@[purchID]];</span><br><span class="line">            <span class="built_in">SKProductsRequest</span> *request = [[<span class="built_in">SKProductsRequest</span> alloc] initWithProductIdentifiers:productIdentifiers];</span><br><span class="line">            request.delegate = <span class="keyword">self</span>;</span><br><span class="line">            [request start];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//没有权限购买</span></span><br><span class="line">            [<span class="keyword">self</span> handleActionWithStatus:IDLIAPPurchNotArrow data:<span class="literal">nil</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> mark - Private</span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)handleActionWithStatus:(IDLIAPPurchStatus)status data:(<span class="built_in">NSData</span> *)data&#123;</span><br><span class="line">    <span class="keyword">if</span>(_completeHandler)&#123;</span><br><span class="line">        _completeHandler(status,data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> mark - SKProductsRequestDelegate</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//[request start] 通过这个回调返回，这里会返回配置的商品信息</span></span><br><span class="line">- (<span class="type">void</span>)productsRequest:(<span class="built_in">SKProductsRequest</span> *)request didReceiveResponse:(<span class="built_in">SKProductsResponse</span> *)response&#123;</span><br><span class="line">    <span class="built_in">NSArray</span> *product = response.products;</span><br><span class="line">    <span class="keyword">if</span>([product count] &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="built_in">SKProduct</span> *p = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">SKProduct</span> *pro <span class="keyword">in</span> product)&#123;</span><br><span class="line">        <span class="keyword">if</span>([pro.productIdentifier isEqualToString:_purchID])&#123;</span><br><span class="line">            p = pro;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">SKPayment</span> *payment = [<span class="built_in">SKPayment</span> paymentWithProduct:p];</span><br><span class="line">    [[<span class="built_in">SKPaymentQueue</span> defaultQueue] addPayment:payment]; <span class="comment">//这里发起一个购买的操作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果交易成功会通过之前监听的交易通知到这里</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> mark - SKPaymentTransactionObserver</span></span><br><span class="line">- (<span class="type">void</span>)paymentQueue:(<span class="built_in">SKPaymentQueue</span> *)queue updatedTransactions:(<span class="built_in">NSArray</span>&lt;<span class="built_in">SKPaymentTransaction</span> *&gt; *)transactions&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">SKPaymentTransaction</span> *tran <span class="keyword">in</span> transactions) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (tran.transactionState) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="built_in">SKPaymentTransactionStatePurchased</span>:</span><br><span class="line">                [<span class="keyword">self</span> completeTransaction:tran];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="built_in">SKPaymentTransactionStatePurchasing</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="built_in">SKPaymentTransactionStateRestored</span>:</span><br><span class="line">                [[<span class="built_in">SKPaymentQueue</span> defaultQueue] finishTransaction:tran];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="built_in">SKPaymentTransactionStateFailed</span>:</span><br><span class="line">                [<span class="keyword">self</span> failedTransaction:tran];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)completeTransaction:(<span class="built_in">SKPaymentTransaction</span> *)transaction&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSURL</span> *receiptUrl = [[<span class="built_in">NSBundle</span> mainBundle] appStoreReceiptURL];</span><br><span class="line">    <span class="built_in">NSData</span> *receiptData = [<span class="built_in">NSData</span> dataWithContentsOfURL:receiptUrl];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (receiptData &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 向自己的服务器验证购买凭证</span></span><br><span class="line">        <span class="comment">// 如果校验成功调用[[SKPaymentQueue defaultQueue] finishTransaction:transaction]; 结束交易</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)failedTransaction:(<span class="built_in">SKPaymentTransaction</span> *)transaction&#123;</span><br><span class="line">    <span class="keyword">if</span> (transaction.error.code != <span class="built_in">SKErrorPaymentCancelled</span>) &#123;</span><br><span class="line">        [<span class="keyword">self</span> handleActionWithStatus:SIAPPurchFailed data:<span class="literal">nil</span>];</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        [<span class="keyword">self</span> handleActionWithStatus:IDLIAPPurchCancle data:<span class="literal">nil</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    [[<span class="built_in">SKPaymentQueue</span> defaultQueue] finishTransaction:transaction];</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>为了不导致整个文章篇幅太长上面只是IAP的简要代码，真正的流程包括重试机制等。后续会把这部分代码整理下放到github上。</p>
<h6 id="2-4-内购过程中可能会遇到的问题"><a href="#2-4-内购过程中可能会遇到的问题" class="headerlink" title="2.4 内购过程中可能会遇到的问题"></a>2.4 内购过程中可能会遇到的问题</h6><p>这部分大家可以参阅：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/07b5ec193353">iOS 贝聊 IAP 实战之满地是坑</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/07b5ec193353">iOS 贝聊 IAP 实战之见坑填坑</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/847838cde48b">iOS 贝聊 IAP 实战之订单绑定</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.bombox.org/2018-07-14/ios-iap/">iOS内购掉单问题</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/entry/5b2a1eae6fb9a00e562c46ef">iOS 内购最新讲解</a></li>
<li><a target="_blank" rel="noopener" href="https://www.pupboss.com/ipa-tips-1/">iOS的应用内购买 iAP 坑 之一</a></li>
<li><a target="_blank" rel="noopener" href="https://xiaovv.me/2018/05/03/My-iOS-In-App-Purchase-Summarize/">iOS 内购总结</a></li>
</ul>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/iOS-%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/">iOS 理论基础</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/iOS-理论基础/">iOS 理论基础</a>
  </div>

</div>



<div class="comments-count">
	
	  	<span></span>
		<a href="/2019/08/30/iOS-支付内购/#comments" class="ds-thread-count comments-count-link" data-thread-key="2019/08/30/iOS-支付内购/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/08/28/iOS-推送总结/" title="iOS 推送总结" itemprop="url">iOS 推送总结</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Edgar" target="_blank" itemprop="author">Edgar</a>
		
  <p class="article-time">
    <time datetime="2019-08-27T18:00:39.000Z" itemprop="datePublished"> Published 2019-08-28</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h5 id="开篇叨叨"><a href="#开篇叨叨" class="headerlink" title="开篇叨叨"></a>开篇叨叨</h5><p>目前推送已经成为了大多数应用的标配，通过推送能够及时地将信息送达到用户手中，可以说极大多数的产品运营都会借助推送功能来提升产品的打开率、使用率、存活率。 该篇博客将从如下几个方面对推送进行比较细致得介绍：</p>
<ol>
<li>推送的种类</li>
<li>本地推送和远程推送</li>
<li>远程推送的服务扩展和内容扩展</li>
</ol>
<h5 id="推送的种类"><a href="#推送的种类" class="headerlink" title="推送的种类"></a>推送的种类</h5><p>在iOS开发中一般会遇到如下的三种推送类型：</p>
<ul>
<li><p>在线推送：在线推送一般指的是消息通过应用自建的网络长链接通道推送到应用本身。这种推送是应用自身的行为与苹果系统无关，与设置中是否打开“通知”无关，是基于自建的长链接来实现的，这个不是这篇文章的重点。后续如果有机会会另外开一篇博客专门介绍在线推送的细节。</p>
</li>
<li><p>本地推送：这种推送是应用自身行为，不需要设备联网，也不经过APNs，但是它需要设备打开”通知”设置，比较常见的比如闹钟通知，待办事项提醒等。</p>
</li>
<li><p>远程推送：远程推送是这篇博客的重心，它需要开启“通知”设置，并且需要联网状态，因为它需要设备与APNs保持着长链接。远程推送又成为离线推送，当APP在离线状体（kill掉进程、切到后台、锁屏）时可以正常收到推送的消息。</p>
</li>
</ul>
<p>远程推送还可以细分为两种类型：普通远程推送和静默远程推送：<br>普通远程推送在收到推送的时候有文字和声音，点开通知，进入应用后才会执行：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="string">[UNUserNotificationCenterDelegate didReceiveNotificationResponse:withCompletionHandler:]</span></span><br></pre></td></tr></table></figure>
<p>而静默推送是没有文字和声音的，在不点开通知，不打开应用的情况下就能执行,用户完全感知不到。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="string">[UIApplicationDelegate application:didReceiveRemoteNotification:fetchCompletionHandler:]</span> </span><br></pre></td></tr></table></figure>

<p>下面是几种推送的简要对比：</p>
<p>|推送类型|是否需要打开“通知”|是否需要APNs|是否需要在前台|<br>|-|-|-|-|-|<br>|在线推送|不需要|不需要|需要|<br>|远程推送|需要|需要|不需要|<br>|本地推送|需要|不需要|不需要|</p>
<h5 id="本地推送"><a href="#本地推送" class="headerlink" title="本地推送"></a>本地推送</h5><ul>
<li>发送本地推送:</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="operator">-</span> (void)sendLocalNotification &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">NSString</span> <span class="operator">*</span>title <span class="operator">=</span> @<span class="string">&quot;本地推送通知-title&quot;</span>;</span><br><span class="line">    <span class="type">NSString</span> <span class="operator">*</span>subtitle <span class="operator">=</span> @<span class="string">&quot;本地推送通知-subtitle&quot;</span>;</span><br><span class="line">    <span class="type">NSString</span> <span class="operator">*</span>body <span class="operator">=</span> @<span class="string">&quot;这是一条本地推送通知，请查收&quot;</span>;</span><br><span class="line">    <span class="type">NSInteger</span> badge <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">NSInteger</span> timeInteval <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">    <span class="type">NSDictionary</span> <span class="operator">*</span>userInfo <span class="operator">=</span> @&#123;@<span class="string">&quot;userid&quot;</span>: @<span class="string">&quot;123456&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">@available</span>(<span class="keyword">iOS</span> <span class="number">10.0</span>, <span class="operator">*</span>)) &#123;</span><br><span class="line">        <span class="comment">// 1.创建通知内容</span></span><br><span class="line">        <span class="type">UNMutableNotificationContent</span> <span class="operator">*</span>content <span class="operator">=</span> [[<span class="type">UNMutableNotificationContent</span> alloc] <span class="keyword">init</span>];</span><br><span class="line">        content.sound <span class="operator">=</span> [<span class="type">UNNotificationSound</span> defaultSound];<span class="comment">//通知的声音时长必须在30s内，否则将被默认声音替换，并且需要注意声音文件必须放到main bundle中</span></span><br><span class="line">        content.title <span class="operator">=</span> title;</span><br><span class="line">        content.subtitle <span class="operator">=</span> subtitle;</span><br><span class="line">        content.body <span class="operator">=</span> body;</span><br><span class="line">        content.badge <span class="operator">=</span> @(badge);</span><br><span class="line">        content.userInfo <span class="operator">=</span> userInfo;</span><br><span class="line">        <span class="comment">// 2.设置通知附件内容</span></span><br><span class="line">        <span class="type">NSError</span> <span class="operator">*</span>error <span class="operator">=</span> <span class="literal">nil</span>;</span><br><span class="line">        <span class="type">NSString</span> <span class="operator">*</span>path <span class="operator">=</span> [[<span class="type">NSBundle</span> mainBundle] pathForResource:@<span class="string">&quot;testImage&quot;</span> ofType:@<span class="string">&quot;png&quot;</span>];</span><br><span class="line">        <span class="type">UNNotificationAttachment</span> <span class="operator">*</span>attr <span class="operator">=</span> [<span class="type">UNNotificationAttachment</span> attachmentWithIdentifier:@<span class="string">&quot;attr&quot;</span> <span class="type">URL</span>:[<span class="type">NSURL</span> fileURLWithPath:path] options:<span class="literal">nil</span> error:<span class="operator">&amp;</span>error];</span><br><span class="line">        <span class="keyword">if</span> (error) &#123;</span><br><span class="line">            <span class="comment">//附件添加错误</span></span><br><span class="line">        &#125;</span><br><span class="line">        content.attachments <span class="operator">=</span> @[attr];</span><br><span class="line">        content.launchImageName <span class="operator">=</span> @<span class="string">&quot;icon_launch&quot;</span>;</span><br><span class="line">        <span class="comment">// 3.触发模式</span></span><br><span class="line">        <span class="type">UNTimeIntervalNotificationTrigger</span> <span class="operator">*</span>trigger <span class="operator">=</span> [<span class="type">UNTimeIntervalNotificationTrigger</span> triggerWithTimeInterval:timeInteval repeats:<span class="type">NO</span>];</span><br><span class="line">        <span class="comment">// 4.设置UNNotificationRequest</span></span><br><span class="line">        <span class="type">UNNotificationRequest</span> <span class="operator">*</span>request <span class="operator">=</span> [<span class="type">UNNotificationRequest</span> requestWithIdentifier:kLocalNotificationReqestIdentifer content:content trigger:trigger];</span><br><span class="line">        <span class="comment">// 5.把通知加到UNUserNotificationCenter, 到指定触发点会被触发</span></span><br><span class="line">        [[<span class="type">UNUserNotificationCenter</span> currentNotificationCenter] addNotificationRequest:request withCompletionHandler:<span class="operator">^</span>(<span class="type">NSError</span> <span class="operator">*</span> _Nullable error) &#123;&#125;];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">UILocalNotification</span> <span class="operator">*</span>localNotification <span class="operator">=</span> [[<span class="type">UILocalNotification</span> alloc] <span class="keyword">init</span>];</span><br><span class="line">        <span class="comment">// 1.设置触发时间,如果立即触发则不用设置该项</span></span><br><span class="line">        localNotification.timeZone <span class="operator">=</span> [<span class="type">NSTimeZone</span> defaultTimeZone];</span><br><span class="line">        localNotification.fireDate <span class="operator">=</span> [<span class="type">NSDate</span> dateWithTimeIntervalSinceNow:<span class="number">5</span>];</span><br><span class="line">        <span class="comment">// 2.设置通知标题</span></span><br><span class="line">        localNotification.alertBody <span class="operator">=</span> title;</span><br><span class="line">        <span class="comment">// 3.设置通知动作按钮的标题</span></span><br><span class="line">        localNotification.alertAction <span class="operator">=</span> @<span class="string">&quot;详情&quot;</span>;</span><br><span class="line">        <span class="comment">// 4.设置提醒的声音</span></span><br><span class="line">        localNotification.soundName <span class="operator">=</span><span class="type">UILocalNotificationDefaultSoundName</span>;</span><br><span class="line">        <span class="comment">// 5.设置通知的 传递的userInfo</span></span><br><span class="line">        localNotification.userInfo <span class="operator">=</span> userInfo;</span><br><span class="line">        <span class="comment">// 6.在规定的日期触发通知</span></span><br><span class="line">        [[<span class="type">UIApplication</span> sharedApplication] scheduleLocalNotification:localNotification];</span><br><span class="line">        <span class="comment">// 7.立即触发一个通知</span></span><br><span class="line">        <span class="comment">//[[UIApplication sharedApplication] presentLocalNotificationNow:localNotification];</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>AppDelegate 回调：</li>
</ul>
<p>iOS 10之前：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果应用已经完全退出：</span></span><br><span class="line">- (<span class="type">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions;</span><br><span class="line"><span class="comment">//获取userInfo可以通过如下方式获取：</span></span><br><span class="line"><span class="comment">// NSDictionary *userInfoLocal = (NSDictionary *)[launchOptions objectForKey:UIApplicationLaunchOptionsLocalNotificationKey];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果应用还在运行，不论是在前台还是后台运行都会调用如下方法</span></span><br><span class="line">- (<span class="type">void</span>)application:(<span class="built_in">UIApplication</span> *)application didReceiveLocalNotification:(<span class="built_in">UILocalNotification</span> *)notification;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>iOS 10之后：</p>
<figure class="highlight erlang"><table><tr><td class="code"><pre><span class="line">- <span class="params">(void)</span>userNotificationCenter:<span class="params">(UNUserNotificationCenter *)</span>center willPresentNotification:<span class="params">(UNNotification *)</span>notification withCompletionHandler:<span class="params">(void (^)</span><span class="params">(UNNotificationPresentationOptions options)</span>)completionHandler;</span><br><span class="line"></span><br><span class="line">- <span class="params">(void)</span>userNotificationCenter:<span class="params">(UNUserNotificationCenter *)</span>center didReceiveNotificationResponse:<span class="params">(UNNotificationResponse *)</span>response withCompletionHandler:<span class="params">(void(^)(void)</span>)completionHandler;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="远程推送"><a href="#远程推送" class="headerlink" title="远程推送"></a>远程推送</h5><p>首先先放上官方远程推送的指导链接<a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/APNSOverview.html#//apple_ref/doc/uid/TP40008194-CH8-SW1">APNs Overview</a></p>
<h6 id="远程推送证书申请"><a href="#远程推送证书申请" class="headerlink" title="远程推送证书申请"></a>远程推送证书申请</h6><p>关于证书的申请可以参照下面这篇博客，写得比较详细之前也是参照这篇博客进行配置的。<br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/c60eb29db67e?utm_campaign=maleskine&utm_content=note&utm_medium=seo_notes&utm_source=recommendation">iOS 远程推送证书详细制作流程</a></p>
<h6 id="远程推送流程"><a href="#远程推送流程" class="headerlink" title="远程推送流程"></a>远程推送流程</h6><p>远程推送涉及到如下几个方面：</p>
<ol>
<li>iOS 设备</li>
<li>APNs</li>
<li>业务推送服务端</li>
</ol>
<p>简单将整个推送的数据流向可以分成如下三个步骤：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1.</span> 业务推送服务端将消息先发送到苹果的APNs</span><br><span class="line"><span class="bullet">2.</span> 由苹果的APNs将消息推送到客户iOS设备端</span><br><span class="line"><span class="bullet">3.</span> 由iOS系统将接收到的消息传递给相应的App</span><br></pre></td></tr></table></figure>
<p>如下图所示：<br><img src="/2019/08/28/iOS-%E6%8E%A8%E9%80%81%E6%80%BB%E7%BB%93/00001.png"></p>
<p>APNs是Apple Push Notification service(苹果推送通知服务）的缩写，在Android平台上，推送是靠应用自身在后台维持客户端与业务推送服务器之间的一个长链接来实现的，但是在iOS系统中为了节省手机电池电量的损耗，系统不允许应用在后台进行过多的操作，一旦应用进入后台，系统只会分配少量时间给应用做必要的收尾工作，虽然我们可以再次申请，但是也是难以做到在后台长期驻留的，应用进入后台后虽然还不会从内存中移除，但是已经不运行任何代码了，这就导致了一旦应用进入后台将不能收到实时的信息。为了解决这个问题苹果推出了APNs，iOS系统自己做了个长连接，依托一个或几个系统常驻内存的进程运作，保持与APNs之间的通讯，接管所有应用的消息推送，独立于应用之外，而且这种长连接即使在手机休眠的时候也一直保持，iOS设备上的所有应用共用这一套长链接，包括iOS版本更新提示,手机时钟校准什么的也都是通过这个链接通知到设备上，设备上的应用通过deviceToken进行区分。</p>
<p>下面是远程推送的详细过程：<br><img src="/2019/08/28/iOS-%E6%8E%A8%E9%80%81%E6%80%BB%E7%BB%93/00005.png"></p>
<p>在我们应用启动的时候会调用向iOS系统请求deviceToken,iOS系统再将请求转发给APNs服务，这时候APNs在对设备进行校验之后就会把当前设备加入到Push服务的设备列表中，同时返给我们一个deviceToken。<br>下面是请求deviceToken的代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="operator">-</span> (void)registerForRemoteNotifications:(<span class="type">UIApplication</span> <span class="operator">*</span>)application&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">@available</span>(<span class="keyword">iOS</span> <span class="number">10.0</span>, <span class="operator">*</span>)) &#123;</span><br><span class="line">        <span class="type">UNAuthorizationOptions</span> authOptions <span class="operator">=</span> <span class="type">UNAuthorizationOptionAlert</span><span class="operator">|</span></span><br><span class="line">                                            <span class="type">UNAuthorizationOptionSound</span><span class="operator">|</span></span><br><span class="line">                                            <span class="type">UNAuthorizationOptionBadge</span>;</span><br><span class="line">        [[<span class="type">UNUserNotificationCenter</span> currentNotificationCenter] requestAuthorizationWithOptions:authOptions completionHandler:<span class="operator">^</span>(<span class="type">BOOL</span> granted, <span class="type">NSError</span> <span class="operator">*</span> _Nullable error) &#123;</span><br><span class="line">            <span class="keyword">if</span> (error) &#123;</span><br><span class="line">                <span class="comment">//........</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(<span class="operator">!</span>granted)&#123;</span><br><span class="line">                <span class="comment">//用户关闭了权限</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;];</span><br><span class="line">        [<span class="type">UNUserNotificationCenter</span> currentNotificationCenter].delegate <span class="operator">=</span> <span class="keyword">self</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">UIUserNotificationType</span> allNotificationTypes <span class="operator">=</span></span><br><span class="line">        (<span class="type">UIUserNotificationTypeSound</span> <span class="operator">|</span> <span class="type">UIUserNotificationTypeAlert</span> <span class="operator">|</span> <span class="type">UIUserNotificationTypeBadge</span>);</span><br><span class="line">        <span class="type">UIUserNotificationSettings</span> <span class="operator">*</span>settings <span class="operator">=</span></span><br><span class="line">        [<span class="type">UIUserNotificationSettings</span> settingsForTypes:allNotificationTypes categories:<span class="literal">nil</span>];</span><br><span class="line">        [application registerUserNotificationSettings:settings];</span><br><span class="line">    &#125;</span><br><span class="line">    [application registerForRemoteNotifications];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在注册远程通知后，会通过如下的delegate方法返回deviceToken：</p>
<figure class="highlight erlang"><table><tr><td class="code"><pre><span class="line">- <span class="params">(void)</span>application:<span class="params">(UIApplication *)</span>application didRegisterForRemoteNotificationsWithDeviceToken:<span class="params">(NSData *)</span>deviceToken;</span><br></pre></td></tr></table></figure>

<p>如果获取失败则会通过下面的方法返回错误信息：</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">- (void)<span class="built_in">application</span>:(UIApplication *)<span class="built_in">application</span> didFailToRegisterForRemoteNotificationsWithError:(NSError *)<span class="keyword">error</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>deviceToken在app卸载后重装等情况时会变化，因此为确保deviceToken变化后app仍然能够正常接收服务器端发送的通知，建议每次启动应用都将获取到的deviceToken传给业务推送服务器，业务服务器将会这些deviceToken存到数据库中。当有需要被推送的消息时，业务推送服务器会按照苹果官方的消息格式组织消息内容，并带上目标应用的deviceToken 一并发给APNs服务器，下面是一个消息的内容例子：</p>
<p><img src="/2019/08/28/iOS-%E6%8E%A8%E9%80%81%E6%80%BB%E7%BB%93/00007.png"></p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;aps&quot;</span>:&#123;</span><br><span class="line">        <span class="string">&quot;alert&quot;</span>:&#123;</span><br><span class="line">            <span class="string">&quot;title&quot;</span>:<span class="string">&quot;这是一条推送测试消息标题&quot;</span>,</span><br><span class="line">            <span class="string">&quot;subtitle&quot;</span>:<span class="string">&quot;这是一条推送测试消息副标题&quot;&quot;,</span></span><br><span class="line">            <span class="string">&quot;body&quot;</span>:<span class="string">&quot;这是一条推送测试消息&quot;</span>,</span><br><span class="line">            <span class="string">&quot;title-loc-key&quot;</span>:<span class="string">&quot;TITLE_LOC_KEY&quot;</span>,</span><br><span class="line">            <span class="string">&quot;title-loc-args&quot;</span>:[</span><br><span class="line">                <span class="string">&quot;idl_01&quot;</span>,</span><br><span class="line">                <span class="string">&quot;idl_02&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="string">&quot;loc-key&quot;</span>:<span class="string">&quot;LOC_KEY&quot;</span>,</span><br><span class="line">            <span class="string">&quot;loc-args&quot;</span>:[</span><br><span class="line">                <span class="string">&quot;idl_01&quot;</span>,</span><br><span class="line">                <span class="string">&quot;idl_02&quot;</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;sound&quot;</span>:<span class="string">&quot;sound01.wav&quot;</span>,</span><br><span class="line">        <span class="string">&quot;badge&quot;</span>:<span class="number">1</span>,</span><br><span class="line">        <span class="string">&quot;mutable-content&quot;</span>:<span class="number">1</span>,</span><br><span class="line">        <span class="string">&quot;category&quot;</span>:<span class="string">&quot;realtime&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;msgid&quot;</span>:<span class="string">&quot;123456&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>payload在iOS8之前最大限制是256字节，iOS8之后大小限制为2K字节，目前payload大小可以达到4K,对于VoIP最大尺寸可以达到5K.<br><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/26233730/apn-apple-push-notification-payload-size-limit">APN (Apple Push Notification) payload size limit</a></p>
<p>APNs收到业务推送服务器发来的消息后，会在自己维护的Push设备列表中查找，找到匹配的设备后，由于我们的设备和APNs维持一个基于SSL协议的TCP流通讯长连接，APNs就可以通过这个长链接将新消息推送到我们设备上，然后由系统将消息呈现出来。</p>
<p>但是如果推送的时候deviceToken对应的机器在APNs服务器上处于离线状态，苹果会保存推送信息一段时间，在离线的设备恢复在线状态时，重新将推送信息到该机器。对于连续推送的情况下，APNs永远只存储最新的一条，上一条信息将会被抛弃，如果某个设备长时间不在线，APNs也会将消息丢掉。如果有多条推送任务时，苹果推荐使用单个连接持续发送，而不是重复的开关连接，否则会被苹果认为DOS攻击而断开连接。如果有多台服务器，可以并发连接到APNS，分摊推送任务，可以更高效的执行任务，发送多条推送任务时，如果其中有一条推送使用了错误的deviceToken，那么这条连接就会被断掉，导致后面的推送任务停止执行。</p>
<p>上面介绍的是正常的流程，但是如果应用从设备卸载后推送的消息又如何处理呢？如何让APNs和业务推送服务器都知道不去向这台卸载了应用的设备推送消息呢？这是通过APNs的Feedback service，APNs会持续的更新Feedback service的列表，当我们的业务推送服务器将信息发给APNs推送到我们的设备时，如果这时设备无法将消息推送到指定的应用，就会向APNs服务器报告一个反馈信息，而这个信息就记录在Feedback service中。因此业务推送服务器可以通过定时的去检测Feedback service的列表，然后删除在自己数据库中记录的存在于反馈列表中的 deviceToken，从而不再向这些设备发送推送信息，下面是从Feedback Service中读取到的过期设备的信息结构：<br><img src="/2019/08/28/iOS-%E6%8E%A8%E9%80%81%E6%80%BB%E7%BB%93/00009.png"></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">第一部分是设备失效后的时间信息</span><br><span class="line">第二个部分是deviceToken的长度</span><br><span class="line">第三部分就是失效的deviceToken</span><br></pre></td></tr></table></figure>

<p>如果一个消息发送失败呢? 比如通知格式不正确或APNs无法解析，这时候APNs 会在大约 500ms 后断掉链接，在断链前发送的消息还没到达设备的消息也会发送失败，并在断链之前返回一个错误应答，带上发消息时的 Identifier 和一个错误码。如下图所示，这样我们就可以定位到到底那条消息发送失败，以及失败的错误码了，我们就可以根据返回的错误信息，对这部分消息进行重发，重发是通过发送缓存做的，维持一个较小的缓存，当收到APNs的错误信息时，从缓存中去除出错的那一条消息，剩下的进行重发。</p>
<p><img src="/2019/08/28/iOS-%E6%8E%A8%E9%80%81%E6%80%BB%E7%BB%93/00008.png"></p>
<p>下面是可能返回的错误码：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Status</span>       codeDescription</span><br><span class="line"><span class="number">0</span>              No errors encountered</span><br><span class="line"><span class="number">1</span>              Processing error</span><br><span class="line"><span class="number">2</span>              Missing device token</span><br><span class="line"><span class="number">3</span>              Missing topic</span><br><span class="line"><span class="number">4</span>              Missing payload</span><br><span class="line"><span class="number">5</span>              Invalid token <span class="built_in">size</span></span><br><span class="line"><span class="number">6</span>              Invalid topic <span class="built_in">size</span></span><br><span class="line"><span class="number">7</span>              Invalid payload <span class="built_in">size</span></span><br><span class="line"><span class="number">8</span>              Invalid token</span><br><span class="line"><span class="number">10</span>             Shutdown</span><br><span class="line"><span class="number">255</span>            <span class="keyword">None</span> (unknown)</span><br></pre></td></tr></table></figure>


<p>设备收到消息会回调应用中的方法：</p>
<figure class="highlight erlang"><table><tr><td class="code"><pre><span class="line">// iOS&lt;<span class="number">10</span>时，且app被完全杀死</span><br><span class="line">- <span class="params">(BOOL)</span>application:<span class="params">(UIApplication *)</span>application didFinishLaunchingWithOptions:<span class="params">(NSDictionary *)</span>launchOptions;</span><br><span class="line"></span><br><span class="line">// 支持iOS7及以上系统</span><br><span class="line">- <span class="params">(void)</span>application:<span class="params">(UIApplication *)</span>application didReceiveRemoteNotification:<span class="params">(NSDictionary *)</span>userInfo fetchCompletionHandler:<span class="params">(void (^)</span><span class="params">(UIBackgroundFetchResult)</span>)completionHandler;</span><br><span class="line"></span><br><span class="line">//  iOS&gt;=10: app在前台获取到通知</span><br><span class="line">- <span class="params">(void)</span>userNotificationCenter:<span class="params">(UNUserNotificationCenter *)</span>center willPresentNotification:<span class="params">(UNNotification *)</span>notification withCompletionHandler:<span class="params">(void (^)</span><span class="params">(UNNotificationPresentationOptions)</span>)completionHandler;</span><br><span class="line"></span><br><span class="line">//  iOS&gt;=10: 点击通知进入app时触发（杀死/切到后台唤起）</span><br><span class="line">- <span class="params">(void)</span>userNotificationCenter:<span class="params">(UNUserNotificationCenter *)</span>center didReceiveNotificationResponse:<span class="params">(UNNotificationResponse *)</span>response withCompletionHandler:<span class="params">(void (^)</span><span class="params">(void)</span>)completionHandler;</span><br></pre></td></tr></table></figure>

<h5 id="Notification-Extension-通知扩展"><a href="#Notification-Extension-通知扩展" class="headerlink" title="Notification Extension 通知扩展"></a>Notification Extension 通知扩展</h5><p>通知扩展是iOS 10之后添加的功能，它包括两个方面：</p>
<table>
<thead>
<tr>
<th>扩展</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>通知服务扩展（UNNotificationServiceExtension）</td>
<td>在收到通知后且展示通知前允许开发者做一些事情，比如添加附件、加载网络请求等</td>
</tr>
<tr>
<td>通知内容扩展（UNNotificationContentExtension）</td>
<td>在展示通知时展示一个自定义的用户界面</td>
</tr>
</tbody></table>
<p><img src="/2019/08/28/iOS-%E6%8E%A8%E9%80%81%E6%80%BB%E7%BB%93/000010.png"></p>
<h6 id="通知服务扩展"><a href="#通知服务扩展" class="headerlink" title="通知服务扩展"></a>通知服务扩展</h6><p><img src="/2019/08/28/iOS-%E6%8E%A8%E9%80%81%E6%80%BB%E7%BB%93/000011.png"></p>
<p>上图是Service Extension的大致流程图，Notification的playload下发到达设备之前会经过Notification Service Extension,因此我们可以用extension修改推送内容，下载推送相关的资源，可以在extension中解密和加密的数据或下载推送相关的图片</p>
<p>在NotificationService.m文件中，有两个回调方法：</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 系统接到通知后，有最多30秒在这里重写通知内容,一般我们会在这里下载附件</span></span><br><span class="line">- (<span class="keyword">void</span>)didReceiveNotificationRequest:(UNNotificationRequest *)request withContentHandler:(<span class="keyword">void</span> (^)(UNNotificationContent *contentToDeliver))contentHandler;</span><br><span class="line"><span class="comment">// 如果修改内容任务没有完成，系统会调用 serviceExtensionTimeWillExpire 方法，给我们提供最后一次提供修改内容的机会。如果还是没有修改远程推送成功，系统将会展示远程推送最原始的内容。</span></span><br><span class="line">- (<span class="keyword">void</span>)serviceExtensionTimeWillExpire;</span><br></pre></td></tr></table></figure>

<p>下面是NotificationService的一个模版：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&quot;NotificationService.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NotificationService</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="type">void</span> (^contentHandler)(UNNotificationContent *contentToDeliver);</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) UNMutableNotificationContent *bestAttemptContent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NotificationService</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)didReceiveNotificationRequest:(UNNotificationRequest *)request withContentHandler:(<span class="type">void</span> (^)(UNNotificationContent * _Nonnull))contentHandler &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.contentHandler = contentHandler;</span><br><span class="line">    <span class="keyword">self</span>.bestAttemptContent = [request.content mutableCopy];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//修改UNNotificationContent内容</span></span><br><span class="line">    <span class="keyword">self</span>.bestAttemptContent.title = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;%@ [title modified]&quot;</span>, <span class="keyword">self</span>.bestAttemptContent.title];</span><br><span class="line">        </span><br><span class="line">    <span class="built_in">NSDictionary</span> *userInfo =  <span class="keyword">self</span>.bestAttemptContent.userInfo;</span><br><span class="line">    <span class="built_in">NSString</span> *mediaUrl = userInfo[<span class="string">@&quot;media&quot;</span>][<span class="string">@&quot;url&quot;</span>];</span><br><span class="line">    <span class="built_in">NSString</span> *mediaType = userInfo[<span class="string">@&quot;media&quot;</span>][<span class="string">@&quot;type&quot;</span>];</span><br><span class="line">    <span class="keyword">if</span> (!mediaUrl.length) &#123;</span><br><span class="line">        <span class="keyword">self</span>.contentHandler(<span class="keyword">self</span>.bestAttemptContent);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        [<span class="keyword">self</span> loadAttachmentForUrlString:mediaUrl withType:mediaType completionHandle:^(UNNotificationAttachment *attach) &#123;</span><br><span class="line">            <span class="keyword">if</span> (attach) &#123;</span><br><span class="line">                <span class="keyword">self</span>.bestAttemptContent.attachments = [<span class="built_in">NSArray</span> arrayWithObject:attach];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">self</span>.contentHandler(<span class="keyword">self</span>.bestAttemptContent);</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)loadAttachmentForUrlString:(<span class="built_in">NSString</span> *)urlStr withType:(<span class="built_in">NSString</span> *)type completionHandle:(<span class="type">void</span>(^)(UNNotificationAttachment *attach))completionHandler &#123;</span><br><span class="line">    __block UNNotificationAttachment *attachment = <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">NSURL</span> *attachmentURL = [<span class="built_in">NSURL</span> URLWithString:urlStr];</span><br><span class="line">    <span class="built_in">NSString</span> *fileExt = [<span class="keyword">self</span> getfileExtWithMediaType:type];</span><br><span class="line">    <span class="built_in">NSURLSession</span> *session = [<span class="built_in">NSURLSession</span> sessionWithConfiguration:[<span class="built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration]];</span><br><span class="line">    [[session downloadTaskWithURL:attachmentURL completionHandler:^(<span class="built_in">NSURL</span> *temporaryFileLocation, <span class="built_in">NSURLResponse</span> *response, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">        <span class="keyword">if</span> (error) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;加载多媒体失败 %@&quot;</span>, error.localizedDescription);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">NSFileManager</span> *fileManager = [<span class="built_in">NSFileManager</span> defaultManager];</span><br><span class="line">            <span class="built_in">NSURL</span> *localURL = [<span class="built_in">NSURL</span> fileURLWithPath:[temporaryFileLocation.path stringByAppendingString:fileExt]];</span><br><span class="line">            [fileManager moveItemAtURL:temporaryFileLocation toURL:localURL error:&amp;error];</span><br><span class="line">            <span class="built_in">NSMutableDictionary</span> * dict = [<span class="keyword">self</span>.bestAttemptContent.userInfo mutableCopy];</span><br><span class="line">            [dict setObject:[<span class="built_in">NSData</span> dataWithContentsOfURL:localURL] forKey:<span class="string">@&quot;image&quot;</span>];</span><br><span class="line">            <span class="keyword">self</span>.bestAttemptContent.userInfo = dict;</span><br><span class="line">            <span class="built_in">NSError</span> *attachmentError = <span class="literal">nil</span>;</span><br><span class="line">            attachment = [UNNotificationAttachment attachmentWithIdentifier:<span class="string">@&quot;attachment_downloaded&quot;</span> URL:localURL options:<span class="literal">nil</span> error:&amp;attachmentError];</span><br><span class="line">            <span class="keyword">if</span> (attachmentError) &#123;</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, attachmentError.localizedDescription);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        completionHandler(attachment);</span><br><span class="line">    &#125;] resume];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)serviceExtensionTimeWillExpire &#123;</span><br><span class="line">    <span class="keyword">self</span>.contentHandler(<span class="keyword">self</span>.bestAttemptContent);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>测试消息格式如下：这样就会把图片下载并缓存到本地。</p>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    <span class="string">&quot;aps&quot;</span>:&#123;</span><br><span class="line">        <span class="string">&quot;alert&quot;</span>:&#123;</span><br><span class="line">            <span class="string">&quot;title&quot;</span>:<span class="string">&quot;测试标题&quot;</span>,</span><br><span class="line">            <span class="string">&quot;subtitle&quot;</span>:<span class="string">&quot;子标题&quot;</span>,</span><br><span class="line">            <span class="string">&quot;body&quot;</span>:<span class="string">&quot;消息内容&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;sound&quot;</span>:<span class="string">&quot;default&quot;</span>,</span><br><span class="line">        <span class="string">&quot;badge&quot;</span>:<span class="number">1</span>,</span><br><span class="line">        <span class="string">&quot;mutable-content&quot;</span>:<span class="number">1</span>,</span><br><span class="line">        <span class="string">&quot;category&quot;</span>:<span class="string">&quot;CategoryIdentifier&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;msgid&quot;</span>:<span class="string">&quot;123456&quot;</span>,</span><br><span class="line">    <span class="string">&quot;media&quot;</span>:&#123;</span><br><span class="line">        <span class="string">&quot;type&quot;</span>:<span class="string">&quot;image&quot;</span>,</span><br><span class="line">        <span class="string">&quot;url&quot;</span>:<span class="string">&quot;https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1565629545485&amp;di=7905ab7e4e3d0f6e4bea6385a481adc5&amp;imgtype=0&amp;src=http%3A%2F%2Fimg4.duitang.com%2Fuploads%2Fitem%2F201409%2F08%2F20140908154922_Gw3h5.jpeg&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里需要注意如下几点：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1. didReceiveNotificationRequest里面加载数据的时间上限为30秒，如果在30秒时间内没有完成内容的加载，通知按系统默认形式弹出</span><br><span class="line">2. UNNotificationAttachment的url接收的是本地文件的url，因此如果图片使用的是网络上的url那么就需要加载到本地并将本地url赋给UNNotificationAttachment</span><br><span class="line">3. aps字符串中的mutable-content字段需要设置为1，才能修改</span><br><span class="line">4. 在对NotificationService进行debug时，需要在Xcode顶栏选择编译运行的target为NotificationService，否则无法进行实时debug。</span><br><span class="line">5. UNNotificationAttachment：attachment支持如下类型：</span><br><span class="line">   * 音频5M（kUTTypeWaveformAudio/kUTTypeMP3/kUTTypeMPEG4Audio/kUTTypeAudioInterchangeFileFormat）</span><br><span class="line">   * 图片10M（kUTTypeJPEG/kUTTypeGIF/kUTTypePNG）</span><br><span class="line">   * 视频50M（kUTTypeMPEG/kUTTypeMPEG2Video/kUTTypeMPEG4/kUTTypeAVIMovie）</span><br></pre></td></tr></table></figure>

<h6 id="通知内容扩展"><a href="#通知内容扩展" class="headerlink" title="通知内容扩展"></a>通知内容扩展</h6><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&quot;NotificationService.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NotificationService</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="type">void</span> (^contentHandler)(UNNotificationContent *contentToDeliver);</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) UNMutableNotificationContent *bestAttemptContent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NotificationService</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)didReceiveNotificationRequest:(UNNotificationRequest *)request withContentHandler:(<span class="type">void</span> (^)(UNNotificationContent * _Nonnull))contentHandler &#123;</span><br><span class="line">    <span class="keyword">self</span>.contentHandler = contentHandler;</span><br><span class="line">    <span class="keyword">self</span>.bestAttemptContent = [request.content mutableCopy];</span><br><span class="line">    <span class="comment">// 设置UNNotificationAction</span></span><br><span class="line">    UNNotificationAction * actionA  =[UNNotificationAction actionWithIdentifier:<span class="string">@&quot;ActionA&quot;</span> title:<span class="string">@&quot;RequiredStyle&quot;</span> options:UNNotificationActionOptionAuthenticationRequired];</span><br><span class="line">    UNNotificationAction * actionB = [UNNotificationAction actionWithIdentifier:<span class="string">@&quot;ActionB&quot;</span> title:<span class="string">@&quot;DestructiveStyle&quot;</span> options:UNNotificationActionOptionDestructive];</span><br><span class="line">    UNNotificationAction * actionC = [UNNotificationAction actionWithIdentifier:<span class="string">@&quot;ActionC&quot;</span> title:<span class="string">@&quot;ForegroundStyle&quot;</span> options:UNNotificationActionOptionForeground];</span><br><span class="line">    UNTextInputNotificationAction * actionD = [UNTextInputNotificationAction actionWithIdentifier:<span class="string">@&quot;ActionD&quot;</span></span><br><span class="line">                                                                                            title:<span class="string">@&quot;InputDestructiveStyle&quot;</span></span><br><span class="line">                                                                                          options:UNNotificationActionOptionDestructive</span><br><span class="line">                                                                             textInputButtonTitle:<span class="string">@&quot;Send&quot;</span></span><br><span class="line">                                                                             textInputPlaceholder:<span class="string">@&quot;input some words here ...&quot;</span>];</span><br><span class="line">    <span class="built_in">NSArray</span> *actionArr = [[<span class="built_in">NSArray</span> alloc] initWithObjects:actionA, actionB, actionC, actionD, <span class="literal">nil</span>];</span><br><span class="line">    <span class="built_in">NSArray</span> *identifierArr = [[<span class="built_in">NSArray</span> alloc] initWithObjects:<span class="string">@&quot;ActionA&quot;</span>, <span class="string">@&quot;ActionB&quot;</span>, <span class="string">@&quot;ActionC&quot;</span>, <span class="string">@&quot;ActionD&quot;</span>, <span class="literal">nil</span>];</span><br><span class="line">    UNNotificationCategory * notficationCategory = [UNNotificationCategory categoryWithIdentifier:<span class="string">@&quot;IDL_CategoryIdentifier&quot;</span></span><br><span class="line">                                                                                          actions:actionArr</span><br><span class="line">                                                                                intentIdentifiers:identifierArr</span><br><span class="line">                                                                                          options:UNNotificationCategoryOptionCustomDismissAction];</span><br><span class="line">    [[UNUserNotificationCenter currentNotificationCenter] setNotificationCategories:[<span class="built_in">NSSet</span> setWithObject:notficationCategory]];</span><br><span class="line">    <span class="comment">// 设置categoryIdentifier</span></span><br><span class="line">    <span class="keyword">self</span>.bestAttemptContent.categoryIdentifier = <span class="string">@&quot;IDL_CategoryIdentifier&quot;</span>;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//.......</span></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>


<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&quot;NotificationViewController.h&quot;</span></span></span><br><span class="line"><span class="meta">#import <span class="string">&lt;UserNotifications/UserNotifications.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="string">&lt;UserNotificationsUI/UserNotificationsUI.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NotificationViewController</span> () &lt;<span class="title">UNNotificationContentExtension</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NotificationViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="variable language_">super</span> viewDidLoad];</span><br><span class="line">    <span class="comment">//这里设置界面</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)didReceiveNotification:(UNNotification *)notification &#123;</span><br><span class="line">    <span class="built_in">NSData</span> *data = notification.request.content.userInfo[<span class="string">@&quot;xxx&quot;</span>];</span><br><span class="line">    <span class="comment">//这里根据收到的通知修改界面</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里处理事件</span></span><br><span class="line">- (<span class="type">void</span>)didReceiveNotificationResponse:(UNNotificationResponse *)response completionHandler:(<span class="type">void</span> (^)(UNNotificationContentExtensionResponseOption))completion &#123;</span><br><span class="line">    <span class="built_in">NSString</span> identifier = response.actionIdentifier;</span><br><span class="line">    <span class="keyword">if</span> ([identifier isEqualToString:<span class="string">@&quot;ActionA&quot;</span>]) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([response.actionIdentifier isEqualToString:<span class="string">@&quot;ActionB&quot;</span>]) &#123;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([response.actionIdentifier isEqualToString:<span class="string">@&quot;ActionC&quot;</span>]) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;  <span class="keyword">else</span> <span class="keyword">if</span> ([response.actionIdentifier isEqualToString:<span class="string">@&quot;ActionD&quot;</span>]) &#123;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        completion(UNNotificationContentExtensionResponseOptionDismiss);</span><br><span class="line">    &#125;</span><br><span class="line">    completion(UNNotificationContentExtensionResponseOptionDoNotDismiss);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)mediaPlay &#123;</span><br><span class="line">    <span class="comment">//按下播放按钮</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)mediaPause &#123;</span><br><span class="line">    <span class="comment">//按下停止播放按钮</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>需要注意的点：</p>
<ol>
<li>有如下几处CategoryIdentifier需要保持一致：</li>
</ol>
<p>*收到消息中的category字段</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;aps&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;category&quot;</span><span class="punctuation">:</span><span class="string">&quot;IDLCategoryIdentifier&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在NotificationService.m didReceiveNotificationRequest中设置category的值：</li>
</ul>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">self.bestAttemptContent.categoryIdentifier</span> = @<span class="string">&quot;IDLCategoryIdentifier&quot;</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>info.plist中关于category的配置</li>
</ul>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">NSE<span class="function"><span class="title">xtension</span> ---&gt;</span> NSE<span class="function"><span class="title">xtensionAttributes</span> --&gt;</span> UNN<span class="function"><span class="title">otificationExtensionCategory</span> ---&gt;</span> <span class="string">&quot;IDLCategoryIdentifier&quot;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>Notification Service Extension 的 target和Notification Conten Extension 的 target在配置中所支持的系统版本要在iOS10及以上</li>
</ol>
<h5 id="推送统计"><a href="#推送统计" class="headerlink" title="推送统计"></a>推送统计</h5><p>在推送业务服务端在push中加一个类似pushId的字段在Notification Service Extension 中的didReceiveNotificationRequest方法中获取self.bestAttemptContent.userInfo<br>从中获取到pushId并通过post请求发给推送业务服务端进行push到达率统计。</p>
<h5 id="如何提高消息送达率"><a href="#如何提高消息送达率" class="headerlink" title="如何提高消息送达率"></a>如何提高消息送达率</h5><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1.</span> 可以借助三方推送平台的统计功能，统计出每天送达率较高的时间段，在这个时间段内推送比较重要的，或者量比较大的消息</span><br><span class="line"><span class="bullet">2.</span> 通过APNs Feedback Service 定期清除错误的deviceToken</span><br><span class="line"><span class="bullet">3.</span> 我们在发送累计达到一定数值后sleep几秒，从而降低推送速率</span><br><span class="line"><span class="bullet">4.</span> 借助自建的在线推送渠道，如果用户在线则通过在线推送，只有用户不在线的情况下使用离线推送</span><br></pre></td></tr></table></figure>

<h5 id="各个版本推送演进过程"><a href="#各个版本推送演进过程" class="headerlink" title="各个版本推送演进过程"></a>各个版本推送演进过程</h5><ol>
<li>playload 容量变化</li>
</ol>
<table>
<thead>
<tr>
<th>版本</th>
<th>限制</th>
</tr>
</thead>
<tbody><tr>
<td>x &lt; iOS8</td>
<td>256字节</td>
</tr>
<tr>
<td>x &gt;&#x3D; iOS8 &amp;&amp; x &lt; iOS10</td>
<td>2KB</td>
</tr>
<tr>
<td>x &gt;&#x3D; iOS10</td>
<td>4KB</td>
</tr>
</tbody></table>
<ol start="2">
<li>推送通知呈现样式变化</li>
</ol>
<table>
<thead>
<tr>
<th>版本</th>
<th>呈现形式</th>
</tr>
</thead>
<tbody><tr>
<td>x &lt; iOS8</td>
<td>只有3个地方展示</td>
</tr>
<tr>
<td>x &gt;&#x3D; iOS8 &amp;&amp; x &lt; iOS10</td>
<td>提供Actions功能</td>
</tr>
<tr>
<td>x &gt;&#x3D; iOS10</td>
<td>提供快捷回复TextInput</td>
</tr>
</tbody></table>
<ol start="3">
<li>证书文件的有效期</li>
</ol>
<table>
<thead>
<tr>
<th>证书类型</th>
<th>有效期</th>
</tr>
</thead>
<tbody><tr>
<td>Development Push SSL Certificate</td>
<td>大概四个月</td>
</tr>
<tr>
<td>ProductionPush SSL Certificate</td>
<td>大约一年</td>
</tr>
</tbody></table>
<h5 id="Others"><a href="#Others" class="headerlink" title="Others"></a>Others</h5><ol>
<li>免费用户不能使用推送</li>
<li>模拟器不能测试推送</li>
<li>目前比较流行的三方推送平台：个推，极光，信鸽，Firebase 等</li>
<li>推送测试软件：SmartPush,Knuff都一样，随便选一个。</li>
</ol>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/iOS-%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/">iOS 理论基础</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/iOS-理论基础/">iOS 理论基础</a>
  </div>

</div>



<div class="comments-count">
	
	  	<span></span>
		<a href="/2019/08/28/iOS-推送总结/#comments" class="ds-thread-count comments-count-link" data-thread-key="2019/08/28/iOS-推送总结/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/08/26/Cocopods-使用/" title="Cocopods 使用" itemprop="url">Cocopods 使用</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Edgar" target="_blank" itemprop="author">Edgar</a>
		
  <p class="article-time">
    <time datetime="2019-08-25T17:58:47.000Z" itemprop="datePublished"> Published 2019-08-26</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p><a target="_blank" rel="noopener" href="https://github.com/CocoaPods/CocoaPods">Cocopods GitHub</a><br><a target="_blank" rel="noopener" href="https://guides.cocoapods.org/">Cocopods 使用说明</a></p>
<h5 id="开篇叨叨"><a href="#开篇叨叨" class="headerlink" title="开篇叨叨"></a><strong><strong>开篇叨叨</strong></strong></h5><p>一般一款软件都往往由几个人同时协作开发，并且开发期间会使用多个开源库，从而避免重复造轮子，这样可以加快开发的速度，但是这也带来了一个问题：如何管理这些依赖，这是一个十分浪费时间并且容易出错的工作，我们不但要定期管理这些三方库的更新，还需要往目标项目工程上添加三方库所需要的依赖库，对于某些开源库可能还需要添加某些编译参数。稍稍完备一点的编程语言一般都会引入依赖管理工具，来减轻这些负担。比如Java语言的Maven,Nodejs的npm，Android的Gradle，Ruby的gem。iOS也有它的依赖管理工具 — CocoaPods。</p>
<h5 id="CocoaPods-安装"><a href="#CocoaPods-安装" class="headerlink" title="CocoaPods 安装"></a><strong><strong>CocoaPods 安装</strong></strong></h5><ol>
<li>CocoaPods 是使用Ruby 实现的，它使用gem命令进行下载并安装，在安装前最好使用下面的命令来更新下gem</li>
</ol>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line">sudo gem <span class="keyword">update</span> --<span class="keyword">system</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>gem是从对应的Ruby软件库中下载对应的软件的，默认情况下使用的是<a target="_blank" rel="noopener" href="https://rubygems.org/">https://rubygems.org</a>它托管在亚马逊云服务上，国内可能会被墙，所以一般会使用国内的源来替换，如果你遇到了这个问题可以使用下面的命令来替换Ruby软件库：</li>
</ol>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">gem sources -l                                  <span class="string">//</span>查看Ruby数据源</span><br><span class="line">gem sources <span class="params">--remove</span> https:<span class="string">//rubygems.org/</span>      <span class="string">//</span>移除原有的Ruby软件库</span><br><span class="line">gem sources -a https:<span class="string">//ruby.taobao.org/</span>         <span class="string">//</span>使用国内淘宝的Ruby软件库</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>安装最新版本的CocoaPods</li>
</ol>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">sudo gem <span class="keyword">install</span> cocoapods</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>安装指定版本的CocoaPods</li>
</ol>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">sudo</span> gem install cocoapods -v <span class="number">1</span>.<span class="number">4</span>.<span class="number">0</span></span><br></pre></td></tr></table></figure>

<ol start="5">
<li>查看当前本地安装的CocoaPods版本</li>
</ol>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">gem list cocoapods</span></span><br></pre></td></tr></table></figure>

<ol start="6">
<li>卸载当前安装的CocoaPods</li>
</ol>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">sudo gem uninstall cocoapods</span></span><br></pre></td></tr></table></figure>

<p>有时候卸载不干净可以通过上面的gem list cocoapods列出所有相关的库，并通过下面命令卸载</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">gem uninstall cocoapods</span><br><span class="line">gem uninstall cocoapods-core</span><br><span class="line">gem uninstall cocoapods-downloader</span><br><span class="line">gem uninstall cocoapods-plugins</span><br><span class="line">gem uninstall cocoapods-<span class="built_in">search</span></span><br><span class="line">gem uninstall cocoapods-stats</span><br><span class="line">gem uninstall cocoapods-trunk</span><br><span class="line">gem uninstall cocoapods-<span class="keyword">try</span></span><br></pre></td></tr></table></figure>

<ol start="7">
<li>初始化CocoaPods repo</li>
</ol>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">pod setup</span><br></pre></td></tr></table></figure>
<p>这一步是比较耗时的，它是将 pod repo 的 镜像索引信息下载到 ~&#x2F;.cocoapods&#x2F;repos目录下,如果这个进度实在等得太久了可以试着 cd 到那个目录，用du -sh *来查看下载进度，我们怎么知道我们有哪些repo呢？</p>
<p>可以使用pod repo命令来查看：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">master</span><br><span class="line">- Type: git (master)</span><br><span class="line">- URL:  https:<span class="regexp">//gi</span>thub.com<span class="regexp">/CocoaPods/</span>Specs.git</span><br><span class="line">- Path: <span class="regexp">/Users/</span>huya<span class="regexp">/.cocoapods/</span>repos/master</span><br></pre></td></tr></table></figure>

<p>URL表示远程的repo库地址，Path表示下载存放的地址。Type 是代码库类型，上图表示的是从<a target="_blank" rel="noopener" href="https://github.com/CocoaPods/Specs.git">https://github.com/CocoaPods/Specs.git</a>这个地址，将镜像索引下载到本地的&#x2F;Users&#x2F;huya&#x2F;.cocoapods&#x2F;repos&#x2F;master 文件夹下。</p>
<p>镜像索引其实是一个配置文件，里面包含了某个库当前的版本，这些库的地址,如下图所示：<br><img src="/2019/08/26/Cocopods-%E4%BD%BF%E7%94%A8/00002.png"></p>
<p>我们可以手动添加删除pod repo库</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">pod repo remove <span class="keyword">master</span></span><br><span class="line"><span class="title">pod</span> repo add <span class="keyword">master</span> <span class="title">https</span>://gitcafe.com/akuandev/Specs.git</span><br></pre></td></tr></table></figure>

<p>当然可以通过在Podfile中通过source来添加，这个后面会举例说明。</p>
<p>一旦setup之后，后续如果需要更新repo库可以通过来更新。</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">pod repo update</span></span><br></pre></td></tr></table></figure>

<h5 id="CocoaPods-常用命令行"><a href="#CocoaPods-常用命令行" class="headerlink" title="CocoaPods 常用命令行"></a><strong><strong>CocoaPods 常用命令行</strong></strong></h5><ol>
<li>初始化Pod</li>
</ol>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">pod <span class="keyword">init</span></span><br></pre></td></tr></table></figure>
<p>这时候会在当前目录下新创建一个Podfile,后面将专门介绍如何编写Podfile</p>
<ol start="2">
<li>安装依赖</li>
</ol>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">pod <span class="keyword">install</span></span><br></pre></td></tr></table></figure>
<p>这时候会参照Podfile从～&#x2F;.cocoapods&#x2F;repos&#x2F;对应的目录下寻找对应库的下载地址并将库下载到Pod文件夹下，然后生成对应的workspace文件，这个在后面介绍原理的时候再详细介绍</p>
<ol start="3">
<li>查找对应的pod库</li>
</ol>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">pod search</span></span><br></pre></td></tr></table></figure>

<p>如果只是开发的话一般上面几个命令就够用了</p>
<ol start="4">
<li>使用指定版本执行命令</li>
</ol>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">pod</span> <span class="number">1</span>.<span class="number">4</span>.<span class="number">0</span> install</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>install 的时候输出详细过程Log</li>
</ol>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">pod <span class="keyword">install</span> –verbose</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>更新某一个组件</li>
</ol>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">//</span> 不添加组件名则更新所有</span><br><span class="line">pod update [组件名]</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>更新本地依赖</li>
</ol>
<p>如果 github 或者私有仓库上面有最新版本，本地搜到的还是旧版本。如果 <code>Podfile</code> 中使用新的版本号，这样是无法执行成功的,这时候必须对本地依赖库进行一次更新。</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">pod repo update</span></span><br></pre></td></tr></table></figure>

<h5 id="多版本CocoaPods管理"><a href="#多版本CocoaPods管理" class="headerlink" title="多版本CocoaPods管理"></a><strong><strong>多版本CocoaPods管理</strong></strong></h5><p>有时候会遇到比如工作中我们协商好都用1.4.0 但是我们自己的某些练习项目需要用到1.8.4 这时候是最头疼的一件事情，为了解决这个问题我目前使用<strong><strong>Bundler</strong></strong>来管理各个项目的CocoaPods版本：</p>
<p>安装bundler:</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">gem <span class="keyword">install</span> bundler</span><br></pre></td></tr></table></figure>

<p>和Cocoapods的Podfile文件一样，我们需要创建一个Gemfile文件，文件位置和Podifle所在位置相同即可，可以使用：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">bundle <span class="keyword">init</span></span><br></pre></td></tr></table></figure>

<p>在Gemfile文件中，配置所需的Cocoapods版本：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">source</span> <span class="string">&quot;https://rubygems.org&quot;</span></span><br><span class="line"><span class="attribute">gem</span> &#x27;cocoapods&#x27;, &#x27;<span class="number">1</span>.<span class="number">8</span>.<span class="number">4</span>&#x27;</span><br></pre></td></tr></table></figure>

<p>执行bundle install</p>
<p>之后就可以在相应位置，执行bundle exec pod xxxxx 就可以了。</p>
<h5 id="Podfile"><a href="#Podfile" class="headerlink" title="****Podfile ****"></a>****Podfile ****</h5><p>最全面的还是官方文档：<a target="_blank" rel="noopener" href="https://guides.cocoapods.org/syntax/podfile.html">Podfile 官方文档</a></p>
<p>一个比较简单的Podfile如下所示</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line">source <span class="string">&#x27;https://github.com/CocoaPods/Specs.git&#x27;</span></span><br><span class="line"></span><br><span class="line">platform <span class="symbol">:ios</span>, <span class="string">&#x27;9.0&#x27;</span></span><br><span class="line"></span><br><span class="line">target <span class="string">&#x27;IDLFundation&#x27;</span> <span class="keyword">do</span></span><br><span class="line">  <span class="comment"># Pods for IDLFundation</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">target <span class="string">&#x27;IDLFundationTest&#x27;</span> <span class="keyword">do</span></span><br><span class="line">    <span class="comment"># Pods for IDLFundationTest</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h6 id="1-install"><a href="#1-install" class="headerlink" title="1. install"></a>1. install</h6><p>这个命令是cocoapods声明的一个安装命令，用于安装引入Podfile里面的依赖库,也就是pod install执行时的一些参数设置，在项目中没有使用过，在这里先不做过多介绍，后面如果有机会会带大家过一下CocoaPods源码，到时候再看下这个配置的作用。</p>
<h6 id="2-source"><a href="#2-source" class="headerlink" title="2. source"></a>2. source</h6><p>source 用于指定specs的位置，sources的顺序是有关系的。CocoaPods将使用pod第一次出现的source中的最高版本.cocoapods 官方source是隐式的需要的，如果只有一个cocoapods官方的source则可以省去不写，但是一旦你指定了其他source 你就需要也把官方的指定上。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> <span class="string">&#x27;https://github.com/CocoaPods/Specs.git&#x27;</span></span><br></pre></td></tr></table></figure>

<h6 id="3-target"><a href="#3-target" class="headerlink" title="3. target"></a>3. target</h6><p>target指明当前的依赖是针对哪个项目target的,可以在target块里面为某个指定的target定义依赖项,一般我们会通过def定义一个依赖集合，然后在不同的target引用，</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">common_Pods</span></span></span><br><span class="line">    <span class="comment">#架构基本</span></span><br><span class="line">    pod <span class="string">&#x27;ReactiveObjC&#x27;</span>, <span class="string">&#x27;~&gt; 3.1.1&#x27;</span></span><br><span class="line">    pod <span class="string">&#x27;PromiseKit&#x27;</span>, <span class="string">&#x27;~&gt; 1.0&#x27;</span></span><br><span class="line">    pod <span class="string">&#x27;Aspects&#x27;</span>, <span class="string">&#x27;~&gt; 1.4.1&#x27;</span></span><br><span class="line">    pod <span class="string">&#x27;Objection&#x27;</span>, <span class="string">&#x27;~&gt; 1.6.1&#x27;</span></span><br><span class="line">    pod <span class="string">&#x27;BlocksKit&#x27;</span>, <span class="string">&#x27;~&gt; 2.2.5&#x27;</span></span><br><span class="line">    </span><br><span class="line">    //.....</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">platform <span class="symbol">:ios</span>, <span class="string">&#x27;9.0&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">target <span class="string">&#x27;IDLFundation&#x27;</span> <span class="keyword">do</span></span><br><span class="line">  common_Pods</span><br><span class="line">  <span class="comment"># Pods for IDLFundation</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">target <span class="string">&#x27;IDLFundationTest&#x27;</span> <span class="keyword">do</span></span><br><span class="line">    common_Pods</span><br><span class="line">    <span class="comment"># Pods for IDLFundationTest</span></span><br><span class="line">    //........</span><br><span class="line">    pod <span class="string">&#x27;LookinServer&#x27;</span>, <span class="symbol">:configurations</span> =&gt; [<span class="string">&#x27;Debug&#x27;</span>]</span><br><span class="line">    pod <span class="string">&#x27;Reveal-SDK&#x27;</span>, <span class="symbol">:configurations</span> =&gt; [<span class="string">&#x27;Debug&#x27;</span>]</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h6 id="4-platform"><a href="#4-platform" class="headerlink" title="4. platform"></a>4. platform</h6><p>platform指定了静态库应该被编译在哪个平台.下面是各个平台platform的默认值。</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">iOS</span> -&gt; <span class="number">4</span>.<span class="number">3</span></span><br><span class="line"><span class="attribute">OS</span> X -&gt; <span class="number">10</span>.<span class="number">6</span></span><br><span class="line"><span class="attribute">tvOS</span> -&gt; <span class="number">9</span>.<span class="number">0</span></span><br><span class="line"><span class="attribute">watchOS</span> -&gt; <span class="number">2</span>.<span class="number">0</span></span><br></pre></td></tr></table></figure>

<h6 id="5-inhibit-all-warnings"><a href="#5-inhibit-all-warnings" class="headerlink" title="5. inhibit_all_warnings"></a>5. inhibit_all_warnings</h6><p>inhibit_all_warnings! 用于屏蔽cocoapods库里面的所有警告，它也可以用于屏蔽某个库的编译警告</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><span class="line">pod <span class="string">&#x27;SSZipArchive&#x27;</span>, :<span class="function"><span class="params">inhibit_warnings</span> =&gt;</span> <span class="literal">true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h6 id="6-use-frameworks"><a href="#6-use-frameworks" class="headerlink" title="6. use_frameworks"></a>6. use_frameworks</h6><p>use_frameworks用于告诉CocoaPods我们想使用Frameworks而不是Static Libraries。不显式指定的话会默认使用Static Libraries，会在Pods工程下的Products目录下生成.a的静态库，如果指定的话会在Pods工程下的Frameworks目录下生成依赖库的framework，由于Swift不支持静态库，所以如果项目中使用到Swift库的话就必须使用use_frameworks!，纯OC项目是不用use_frameworks的。</p>
<h6 id="7-Pod"><a href="#7-Pod" class="headerlink" title="7. Pod"></a>7. Pod</h6><p>指定每个target的依赖项</p>
<ul>
<li>如果后面不写依赖库的具体版本号，那么cocoapods会默认选取最新版本,一般不推荐使用这种方式，因为库升级的时候可能会带来不兼容或者其他怪异的问题，一般我们项目中都不会使用这种方式，而是在使用库的时候明确指明库对应的版本，如果要升级库也要我们明确，库的升级是否会给我们带来问题，并通过测试后才能升级发布，否则一个项目中有几十个库，很难追踪问题是哪个库升级导致的。</li>
</ul>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">pod</span> <span class="string">&#x27;SSZipArchive&#x27;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>要特定的依赖库的版本，只需要在后面写上具体版本号即可：</li>
</ul>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">pod</span> <span class="string">&#x27;Objection&#x27;</span>, <span class="string">&#x27;0.9&#x27;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>当然除了指定特定版本外还可以通过下面的来指定版本范围，但是个人还是推荐明确指明所依赖的库的版本。</li>
</ul>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="bullet">* </span>&gt; 0.1 高于0.1版本（不包含0.1版本）的任意一个版本</span><br><span class="line"><span class="bullet">* </span>&gt;= 0.1 高于0.1版本（包含0.1版本）的任意一个版本</span><br><span class="line"><span class="bullet">* </span>&lt; 0.1 低于0.1版本（不包含0.1版本）的任意一个</span><br><span class="line"><span class="bullet">* </span>&lt;= 0.1低于0.1版本（包含0.1版本）的任意一个</span><br><span class="line"><span class="bullet">* </span>~&gt; 0.1.2 版本 这个例子等效于&gt;= 0.1.2并且 &lt;0.2.0，并且始终是你指定范围内的最新版本,一般同一个版本簇的API都是需要兼容的，所以这也是一个比较合理的方式，但是很难避免某些三方库的开发人员没有这方面的考虑和支持，因此还是推荐明确指定使用的版本。</span><br></pre></td></tr></table></figure>
<ul>
<li>pod 中还可以指定当前依赖只在某些给定的build configuration中被启用，比如：</li>
</ul>
<figure class="highlight arcade"><table><tr><td class="code"><pre><span class="line">pod <span class="string">&#x27;LookinServer&#x27;</span>, :<span class="function"><span class="params">configurations</span> =&gt;</span> [<span class="string">&#x27;Debug&#x27;</span>]</span><br></pre></td></tr></table></figure>

<ul>
<li>正常情况下我们会通过依赖库的名称来引入，但是有些依赖库是有多个子依赖的，比如:</li>
</ul>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">pod</span> <span class="string">&#x27;Firebase/Analytics&#x27;</span></span><br><span class="line">pod <span class="string">&#x27;Firebase/Performance&#x27;</span></span><br><span class="line">pod <span class="string">&#x27;Firebase/RemoteConfig&#x27;</span></span><br></pre></td></tr></table></figure>
<p>这种除了使用上面写法外，还可以通过Subspecs来代替,但是个人还是推荐上面的写法比较简单：</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><span class="line">pod <span class="string">&#x27;Firebase&#x27;</span>, :<span class="function"><span class="params">subspecs</span> =&gt;</span> [<span class="string">&#x27;RemoteConfig&#x27;</span>]</span><br></pre></td></tr></table></figure>
<ul>
<li>使用本地依赖</li>
</ul>
<figure class="highlight arcade"><table><tr><td class="code"><pre><span class="line">pod <span class="string">&#x27;AFNetworking&#x27;</span>, :<span class="function"><span class="params">path</span> =&gt;</span> <span class="string">&#x27;~/Documents/AFNetworking&#x27;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>使用指定远程依赖</li>
</ul>
<p>引入master分支（默认）</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><span class="line">pod <span class="string">&#x27;AFNetworking&#x27;</span>, :<span class="function"><span class="params">git</span> =&gt;</span> <span class="string">&#x27;https://github.com/gowalla/AFNetworking.git&#x27;</span></span><br></pre></td></tr></table></figure>
<p>引入指定的分支</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><span class="line">pod <span class="string">&#x27;AFNetworking&#x27;</span>, :<span class="function"><span class="params">git</span> =&gt;</span> <span class="string">&#x27;https://github.com/gowalla/AFNetworking.git&#x27;</span>, :<span class="function"><span class="params">branch</span> =&gt;</span> <span class="string">&#x27;dev&#x27;</span></span><br></pre></td></tr></table></figure>
<p>引入某个Tag标签的代码</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><span class="line">pod <span class="string">&#x27;AFNetworking&#x27;</span>, :<span class="function"><span class="params">git</span> =&gt;</span> <span class="string">&#x27;https://github.com/gowalla/AFNetworking.git&#x27;</span>, :<span class="function"><span class="params">tag</span> =&gt;</span> <span class="string">&#x27;0.7.0&#x27;</span></span><br></pre></td></tr></table></figure>
<p>引入某个特殊的提交节点</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><span class="line">pod <span class="string">&#x27;AFNetworking&#x27;</span>, :<span class="function"><span class="params">git</span> =&gt;</span> <span class="string">&#x27;https://github.com/gowalla/AFNetworking.git&#x27;</span>, :<span class="function"><span class="params">commit</span> =&gt;</span> <span class="string">&#x27;082f8319af&#x27;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>从另一个源库引入</li>
</ul>
<figure class="highlight arcade"><table><tr><td class="code"><pre><span class="line">pod <span class="string">&#x27;PonyDebugger&#x27;</span>, :<span class="function"><span class="params">source</span> =&gt;</span> <span class="string">&#x27;https://github.com/CocoaPods/Specs.git&#x27;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight arcade"><table><tr><td class="code"><pre><span class="line">pod <span class="string">&#x27;JSONKit&#x27;</span>, :<span class="function"><span class="params">podspec</span> =&gt;</span> <span class="string">&#x27;https://example.com/JSONKit.podspec&#x27;</span></span><br></pre></td></tr></table></figure>

<p>podspec 用于指定podspec的信息：</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 不指定表示使用根目录下的podspec，默认一般都会放在根目录下,并且使用库名作为名称</span></span><br><span class="line">podspec</span><br><span class="line"><span class="comment"># 如果podspec的名字与库名不一样，可以通过这样来指定</span></span><br><span class="line">podspec <span class="symbol">:name</span> =&gt; <span class="string">&#x27;DemoPodSpect&#x27;</span></span><br><span class="line"><span class="comment"># 如果podspec不是在根目录下，那么可以通过:path来指定路径</span></span><br><span class="line">podspec <span class="symbol">:path</span> =&gt; <span class="string">&#x27;/Documents/PrettyKit/PrettyKit.podspec&#x27;</span></span><br></pre></td></tr></table></figure>

<h6 id="8-project"><a href="#8-project" class="headerlink" title="8. project"></a>8. project</h6><p>用于指定当前target要应用到哪个project，这个用在多project的情况下，如果没有指定说明该target要应用到Podfile目录下与target同名的工程</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="comment"># MusicApp这个target只有在MyMusic工程中才会链接</span></span><br><span class="line">target <span class="string">&#x27;MusicApp&#x27;</span> <span class="keyword">do</span></span><br><span class="line">  project <span class="string">&#x27;MyMusic&#x27;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># NotesApp这个target只有在MyNotes工程中才会链接</span></span><br><span class="line">target <span class="string">&#x27;NotesApp&#x27;</span> <span class="keyword">do</span></span><br><span class="line">  project <span class="string">&#x27;MyNotes&#x27;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h6 id="9-workspace"><a href="#9-workspace" class="headerlink" title="9. workspace"></a>9. workspace</h6><p>默认情况下不需要指定，直接使用与Podfile所在目录的工程名一样就可以了。如果要指定另外的名称，而不是使用工程的名称，可以使用workspace来指定：</p>
<figure class="highlight mel"><table><tr><td class="code"><pre><span class="line"><span class="keyword">workspace</span> <span class="string">&#x27;MyWorkspace&#x27;</span></span><br></pre></td></tr></table></figure>

<h6 id="10-def"><a href="#10-def" class="headerlink" title="10. def"></a>10. def</h6><p>def命令来声明一个pod集, 然后在需要引入的target中引入：</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">common_Pods</span></span></span><br><span class="line">    <span class="comment">#架构基本</span></span><br><span class="line">    pod <span class="string">&#x27;ReactiveObjC&#x27;</span>, <span class="string">&#x27;~&gt; 3.1.1&#x27;</span></span><br><span class="line">    pod <span class="string">&#x27;PromiseKit&#x27;</span>, <span class="string">&#x27;~&gt; 1.0&#x27;</span></span><br><span class="line">    pod <span class="string">&#x27;Aspects&#x27;</span>, <span class="string">&#x27;~&gt; 1.4.1&#x27;</span></span><br><span class="line">    pod <span class="string">&#x27;Objection&#x27;</span>, <span class="string">&#x27;~&gt; 1.6.1&#x27;</span></span><br><span class="line">    pod <span class="string">&#x27;BlocksKit&#x27;</span>, <span class="string">&#x27;~&gt; 2.2.5&#x27;</span></span><br><span class="line">    </span><br><span class="line">    //.....</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">platform <span class="symbol">:ios</span>, <span class="string">&#x27;9.0&#x27;</span></span><br><span class="line"></span><br><span class="line">target <span class="string">&#x27;IDLFundation&#x27;</span> <span class="keyword">do</span></span><br><span class="line">  common_Pods</span><br><span class="line">  <span class="comment"># Pods for IDLFundation</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">target <span class="string">&#x27;IDLFundationTest&#x27;</span> <span class="keyword">do</span></span><br><span class="line">    common_Pods</span><br><span class="line">    <span class="comment"># Pods for IDLFundationTest</span></span><br><span class="line">    //........</span><br><span class="line">    pod <span class="string">&#x27;LookinServer&#x27;</span>, <span class="symbol">:configurations</span> =&gt; [<span class="string">&#x27;Debug&#x27;</span>]</span><br><span class="line">    pod <span class="string">&#x27;Reveal-SDK&#x27;</span>, <span class="symbol">:configurations</span> =&gt; [<span class="string">&#x27;Debug&#x27;</span>]</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h6 id="11-pre-install"><a href="#11-pre-install" class="headerlink" title="11. pre_install"></a>11. pre_install</h6><p>这个允许用户在Pods下载完成，但还未安装前对Pods做一些修改，它有一个唯一参数Pod::Installer</p>
<figure class="highlight coq"><table><tr><td class="code"><pre><span class="line">pre_install <span class="built_in">do</span> |<span class="type">installer</span>|</span><br><span class="line">  <span class="type">#......</span></span><br><span class="line"><span class="type">end</span></span><br></pre></td></tr></table></figure>

<h6 id="12-post-install"><a href="#12-post-install" class="headerlink" title="12. post_install"></a>12. post_install</h6><p>当我们安装完成，但是生成的工程还没有写入磁盘之时，我们可以指定要执行的操作。比如，我们可以在写入磁盘之前，修改一些工程的配置：<br>这两个在项目中暂时没有遇到过。</p>
<figure class="highlight coq"><table><tr><td class="code"><pre><span class="line">post_install <span class="built_in">do</span> |<span class="type">installer</span>| <span class="type">installer</span>.pods_project.targets.each <span class="built_in">do</span> |<span class="type">target</span>| </span><br><span class="line">        <span class="type">target</span>.build_configurations.each <span class="built_in">do</span> |<span class="type">config</span>| </span><br><span class="line">            <span class="type">config</span>.build_settings[&#x27;GCC_ENABLE_OBJC_GC&#x27;] = &#x27;supported&#x27; </span><br><span class="line">        <span class="keyword">end</span> </span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>下面是一个比较全的一个Podfile模版,供大家参考：</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line">source <span class="string">&#x27;https://github.com/CocoaPods/Specs.git&#x27;</span> <span class="comment"># 组件依赖文件所存放仓库，根据需求可引入多个</span></span><br><span class="line">source <span class="string">&#x27;https://github.com/artsy/Specs.git&#x27;</span></span><br><span class="line"></span><br><span class="line">platform <span class="symbol">:ios</span>, <span class="string">&#x27;8.0&#x27;</span>            <span class="comment"># </span></span><br><span class="line">inhibit_all_warnings!           <span class="comment"># 忽视引用的代码中的警告</span></span><br><span class="line">workspace <span class="string">&#x27;CocoaPodsDemo&#x27;</span>       <span class="comment"># 指定生成的 workspace 名字</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">common_pods</span></span>                 <span class="comment"># 如果有多个 target，可以将公共部分进行 def 定义再引入</span></span><br><span class="line">    pod <span class="string">&#x27;xxx&#x27;</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">target <span class="string">&#x27;CocoaPodsDemo&#x27;</span> <span class="keyword">do</span></span><br><span class="line">    project <span class="string">&#x27;DemoProject&#x27;</span>       <span class="comment"># 可用于指定实际的工程</span></span><br><span class="line">    use_frameworks!             <span class="comment"># 是否以 framework 形式引入。swift 必须有这个关键字 </span></span><br><span class="line">    common_pods              <span class="comment"># 公共引入的组件</span></span><br><span class="line">    pod <span class="string">&#x27;SSipArchive&#x27;</span>, <span class="symbol">:inhibit_warnings</span> =&gt; <span class="literal">true</span>   <span class="comment"># 屏蔽某个 pod 的 warning</span></span><br><span class="line">    pod <span class="string">&#x27;AFNetworking&#x27;</span>, <span class="string">&#x27;3.2&#x27;</span>   <span class="comment"># 使用 3.2 版本</span></span><br><span class="line">    pod <span class="string">&#x27;YYCache&#x27;</span>, <span class="string">&#x27;~&gt; 0.3&#x27;</span>     <span class="comment"># pod update 时最高升级到 &lt; 1.0，不包括 1.0</span></span><br><span class="line">    </span><br><span class="line">   <span class="comment"># Build 环境配置</span></span><br><span class="line">   pod <span class="string">&#x27;PonyDebugger&#x27;</span>, <span class="symbol">:configurations</span> =&gt; [<span class="string">&#x27;Debug&#x27;</span>, <span class="string">&#x27;Beta&#x27;</span>]</span><br><span class="line">   pod <span class="string">&#x27;PonyDebugger&#x27;</span>, <span class="symbol">:configuration</span> =&gt; <span class="string">&#x27;Debug&#x27;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment"># 使用具体的某个 subspec</span></span><br><span class="line">   pod <span class="string">&#x27;QueryKit/Attribute&#x27;</span></span><br><span class="line">   pod <span class="string">&#x27;QueryKit&#x27;</span>, <span class="symbol">:subspecs</span> =&gt; [<span class="string">&#x27;Attribute&#x27;</span>, <span class="string">&#x27;QuerySet&#x27;</span>]</span><br><span class="line">   </span><br><span class="line">   <span class="comment"># 引用本地组件</span></span><br><span class="line">   pod <span class="string">&#x27;AFNetworking&#x27;</span>, <span class="symbol">:path</span> =&gt; <span class="string">&#x27;~/Documents/AFNetworking&#x27;</span></span><br><span class="line">   </span><br><span class="line">   <span class="comment"># 使用具体仓库</span></span><br><span class="line">   pod <span class="string">&#x27;AFNetworking&#x27;</span>, <span class="symbol">:git</span> =&gt; <span class="string">&#x27;https://github.com/gowalla/AFNetworking.git&#x27;</span></span><br><span class="line">   <span class="comment"># 使用具体仓库具体分支</span></span><br><span class="line">   pod <span class="string">&#x27;AFNetworking&#x27;</span>, <span class="symbol">:git</span> =&gt; <span class="string">&#x27;https://github.com/gowalla/AFNetworking.git&#x27;</span>, <span class="symbol">:branch</span> =&gt; <span class="string">&#x27;dev&#x27;</span></span><br><span class="line">   <span class="comment"># 使用具体仓库的某个 tag</span></span><br><span class="line">   pod <span class="string">&#x27;AFNetworking&#x27;</span>, <span class="symbol">:git</span> =&gt; <span class="string">&#x27;https://github.com/gowalla/AFNetworking.git&#x27;</span>, <span class="symbol">:tag</span> =&gt; <span class="string">&#x27;0.7.0&#x27;</span></span><br><span class="line">   <span class="comment"># 使用具体仓库的某个 commit</span></span><br><span class="line">   pod <span class="string">&#x27;AFNetworking&#x27;</span>, <span class="symbol">:git</span> =&gt; <span class="string">&#x27;https://github.com/gowalla/AFNetworking.git&#x27;</span>, <span class="symbol">:commit</span> =&gt; <span class="string">&#x27;082f8319af&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 使用指定路径的 spec 文件</span></span><br><span class="line">   pod <span class="string">&#x27;JSONKit&#x27;</span>, <span class="symbol">:podspec</span> =&gt; <span class="string">&#x27;https://example.com/JSONKit.podspec&#x27;</span></span><br><span class="line">   </span><br><span class="line">   target <span class="string">&#x27;ShowsApp&#x27;</span> <span class="keyword">do</span></span><br><span class="line">     pod <span class="string">&#x27;ShowsKit&#x27;</span></span><br><span class="line"></span><br><span class="line">      <span class="comment"># Has its own copy of ShowsKit + ShowTVAuth</span></span><br><span class="line">       target <span class="string">&#x27;ShowsTV&#x27;</span> <span class="keyword">do</span></span><br><span class="line">       pod <span class="string">&#x27;ShowTVAuth&#x27;</span></span><br><span class="line">       <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">      <span class="comment"># Has its own copy of Specta + Expecta</span></span><br><span class="line">      <span class="comment"># and has access to ShowsKit via the app</span></span><br><span class="line">     <span class="comment"># that the test target is bundled into</span></span><br><span class="line">      target <span class="string">&#x27;ShowsTests&#x27;</span> <span class="keyword">do</span></span><br><span class="line">       <span class="comment"># inherit！ 有三种类型：&#x27;:complete&#x27; 继承父级所有行为；&#x27;:none&#x27; 什么行为都不继承；&#x27;:search_paths&#x27; 继承父级的 search paths</span></span><br><span class="line">        inherit! <span class="symbol">:search_paths</span></span><br><span class="line">        pod <span class="string">&#x27;Specta&#x27;</span></span><br><span class="line">        pod <span class="string">&#x27;Expecta&#x27;</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># hook 配置, 在 preparing 阶段后，install 之前</span></span><br><span class="line">pre_install <span class="keyword">do</span> |installer|</span><br><span class="line">    </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># hook 配置，在 pod install 之后，可用于修改工程配置等</span></span><br><span class="line">post_install <span class="keyword">do</span> |installer|</span><br><span class="line">  installer.pods_project.targets.each <span class="keyword">do</span> |target|</span><br><span class="line">    target.build_configurations.each <span class="keyword">do</span> |config|</span><br><span class="line">      config.build_settings[<span class="string">&#x27;GCC_ENABLE_OBJC_GC&#x27;</span>] = <span class="string">&#x27;supported&#x27;</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="CocoaPods-工作原理"><a href="#CocoaPods-工作原理" class="headerlink" title="CocoaPods 工作原理"></a><strong><strong>CocoaPods 工作原理</strong></strong></h5><p>关于CocoaPods的工作原理的细节大家可以翻看下CocoaPods的源码看下整个流程：<br>下面推荐几篇CocoaPod源码解析文章给大家，大家可以结合这些文章对源码进行解析：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://draveness.me/cocoapods">CocoaPods 都做了什么？</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5b1cfaff6fb9a01e417b6051">我所理解的 CocoaPods</a></li>
<li><a target="_blank" rel="noopener" href="https://myseven.github.io/2018-04-25/Cocoapods%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90">Cocoapods源码解析</a></li>
</ul>
<p>这里只想从使用者的角度来介绍下CocoaPods工作原理,主要包括</p>
<ol>
<li>CocoaPods的组成</li>
<li>CocoaPods的工作流</li>
<li>pod install,pod update，Podfile.lock,Manifest.lock</li>
</ol>
<ul>
<li><strong><strong>CocoaPods的组成</strong></strong></li>
</ul>
<p>CocoaPods 本身是由Ruby编写的，它是由多个Ruby包组成的，最主要包括CocoaPods Core，CocoaPods Downloader，Xcodeproj，CLAide，Molinillo这些Ruby包，这些包是通过gem进行管理的，当我们执行pod 命令的时候就会调用对应的模块完成对应的任务，下面是对应模块的源码地址，作用，以及对应的帮助文档，大家在遇到问题的时候可以查找这些资料来解决问题。</p>
<table>
<thead>
<tr>
<th>模块</th>
<th>说明</th>
<th>帮助文档</th>
</tr>
</thead>
<tbody><tr>
<td><a target="_blank" rel="noopener" href="https://github.com/CocoaPods/Specs.git">CocoaPods&#x2F;Specs</a></td>
<td>三方库Podspec文件托管仓库</td>
<td><a target="_blank" rel="noopener" href="https://guides.cocoapods.org/making/specs-and-specs-repo.html">Doc</a></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://github.com/CocoaPods/CocoaPods">CocoaPods</a></td>
<td>CocoaPod 命令行工具</td>
<td><a target="_blank" rel="noopener" href="https://guides.cocoapods.org/">Guide</a></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://github.com/CocoaPods/Core">CocoaPods Core</a></td>
<td>CocoaPods 相关文件(Specification,Podfile,Source)的处理</td>
<td><a target="_blank" rel="noopener" href="https://guides.cocoapods.org/">Guide</a></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://github.com/CocoaPods/cocoapods-downloader">CocoaPods Downloader</a></td>
<td>支持git&#x2F;SVN&#x2F;等多种协议的代码下载器</td>
<td><a target="_blank" rel="noopener" href="https://www.rubydoc.info/gems/cocoapods-downloader">Guide</a></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://github.com/CocoaPods/Xcodeproj">Xcodeproj</a></td>
<td>创建和修改Xcode projects文件</td>
<td><a target="_blank" rel="noopener" href="https://www.rubydoc.info/gems/xcodeproj">Guide</a></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://github.com/CocoaPods/CLAide">CLAide</a></td>
<td>命令行接口框架</td>
<td><a target="_blank" rel="noopener" href="https://www.rubydoc.info/gems/claide">Guide</a></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://github.com/CocoaPods/Molinillo">Molinillo</a></td>
<td>通用依赖解析器</td>
<td><a target="_blank" rel="noopener" href="https://www.rubydoc.info/gems/molinillo">Guide</a></td>
</tr>
</tbody></table>
<ul>
<li><strong><strong>CocoaPods的工作流</strong></strong></li>
</ul>
<p>整个CocoaPods涉及到了三方组件库的开发者，CocoaPods Repo，三方组件库的使用者，三方面对象，整个关系如下图所示：<br><img src="/2019/08/26/Cocopods-%E4%BD%BF%E7%94%A8/00003.png"></p>
<ol>
<li><p>首先三方组件库的开发者编写完三方库的代码后会将组件代码上传到GitHub&#x2F;SVN等代码托管仓库，然后创建一个 podspec 文件，该文件包含了该组件包含的代码及资源，以及依赖关系，版本信息，以及该组件的存储地址,然后将这个podspec推送到CocoaPods共有仓库或者私有Spec管理仓库。</p>
</li>
<li><p>在运行pod setup或者pod install的时候会查看source指令，将source指令所指定的repo 下载到<del>&#x2F;.cocoapods&#x2F;repos目录下。这个文件夹下包含了各个三方组件对应版本以及该版本的podspec文件和podspec.json文件，后续需要下载的时候就可以根据podspec中指定的下载路径下载三方组件了。如果有一个第三方库发布了一个最新的版本，如果不执行pod repo update，那么本地是不会知道有一个最新版本的，还一直以本地的资源目录为准。那么我们永远都拿不到这个库的最新版本，但是有时候我们不执行pod repo update发现也可以拿到最新的库，那是因为pod update会先拉取远程最新目录，再根据目录中的资源重新更新一遍pod，但是如果podfile没有为每个库指定明确的版本，那么每次都会拉取一遍最新库，这时候如果不想每次都拉取，可以使用pod update –no-repo-update。正常情况下pod repo update 会将</del>&#x2F;.cocoapods&#x2F;repos&#x2F;下的所有组件库都更新一遍，如果只想更新某个私有库那么只需要带上需要更新的文件夹就可以只更新某个repo了。</p>
 <figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">pod repo update ~<span class="regexp">/.cocoapods/</span>repos<span class="regexp">/XXX/</span></span><br></pre></td></tr></table></figure></li>
<li><p>三方组件库使用者要使用某个组件，需要在Podfile中指定组件名字，版本，repo 源，然后运行pod install命令，CocoaPods 会首先使用eval运行Podfile，并开始解析Podfile。</p>
<p> <strong><strong>pod install可以分成如下阶段</strong></strong>：</p>
</li>
</ol>
<ul>
<li><p>prepare 准备阶段<br>在该阶段首先会先检查当前运行目录是否是项目根目录，为啥要在根目录？因为pod init的时候需要从.xcodeproj中获取target信息，这就导致了生成的Podfile在项目根目录，而pod install需要Podfile所以也必须需要在根目录。接着检查Podfile.lock文件cocoapods和当前的cocoapods版本是否一致，Podfile中的plugin插件是否已经安装完成并加载，一旦这些检查完毕就会创建Pods以及子目录，并运行pre_install。</p>
</li>
<li><p>resolve_dependencies 解决依赖冲突<br>这个阶段主要是解析podfile文件中的pod 以及 target等信息以及之间的关系，存储到对应的数据结构中。如果Podfile中有删除的库, 先进行文件清理。</p>
</li>
<li><p>download_dependencies 下载依赖<br>这个阶段会拿着组件名，组件版本到~&#x2F;.cocoapods&#x2F;repos&#x2F;中去寻找对应的podspec，在podspec文件中找到三方组件存放的地址，从而从远程下载。当然不是每个都需要下载，如果某个组件已经下载，并且版本没有变化的情况下就不会从远程下载。</p>
</li>
<li><p>validate_targets target校验<br>这阶段将会对下载的依赖进行校验，比如校验是否有多重引用framework 或者 library 的情况，检查不同target所使用的swift版本是否相同，如果使用swift的情况下，检查Podfile是否添加了use_frameworks!。</p>
</li>
<li><p>generate_pods_project 生成 Pod project 文件<br>这阶段将会生成Pods.xcodeproj工程文件,并将下载的依赖文件，Library 加入工程，处理 target 依赖，并将项目文件以及Pods项目文件添加到新生成的.xcworkspace文件。</p>
</li>
<li><p><strong><strong>pod install,pod update，Podfile.lock,Manifest.lock</strong></strong></p>
</li>
</ul>
<p>其实上面已经对这部分内容有所介绍了，这里将这些内容放在一起对比下会更加明显：</p>
<p>在项目第一次使用Cocoapods时候，或者在podfile文件中增加或者删除某个组件的时候需要使用pod install而不是pod update。</p>
<p>当运行pod install，它只解析Podfile.lock中没有的pod的依赖库.对于Podfile.lock中已经有的组件库, Podfile.lock不会尝试检查~&#x2F;.cocoapods&#x2F;repos是否有更新的版本.对于没有在Podfile.lock中列出的组件库,pod会搜索与Podfile匹配的版本或最新的版本，并将每个组件已经安装的版本写入到Podfile.lock中.也就是说Podfile.lock 的功能是用于跟踪每个组件的已安装版本并锁定这些版本。</p>
<p>简单说：pod install会优先考虑Podfile里指定的版本信息，其次考虑Podfile.lock 里指定的版本信息来安装对应的依赖库，而不会每次都考虑~&#x2F;.cocoapods&#x2F;repos的最新版本</p>
<p>当运行pod update的时候CocoaPods将尝试查找更新的组件版本, 并且会忽略掉Podfile.lock中已经存在的版本.</p>
<p>在多人协作的项目中一般需要将Podfile.lock文件提交到版本控制库中，这样大家就会保证同一时刻使用的三方组件库是一致的，只有在确认某个更新需要同步的时候，某人运行pod update后将Podfile.lock再次提交到代码仓库，其他人拉取到这个最新的Podfile.lock的时候就会提示需要更新，这时候其他人就也需要使用pod update 更新本地的三方组件，但是不论怎样，整个团队的三方组件库总是一致的。</p>
<p>上面介绍了Podfile.lock 那么 Manifest.lock 的作用又是什么？Manifest.lock 是 Podfile.lock 的副本，每次只要生成 Podfile.lock 时就会生成一个一样的 Manifest.lock 存储在 Pods 文件夹下。在每次项目 Build 的时候，会跑一下脚本检查一下 Podfile.lock 和 Manifest.lock 是否一致。也就是说Manifest.lock是用于记录本地&#x2F;Pod目录下各个组件库的版本信息，那不是和Podfile.lock重复了么？不是的，因为一般我们会将Podfile.lock放到代码仓库中，这部分是有可能其他人远程改动后，我们拉下来，这时候有可能导致Podfile.lock中指定的组件版本和本地的组件版本不一致，那么我们怎么发现这种不一致呢？靠Podfile？这是不可能的，一般就是因为Podfile改了，pod update后导致Podfile.lock发生改动，这样如果没有Manifest.lock 就难以判断远程的是否和本地的版本有差异了，也就是说Manifest.lock 用于标记本地sandbox中三方组件的版本，这也是为什么有了Podfile.lock之后还需要Manifest.lock 的原因了。</p>
<h5 id="CocoaPods-私有库-x2F-共有库-制作依赖库"><a href="#CocoaPods-私有库-x2F-共有库-制作依赖库" class="headerlink" title="CocoaPods 私有库&#x2F;共有库 制作依赖库"></a><strong><strong>CocoaPods 私有库&#x2F;共有库 制作依赖库</strong></strong></h5><h6 id="1-创建组件库工程"><a href="#1-创建组件库工程" class="headerlink" title="1 创建组件库工程"></a>1 创建组件库工程</h6><p>将代码clone到本地，在根目录运行：</p>
<figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line">pod <span class="keyword">lib</span> <span class="keyword">create</span> IDLUtils</span><br></pre></td></tr></table></figure>

<p>会自动引导我们创建一个组件库：</p>
<p><img src="/2019/08/26/Cocopods-%E4%BD%BF%E7%94%A8/0000004.png"></p>
<p>这时候会生成IDLUtils.podspec文件，文件内容如下：</p>
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line">#</span><br><span class="line"># 在提交前需要先运行 pod lib lint IDLUtils.podspec 来对当前文件进行校验，并且删除包括所有无用的注释。 </span><br><span class="line"># </span><br><span class="line"># 如果有关于Podspec 的可以查看 https:<span class="comment">//guides.cocoapods.org/syntax/podspec.html 文档</span></span><br><span class="line">#</span><br><span class="line">#</span><br><span class="line"></span><br><span class="line">Pod::Spec.new do |s|</span><br><span class="line"></span><br><span class="line">  # 组件名</span><br><span class="line">  s.name             = <span class="string">&#x27;IDLUtils&#x27;</span></span><br><span class="line">  # 组件版本号，命名规则遵循 https:<span class="comment">//semver.org/</span></span><br><span class="line">  s.version          = <span class="string">&#x27;0.0.1&#x27;</span></span><br><span class="line">  # 概要</span><br><span class="line">  s.summary          = <span class="string">&#x27;IDLUtils is a Collection of Utils Help to speed up your develop.&#x27;</span></span><br><span class="line"></span><br><span class="line">  # 这个描述会出现在搜索结果上，因此我们可以描述以下信息：</span><br><span class="line">  #</span><br><span class="line">  #   * 这个库的功能是什么？为什么要实现它，它的关注点在哪里</span><br><span class="line">  #   * 尽量简单明了.</span><br><span class="line">  #   * 在下面的DESC分隔符之间写下描述</span><br><span class="line">  #   * 最后，不要担心缩进，CocoaPods会自动删除它</span><br><span class="line"></span><br><span class="line">  s.description      = <span class="string">&quot;IDLUtils is a Collection of Utils Help to speed up your develop. Hope you like it &quot;</span></span><br><span class="line"></span><br><span class="line">  # 仓库主页</span><br><span class="line">  s.homepage         = <span class="string">&#x27;http://coderlin.coding.me&#x27;</span></span><br><span class="line">  # s.screenshots     = <span class="string">&#x27;www.example.com/screenshots_1&#x27;</span>, <span class="string">&#x27;www.example.com/screenshots_2&#x27;</span></span><br><span class="line">  # 遵循的协议</span><br><span class="line">  s.license          = &#123; :type =&gt; <span class="string">&#x27;MIT&#x27;</span>, :file =&gt; <span class="string">&#x27;LICENSE&#x27;</span> &#125;</span><br><span class="line">  # 作者</span><br><span class="line">  s.author           = &#123; <span class="string">&#x27;tbfungeek&#x27;</span> =&gt; <span class="string">&#x27;tbfungeek@163.com&#x27;</span> &#125;</span><br><span class="line">  # 在线源码仓库</span><br><span class="line">  s.source           = &#123; :git =&gt; <span class="string">&#x27;https://github.com/tbfungeek/IDLUtils.git&#x27;</span>, :tag =&gt; s.version.to_s &#125;</span><br><span class="line">  # 作者社交联系地址</span><br><span class="line">  # s.social_media_url = <span class="string">&#x27;https://twitter.com/&lt;TWITTER_USERNAME&gt;&#x27;</span></span><br><span class="line"></span><br><span class="line">  # 目标版本</span><br><span class="line">  s.ios.deployment_target = <span class="string">&#x27;9.0&#x27;</span></span><br><span class="line">  # 源文件</span><br><span class="line">  s.source_files = <span class="string">&#x27;IDLUtils/Classes/**/*&#x27;</span></span><br><span class="line">  </span><br><span class="line">  #资源</span><br><span class="line">  # s.resource_bundles = &#123;</span><br><span class="line">  #   <span class="string">&#x27;IDLUtils&#x27;</span> =&gt; [<span class="string">&#x27;IDLUtils/Assets/*.png&#x27;</span>]</span><br><span class="line">  # &#125;</span><br><span class="line"></span><br><span class="line">  #公开的头文件</span><br><span class="line">  # s.public_header_files = <span class="string">&#x27;Pod/Classes/**/*.h&#x27;</span></span><br><span class="line">  #依赖的库</span><br><span class="line">  # s.frameworks = <span class="string">&#x27;UIKit&#x27;</span>, <span class="string">&#x27;MapKit&#x27;</span></span><br><span class="line">  # s.dependency <span class="string">&#x27;AFNetworking&#x27;</span>, <span class="string">&#x27;~&gt; 2.3&#x27;</span></span><br><span class="line">end</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>下面是pod spec create 创建的大家可以对比下，这种方式生成的选项更多，但是pod lib create 对于简单的组件已经够用了。 </p>
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line">#</span><br><span class="line">#  在提交前需要先运行 pod spec lint IDLKeyChainTool.podspec 来对当前文件进行校验，并且删除包括所有无用的注释。</span><br><span class="line">#</span><br><span class="line">#  如果要查看Podspec的属性可以查看：http:<span class="comment">//docs.cocoapods.org/specification.html</span></span><br><span class="line">#</span><br><span class="line"></span><br><span class="line">Pod::Spec.new do |s|</span><br><span class="line"></span><br><span class="line">  # ―――  Spec Metadata  ―――――――――――――――――――――――――――――――――――――――――――――――――――――――――― #</span><br><span class="line">  #</span><br><span class="line">  # 这些信息主要用于方便使用者能够快速查找到我们这个组件库，所以最好写得简单明了</span><br><span class="line">  #</span><br><span class="line">  # 组件名</span><br><span class="line">  s.name         = <span class="string">&quot;IDLKeyChainTool&quot;</span></span><br><span class="line">  # 组件版本号，命名规则遵循 https:<span class="comment">//semver.org/</span></span><br><span class="line">  s.version      = <span class="string">&quot;0.0.1&quot;</span></span><br><span class="line">  # 概要</span><br><span class="line">  s.summary      = <span class="string">&quot;A short description of IDLKeyChainTool.&quot;</span></span><br><span class="line"></span><br><span class="line">  # 这个描述会出现在搜索结果上，因此我们可以描述以下信息：</span><br><span class="line">  #</span><br><span class="line">  #   * 这个库的功能是什么？为什么要实现它，它的关注点在哪里</span><br><span class="line">  #   * 尽量简单明了.</span><br><span class="line">  #   * 在下面的DESC分隔符之间写下描述</span><br><span class="line">  #   * 最后，不要担心缩进，CocoaPods会自动删除它</span><br><span class="line">  # 详细描述，很重要的</span><br><span class="line">  s.description  = <span class="string">&quot;This is a KeyChain Tool for Objective C&quot;</span></span><br><span class="line">  # 仓库主页</span><br><span class="line">  s.homepage     = <span class="string">&quot;http://EXAMPLE/IDLKeyChainTool&quot;</span></span><br><span class="line">  # 展示截图</span><br><span class="line">  # s.screenshots  = <span class="string">&quot;www.example.com/screenshots_1.gif&quot;</span>, <span class="string">&quot;www.example.com/screenshots_2.gif&quot;</span></span><br><span class="line"></span><br><span class="line">  # ―――  Spec License  ――――――――――――――――――――――――――――――――――――――――――――――――――――――――――― #</span><br><span class="line">  #</span><br><span class="line">  #  当前组件库所使用的证书，可以查看 http:<span class="comment">//choosealicense.com 对应的说明，CocoaPods将会查看对应的组件库是否有文件名为LICENSE*的文件</span></span><br><span class="line">  #  比较常见的有 <span class="string">&#x27;MIT&#x27;</span>, <span class="string">&#x27;BSD&#x27;</span><span class="string">&#x27;Apache License, Version 2.0&#x27;</span> 类型</span><br><span class="line">  #</span><br><span class="line">  # 许可证</span><br><span class="line">  s.license      = <span class="string">&quot;MIT (example)&quot;</span></span><br><span class="line">  # s.license      = &#123; :type =&gt; <span class="string">&quot;MIT&quot;</span>, :file =&gt; <span class="string">&quot;FILE_LICENSE&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line">  # ――― Author Metadata  ――――――――――――――――――――――――――――――――――――――――――――――――――――――――― #</span><br><span class="line">  #</span><br><span class="line">  #  这里可以指定作者名称，邮箱，以及社交网站主页地址</span><br><span class="line">  #</span><br><span class="line">  s.author             = &#123; <span class="string">&quot;Xiaohai.lin&quot;</span> =&gt; <span class="string">&quot;tbfungeek@163.com&quot;</span> &#125;</span><br><span class="line">  # Or just: s.author    = <span class="string">&quot;Xiaohai.lin&quot;</span></span><br><span class="line">  # s.authors            = &#123; <span class="string">&quot;Xiaohai.lin&quot;</span> =&gt; <span class="string">&quot;tbfungeek@163.com&quot;</span> &#125;</span><br><span class="line">  # s.social_media_url   = <span class="string">&quot;http://twitter.com/Xiaohai.lin&quot;</span></span><br><span class="line"></span><br><span class="line">  # ――― Platform Specifics ――――――――――――――――――――――――――――――――――――――――――――――――――――――― #</span><br><span class="line">  #</span><br><span class="line">  #  这里可以指定对应的平台信息</span><br><span class="line">  #</span><br><span class="line">  # s.platform     = :ios</span><br><span class="line">  s.platform     = :ios, <span class="string">&quot;9.0&quot;</span></span><br><span class="line"></span><br><span class="line">  #  When using multiple platforms</span><br><span class="line">  # s.ios.deployment_target = <span class="string">&quot;5.0&quot;</span></span><br><span class="line">  # s.osx.deployment_target = <span class="string">&quot;10.7&quot;</span></span><br><span class="line">  # s.watchos.deployment_target = <span class="string">&quot;2.0&quot;</span></span><br><span class="line">  # s.tvos.deployment_target = <span class="string">&quot;9.0&quot;</span></span><br><span class="line">  # ――― Source Location ―――――――――――――――――――――――――――――――――――――――――――――――――――――――――― #</span><br><span class="line">  #</span><br><span class="line">  #  这里用于指定到哪里获取代码，CocoasPods支持git, hg, bzr, svn， HTTP等协议的代码托管地址</span><br><span class="line">  #</span><br><span class="line"></span><br><span class="line">  s.source       = &#123; :git =&gt; <span class="string">&quot;https://github.com/tbfungeek/IDLKeyChainTool.git&quot;</span>, :tag =&gt; <span class="string">&quot;#&#123;s.version&#125;&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line">  # ――― Source Code ―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――― #</span><br><span class="line">  #</span><br><span class="line">  #  CocoaPods 中一般使用一个文件夹作为代码文件夹，文件夹下可以包含</span><br><span class="line">  #  swift, h, m, mm, c/cpp文件，只要在s.source_files中指定就好</span><br><span class="line">  #  s.exclude_files中指定的文件会被剔除，而s.public_header_files文件将会对全局可见</span><br><span class="line">  #</span><br><span class="line"></span><br><span class="line">  s.source_files  = <span class="string">&quot;Classes&quot;</span>, <span class="string">&quot;Classes/**/*.&#123;h,m&#125;&quot;</span></span><br><span class="line">  s.exclude_files = <span class="string">&quot;Classes/Exclude&quot;</span></span><br><span class="line">  # 引入的共有头文件</span><br><span class="line">  # s.public_header_files = <span class="string">&quot;Classes/**/*.h&quot;</span></span><br><span class="line">  # 引入的私有头文件</span><br><span class="line">  #spec.private_header_files = <span class="string">&#x27;Headers/Private/*.h&#x27;</span></span><br><span class="line"></span><br><span class="line">  # ――― Resources ――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――</span><br><span class="line">  #</span><br><span class="line">  #  下面指定的资源将会通过build phase脚本拷贝到指定的bundle。</span><br><span class="line">  #</span><br><span class="line"></span><br><span class="line">  # s.resource  = <span class="string">&quot;icon.png&quot;</span></span><br><span class="line">  # s.resources = <span class="string">&quot;Resources/*.png&quot;</span></span><br><span class="line">  # s.preserve_paths = <span class="string">&quot;FilesToSave&quot;</span>, <span class="string">&quot;MoreFilesToSave&quot;</span></span><br><span class="line"></span><br><span class="line">  # ――― Project Linking ―――――――――――――――――――――――――――――――――――――――――――――――――――――――――― #</span><br><span class="line">  #</span><br><span class="line">  #  该组件库相关的frameworks以及libraries，其中libraries不用包括它的名字前缀</span><br><span class="line">  #</span><br><span class="line"></span><br><span class="line">  # s.framework  = <span class="string">&quot;SomeFramework&quot;</span></span><br><span class="line">  # s.frameworks = <span class="string">&quot;SomeFramework&quot;</span>, <span class="string">&quot;AnotherFramework&quot;</span></span><br><span class="line"></span><br><span class="line">  # s.library   = <span class="string">&quot;iconv&quot;</span></span><br><span class="line">  # s.libraries = <span class="string">&quot;iconv&quot;</span>, <span class="string">&quot;xml2&quot;</span></span><br><span class="line"></span><br><span class="line">  # ――― Project Settings ――――――――――――――――――――――――――――――――――――――――――――――――――――――――― #</span><br><span class="line">  #</span><br><span class="line">  # 在这里可以指定对应的编译选项以及依赖的三方库</span><br><span class="line">  #</span><br><span class="line"></span><br><span class="line">  s.requires_arc = true</span><br><span class="line">  # s.xcconfig = &#123; <span class="string">&quot;HEADER_SEARCH_PATHS&quot;</span> =&gt; <span class="string">&quot;$(SDKROOT)/usr/include/libxml2&quot;</span> &#125;</span><br><span class="line">  # s.dependency <span class="string">&quot;JSONKit&quot;</span>, <span class="string">&quot;~&gt; 1.4&quot;</span></span><br><span class="line"></span><br><span class="line">  # ――― Subspecs ――――――――――――――――――――――――――――――――――――――――――――――――――――――――― #</span><br><span class="line">  #</span><br><span class="line">  # 将组件分为多个子组件，接入方可以根据需求只接入几个子组件，减少包体积</span><br><span class="line">  #subspec <span class="string">&#x27;Twitter&#x27;</span> do |sp|</span><br><span class="line">  #   sp.source_files = <span class="string">&#x27;Classes/Twitter&#x27;</span></span><br><span class="line">  #end</span><br><span class="line"></span><br><span class="line">  # 测试组件</span><br><span class="line">  #spec.test_spec do |test_spec|</span><br><span class="line">  #    test_spec.source_files = <span class="string">&#x27;NSAttributedString+CCLFormatTests.m&#x27;</span></span><br><span class="line">  #    test_spec.dependency <span class="string">&#x27;Expecta&#x27;</span></span><br><span class="line">  #end</span><br><span class="line">  # 默认子组件。也就是当接入方不作区分时，直接使用组件名引入时，所引入子组件</span><br><span class="line">  #spec.default_subspec = <span class="string">&#x27;Core&#x27;</span></span><br><span class="line">end</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> </p>
<h6 id="1-创建GitHub-代码仓库"><a href="#1-创建GitHub-代码仓库" class="headerlink" title="1 创建GitHub 代码仓库"></a>1 创建GitHub 代码仓库</h6><p>这里需要创建两个GitHub库，一个是Spec仓库,一个是组件代码仓库，我们这里先介绍组件代码仓库，最后的时候会给大家介绍Spec仓库：</p>
<p>首先创建一个代码仓库用于存放组件代码，如下所示：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/tbfungeek/IDLUtils.git">https://github.com/tbfungeek/IDLUtils.git</a></p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;xxxxxxxxxx&quot;</span></span><br><span class="line">git remote add origin https:<span class="regexp">//gi</span>thub.com<span class="regexp">/tbfungeek/</span>IDLUtils.git</span><br><span class="line"><span class="regexp">//gi</span>t pull --rebase origin master</span><br><span class="line"><span class="regexp">//</span>解决冲突</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>

<p>将组件代码push到远端仓库，新建tag</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">git</span> tag <span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>将本地的tag推送到远程仓库</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">git push <span class="comment">--tags</span></span><br></pre></td></tr></table></figure>

<p>注意tag号要和s.version保持一致</p>
<p>在上面工作完成后运行<strong><strong>pod lib lint IDLUtils.podspec</strong></strong>对podspec文件进行校验。如果遇到有问题可以通过****–verbose****来看详细的过程。</p>
<p>下面是可能会遇到的导致校验不过的可能问题：</p>
<p><strong><strong>情景一：</strong></strong></p>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line">[!] IDLUtils did <span class="keyword">not</span> pass validation, due <span class="keyword">to</span> <span class="number">1</span> <span class="literal">warning</span> (but you can <span class="keyword">use</span> `<span class="comment">--allow-warnings` to ignore it).</span></span><br><span class="line">You can <span class="keyword">use</span> the `<span class="comment">--no-clean` option to inspect any issue.</span></span><br></pre></td></tr></table></figure>

<p>这种情况下通过****–verbose**** 看下如果warning没问题可以通过****–allow-warnings**** 忽略错误。</p>
<p><strong><strong>情景二：</strong></strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">.podspec error <span class="operator">-</span> source_files` <span class="keyword">pattern</span> did <span class="keyword">not</span> <span class="keyword">match</span> <span class="keyword">any</span> file</span><br></pre></td></tr></table></figure>
<p>这种一般是只是将文件放置到Class目录，没有将Class添加到XCode的引用关系中。</p>
<p><strong><strong>情景三：</strong></strong></p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">C<span class="function"><span class="title">ould</span> <span class="built_in">not</span> find a `ios` simulator， Ensure that Xcode -&gt;</span> W<span class="function"><span class="title">indow</span> -&gt;</span> Devices has <span class="built_in">at</span> least on</span><br></pre></td></tr></table></figure>
<p>升级cocoaPods版本。</p>
<p><strong><strong>情景四：</strong></strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="string">[!]</span> Found multiple specifications</span><br></pre></td></tr></table></figure>

<p>将私有仓库拉到本地时可能会存在两个。移除重复的库。</p>
<p>有时候你会发现什么都对，但是结果不对，你就可以进入对应的缓存中查看下实际的内容是怎样的？或者使用下面的命令清除缓存看下：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">rm ~<span class="regexp">/Library/</span>Caches<span class="regexp">/CocoaPods/</span>search_index.json</span><br><span class="line">rm -fr  ~<span class="regexp">/Library/</span>Caches<span class="regexp">/CocoaPods/</span>Pods<span class="regexp">/External/</span>IDLUtils</span><br><span class="line">rm -fr  ~<span class="regexp">/Library/</span>Caches<span class="regexp">/CocoaPods/</span>Pods<span class="regexp">/Specs/</span>External<span class="regexp">/IDLUtils/</span></span><br></pre></td></tr></table></figure>

<h6 id="3-注册CocoaPods"><a href="#3-注册CocoaPods" class="headerlink" title="3 注册CocoaPods"></a>3 注册CocoaPods</h6><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">pod trunk register tbfungeek@<span class="number">163</span><span class="selector-class">.com</span> <span class="string">&#x27;tbfungeek&#x27;</span> <span class="attr">--description</span>=<span class="string">&#x27;tbfungeek&#x27;</span></span><br></pre></td></tr></table></figure>

<p>这时候注册邮箱会收到一份验证邮件，通过邮件链接可以完成注册</p>
<h6 id="4-将podspec-push-到-CocoaPods-Specs"><a href="#4-将podspec-push-到-CocoaPods-Specs" class="headerlink" title="4 将podspec push 到 CocoaPods Specs"></a>4 将podspec push 到 CocoaPods Specs</h6><figure class="highlight arcade"><table><tr><td class="code"><pre><span class="line">pod trunk <span class="built_in">push</span> IDLUtils.podspec</span><br></pre></td></tr></table></figure>

<h5 id="创建私有Spec-仓库"><a href="#创建私有Spec-仓库" class="headerlink" title="创建私有Spec 仓库"></a>创建私有Spec 仓库</h5><h6 id="1-新建私有仓库"><a href="#1-新建私有仓库" class="headerlink" title="1.新建私有仓库"></a>1.新建私有仓库</h6><p>目前github也支持私有仓库了，所以可以在github，gitlab上创建一个。</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">https:<span class="regexp">//gi</span>thub.com<span class="regexp">/tbfungeek/</span>IDLPodSpecs.git</span><br></pre></td></tr></table></figure>

<h6 id="2-将私有仓库添加到本地"><a href="#2-将私有仓库添加到本地" class="headerlink" title="2.将私有仓库添加到本地"></a>2.将私有仓库添加到本地</h6><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">pod repo add IDLPodSpecs https:<span class="regexp">//gi</span>thub.com<span class="regexp">/tbfungeek/</span>IDLPodSpecs.git</span><br></pre></td></tr></table></figure>
<p>这时候会将IDLPodSpecs clone 到 ~&#x2F;.cocoapods&#x2F;repos 目录</p>
<h6 id="3-提交-podspec-至私有-Spec-仓库"><a href="#3-提交-podspec-至私有-Spec-仓库" class="headerlink" title="3. 提交 podspec 至私有 Spec 仓库"></a>3. 提交 podspec 至私有 Spec 仓库</h6><figure class="highlight arcade"><table><tr><td class="code"><pre><span class="line">pod repo <span class="built_in">push</span> IDLPodSpecs IDLUtils.podspec</span><br></pre></td></tr></table></figure>

<h6 id="4-在项目中应用该私有库"><a href="#4-在项目中应用该私有库" class="headerlink" title="4. 在项目中应用该私有库"></a>4. 在项目中应用该私有库</h6><p>在Podfile 头部添加repo 源</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> <span class="string">&#x27;https://github.com/tbfungeek/IDLPodSpecs.git&#x27;</span></span><br><span class="line"><span class="built_in">source</span> <span class="string">&#x27;https://github.com/CocoaPods/Specs.git&#x27;</span></span><br></pre></td></tr></table></figure>
<p>接下来就可以使用了</p>
<h5 id="更深入学习"><a href="#更深入学习" class="headerlink" title="更深入学习"></a><strong><strong>更深入学习</strong></strong></h5><p>学习了上面的技术够一般项目使用了，但是随着项目推进，你会发现项目编译速度会越来越慢，甚至达到难以容忍的地步，这时候就需要进行CocoaPods 的组件二进制化，这样就省去了各个组件库的编译速度。这个会在后续章节中专门开一篇博客进行介绍，大家如果感兴趣可以事先了解下，下面是一篇个人认为写得比较好的一篇博客，推荐给大家。</p>
<p><a target="_blank" rel="noopener" href="https://dmanager.github.io/ios/2019/01/21/%E5%9F%BA%E4%BA%8ECocoaPods%E7%9A%84%E7%BB%84%E4%BB%B6%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8C%96%E5%AE%9E%E8%B7%B5/">基于 CocoaPods 的组件二进制化实践</a><br><a target="_blank" rel="noopener" href="https://www.google.com/search?q=CocoaPods+%E7%9A%84%E7%BB%84%E4%BB%B6%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8C%96&oq=CocoaPods+%E7%9A%84%E7%BB%84%E4%BB%B6%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8C%96&aqs=chrome..69i57j69i64j69i60.360j0j0&sourceid=chrome&ie=UTF-8">Google – CocoaPods 的组件二进制化</a></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/iOS-%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/">iOS 理论基础</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/iOS-理论基础/">iOS 理论基础</a>
  </div>

</div>



<div class="comments-count">
	
	  	<span></span>
		<a href="/2019/08/26/Cocopods-使用/#comments" class="ds-thread-count comments-count-link" data-thread-key="2019/08/26/Cocopods-使用/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/08/24/使用LLDB来辅助调试iOS程序/" title="使用LLDB来辅助调试iOS程序" itemprop="url">使用LLDB来辅助调试iOS程序</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Edgar" target="_blank" itemprop="author">Edgar</a>
		
  <p class="article-time">
    <time datetime="2019-08-24T06:29:11.000Z" itemprop="datePublished"> Published 2019-08-24</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h4 id="开发中常用的LLDB调试命令"><a href="#开发中常用的LLDB调试命令" class="headerlink" title="开发中常用的LLDB调试命令"></a>开发中常用的LLDB调试命令</h4><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">启动                      run</span><br><span class="line">调试可执行文件              lldb /Projects/Sketch/build/Debug/Sketch<span class="selector-class">.app</span> </span><br><span class="line">调试运行时带参数的可执行文件   lldb -- DebugDemo<span class="selector-class">.run</span> <span class="selector-attr">[参数列表]</span></span><br><span class="line">调试某个正在运行中的进程   </span><br><span class="line"><span class="number">1</span>.启动lldb lldb  </span><br><span class="line"><span class="number">2</span>.附到某个进程 process attach <span class="attr">--pid</span> <span class="number">9939</span>  或者 process attach <span class="attr">--name</span> Safari </span><br><span class="line">查看代码 list  或者 l</span><br><span class="line">看其他文件的代码 list 文件名 然后在用l来查看</span><br><span class="line">看某个函数的代码 list <span class="selector-tag">main</span></span><br><span class="line"></span><br><span class="line">breakpoint  <span class="selector-attr">[断点管理]</span></span><br><span class="line">breakpoint set <span class="attr">--file</span> foo<span class="selector-class">.c</span> <span class="attr">--line</span> <span class="number">12</span></span><br><span class="line"><span class="selector-tag">b</span> <span class="selector-tag">main</span><span class="selector-class">.m</span>:<span class="number">127</span> 推荐这种写法</span><br><span class="line">breakpoint set <span class="attr">--selector</span> alignLeftEdges:</span><br><span class="line"><span class="selector-tag">b</span> functionName:</span><br><span class="line"><span class="selector-tag">b</span> +<span class="selector-attr">[NSSet setWithObject:]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">breakpoint list</span><br><span class="line">breakpoint enable &lt;breakpointID&gt;</span><br><span class="line">breakpoint disable &lt;breakpointID&gt;</span><br><span class="line">breakpoint delete &lt;breakpointID&gt;</span><br><span class="line"></span><br><span class="line">调试</span><br><span class="line">c<span class="selector-attr">[继续运行]</span> n<span class="selector-attr">[Step over]</span> s<span class="selector-attr">[Step into]</span> finish<span class="selector-attr">[Step out]</span></span><br><span class="line"></span><br><span class="line">变量输出</span><br><span class="line"><span class="selector-tag">p</span> 变量  <span class="selector-attr">[打印出某个变量的详细信息]</span> </span><br><span class="line">默认的格式  <span class="selector-tag">p</span> <span class="number">16</span> </span><br><span class="line">十六进制:   p/x <span class="number">16</span></span><br><span class="line">二进制:     p/t <span class="number">16</span></span><br><span class="line">po 变量 <span class="selector-attr">[打印出某个变量的简要信息]</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">p</span> $<span class="number">0</span> = <span class="number">23</span> <span class="selector-attr">[修改变量值]</span></span><br><span class="line"></span><br><span class="line"><span class="selector-attr">[代码帧调试]</span></span><br><span class="line">bt 当前栈信息  配合up down 指令使用</span><br><span class="line">frame select <span class="number">0</span> <span class="selector-attr">[查看某个栈代码]</span></span><br><span class="line">frame variable <span class="selector-attr">[查看方法的调用者及方法名称]</span></span><br><span class="line"></span><br><span class="line"><span class="selector-attr">[地址映射到代码]</span></span><br><span class="line">image lookup -<span class="selector-tag">a</span> 栈地址 寻找栈地址对应的代码位置 </span><br><span class="line"></span><br><span class="line">安装 LLDB插件 <span class="selector-attr">[chisel 及 LLDB]</span></span><br><span class="line">!<span class="selector-attr">[chisel]</span>(https:<span class="comment">//github.com/facebook/chisel)</span></span><br><span class="line">!<span class="selector-attr">[LLDB]</span>(https:<span class="comment">//github.com/DerekSelander/LLDB)</span></span><br><span class="line"></span><br><span class="line">查看某个类或者实例的方法</span><br><span class="line">methods IDLZipTool</span><br><span class="line"></span><br><span class="line">taplog 点击控件，会打印控件的地址，大小及透明度等信息 后面跟的控件id可以用于后续操作</span><br><span class="line">flicker 控件会闪烁</span><br><span class="line">hide  <span class="number">0</span>x7f7edd64b280 隐藏控件</span><br><span class="line">show <span class="number">0</span>x7f7edd64b280  显示控件</span><br><span class="line"><span class="attribute">border</span> <span class="number">0</span>x7f7edd64b280 -c red -w <span class="number">10</span> 给控件加边框</span><br><span class="line">pclass encryptStr  打印继承关系</span><br><span class="line">presponder <span class="number">0</span>x7faa9455d2f0 打印响应链</span><br><span class="line"></span><br><span class="line">给某个控件设置背景</span><br><span class="line">(lldb) <span class="selector-tag">p</span> <span class="number">0</span>x7faa9455d2f0</span><br><span class="line">(long) $<span class="number">44</span> = <span class="number">140370609820400</span></span><br><span class="line">(lldb) <span class="selector-tag">p</span> (void)<span class="selector-attr">[$44 setBackgroundColor:[UIColor redColor]</span>]</span><br><span class="line">(lldb) caflush</span><br><span class="line">pviews 打印继承树</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="较好的文章推荐"><a href="#较好的文章推荐" class="headerlink" title="较好的文章推荐"></a>较好的文章推荐</h4><p>[1]. <a target="_blank" rel="noopener" href="https://www.colabug.com/5606133.html">LLDB调试利器及高级用法</a><br>[2]. <a target="_blank" rel="noopener" href="https://casatwy.com/shi-yong-lldbdiao-shi-cheng-xu.html">使用LLDB调试程序</a><br>[3]. <a target="_blank" rel="noopener" href="https://blog.cnbluebox.com/blog/2015/03/05/chisel/">Chisel-LLDB命令插件，让调试更Easy</a><br>[4]. <a target="_blank" rel="noopener" href="https://lldb.llvm.org/use/map.html">GDB to LLDB command map</a><br>[5]. <a target="_blank" rel="noopener" href="https://lldb.llvm.org/">The LLDB Debugger</a><br>[6]. <a target="_blank" rel="noopener" href="http://junch.github.io/debug/2016/09/19/original-lldb.html">Debug on the iOS Simulator with LLDB</a><br>[7]. <a target="_blank" rel="noopener" href="https://www.objc.io/issues/19-debugging/lldb-debugging/">跳舞吧！与LLDB共舞华尔兹</a></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/iOS-%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/">iOS 工具使用</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/iOS-工具使用/">iOS 工具使用</a>
  </div>

</div>



<div class="comments-count">
	
	  	<span></span>
		<a href="/2019/08/24/使用LLDB来辅助调试iOS程序/#comments" class="ds-thread-count comments-count-link" data-thread-key="2019/08/24/使用LLDB来辅助调试iOS程序/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/08/20/XCode-快捷键/" title="XCode 快捷键" itemprop="url">XCode 快捷键</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Edgar" target="_blank" itemprop="author">Edgar</a>
		
  <p class="article-time">
    <time datetime="2019-08-20T06:31:42.000Z" itemprop="datePublished"> Published 2019-08-20</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>XCode 常用快捷键</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>. 工程导航器<span class="symbol">:Command+</span><span class="number">1</span></span><br><span class="line">在光标定位到导航栏区域后按左右键可用于展开和合并目录</span><br><span class="line"><span class="title class_">Command</span> + 上下按钮用于在不显示具体文件的情况下移动选中文件</span><br><span class="line">如果不按command 只按上下键 则边移动边选中文件</span><br><span class="line"></span><br><span class="line">显示/隐藏实用工具面板<span class="symbol">:Command+Option+</span><span class="number">0</span></span><br><span class="line"><span class="title class_">Command</span> <span class="number">1</span> - <span class="number">8</span> 对应导航栏面板上的<span class="number">8</span>个按钮</span><br><span class="line">显示/隐藏导航器面板<span class="symbol">:Command+</span><span class="number">0</span></span><br><span class="line">c.command + shift + Y 隐藏调试栏</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>. 快速查找某个文件 <span class="title class_">Command</span> + <span class="title class_">Shift</span> + O </span><br><span class="line">在文件导航栏上定位文件 <span class="title class_">Command</span> + <span class="title class_">Shift</span> + J</span><br><span class="line">快速跳转到类的特定行command + L</span><br><span class="line">文件跳转栏<span class="symbol">:Control+</span><span class="number">6</span>（键入方法/变量名+<span class="title class_">Enter</span>跳转）</span><br><span class="line"><span class="title class_">Show</span> <span class="title class_">Related</span> <span class="title class_">Items</span>：<span class="title class_">Control</span> + <span class="number">1</span>（注：可以查看光标所在方法的callers和callees）</span><br><span class="line">类文件<span class="string">&quot;.h&quot;</span>与“.m”之间切换：control+command+↑/control+command+↓</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>.  代码操作快捷键</span><br><span class="line"></span><br><span class="line">注释代码： 快捷键<span class="symbol">:command</span> + /</span><br><span class="line">代码右缩进 :  command + [</span><br><span class="line">代码左缩进  :  command + ]</span><br><span class="line">快速创建文件  command + N</span><br><span class="line">删除整行：先把光标移到行末，再操作<span class="title class_">Command</span> + delete</span><br><span class="line">向上/下 移动整行：<span class="title class_">Option</span> + <span class="title class_">Command</span> + [ / ]</span><br><span class="line">双击某个分隔符（如()、[]、&#123;&#125; 等），<span class="title class_">Xcode</span>会选中匹配代码块</span><br><span class="line"></span><br><span class="line">在项目导航器中选中文件执行<span class="title class_">Option</span>+左键点击操作。</span><br><span class="line">搜索导航器(<span class="title class_">Find</span> <span class="title class_">Navigator</span>，也就是搜索)<span class="symbol">:Command+Shift+F</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span>.  调试快捷键</span><br><span class="line">运行<span class="symbol">app:</span> <span class="title class_">Command</span> + R</span><br><span class="line">清除工程: <span class="title class_">Command</span> + <span class="title class_">Shift</span> + K</span><br><span class="line">清除控制台打印信息<span class="symbol">:command+K</span></span><br><span class="line"><span class="title class_">F6</span>单步调试、<span class="title class_">F7</span>跳入，<span class="title class_">F8</span>继续</span><br><span class="line"><span class="title class_">Command</span> + \: 设置或取消断点</span><br><span class="line"><span class="title class_">Command</span> + <span class="title class_">Option</span> + \: 允许或禁用当前断点</span><br><span class="line"></span><br></pre></td></tr></table></figure>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/iOS-%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/">iOS 工具使用</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/iOS-工具使用/">iOS 工具使用</a>
  </div>

</div>



<div class="comments-count">
	
	  	<span></span>
		<a href="/2019/08/20/XCode-快捷键/#comments" class="ds-thread-count comments-count-link" data-thread-key="2019/08/20/XCode-快捷键/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/08/14/iOS-多线程总结-锁/" title="iOS 多线程总结 - 线程安全" itemprop="url">iOS 多线程总结 - 线程安全</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Edgar" target="_blank" itemprop="author">Edgar</a>
		
  <p class="article-time">
    <time datetime="2019-08-14T02:14:03.000Z" itemprop="datePublished"> Published 2019-08-14</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h5 id="1-多线程时间分片模式"><a href="#1-多线程时间分片模式" class="headerlink" title="1. 多线程时间分片模式:"></a><strong><strong>1. 多线程时间分片模式:</strong></strong></h5><p>多数现代操作系统使用时间分片模式来管理线程的，它会将CPU运行时间分割成一个个时间片，一般在10-100毫秒之间不等，当线程被分配到执行时间后，系统将会将该线程的堆栈以及寄存器加载到CPU，并将旧线程的堆栈和寄存器数据保存起来，这就是所谓的上下文切换，这个切换也是需要耗费时间的，如果将时间片分割得太短就会导致过度频繁的上下文切换，从而导致大量的CPU时间浪费在切换上。这也是自旋锁存在的原因，这个在后面会详细介绍。</p>
<p>今天介绍的主题是线程安全，之前我们说过同一进程的线程之间是共享资源的，并且多线程是并发执行的，在这种并发环境下资源共享带来的一个问题就是资源竞争，竞争的资源可以是：锁、网络连接、通知事件，磁盘、带宽，以及一切可以被称作“资源”的东西，如果没有对共享资源进行保护，就会导致多个线程对资源进行修改，从而导致资源状态不确定，也就是我们所说的<strong><strong>数据竞态</strong></strong>。</p>
<p>但是并不是所有情况下多线程访问共享资源都会存在这些问题。<br>以下这些情况就不存在线程安全的情况：</p>
<ul>
<li>多线程串行访问共享资源，这也是很多时候解决数据竞态的一种方案，将访问资源的操作串行化。</li>
<li>多线程并行情况下但是这些线程都是访问共享资源而不去修改共享资源，比如多个线程同时读一个文件。</li>
</ul>
<p>所以发生数据竞态的条件有两个:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1.</span> 至少有两个线程同时访问同一个资源</span><br><span class="line"><span class="bullet">2.</span> 至少其中有一个是改变资源的状态，比如写操作</span><br></pre></td></tr></table></figure>

<h5 id="2-基础概念"><a href="#2-基础概念" class="headerlink" title="2. 基础概念"></a><strong><strong>2. 基础概念</strong></strong></h5><ol>
<li><strong><strong>临界区</strong></strong>：指的是一块对公共资源进行访问的代码</li>
<li><strong><strong>竞态条件</strong></strong>：当两个线程竞争同一资源时，如果对资源的访问顺序敏感，就称存在竞态条件</li>
<li><strong><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/ktgu/p/3529143.html">死锁</a></strong></strong>:是指两个或两个以上的线程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去</li>
</ol>
<p><strong><strong>死锁发生的条件:</strong></strong></p>
<ul>
<li><strong><strong>互斥条件</strong></strong>：线程对资源的访问是排他性的，如果一个线程占用了某个资源，那么其他线程等待，直到锁被释放。</li>
<li><strong><strong>不可剥夺条件</strong></strong>：线程已获得的资源，在未使用完之前，不能被其他线程剥夺，只能在使用完以后由自己释放。</li>
<li><strong><strong>保持和请求条件</strong></strong>：线程T1至少已经保持了一个资源R1占用,但又提出对另一个资源R2请求，而此时，资源R2被其他线程T2占用，于是该线程T1也必须等待，但又对自己保持的资源R1不释放。</li>
<li><strong><strong>环路等待条件</strong></strong>：在死锁发生时，必然存在一个“线程-资源环形链”，即：{p0,p1,p2,…pn},进程p0（或线程）等待p1占用的资源，p1等待p2占用的资源，pn等待p0占用的资源。</li>
</ul>
<ol start="4">
<li><p><strong><strong>资源饥饿</strong></strong>: 当一个线程一直无法得到自己的资源而一直无法进行后续的操作时，我们称这个线程会饥饿而死。</p>
</li>
<li><p><strong><strong>优先级反转</strong></strong>:<br>优先级反转是在高优级(假设为A)的任务要访问一个被低优先级任务(假设为C)占有的资源时被阻塞.<br>而此时又有优先级高于占有资源的任务(C)，而低于被阻塞的任务(A)的优先级的中间优先级任务(假设为B)进入时,这时候,占有资源的任务(C)就被挂起(占有的资源仍为它占有),因为占有资源的任务优先级很低,所以,它可能一直被另外的任务挂起.而它占有的资源也就一直不能释放,这样,引起任务A一直没办法执行.而比它优先低的任务却可以执行.</p>
</li>
</ol>
<p>  </p>
<p><strong><strong>解决方案</strong></strong>:</p>
<ul>
<li><strong><strong>优先级继承</strong></strong>:将低优先级任务的优先级提升到等待它所占有的资源的最高优先级任务的优先级.当高优先级任务由于等待资源而被阻塞时,此时资源的拥有者的优先级将会自动被提升.   </li>
<li><strong><strong>优先级天花板</strong></strong>:将申请某资源的任务的优先级提升到可能访问该资源的所有任务中最高优先级任务的优先级<br>两者区别：<br>优先级继承,只有当占有资源的低优先级的任务被阻塞时,才会提高占有资源任务的优先级,而优先级天花板,不论是否发生阻塞都提升.</li>
</ul>
<ol start="6">
<li><strong><strong>原子操作</strong></strong>: 一条不可打断的操作,在单处理器环境下，一条汇编指令是原子操作，但一句高级语言的代码却不是原子的，因为它最终是由多条汇编语言完成</li>
<li><strong><strong>可重入</strong></strong>:当子程序正在运行时，执行线程可以再次进入并执行它，仍然获得符合设计时预期的结果。与多线程并发执行的线程安全不同，可重入强调对单个线程执行时重新进入同一个子程序仍然是安全的</li>
<li><strong><strong>线程安全</strong></strong>:指某个函数、函数库在多线程环境中被调用时，能够正确地处理多个线程之间的共享变量，使程序功能正确完成。</li>
</ol>
<h5 id="3-iOS多线程开发中的常用锁"><a href="#3-iOS多线程开发中的常用锁" class="headerlink" title="3. iOS多线程开发中的常用锁:"></a><strong><strong>3. iOS多线程开发中的常用锁</strong></strong>:</h5><h6 id="3-1-互斥锁"><a href="#3-1-互斥锁" class="headerlink" title="3.1 互斥锁"></a><strong><strong>3.1 互斥锁</strong></strong></h6><p>互斥锁在出现锁的争夺时，未获得锁的线程会主动让出时间片，<strong><strong>阻塞线程并睡眠</strong></strong>，CPU会通过上下文切换，让其它线程继续运行。互斥锁用于保证某个资源只允许一个线程访问。</p>
<h6 id="3-1-1-NSLock"><a href="#3-1-1-NSLock" class="headerlink" title="3.1.1 NSLock"></a><strong><strong>3.1.1 NSLock</strong></strong></h6><p>NSLock 内部封装了一个 pthread_mutex，属性为 PTHREAD_MUTEX_ERRORCHECK, 它比pthread_mutex多了错误提示，也正式这个原因它比pthread_mutex性能上要慢，但是由于它在内部使用了缓存机制，所以性能上不会相差很多。但是它使用的时候需要注意的是<strong><strong>加锁和解锁需要成对出现，并且在解锁之前不可以进行再次加锁。否则会造成死锁</strong></strong>。</p>
<figure class="highlight cos"><table><tr><td class="code"><pre><span class="line">NSLock *<span class="keyword">lock</span> = [NSLock alloc] init]<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 加锁</span></span><br><span class="line">[<span class="keyword">lock</span> <span class="keyword">lock</span>]<span class="comment">;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 被加锁的代码区间,在这里可以访问需要锁保护的资源</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 解锁</span></span><br><span class="line">[<span class="keyword">lock</span> unlock]<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>NSLock死锁的例子：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">- (void)recursiveFunc:(NSInteger)value &#123;</span><br><span class="line">    <span class="selector-attr">[self.lock lock]</span>;</span><br><span class="line">    <span class="built_in">if</span>(value != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="attr">--value</span>;</span><br><span class="line">        <span class="selector-attr">[self recursiveFunc:value]</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-attr">[self.lock unlock]</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果不清楚的话展开就应该很容易明白了</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-attr">[self.lock lock]</span>;</span><br><span class="line"><span class="built_in">if</span>(value != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="attr">--value</span>;</span><br><span class="line">    <span class="selector-attr">[self.lock lock]</span>;<span class="comment">//其实这里就因为等待锁而阻塞了</span></span><br><span class="line">    <span class="built_in">if</span>(value != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="attr">--value</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...........</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-attr">[self.lock unlock]</span>;</span><br></pre></td></tr></table></figure>

<p>最后再强调下在使用NSLock的时候注意加解锁需要在统一线程中，并且在解锁之前不能重复加锁。</p>
<h6 id="3-2-递归锁"><a href="#3-2-递归锁" class="headerlink" title="3.2 递归锁"></a><strong><strong>3.2 递归锁</strong></strong></h6><h6 id="3-2-1-NSRecursiveLock"><a href="#3-2-1-NSRecursiveLock" class="headerlink" title="3.2.1 NSRecursiveLock"></a><strong><strong>3.2.1 NSRecursiveLock</strong></strong></h6><p><strong><strong>递归锁在被同一线程重复获取时不会产生死锁</strong></strong>。它会记录上锁和解锁的次数，当二者平衡的时候，才会释放锁，其它线程才可以上锁成功</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSRecursiveLock</span> *recursiveLock;</span><br><span class="line">_recursiveLock = [[<span class="built_in">NSRecursiveLock</span> alloc] init];</span><br><span class="line"></span><br><span class="line">[_recursiveLock lock];</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 被加锁的代码区间,在这里可以访问需要锁保护的资源</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">[_recursiveLock unlock];</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="3-2-2-synchronized"><a href="#3-2-2-synchronized" class="headerlink" title="3.2.2 synchronized"></a><strong><strong>3.2.2 synchronized</strong></strong></h6><p>@synchronized 结构在工作时为传入的对象分配了一个<strong><strong>递归锁</strong></strong>。它需要使用一个唯一的标识用来区分保护锁。</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">@try</span> &#123;</span><br><span class="line">    <span class="built_in">objc_sync_enter</span>(obj);</span><br><span class="line">    <span class="comment">// do work</span></span><br><span class="line">&#125; <span class="keyword">@finally</span> &#123;</span><br><span class="line">    <span class="built_in">objc_sync_exit</span>(obj);    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>当调用 objc_sync_enter(obj) 时，它用 obj <strong><strong>内存地址的哈希值</strong></strong>查找合适的 SyncData(包含传入对象和一个递归锁的结构体)，然后将其上锁。当你调用 objc_sync_exit(obj) 时，它查找合适的 SyncData 并将其解锁。</p>
<p>@synchronized(object)指令使用的 object 为该锁的唯一标识，只有当标识相同时，才满足互斥</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">优点：使用起来十分简单不需要在代码中显式的创建锁对象，便可以实现锁的机制，并且不用担心忘记解锁的情况出现。同时<span class="keyword">synchronized</span>不需要像NSLock一样需要考虑在加解锁时需要在同一线程中的问题，也不需要考虑同一个线程中连续加锁的问题。</span><br><span class="line">缺点：性能较差，一般用在多线程情况下访问属性的情况</span><br></pre></td></tr></table></figure>

<p>注意：如果在 @sychronized(object){} 内部object 被释放或被设为nil，没有问题，但如果 object 一开始就是nil，则失去了锁的功能。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)setIntegerValue:(<span class="built_in">NSInteger</span>)intValue &#123;</span><br><span class="line">    <span class="keyword">@synchronized</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        _intValue = intValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="3-3-自旋锁："><a href="#3-3-自旋锁：" class="headerlink" title="3.3 自旋锁："></a><strong><strong>3.3 自旋锁：</strong></strong></h6><p>自旋锁与互斥锁有点类似，只是自旋锁被某线程占用时，其他线程<strong><strong>不会进入睡眠状态等待，而是一直轮询查询直到锁被释放</strong></strong>。<br>由于不涉及用户态与内核态之间的切换，它的效率远远高于互斥锁。<br>但是自旋锁也有很明显的不足：</p>
<ul>
<li>自旋锁一直占用CPU，在未获得锁的情况下会占用着CPU一直运行，如果不能在很短的时间内获得锁，这无疑会使CPU效率降低。</li>
<li>自旋锁可能会引起优先级反转问题。如果一个低优先级的线程获得锁并访问共享资源，这时一个高优先级的线程也尝试获得这个锁，自旋锁会处于忙等状态从而占用大量 CPU。此时低优先级线程无法与高优先级线程争夺 CPU 时间，从而导致任务迟迟完不成、无法释放 lock。</li>
</ul>
<p>所以一般自旋锁只有在内核可抢占式比较适用，在<strong><strong>单CPU且不可抢占式的内核下自旋锁只适用于锁使用者保持锁时间比较短的情况</strong></strong>。</p>
<h6 id="3-3-1-OSSpinLock"><a href="#3-3-1-OSSpinLock" class="headerlink" title="3.3.1 OSSpinLock"></a><strong><strong>3.3.1 OSSpinLock</strong></strong></h6><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">spinLock = OS_SPINKLOCK_INIT;</span><br><span class="line"><span class="comment">// 加锁</span></span><br><span class="line"><span class="constructor">OSSpinLockLock(&amp;<span class="params">spinLock</span>)</span>;</span><br><span class="line"><span class="comment">// 解锁</span></span><br><span class="line"><span class="constructor">OSSpinLockUnlock(&amp;<span class="params">spinLock</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>目前OSSpinLock存在优先级反转的问题，在使用的时候需要十分注意。<br><a target="_blank" rel="noopener" href="https://blog.ibireme.com/2016/01/16/spinlock_is_unsafe_in_ios/?utm_source=tuicool&utm_medium=referral">不再安全的 OSSpinLock</a></p>
<h6 id="3-3-2-os-unfair-lock"><a href="#3-3-2-os-unfair-lock" class="headerlink" title="3.3.2 os_unfair_lock"></a><strong><strong>3.3.2 os_unfair_lock</strong></strong></h6><p>os_unfair_lock是替代OSSpinLock的产物，iOS 10.+ 之后添加的，也是属于忙等锁。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">#import &lt;os/lock.h&gt;</span><br><span class="line"></span><br><span class="line">os_unfair_lock_t unfairlock = &amp;(OS_UNFAIR_LOCK_INIT);</span><br><span class="line"></span><br><span class="line">os<span class="constructor">_unfair_lock_lock(<span class="params">unfairlock</span>)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 被加锁的代码区间,在这里可以访问需要锁保护的资源</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">os<span class="constructor">_unfair_lock_unlock(<span class="params">unfairlock</span>)</span>;</span><br></pre></td></tr></table></figure>

<h6 id="3-4-信号量"><a href="#3-4-信号量" class="headerlink" title="3.4 信号量"></a><strong><strong>3.4 信号量</strong></strong></h6><p>加锁时会把信号量的值减一，并判断是否大于零。如果大于零，立刻执行。如果等于零的时候将会等待，在资源使用结束的时候释放信号量让信号量增加1。并唤醒等待的线程。<br>信号量可以有更多的取值空间，用来实现更加复杂的同步，而不单单是线程间互斥。</p>
<h6 id="3-4-1-dispatch-semaphore"><a href="#3-4-1-dispatch-semaphore" class="headerlink" title="3.4.1 dispatch_semaphore"></a><strong><strong>3.4.1 dispatch_semaphore</strong></strong></h6><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">dispatch_semaphore_t signal = dispatch<span class="constructor">_semaphore_create(1)</span>;</span><br><span class="line">dispatch_time_t timeout = dispatch<span class="constructor">_time(DISPATCH_TIME_NOW, 3.0f <span class="operator">*</span> NSEC_PER_SEC)</span>;</span><br><span class="line">dispatch<span class="constructor">_async(<span class="params">dispatch_get_global_queue</span>(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)</span>, ^&#123;</span><br><span class="line">    dispatch<span class="constructor">_semaphore_wait(<span class="params">signal</span>, <span class="params">timeout</span>)</span>;   </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 被加锁的代码区间,在这里可以访问需要锁保护的资源</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    dispatch<span class="constructor">_semaphore_signal(<span class="params">signal</span>)</span>;    </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h6 id="3-5-条件锁"><a href="#3-5-条件锁" class="headerlink" title="3.5 条件锁"></a><strong><strong>3.5 条件锁</strong></strong></h6><p>条件锁一般常用于生产者–消费者模式</p>
<h6 id="3-5-1-NSCondition"><a href="#3-5-1-NSCondition" class="headerlink" title="3.5.1 NSCondition"></a><strong><strong>3.5.1 NSCondition</strong></strong></h6><p>NSCondition同样实现了NSLocking协议,可以当做NSLock来使用解决线程同步问题，用法完全一样。但是性能相对更差点，除了lock 和 unlock，NSCondition提供了更高级的用法wait&#x2F;signal&#x2F;broadcast：wait 进入等待状态，当其它线程中的该锁执行signal 或者 broadcast方法时，线程被唤醒，继续运行之后的方法。其中 signal 和 broadcast 方法的区别在于，signal 只是一个信号量，只能唤醒一个等待的线程，想唤醒多个就得多次调用，而 broadcast 可以唤醒所有在等待的线程。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSCondition</span> *condition;</span><br><span class="line">_condition = [[<span class="built_in">NSCondition</span> alloc] init];</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)conditionLockTest &#123;</span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">&quot;com.idealist.locktest&quot;</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSInteger</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">            [<span class="keyword">self</span> conditionAdd];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSInteger</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">            [<span class="keyword">self</span> conditionRemove];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)conditionAdd &#123;</span><br><span class="line">    [_condition lock];</span><br><span class="line">    <span class="comment">// 生产数据</span></span><br><span class="line">    <span class="built_in">NSObject</span> *object = [<span class="built_in">NSObject</span> new];</span><br><span class="line">    [_ticketsArr addObject:object];</span><br><span class="line">    [_condition signal];</span><br><span class="line">    </span><br><span class="line">    [_condition unlock];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)conditionRemove &#123;</span><br><span class="line">    </span><br><span class="line">    [_condition lock];</span><br><span class="line">    <span class="keyword">if</span> (!_ticketsArr.count) &#123;</span><br><span class="line">        [_condition wait];</span><br><span class="line">    &#125;</span><br><span class="line">    [_ticketsArr removeObjectAtIndex:<span class="number">0</span>];</span><br><span class="line">    [_condition unlock];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h6 id="3-5-2-NSConditionLock"><a href="#3-5-2-NSConditionLock" class="headerlink" title="3.5.2 NSConditionLock"></a><strong><strong>3.5.2 NSConditionLock</strong></strong></h6><p>NSConditionLock 借助 NSCondition 来实现，内部持有一个 NSCondition 对象，以及 _condition_value 属性</p>
<p>lockWhenCondition:方法是当condition参数与当前condition相等时才可加锁<br>unlockWithCondition:方法是解锁之后修改 Condition 的值</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置条件</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IDL_NO_DATA   100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IDL_HAS_DATA  101</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化条件锁对象</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSConditionLock</span> *conditionLock;</span><br><span class="line"><span class="comment">// 实例化</span></span><br><span class="line">_conditionLock = [[<span class="built_in">NSConditionLock</span> alloc] initWithCondition:IDL_NO_DATA];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用测试方法</span></span><br><span class="line">- (<span class="type">void</span>)conditionLockTest &#123;</span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">&quot;com.idealist.conditionlocktest&quot;</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSInteger</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">            [<span class="keyword">self</span> conditionLockAdd];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSInteger</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">            [<span class="keyword">self</span> conditionLockRemove];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)conditionLockAdd &#123;</span><br><span class="line">    </span><br><span class="line">    [_conditionLock lockWhenCondition:IDL_NO_DATA];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSObject</span> *object = [<span class="built_in">NSObject</span> new];</span><br><span class="line">    [_ticketsArr addObject:object];</span><br><span class="line">    [_condition signal];</span><br><span class="line">    </span><br><span class="line">    [_conditionLock unlockWithCondition:IDL_HAS_DATA];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)conditionLockRemove &#123;</span><br><span class="line">    </span><br><span class="line">    [_conditionLock lockWhenCondition:IDL_HAS_DATA];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!_ticketsArr.count) &#123;</span><br><span class="line">        [_condition wait];</span><br><span class="line">    &#125;</span><br><span class="line">    [_ticketsArr removeObjectAtIndex:<span class="number">0</span>];</span><br><span class="line">    [_conditionLock unlockWithCondition:IDL_NO_DATA];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="3-6-读写锁"><a href="#3-6-读写锁" class="headerlink" title="3.6 读写锁"></a><strong><strong>3.6 读写锁</strong></strong></h6><p>读写锁把对共享资源的访问者划分成读和写，在多处理器系统中，它允许同时有多个读来访问共享资源，最大可能的读者数为实际的逻辑CPU数。但是写操作是排他性的。<br>所以如下情况可以并发进行：</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="bullet">* </span>多个读，没有写操作</span><br><span class="line"><span class="bullet">* </span>一个写操作，多个读操作</span><br></pre></td></tr></table></figure>
<h6 id="3-6-1-dispatch-barrier-async-x2F-dispatch-barrier-sync"><a href="#3-6-1-dispatch-barrier-async-x2F-dispatch-barrier-sync" class="headerlink" title="3.6.1 dispatch_barrier_async &#x2F; dispatch_barrier_sync"></a><strong><strong>3.6.1 dispatch_barrier_async &#x2F; dispatch_barrier_sync</strong></strong></h6><p>具体用法见iOS多线程总结 基本用法</p>
<ul>
<li>共同点：1、等待在它前面插入队列的任务先执行完；2、等待他们自己的任务执行完再执行后面的任务。</li>
<li>不同点：1、dispatch_barrier_sync将自己的任务插入到队列的时候，需要等待自己的任务结束之后才会继续插入被写在它后面的任务，然后执行它们；2、dispatch_barrier_async将自己的任务插入到队列之后，不会等待自己的任务结束，它会继续把后面的任务插入队列，然后等待自己的任务结束后才执行后面的任务。</li>
</ul>
<h6 id="3-6-1-pthread-rwlock"><a href="#3-6-1-pthread-rwlock" class="headerlink" title="3.6.1 pthread_rwlock"></a><strong><strong>3.6.1 pthread_rwlock</strong></strong></h6><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">#import &lt;pthread.h&gt;</span><br><span class="line">__block pthread_rwlock_t rwlock;</span><br><span class="line">pthread<span class="constructor">_rwlock_init(&amp;<span class="params">rwlock</span>,NULL)</span>;</span><br><span class="line">pthread<span class="constructor">_rwlock_rdlock(&amp;<span class="params">rwlock</span>)</span>;</span><br><span class="line">pthread<span class="constructor">_rwlock_unlock(&amp;<span class="params">rwlock</span>)</span>;</span><br><span class="line">pthread<span class="constructor">_rwlock_wrlock(&amp;<span class="params">rwlock</span>)</span>;</span><br></pre></td></tr></table></figure>

<h6 id="3-7-atomic"><a href="#3-7-atomic" class="headerlink" title="3.7 atomic"></a><strong><strong>3.7 atomic</strong></strong></h6><p>atomic用于保证属性setter、getter的原子性操作，在getter和setter内部加了线程同步的锁，但是它并不能保证使用属性的过程是线程安全的</p>
<h5 id="4-其它保证线程安全的方式"><a href="#4-其它保证线程安全的方式" class="headerlink" title="4. 其它保证线程安全的方式"></a><strong><strong>4. 其它保证线程安全的方式</strong></strong></h5><p>使用异步串行队列来将访问资源的操作串行化</p>
<h5 id="5-pthread的各种同步机制"><a href="#5-pthread的各种同步机制" class="headerlink" title="5. pthread的各种同步机制"></a><strong><strong>5. <a target="_blank" rel="noopener" href="https://casatwy.com/pthreadde-ge-chong-tong-bu-ji-zhi.html">pthread的各种同步机制</a></strong></strong></h5><h5 id="6-性能对比"><a href="#6-性能对比" class="headerlink" title="6. 性能对比"></a><strong><strong>6. 性能对比</strong></strong></h5><p><img src="/2019/08/14/iOS-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%93-%E9%94%81/000001.png"></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/iOS-%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/">iOS 理论基础</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/iOS-理论基础/">iOS 理论基础</a>
  </div>

</div>



<div class="comments-count">
	
	  	<span></span>
		<a href="/2019/08/14/iOS-多线程总结-锁/#comments" class="ds-thread-count comments-count-link" data-thread-key="2019/08/14/iOS-多线程总结-锁/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/08/12/iOS-多线程总结/" title="iOS 多线程总结 - 基本概念 GCD NSOperation" itemprop="url">iOS 多线程总结 - 基本概念 GCD NSOperation</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Edgar" target="_blank" itemprop="author">Edgar</a>
		
  <p class="article-time">
    <time datetime="2019-08-12T09:25:06.000Z" itemprop="datePublished"> Published 2019-08-12</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>在介绍多线程编程的时候我们需要明确一般会在什么场合上使用多线程，我们知道每个进程一定有一个线程–主线程，在这个线程中一般用于更新界面相关的任务，一般任务又可以分成耗时的和非耗时操作，计算密集型的任务和IO密集型任务就属于耗时任务，比如读写数据库，读写磁盘文件，访问网络等，这些一般放在子线程中完成，但是一般在任务完成等时候都会将结果呈现在界面上，这时候就需要在主线程中完成。这个大家应该都知道，但是往往很多人会有误区，是不是线程越多越好，答案是否定的，创建的线程过多有如下问题：</p>
<ul>
<li>从空间角度来看：每个线程都需要占用一定的内存空间，如果开启大量的线程，会占用大量的内存空间，降低程序的性能</li>
<li>线程切换需要上下文切换，这就需要耗费一定的时间，线程越多，CPU在调度线程上的开销就越大，同样会降低程序的性能</li>
<li>线程越多，线程关系越复杂，线程竞争，线程管理，以及死锁等其他多线程问题发生的概率就会相应的增加。</li>
</ul>
<p>因此合理得管理多线程是十分必要的工作。</p>
<p><img src="/2019/08/12/iOS-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%93/0003.png"></p>
<p>下面将从：<br>1.多线程基本概念<br>2.线程通讯<br>3.线程同步，线程安全</p>
<p>三个大方面对iOS多线程技术进行一个简要的总结</p>
<h5 id="1-多线程基本概念"><a href="#1-多线程基本概念" class="headerlink" title="1.多线程基本概念"></a><strong><strong>1.多线程基本概念</strong></strong></h5><h6 id="1-1-多线程编程的基本概念"><a href="#1-1-多线程编程的基本概念" class="headerlink" title="1.1 多线程编程的基本概念"></a><strong><strong>1.1 多线程编程的基本概念</strong></strong></h6><p><strong><strong>进程</strong></strong>: 进程是指系统中正在运行的一个应用程序，进程之间是独立的，有自己专用且受保护的内存空间。<br><strong><strong>线程</strong></strong>: 是操作系统能够进行运算调度的最小单位，是一个CPU执行的一条无分叉的命令序列，进程是由至少一个线程（主线程）构成，同一进程中的多个线程将共享该进程中的全部系统资源，如虚拟地址空间、文件描述符等。但每个线程都拥有自己的栈，寄存器，本地存储<br><strong><strong>并行，串行</strong></strong>: 是针对线程队列的，表示一次可以执行多少个线程，串行队列每次只能执行一个线程，并行队列可以同时执行多个线程。<br><strong><strong>同步，异步</strong></strong>: 是针对线程行为的，指明线程的执行是否要等到任务返回后再往下执行。<br><strong><strong>线程安全</strong></strong>: 指代码在多线程或者并发任务下能够被安全调用，而不会引起任何问题<br><strong><strong>线程生命周期</strong></strong>：</p>
<p>线程生命周期可以分成如下5个阶段：</p>
<ul>
<li><strong><strong>NEW</strong></strong> - <strong><strong>[新建状态]</strong></strong> 表示线程被新建的状态</li>
<li><strong><strong>RUNNABLE</strong></strong> - <strong><strong>[可运行状态]</strong></strong> 新建的线程并不一定会马上被CPU调度，而是进入一个中间状态RUNNABLE状态，等待被CPU调度，处于阻塞状态的线程恢复后不会立刻切换到RUNNING状态，而是先切换到RUNNABLE状态。</li>
<li><strong><strong>RUNNING</strong></strong> -  <strong><strong>[正在运行状态]</strong></strong> 当CPU调度发生，并任务队列中选中了某个RUNNABLE线程时，该线程会进入RUNNING 执行状态。</li>
<li><strong><strong>BLOCKED</strong></strong> - <strong><strong>[阻塞状态]</strong></strong> 由于调用了睡眠，IO阻塞，等待锁的时候会处于阻塞状态。</li>
<li><strong><strong>TERMINATED</strong></strong> - <strong><strong>[终结状态]</strong></strong> 终结状态是线程的最终状态，处于此状态中的线程不会切换到以上任何状态，一旦线程进入了终结状态，就意味着这个线程生命的终结。</li>
</ul>
<p>我们来简单介绍下线程这五种状态的切换图：</p>
<p><img src="/2019/08/12/iOS-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%93/0005.png"></p>
<p>新创建的线程会进入NEW状态，如果有线程正在运行则处于<strong><strong>NEW状态</strong></strong>的线程会转换到<strong><strong>RUNNABLE状态</strong></strong>，等待被CPU调度，一旦正在运行的线程让出了CPU时间，CPU就会从处于<strong><strong>RUNNABLE状态</strong></strong>的线程中取出优先级最高的线程，进入<strong><strong>RUNNING状态</strong></strong>，处于<strong><strong>RUNNING状态</strong></strong>的线程一旦调用了睡眠，IO阻塞，等待锁的时候会处于<strong><strong>BLOCKED状态</strong></strong>。一旦阻塞的条件解除了就会进入<strong><strong>RUNABLE状态</strong></strong>，不论是处于<strong><strong>RUNNING状态</strong></strong>还是<strong><strong>RUNNABLE状态</strong></strong>，还是<strong><strong>BLOCKED状态</strong></strong>只要调用了stop方法，就会进入<strong><strong>TERMINATED状态</strong></strong>。</p>
<h6 id="1-2-iOS多线程实现方案对比"><a href="#1-2-iOS多线程实现方案对比" class="headerlink" title="1.2 iOS多线程实现方案对比"></a><strong><strong>1.2 iOS多线程实现方案对比</strong></strong></h6><p>iOS 多线程方案有如下几种:</p>
<ul>
<li><p><strong><strong>pthread</strong></strong><br>语言: C 语言<br>优点：跨平台，可移植<br>缺点：需要自己管理线程生命周期，所以用得比较少</p>
</li>
<li><p><strong><strong>NSThread</strong></strong><br>语言: OC 语言<br>优点：是针对pthread的面向对象的封装<br>缺点：需要自己管理线程生命周期，使用上还是显得比较麻烦，一般用于查看当前线程状态等不涉及线程周期的场景。</p>
</li>
<li><p><strong><strong>GCD</strong></strong><br>语言: C 语言<br>优点：能够充分发挥多核的特性,自动管理线程生命周期不需要手动管理</p>
</li>
<li><p><strong><strong>NSOperation&amp;&amp;NSOperationQueue</strong></strong><br>语言: OC 语言<br>优点：基于GCD 底层的面向对象封装，添加了线程依赖，并发数控制等功能</p>
</li>
</ul>
<h6 id="1-3-iOS多线程组成："><a href="#1-3-iOS多线程组成：" class="headerlink" title="1.3 iOS多线程组成："></a><strong><strong>1.3 iOS多线程组成：</strong></strong></h6><p>iOS平台多线程的组成如下图所示：</p>
<p><img src="/2019/08/12/iOS-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%93/0004.png"></p>
<p>顶层包括两大部分，一部分是基于OC语言的NSThread和NSOperationQueue类，它们建立在Core Services层的Foundation框架之上，同时也提供了一套基于C语言的GCD线程池函数库来支持多线程的处理应用，这两部分的底层都是基于POSIX标准中的pthread线程库。用户态下的线程创建通过系统调用到达内核态的BSD层并创建bsdthread对象，而BSD层则调用Mach层的ksthread对象来完成最终线程的创建和调度的。</p>
<h6 id="1-4-NSThread的使用"><a href="#1-4-NSThread的使用" class="headerlink" title="1.4 NSThread的使用"></a><strong><strong>1.4 NSThread的使用</strong></strong></h6><p>NSThread的创建：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    param 1：要执行的方法，</span></span><br><span class="line"><span class="comment">    param 2：提供selector的对象，通常是self，</span></span><br><span class="line"><span class="comment">    param 3：传递给selector的参数</span></span><br><span class="line"><span class="comment">    这种方式是默认start的</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">[<span class="built_in">NSThread</span> detachNewThreadSelector:(<span class="keyword">nonnull</span> SEL)&gt; toTarget:(<span class="keyword">nonnull</span> <span class="type">id</span>) withObject:(<span class="keyword">nullable</span> <span class="type">id</span>)]</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    param 1：提供selector的对象，通常是self</span></span><br><span class="line"><span class="comment">    param 2：要执行的方法</span></span><br><span class="line"><span class="comment">    param 3：传递给selector的参数</span></span><br><span class="line"><span class="comment">    这种方式需要手动start</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">NSThread</span> *thread = [[<span class="built_in">NSThread</span> alloc]initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(doSomething) object:<span class="literal">nil</span>];</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    param 1：调用的方法</span></span><br><span class="line"><span class="comment">    param 2：传给selector方法的参数</span></span><br><span class="line"><span class="comment">    隐式创建线程</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">- (<span class="type">void</span>)performSelectorInBackground:(SEL)aSelector withObject:(<span class="type">id</span>)arg</span><br></pre></td></tr></table></figure>

<p>NSThread常见属性:</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="comment">//只读属性，线程是否在执行</span></span><br><span class="line">thread.isExecuting;</span><br><span class="line"><span class="comment">//只读属性，线程是否被取消</span></span><br><span class="line">thread.isCancelled;</span><br><span class="line"><span class="comment">//只读属性，线程是否完成</span></span><br><span class="line">thread.isFinished;</span><br><span class="line"><span class="comment">//是否是主线程</span></span><br><span class="line">thread.isMainThread;</span><br><span class="line"><span class="comment">//线程的优先级，取值范围0.0到1.0，默认优先级0.5，1.0表示最高优先级，优先级高，CPU调度的频率高</span></span><br><span class="line">thread.threadPriority;</span><br><span class="line"><span class="comment">//线程的堆栈大小，线程执行前堆栈大小为512K，线程完成后堆栈大小为0K</span></span><br><span class="line">thread.stackSize;</span><br></pre></td></tr></table></figure>

<p>NSThread常用方法:</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[thread start]</span><span class="comment">; 启动线程</span></span><br><span class="line"><span class="section">[NSThread exit]</span><span class="comment">; 退出线程</span></span><br><span class="line"><span class="section">[NSThread isMainThread]</span><span class="comment">; 当前线程是否为主线程</span></span><br><span class="line"><span class="section">[NSThread isMultiThreaded]</span><span class="comment">; 是否多线程</span></span><br><span class="line"><span class="section">[NSThread mainThread]</span><span class="comment">; 返回主线程的对象</span></span><br><span class="line"><span class="section">[NSThread currentThread]</span><span class="comment">;（1 表示主线程，其他表示后台线程）</span></span><br><span class="line"><span class="section">[NSThread sleepUntilDate:[NSDate date]]</span><span class="comment">; （休眠到指定时间）</span></span><br><span class="line"><span class="section">[NSThread sleepForTimeInterval:4.5]</span><span class="comment">; （休眠指定时长）</span></span><br></pre></td></tr></table></figure>

<p>线程之间的通信:</p>
<figure class="highlight erlang"><table><tr><td class="code"><pre><span class="line">// 在主线程上执行操作</span><br><span class="line">- <span class="params">(void)</span>performSelectorOnMainThread:<span class="params">(SEL)</span>aSelector withObject:<span class="params">(id)</span>arg waitUntilDone:<span class="params">(BOOL)</span>wait;</span><br><span class="line">- <span class="params">(void)</span>performSelectorOnMainThread:<span class="params">(SEL)</span>aSelector withObject:<span class="params">(id)</span>arg waitUntilDone:<span class="params">(BOOL)</span>wait modes:<span class="params">(NSArray&lt;NSString *&gt; *)</span>array;</span><br><span class="line"></span><br><span class="line">// 在指定线程上执行操作</span><br><span class="line">- <span class="params">(void)</span>performSelector:<span class="params">(SEL)</span>aSelector onThread:<span class="params">(NSThread *)</span>thr withObject:<span class="params">(id)</span>arg waitUntilDone:<span class="params">(BOOL)</span>wait modes:<span class="params">(NSArray *)</span>array;</span><br><span class="line">- <span class="params">(void)</span>performSelector:<span class="params">(SEL)</span>aSelector onThread:<span class="params">(NSThread *)</span>thr withObject:<span class="params">(id)</span>arg waitUntilDone:<span class="params">(BOOL)</span>wait;</span><br><span class="line"></span><br><span class="line">// 在当前线程上执行操作，调用 NSObject 的 performSelector:相关方法</span><br><span class="line">- <span class="params">(id)</span>performSelector:<span class="params">(SEL)</span>aSelector;</span><br><span class="line">- <span class="params">(id)</span>performSelector:<span class="params">(SEL)</span>aSelector withObject:<span class="params">(id)</span>object;</span><br><span class="line">- <span class="params">(id)</span>performSelector:<span class="params">(SEL)</span>aSelector withObject:<span class="params">(id)</span>object1 withObject:<span class="params">(id)</span>object2;</span><br></pre></td></tr></table></figure>

<h6 id="1-5-GCD-的使用"><a href="#1-5-GCD-的使用" class="headerlink" title="1.5 GCD 的使用"></a><strong><strong>1.5 GCD 的使用</strong></strong></h6><p>使用GCD 需要明确：需要执行哪些操作，要投递到哪种分发队列，怎么执行这些任务串行还是并行。它有两个核心概念“任务”和“队列”，我们只需专注于想要执行的“任务” block，然后添加到适当的“队列”中，剩余的多线程生命周期管理以及多CPU任务分配问题都是GCD来替我们完成。</p>
<h6 id="1-5-1-GCD-的队列类型"><a href="#1-5-1-GCD-的队列类型" class="headerlink" title="1.5.1 GCD 的队列类型"></a><strong><strong>1.5.1 GCD 的队列类型</strong></strong></h6><p>GCD 有两大类队列：</p>
<ul>
<li>串行队列(Serial Dispatch Queue):</li>
</ul>
<p>串行队列每次只能执行一个任务,但是在应用中可以创建多个串行队列</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">dispatch_queue_t queue = dispatch<span class="constructor">_queue_create(“<span class="params">com</span>.<span class="params">idealist</span>.<span class="params">test</span>”, DISPATCH_QUEUE_SERIAL)</span>;</span><br></pre></td></tr></table></figure>
<p>iOS 默认创建的主线程就是串行队列，获取串行队列可以通过如下方法获取：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">dispatch_get_main_queue</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<p>串行队列的一个很重要的用途就是用于解决数据竞争，因为处于同一个串行队列中两个任务不可能并发运行，所以就没有可能会同时访问同一个临界区的风险。所以仅对于这些任务而言，这种运行机制能够保护临界区避免发生竟态条件</p>
<ul>
<li>并行队列(Concurrent Dispatch Queue):</li>
</ul>
<p>并行队列和散弹枪一样每次可以同时执行多个任务，但是在系统中对同时执行的任务数是有限制的，这取决于CPU核数以及CPU负载等因素决定。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">dispatch_queue_t queue = dispatch<span class="constructor">_queue_create(“<span class="params">com</span>.<span class="params">idealist</span>.<span class="params">test</span>”, DISPATCH_QUEUE_CONCURRENT)</span>;</span><br></pre></td></tr></table></figure>

<p>和串行队列一样iOS系统为创建并行队列增加了全局并行队列：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">dispatch_get_global_queue</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<p>全局队列有四个优先级：</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DISPATCH_QUEUE_PRIORITY_HIGHT </span>      高优先级</span><br><span class="line"><span class="keyword">DISPATCH_QUEUE_PRIORITY_DEFAULT </span>    默认先级</span><br><span class="line"><span class="keyword">DISPATCH_QUEUE_PRIORITY_LOW </span>        低先级</span><br><span class="line"><span class="keyword">DISPATCH_QUEUE_PRIORITY_BACKGROUND </span> 后台优先级</span><br></pre></td></tr></table></figure>

<p><img src="/2019/08/12/iOS-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%93/0001.png"></p>
<h6 id="1-5-2-任务派发函数"><a href="#1-5-2-任务派发函数" class="headerlink" title="1.5.2 任务派发函数"></a><strong><strong>1.5.2 任务派发函数</strong></strong></h6><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_sync</span>(queue, ^&#123;</span><br><span class="line">    <span class="comment">// 这里放同步执行任务代码</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    <span class="comment">// 这里放异步执行任务代码</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>dispatch_sync 函数将一个任务添加到一个队列中，会阻塞当前线程，直到该任务执行完毕。dispatch_async 不会等待任务执行完，当前线程会继续往下走，不会阻塞当前线程。</p>
<p>在使用的时候需要特别注意不要往当前队列中使用dispatch_sync抛任务，这样很容易造成死锁。</p>
<h6 id="1-5-3-GCD-停止和恢复"><a href="#1-5-3-GCD-停止和恢复" class="headerlink" title="1.5.3 GCD 停止和恢复"></a><strong><strong>1.5.3 GCD 停止和恢复</strong></strong></h6><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">dispatch_suspend</span><span class="params">(queue)</span></span> <span class="comment">//暂停某个队列  </span></span><br><span class="line"><span class="function"><span class="title">dispatch_resume</span><span class="params">(queue)</span></span>  <span class="comment">//恢复某个队列</span></span><br></pre></td></tr></table></figure>

<h6 id="1-5-4-任务和队列的搭配情况"><a href="#1-5-4-任务和队列的搭配情况" class="headerlink" title="1.5.4 任务和队列的搭配情况"></a><strong><strong>1.5.4 任务和队列的搭配情况</strong></strong></h6><p>我们知道任务有同步任务和异步任务，队列有串行队列和并行队列之分。所以具体就有4种组合：</p>
<p>在介绍这四种方式的行为之前大家要记住一点，同步方式是不会创建新线程的，异步方式会创建新线程。</p>
<ul>
<li><strong><strong>[同步 + 串行]</strong></strong>:</li>
</ul>
<p>这种方式没有开启新线程，串行执行任务，并且要注意这种情况很容易造成死锁，如果一个消息队列向自己消息队列中投放任务这时候就会造成死锁。</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">dispatch_queue_t disqueue =  dispatch_queue_create(<span class="string">&quot;com.idealist.test&quot;</span>, DISPATCH_QUEUE_SERIAL)<span class="comment">;</span></span><br><span class="line">dispatch_sync(<span class="name">disqueue</span>, ^&#123;</span><br><span class="line">    NSLog(@<span class="string">&quot;disqueue队列向disqueue队列投放任务&quot;</span>)<span class="comment">;</span></span><br><span class="line">    dispatch_sync(<span class="name">disqueue</span>, ^&#123;</span><br><span class="line">        NSLog(@<span class="string">&quot;这里由于死锁不能执行&quot;</span>)<span class="comment">;</span></span><br><span class="line">    &#125;)<span class="comment">;</span></span><br><span class="line">&#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>只有在发送任务的队列和任务队列不是同一个队列的时候才会正常执行，注意这里是在同一个线程</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">dispatch_queue_t disqueue =  dispatch_queue_create(<span class="string">&quot;com.idealist.disqueue&quot;</span>, DISPATCH_QUEUE_SERIAL)<span class="comment">;</span></span><br><span class="line">dispatch_queue_t workqueue =  dispatch_queue_create(<span class="string">&quot;com.idealist.workqueue&quot;</span>, DISPATCH_QUEUE_SERIAL)<span class="comment">;</span></span><br><span class="line">dispatch_sync(<span class="name">disqueue</span>, ^&#123;</span><br><span class="line">    NSLog(@<span class="string">&quot;在disqueue任务队列上向workqueue队列发送同步任务&quot;</span>)<span class="comment">;</span></span><br><span class="line">    dispatch_sync(<span class="name">workqueue</span>, ^&#123;</span><br><span class="line">        sleep(<span class="number">10</span>)<span class="comment">;</span></span><br><span class="line">        NSLog(@<span class="string">&quot;这里会阻塞disqueue队列&quot;</span>)<span class="comment">;</span></span><br><span class="line">    &#125;)<span class="comment">;</span></span><br><span class="line">    NSLog(@<span class="string">&quot;workqueue执行完毕后才会继续往下执行&quot;</span>)<span class="comment">;</span></span><br><span class="line">&#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>这种用得不多。</p>
<ul>
<li><strong><strong>[异步 + 串行]</strong></strong>:</li>
</ul>
<p>这种情况只会生成一个线程，同一个队列的任务在同一个线程执行。</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">dispatch_queue_t disqueue =  dispatch_queue_create(<span class="string">&quot;com.idealist.disqueue&quot;</span>, DISPATCH_QUEUE_SERIAL)<span class="comment">;</span></span><br><span class="line">dispatch_async(<span class="name">disqueue</span>, ^&#123;</span><br><span class="line">    sleep(<span class="number">8</span>)<span class="comment">;</span></span><br><span class="line">&#125;)<span class="comment">;</span></span><br><span class="line">dispatch_async(<span class="name">disqueue</span>, ^&#123;</span><br><span class="line">    sleep(<span class="number">10</span>)<span class="comment">;</span></span><br><span class="line">&#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>这种比较常用，在不阻塞工作线程外，还能避免资源的竞争。</p>
<ul>
<li><strong><strong>[同步 + 并行]</strong></strong>:</li>
</ul>
<p>这种情况下没有开启新的线程，并且任务也是一个个运行的。虽然并发队列可以开启多个线程同时执行多个任务。但是因为同步任务不具备开启新线程的能力，只有当前线程这一个线程，所以也就不存在并发。而且同步任务需要等待队列的任务执行结束之后，才能继续接着执行下面的操作，所以任务只能一个接一个按顺序执行，不能同时执行。</p>
<ul>
<li><strong><strong>[异步 + 并行]</strong></strong>:<br>这种情况下可开启多个线程，同时执行多个任务，但是这种由于任务并行的顺序不确定性，会很容易出错。</li>
</ul>
<p><img src="/2019/08/12/iOS-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%93/0006.png"></p>
<h6 id="1-5-5-GCD-任务组-（dispatch-group）"><a href="#1-5-5-GCD-任务组-（dispatch-group）" class="headerlink" title="1.5.5 GCD 任务组 （dispatch_group）"></a><strong><strong>1.5.5 GCD 任务组 （dispatch_group）</strong></strong></h6><ul>
<li>“对于并行队列，以及多个串行、并行队列混合的情况我们如何知道所有任务都已经执行完了” </li>
<li>“如何在某些任务执行完毕后，执行一个操作“</li>
</ul>
<p>遇到这种情况我们就可以使用GCD 任务组来解决，GCD 任务组 能够在任务组中的任务执行完毕后，执行某个任务。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建调度组</span></span><br><span class="line">dispatch_group_t group = dispatch<span class="constructor">_group_create()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将调度组添加到队列，执行 block 任务，如果提交到queue中的block全都执行完毕会调用dispatch_group_notify并且dispatch_group_wait会停止等待。</span></span><br><span class="line">dispatch<span class="constructor">_group_async(<span class="params">group</span>, <span class="params">queue</span>, <span class="params">block</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//阻塞当前线程，等待 group 关联的所有 block 执行完毕或者到达指定时间。如果到达指定时间后，所有任务并没有全部完成，那么 dispatch_group_wait 返回一个非 0 的数，可以根据这个返回值，判断是否等待超时。如果设置为 DISPATCH_TIME_FOREVER ，意思是永远等待，直到所有 block 执行完毕，</span></span><br><span class="line"><span class="comment">//需要注意的是dispatch_group_wait是同步的所以不能放在主线程执行。</span></span><br><span class="line">dispatch<span class="constructor">_group_wait(<span class="params">group</span>, DISPATCH_TIME_FOREVER)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当调度组中的所有任务执行结束后，获得通知，统一做后续操作,一个group可以关联多个任务队列dispatch_group会等和它关联的所有的dispatch_queue_t上的任务都执行完毕才会发出同步信号</span></span><br><span class="line">dispatch<span class="constructor">_group_notify(<span class="params">group</span>, <span class="params">dispatch_get_main_queue</span>()</span>, block);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果我们要提交到调度组中的操作是同步的，可以通过dispatch_group_async，但是如果操作是异步的，那么就需要借助dispatch_group_enter///dispatch_group_leave 两个操作了，这两个操作功能如下：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//将任务放到任务组</span></span><br><span class="line">void dispatch<span class="constructor">_group_enter(<span class="params">dispatch_group_t</span> <span class="params">group</span>)</span>;</span><br><span class="line"><span class="comment">//将任务从任务组取出</span></span><br><span class="line">void dispatch<span class="constructor">_group_leave(<span class="params">dispatch_group_t</span> <span class="params">group</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//需要注意的是：</span></span><br><span class="line"><span class="comment">//* dispatch_group_enter必须在dispatch_group_leave之前出现，当dispatch_group_leave比dispatch_group_enter多调用了一次或者说在dispatch_group_enter之前被调用的时候会触发程序的崩溃。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//* dispatch_group_enter和dispatch_group_leave必须成对出现，当调用了dispatch_group_enter而没有调用dispatch_group_leave时dispatch_group_notify中的任务无法执行或者dispatch_group_wait收不到信号而卡住线程。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line">dispatch_group_async(<span class="keyword">group</span>, <span class="built_in">queue</span>, ^&#123; </span><br><span class="line">　　<span class="comment">// 同步耗时操作</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>等价于</p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line">dispatch_group_enter(<span class="keyword">group</span>);</span><br><span class="line">dispatch_async(<span class="built_in">queue</span>, ^&#123;</span><br><span class="line">　　<span class="comment">// 同步耗时操作</span></span><br><span class="line">　　dispatch_group_leave(<span class="keyword">group</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>dispatch_group 例子：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">dispatch_group_t group = dispatch<span class="constructor">_group_create()</span>;</span><br><span class="line">dispatch<span class="constructor">_group_async(<span class="params">group</span>, <span class="params">dispatch_get_global_queue</span>(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)</span>, ^&#123;</span><br><span class="line">    write<span class="constructor">File()</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch<span class="constructor">_group_enter(<span class="params">group</span>)</span>;</span><br><span class="line"><span class="literal">[<span class="identifier">self</span> <span class="identifier">sendHttpRequestWithCompletion</span>:^(<span class="identifier">id</span> <span class="identifier">response</span>) &#123;</span></span><br><span class="line"><span class="literal">    <span class="operator">/</span><span class="operator">/</span>操作</span></span><br><span class="line"><span class="literal">    <span class="identifier">dispatch_group_leave</span>(<span class="identifier">group</span>);</span></span><br><span class="line"><span class="literal">&#125;]</span>;</span><br><span class="line"></span><br><span class="line">dispatch<span class="constructor">_group_enter(<span class="params">group</span>)</span>;</span><br><span class="line"><span class="literal">[<span class="identifier">self</span> <span class="identifier">sendHttpRequestWithCompletion</span>:^(<span class="identifier">id</span> <span class="identifier">response</span>) &#123;</span></span><br><span class="line"><span class="literal">    <span class="operator">/</span><span class="operator">/</span>操作</span></span><br><span class="line"><span class="literal">    <span class="identifier">dispatch_group_leave</span>(<span class="identifier">group</span>);</span></span><br><span class="line"><span class="literal">&#125;]</span>;</span><br><span class="line"></span><br><span class="line">dispatch<span class="constructor">_group_notify(<span class="params">group</span>, <span class="params">dispatch_get_main_queue</span>()</span>, ^&#123;</span><br><span class="line">    <span class="constructor">NSLog(@<span class="string">&quot;完成任务!&quot;</span>)</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h6 id="1-5-5-GCD-其他方法"><a href="#1-5-5-GCD-其他方法" class="headerlink" title="1.5.5 GCD 其他方法"></a><strong><strong>1.5.5 GCD 其他方法</strong></strong></h6><ul>
<li><strong><strong>GCD 栅栏方法：dispatch_barrier_async</strong></strong></li>
</ul>
<p>要异步执行多组操作，且前一组操作执行完之后，才能开始执行后一组操作。这种情况就需要用到栅栏来隔离。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">dispatch_queue_t</span> queue = <span class="built_in">dispatch_queue_create</span>(<span class="string">&quot;com.dnduuhn.test&quot;</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    </span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    <span class="comment">// 追加任务1</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    <span class="comment">// 追加任务2</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_barrier_async</span>(queue, ^&#123;</span><br><span class="line">    <span class="comment">// 追加任务 barrier</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    <span class="comment">// 追加任务3</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    <span class="comment">// 追加任务4</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在上面任务中任务3，任务4 会在 任务1，任务2之后执行。</p>
<ul>
<li><strong><strong>GCD 延时执行方法:dispatch_after</strong></strong></li>
</ul>
<p>延迟一段时间后执行某个操作：</p>
<p>dispatch_after函数传入的时间参数，并不是指在这时间之后开始执行处理，而是在指定时间之后将任务追加到队列中。并且这个时间不是绝对准确时间，但是可以满足对时间不是很严格的延迟要求。</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_after</span>(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">3.0</span> * NSEC_PER_SEC)), <span class="built_in">dispatch_get_main_queue</span>(), ^&#123;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li><strong><strong>GCD 一次性代码:dispatch_once</strong></strong></li>
</ul>
<p>使用 dispatch_once 函数能保证某段代码在程序运行过程中只被执行1次，并且即使在多线程的环境下，dispatch_once也可以保证线程安全。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line"><span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">    <span class="comment">// 只执行1次的代码(这里面默认是线程安全的)</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><strong>GCD 快速迭代方法：dispatch_apply</strong></strong></li>
</ul>
<p>dispatch_apply按照指定的次数将指定的任务追加到指定的队列中，并等待全部队列执行结束。</p>
<p>如果是在串行队列中使用 dispatch_apply，那么就和 for 循环一样，按顺序同步执行。可这样就体现不出快速迭代的意义了。<br>我们可以利用并发队列进行异步执行。比如说遍历 0~5 这6个数字，for 循环的做法是每次取出一个元素，逐个遍历。dispatch_apply 可以 在多个线程中同时（异步）遍历多个数字。还有一点，无论是在串行队列，还是异步队列中，dispatch_apply 都会等待全部任务执行完毕</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">dispatch_queue_t queue = dispatch<span class="constructor">_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)</span>;</span><br><span class="line">dispatch<span class="constructor">_apply(6, <span class="params">queue</span>, ^(<span class="params">size_t</span> <span class="params">index</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 迭代任务</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面会跑6个任务，这6个任务同时并行，index代表第几个任务。这些任务是无序得并发执行。</p>
<ul>
<li><strong><strong>GCD 信号量: Dispatch Semaphore</strong></strong></li>
</ul>
<p>信号量是持有计数的信号，使用它控制对有限资源的使用和访问。假设有一间房子，它对应一个进程，房子里的两个人就对应两个线程。这个房子(进程)有很多资源，比如花园、客厅、卫生间等，是所有人(线程)共享的。但是有些地方，比卫生间，最多只能有1个人能进去。怎么办呢，在卫生间门口挂1把钥匙。进去的人(线程)拿着钥匙进去(信号量 -1)，外面的人(线程)没有钥匙就在门口等待，直到里面的人出来并把钥匙重新放回门口(信号量+1)，此时外面等待的人再拿着这个钥匙进去，所有人(线程)就按照这种方式依次访问卫生间这个有限的资源。门口的钥匙数量就称为信号量(Semaphore)。信号量为0时需要等待，信号量不为零时，减去1而且不等待。</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attribute">dispatch_semaphore_create</span>：创建一个Semaphore并初始化信号的总量</span><br><span class="line"><span class="attribute">dispatch_semaphore_signal</span>：解锁，释放一个信号量，使得信号量值加<span class="number">1</span></span><br><span class="line"><span class="attribute">dispatch_semaphore_wait</span>：加锁，信号量减去<span class="number">1</span>，当信号总量为<span class="number">0</span>时就会阻塞所在线程，否则就可以正常执行。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">dispatch_queue_t</span> queue = <span class="built_in">dispatch_get_global_queue</span>(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line"><span class="type">dispatch_semaphore_t</span> semaphore = <span class="built_in">dispatch_semaphore_create</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">     <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">          <span class="comment">//加锁 信号量 -1</span></span><br><span class="line">          <span class="built_in">dispatch_semaphore_wait</span>(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line"></span><br><span class="line">          <span class="comment">//访问临界区数据</span></span><br><span class="line"></span><br><span class="line">          <span class="comment">//解锁 信号量 +1</span></span><br><span class="line">          <span class="built_in">dispatch_semaphore_signal</span>(semaphore);</span><br><span class="line">      &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="1-6-NSOperation-amp-amp-NSOperationQueue的使用"><a href="#1-6-NSOperation-amp-amp-NSOperationQueue的使用" class="headerlink" title="1.6 NSOperation &amp;&amp; NSOperationQueue的使用"></a><strong><strong>1.6 NSOperation &amp;&amp; NSOperationQueue的使用</strong></strong></h6><p>下图中列举了NSOperation 以及NSOperationQueue的一些重要概念：</p>
<p><img src="/2019/08/12/iOS-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%93/0002.png"></p>
<p>在介绍NSOperation之前我们需要知道NSOperation其实是GCD的一种封装，但是它的调度形式和GCD有着明显区别，GCD中的调度是以FIFO形式进行调度的，但是添加到NSOperationQueue中的任务会先进入RUNABLE状态，然后按照操作的优先级进行调度，并且通过设置队列的最大并发数来控制任务队列的串行，并行行为。</p>
<h6 id="1-6-1-创建操作NSOperation"><a href="#1-6-1-创建操作NSOperation" class="headerlink" title="****1.6.1 创建操作NSOperation ****"></a>****1.6.1 创建操作NSOperation ****</h6><p>NSOperation 有三种方式可以创建，一种是NSInvocationOperation，一种是NSBlockOperation，还有一种通过自定义NSOperation</p>
<h6 id="NSInvocationOperation"><a href="#NSInvocationOperation" class="headerlink" title="NSInvocationOperation:"></a><strong><strong>NSInvocationOperation:</strong></strong></h6><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.创建 NSInvocationOperation 对象</span></span><br><span class="line"><span class="built_in">NSInvocationOperation</span> *invocationOperation = [[<span class="built_in">NSInvocationOperation</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(operation1) object:<span class="literal">nil</span>];</span><br><span class="line"><span class="comment">// 2.调用 start 方法开始执行操作</span></span><br><span class="line">[invocationOperation start];</span><br></pre></td></tr></table></figure>

<p>这种形式任务会运行在当前线程。</p>
<h6 id="NSBlockOperation"><a href="#NSBlockOperation" class="headerlink" title="NSBlockOperation:"></a><strong><strong>NSBlockOperation:</strong></strong></h6><p>NSBlockOperation 是否开启新线程，取决于操作的个数。如果添加的操作的个数多，就会自动开启新线程。</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">//</span> <span class="number">1</span>.创建 NSBlockOperation 对象</span><br><span class="line">NSBlockOperation *op = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">    <span class="regexp">//</span> <span class="keyword">do</span> something</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span> <span class="number">2</span>.调用 start 方法开始执行操作</span><br><span class="line">[op start];</span><br></pre></td></tr></table></figure>

<p>通过 addExecutionBlock 添加额外操作，这些操作（包括blockOperationWithBlock中的操作）可以在不同的线程中并发执行。只有当所有相关的操作已经完成执行时，才视为操作完成</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">//</span> <span class="number">1</span>.创建 NSBlockOperation 对象</span><br><span class="line">NSBlockOperation *op = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">    <span class="regexp">//</span> <span class="keyword">do</span> something</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span> <span class="number">2</span>.添加额外的操作</span><br><span class="line">[op addExecutionBlock:^&#123;</span><br><span class="line">    <span class="regexp">//</span> <span class="keyword">do</span> additional something</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span> <span class="number">3</span>.调用 start 方法开始执行操作</span><br><span class="line">[op start];</span><br></pre></td></tr></table></figure>

<h6 id="自定义NSOperation"><a href="#自定义NSOperation" class="headerlink" title="自定义NSOperation:"></a><strong><strong>自定义NSOperation:</strong></strong></h6><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@interface</span> <span class="attribute">IDLOperation </span>: NSOperation</span><br><span class="line"></span><br><span class="line"><span class="variable">@end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&quot;IDLOperation.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">IDLOperation</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)main &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>.isCancelled) &#123;</span><br><span class="line">        <span class="comment">//执行对应的操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<h6 id="1-6-2-创建操作队列"><a href="#1-6-2-创建操作队列" class="headerlink" title="1.6.2 创建操作队列"></a><strong><strong>1.6.2 创建操作队列</strong></strong></h6><p>NSOperationQueue 为我们提供了两种不同类型的队列：主队列和自定义队列。主队列运行在主线程之上，而自定义队列在后台执行。</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">NSOperationQueue *queue <span class="operator">=</span> [NSOperationQueue mainQueue]<span class="comment">;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>自定义队列创建方法:添加到这种队列中的操作，就会自动放到子线程中执行</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">NSOperationQueue</span> <span class="operator">*</span>queue <span class="operator">=</span> [[<span class="type">NSOperationQueue</span> alloc] <span class="keyword">init</span>];</span><br></pre></td></tr></table></figure>

<h6 id="1-6-4-将操作添加到操作队列"><a href="#1-6-4-将操作添加到操作队列" class="headerlink" title="1.6.4 将操作添加到操作队列"></a><strong><strong>1.6.4 将操作添加到操作队列</strong></strong></h6><p>addOperation</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[operationQueue addOperation:op1]</span><span class="comment">;</span></span><br><span class="line"><span class="section">[operationQueue addOperation:op2]</span><span class="comment">;</span></span><br><span class="line"><span class="section">[operationQueue addOperation:op3]</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>addOperationWithBlock</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">[operationQueue addOperationWithBlock:^&#123;</span><br><span class="line">    <span class="regexp">//</span> <span class="keyword">do</span> something</span><br><span class="line">&#125;];</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>通过上述两种方式将操作加入到操作队列后能够开启新线程，进行并发执行</p>
<h6 id="1-6-3-设置操作队列属性"><a href="#1-6-3-设置操作队列属性" class="headerlink" title="1.6.3 设置操作队列属性"></a><strong><strong>1.6.3 设置操作队列属性</strong></strong></h6><p>最大并发操作数：<strong><strong>maxConcurrentOperationCount</strong></strong></p>
<ul>
<li>maxConcurrentOperationCount 默认情况下为-1，表示不进行限制，可进行并发执行。</li>
<li>maxConcurrentOperationCount 为1时，队列为串行队列。只能串行执行，一个操作完成之后，下一个操作才开始执行。</li>
<li>maxConcurrentOperationCount 大于1时，队列为并发队列。操作并发执行，可以同时执行多个操作。开启线程数量是由系统决定的，不需要我们来管理。</li>
</ul>
<p>我们一般通过maxConcurrentOperationCount来控制操作队列的串并行执行顺序。</p>
<h6 id="1-6-4-设置操作间依赖，及优先级，启动操作"><a href="#1-6-4-设置操作间依赖，及优先级，启动操作" class="headerlink" title="1.6.4 设置操作间依赖，及优先级，启动操作"></a><strong><strong>1.6.4 设置操作间依赖，及优先级，启动操作</strong></strong></h6><ul>
<li><strong><strong>设置操作间依赖</strong></strong></li>
</ul>
<p>NSOperation 还有一个比较强大的功能就是可以设置操作直接的依赖，依赖的操作会等被依赖的操作执行完毕后执行。</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">- (void)addDependency:(NSOperation *)<span class="keyword">op</span>; 添加依赖，在操作<span class="keyword">op</span>完成之后才执行当前操作。</span><br><span class="line">- (void)removeDependency:(NSOperation *)<span class="keyword">op</span>; 移除依赖，取消当前操作对操作 <span class="keyword">op</span> 的依赖。</span><br></pre></td></tr></table></figure>

<p>还可以通过</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">copy</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">NSOperation</span> *&gt; *dependencies;</span><br></pre></td></tr></table></figure>
<p>来获取当前操作开始执行之前完成执行的所有操作对象数组。</p>
<ul>
<li><strong><strong>设置操作优先级</strong></strong></li>
</ul>
<p>优先级的取值如下，可以通过****setQueuePriority:****方法来设置优先级。</p>
<figure class="highlight elm"><table><tr><td class="code"><pre><span class="line">typedef <span class="type">NS_ENUM</span>(<span class="type">NSInteger</span>, <span class="type">NSOperationQueuePriority</span>) &#123;</span><br><span class="line">    <span class="type">NSOperationQueuePriorityVeryLow</span> = -8L,</span><br><span class="line">    <span class="type">NSOperationQueuePriorityLow</span> = -4L,</span><br><span class="line">    <span class="type">NSOperationQueuePriorityNormal</span> = 0,</span><br><span class="line">    <span class="type">NSOperationQueuePriorityHigh</span> = 4,</span><br><span class="line">    <span class="type">NSOperationQueuePriorityVeryHigh</span> = 8</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>优先级只是一个参考，如果一个低优先级的任务，准备就绪了，但是一个高优先级的尚未准备就绪，就会先跑低优先级的任务。</p>
<h6 id="1-6-5-NSOperation-线程切换"><a href="#1-6-5-NSOperation-线程切换" class="headerlink" title="1.6.5 NSOperation 线程切换"></a><strong><strong>1.6.5 NSOperation 线程切换</strong></strong></h6><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">NSOperationQueue *queue = [[NSOperationQueue alloc]init];</span><br><span class="line">[queue addOperationWithBlock:^&#123;</span><br><span class="line">    <span class="regexp">//</span> 异步进行耗时操作</span><br><span class="line">    <span class="regexp">//</span> .....</span><br><span class="line">    <span class="regexp">//</span> 回到主线程</span><br><span class="line">    [[NSOperationQueue mainQueue] addOperationWithBlock:^&#123;</span><br><span class="line">        <span class="regexp">//</span> 更新UI操作</span><br><span class="line">        <span class="regexp">//</span> ...</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/iOS-%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/">iOS 理论基础</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/iOS-理论基础/">iOS 理论基础</a>
  </div>

</div>



<div class="comments-count">
	
	  	<span></span>
		<a href="/2019/08/12/iOS-多线程总结/#comments" class="ds-thread-count comments-count-link" data-thread-key="2019/08/12/iOS-多线程总结/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>







  <nav id="page-nav" class="clearfix">
    <a class="extend prev" rel="prev" href="/page/6/">&lt;span&gt;&lt;&#x2F;span&gt;Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><a class="page-number" href="/page/9/">9</a><span class="space">&hellip;</span><a class="page-number" href="/page/30/">30</a><a class="extend next" rel="next" href="/page/8/">Next&lt;span&gt;&lt;&#x2F;span&gt;</a>
  </nav>

</div>
      <div class="openaside"><a class="navbutton" href="#" title="Show Sidebar"></a></div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="Hide Sidebar"></a></div>
<aside class="clearfix">
<div id="authorInfo">
	
		<div class="author-img"></div>		
	
	<div class="social-info" class="clearfix">
		
		
		<a href="https://github.com/tbfungeek" target="_blank" class="icon-github" title="github"></a>
		
		
		
		
		
		
		
		
		
		
		<a href="mailto:tbfungeek@163.com" target="_blank" class="icon-email" title="Email Me"></a>
		

	</div>
</div>

  
<div class="categorieslist">
	<p class="asidetitle">Categories</p>
		<ul>
		
		  
			<li><a href="/categories/Android-小经验/" title="Android 小经验">Android 小经验<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Android-源码分析/" title="Android 源码分析">Android 源码分析<sup>21</sup></a></li>
		  
		
		  
			<li><a href="/categories/Android其他/" title="Android其他">Android其他<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Android初步/" title="Android初步">Android初步<sup>21</sup></a></li>
		  
		
		  
			<li><a href="/categories/Android进阶/" title="Android进阶">Android进阶<sup>100</sup></a></li>
		  
		
		  
			<li><a href="/categories/Hexo-使用/" title="Hexo 使用">Hexo 使用<sup>10</sup></a></li>
		  
		
		  
			<li><a href="/categories/JavaScript理论/" title="JavaScript理论">JavaScript理论<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Objective-C-相关/" title="Objective C 相关">Objective C 相关<sup>24</sup></a></li>
		  
		
		  
			<li><a href="/categories/OpenCV/" title="OpenCV">OpenCV<sup>6</sup></a></li>
		  
		
		  
			<li><a href="/categories/ROS/" title="ROS">ROS<sup>9</sup></a></li>
		  
		
		  
			<li><a href="/categories/iOS-工具使用/" title="iOS 工具使用">iOS 工具使用<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/iOS-开源库分析/" title="iOS 开源库分析">iOS 开源库分析<sup>36</sup></a></li>
		  
		
		  
			<li><a href="/categories/iOS-理论基础/" title="iOS 理论基础">iOS 理论基础<sup>14</sup></a></li>
		  
		
		  
			<li><a href="/categories/iOS-进阶/" title="iOS 进阶">iOS 进阶<sup>4</sup></a></li>
		  
		
		  
			<li><a href="/categories/个人收藏/" title="个人收藏">个人收藏<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/代码规范/" title="代码规范">代码规范<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/其他/" title="其他">其他<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/博客分类目录/" title="博客分类目录">博客分类目录<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/叨叨系列/" title="叨叨系列">叨叨系列<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/开源代码分析/" title="开源代码分析">开源代码分析<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/开源库分析/" title="开源库分析">开源库分析<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/树莓派/" title="树莓派">树莓派<sup>4</sup></a></li>
		  
		
		  
			<li><a href="/categories/版本控制/" title="版本控制">版本控制<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/直播/" title="直播">直播<sup>6</sup></a></li>
		  
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">Tags</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/iOS-开源库分析/" title="iOS 开源库分析">iOS 开源库分析<sup>36</sup></a></li>
			
		
			
				<li><a href="/tags/Android-设计模式/" title="Android 设计模式">Android 设计模式<sup>29</sup></a></li>
			
		
			
				<li><a href="/tags/Objective-C-相关/" title="Objective C 相关">Objective C 相关<sup>24</sup></a></li>
			
		
			
				<li><a href="/tags/Android基础/" title="Android基础">Android基础<sup>21</sup></a></li>
			
		
			
				<li><a href="/tags/AOSP-源码/" title="AOSP 源码">AOSP 源码<sup>17</sup></a></li>
			
		
			
				<li><a href="/tags/Android-常用第三方库/" title="Android 常用第三方库">Android 常用第三方库<sup>15</sup></a></li>
			
		
			
				<li><a href="/tags/iOS-理论基础/" title="iOS 理论基础">iOS 理论基础<sup>14</sup></a></li>
			
		
			
				<li><a href="/tags/Hexo-使用/" title="Hexo 使用">Hexo 使用<sup>10</sup></a></li>
			
		
			
				<li><a href="/tags/ROS/" title="ROS">ROS<sup>9</sup></a></li>
			
		
			
				<li><a href="/tags/Android-动画进阶/" title="Android 动画进阶">Android 动画进阶<sup>8</sup></a></li>
			
		
			
				<li><a href="/tags/Android-JNI/" title="Android JNI">Android JNI<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/Android-绘图进阶/" title="Android 绘图进阶">Android 绘图进阶<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/Android性能优化/" title="Android性能优化">Android性能优化<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/Android-自动化测试/" title="Android 自动化测试">Android 自动化测试<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/OpenCV/" title="OpenCV">OpenCV<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/直播/" title="直播">直播<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/Android-开源源码/" title="Android 开源源码">Android 开源源码<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/Android-自定义View进阶/" title="Android 自定义View进阶">Android 自定义View进阶<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/树莓派/" title="树莓派">树莓派<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/iOS-进阶/" title="iOS 进阶">iOS 进阶<sup>4</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">Links</p>
    <ul>
        
          <li>
            
            	<a href="https://hexo.io" target="_blank" title="Hexo">Hexo</a>
            
          </li>
        
          <li>
            
            	<a href="https://pages.github.com/" target="_blank" title="GitHub">GitHub</a>
            
          </li>
        
          <li>
            
            	<a href="http://pf18.github.io/" target="_blank" title="PF18">PF18</a>
            
          </li>
        
          <li>
            
            	<a href="http://toutiao.io/" target="_blank" title="开发者头条">开发者头条</a>
            
          </li>
        
          <li>
            
            	<a href="http://www.jcodecraeer.com/" target="_blank" title="泡在网上的日子">泡在网上的日子</a>
            
          </li>
        
    </ul>
</div>

  


  <div class="rsspart">
	<a href="atom.xml" target="_blank" title="rss">RSS</a>
</div>

  
  <div class="tagcloudlist">
    <p class="asidetitle">Tag Cloud</p>
    <div class="tagcloudlist clearfix">
       <a href="/tags/AOSP-%E6%BA%90%E7%A0%81/" style="font-size: 17.14px;">AOSP 源码</a> <a href="/tags/Android-APK-%E7%AD%BE%E5%90%8D/" style="font-size: 10px;">Android APK 签名</a> <a href="/tags/Android-JNI/" style="font-size: 12.86px;">Android JNI</a> <a href="/tags/Android-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E8%BF%9B%E9%98%B6/" style="font-size: 10.71px;">Android 事件处理进阶</a> <a href="/tags/Android-%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6/" style="font-size: 13.57px;">Android 动画进阶</a> <a href="/tags/Android-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%80%E5%8F%91/" style="font-size: 10px;">Android 多线程开发</a> <a href="/tags/Android-%E5%B0%8F%E7%BB%8F%E9%AA%8C/" style="font-size: 10px;">Android 小经验</a> <a href="/tags/Android-%E5%B8%B8%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/" style="font-size: 16.43px;">Android 常用第三方库</a> <a href="/tags/Android-%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/" style="font-size: 10px;">Android 开发流程</a> <a href="/tags/Android-%E5%BC%80%E6%BA%90%E6%BA%90%E7%A0%81/" style="font-size: 12.14px;">Android 开源源码</a> <a href="/tags/Android-%E7%BB%98%E5%9B%BE%E8%BF%9B%E9%98%B6/" style="font-size: 12.86px;">Android 绘图进阶</a> <a href="/tags/Android-%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/" style="font-size: 12.86px;">Android 自动化测试</a> <a href="/tags/Android-%E8%87%AA%E5%AE%9A%E4%B9%89View%E8%BF%9B%E9%98%B6/" style="font-size: 12.14px;">Android 自定义View进阶</a> <a href="/tags/Android-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 19.29px;">Android 设计模式</a> <a href="/tags/Android%E5%85%B6%E4%BB%96/" style="font-size: 10px;">Android其他</a> <a href="/tags/Android%E5%9F%BA%E7%A1%80/" style="font-size: 17.86px;">Android基础</a> <a href="/tags/Android%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/" style="font-size: 10px;">Android开发流程</a> <a href="/tags/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" style="font-size: 12.86px;">Android性能优化</a> <a href="/tags/Android%E6%B7%B7%E6%B7%86%E6%8A%80%E6%9C%AF/" style="font-size: 10px;">Android混淆技术</a> <a href="/tags/Android%E8%B4%A8%E9%87%8F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/" style="font-size: 11.43px;">Android质量管理工具</a> <a href="/tags/Android%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/" style="font-size: 10px;">Android逆向工程</a> <a href="/tags/Git-github/" style="font-size: 10px;">Git && github</a> <a href="/tags/Hexo-%E4%BD%BF%E7%94%A8/" style="font-size: 15px;">Hexo 使用</a> <a href="/tags/JavaScript/" style="font-size: 10px;">JavaScript</a> <a href="/tags/Linux-%E4%BD%BF%E7%94%A8/" style="font-size: 10px;">Linux 使用</a> <a href="/tags/Objective-C-%E7%9B%B8%E5%85%B3/" style="font-size: 18.57px;">Objective C 相关</a> <a href="/tags/OpenCV/" style="font-size: 12.86px;">OpenCV</a> <a href="/tags/ROS/" style="font-size: 14.29px;">ROS</a> <a href="/tags/iOS-%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/" style="font-size: 10.71px;">iOS 工具使用</a> <a href="/tags/iOS-%E5%BC%80%E6%BA%90%E5%BA%93%E5%88%86%E6%9E%90/" style="font-size: 20px;">iOS 开源库分析</a> <a href="/tags/iOS-%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/" style="font-size: 15.71px;">iOS 理论基础</a> <a href="/tags/iOS-%E8%BF%9B%E9%98%B6/" style="font-size: 12.14px;">iOS 进阶</a> <a href="/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/" style="font-size: 10px;">代码规范</a> <a href="/tags/%E5%8D%9A%E5%AE%A2%E5%88%86%E7%B1%BB%E7%9B%AE%E5%BD%95/" style="font-size: 10.71px;">博客分类目录</a> <a href="/tags/%E5%8F%A8%E5%8F%A8%E7%B3%BB%E5%88%97/" style="font-size: 10px;">叨叨系列</a> <a href="/tags/%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/" style="font-size: 11.43px;">工具的使用</a> <a href="/tags/%E5%BC%80%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/" style="font-size: 10.71px;">开源代码分析</a> <a href="/tags/%E5%BC%80%E6%BA%90%E5%BA%93%E5%88%86%E6%9E%90/" style="font-size: 10px;">开源库分析</a> <a href="/tags/%E6%9D%82%E7%B1%BB/" style="font-size: 10px;">杂类</a> <a href="/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/" style="font-size: 12.14px;">树莓派</a> <a href="/tags/%E7%9B%B4%E6%92%AD/" style="font-size: 12.86px;">直播</a> <a href="/tags/%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/" style="font-size: 10.71px;">编程技巧</a> <a href="/tags/%E7%BD%91%E7%AB%99%E6%94%B6%E8%97%8F/" style="font-size: 10px;">网站收藏</a> <a href="/tags/%E9%87%8D%E8%A6%81%E6%8E%A7%E4%BB%B6/" style="font-size: 11.43px;">重要控件</a>
    </div>
  </div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
		
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/hsihohuang/kiddochan" target="_blank" title="Kiddochan">Kiddochan</a> © 2022 
		
		<a href="/about" target="_blank" title="Edgar">Edgar</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
        
    }
  });
});
</script>










<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?7c9443b0374f1cf6b1dbb5ab84d939cb";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="Back to Top"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
 </html>
