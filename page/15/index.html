
 <!DOCTYPE HTML>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
  
    <title>Edgar&#39;s Blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="Edgar">
    

    
    <meta name="description" content="Android | 全栈工程师">
<meta property="og:type" content="website">
<meta property="og:title" content="Edgar&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/page/15/index.html">
<meta property="og:site_name" content="Edgar&#39;s Blog">
<meta property="og:description" content="Android | 全栈工程师">
<meta property="og:locale">
<meta property="article:author" content="Edgar">
<meta name="twitter:card" content="summary">

    
    <link rel="alternative" href="atom.xml" title="Edgar&#39;s Blog" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/unnamed4_n_mSY_icon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/profile.png">
    <link rel="apple-touch-icon-precomposed" href="/img/profile.png">
    
    
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 6.2.0"></head>

  <body>
    <header>
      
<div>
		
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="Edgar&#39;s Blog">Edgar&#39;s Blog</a></h1>
				<h2 class="blog-motto"></h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="Menu">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
					<li>
 					
					<form class="search" action="/search/index.html" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" autocomplete="off" name="q" maxlength="20" placeholder="Search" />
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main">

   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/07/25/Android-进阶之加快启动速度/" title="Android 进阶之加快启动速度" itemprop="url">Android 进阶之加快启动速度</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Edgar" target="_blank" itemprop="author">Edgar</a>
		
  <p class="article-time">
    <time datetime="2016-07-25T03:10:48.000Z" itemprop="datePublished"> Published 2016-07-25</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h4 id="两种启动方式"><a href="#两种启动方式" class="headerlink" title="两种启动方式"></a>两种启动方式</h4><p>在Android系统中有两种启动方式分别为冷启动和热启动，定义如下：</p>
<ul>
<li>冷启动：冷启动就是通过点击桌面图标启动应用，这种启动方式由于后台没有该应用的进程，系统会从Zygote进程中fork创建出一个新的进程分配给该应用，之后会依次创建和初始化Application类、创建MainActivity类、加载主题样式Theme中的windowBackground等属性设置给MainActivity以及配置Activity层级上的一些属性、再inflate布局、当onCreate&#x2F;onStart&#x2F;onResume方法都走完了后最后才进行contentView的measure&#x2F;layout&#x2F;draw显示在界面上。<br>整个过程如下所示：</li>
</ul>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">Application构造 ——&gt; <span class="built_in">attachBaseContext</span>()——&gt;<span class="built_in">onCreate</span>()——&gt;Activity的构造方法——&gt;<span class="built_in">onCreate</span>()——&gt;配置主题中背景等属性——&gt;<span class="built_in">onStart</span>()——&gt;<span class="built_in">onResume</span>()——&gt;测量布局绘制显示在界面上。</span><br></pre></td></tr></table></figure>

<ul>
<li>热启动：当启动应用时，后台已有该应用的进程，所以在已有进程的情况下，这种启动会从已有的进程中来启动应用，这种方式叫热启动。热启动因为会从已有的进程中来启动，所以热启动就不会走Application这步了，而是直接走MainActivity（包括一系列的测量、布局、绘制），所以热启动的过程只需要创建和初始化一个MainActivity就行了，而不必创建和初始化Application，因为一个应用从新进程的创建到进程的销毁，Application只会初始化一次。</li>
</ul>
<h4 id="启动时间和启动时间的测量"><a href="#启动时间和启动时间的测量" class="headerlink" title="启动时间和启动时间的测量"></a>启动时间和启动时间的测量</h4><p>启动时间指的是从点击应用的启动图标开始直到我们看到了界面的第一帧，这段时间就是应用的启动时间。应用启动时间可以通过如下方式进行测量：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">adb shell am start -W <span class="selector-attr">[packageName]</span>/<span class="selector-attr">[packageName.MainActivity]</span></span><br></pre></td></tr></table></figure>

<h4 id="减小应用启动时间的方法"><a href="#减小应用启动时间的方法" class="headerlink" title="减小应用启动时间的方法"></a>减小应用启动时间的方法</h4><ul>
<li>在Application的onCreate()方法中不要进行耗时操作的初始化，尽量将耗时间操作放在后台线程异步处理。</li>
<li>对于MainActivity，由于在获取到第一帧前，需要对布局进行测量绘制操作所以尽量减少布局的层次，以及采用ViewStab延迟加载策略，并在onCreate、onStart、onResume方法中避免做耗时操作。</li>
<li>由于在冷启动时刻，WindowManager会先加载app主题样式中的windowBackground做为app的预览元素，然后再真正去加载activity的layout布局，所以可以通过给windowBackground设置一个图片在视觉上来骗过用户</li>
</ul>
<p>推荐使用如下的解决方案，我这边尝试了下还是有效果的，但是如果本身应用在这段时间如果就没处理什么事情，就比较难看出这个效果了：<br><a target="_blank" rel="noopener" href="https://github.com/DreaminginCodeZH/MaterialColdStart">https://github.com/DreaminginCodeZH/MaterialColdStart</a></p>
<p>英文不好的可以看下下面这篇博客：<br><a target="_blank" rel="noopener" href="http://blog.csdn.net/ccsutofly/article/details/49990939">http://blog.csdn.net/ccsutofly/article/details/49990939</a></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Android%E8%BF%9B%E9%98%B6/">Android进阶</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/Android性能优化/">Android性能优化</a>
  </div>

</div>



<div class="comments-count">
	
	  	<span></span>
		<a href="/2016/07/25/Android-进阶之加快启动速度/#comments" class="ds-thread-count comments-count-link" data-thread-key="2016/07/25/Android-进阶之加快启动速度/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/07/25/Android进阶之Assets-目录与res目录的使用的区别/" title="Android-进阶之Assets 目录与res目录的使用的区别" itemprop="url">Android-进阶之Assets 目录与res目录的使用的区别</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Edgar" target="_blank" itemprop="author">Edgar</a>
		
  <p class="article-time">
    <time datetime="2016-07-25T02:52:26.000Z" itemprop="datePublished"> Published 2016-07-25</time>
    
  </p>
</header>
    <div class="article-content">
        
        <table>
<thead>
<tr>
<th>对比项</th>
<th>assets</th>
<th>res&#x2F;raw</th>
<th>res&#x2F;drawable</th>
</tr>
</thead>
<tbody><tr>
<td>获取资源方式</td>
<td>路径+文件名（这里的路径是相对于assets的路径）</td>
<td>R.raw.xxx</td>
<td>R.drawable.xxx</td>
</tr>
<tr>
<td>是否被压缩</td>
<td>NO</td>
<td>NO</td>
<td>YES</td>
</tr>
<tr>
<td>是否支持多级子目录</td>
<td>YES</td>
<td>NO</td>
<td>NO</td>
</tr>
</tbody></table>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Android%E8%BF%9B%E9%98%B6/">Android进阶</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/杂类/">杂类</a>
  </div>

</div>



<div class="comments-count">
	
	  	<span></span>
		<a href="/2016/07/25/Android进阶之Assets-目录与res目录的使用的区别/#comments" class="ds-thread-count comments-count-link" data-thread-key="2016/07/25/Android进阶之Assets-目录与res目录的使用的区别/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/07/25/Android-进阶之推出当前应用的方式/" title="Android-进阶之退出当前应用的方式" itemprop="url">Android-进阶之退出当前应用的方式</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Edgar" target="_blank" itemprop="author">Edgar</a>
		
  <p class="article-time">
    <time datetime="2016-07-25T02:26:13.000Z" itemprop="datePublished"> Published 2016-07-25</time>
    
  </p>
</header>
    <div class="article-content">
        
        <ol>
<li>比较粗鲁的方式-杀进程</li>
</ol>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">android.os.Process.killProcess(android.os.Process.myPid());</span><br><span class="line">System.<span class="keyword">exit</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用ActivityManager的restartPackage方法，这种方法需要注意的是需要运行在Android 1.5 API Level为3以上才可以，并且需要权限</li>
</ol>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">ActivityManager am <span class="operator">=</span> (ActivityManager)getSystemService (Context.ACTIVITY_SERVICE)<span class="comment">;</span></span><br><span class="line">am.restartPackage(getPackageName())<span class="comment">; </span></span><br></pre></td></tr></table></figure>
<p>所需权限：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.RESTART_PACKAGES&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">uses-permission</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>使用FLAG_ACTIVITY_CLEAR_TOP 方式</li>
</ol>
<p>使用FLAG_ACTIVITY_CLEAR_TOP 启动第一个Activity也就是MAIN的那个Activity然后在需要全部退出时调用finish</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> <span class="constructor">Intent()</span>; </span><br><span class="line">intent.set<span class="constructor">Class(<span class="params">xxxx</span>,<span class="params">xxxxx</span>)</span>; </span><br><span class="line">intent.set<span class="constructor">Flags(Intent.FLAG_ACTIVITY_CLEAR_TOP)</span>; </span><br><span class="line">start<span class="constructor">Activity(<span class="params">intent</span>)</span>;</span><br><span class="line">````</span><br><span class="line"></span><br><span class="line">下面是我自己之前写的一个退出整个应用的方式使用的是ActivityLifeCycleCallback + 单例也是个人比较推崇的方式：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>public abstract class MyApplication extends Application {</p>
<pre><code>private static List&lt;Activity&gt; mActivityList = new LinkedList&lt;Activity&gt;();
@Override
public void onCreate() &#123;
    super.onCreate();
    if(mActivityList!= null) &#123;
        mActivityList.clear();
    &#125;
    registerActivityLifecycleCallbacks (new Application.ActivityLifecycleCallbacks() &#123;

        public void	onActivityCreated(Activity activity, Bundle savedInstanceState) &#123;
            if(mActivityList != null) &#123;
                mActivityList.add(activity);
            &#125;
        &#125;
        public void	onActivityDestroyed(Activity activity) &#123;
            if(mActivityList != null &amp;&amp; mActivityList.contains(activity)) &#123;
                mActivityList.remove(activity);
            &#125;
        &#125;
        public void	onActivityPaused(Activity activity) &#123;
        &#125;

        public void	onActivityResumed(Activity activity) &#123;

        &#125;
        public void	onActivitySaveInstanceState(Activity activity, Bundle outState) &#123;&#125;
        public void	onActivityStarted(Activity activity) &#123;
        &#125;
        
        public void	onActivityStopped(Activity activity) &#123;
        &#125;
    &#125;);
&#125;

public static void  exitAppication(MixEngineService.callbackBefore callbackBefore) &#123;
    if(mActivityList != null) &#123;
        int activityCount = mActivityList.size();
        for(int i =0;i&lt;activityCount;i++) &#123;
            Activity activity = mActivityList.get(i);
            if(activity != null) &#123;
                activity.finish();
                activity.overridePendingTransition(0, R.anim.exitapplication_anim);
            &#125;
        &#125;
        System.exit(0);
    &#125;
&#125;
</code></pre>
<p>}</p>
<pre><code>
</code></pre>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Android%E8%BF%9B%E9%98%B6/">Android进阶</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/编程技巧/">编程技巧</a>
  </div>

</div>



<div class="comments-count">
	
	  	<span></span>
		<a href="/2016/07/25/Android-进阶之推出当前应用的方式/#comments" class="ds-thread-count comments-count-link" data-thread-key="2016/07/25/Android-进阶之推出当前应用的方式/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/07/19/两年工作总结/" title="两年工作总结" itemprop="url">两年工作总结</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Edgar" target="_blank" itemprop="author">Edgar</a>
		
  <p class="article-time">
    <time datetime="2016-07-19T14:20:38.000Z" itemprop="datePublished"> Published 2016-07-19</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>转眼已经工作两年了，上个月向公司递交了离职申请，第一次辞职，在离职面谈的时候HR很诧异地对我说：”公司走的人大多数都是找好下家后再提交辞职申请的，你为什么不现在这里找到下家一下再走呢“，其实这也算得上我自己对第一份工作的认真吧，拿着公司的薪水找下家，自己心里不是很舒坦，也不知道对于工作许久的人来说这算不上天真，如果算天真，也就天真一回吧，7月20号也就是明天是我在团队中上班的最后一天，也相当于对于公司的一份感恩吧，可以肯定的是这不是出于自信，但是个人始终坚信一点”认真“，”努力“，”坚持“这三样做到了，结果都不会很差，剩下就靠机遇了。接下来的一段时间会一边找工作一边借着这个空档期给自己的下一阶段充充电。</p>
<p>这两年发生了好多事情，一向坚强的爸爸做了心脏起搏器植入的手术，当时我连续失眠了好久，妈妈手摔骨折了，虽然都好了但是还是心有余悸，当然还有一些收获：我和相恋四年的女朋友结婚了，没有钻戒，没有婚礼，我们用自己所有的积蓄付了房子首付，希望能够在明年将爸爸妈妈接过来。</p>
<p>在工作，技术提升方面除了公司日常工作外，下班的8个小时也被充分地利用起来的了，每天写写博客，写写代码，认识了一些产品方面的同事，在空余时间也会向他们沟通产品设计中的一些事情。我也会给他们分享一些技术上的东西。也是基于这种分享的快乐所以有了这个专门的博客。</p>
<p>这个博客是在今年二月份开始写的，之前都是在本地笔记上记录自己的知识积累，在读书的时候包括刚刚开始工作的时候特别讨厌写文档，那时候觉得买个技术书籍用得时候查阅就OK了何必花时间去做这种别人已经做好的工作，但是在自己工作中遇到的问题越来越多，感觉那些技术书籍包括博客上的东西就越来越凌乱了，并且很多东西别人博客上的不一定都是正确的，所以有了整理自己知识体系的想法，起初的时候用的是笔记软件，也就是这些博客的原始素材，后来在无意中好友 pf18 向我推荐了Hexo，也就在今年二月份开始，开始慢慢整理自己的笔记，并写成博文，写笔记和写技术博客是有很大的区别的，写笔记的时候会比较随意，只要自己看得明白就好，不用插图，但是博客就不一样了，必须认真地表述，认真琢磨。所以经过初期的计划，就开始利用下班时间写博客。博客计划主要分成六个部分：</p>
<p>目前是处于第一阶段，主要是一些Android开发中的常用技术。<br>第二阶段会是基于AOSP 的 源码分析由于之前是在做多媒体小组，所以会侧重于MediaPlayer 播放框架，MediaRecorder，MediaScanner，Music，Video，Camera，SoundRecorder， MediaProject，流媒体方面的源码解析。<br>第三阶段会是一些开源库的代码分析<br>第四部分会是一些自定义View和自定义动画的博客<br>第五部分是OpenCV，OpenGL，ffmpeg的学习总结<br>第六部分会是一些产品设计方面的总结<br>这些内容会有计划，但是不定期得发布,希望自己能够坚持下来。</p>
<p>下面是第一阶段博文的目录，共117篇，涵盖了开发过程中所需的各个方面技术，直到产品发布为止。在下面的博客中有参考了很多优秀的博客，也谢谢他们的分享精神让自己在技术方面有了较大的提高。也是出于感恩，有了下面的博客。</p>
<p>Android初步系列共有21篇</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">* <span class="keyword">Android </span>初步之<span class="keyword">Android </span>体系结构 </span><br><span class="line">* <span class="keyword">Android </span>初步之<span class="keyword">Android </span>SDK 目录结构 </span><br><span class="line">* <span class="keyword">Android </span>初步之<span class="keyword">Android组件 </span>概图 </span><br><span class="line">* <span class="keyword">Android </span>初步之<span class="keyword">Android组件 </span><span class="built_in">Context</span> </span><br><span class="line">* <span class="keyword">Android </span>初步之<span class="keyword">Android组件 </span>Activity</span><br><span class="line">* <span class="keyword">Android </span>初步之<span class="keyword">Android组件 </span>Service</span><br><span class="line">* <span class="keyword">Android </span>初步之<span class="keyword">Android组件 </span><span class="keyword">BroadcastReceiver</span></span><br><span class="line"><span class="keyword"></span>* <span class="keyword">Android </span>初步之<span class="keyword">Android组件 </span>Intent</span><br><span class="line">* <span class="keyword">Android </span>初步之<span class="keyword">Android组件 </span>Content Provider</span><br><span class="line">* <span class="keyword">Android </span>初步之<span class="keyword">Android组件 </span>Fragment</span><br><span class="line">* <span class="keyword">Android </span>初步之布局管理</span><br><span class="line">* <span class="keyword">Android </span>初步之资源的使用</span><br><span class="line">* <span class="keyword">Android </span>初步之数据存储</span><br><span class="line">* <span class="keyword">Android </span>初步之Adapter 与 ListView</span><br><span class="line">* <span class="keyword">Android </span>初步之Timmer &amp;&amp; AlarmManager</span><br><span class="line">* <span class="keyword">Android </span>初步之网络与定位服务 </span><br><span class="line">* <span class="keyword">Android </span>初步之 使用<span class="keyword">Android </span>studio 开发 AIDL</span><br><span class="line">* <span class="keyword">Android </span>studio 下使用<span class="keyword">JNI</span></span><br><span class="line"><span class="keyword"></span>* <span class="keyword">Android </span>初步之<span class="keyword">Android </span>安全机制 </span><br><span class="line">* <span class="keyword">Android </span>初步之剪贴板 </span><br><span class="line">* <span class="keyword">Android </span>初步之语音朗读和语音识别</span><br></pre></td></tr></table></figure>
<p>Android 进阶系列共有96篇：</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">* <span class="keyword">Android </span>进阶之<span class="keyword">Android </span>绘图 零 大纲</span><br><span class="line">* <span class="keyword">Android </span>进阶之<span class="keyword">Android </span>绘图 一 <span class="keyword">Android坐标体系及屏幕尺寸相关概念</span></span><br><span class="line"><span class="keyword"></span>* <span class="keyword">Android </span>进阶之<span class="keyword">Android </span>绘图 二 画笔Paint</span><br><span class="line">* <span class="keyword">Android </span>进阶之<span class="keyword">Android </span>绘图 三 画布Canvs以及SurfaceView</span><br><span class="line">* <span class="keyword">Android </span>进阶之<span class="keyword">Android </span>绘图 四 图像容器<span class="keyword">Bitmap </span>Drawable以及图像变换</span><br><span class="line">* <span class="keyword">Android </span>进阶之<span class="keyword">Android </span>绘图 五 硬件加速</span><br><span class="line">* <span class="keyword">Android </span>进阶之事件交互 一 触摸事件和键盘事件</span><br><span class="line">* <span class="keyword">Android </span>进阶之事件交互 二 滑动事件</span><br><span class="line">* <span class="keyword">Android </span>进阶之动画 零 大纲</span><br><span class="line">* <span class="keyword">Android </span>进阶之动画 一 视图动画</span><br><span class="line">* <span class="keyword">Android </span>进阶之动画 二 逐帧动画</span><br><span class="line">* <span class="keyword">Android </span>进阶之动画 三 属性动画</span><br><span class="line">* <span class="keyword">Android </span>进阶之动画 四 布局动画</span><br><span class="line">* <span class="keyword">Android </span>进阶之动画 五 动画集合</span><br><span class="line">* <span class="keyword">Android </span>进阶之动画 六 动画事件</span><br><span class="line">* <span class="keyword">Android </span>进阶之动画 七 插值器</span><br><span class="line">* <span class="keyword">Android-进阶之自定义View </span>一 自定义View 流程</span><br><span class="line">* <span class="keyword">Android-进阶之自定义View </span>二 View的刷新模式</span><br><span class="line">* <span class="keyword">Android-进阶之自定义View </span>三 实现自定义View的方式</span><br><span class="line">* <span class="keyword">Android </span>进阶之自定义View 四 自定义ViewGroup</span><br><span class="line">* <span class="keyword">Android </span>进阶之设计模式 一 MVC模式</span><br><span class="line">* <span class="keyword">Android </span>进阶之设计模式 二 MVP模式</span><br><span class="line">* <span class="keyword">Android </span>进阶之设计模式 三 MVVM模式</span><br><span class="line">* <span class="keyword">Android </span>进阶之设计模式 三 MVVM模式 DataBinding [一] 搭建开发环境</span><br><span class="line">* <span class="keyword">Android </span>进阶之设计模式 三 MVVM模式- DataBinding[二]</span><br><span class="line">* <span class="keyword">Android </span>进阶之设计模式 (转)<span class="keyword">Android-CleanArchitecture</span></span><br><span class="line"><span class="keyword"></span>* <span class="keyword">Android </span>进阶之设计模式 六大原则</span><br><span class="line">* <span class="keyword">Android </span>进阶之设计模式 创建型模式-单例模式</span><br><span class="line">* <span class="keyword">Android </span>进阶之设计模式 原型模式</span><br><span class="line">* <span class="keyword">Android </span>进阶之设计模式 外观模式</span><br><span class="line">* <span class="keyword">Android </span>进阶之设计模式 备忘录模式</span><br><span class="line">* <span class="keyword">Android </span>进阶之设计模式 命令模式</span><br><span class="line">* <span class="keyword">Android </span>进阶之设计模式 代理模式</span><br><span class="line">* <span class="keyword">Android </span>进阶之设计模式 享元模式</span><br><span class="line">* <span class="keyword">Android </span>进阶之设计模式 中介者模式</span><br><span class="line">* <span class="keyword">Android </span>进阶之设计模式 工厂方法模式 &amp;&amp; 抽象工厂模式</span><br><span class="line">* <span class="keyword">Android </span>进阶之设计模式 适配器模式</span><br><span class="line">* <span class="keyword">Android </span>进阶之设计模式 迭代器模式</span><br><span class="line">* <span class="keyword">Android </span>进阶之设计模式 责任链模式</span><br><span class="line">* <span class="keyword">Android </span>进阶之重要的控件 CardView</span><br><span class="line">* <span class="keyword">Android </span>进阶之重要的控件 RecycleView</span><br><span class="line">* <span class="keyword">Android </span>进阶之重要的控件 Toolbar</span><br><span class="line">* <span class="keyword">Android </span>进阶之性能优化 UI视图优化</span><br><span class="line">* <span class="keyword">Android </span>进阶之性能优化 内存优化</span><br><span class="line">* <span class="keyword">Android </span>进阶之性能优化 电量优化</span><br><span class="line">* <span class="keyword">Android </span>进阶之性能优化 网络优化</span><br><span class="line">* <span class="keyword">Android </span>进阶之性能优化 代码级优化</span><br><span class="line">* <span class="keyword">Android </span>进阶之第三方库的介绍 <span class="keyword">butterknife</span></span><br><span class="line"><span class="keyword"></span>* <span class="keyword">Android </span>进阶之第三方库的介绍 Picasso</span><br><span class="line">* <span class="keyword">Android </span>进阶之第三方库的介绍 Glide</span><br><span class="line">* <span class="keyword">Android </span>进阶之第三方库的介绍 Fresco</span><br><span class="line">* <span class="keyword">Android </span>进阶之第三方库的介绍 Gson</span><br><span class="line">* <span class="keyword">Android </span>进阶之第三方库的介绍 Realm [一] 基础用法</span><br><span class="line">* <span class="keyword">Android </span>进阶之第三方库的介绍 Realm [二] 进阶用法</span><br><span class="line">* <span class="keyword">Android </span>进阶之第三方库的介绍 Retrofit</span><br><span class="line">* <span class="keyword">Android </span>进阶之第三方库的介绍 RxJava &amp;&amp; RxAndroid 一 [事件源Observable]</span><br><span class="line">* <span class="keyword">Android </span>进阶之第三方库的介绍 RxJava &amp;&amp; RxAndroid 二 [事件源的过滤]</span><br><span class="line">* <span class="keyword">Android </span>进阶之第三方库的介绍 RxJava &amp;&amp; RxAndroid 三 [事件源的转换]</span><br><span class="line">* <span class="keyword">Android </span>进阶之第三方库的介绍 RxJava &amp;&amp; RxAndroid 四 [事件源的组合]</span><br><span class="line">* <span class="keyword">Android </span>进阶之第三方库的介绍 RxJava &amp;&amp; RxAndroid 五 [线程调度]</span><br><span class="line">* <span class="keyword">Android </span>进阶之第三方库的介绍 RxJava &amp;&amp; RxAndroid 六 [转]RxJava使用场景小结</span><br><span class="line">* <span class="keyword">Android </span>进阶之第三方库的介绍 RxJava &amp;&amp; RxAndroid 七 [学习RxJava必备的文章]</span><br><span class="line">* <span class="keyword">Android </span>进阶之<span class="keyword">Android开发中的质量跟踪工具</span></span><br><span class="line"><span class="keyword"></span>* <span class="keyword">Android </span>进阶之工具的使用 Findbugs</span><br><span class="line">* <span class="keyword">Android </span>进阶之工具的使用 LeakCanary</span><br><span class="line">* <span class="keyword">Android </span>进阶之工具的使用 Lint</span><br><span class="line">* <span class="keyword">Android </span>进阶之工具的使用Checkstyle</span><br><span class="line">* <span class="keyword">Android </span>进阶之工具的使用 TraceView</span><br><span class="line">* <span class="keyword">Android </span>进阶之 混淆技术</span><br><span class="line">* <span class="keyword">Android </span>进阶之 反编译</span><br><span class="line">* <span class="keyword">Android </span>进阶之自动化构建工具Travis CI</span><br><span class="line">* <span class="keyword">Android </span>进阶之自动化测试 之 <span class="keyword">AndroidJunitRunner</span></span><br><span class="line"><span class="keyword"></span>* <span class="keyword">Android </span>进阶之自动化测试 <span class="keyword">Junit</span></span><br><span class="line"><span class="keyword"></span>* <span class="keyword">Android </span>进阶之自动化测试 Monkey测试</span><br><span class="line">* <span class="keyword">Android </span>进阶之自动化测试Espreso</span><br><span class="line">* <span class="keyword">Android </span>进阶之自动化测试 UIAutomator</span><br><span class="line">* <span class="keyword">Android </span>进阶之自动化测试Robolectric</span><br><span class="line">* <span class="keyword">Android </span>进阶之版本释放流程</span><br><span class="line">* <span class="keyword">Android </span>进阶之Apk签名</span><br><span class="line">* <span class="keyword">Android </span>进阶之多线程技术</span><br><span class="line">* <span class="keyword">Android </span>进阶之<span class="keyword">JNI </span>开发 一 概述</span><br><span class="line">* <span class="keyword">Android </span>进阶之 NDK 开发</span><br><span class="line">* <span class="keyword">Android </span>进阶之<span class="keyword">JNI </span>开发 二 <span class="keyword">JNI数据类型介绍</span></span><br><span class="line"><span class="keyword"></span>* <span class="keyword">Android </span>进阶之<span class="keyword">JNI </span>开发 三 访问对象成员变量和成员方法</span><br><span class="line">* <span class="keyword">Android </span>进阶之<span class="keyword">JNI </span>开发 四 局部引用，全局引用和弱全局引用</span><br><span class="line">* <span class="keyword">Android </span>进阶之<span class="keyword">JNI </span>开发 五 <span class="keyword">JNI </span>异常处理</span><br></pre></td></tr></table></figure>

<p>如果大家觉得写得不好或者有一些其他建议的可以给我留言，如果大家觉得写得不错的话也希望大家在转载的时候帮我推广下，在转载的时候将下面的贴到博客上方即可，因为这份坚持也需要有大家的鼓励。博客的About 是我的个人简介及简历，如果有志同道合的朋友的话可以通过上面的联系方式和我取得联系。<br>希望能够在技术成长的道路上能够给大家力所能及的帮助，也希望能够得到大家的意见和建议。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">文／tbfungeek</span><br><span class="line">网站链接：http:<span class="comment">//tbfungeek.github.io/</span></span><br><span class="line">邮箱：<span class="symbol">tbfungeek@</span><span class="number">163.</span>com</span><br></pre></td></tr></table></figure>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/%E5%8D%9A%E5%AE%A2%E5%88%86%E7%B1%BB%E7%9B%AE%E5%BD%95/">博客分类目录</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/博客分类目录/">博客分类目录</a>
  </div>

</div>



<div class="comments-count">
	
	  	<span></span>
		<a href="/2016/07/19/两年工作总结/#comments" class="ds-thread-count comments-count-link" data-thread-key="2016/07/19/两年工作总结/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/07/11/Android-进阶之JNI-开发-五-JNI-异常处理/" title="Android 进阶之JNI 开发 五 JNI 异常处理" itemprop="url">Android 进阶之JNI 开发 五 JNI 异常处理</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Edgar" target="_blank" itemprop="author">Edgar</a>
		
  <p class="article-time">
    <time datetime="2016-07-11T15:15:22.000Z" itemprop="datePublished"> Published 2016-07-11</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>JNI异常和Java异常有一点很重要的区别是：</p>
<p>当Java中发生异常时如果没有使用try…catch来捕获，会导致程序Crash这种情况下后续的代码不会被执行。而在调用JNI接口的时候如果发生异常那么后续的代码不会停止，还会继续往下执行，所以在这种情况下需要使用return退出后续执行。<br>下面是一个很典型的异常处理代码片段：</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">JNIEXPORT void JNICALL</span><br><span class="line">Java_com_idealist_myapplication_MainActivity_callMethodWithException(JNIEnv *env,</span><br><span class="line">                                                                     jobject instance) &#123;</span><br><span class="line">    <span class="comment">//调用会抛出异常的方法</span></span><br><span class="line">    <span class="function"><span class="title">jclass</span>  cls = (*env)-&gt;</span>GetObjectClass(env,instance);</span><br><span class="line">    <span class="function"><span class="title">jmethodID</span> methodid = (*env)-&gt;</span>GetMethodID(env,cls,<span class="string">&quot;methodWithException&quot;</span>,<span class="string">&quot;()V&quot;</span>);</span><br><span class="line">    (*<span class="function"><span class="title">env</span>)-&gt;</span>CallVoidMethod(env, instance, methodid);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//检查调用上述方法后异常是否抛出</span></span><br><span class="line">    <span class="function"><span class="title">jthrowable</span> exception = (*env)-&gt;</span>ExceptionOccurred(env);</span><br><span class="line">    <span class="comment">//如果有异常</span></span><br><span class="line">    <span class="keyword">if</span>(exception) &#123;</span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        (*<span class="function"><span class="title">env</span>)-&gt;</span>DeleteLocalRef(env,cls);</span><br><span class="line">        <span class="comment">//打印异常信息</span></span><br><span class="line">        (*<span class="function"><span class="title">env</span>)-&gt;</span>ExceptionDescribe(env);</span><br><span class="line">        <span class="comment">//清除异常</span></span><br><span class="line">        (*<span class="function"><span class="title">env</span>)-&gt;</span>ExceptionClear(env);</span><br><span class="line">        <span class="comment">//抛出自定义的异常</span></span><br><span class="line">        <span class="function"><span class="title">jclass</span> exclass = (*env)-&gt;</span>FindClass(env, <span class="string">&quot;java/lang/Exception&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (exclass == NULL) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        (*<span class="function"><span class="title">env</span>)-&gt;</span>ThrowNew(env, exclass, <span class="string">&quot;Here is a Exception Occur!&quot;</span>);</span><br><span class="line">        <span class="comment">//将程序流终止，这里由于是最后了所以可以省略，但是如果不是处于最后那么一定不要忘记添加return终止程序运行。</span></span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Android%E8%BF%9B%E9%98%B6/">Android进阶</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/Android-JNI/">Android JNI</a>
  </div>

</div>



<div class="comments-count">
	
	  	<span></span>
		<a href="/2016/07/11/Android-进阶之JNI-开发-五-JNI-异常处理/#comments" class="ds-thread-count comments-count-link" data-thread-key="2016/07/11/Android-进阶之JNI-开发-五-JNI-异常处理/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/07/10/Android-进阶之JNI-开发-四-局部引用，全局引用和弱全局引用/" title="Android 进阶之JNI 开发 四 局部引用，全局引用和弱全局引用" itemprop="url">Android 进阶之JNI 开发 四 局部引用，全局引用和弱全局引用</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Edgar" target="_blank" itemprop="author">Edgar</a>
		
  <p class="article-time">
    <time datetime="2016-07-10T14:08:17.000Z" itemprop="datePublished"> Published 2016-07-10</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>大家都知道，如果一个Java对象没有被其它成员变量或静态变量所引用的话，就随时有可能会被GC回收掉。所以我们在编写本地代码时，要注意从JVM中获取到的引用在使用时被GC回收的可能性。</p>
<p>JNI中有三种引用分别是：局部引用（Local Reference）、全局引用（Global Reference）、弱全局引用（Weak Global Reference）</p>
<h4 id="局部引用"><a href="#局部引用" class="headerlink" title="局部引用"></a>局部引用</h4><p>局部引用可以通过NewLocalRef和FindClass、NewObject、GetObjectClass和NewCharArray等方法进行创建，一般是在方法中使用并且值在创建它的方法内有效，它会增加引用计数从而阻止GC回收所引用的对象，但是一旦出了这个方法就变得无效了。也就是说它的生命周期只在创建该局部引用的方法内部。在用完局部引用之后可以选择不手动释放而是在本地方法执行完之后由JVM自动释放，还可以手动调用DeleteLocalRef释放。但是一般最好手动在刚用完之后就立刻释放，因为JNI会将创建的局部引用都存储在一个局部引用表中，如果这个表超过了最大容量限制（Android上的JNI局部引用表最大数量是512个），就会造成局部引用表溢出，从而导致程序崩溃。并且有可能在你申请并使用完局部引用之后的操作还需要比较大的空间，这时候如果不即使释放有可能导致OOM。在使用局部引用的时候还需要注意的是局部引用不能跨线程使用，只在创建它的线程有效。不要试图在一个线程中创建局部引用并存储到全局引用中，然后在另外一个线程中使用。</p>
<h4 id="全局引用"><a href="#全局引用" class="headerlink" title="全局引用"></a>全局引用</h4><p>与局部引用创建方式不同的是，全局变量只能通过NewGlobalRef方法创建。JVM不会自动释放它，而是需要我们手动释放才会失效，并且它可以跨方法，跨线程使用。</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">jstring  </span><br><span class="line">MyNewString(JNIEnv *env, jchar *chars, jint len)  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">static</span> j<span class="keyword">class</span> <span class="title class_">stringClass</span> = NULL;  </span><br><span class="line">    ...  </span><br><span class="line">    <span class="keyword">if</span> (stringClass == NULL) &#123;  </span><br><span class="line">        j<span class="keyword">class</span> <span class="title class_">localRefCls</span> =  </span><br><span class="line">            <span class="function"><span class="params">(*env)</span>-&gt;</span>FindClass(env, <span class="string">&quot;java/lang/String&quot;</span>);  </span><br><span class="line">        <span class="keyword">if</span> (localRefCls == NULL) &#123;  </span><br><span class="line">            <span class="keyword">return</span> NULL; <span class="comment">/* exception thrown */</span>  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">/* Create a global reference */</span>  </span><br><span class="line">        <span class="function"><span class="title">stringClass</span> = <span class="params">(*env)</span>-&gt;</span>NewGlobalRef(env, localRefCls);  </span><br><span class="line">        <span class="comment">/* The local reference is no longer useful */</span>  </span><br><span class="line">        <span class="function"><span class="params">(*env)</span>-&gt;</span>DeleteLocalRef(env, localRefCls);  </span><br><span class="line">        <span class="comment">/* Is the global reference created successfully? */</span>  </span><br><span class="line">        <span class="keyword">if</span> (stringClass == NULL) &#123;  </span><br><span class="line">            <span class="keyword">return</span> NULL; <span class="comment">/* out of memory exception thrown */</span>  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    ...  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h4 id="弱全局引用"><a href="#弱全局引用" class="headerlink" title="弱全局引用"></a>弱全局引用</h4><p>调用NewWeakGlobalRef基于局部引用或全局引用创建，不能增加引用计数，不会阻止GC回收所引用的对象，也就是说它对应的Java对象生命周期依然取决于虚拟机，这就导致即便弱全局引用没有被释放，其引用的Java对象有可能已经被释放，和全局引用一样可以跨方法、跨线程使用。引用不会自动释放，在JVM认为应该回收它的时候进行回收而被释放。或者调用DeleteWeakGlobalRef手动释放。</p>
<h4 id="引用比较与弱引用是否被回收"><a href="#引用比较与弱引用是否被回收" class="headerlink" title="引用比较与弱引用是否被回收"></a>引用比较与弱引用是否被回收</h4><p>给定两个引用（不管是全局、局部还是弱全局引用），只需要调用IsSameObject就可以判断两个是否指向相同的对象，例如：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">（*env)-&gt;<span class="constructor">IsSameObject(<span class="params">env</span>, <span class="params">obj1</span>, <span class="params">obj2</span>)</span></span><br></pre></td></tr></table></figure>
<p>如果obj1和obj2指向相同的对象，则返回JNI_TRUE，否则返回JNI_FALSE。但是使用IsSameObject比较弱全局引用与NULL的时候，返回值的意义是有点特别的：比如：</p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line">jboolean isWeakRefGC = <span class="function"><span class="params">(*env)</span>-&gt;</span>IsSameObject(env,gw_obj_ref, NULL);</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，如果gw_obj_ref指向的引用已经被回收，会返回JNI_TRUE，如果gw_obj_ref仍然指向一个活动对象，会返回JNI_FALSE。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Android%E8%BF%9B%E9%98%B6/">Android进阶</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/Android-JNI/">Android JNI</a>
  </div>

</div>



<div class="comments-count">
	
	  	<span></span>
		<a href="/2016/07/10/Android-进阶之JNI-开发-四-局部引用，全局引用和弱全局引用/#comments" class="ds-thread-count comments-count-link" data-thread-key="2016/07/10/Android-进阶之JNI-开发-四-局部引用，全局引用和弱全局引用/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/07/09/Android-进阶之JNI-开发-三访问对象成员变量和成员方法/" title="Android 进阶之JNI 开发 三访问对象成员变量和成员方法" itemprop="url">Android 进阶之JNI 开发 三访问对象成员变量和成员方法</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Edgar" target="_blank" itemprop="author">Edgar</a>
		
  <p class="article-time">
    <time datetime="2016-07-09T12:27:54.000Z" itemprop="datePublished"> Published 2016-07-09</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h4 id="访问对象的成员属性和成员方法："><a href="#访问对象的成员属性和成员方法：" class="headerlink" title="访问对象的成员属性和成员方法："></a>访问对象的成员属性和成员方法：</h4><p>下面我们通过一个例子来介绍对象成员属性和成员方法的访问：</p>
<p>首先我们先定义一个测试类，在这篇博客中将对测试类的testString方法进行访问和设置，我们先看下这个测试类：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Testjni</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title class_">String</span> testString;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title class_">String</span> <span class="title function_">getTestString</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> testString;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">setTestString</span>(<span class="params"><span class="built_in">String</span> testString</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">testString</span> = testString;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line"><span class="regexp">//</span>通过调用Java层方法来实现某个功能</span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL</span><br><span class="line">Java_com_idealist_myapplication_MainActivity_setTestString(JNIEnv *env, jobject instance,</span><br><span class="line">                                                           jobject obj, jstring str_) &#123;</span><br><span class="line">    <span class="regexp">//</span>获得某个对象的类类型</span><br><span class="line">    j<span class="keyword">class</span> <span class="title class_">testCls</span> = <span class="function"><span class="params">(*env)</span>-&gt;</span>GetObjectClass(env,obj);</span><br><span class="line">    <span class="regexp">//</span>获得对应的方法id</span><br><span class="line">	jmethodID methodId = <span class="function"><span class="params">(*env)</span>-&gt;</span>GetMethodID(env,testCls,<span class="string">&quot;setTestString&quot;</span>,<span class="string">&quot;(Ljava/lang/String;)V&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(methodId == NULL) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="regexp">//</span>通过方法id 调用该方法</span><br><span class="line">    (*env)-&gt;CallVoidMethod(env,obj,methodId,str_);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span>通过调用Java层的方法，来获取testString</span><br><span class="line">JNIEXPORT jstring JNICALL</span><br><span class="line">Java_com_idealist_myapplication_MainActivity_getTestString(JNIEnv *env, jobject instance,</span><br><span class="line">                                                           jobject obj) &#123;</span><br><span class="line"></span><br><span class="line">    j<span class="keyword">class</span> <span class="title class_">testCls</span> = <span class="function"><span class="params">(*env)</span>-&gt;</span>GetObjectClass(env,obj);</span><br><span class="line">    jmethodID methodId = <span class="function"><span class="params">(*env)</span>-&gt;</span>GetMethodID(env,testCls,<span class="string">&quot;getTestString&quot;</span>,<span class="string">&quot;()Ljava/lang/String;&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(methodId == NULL) &#123;</span><br><span class="line">        <span class="keyword">return</span> NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    jstring str = <span class="function"><span class="params">(*env)</span>-&gt;</span>CallObjectMethod(env, obj, methodId);</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span>通过直接访问属性域，来设置testString值。</span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL</span><br><span class="line">Java_com_idealist_myapplication_MainActivity_setTestStrByField(JNIEnv *env, jobject instance,</span><br><span class="line">                                                               jobject obj, jstring str_) &#123;</span><br><span class="line"></span><br><span class="line">    j<span class="keyword">class</span> <span class="title class_">testCls</span> = <span class="function"><span class="params">(*env)</span>-&gt;</span>GetObjectClass(env, obj);</span><br><span class="line">    jfieldID  fieldId = <span class="function"><span class="params">(*env)</span>-&gt;</span>GetFieldID(env,testCls,<span class="string">&quot;testString&quot;</span>,<span class="string">&quot;Ljava/lang/String;&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(fieldId == NULL) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    (*env)-&gt;SetObjectField(env, obj, fieldId, str_);</span><br><span class="line">&#125;</span><br><span class="line"><span class="regexp">//</span>通过直接访问属性域，来获取testString值。</span><br><span class="line">JNIEXPORT jstring JNICALL</span><br><span class="line">Java_com_idealist_myapplication_MainActivity_getTestStringByField(JNIEnv *env, jobject instance,</span><br><span class="line">                                                                  jobject obj) &#123;</span><br><span class="line">    j<span class="keyword">class</span> <span class="title class_">testCls</span> = <span class="function"><span class="params">(*env)</span>-&gt;</span>GetObjectClass(env,obj);</span><br><span class="line">    jfieldID fieldId = <span class="function"><span class="params">(*env)</span>-&gt;</span>GetFieldID(env,testCls,<span class="string">&quot;testString&quot;</span>,<span class="string">&quot;Ljava/lang/String;&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(fieldId == NULL) &#123;</span><br><span class="line">        <span class="keyword">return</span> NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    jstring str = <span class="function"><span class="params">(*env)</span>-&gt;</span>GetObjectField(env, obj, fieldId);</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个是来自JNI Programmer’s Guide and Specification文档中的一个例子：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">JNIEXPORT void JNICALL</span><br><span class="line"><span class="constructor">Java_InstanceFieldAccess_accessField(JNIEnv <span class="operator">*</span><span class="params">env</span>, <span class="params">jobject</span> <span class="params">obj</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	jfieldID fid;<span class="comment">/* store the field ID */</span></span><br><span class="line">	jstring jstr;</span><br><span class="line">	const <span class="built_in">char</span> *str;</span><br><span class="line">	<span class="comment">/* 根据jobject对象实例创建指向它的类引用 */</span></span><br><span class="line">	jclass cls = (*env)-&gt;<span class="constructor">GetObjectClass(<span class="params">env</span>, <span class="params">obj</span>)</span>;</span><br><span class="line">	printf(<span class="string">&quot;In C:\n&quot;</span>);</span><br><span class="line">	<span class="comment">/* 根据上述找到的jclass类型以及类名和标识符寻找fieldID 最后一个参数可以通过javap -p -s InstanceFieldAccess 来查看*/</span></span><br><span class="line">	fid = (*env)-&gt;<span class="constructor">GetFieldID(<span class="params">env</span>, <span class="params">cls</span>, <span class="string">&quot;s&quot;</span>,<span class="string">&quot;Ljava/lang/String;&quot;</span>)</span>;</span><br><span class="line">	<span class="keyword">if</span> (fid<span class="operator"> == </span>NULL) &#123;</span><br><span class="line">		return; <span class="comment">/* failed to find the field */</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* 读取对象的成员属性域*/</span></span><br><span class="line">	jstr = (*env)-&gt;<span class="constructor">GetObjectField(<span class="params">env</span>, <span class="params">obj</span>, <span class="params">fid</span>)</span>;</span><br><span class="line">	<span class="comment">/* 转化为C语言的字符串形式 */</span></span><br><span class="line">	str = (*env)-&gt;<span class="constructor">GetStringUTFChars(<span class="params">env</span>, <span class="params">jstr</span>, NULL)</span>;</span><br><span class="line">	<span class="keyword">if</span> (str<span class="operator"> == </span>NULL) &#123;</span><br><span class="line">		return; <span class="comment">/* out of memory */</span></span><br><span class="line">	&#125;</span><br><span class="line">	printf(<span class="string">&quot; c.s = \&quot;%s\&quot;\n&quot;</span>, str);</span><br><span class="line">	<span class="comment">/* 释放掉无用的资源 */</span></span><br><span class="line">	(*env)-&gt;<span class="constructor">ReleaseStringUTFChars(<span class="params">env</span>, <span class="params">jstr</span>, <span class="params">str</span>)</span>;</span><br><span class="line">	<span class="comment">/* 创建一个新的字符串 */</span></span><br><span class="line">	jstr = (*env)-&gt;<span class="constructor">NewStringUTF(<span class="params">env</span>, <span class="string">&quot;123&quot;</span>)</span>;</span><br><span class="line">	<span class="keyword">if</span> (jstr<span class="operator"> == </span>NULL) &#123;</span><br><span class="line">		return; <span class="comment">/* out of memory */</span></span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">/*设置对象属性值*/</span></span><br><span class="line">	(*env)-&gt;<span class="constructor">SetObjectField(<span class="params">env</span>, <span class="params">obj</span>, <span class="params">fid</span>, <span class="params">jstr</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是访问静态成员变量的例子：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">JNIEXPORT void JNICALL</span><br><span class="line"><span class="constructor">Java_StaticFieldAccess_accessField(JNIEnv <span class="operator">*</span><span class="params">env</span>, <span class="params">jobject</span> <span class="params">obj</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	jfieldID fid;</span><br><span class="line">	<span class="comment">/* store the field ID */</span></span><br><span class="line">	jint si;</span><br><span class="line">	<span class="comment">/* Get a reference to obj’s class */</span></span><br><span class="line">	jclass cls = (*env)-&gt;<span class="constructor">GetObjectClass(<span class="params">env</span>, <span class="params">obj</span>)</span>;</span><br><span class="line">	printf(<span class="string">&quot;In C:\n&quot;</span>);</span><br><span class="line">	<span class="comment">/* Look for the static field si in cls */</span></span><br><span class="line">	fid = (*env)-&gt;<span class="constructor">GetStaticFieldID(<span class="params">env</span>, <span class="params">cls</span>, <span class="string">&quot;si&quot;</span>, <span class="string">&quot;I&quot;</span>)</span>;</span><br><span class="line">	<span class="keyword">if</span> (fid<span class="operator"> == </span>NULL) &#123;</span><br><span class="line">		return; <span class="comment">/* field not found */</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* Access the static field si */</span></span><br><span class="line">	si = (*env)-&gt;<span class="constructor">GetStaticIntField(<span class="params">env</span>, <span class="params">cls</span>, <span class="params">fid</span>)</span>;</span><br><span class="line">	printf(<span class="string">&quot; StaticFieldAccess.si = %d\n&quot;</span>, si);</span><br><span class="line">	(*env)-&gt;<span class="constructor">SetStaticIntField(<span class="params">env</span>, <span class="params">cls</span>, <span class="params">fid</span>, 200)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是访问静态成员方法的例子：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">JNIEXPORT void JNICALL</span><br><span class="line"><span class="constructor">Java_StaticMethodCall_nativeMethod(JNIEnv <span class="operator">*</span><span class="params">env</span>, <span class="params">jobject</span> <span class="params">obj</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	jclass cls = (*env)-&gt;<span class="constructor">GetObjectClass(<span class="params">env</span>, <span class="params">obj</span>)</span>;</span><br><span class="line">	jmethodID mid =(*env)-&gt;<span class="constructor">GetStaticMethodID(<span class="params">env</span>, <span class="params">cls</span>, <span class="string">&quot;callback&quot;</span>, <span class="string">&quot;()V&quot;</span>)</span>;</span><br><span class="line">	<span class="keyword">if</span> (mid<span class="operator"> == </span>NULL) &#123;</span><br><span class="line">		return; <span class="comment">/* method not found */</span></span><br><span class="line">	&#125;</span><br><span class="line">	printf(<span class="string">&quot;In C\n&quot;</span>);</span><br><span class="line">	(*env)-&gt;<span class="constructor">CallStaticVoidMethod(<span class="params">env</span>, <span class="params">cls</span>, <span class="params">mid</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面我们介绍了通过GetObjectClass来获得某个jclass，下面将通过FindClass来获取：</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line">jobject thd = ...; /* a java.lang.Thread<span class="built_in"> instance </span>*/</span><br><span class="line">jmethodID mid;</span><br><span class="line">jclass runnableIntf = (*env)-&gt;FindClass(env, <span class="string">&quot;java/lang/Runnable&quot;</span>);<span class="built_in"></span></span><br><span class="line"><span class="built_in">if </span>(runnableIntf == NULL) &#123;</span><br><span class="line"><span class="keyword">.</span>.. /* error handling */</span><br><span class="line">&#125;</span><br><span class="line">mid = (*env)-&gt;GetMethodID(env, runnableIntf, <span class="string">&quot;run&quot;</span>, <span class="string">&quot;()V&quot;</span>);<span class="built_in"></span></span><br><span class="line"><span class="built_in">if </span>(mid == NULL) &#123;</span><br><span class="line">	... /* error handling */</span><br><span class="line">&#125;</span><br><span class="line">(*env)-&gt;CallVoidMethod(env, thd, mid);</span><br><span class="line"><span class="keyword">.</span>.. /*<span class="built_in"> check </span>for possible exceptions */</span><br></pre></td></tr></table></figure>

<h4 id="访问属性和方法总结："><a href="#访问属性和方法总结：" class="headerlink" title="访问属性和方法总结："></a>访问属性和方法总结：</h4><p>调用对象的静态方法的步骤</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1.</span> 使用FindClass或者GetObjectClass来获取jclass对象</span><br><span class="line"><span class="bullet">2.</span> 通过GetMethodID获取在某个类中的方法的id值。这一步需要步骤1中获取到的jclass对象，方法名，方法签名</span><br><span class="line"><span class="bullet">3.</span> 通过这个id值来调用通过CallStaticXXXMethod方法传入id，参数</span><br><span class="line"><span class="bullet">4.</span> 释放局部变量</span><br></pre></td></tr></table></figure>
<p>调用对象的实例方法的步骤（没有传入jobject的情况）</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1.</span> 使用FindClass搜索某个类</span><br><span class="line"><span class="bullet">2.</span> 获取某个类的默认构造方法</span><br><span class="line"><span class="bullet">3.</span> 通过NewObject创建该类的实例</span><br><span class="line"><span class="bullet">4.</span> 通过GetMethodID查找要调用的实例对象的方法id</span><br><span class="line"><span class="bullet">5.</span> 通过CallXXXMethod调用实例的方法</span><br><span class="line"><span class="bullet">6.</span> 释放局部变量</span><br></pre></td></tr></table></figure>
<p>调用对象的实例方法的步骤（有传入jobject的情况）</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1.</span> 如果有传入对象的话可以使用GetObjectClass获取jclass对象</span><br><span class="line"><span class="bullet">2.</span> 通过GetMethodID查找要调用的实例对象的方法id</span><br><span class="line"><span class="bullet">3.</span> 通过CallXXXMethod调用实例的方法</span><br><span class="line"><span class="bullet">4.</span> 释放局部变量</span><br></pre></td></tr></table></figure>
<p>获取和设置实例对象的属性</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1.</span> 通过 GetObjectClass 获取类的jclass引用</span><br><span class="line"><span class="bullet">2.</span> 通过GetFieldID获取实例变量的属性id</span><br><span class="line"><span class="bullet">3.</span> 通过GetXXXField来获取某个属性变量的值</span><br><span class="line"><span class="bullet">4.</span> 通过setObjectField设置某个属性对象的值</span><br><span class="line"><span class="bullet">5.</span> 删除局部变量</span><br></pre></td></tr></table></figure>

<p>获取和设置某个静态属性</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1.</span> 通过FindClass 获取类的jclass引用</span><br><span class="line"><span class="bullet">2.</span> 通过GetStaticFieldID获得静态属性id</span><br><span class="line"><span class="bullet">3.</span> 通过GetStaticXXXField来获取某个属性变量的值</span><br><span class="line"><span class="bullet">4.</span> 通过setStaticObjectField设置某个属性对象的值</span><br><span class="line"><span class="bullet">5.</span> 删除局部变量</span><br></pre></td></tr></table></figure>
<h4 id="访问父类方法和访问构造函数："><a href="#访问父类方法和访问构造函数：" class="headerlink" title="访问父类方法和访问构造函数："></a>访问父类方法和访问构造函数：</h4><ol>
<li>访问父类方法：</li>
</ol>
<p>我们可以调用在父类中已经定义但是已经被覆写的实例方法，JNI 中提供了一系列的CallNonvirtual<Type> 方法用来解决这个问题，为了能够调用父类的方法需要如下处理：</Type></p>
<ul>
<li>使用GetMethodID或者GetStaticMethodID从父类引用中获得方法id</li>
<li>传入对象，父类，方法id到上面提到的CallNonvirtual<Type>方法中。</Type></li>
</ul>
<ol start="2">
<li>访问构造函数：<br>在JNI中可以通过和调用实例对象的其他方法一样调用构造方法，唯一的区别是需要传入”<init>“作为方法名”V” 作为返回类型标识。然后通过调用 NewObject并传入方法id来创建出实例对象。<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">jstring</span><br><span class="line"><span class="constructor">MyNewString(JNIEnv <span class="operator">*</span><span class="params">env</span>, <span class="params">jchar</span> <span class="operator">*</span><span class="params">chars</span>, <span class="params">jint</span> <span class="params">len</span>)</span>&#123;</span><br><span class="line">	jclass stringClass;</span><br><span class="line">	jmethodID cid;</span><br><span class="line">	jcharArray elemArr;</span><br><span class="line">	jstring result;</span><br><span class="line">	stringClass = (*env)-&gt;<span class="constructor">FindClass(<span class="params">env</span>, <span class="string">&quot;java/lang/String&quot;</span>)</span>;</span><br><span class="line">	<span class="keyword">if</span> (stringClass<span class="operator"> == </span>NULL) &#123;</span><br><span class="line">		return NULL; <span class="comment">/* exception thrown */</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* Get the method ID for the String(char[]) constructor */</span></span><br><span class="line">	cid = (*env)-&gt;<span class="constructor">GetMethodID(<span class="params">env</span>, <span class="params">stringClass</span>,<span class="string">&quot;&lt;init&gt;&quot;</span>, <span class="string">&quot;([C)V&quot;</span>)</span>;</span><br><span class="line">	<span class="keyword">if</span> (cid<span class="operator"> == </span>NULL) &#123;</span><br><span class="line">		return NULL; <span class="comment">/* exception thrown */</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* Create a char[] that holds the string characters */</span></span><br><span class="line">	elemArr = (*env)-&gt;<span class="constructor">NewCharArray(<span class="params">env</span>, <span class="params">len</span>)</span>;</span><br><span class="line">	<span class="keyword">if</span> (elemArr<span class="operator"> == </span>NULL) &#123;</span><br><span class="line">		return NULL; <span class="comment">/* exception thrown */</span></span><br><span class="line">	&#125;</span><br><span class="line">	(*env)-&gt;<span class="constructor">SetCharArrayRegion(<span class="params">env</span>, <span class="params">elemArr</span>, 0, <span class="params">len</span>, <span class="params">chars</span>)</span>;</span><br><span class="line">	<span class="comment">/* Construct a java.lang.String object */</span></span><br><span class="line">	result = (*env)-&gt;<span class="constructor">NewObject(<span class="params">env</span>, <span class="params">stringClass</span>, <span class="params">cid</span>, <span class="params">elemArr</span>)</span>;</span><br><span class="line">	<span class="comment">/* Free local references */</span></span><br><span class="line">	(*env)-&gt;<span class="constructor">DeleteLocalRef(<span class="params">env</span>, <span class="params">elemArr</span>)</span>;</span><br><span class="line">	(*env)-&gt;<span class="constructor">DeleteLocalRef(<span class="params">env</span>, <span class="params">stringClass</span>)</span>;</span><br><span class="line">	return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></init></li>
</ol>
<p>下面通过一个例子来验证上述的知识点：</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">JNIEXPORT void JNICALL</span><br><span class="line">Java_com_idealist_myapplication_MainActivity_testSayHello(JNIEnv *env, jobject instance,</span><br><span class="line">                                                          jstring name_) &#123;</span><br><span class="line">    <span class="comment">//获取ChildClass类															  </span></span><br><span class="line">    <span class="function"><span class="title">jclass</span>  clzz = (*env)-&gt;</span>FindClass(env, <span class="string">&quot;com/idealist/myapplication/ChildClass&quot;</span>);</span><br><span class="line">    <span class="comment">//获取ChildClass的构造函数</span></span><br><span class="line">	<span class="function"><span class="title">jmethodID</span> contructureid = (*env)-&gt;</span>GetMethodID(env,clzz,<span class="string">&quot;&lt;init&gt;&quot;</span>,<span class="string">&quot;()V&quot;</span>);</span><br><span class="line">    <span class="comment">//使用构造函数创建一个对象</span></span><br><span class="line">	<span class="function"><span class="title">jobject</span> childObj = (*env)-&gt;</span>NewObject(env, clzz, contructureid);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//通过这个对象调用ChildClass sayHello的方法</span></span><br><span class="line">    <span class="function"><span class="title">jmethodID</span> sayhelloid = (*env)-&gt;</span>GetMethodID(env,clzz,<span class="string">&quot;sayHello&quot;</span>,<span class="string">&quot;(Ljava/lang/String;)V&quot;</span>);</span><br><span class="line">    (*<span class="function"><span class="title">env</span>)-&gt;</span>CallVoidMethod(env, childObj, sayhelloid, name_);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//通过FindClass获取FatherClass类</span></span><br><span class="line">    <span class="function"><span class="title">jclass</span> suppercls = (*env)-&gt;</span>FindClass(env,<span class="string">&quot;com/idealist/myapplication/FatherClass&quot;</span>);</span><br><span class="line">	<span class="comment">//获取FatherClass的sayHello的id</span></span><br><span class="line">    <span class="function"><span class="title">jmethodID</span> sayhellofromSuper = (*env)-&gt;</span>GetMethodID(env,suppercls,<span class="string">&quot;sayHello&quot;</span>,<span class="string">&quot;(Ljava/lang/String;)V&quot;</span>);</span><br><span class="line">	<span class="comment">//通过子类对象，父类jclass，父类方法id来调用父类的方法。</span></span><br><span class="line">    (*<span class="function"><span class="title">env</span>)-&gt;</span>CallNonvirtualVoidMethod(env, childObj, suppercls, sayhellofromSuper, name_);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//释放局部变量</span></span><br><span class="line">    (*<span class="function"><span class="title">env</span>)-&gt;</span>DeleteLocalRef(env, clzz);</span><br><span class="line">    (*<span class="function"><span class="title">env</span>)-&gt;</span>DeleteLocalRef(env, contructureid);</span><br><span class="line">    (*<span class="function"><span class="title">env</span>)-&gt;</span>DeleteLocalRef(env, childObj);</span><br><span class="line">    (*<span class="function"><span class="title">env</span>)-&gt;</span>DeleteLocalRef(env, sayhelloid);</span><br><span class="line">    (*<span class="function"><span class="title">env</span>)-&gt;</span>DeleteLocalRef(env, suppercls);</span><br><span class="line">    (*<span class="function"><span class="title">env</span>)-&gt;</span>DeleteLocalRef(env, sayhellofromSuper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">07</span>-<span class="number">05</span> <span class="number">21</span>:<span class="number">52</span>:<span class="number">49</span>.<span class="number">212</span> <span class="number">20472</span>-<span class="number">20472</span>/com.idealist.myapplication I/xiaohai.lin: Constructure of FatherClass</span><br><span class="line"><span class="attribute">07</span>-<span class="number">05</span> <span class="number">21</span>:<span class="number">52</span>:<span class="number">49</span>.<span class="number">212</span> <span class="number">20472</span>-<span class="number">20472</span>/com.idealist.myapplication I/xiaohai.lin: Constructure of ChildClass</span><br><span class="line"><span class="attribute">07</span>-<span class="number">05</span> <span class="number">21</span>:<span class="number">52</span>:<span class="number">49</span>.<span class="number">212</span> <span class="number">20472</span>-<span class="number">20472</span>/com.idealist.myapplication I/xiaohai.lin: From Child class Hello Jimmy</span><br><span class="line"><span class="attribute">07</span>-<span class="number">05</span> <span class="number">21</span>:<span class="number">52</span>:<span class="number">49</span>.<span class="number">212</span> <span class="number">20472</span>-<span class="number">20472</span>/com.idealist.myapplication I/xiaohai.lin: From Super class Hello Jimmy</span><br></pre></td></tr></table></figure>

<h4 id="缓存FieldID-以及methodID"><a href="#缓存FieldID-以及methodID" class="headerlink" title="缓存FieldID 以及methodID"></a>缓存FieldID 以及methodID</h4><p>每次获取FieldID以及和methodID都需要对字段、方法的名字和描述符进行一费时的检索过程。为了减小检索过程的耗时行为可以将第一次获取到的字段id缓存起来，缓存方法有两种，一种是通过将id声明为static变量在使用时缓存，另一种实在类静态初始化的时候。</p>
<ul>
<li>使用时缓存：<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">JNIEXPORT void JNICALL</span><br><span class="line"><span class="constructor">Java_InstanceFieldAccess_accessField(JNIEnv <span class="operator">*</span><span class="params">env</span>, <span class="params">jobject</span> <span class="params">obj</span>)</span> &#123;</span><br><span class="line">	<span class="comment">//使用静态变量缓存</span></span><br><span class="line">	static jfieldID fid_s = NULL; <span class="comment">/* cached field ID for s */</span></span><br><span class="line">	jclass cls = (*env)-&gt;<span class="constructor">GetObjectClass(<span class="params">env</span>, <span class="params">obj</span>)</span>;</span><br><span class="line">	jstring jstr;</span><br><span class="line">	const <span class="built_in">char</span> *str;</span><br><span class="line">	<span class="comment">//判断是否是第一次</span></span><br><span class="line">	<span class="keyword">if</span> ( fid_s<span class="operator"> == </span>NULL) &#123;</span><br><span class="line">		fid_s = (*env)-&gt;<span class="constructor">GetFieldID(<span class="params">env</span>, <span class="params">cls</span>, <span class="string">&quot;s&quot;</span>,<span class="string">&quot;Ljava/lang/String;&quot;</span>)</span>;</span><br><span class="line">		<span class="keyword">if</span> ( fid_s<span class="operator"> == </span>NULL) &#123;</span><br><span class="line">			return; <span class="comment">/* exception already thrown */</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	printf(<span class="string">&quot;In C:\n&quot;</span>);</span><br><span class="line">	jstr = (*env)-&gt;<span class="constructor">GetObjectField(<span class="params">env</span>, <span class="params">obj</span>, <span class="params">fid_s</span> )</span>;</span><br><span class="line">	str = (*env)-&gt;<span class="constructor">GetStringUTFChars(<span class="params">env</span>, <span class="params">jstr</span>, NULL)</span>;</span><br><span class="line">	<span class="keyword">if</span> (str<span class="operator"> == </span>NULL) &#123;</span><br><span class="line">		return; <span class="comment">/* out of memory */</span></span><br><span class="line">	&#125;</span><br><span class="line">	printf(<span class="string">&quot; c.s = \&quot;%s\&quot;\n&quot;</span>, str);</span><br><span class="line">	(*env)-&gt;<span class="constructor">ReleaseStringUTFChars(<span class="params">env</span>, <span class="params">jstr</span>, <span class="params">str</span>)</span>;</span><br><span class="line">	jstr = (*env)-&gt;<span class="constructor">NewStringUTF(<span class="params">env</span>, <span class="string">&quot;123&quot;</span>)</span>;</span><br><span class="line">	<span class="keyword">if</span> (jstr<span class="operator"> == </span>NULL) &#123;</span><br><span class="line">		return; <span class="comment">/* out of memory */</span></span><br><span class="line">	&#125;</span><br><span class="line">	(*env)-&gt;<span class="constructor">SetObjectField(<span class="params">env</span>, <span class="params">obj</span>, <span class="params">fid_s</span> , <span class="params">jstr</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>类初始化时缓存：<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">InstanceMethodCall</span> &#123;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> native <span class="keyword">void</span> <span class="title">initIDs</span>()</span>;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> native <span class="keyword">void</span> <span class="title">nativeMethod</span>()</span>;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">callback</span>()</span> &#123;</span><br><span class="line">		System.<span class="keyword">out</span>.println(<span class="string">&quot;In Java&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String args[]</span>)</span> &#123;</span><br><span class="line">	InstanceMethodCall c = <span class="keyword">new</span> InstanceMethodCall();</span><br><span class="line">		c.nativeMethod();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		System.loadLibrary(<span class="string">&quot;InstanceMethodCall&quot;</span>);</span><br><span class="line">		initIDs();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在类初始化的时候就获取要使用方法id或者成员变量id，并缓存起来。</span></span><br><span class="line">jmethodID MID_InstanceMethodCall_callback;</span><br><span class="line"><span class="function">JNIEXPORT <span class="keyword">void</span> JNICALL</span></span><br><span class="line"><span class="function"><span class="title">Java_InstanceMethodCall_initIDs</span>(<span class="params">JNIEnv *env, jclass cls</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	MID_InstanceMethodCall_callback =</span><br><span class="line">	(*env)-&gt;GetMethodID(env, cls, <span class="string">&quot;callback&quot;</span>, <span class="string">&quot;()V&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>那么到底用哪种方式比较合适呢？这个必须依据实际情况：<br>如果我们不能修改方法或者字段所在的类的源码的话，这时候就不用说得用使用时缓存，但是如果可以修改的话尽量使用静态初始化时缓存，因为在使用时缓存需要每次使用的时候都需要判断一下才能使用。这样效率往往不高。</p>
<h4 id="是否需要引入jni"><a href="#是否需要引入jni" class="headerlink" title="是否需要引入jni"></a>是否需要引入jni</h4><p>在我们印象中引入jni会提高运行效率，事实并不是这样的java&#x2F;native 比起 JVM 内部的 java&#x2F;java 来说有一个调用转换过程,在把控制权和入口切换给本地方法之前,VM 必须做一些额外的操作来创建参数和栈帧。这个步骤会导致java&#x2F;native 调用比java&#x2F;java 要慢。我们再来看下native&#x2F;java 调用和 java&#x2F;native从技术角度来看, native&#x2F;java 调用和 java&#x2F;native 是相似的。但实际上 native&#x2F;java调用很少见,因此VM 通常不会优化 native&#x2F;java 这种回调方式。<br>这就导致了native&#x2F;java 调用的消耗可以达到 java&#x2F;java 调用的好几倍。并且引入jni会对调试引入极大的难度，所以不是万不得已最好不要引入Jni。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Android%E8%BF%9B%E9%98%B6/">Android进阶</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/Android-JNI/">Android JNI</a>
  </div>

</div>



<div class="comments-count">
	
	  	<span></span>
		<a href="/2016/07/09/Android-进阶之JNI-开发-三访问对象成员变量和成员方法/#comments" class="ds-thread-count comments-count-link" data-thread-key="2016/07/09/Android-进阶之JNI-开发-三访问对象成员变量和成员方法/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/07/08/Android-进阶之JNI-开发-二-基本数据类型介绍/" title="Android 进阶之JNI 开发 二 JNI数据类型介绍" itemprop="url">Android 进阶之JNI 开发 二 JNI数据类型介绍</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Edgar" target="_blank" itemprop="author">Edgar</a>
		
  <p class="article-time">
    <time datetime="2016-07-08T12:18:38.000Z" itemprop="datePublished"> Published 2016-07-08</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h4 id="JNI数据类型"><a href="#JNI数据类型" class="headerlink" title="JNI数据类型"></a>JNI数据类型</h4><p>如果需要使用Jni中定义的标准数据类型需要将jni.h include到源码中。<br>JNI 提供的数据类型包括两类一类是基本数据类型，一类是引用数据类型：</p>
<p>基本数据类型总共有八种如下所示：<br><img src="/2016/07/08/Android-%E8%BF%9B%E9%98%B6%E4%B9%8BJNI-%E5%BC%80%E5%8F%91-%E4%BA%8C-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%BB%8B%E7%BB%8D/1.png"><br>引用类型就比较多了整个继承关系如下所示：<br><img src="/2016/07/08/Android-%E8%BF%9B%E9%98%B6%E4%B9%8BJNI-%E5%BC%80%E5%8F%91-%E4%BA%8C-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%BB%8B%E7%BB%8D/2.png"></p>
<p>还有一个是与访问类对象成员以及类对象方法有关的jfieldID以及jmethodID，这两个方法将会在介绍类成员调用的部分进行介绍。</p>
<p>关于八种基本数据类型我们先不再这里进行介绍了，我们重点介绍下字符串相关的类型以及数组相关类型调用的方法：</p>
<h4 id="字符串相关方法："><a href="#字符串相关方法：" class="headerlink" title="字符串相关方法："></a>字符串相关方法：</h4><p>jstring 对应的是Java语言中的strings类型，它和标准C语言下的字符串类型是不一样的，C语言中的字符串使用的是char *，是一个指向字符串的一个指针。所以我们需要在native层代码中使用字符串之前将jstring转换为C语言类型的字符串。JNI 提供了Unicode和UTF-8字符串到C语言字符类型之间的相互转换。GetStringUTFChars 这个方法可以将jstring类型的字符串转换为char * 类型，但是这里需要注意的是我们在调用这个方法进行转换的时候不要忘了对返回值进行判空处理，因为Java虚拟机需要分配内存用于存储UTF字符串。这有可能导致内存分配失败。还需要注意的是我们在使用完这些字符后需要调用ReleaseStringUTFChars来释放之前申请的内存。如果没有及时调用ReleaseStringUTFChars或者调用失败，那么就会导致内存泄漏，这个是很严重的问题。<br>接下来我们还需要看下GetStringUTFChars的第三个参数：这个是用于表示当前访问的字符串是来自原始字符串的拷贝还是直接指向原始字符串，如果返回的为JNI_TRUE那么表示返回的字符串是来自原始字符串的拷贝，如果返回的是JNI_FALSE那么返回的字符串是直接指向原来的字符串，这种情况下要注意不能去修改返回值，否则原始的字符串内容也将会同时被修改。一般我们在不需要关心Java虚拟机返回的是拷贝还是指向原始位置的指针的时候我们可以传递NULL；</p>
<p>如果我们需要使用将C语言类型的字符串转换为Java类型的字符串，那么需要使用NewStringUTF，如果这个方法中分配内存失败那么将会抛出OutOfMemoryError异常，并且返回NULL。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">JNIEXPORT jstring JNICALL</span><br><span class="line"><span class="constructor">Java_com_idealist_myapplication_MainActivity_getLine(JNIEnv <span class="operator">*</span><span class="params">env</span>, <span class="params">jobject</span> <span class="params">instance</span>, <span class="params">jstring</span> <span class="params">line_</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">    jboolean isCopy = JNI_FALSE;</span><br><span class="line">    const <span class="built_in">char</span> *line = (*env)-&gt;<span class="constructor">GetStringUTFChars(<span class="params">env</span>, <span class="params">line_</span>, &amp;<span class="params">isCopy</span>)</span>;</span><br><span class="line">    <span class="keyword">if</span>(line<span class="operator"> == </span>NULL) &#123;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">char</span> buf<span class="literal">[<span class="number">256</span>]</span>;</span><br><span class="line">    stpcpy(buf,<span class="string">&quot; This is a String add by xiaohai &quot;</span>);</span><br><span class="line">    strcat(buf,line);</span><br><span class="line">    (*env)-&gt;<span class="constructor">ReleaseStringUTFChars(<span class="params">env</span>, <span class="params">line_</span>, <span class="params">line</span>)</span>;</span><br><span class="line">    return (*env)-&gt;<span class="constructor">NewStringUTF(<span class="params">env</span>, <span class="params">buf</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">下面是字符串相关的JNI方法的说明：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>GetStringChars&#x2F;ReleaseStringChars</td>
<td>获取或者释放一个指向Unicode格式字符串的内容的指针，这种情况下有可能返回字符串的拷贝</td>
</tr>
<tr>
<td>GetStringUTFChars&#x2F;ReleaseStringUTFChars</td>
<td>获取或者释放一个指向UTF格式字符串的内容的指针，这种情况下有可能返回字符串的拷贝</td>
</tr>
<tr>
<td>GetStringLength</td>
<td>返回在Unicode string中的字符串个数</td>
</tr>
<tr>
<td>GetStringUTFLength</td>
<td>返回在UTF-8 string中的字符串个数</td>
</tr>
<tr>
<td>NewString</td>
<td>通过传入的Unicode C string 创建一个java.lang.String对象</td>
</tr>
<tr>
<td>NewStringUTF</td>
<td>通过传入的UTF-8 C string 创建一个java.lang.String对象</td>
</tr>
<tr>
<td>Get&#x2F;ReleaseStringCritical</td>
<td>这两个方法一般成对使用，在这两个方法之间的native代码必须不能调用哪些会导致当前线程阻塞或者等待其他运行在Java虚拟机上的线程，这些限制可以避免Java虚拟机在native代码持有一个通过GetStringCritical返回的直接指针的时候进行垃圾回收</td>
</tr>
<tr>
<td>GetStringUTFRegion&#x2F;SetStringRegion</td>
<td>由于GetStringUTFRegion没有进行内存分配所以我们不需要进行out-of-memory条件的判断，并且不需要对资源进行释放</td>
</tr>
<tr>
<td>GetStringUTFRegion&#x2F;SetStringRegion</td>
<td>这个与上面的类似</td>
</tr>
</tbody></table>
<p>下面是关于如何选择对应方法的说明：<br><img src="/2016/07/08/Android-%E8%BF%9B%E9%98%B6%E4%B9%8BJNI-%E5%BC%80%E5%8F%91-%E4%BA%8C-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%BB%8B%E7%BB%8D/3.png"></p>
<h4 id="数组相关方法："><a href="#数组相关方法：" class="headerlink" title="数组相关方法："></a>数组相关方法：</h4><p>使用GetIntArrayRegion方法来访问：</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">JNIEXPORT </span><span class="keyword">jint </span><span class="keyword">JNICALL</span></span><br><span class="line"><span class="keyword"></span><span class="keyword">Java_com_idealist_myapplication_MainActivity_sumOfTheArrayByRegion(JNIEnv </span>*env, <span class="keyword">jobject </span><span class="keyword">instance,</span></span><br><span class="line"><span class="keyword"></span>                                                                   <span class="keyword">jintArray </span>intArray_, <span class="keyword">jint </span>size) &#123;</span><br><span class="line">    <span class="keyword">jint </span><span class="keyword">buf[size];</span></span><br><span class="line"><span class="keyword"></span>    <span class="keyword">jint </span>i, sum = <span class="number">0</span>;</span><br><span class="line">    (*env)-&gt;GetIntArrayRegion(env, intArray_, <span class="number">0</span>, size, <span class="keyword">buf);</span></span><br><span class="line"><span class="keyword"></span>    for (i = <span class="number">0</span><span class="comment">; i &lt; 10; i++) &#123;</span></span><br><span class="line">        sum += <span class="keyword">buf[i];</span></span><br><span class="line"><span class="keyword"></span>    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第三个参数表示起始的index，第四个参数表示需要copy的元素的个数，一旦这些元素都被拷贝到C缓存器那么我们就可以在native层使用这些参数了。同样我们可以使用SetIntArrayRegion方法来设置某个数组的值。对于小型，大小固定的数组Get&#x2F;Set<Type>ArrayRegion是最有效的方式，因为在C堆栈中分配内存是十分快速的方式。</Type></p>
<p>使用GetIntArrayElements方法来访问</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">Java_com_idealist_myapplication_MainActivity_sumOfTheArray(JNIEnv *env, jobject instance,</span><br><span class="line">                                                           jintArray intArray_, jint <span class="built_in">size</span>) &#123;</span><br><span class="line">    jint *intArray = (*env)-&gt;GetIntArrayElements(env, intArray_, NULL);</span><br><span class="line">    <span class="keyword">if</span>(intArray == NULL) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    jint <span class="built_in">sum</span> = <span class="number">0</span>;</span><br><span class="line">    jint <span class="built_in">index</span> =<span class="number">0</span>;</span><br><span class="line">    for(<span class="built_in">index</span> = <span class="number">0</span>;<span class="built_in">index</span>&lt;<span class="built_in">size</span>;<span class="built_in">index</span>++) &#123;</span><br><span class="line">        <span class="built_in">sum</span> += intArray[<span class="built_in">index</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    (*env)-&gt;ReleaseIntArrayElements(env, intArray_, intArray, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>GetArrayLength 返回数组中的元素长度<br>New<Type>Array 创建一个指定长度的数组</Type></p>
<p><img src="/2016/07/08/Android-%E8%BF%9B%E9%98%B6%E4%B9%8BJNI-%E5%BC%80%E5%8F%91-%E4%BA%8C-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%BB%8B%E7%BB%8D/4.png"></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Android%E8%BF%9B%E9%98%B6/">Android进阶</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/Android-JNI/">Android JNI</a>
  </div>

</div>



<div class="comments-count">
	
	  	<span></span>
		<a href="/2016/07/08/Android-进阶之JNI-开发-二-基本数据类型介绍/#comments" class="ds-thread-count comments-count-link" data-thread-key="2016/07/08/Android-进阶之JNI-开发-二-基本数据类型介绍/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/07/07/Android-进阶之-NDK-开发/" title="Android 进阶之 NDK 开发" itemprop="url">Android 进阶之 NDK 开发</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Edgar" target="_blank" itemprop="author">Edgar</a>
		
  <p class="article-time">
    <time datetime="2016-07-07T13:01:41.000Z" itemprop="datePublished"> Published 2016-07-07</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>之前写过在Android 使用NDK进行开发的博客，<a href="/Android-studio-%E4%B8%8B%E4%BD%BF%E7%94%A8JNI.md">Android Studio 下使用JNI</a> 但是这种方式很麻烦，我觉得NDK只是一个工具不应该在配置上弄得十分麻烦，所以我在看到gradle-experimental插件进行JNI开发的时候我就好不犹豫地进行了尝试，下面我们就来看下如何使用gradle-experimental进行JNI开发：</p>
<ul>
<li><p>添加NDK路径<br><img src="/2016/07/07/Android-%E8%BF%9B%E9%98%B6%E4%B9%8B-NDK-%E5%BC%80%E5%8F%91/1.png"></p>
</li>
<li><p>配置Project的build.gradle</p>
</li>
</ul>
<p>将项目build.gradle配置文件的dependencies节点中中classpath的值改为对应的gradle-experimental插件。如果你不知道gradle-experimental最新的版本可以使用如下方式查询，它会返回目前的最新插件版本。<br><img src="/2016/07/07/Android-%E8%BF%9B%E9%98%B6%E4%B9%8B-NDK-%E5%BC%80%E5%8F%91/2.png"></p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    <span class="keyword">classpath</span> <span class="string">&#x27;com.android.tools.build:gradle-experimental:0.7.2&#x27;</span></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>修改app目录下的build.gradle</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将插件名由&#x27;com.android.application&#x27;换成&#x27;com.android.model.application&#x27;。</span></span><br><span class="line">apply plugin: <span class="string">&#x27;com.android.model.application&#x27;</span></span><br><span class="line"><span class="comment">//新增加model节点，将原来android除了defaultConfig外的其他节点全部移到android节点外并与android并列，并且前面的名字加上android.。</span></span><br><span class="line">model &#123;</span><br><span class="line">    <span class="comment">//该节点下的全部都换成 “ = ”</span></span><br><span class="line">    android &#123;</span><br><span class="line">        compileSdkVersion = <span class="number">23</span></span><br><span class="line">        buildToolsVersion = <span class="string">&quot;23.0.3&quot;</span></span><br><span class="line">        defaultConfig &#123;</span><br><span class="line">            applicationId = <span class="string">&quot;com.idealist.myapplication&quot;</span></span><br><span class="line">            <span class="comment">//这里修改为minSdkVersion.apiLevel</span></span><br><span class="line">            minSdkVersion<span class="selector-class">.apiLevel</span> = <span class="number">15</span></span><br><span class="line">            <span class="comment">//这里修改为targetSdkVersion.apiLevel</span></span><br><span class="line">            targetSdkVersion<span class="selector-class">.apiLevel</span> = <span class="number">23</span></span><br><span class="line">            versionCode = <span class="number">4</span></span><br><span class="line">            versionName = <span class="string">&quot;1.0.1&quot;</span></span><br><span class="line">            testInstrumentationRunner = <span class="string">&quot;android.support.test.runner.AndroidJUnitRunner&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    android<span class="selector-class">.buildTypes</span> &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            minifyEnabled false</span><br><span class="line">            <span class="comment">//修改为proguardFiles.add</span></span><br><span class="line">            proguardFiles<span class="selector-class">.add</span>(<span class="built_in">file</span>(<span class="string">&quot;proguard-rules.txt&quot;</span>))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//新增节点</span></span><br><span class="line">    android<span class="selector-class">.ndk</span> &#123;</span><br><span class="line">        moduleName <span class="string">&quot;testndk&quot;</span></span><br><span class="line">        ldLibs<span class="selector-class">.addAll</span>(<span class="selector-attr">[<span class="string">&#x27;log&#x27;</span>]</span>)</span><br><span class="line">        cppFlags<span class="selector-class">.add</span>(<span class="string">&quot;-std=c++11&quot;</span>)</span><br><span class="line">        cppFlags<span class="selector-class">.add</span>(<span class="string">&quot;-fexceptions&quot;</span>)</span><br><span class="line">        stl <span class="string">&#x27;gnustl_shared&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile <span class="built_in">fileTree</span>(include: <span class="selector-attr">[<span class="string">&#x27;*.jar&#x27;</span>]</span>, dir: <span class="string">&#x27;libs&#x27;</span>)</span><br><span class="line">    compile <span class="string">&#x27;com.android.support:appcompat-v7:23.3.0&#x27;</span></span><br><span class="line">    compile <span class="string">&#x27;com.android.support.constraint:constraint-layout:1.0.0-alpha1&#x27;</span></span><br><span class="line">    testCompile <span class="string">&#x27;junit:junit:4.12&#x27;</span></span><br><span class="line">    androidTestCompile <span class="string">&#x27;com.android.support.test.espresso:espresso-core:2.2.2&#x27;</span></span><br><span class="line">    androidTestCompile <span class="string">&#x27;com.android.support.test:runner:0.5&#x27;</span></span><br><span class="line">    androidTestCompile <span class="string">&#x27;com.android.support:support-annotations:23.3.0&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>打开MainActivity 定义native方法，这时候方法会提示错误的信息，按下Alt + Enter打开备选解决方案：Create function java_com_idealist_myapplication_MainActivity_getStringFromNative<br><img src="/2016/07/07/Android-%E8%BF%9B%E9%98%B6%E4%B9%8B-NDK-%E5%BC%80%E5%8F%91/3.png"></li>
<li>这时候会在java的同级目录下自动新建一个jni的目录，并新建了一个c++源码文件：<br><img src="/2016/07/07/Android-%E8%BF%9B%E9%98%B6%E4%B9%8B-NDK-%E5%BC%80%E5%8F%91/4.png"></li>
<li>源码内容如下，我们修改这个方法通过它来返回一个字符串如下所示：<br><img src="/2016/07/07/Android-%E8%BF%9B%E9%98%B6%E4%B9%8B-NDK-%E5%BC%80%E5%8F%91/5.png"></li>
<li>使用loadLibrary引入库，在MainActivity中使用getStringFromNative<br><img src="/2016/07/07/Android-%E8%BF%9B%E9%98%B6%E4%B9%8B-NDK-%E5%BC%80%E5%8F%91/6.png"></li>
</ul>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Android%E8%BF%9B%E9%98%B6/">Android进阶</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/Android-JNI/">Android JNI</a>
  </div>

</div>



<div class="comments-count">
	
	  	<span></span>
		<a href="/2016/07/07/Android-进阶之-NDK-开发/#comments" class="ds-thread-count comments-count-link" data-thread-key="2016/07/07/Android-进阶之-NDK-开发/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/07/07/Android-进阶之JNI-开发-一/" title="Android 进阶之JNI 开发 一 概述" itemprop="url">Android 进阶之JNI 开发 一 概述</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Edgar" target="_blank" itemprop="author">Edgar</a>
		
  <p class="article-time">
    <time datetime="2016-07-07T11:09:03.000Z" itemprop="datePublished"> Published 2016-07-07</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h4 id="为什么使用JNI"><a href="#为什么使用JNI" class="headerlink" title="为什么使用JNI"></a>为什么使用JNI</h4><p>我们知道Java语言是一个跨平台的语音，而C&#x2F;C++这是一个对平台有依赖的语言，所以不是万不得已个人并不推荐在项目中引入项目中，一旦引入JNI那么我们将失去跨平台的特性，对特定的平台会产生依赖，并且NE是开发中最难解决的问题，一旦抛出Native 层的错误将会增加我们定位问题的难度。那么我们一般什么时候才需要使用到JNI技术呢?</p>
<ul>
<li>我们在编程中需要用到某个功能，这个功能之前已经用C&#x2F;C++等本地语言进行编写了，这时候为了避免重复造轮子，所以使用JNI在Java层调用这些已经封装好的方法。</li>
<li>有些功能需要非常严格的时效性，或者某些方法需要和特定的硬件进行交互，比如某些缓存的操作等。这种情况下就需要使用到JNI了。</li>
<li>为了应用的安全性，会将一些复杂的逻辑和算法通过本地代码来实现，然后封装成so动态库文件，并提供Java接口供应用层调用，从而防止被反编译。</li>
</ul>
<h4 id="JNI在整个开发中所扮演的角色"><a href="#JNI在整个开发中所扮演的角色" class="headerlink" title="JNI在整个开发中所扮演的角色"></a>JNI在整个开发中所扮演的角色</h4><p>JNI顾名思义Java Native Interface，是Java和Native层的一个接口，但是要注意的是这是一个双向接口，也就是说不但运行在Java层调用Native层，也允许在Native层调用Java层。<br><img src="/2016/07/07/Android-%E8%BF%9B%E9%98%B6%E4%B9%8BJNI-%E5%BC%80%E5%8F%91-%E4%B8%80/1.png"></p>
<h4 id="使用Android-Studio开发JNI"><a href="#使用Android-Studio开发JNI" class="headerlink" title="使用Android Studio开发JNI"></a>使用Android Studio开发JNI</h4><p>在Android Studio中进行JNI开发环境的搭建，请查看我之前的一篇博客《Android 进阶之 NDK 开发》这里就不重复介绍了。</p>
<h4 id="最简单的例子介绍"><a href="#最简单的例子介绍" class="headerlink" title="最简单的例子介绍"></a>最简单的例子介绍</h4><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public <span class="keyword">class</span> MainActivity extends AppCompatActivity &#123;</span><br><span class="line">    <span class="comment">// [1]</span></span><br><span class="line">    <span class="keyword">private</span> native String get<span class="constructor">StringFromNative()</span>;</span><br><span class="line">    <span class="comment">// [2]</span></span><br><span class="line">    static &#123;</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>load<span class="constructor">Library(<span class="string">&quot;testndk&quot;</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> TextView mTextView = null;</span><br><span class="line">    @Override</span><br><span class="line">    protected void on<span class="constructor">Create(Bundle <span class="params">savedInstanceState</span>)</span> &#123;</span><br><span class="line">        super.on<span class="constructor">Create(<span class="params">savedInstanceState</span>)</span>;</span><br><span class="line">        set<span class="constructor">ContentView(R.<span class="params">layout</span>.<span class="params">activity_main</span>)</span>;</span><br><span class="line">        mTextView = (TextView) find<span class="constructor">ViewById(R.<span class="params">id</span>.<span class="params">demojni</span>)</span>;</span><br><span class="line">        mTextView.set<span class="constructor">Text(<span class="params">getStringFromNative</span>()</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">#<span class="keyword">include</span> &lt;jni.h&gt;</span><br><span class="line">JNIEXPORT jstring JNICALL</span><br><span class="line"><span class="comment">//[3]</span></span><br><span class="line"><span class="constructor">Java_com_idealist_myapplication_MainActivity_getStringFromNative(JNIEnv <span class="operator">*</span><span class="params">env</span>, <span class="params">jobject</span> <span class="params">instance</span>)</span> &#123;</span><br><span class="line">    return (*env)-&gt;<span class="constructor">NewStringUTF(<span class="params">env</span>, <span class="string">&quot;Hello JNI&quot;</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面将会上面标注的三点进行讲解，给大家一个简单的入门，这个例子中通过调用getStringFromNative这个native方法返回一个”Hello JNI”，并将其显示到TextView上。<br>[1]. 所有的Native方法在定义的时候都需要添加native标识。<br>[2]. 在Linux 环境下编译后会生成一个”lib”+模块名+“.so”的库文件，在这个例子中模块名为testndk所以会生成libtestndk.so，而在Window环境下会生成一个”lib”+模块名+“.dll”的库文件，在需要使用这些库文件里面的方法的时候需要使用loadLibrary将库引入。<br>[3]. Java_com_idealist_myapplication_MainActivity_getStringFromNative这个方法是自动生成的，它的生成规律是Java_包名将所有的分隔符由点换成下划线_native方法声明所处的类库_native方法名。<br>我们接下来看下这个jni方法的参数(JNIEnv *env, jobject instance) 第一个参数是一个方法指针指向JNI提供的方法，如果下图所示：<br><img src="/2016/07/07/Android-%E8%BF%9B%E9%98%B6%E4%B9%8BJNI-%E5%BC%80%E5%8F%91-%E4%B8%80/2.png"><br>第二个参数要视Java层上声明的方法为静态方法还是非静态方法，如果是静态方法则传入的是jclass表示指向某个类，如果是动态方法者传入的是jobject类型参数，指向的是调用的对象。<br>JNIEXPORT 和 JNICALL 宏定义用于确保外部能够从native库中看到这个方法。</p>
<p>如果上面看不是很懂，没事可以在接下来的博客的例子中慢慢体会。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Android%E8%BF%9B%E9%98%B6/">Android进阶</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/Android-JNI/">Android JNI</a>
  </div>

</div>



<div class="comments-count">
	
	  	<span></span>
		<a href="/2016/07/07/Android-进阶之JNI-开发-一/#comments" class="ds-thread-count comments-count-link" data-thread-key="2016/07/07/Android-进阶之JNI-开发-一/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>







  <nav id="page-nav" class="clearfix">
    <a class="extend prev" rel="prev" href="/page/14/">&lt;span&gt;&lt;&#x2F;span&gt;Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><a class="page-number" href="/page/14/">14</a><span class="page-number current">15</span><a class="page-number" href="/page/16/">16</a><a class="page-number" href="/page/17/">17</a><span class="space">&hellip;</span><a class="page-number" href="/page/30/">30</a><a class="extend next" rel="next" href="/page/16/">Next&lt;span&gt;&lt;&#x2F;span&gt;</a>
  </nav>

</div>
      <div class="openaside"><a class="navbutton" href="#" title="Show Sidebar"></a></div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="Hide Sidebar"></a></div>
<aside class="clearfix">
<div id="authorInfo">
	
		<div class="author-img"></div>		
	
	<div class="social-info" class="clearfix">
		
		
		<a href="https://github.com/tbfungeek" target="_blank" class="icon-github" title="github"></a>
		
		
		
		
		
		
		
		
		
		
		<a href="mailto:tbfungeek@163.com" target="_blank" class="icon-email" title="Email Me"></a>
		

	</div>
</div>

  
<div class="categorieslist">
	<p class="asidetitle">Categories</p>
		<ul>
		
		  
			<li><a href="/categories/Android-小经验/" title="Android 小经验">Android 小经验<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Android-源码分析/" title="Android 源码分析">Android 源码分析<sup>21</sup></a></li>
		  
		
		  
			<li><a href="/categories/Android其他/" title="Android其他">Android其他<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Android初步/" title="Android初步">Android初步<sup>21</sup></a></li>
		  
		
		  
			<li><a href="/categories/Android进阶/" title="Android进阶">Android进阶<sup>100</sup></a></li>
		  
		
		  
			<li><a href="/categories/Hexo-使用/" title="Hexo 使用">Hexo 使用<sup>10</sup></a></li>
		  
		
		  
			<li><a href="/categories/JavaScript理论/" title="JavaScript理论">JavaScript理论<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Objective-C-相关/" title="Objective C 相关">Objective C 相关<sup>24</sup></a></li>
		  
		
		  
			<li><a href="/categories/OpenCV/" title="OpenCV">OpenCV<sup>6</sup></a></li>
		  
		
		  
			<li><a href="/categories/ROS/" title="ROS">ROS<sup>9</sup></a></li>
		  
		
		  
			<li><a href="/categories/iOS-工具使用/" title="iOS 工具使用">iOS 工具使用<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/iOS-开源库分析/" title="iOS 开源库分析">iOS 开源库分析<sup>36</sup></a></li>
		  
		
		  
			<li><a href="/categories/iOS-理论基础/" title="iOS 理论基础">iOS 理论基础<sup>14</sup></a></li>
		  
		
		  
			<li><a href="/categories/iOS-进阶/" title="iOS 进阶">iOS 进阶<sup>4</sup></a></li>
		  
		
		  
			<li><a href="/categories/个人收藏/" title="个人收藏">个人收藏<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/代码规范/" title="代码规范">代码规范<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/其他/" title="其他">其他<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/博客分类目录/" title="博客分类目录">博客分类目录<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/叨叨系列/" title="叨叨系列">叨叨系列<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/开源代码分析/" title="开源代码分析">开源代码分析<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/开源库分析/" title="开源库分析">开源库分析<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/树莓派/" title="树莓派">树莓派<sup>4</sup></a></li>
		  
		
		  
			<li><a href="/categories/版本控制/" title="版本控制">版本控制<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/直播/" title="直播">直播<sup>6</sup></a></li>
		  
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">Tags</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/iOS-开源库分析/" title="iOS 开源库分析">iOS 开源库分析<sup>36</sup></a></li>
			
		
			
				<li><a href="/tags/Android-设计模式/" title="Android 设计模式">Android 设计模式<sup>29</sup></a></li>
			
		
			
				<li><a href="/tags/Objective-C-相关/" title="Objective C 相关">Objective C 相关<sup>24</sup></a></li>
			
		
			
				<li><a href="/tags/Android基础/" title="Android基础">Android基础<sup>21</sup></a></li>
			
		
			
				<li><a href="/tags/AOSP-源码/" title="AOSP 源码">AOSP 源码<sup>17</sup></a></li>
			
		
			
				<li><a href="/tags/Android-常用第三方库/" title="Android 常用第三方库">Android 常用第三方库<sup>15</sup></a></li>
			
		
			
				<li><a href="/tags/iOS-理论基础/" title="iOS 理论基础">iOS 理论基础<sup>14</sup></a></li>
			
		
			
				<li><a href="/tags/Hexo-使用/" title="Hexo 使用">Hexo 使用<sup>10</sup></a></li>
			
		
			
				<li><a href="/tags/ROS/" title="ROS">ROS<sup>9</sup></a></li>
			
		
			
				<li><a href="/tags/Android-动画进阶/" title="Android 动画进阶">Android 动画进阶<sup>8</sup></a></li>
			
		
			
				<li><a href="/tags/Android-JNI/" title="Android JNI">Android JNI<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/Android-绘图进阶/" title="Android 绘图进阶">Android 绘图进阶<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/Android性能优化/" title="Android性能优化">Android性能优化<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/Android-自动化测试/" title="Android 自动化测试">Android 自动化测试<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/OpenCV/" title="OpenCV">OpenCV<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/直播/" title="直播">直播<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/Android-开源源码/" title="Android 开源源码">Android 开源源码<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/Android-自定义View进阶/" title="Android 自定义View进阶">Android 自定义View进阶<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/树莓派/" title="树莓派">树莓派<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/iOS-进阶/" title="iOS 进阶">iOS 进阶<sup>4</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">Links</p>
    <ul>
        
          <li>
            
            	<a href="https://hexo.io" target="_blank" title="Hexo">Hexo</a>
            
          </li>
        
          <li>
            
            	<a href="https://pages.github.com/" target="_blank" title="GitHub">GitHub</a>
            
          </li>
        
          <li>
            
            	<a href="http://pf18.github.io/" target="_blank" title="PF18">PF18</a>
            
          </li>
        
          <li>
            
            	<a href="http://toutiao.io/" target="_blank" title="开发者头条">开发者头条</a>
            
          </li>
        
          <li>
            
            	<a href="http://www.jcodecraeer.com/" target="_blank" title="泡在网上的日子">泡在网上的日子</a>
            
          </li>
        
    </ul>
</div>

  


  <div class="rsspart">
	<a href="atom.xml" target="_blank" title="rss">RSS</a>
</div>

  
  <div class="tagcloudlist">
    <p class="asidetitle">Tag Cloud</p>
    <div class="tagcloudlist clearfix">
       <a href="/tags/AOSP-%E6%BA%90%E7%A0%81/" style="font-size: 17.14px;">AOSP 源码</a> <a href="/tags/Android-APK-%E7%AD%BE%E5%90%8D/" style="font-size: 10px;">Android APK 签名</a> <a href="/tags/Android-JNI/" style="font-size: 12.86px;">Android JNI</a> <a href="/tags/Android-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E8%BF%9B%E9%98%B6/" style="font-size: 10.71px;">Android 事件处理进阶</a> <a href="/tags/Android-%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6/" style="font-size: 13.57px;">Android 动画进阶</a> <a href="/tags/Android-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%80%E5%8F%91/" style="font-size: 10px;">Android 多线程开发</a> <a href="/tags/Android-%E5%B0%8F%E7%BB%8F%E9%AA%8C/" style="font-size: 10px;">Android 小经验</a> <a href="/tags/Android-%E5%B8%B8%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/" style="font-size: 16.43px;">Android 常用第三方库</a> <a href="/tags/Android-%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/" style="font-size: 10px;">Android 开发流程</a> <a href="/tags/Android-%E5%BC%80%E6%BA%90%E6%BA%90%E7%A0%81/" style="font-size: 12.14px;">Android 开源源码</a> <a href="/tags/Android-%E7%BB%98%E5%9B%BE%E8%BF%9B%E9%98%B6/" style="font-size: 12.86px;">Android 绘图进阶</a> <a href="/tags/Android-%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/" style="font-size: 12.86px;">Android 自动化测试</a> <a href="/tags/Android-%E8%87%AA%E5%AE%9A%E4%B9%89View%E8%BF%9B%E9%98%B6/" style="font-size: 12.14px;">Android 自定义View进阶</a> <a href="/tags/Android-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 19.29px;">Android 设计模式</a> <a href="/tags/Android%E5%85%B6%E4%BB%96/" style="font-size: 10px;">Android其他</a> <a href="/tags/Android%E5%9F%BA%E7%A1%80/" style="font-size: 17.86px;">Android基础</a> <a href="/tags/Android%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/" style="font-size: 10px;">Android开发流程</a> <a href="/tags/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" style="font-size: 12.86px;">Android性能优化</a> <a href="/tags/Android%E6%B7%B7%E6%B7%86%E6%8A%80%E6%9C%AF/" style="font-size: 10px;">Android混淆技术</a> <a href="/tags/Android%E8%B4%A8%E9%87%8F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/" style="font-size: 11.43px;">Android质量管理工具</a> <a href="/tags/Android%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/" style="font-size: 10px;">Android逆向工程</a> <a href="/tags/Git-github/" style="font-size: 10px;">Git && github</a> <a href="/tags/Hexo-%E4%BD%BF%E7%94%A8/" style="font-size: 15px;">Hexo 使用</a> <a href="/tags/JavaScript/" style="font-size: 10px;">JavaScript</a> <a href="/tags/Linux-%E4%BD%BF%E7%94%A8/" style="font-size: 10px;">Linux 使用</a> <a href="/tags/Objective-C-%E7%9B%B8%E5%85%B3/" style="font-size: 18.57px;">Objective C 相关</a> <a href="/tags/OpenCV/" style="font-size: 12.86px;">OpenCV</a> <a href="/tags/ROS/" style="font-size: 14.29px;">ROS</a> <a href="/tags/iOS-%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/" style="font-size: 10.71px;">iOS 工具使用</a> <a href="/tags/iOS-%E5%BC%80%E6%BA%90%E5%BA%93%E5%88%86%E6%9E%90/" style="font-size: 20px;">iOS 开源库分析</a> <a href="/tags/iOS-%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/" style="font-size: 15.71px;">iOS 理论基础</a> <a href="/tags/iOS-%E8%BF%9B%E9%98%B6/" style="font-size: 12.14px;">iOS 进阶</a> <a href="/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/" style="font-size: 10px;">代码规范</a> <a href="/tags/%E5%8D%9A%E5%AE%A2%E5%88%86%E7%B1%BB%E7%9B%AE%E5%BD%95/" style="font-size: 10.71px;">博客分类目录</a> <a href="/tags/%E5%8F%A8%E5%8F%A8%E7%B3%BB%E5%88%97/" style="font-size: 10px;">叨叨系列</a> <a href="/tags/%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/" style="font-size: 11.43px;">工具的使用</a> <a href="/tags/%E5%BC%80%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/" style="font-size: 10.71px;">开源代码分析</a> <a href="/tags/%E5%BC%80%E6%BA%90%E5%BA%93%E5%88%86%E6%9E%90/" style="font-size: 10px;">开源库分析</a> <a href="/tags/%E6%9D%82%E7%B1%BB/" style="font-size: 10px;">杂类</a> <a href="/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/" style="font-size: 12.14px;">树莓派</a> <a href="/tags/%E7%9B%B4%E6%92%AD/" style="font-size: 12.86px;">直播</a> <a href="/tags/%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/" style="font-size: 10.71px;">编程技巧</a> <a href="/tags/%E7%BD%91%E7%AB%99%E6%94%B6%E8%97%8F/" style="font-size: 10px;">网站收藏</a> <a href="/tags/%E9%87%8D%E8%A6%81%E6%8E%A7%E4%BB%B6/" style="font-size: 11.43px;">重要控件</a>
    </div>
  </div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
		
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/hsihohuang/kiddochan" target="_blank" title="Kiddochan">Kiddochan</a> © 2022 
		
		<a href="/about" target="_blank" title="Edgar">Edgar</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
        
    }
  });
});
</script>










<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?7c9443b0374f1cf6b1dbb5ab84d939cb";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="Back to Top"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
 </html>
