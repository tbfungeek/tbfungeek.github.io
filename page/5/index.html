
 <!DOCTYPE HTML>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
  
    <title>Edgar&#39;s Blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="Edgar">
    

    
    <meta name="description" content="Android | 全栈工程师">
<meta property="og:type" content="website">
<meta property="og:title" content="Edgar&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/page/5/index.html">
<meta property="og:site_name" content="Edgar&#39;s Blog">
<meta property="og:description" content="Android | 全栈工程师">
<meta property="og:locale">
<meta property="article:author" content="Edgar">
<meta name="twitter:card" content="summary">

    
    <link rel="alternative" href="atom.xml" title="Edgar&#39;s Blog" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/unnamed4_n_mSY_icon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/profile.png">
    <link rel="apple-touch-icon-precomposed" href="/img/profile.png">
    
    
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 6.2.0"></head>

  <body>
    <header>
      
<div>
		
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="Edgar&#39;s Blog">Edgar&#39;s Blog</a></h1>
				<h2 class="blog-motto"></h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="Menu">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
					<li>
 					
					<form class="search" action="/search/index.html" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" autocomplete="off" name="q" maxlength="20" placeholder="Search" />
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main">

   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/11/15/Texture-六-Texture-的其他用法/" title="Texture 六 Texture 的其他用法" itemprop="url">Texture 六 Texture 的其他用法</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Edgar" target="_blank" itemprop="author">Edgar</a>
		
  <p class="article-time">
    <time datetime="2019-11-15T07:45:22.000Z" itemprop="datePublished"> Published 2019-11-15</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h6 id="1-使用-Hit-Test-Slop-来扩大某个节点的点击区间"><a href="#1-使用-Hit-Test-Slop-来扩大某个节点的点击区间" class="headerlink" title="1 使用 Hit Test Slop 来扩大某个节点的点击区间"></a>1 使用 Hit Test Slop 来扩大某个节点的点击区间</h6><p>个人觉得这个功能还是十分便捷的，有时候设计很经常又要求图片显示区域小，但是点击区域又要很大，这时候就可以使用Hit Test Slop来完成。<br>hitTestSlop属性是一个UIEdgeInsets类型，可以通过它来扩大或者缩小可点击区域。值得注意的是这个属性在ASDisplayNode类中，所以任何的节点都可以使用它来扩展点击区域。</p>
<p>Hit Test的可视化调试工具：</p>
<p><a target="_blank" rel="noopener" href="http://texturegroup.org/docs/debug-tool-hit-test-visualization">http://texturegroup.org/docs/debug-tool-hit-test-visualization</a></p>
<p>使用方法：</p>
<p>在AppDelegate.m 文件中导入AsyncDisplayKit+Debug.h 在 didFinishLaunchingWithOptions 方法里面添加</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="string">[ASControlNode setEnableHitTestDebug:YES]</span></span><br></pre></td></tr></table></figure>
<p>需要注意的是上面这个调用必须在所有的ASControlNodes初始化之前。</p>
<h6 id="2-提前批量获取"><a href="#2-提前批量获取" class="headerlink" title="2 提前批量获取"></a>2 提前批量获取</h6><p>在默认情况下，在用户滚动列表的时候，当到达数据还没到达界面上的时候可以提前批量获取数据。如果需要提前获取可以指定leadingScreensForBatching</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">tableNode.view.leadingScreensForBatching</span> = <span class="number">3.0</span><span class="comment">; </span></span><br></pre></td></tr></table></figure>
<p>指定leadingScreensForBatching 后我们滚动列表，一旦列表到达需要预加载的区域，就会调用shouldBatchFetchForTableNode方法，这个方法可以决定是否需要预先加载数据。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">BOOL</span>)shouldBatchFetchForTableNode:(ASTableNode *)tableNode &#123;</span><br><span class="line">  <span class="keyword">if</span> (_weNeedMoreContent) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果shouldBatchFetchForTableNode返回YES 那么就会通过tableNode:willBeginBatchFetchWithContext 来获取数据。注意这个方法是在后台调用的，如果我们需要处理一些只有在主线程才能执行的动作那么需要切换到主线程。</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">- (void)tableNode:(ASTableNode *)tableNode willBeginBatchFetchWithContext:(ASBatchContext *)context  &#123;</span><br><span class="line">  <span class="regexp">//</span> 从远程网络或者本地获取数据</span><br><span class="line">  NSArray *newPhotos = [SomeSource getNewPhotos];</span><br><span class="line"></span><br><span class="line">  <span class="regexp">//</span> 将数据插入table</span><br><span class="line">  [self insertNewRowsInTableNode:newPhotos];</span><br><span class="line"></span><br><span class="line">  <span class="regexp">//</span> 决定是否还需要继续获取数据</span><br><span class="line">  _stillDataToFetch = ...;</span><br><span class="line"></span><br><span class="line">  <span class="regexp">//</span> 结束批量获取</span><br><span class="line">  [context completeBatchFetching:YES];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="3-图片修改Block"><a href="#3-图片修改Block" class="headerlink" title="3 图片修改Block"></a>3 图片修改Block</h6><p>imageModificationBlock 会在图片显示到ASImageNode之前对图片进行一些预处理，使用imageModificationBlock可以很方便得添加图片特效，添加圆角，边界或者其他处理。这是相当方便的功能。</p>
<h6 id="4-占位图"><a href="#4-占位图" class="headerlink" title="4 占位图"></a>4 占位图</h6><p>任何一个ASDisplayNode子类都可以重写-placeholderImage方法来提供一个占位图，这个占位图将会等到节点的内容完全加载后消失。要使用占位图，必须设置placeholderEnabled属性为YES,还可以设置placeholderFadeDuration 来指定占位图消失的过渡时间。同时还需要注意的是placeholderImage是在后台线程中调用的所以必须保证它是线程安全的，所以我们在加载图片的时候可以使用-[UIImage imageWithContentsOfFile:] 但是不能使用-[UIImage imageNamed:].因为后者是线程不安全的。</p>
<p>除了placeholderImage ASNetworkImageNode 节点也有对应的占位图，我们可以使用defaultImage来指定一个图片，当URL为空或者给定的URL加载失败的时候就会显示这个默认图。</p>
<h6 id="5-视图与图层之间的切换"><a href="#5-视图与图层之间的切换" class="headerlink" title="5 视图与图层之间的切换"></a>5 视图与图层之间的切换</h6><p>视图和图层是两个不同量级的组件，我们一般会在不需要触摸处理的情况下使用图层，但是在开发中我们还是会默认使用视图，因为需求不断改变的，现在不需要触摸处理不代表以后不需要触摸处理，一旦需要处理触摸事件的时候估计就傻眼了，因为在UIKit中从视图切换到图层是十分费时的，这种事情遇到过才知道这个过程的痛苦，如果使用Texture 就不存在这个问题，在Texture中将整个子树从视图转换为图层非常简单，只需要下面一行代码就可以搞定：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">rootNode.isLayerBacked</span> = <span class="literal">YES</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>

<h6 id="6-将子树光栅化"><a href="#6-将子树光栅化" class="headerlink" title="6 将子树光栅化"></a>6 将子树光栅化</h6><p>将整个视图层次结构转化为单个视图层可以提高性能，在Texture中值需要下面一行代码，就可以将从该点开始的整个节点层次结构呈现为一个层</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[rootNode enableSubtreeRasterization]</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/iOS-%E5%BC%80%E6%BA%90%E5%BA%93%E5%88%86%E6%9E%90/">iOS 开源库分析</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/iOS-开源库分析/">iOS 开源库分析</a>
  </div>

</div>



<div class="comments-count">
	
	  	<span></span>
		<a href="/2019/11/15/Texture-六-Texture-的其他用法/#comments" class="ds-thread-count comments-count-link" data-thread-key="2019/11/15/Texture-六-Texture-的其他用法/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/11/12/Texture-五-Texture源码解析/" title="Texture 五 Texture源码解析" itemprop="url">Texture 五 Texture源码解析</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Edgar" target="_blank" itemprop="author">Edgar</a>
		
  <p class="article-time">
    <time datetime="2019-11-12T03:27:59.000Z" itemprop="datePublished"> Published 2019-11-12</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h5 id="1-Texture-异步绘制源码分析"><a href="#1-Texture-异步绘制源码分析" class="headerlink" title="1. Texture 异步绘制源码分析"></a>1. Texture 异步绘制源码分析</h5><h6 id="1-1-整体流程图"><a href="#1-1-整体流程图" class="headerlink" title="1.1 整体流程图"></a>1.1 整体流程图</h6><p>在开始分析代码之前先给大家看下整个异步绘制的关键流程图，我把它划分成两条主线，第一条以setNeedDisplay为起点，将displayBlock返回的UImage在Group中转换为ASAsyncTransationOperation的value，另一条是以<br>RunLoop休眠前及退出RunLoop事件为触发点，将第一条主线产生的UImage通过ASAsyncTransationOperation 的 operationCompleteBlock 传到layer.content.</p>
<p>整个图可以分成两大块，第一块是displayBlock生成UImage,第二块是UImage怎么传到layer.content</p>
<p>围绕着这两条主线，两大块就可以捋清楚整个异步绘制的整个流程。</p>
<p><img src="/2019/11/12/Texture-%E4%BA%94-Texture%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/000023.png"></p>
<h6 id="1-2-触发异步绘制的入口点"><a href="#1-2-触发异步绘制的入口点" class="headerlink" title="1.2 触发异步绘制的入口点"></a>1.2 触发异步绘制的入口点</h6><p>Texture触发异步绘制的入口点主要有如下两个地方：</p>
<ul>
<li>UIView加入视图层级，这时候会调用willMoveToWindow</li>
<li>直接调用setNeedsDisplay方法</li>
</ul>
<p>其实最终都会归并到setNeedsDisplay</p>
<p>首先看下willMoveToWindow，这里会调用ASDisplayNode的__enterHierarchy</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">- (void)willMoveToWindow:(UIWindow *)newWindow &#123;</span><br><span class="line">  ASDisplayNode *<span class="keyword">node</span> <span class="title">= _asyncdisplaykit_node</span>; // Create strong <span class="keyword">reference</span> to weak ivar.</span><br><span class="line">  BOOL visible = (newWindow != nil);</span><br><span class="line">  if (visible &amp;&amp; !node.inHierarchy) &#123;</span><br><span class="line">    [<span class="keyword">node</span> <span class="title">__enterHierarchy</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在__enterHierarchy中会调用子节点的__enterHierarchy，并且根据具体情况创建placeHolderLayer添加到当前layer上</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)__enterHierarchy</span><br><span class="line">&#123;</span><br><span class="line">  ASDisplayNodeAssertMainThread();</span><br><span class="line">  <span class="comment">//.......</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (!_flags.isInHierarchy &amp;&amp; !_flags.visibilityNotificationsDisabled &amp;&amp; ![<span class="keyword">self</span> __selfOrParentHasVisibilityNotificationsDisabled]) &#123;</span><br><span class="line">      <span class="comment">//.......</span></span><br><span class="line">      <span class="comment">//更新状态</span></span><br><span class="line">      [<span class="keyword">self</span> willEnterHierarchy];</span><br><span class="line">      <span class="comment">//遍历节点调用节点的__enterHierarchy</span></span><br><span class="line">      <span class="keyword">for</span> (ASDisplayNode *subnode <span class="keyword">in</span> <span class="keyword">self</span>.subnodes) &#123;</span><br><span class="line">        [subnode __enterHierarchy];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//.......</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.contents == <span class="literal">nil</span>) &#123; <span class="comment">//如果内容为空</span></span><br><span class="line">      <span class="built_in">CALayer</span> *layer = <span class="keyword">self</span>.layer;</span><br><span class="line">      [layer setNeedsDisplay]; <span class="comment">//调用layer的setNeedsDisplay</span></span><br><span class="line">      <span class="comment">//如果有占位图则显示占位图</span></span><br><span class="line">      <span class="keyword">if</span> ([<span class="keyword">self</span> _locked_shouldHavePlaceholderLayer]) &#123;</span><br><span class="line">        [<span class="built_in">CATransaction</span> begin];</span><br><span class="line">        [<span class="built_in">CATransaction</span> setDisableActions:<span class="literal">YES</span>];</span><br><span class="line">        <span class="comment">//显示placeHolderLayer</span></span><br><span class="line">        [<span class="keyword">self</span> _locked_setupPlaceholderLayerIfNeeded];</span><br><span class="line">        _placeholderLayer.opacity = <span class="number">1.0</span>;</span><br><span class="line">        [<span class="built_in">CATransaction</span> commit];</span><br><span class="line">        <span class="comment">//将placehHolderLayer添加到layer</span></span><br><span class="line">        [layer addSublayer:_placeholderLayer];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  [<span class="keyword">self</span> didEnterHierarchy];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里比较关键的是setNeedsDisplay，在这里会创建后续需要的渲染队列，渲染队列是一个高优先级的串行异步队列，displayBlock就是这个队列中执行的，</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)setNeedsDisplay</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//...........</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//...........</span></span><br><span class="line">    <span class="keyword">if</span> (isRasterized == <span class="literal">NO</span> &amp;&amp; shouldApply == <span class="literal">NO</span>) &#123;</span><br><span class="line">      <span class="comment">// We can&#x27;t release the lock before applying to pending state, or it may be flushed before it can be applied.</span></span><br><span class="line">      [ASDisplayNodeGetPendingState(<span class="keyword">self</span>) setNeedsDisplay];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (isRasterized) &#123;</span><br><span class="line">    ASPerformBlockOnMainThread(^&#123;</span><br><span class="line">      <span class="comment">// The below operation must be performed on the main thread to ensure against an extremely rare deadlock, where a parent node</span></span><br><span class="line">      <span class="comment">// begins materializing the view / layer hierarchy (locking itself or a descendant) while this node walks up</span></span><br><span class="line">      <span class="comment">// the tree and requires locking that node to access .rasterizesSubtree.</span></span><br><span class="line">      <span class="comment">// For this reason, this method should be avoided when possible.  Use _hierarchyState &amp; ASHierarchyStateRasterized.</span></span><br><span class="line">      ASDisplayNodeAssertMainThread();</span><br><span class="line">      ASDisplayNode *rasterizedContainerNode = <span class="keyword">self</span>.supernode;</span><br><span class="line">      <span class="keyword">while</span> (rasterizedContainerNode) &#123;</span><br><span class="line">        <span class="keyword">if</span> (rasterizedContainerNode.rasterizesSubtree) &#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        rasterizedContainerNode = rasterizedContainerNode.supernode;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//将根节点标记为dirty</span></span><br><span class="line">      [rasterizedContainerNode setNeedsDisplay];</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (shouldApply) &#123;</span><br><span class="line">      <span class="comment">// If not rasterized, and the node is loaded (meaning we certainly have a view or layer), send a</span></span><br><span class="line">      <span class="comment">// message to the view/layer first. This is because __setNeedsDisplay calls as scheduleNodeForDisplay,</span></span><br><span class="line">      <span class="comment">// which may call -displayIfNeeded. We want to ensure the needsDisplay flag is set now, and then cleared.</span></span><br><span class="line">      [viewOrLayer setNeedsDisplay];</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="keyword">self</span> __setNeedsDisplay];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)__setNeedsDisplay</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">BOOL</span> shouldScheduleForDisplay = <span class="literal">NO</span>;</span><br><span class="line">  &#123;</span><br><span class="line">    MutexLocker l(__instanceLock__);</span><br><span class="line">    <span class="type">BOOL</span> nowDisplay = ASInterfaceStateIncludesDisplay(_interfaceState);</span><br><span class="line">    <span class="comment">// <span class="doctag">FIXME:</span> This should not need to recursively display, so create a non-recursive variant.</span></span><br><span class="line">    <span class="comment">// The semantics of setNeedsDisplay (as defined by CALayer behavior) are not recursive.</span></span><br><span class="line">    <span class="keyword">if</span> (_layer != <span class="literal">nil</span> &amp;&amp; !checkFlag(Synchronous) &amp;&amp; nowDisplay &amp;&amp; [<span class="keyword">self</span> _implementsDisplay]) &#123;</span><br><span class="line">      shouldScheduleForDisplay = <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (shouldScheduleForDisplay) &#123;</span><br><span class="line">    [ASDisplayNode scheduleNodeForRecursiveDisplay:<span class="keyword">self</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="type">void</span>)scheduleNodeForRecursiveDisplay:(ASDisplayNode *)node</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">  <span class="keyword">static</span> ASRunLoopQueue&lt;ASDisplayNode *&gt; *renderQueue;</span><br><span class="line">  <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">    renderQueue = [[ASRunLoopQueue&lt;ASDisplayNode *&gt; alloc] initWithRunLoop:<span class="built_in">CFRunLoopGetMain</span>()</span><br><span class="line">                                                             retainObjects:<span class="literal">NO</span></span><br><span class="line">                                                                   handler:^(ASDisplayNode * _Nonnull dequeuedItem, <span class="type">BOOL</span> isQueueDrained) &#123;</span><br><span class="line">      [dequeuedItem _recursivelyTriggerDisplayAndBlock:<span class="literal">NO</span>];</span><br><span class="line">      <span class="keyword">if</span> (isQueueDrained) &#123;</span><br><span class="line">        <span class="built_in">CFTimeInterval</span> timestamp = <span class="built_in">CACurrentMediaTime</span>();</span><br><span class="line">        [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:ASRenderingEngineDidDisplayScheduledNodesNotification</span><br><span class="line">                                                            object:<span class="literal">nil</span></span><br><span class="line">                                                          userInfo:@&#123;ASRenderingEngineDidDisplayNodesScheduledBeforeTimestamp: @(timestamp)&#125;];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  as_log_verbose(ASDisplayLog(), <span class="string">&quot;%s %@&quot;</span>, sel_getName(_cmd), node);</span><br><span class="line">  [renderQueue enqueue:node];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经过层层调用会调到_ASDisplayLayer的display方法</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">- (void)<span class="attribute">display</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">ASDisplayNodeAssertMainThread</span>();</span><br><span class="line">  <span class="selector-attr">[self _hackResetNeedsDisplay]</span>;</span><br><span class="line"></span><br><span class="line">  if (self.displaySuspended) &#123;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="selector-attr">[self display:self.displaysAsynchronously]</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>display方法中的实际工作就是调用 - (void)display:(BOOL)asynchronously，在- (void)display:(BOOL)asynchronously中将流程转到asyncDelegate中</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)display:(<span class="type">BOOL</span>)asynchronously</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">CGRectIsEmpty</span>(<span class="keyword">self</span>.bounds)) &#123;</span><br><span class="line">    _attemptedDisplayWhileZeroSized = <span class="literal">YES</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  [<span class="keyword">self</span>.asyncDelegate displayAsyncLayer:<span class="keyword">self</span> asynchronously:asynchronously];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="1-3-几个重要类之间的关系"><a href="#1-3-几个重要类之间的关系" class="headerlink" title="1.3 几个重要类之间的关系"></a>1.3 几个重要类之间的关系</h6><p>接下来就是比较重要的异步绘制的流程了，这里主要分两大块：</p>
<ol>
<li>displayBlock,completionBlock 指责是什么，怎么构建出来的，在什么时机调用？</li>
<li>整个异步绘制的流程是怎样的？</li>
</ol>
<p>对于第一点我们先留一个印象，displayBlock是用于生成UImage的，completionBlock是用于将displayBlock获得的UIImage设置到layer.content中。我们先把最大块的第二点给梳理清楚—整个异步绘制的流程。</p>
<p>在开始之前需先梳理下_ASAsyncTransactionGroup,ASAsyncTransactionContainer,_ASAsyncTransaction,ASAsyncTransactionQueue,ASAsyncTransactionOperation,DispatchEntry,Operation 这些类的关系，其实梳理了这些类的关系整个异步绘制流程就会显得十分清晰，建议大家可以结合文章开始时候给出的图来看。</p>
<ul>
<li>_ASAsyncTransactionGroup</li>
</ul>
<p>_ASAsyncTransactionGroup 用于管理ASAsyncTransactionContainer，ASAsyncTransactionContainer通过_ASAsyncTransactionGroup的addTransactionContainer方法添加到_ASAsyncTransactionGroup中，这里有个很重要的_ASAsyncTransactionGroup 就是mainTransactionGroup，在每个主线程RunLoop即将进入睡眠期间，以及由于RunLoop模式切换等原因导致的当前RunLoop退出的时候将添加mainTransactionGroup中ASAsyncTransactionContainer中的_ASAsyncTransaction 调用commit进行提交，这里先卖个关子，先不介绍commit到底是干啥的。我们先看看mainTransactionGroup：</p>
<figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">+ (<span class="variable">_ASAsyncTransactionGroup</span> *)mainTransactionGroup</span><br><span class="line">&#123;</span><br><span class="line">  ASDisplayNodeAssertMainThread();</span><br><span class="line">  static <span class="variable">_ASAsyncTransactionGroup</span> *mainTransactionGroup;</span><br><span class="line">  <span class="comment">//懒加载_ASAsyncTransactionGroup</span></span><br><span class="line">  <span class="keyword">if</span> (mainTransactionGroup == <span class="literal">nil</span>) &#123;</span><br><span class="line">    mainTransactionGroup = [[<span class="variable">_ASAsyncTransactionGroup</span> alloc] <span class="variable">_init</span>];</span><br><span class="line">    <span class="comment">//注册监听runloop结束或者进入休眠之前的通知</span></span><br><span class="line">    [mainTransactionGroup registerAsMainRunloopObserver];</span><br><span class="line">  &#125;</span><br><span class="line">  return mainTransactionGroup;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>mainTransactionGroup 是以懒加载的方式实例化出来，在创建的时候会注册监听kCFRunLoopBeforeWaiting和kCFRunLoopExit这两个通知，在RunLoop睡眠和退出之前，在主线程调用commit。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)registerAsMainRunloopObserver</span><br><span class="line">&#123;</span><br><span class="line">  ASDisplayNodeAssertMainThread();</span><br><span class="line">  <span class="keyword">static</span> <span class="built_in">CFRunLoopObserverRef</span> observer;</span><br><span class="line">  <span class="built_in">CFRunLoopRef</span> runLoop = <span class="built_in">CFRunLoopGetCurrent</span>();</span><br><span class="line">  <span class="built_in">CFOptionFlags</span> activities = (kCFRunLoopBeforeWaiting | <span class="comment">// before the run loop starts sleeping</span></span><br><span class="line">                              kCFRunLoopExit);          <span class="comment">// before exiting a runloop run</span></span><br><span class="line"></span><br><span class="line">  observer = <span class="built_in">CFRunLoopObserverCreateWithHandler</span>(<span class="literal">NULL</span>,        <span class="comment">// allocator</span></span><br><span class="line">                                                activities,  <span class="comment">// activities</span></span><br><span class="line">                                                <span class="literal">YES</span>,         <span class="comment">// repeats</span></span><br><span class="line">                                                INT_MAX,     <span class="comment">// order after CA transaction commits</span></span><br><span class="line">                                                ^(<span class="built_in">CFRunLoopObserverRef</span> observer, <span class="built_in">CFRunLoopActivity</span> activity) &#123;</span><br><span class="line">                                                  ASDisplayNodeCAssertMainThread();</span><br><span class="line">                                                  <span class="comment">//在进入runloop休眠之前或者切换runloop模式导致runloop退出的时候会调用commit</span></span><br><span class="line">                                                  [<span class="keyword">self</span> commit];</span><br><span class="line">                                                &#125;);</span><br><span class="line">  <span class="built_in">CFRunLoopAddObserver</span>(runLoop, observer, kCFRunLoopCommonModes);</span><br><span class="line">  <span class="built_in">CFRelease</span>(observer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在commit中遍历添加到mainTransactionGroup中的TransactionContainer，调用asyncdisplaykit_currentAsyncTransaction的commit方法提交，<br>提交后会将asyncdisplaykit_currentAsyncTransaction设置为nil。</p>
<figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line">- (void)commit</span><br><span class="line">&#123;</span><br><span class="line">  ASDisplayNodeAssertMainThread();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ([<span class="variable">_containers</span> <span class="built_in">count</span>]) &#123;</span><br><span class="line">    NSHashTable *containersToCommit = <span class="variable">_containers</span>;</span><br><span class="line">    <span class="variable">_containers</span> = [NSHashTable hashTableWithOptions:NSHashTableObjectPointerPersonality];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//遍历添加到mainTransactionContainer中的TransactionContainer，调用asyncdisplaykit_currentAsyncTransaction的commit方法</span></span><br><span class="line">    <span class="keyword">for</span> (id&lt;ASAsyncTransactionContainer&gt; container <span class="built_in">in</span> containersToCommit) &#123;</span><br><span class="line">      <span class="variable">_ASAsyncTransaction</span> *transaction = container.asyncdisplaykit_currentAsyncTransaction;</span><br><span class="line">      container.asyncdisplaykit_currentAsyncTransaction = <span class="literal">nil</span>;</span><br><span class="line">      [transaction commit];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>ASAsyncTransactionContainer</li>
</ul>
<p>ASAsyncTransactionContainer 是Transaction的容器，它其实是一个CALayer,最重要的有两个属性：</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line">asyncdisplaykit<span class="emphasis">_currentAsyncTransaction  当前的异步事务</span></span><br><span class="line"><span class="emphasis">asyncdisplaykit_</span>asyncLayerTransactions   当前layer的所有异步事务</span><br></pre></td></tr></table></figure>
<p>在 - (void)displayAsyncLayer:(_ASDisplayLayer *)asyncLayer asynchronously:(BOOL)asynchronously方法中会在整个层级树中找到最顶层的父节点，调用ASAsyncTransactionContainer的asyncdisplaykit_asyncTransaction方法为父节点创建asyncdisplaykit_asyncLayerTransactions以及asyncdisplaykit_currentAsyncTransaction，然后将当前TransactionContainer 添加到 mainTransactionGroup。代码如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="operator">-</span> (_ASAsyncTransaction <span class="operator">*</span>)asyncdisplaykit_asyncTransaction</span><br><span class="line">&#123;</span><br><span class="line">  _ASAsyncTransaction <span class="operator">*</span>transaction <span class="operator">=</span> <span class="keyword">self</span>.asyncdisplaykit_currentAsyncTransaction;</span><br><span class="line">  <span class="keyword">if</span> (transaction <span class="operator">==</span> <span class="literal">nil</span>) &#123;</span><br><span class="line">    <span class="comment">//如果当前的异步Transaction为空</span></span><br><span class="line">    <span class="type">NSMutableSet</span>&lt;_ASAsyncTransaction *&gt; <span class="operator">*</span>transactions <span class="operator">=</span> <span class="keyword">self</span>.asyncdisplaykit_asyncLayerTransactions;</span><br><span class="line">    <span class="keyword">if</span> (transactions <span class="operator">==</span> <span class="literal">nil</span>) &#123;</span><br><span class="line">      <span class="comment">//检查transactions是否为空，如果为空则创建一个并作为asyncdisplaykit_asyncLayerTransactions</span></span><br><span class="line">      transactions <span class="operator">=</span> <span class="type">ASCreatePointerBasedMutableSet</span>();</span><br><span class="line">      <span class="keyword">self</span>.asyncdisplaykit_asyncLayerTransactions <span class="operator">=</span> transactions;</span><br><span class="line">    &#125;</span><br><span class="line">    __weak <span class="type">CALayer</span> <span class="operator">*</span>weakSelf <span class="operator">=</span> <span class="keyword">self</span>;</span><br><span class="line">    transaction <span class="operator">=</span> [[_ASAsyncTransaction alloc] initWithCompletionBlock:<span class="operator">^</span>(_ASAsyncTransaction <span class="operator">*</span>completedTransaction, <span class="type">BOOL</span> cancelled) &#123;</span><br><span class="line">      __strong <span class="type">CALayer</span> <span class="operator">*</span><span class="keyword">self</span> <span class="operator">=</span> weakSelf;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">self</span> <span class="operator">==</span> <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      [<span class="keyword">self</span>.asyncdisplaykit_asyncLayerTransactions removeObject:completedTransaction];</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">self</span>.asyncdisplaykit_asyncLayerTransactions.count <span class="operator">==</span> <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Reclaim object memory.</span></span><br><span class="line">        <span class="keyword">self</span>.asyncdisplaykit_asyncLayerTransactions <span class="operator">=</span> <span class="literal">nil</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      [<span class="keyword">self</span> asyncdisplaykit_asyncTransactionContainerDidCompleteTransaction:completedTransaction];</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将transaction添加到transactions进行管理</span></span><br><span class="line">    [transactions addObject:transaction];</span><br><span class="line">    <span class="keyword">self</span>.asyncdisplaykit_currentAsyncTransaction <span class="operator">=</span> transaction;</span><br><span class="line">    [<span class="keyword">self</span> asyncdisplaykit_asyncTransactionContainerWillBeginTransaction:transaction];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//ASAsyncTransactionContainer----&gt; transations ----&gt; transaction</span></span><br><span class="line">  <span class="comment">//将当前TransactionContainer 添加到 mainTransactionGroup，在runloop结束或者休眠之前会调用transaction的commit</span></span><br><span class="line">  [_ASAsyncTransactionGroup.mainTransactionGroup addTransactionContainer:<span class="keyword">self</span>];</span><br><span class="line">  <span class="keyword">return</span> transaction;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>_ASAsyncTransaction</li>
</ul>
<p>_ASAsyncTransaction 是啥？源码中给出了如下的描述：</p>
<blockquote>
<p>@summary ASAsyncTransaction provides lightweight transaction semantics for asynchronous operations.<br>  ASAsyncTransaction 为异步操作提供了轻量级的事务片段</p>
</blockquote>
<blockquote>
<p>@desc ASAsyncTransaction provides the following properties:</p>
<ul>
<li>Transactions group an arbitrary number of operations, each consisting of an execution block and a completion block.<br>  Transactions 将任意多个operations打包在一起，每个Transaction包含一个executionBlok以及一个completionblock</li>
<li>The execution block returns a single object that will be passed to the completion block.<br>  execution block将会生成一个对象，然后将这个对象传递给completionblock</li>
<li>Execution blocks added to a transaction will run in parallel on the global background dispatch queues;<br> the completion blocks are dispatched to the callback queue.<br> 添加到transaction的execution blocks将会在后台线程中并行运行，而completion block将会在回调队列中执行。</li>
<li>Every operation completion block is guaranteed to execute, regardless of cancelation.<br> However, execution blocks may be skipped if the transaction is canceled.<br> 只要transaction不被取消每个completion block都会确保执行。 </li>
<li>Operation completion blocks are always executed in the order they were added to the transaction, assuming the<br> callback queue is serial of course.<br> completion总是会按照加入到transaction的顺序执行。</li>
</ul>
</blockquote>
<p>应用到当前场景，简单得说就是，每个_ASAsyncTransaction包裹着display Block和 complage Block,display block将会在后台并行执行，然后将结果传递给complete block,complete block会按照顺序在主线程中顺序执行。</p>
<figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line">@implementation <span class="variable">_ASAsyncTransaction</span></span><br><span class="line">&#123;</span><br><span class="line">  ASAsyncTransactionQueue::<span class="built_in">Group</span> *<span class="variable">_group</span>;</span><br><span class="line">  NSMutableArray&lt;ASAsyncTransactionOperation *&gt; *<span class="variable">_operations</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>_ASAsyncTransaction 有两个主要的私有成员属性，_group和_operations。这就会扯到ASAsyncTransactionQueue，ASAsyncTransactionOperation，Operation，DispatchEntry</p>
<ul>
<li>ASAsyncTransactionOperation</li>
</ul>
<p>首先看下_operations 它其实是一个ASAsyncTransactionOperation数组，ASAsyncTransactionOperation类的结构如下，</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@interface</span> <span class="attribute">ASAsyncTransactionOperation </span>: NSObject</span><br><span class="line"></span><br><span class="line">- (instancetype)<span class="attribute">initWithOperationCompletionBlock</span>:(asyncdisplaykit_async_transaction_operation_completion_block_t)operationCompletionBlock;</span><br><span class="line"></span><br><span class="line"><span class="variable">@property</span> (nonatomic) asyncdisplaykit_async_transaction_operation_completion_block_t operationCompletionBlock;</span><br><span class="line"><span class="variable">@property</span> id value; <span class="comment">// set on bg queue by the operation block</span></span><br><span class="line"></span><br><span class="line"><span class="variable">@end</span></span><br></pre></td></tr></table></figure>
<p>这里比较关键的是operationCompletionBlock和value，operationCompletionBlock是最前面提到的complete block 用于将display block 返回的UIImage传递给layer.content. </p>
<p>value 就是 display block 返回的UIImage，这里会在后台线程中生成UIImage，然后将其保存到value中，这个后面会介绍。最关键的是callAndReleaseCompletionBlock这个方法，CompletionBlock就是在这个方法中调用的，至于callAndReleaseCompletionBlock什么时候调用先留在后面。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">- (void)callAndReleaseCompletionBlock:(BOOL)canceled;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="constructor">ASDisplayNodeAssertMainThread()</span>;</span><br><span class="line">  <span class="keyword">if</span> (_operationCompletionBlock) &#123;</span><br><span class="line">    <span class="comment">//调用CompletionBlock</span></span><br><span class="line">    <span class="constructor">_operationCompletionBlock(<span class="params">self</span>.<span class="params">value</span>, <span class="params">canceled</span>)</span>;</span><br><span class="line">    _operationCompletionBlock = nil;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总而言之ASAsyncTransactionOperation封装着complete block,和一个存储display block执行结果的value值，并且在某个时期调用complete block</p>
<ul>
<li>ASAsyncTransactionQueue</li>
</ul>
<p>ASAsyncTransactionQueue 其实是一个并发数受限的轻量级operation队列，它包含了Group，Operation，DispatchEntry 三大对象。</p>
<p>Group 有点类似于 dispatch_group_t，它比较重要的有两个方法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在指定队列中调度block</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">schedule</span><span class="params">(NSInteger priority, <span class="type">dispatch_queue_t</span> queue, <span class="type">dispatch_block_t</span> block)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有先前调度的block都完成的时候发送的通知block</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">notify</span><span class="params">(<span class="type">dispatch_queue_t</span> queue, <span class="type">dispatch_block_t</span> block)</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>schedule 方法中会创建一个Operation然后通过DispatchEntry pushOperation添加到DispatchEntry，DispatchEntry中的线程数是受控制的，它最多是当前处理器内核数的两倍，如果还有线程数可以用，那么将会从DispatchEntry中按照优先级pop出一个operation执行它的block。要注意这里的block不是display block也不是complete block。而是执行display block后将值存储到operation.value中。</p>
<figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line">void ASAsyncTransactionQueue::GroupImpl::schedule(NSInteger <span class="built_in">priority</span>, dispatch_queue_t queue, dispatch_block_t block)</span><br><span class="line">&#123;</span><br><span class="line">  ASAsyncTransactionQueue &amp;q = <span class="variable">_queue</span>;</span><br><span class="line">  std::lock_guard&lt;std::mutex&gt; l(q.<span class="variable">_mutex</span>);</span><br><span class="line">  </span><br><span class="line">  DispatchEntry &amp;entry = q.<span class="variable">_entries</span>[queue];</span><br><span class="line">  </span><br><span class="line">  Operation operation;</span><br><span class="line">  operation.<span class="variable">_block</span> = block;</span><br><span class="line">  operation.<span class="variable">_group</span> = this;</span><br><span class="line">  operation.<span class="variable">_priority</span> = <span class="built_in">priority</span>;</span><br><span class="line">  entry.pushOperation(operation);</span><br><span class="line">  </span><br><span class="line">  ++<span class="variable">_pendingOperations</span>; <span class="comment">// enter group</span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#if ASDISPLAYNODE_DELAY_DISPLAY</span></span><br><span class="line">  NSUInteger maxThreads = <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span> </span></span><br><span class="line">  NSUInteger maxThreads = [NSProcessInfo processInfo].activeProcessorCount * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Bit questionable maybe - we can give main thread more CPU time during tracking.</span></span><br><span class="line">  <span class="keyword">if</span> ([[NSRunLoop mainRunLoop].currentMode isEqualToString:UITrackingRunLoopMode])</span><br><span class="line">    --maxThreads;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (entry.<span class="variable">_threadCount</span> &lt; maxThreads) &#123; <span class="comment">// we need to spawn another thread</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// first thread will take operations in queue order (regardless of priority), other threads will respect priority</span></span><br><span class="line">    bool respectPriority = entry.<span class="variable">_threadCount</span> &gt; <span class="number">0</span>;</span><br><span class="line">    ++entry.<span class="variable">_threadCount</span>;</span><br><span class="line">    </span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">      std::unique_lock&lt;std::mutex&gt; <span class="built_in">lock</span>(q.<span class="variable">_mutex</span>);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// go until there are no more pending operations</span></span><br><span class="line">      <span class="keyword">while</span> (!entry.<span class="variable">_operationQueue</span>.empty()) &#123;</span><br><span class="line">        Operation operation = entry.popNextOperation(respectPriority);</span><br><span class="line">        <span class="built_in">lock</span>.unlock();</span><br><span class="line">        <span class="keyword">if</span> (operation.<span class="variable">_block</span>) &#123;</span><br><span class="line">          operation.<span class="variable">_block</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        operation.<span class="variable">_group</span>-&gt;leave();</span><br><span class="line">        operation.<span class="variable">_block</span> = <span class="literal">nil</span>; <span class="comment">// the block must be freed while mutex is unlocked</span></span><br><span class="line">        <span class="built_in">lock</span>.<span class="built_in">lock</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      --entry.<span class="variable">_threadCount</span>;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (entry.<span class="variable">_threadCount</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        NSCAssert(entry.<span class="variable">_operationQueue</span>.empty() || entry.<span class="variable">_operationPriorityMap</span>.empty(), @<span class="string">&quot;No working threads but operations are still scheduled&quot;</span>); <span class="comment">// this shouldn&#x27;t happen</span></span><br><span class="line">        q.<span class="variable">_entries</span>.erase(queue);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>notify 方法是将block和queue封装成GroupNotify后添加到_notifyList，我们看到schedule方法中会调用_group-&gt;leave()</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> ASAsyncTransactionQueue::GroupImpl::<span class="built_in">notify</span>(<span class="type">dispatch_queue_t</span> queue, <span class="type">dispatch_block_t</span> block)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">l</span><span class="params">(_queue._mutex)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (_pendingOperations == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, block);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    GroupNotify notify;</span><br><span class="line">    notify._block = block;</span><br><span class="line">    notify._queue = queue;</span><br><span class="line">    _notifyList.<span class="built_in">push_back</span>(notify);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在leave中会将_notifyList取出来，将GroupNotify的block放到queue中执行。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> ASAsyncTransactionQueue::GroupImpl::<span class="built_in">leave</span>()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">l</span><span class="params">(_queue._mutex)</span></span>;</span><br><span class="line">  --_pendingOperations;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (_pendingOperations == <span class="number">0</span>) &#123;</span><br><span class="line">    std::list&lt;GroupNotify&gt; notifyList;</span><br><span class="line">    _notifyList.<span class="built_in">swap</span>(notifyList);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (GroupNotify &amp; notify : notifyList) &#123;</span><br><span class="line">      <span class="built_in">dispatch_async</span>(notify._queue, notify._block);</span><br><span class="line">    &#125;</span><br><span class="line">    _condition.<span class="built_in">notify_one</span>();</span><br><span class="line">    <span class="keyword">if</span> (_releaseCalled) &#123;</span><br><span class="line">      <span class="keyword">delete</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么这里就有两个问题，notify什么时候被调用，_notifyList放的是什么东西。这个也放在流程中讲，这里只需要了解，Group 实际上是一个线程数受控的类似于dispatch_group_t的任务队列，每次调用shedule的时候，会将block封装成一个Operation，然后添加到DispatchEntry，然后在DispatchEntry线程数没达到最大值的时候，会从DispatchEntry中取出来一个执行它的block，然后在leave中，将_notifyList运行完。</p>
<ul>
<li>DispatchEntry &amp;&amp; Operation</li>
</ul>
<p>DispatchEntry 放着两个东西，一个是操作列表_operationQueue，一个是以优先级为key，操作列表为value的map _operationPriorityMap。在添加的时候会同时往这两个上面同时添加。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">DispatchEntry</span> <span class="comment">// entry for each dispatch queue</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">typedef</span> std::list&lt;Operation&gt; OperationQueue;</span><br><span class="line">  <span class="keyword">typedef</span> std::list&lt;OperationQueue::iterator&gt; OperationIteratorList; <span class="comment">// each item points to operation queue</span></span><br><span class="line">  <span class="keyword">typedef</span> std::map&lt;NSInteger, OperationIteratorList&gt; OperationPriorityMap; <span class="comment">// sorted by priority</span></span><br><span class="line"></span><br><span class="line">  OperationQueue _operationQueue;</span><br><span class="line">  OperationPriorityMap _operationPriorityMap;</span><br><span class="line">  <span class="type">int</span> _threadCount;</span><br><span class="line">    </span><br><span class="line">  <span class="function">Operation <span class="title">popNextOperation</span><span class="params">(<span class="type">bool</span> respectPriority)</span></span>;  <span class="comment">// assumes locked mutex</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">pushOperation</span><span class="params">(Operation operation)</span></span>;           <span class="comment">// assumes locked mutex</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Operation 就是个结构体封装着block group和优先级</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">struct Operation</span><br><span class="line">&#123;</span><br><span class="line">    dispatch_block_t _block<span class="comment">;</span></span><br><span class="line">    GroupImpl *_group<span class="comment">;</span></span><br><span class="line">    NSInteger _priority<span class="comment">;</span></span><br><span class="line">&#125;<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>稍稍总结下，我们会将一个block（非display block）包装在Operation 然后添加到DispatchEntry，中的OperationQueue和OperationPriorityMap，在Group的schedule方法中从DispatchEntry按照优先级取出后，在后台线程中执行block，并在执行完后执行leave方法。</p>
<p>这里有几个预留的问题下面要介绍的：</p>
<ol>
<li>Operation 中的block到底是啥</li>
<li>Group的notify操作是干啥的，什么时候调用，leave 方法中的_notifyList放的是什么东西</li>
</ol>
<h6 id="1-4-异步绘制流程"><a href="#1-4-异步绘制流程" class="headerlink" title="1.4 异步绘制流程"></a>1.4 异步绘制流程</h6><p>有了上面的铺垫这里可以开始讲整个异步绘制流程了，我们先看下：- (void)displayAsyncLayer:(_ASDisplayLayer *)asyncLayer asynchronously:(BOOL)asynchronously</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)displayAsyncLayer:(_ASDisplayLayer *)asyncLayer asynchronously:(<span class="type">BOOL</span>)asynchronously</span><br><span class="line">&#123;</span><br><span class="line">  ASDisplayNodeAssertMainThread();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//......</span></span><br><span class="line">  <span class="comment">///1. CancelBlock  displayBlock  completetionBlock 初始化</span></span><br><span class="line">  <span class="comment">//创建CancelBlock</span></span><br><span class="line">  asdisplaynode_iscancelled_block_t isCancelledBlock = <span class="literal">nil</span>;</span><br><span class="line">  <span class="keyword">if</span> (asynchronously) &#123;</span><br><span class="line">    uint displaySentinelValue = ++_displaySentinel;</span><br><span class="line">    __<span class="keyword">weak</span> ASDisplayNode *weakSelf = <span class="keyword">self</span>;</span><br><span class="line">    isCancelledBlock = ^<span class="type">BOOL</span>&#123;</span><br><span class="line">      __<span class="keyword">strong</span> ASDisplayNode *<span class="keyword">self</span> = weakSelf;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">self</span> == <span class="literal">nil</span> || (displaySentinelValue != <span class="keyword">self</span>-&gt;_displaySentinel.load());</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    isCancelledBlock = ^<span class="type">BOOL</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建displayBlock，这里会调用delegate display 或者draw方法来获取到UIImage内容</span></span><br><span class="line">  asyncdisplaykit_async_transaction_operation_block_t displayBlock = [<span class="keyword">self</span> _displayBlockWithAsynchronous:asynchronously</span><br><span class="line">                                                                                        isCancelledBlock:isCancelledBlock</span><br><span class="line">                                                                                             rasterizing:<span class="literal">NO</span>];</span><br><span class="line">  <span class="comment">//.........</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建completionBlock：这个block会在当前异步事务完成后并完成渲染后在主线程被调用，或者在同步的情况下（asynchronously == NO）直接调用</span></span><br><span class="line">  asyncdisplaykit_async_transaction_operation_completion_block_t completionBlock = ^(<span class="type">id</span>&lt;<span class="built_in">NSObject</span>&gt; value, <span class="type">BOOL</span> canceled)&#123;</span><br><span class="line">    ASDisplayNodeCAssertMainThread();</span><br><span class="line">    <span class="keyword">if</span> (!canceled &amp;&amp; !isCancelledBlock()) &#123; <span class="comment">//是否被取消，同步的情况下isCancelledBlock始终为NO</span></span><br><span class="line">      <span class="built_in">UIImage</span> *image = (<span class="built_in">UIImage</span> *)value; <span class="comment">//value放置的是image</span></span><br><span class="line">      <span class="type">BOOL</span> stretchable = (<span class="literal">NO</span> == <span class="built_in">UIEdgeInsetsEqualToEdgeInsets</span>(image.capInsets, <span class="built_in">UIEdgeInsetsZero</span>)); <span class="comment">//图像是否是可拉伸的</span></span><br><span class="line">      <span class="keyword">if</span> (stretchable) &#123;</span><br><span class="line">        ASDisplayNodeSetResizableContents(layer, image);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//不可拉伸的情况下直接将内容作为contents</span></span><br><span class="line">        layer.contentsScale = <span class="keyword">self</span>.contentsScale;</span><br><span class="line">        layer.contents = (<span class="type">id</span>)image.CGImage;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//............</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//............</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (asynchronously) &#123;</span><br><span class="line">    <span class="comment">// 异步渲染操作被包含在transaction中，transaction可以允许并行处理最终将结果以同步的方式应用到layer的contents属性中</span></span><br><span class="line">    <span class="comment">// Async rendering operations are contained by a transaction, which allows them to proceed and concurrently</span></span><br><span class="line">    <span class="comment">// while synchronizing the final application of the results to the layer&#x27;s contents property (completionBlock).</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 我们先查看我们是否可以将自己添加到父类的transaction容器中</span></span><br><span class="line">    <span class="comment">// First, look to see if we are expected to join a parent&#x27;s transaction container.</span></span><br><span class="line">    <span class="built_in">CALayer</span> *containerLayer = layer.asyncdisplaykit_parentTransactionContainer ? : layer;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果transaction没有存在那么这里将会实例化并将它添加到_ASAsyncTransactionGroup，它会在runloop结束或者即将进入休眠之前提交出去</span></span><br><span class="line">    <span class="comment">// In the case that a transaction does not yet exist (such as for an individual node outside of a container),</span></span><br><span class="line">    <span class="comment">// this call will allocate the transaction and add it to _ASAsyncTransactionGroup.</span></span><br><span class="line">    <span class="comment">// It will automatically commit the transaction at the end of the runloop.</span></span><br><span class="line">    _ASAsyncTransaction *transaction = containerLayer.asyncdisplaykit_asyncTransaction;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3. 将displayBlock添加到transaction，transaction将会立即启动执行</span></span><br><span class="line">    <span class="comment">// Adding this displayBlock operation to the transaction will start it IMMEDIATELY.</span></span><br><span class="line">    <span class="comment">// The only function of the transaction commit is to gate the calling of the completionBlock.</span></span><br><span class="line">    [transaction addOperationWithBlock:displayBlock priority:<span class="keyword">self</span>.drawingPriority queue:[_ASDisplayLayer displayQueue] completion:completionBlock];</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//同步的情况下直接通过displayBlock生成contents，并通过completionBlock设置到layer.content</span></span><br><span class="line">    <span class="built_in">UIImage</span> *contents = (<span class="built_in">UIImage</span> *)displayBlock();</span><br><span class="line">    completionBlock(contents, <span class="literal">NO</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>上面代码有三个关键点：</p>
<ol>
<li>创建CancelBlock  displayBlock  completetionBlock 这里先不展开</li>
<li>顺着层级树找到最顶层的节点作为TransationContainer,并根据实际情况创建它的asyncdisplaykit_currentAsyncTransaction。并将TransationContainer添加到mainTransactionGroup。</li>
<li>调用addOperationWithBlock 往asyncdisplaykit_currentAsyncTransaction中添加display Block和complete Block.</li>
</ol>
<figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">- (void)addOperationWithBlock:(asyncdisplaykit_async_transaction_operation_block_t)<span class="built_in">block</span></span><br><span class="line">                     priority:(NSInteger)priority</span><br><span class="line">                        <span class="keyword">queue</span>:(dispatch_queue_t)<span class="keyword">queue</span></span><br><span class="line">                   completion:(asyncdisplaykit_async_transaction_operation_completion_block_t)completion</span><br><span class="line">&#123;</span><br><span class="line">  ASDisplayNodeAssertMainThread();</span><br><span class="line">  //...........</span><br><span class="line">  //创建一个TransationOperation将它添加到_operations，并且在displayQueue中执行displayBlock() 并将输出的UIImage保存到value中</span><br><span class="line">  ASAsyncTransactionOperation *operation = [[ASAsyncTransactionOperation alloc] initWithOperationCompletionBlock:completion];</span><br><span class="line">  [_operations addObject:operation];</span><br><span class="line">  _group-&gt;schedule(priority, <span class="keyword">queue</span>, ^&#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">      if (<span class="literal">self</span>.<span class="keyword">state</span> != ASAsyncTransactionStateCanceled) &#123;</span><br><span class="line">        operation.value = <span class="built_in">block</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>addOperationWithBlock 完成两个工作：</p>
<ol>
<li>将complete block 封装到ASAsyncTransactionOperation，并添加到_operations中</li>
<li>调用group 的 schedule，这里就可以解答第一个问题，schedule 中的block其实是如下的一个block,用于执行displayBlock后将输出的UIImage保存到value中</li>
</ol>
<figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">^&#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">      if (<span class="literal">self</span>.<span class="keyword">state</span> != ASAsyncTransactionStateCanceled) &#123;</span><br><span class="line">        operation.value = <span class="built_in">block</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>还有第二个问题：<br>Group的notify操作是干啥的，什么时候调用，leave 方法中的_notifyList放的是什么东西</p>
<p>ASAsyncTransaction的commit方法中</p>
<figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">- (void)commit</span><br><span class="line">&#123;</span><br><span class="line">  ASDisplayNodeAssertMainThread();</span><br><span class="line">  NSAssert(<span class="literal">self</span>.<span class="keyword">state</span> == ASAsyncTransactionStateOpen, @<span class="string">&quot;You cannot double-commit a transaction&quot;</span>);</span><br><span class="line">  <span class="literal">self</span>.<span class="keyword">state</span> = ASAsyncTransactionStateCommitted;</span><br><span class="line">  </span><br><span class="line">  if ([_operations count] == <span class="number">0</span>) &#123;</span><br><span class="line">    // Fast path: if a transaction was opened, but <span class="keyword">no</span> operations were added, execute completion <span class="built_in">block</span> synchronously.</span><br><span class="line">    if (_completionBlock) &#123;</span><br><span class="line">      _completionBlock(<span class="literal">self</span>, NO);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    NSAssert(_group != NULL, @<span class="string">&quot;If there are operations, dispatch group should have been created&quot;</span>);</span><br><span class="line">    //通过_group发出通知将后台得到的UImage通过completeBlock</span><br><span class="line">    _group-&gt;notify(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">      [<span class="literal">self</span> completeTransaction];</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)completeTransaction</span><br><span class="line">&#123;</span><br><span class="line">  ASDisplayNodeAssertMainThread();</span><br><span class="line">  ASAsyncTransactionState <span class="keyword">state</span> = <span class="literal">self</span>.<span class="keyword">state</span>;</span><br><span class="line">  if (<span class="keyword">state</span> != ASAsyncTransactionStateComplete) &#123;</span><br><span class="line">    BOOL isCanceled = (<span class="keyword">state</span> == ASAsyncTransactionStateCanceled);</span><br><span class="line">    //遍历每个ASAsyncTransactionOperation 让后台生成的image通过ComplateBlock设置到layer.content上</span><br><span class="line">    <span class="keyword">for</span> (ASAsyncTransactionOperation *operation <span class="keyword">in</span> _operations) &#123;</span><br><span class="line">      [operation callAndReleaseCompletionBlock:isCanceled];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // Always <span class="built_in">set</span> <span class="keyword">state</span> <span class="keyword">to</span> Complete, even if we were cancelled, <span class="keyword">to</span> <span class="built_in">block</span> <span class="literal">any</span> extraneous</span><br><span class="line">    // calls <span class="keyword">to</span> this method that may have been scheduled <span class="keyword">for</span> the next runloop</span><br><span class="line">    // (e.g. if we needed <span class="keyword">to</span> force one <span class="keyword">in</span> this runloop with -waitUntilComplete, but another was already scheduled)</span><br><span class="line">    <span class="literal">self</span>.<span class="keyword">state</span> = ASAsyncTransactionStateComplete;</span><br><span class="line"></span><br><span class="line">    //通过回调通知当前transation结束</span><br><span class="line">    if (_completionBlock) &#123;</span><br><span class="line">      _completionBlock(<span class="literal">self</span>, isCanceled);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们知道commit是在Runloop进入休眠状态或者退出之前调用的，这里调用了group的notify方法，将completeTransaction 添加到_notifyList，在group shedule方法中执行block后将display block产生的UIImage 放到value中，然后调用leave方法，将_notifyList中的block放到queue中执行，也就是在主线程中执行complete block，将value传出来最终设置到layer.content中。</p>
<p>总结一下：</p>
<ol>
<li><p>首先，在RunLoop进入休眠状态或者退出的时候通知到mainTransationGroup,mainTransationGroup 在commit方法中，遍历加入到mainTransationGroup中的每个TransationContainer，在TransationContainer中会对currentTransation调用一次commit方法。从而触发Group的notify方法，将在主线程执行的block操作放到Group的_notifyList中，这个bock操作就是将displayBlock生成的对象通过completeBlock传递给layer.content.</p>
</li>
<li><p>在displayAsyncLayer方法中将会创建displayBlock 和 complateBlock，然后封装到ASAsyncTransationOperation,并将它添加到当前页面的TransationContainer中的currentTransation中。在currentTransation中将diaplayBlock获取UIImage并存储到ASTransationOperation value中的操作封装成block，在Group中的DispathEntry中执行。执行完block后会调用Group leave，执行_notifyList中的任务，将ASTransationOperation value中的 UIImage通过complete Block设置到layer.content.</p>
</li>
</ol>
<h6 id="1-5-DisplayBlock-amp-amp-Complete-Block"><a href="#1-5-DisplayBlock-amp-amp-Complete-Block" class="headerlink" title="1.5 DisplayBlock  &amp;&amp; Complete Block"></a>1.5 DisplayBlock  &amp;&amp; Complete Block</h6><ol>
<li>Complete Block其实没多少东西可以介绍的，它的逻辑十分简单：就是将传入的value也就是displayBlock生成的UIImage设置到layer.content</li>
</ol>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">asyncdisplaykit_async_transaction_operation_completion_block_t completionBlock = ^(<span class="type">id</span>&lt;<span class="built_in">NSObject</span>&gt; value, <span class="type">BOOL</span> canceled)&#123;</span><br><span class="line">  ASDisplayNodeCAssertMainThread();</span><br><span class="line">  <span class="keyword">if</span> (!canceled &amp;&amp; !isCancelledBlock()) &#123; <span class="comment">//是否被取消，同步的情况下isCancelledBlock始终为NO</span></span><br><span class="line">    <span class="built_in">UIImage</span> *image = (<span class="built_in">UIImage</span> *)value; <span class="comment">//value放置的是image</span></span><br><span class="line">    <span class="type">BOOL</span> stretchable = (<span class="literal">NO</span> == <span class="built_in">UIEdgeInsetsEqualToEdgeInsets</span>(image.capInsets, <span class="built_in">UIEdgeInsetsZero</span>)); <span class="comment">//图像是否是可拉伸的</span></span><br><span class="line">    <span class="keyword">if</span> (stretchable) &#123;</span><br><span class="line">      ASDisplayNodeSetResizableContents(layer, image);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//不可拉伸的情况下直接将内容作为contents</span></span><br><span class="line">      layer.contentsScale = <span class="keyword">self</span>.contentsScale;</span><br><span class="line">      layer.contents = (<span class="type">id</span>)image.CGImage;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//........</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>DisplayBlock</li>
</ol>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (asyncdisplaykit_async_transaction_operation_block_t)_displayBlockWithAsynchronous:(<span class="type">BOOL</span>)asynchronous</span><br><span class="line">                                                                    isCancelledBlock:(asdisplaynode_iscancelled_block_t)isCancelledBlock</span><br><span class="line">                                                                         rasterizing:(<span class="type">BOOL</span>)rasterizing</span><br><span class="line">&#123;</span><br><span class="line">  ASDisplayNodeAssertMainThread();</span><br><span class="line">  asyncdisplaykit_async_transaction_operation_block_t displayBlock = <span class="literal">nil</span>;</span><br><span class="line">  ASDisplayNodeFlags flags;</span><br><span class="line">  </span><br><span class="line">  __instanceLock__.lock();</span><br><span class="line"></span><br><span class="line">  flags = _flags;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// We always create a graphics context, unless a -display method is used, OR if we are a subnode drawing into a rasterized parent.</span></span><br><span class="line">  <span class="comment">//如果没有display方法或者正在将子节点绘制到栅格化的父类上的时候需要创建Context</span></span><br><span class="line">  <span class="type">BOOL</span> shouldCreateGraphicsContext = (flags.implementsImageDisplay == <span class="literal">NO</span> &amp;&amp; rasterizing == <span class="literal">NO</span>);</span><br><span class="line">  <span class="comment">//子节点时候需要栅格化</span></span><br><span class="line">  <span class="type">BOOL</span> shouldBeginRasterizing = (rasterizing == <span class="literal">NO</span> &amp;&amp; flags.rasterizesSubtree);</span><br><span class="line">  <span class="comment">//是否实现了display方法</span></span><br><span class="line">  <span class="type">BOOL</span> usesImageDisplay = flags.implementsImageDisplay;</span><br><span class="line">  <span class="comment">//是否实现了drawRect方法</span></span><br><span class="line">  <span class="type">BOOL</span> usesDrawRect = flags.implementsDrawRect;</span><br><span class="line">  <span class="comment">//如果没有实现display/drawRect方法并且子节点不需要栅格化直接返回</span></span><br><span class="line">  <span class="keyword">if</span> (usesImageDisplay == <span class="literal">NO</span> &amp;&amp; usesDrawRect == <span class="literal">NO</span> &amp;&amp; shouldBeginRasterizing == <span class="literal">NO</span>) &#123;</span><br><span class="line">    <span class="comment">// Early exit before requesting more expensive properties like bounds and opaque from the layer.</span></span><br><span class="line">    __instanceLock__.unlock();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="type">BOOL</span> opaque = <span class="keyword">self</span>.opaque;</span><br><span class="line">  <span class="built_in">CGRect</span> bounds = <span class="keyword">self</span>.bounds;</span><br><span class="line">  <span class="built_in">UIColor</span> *backgroundColor = <span class="keyword">self</span>.backgroundColor;</span><br><span class="line">  <span class="built_in">CGColorRef</span> borderColor = <span class="keyword">self</span>.borderColor;</span><br><span class="line">  <span class="built_in">CGFloat</span> borderWidth = <span class="keyword">self</span>.borderWidth;</span><br><span class="line">  <span class="built_in">CGFloat</span> contentsScaleForDisplay = _contentsScaleForDisplay;</span><br><span class="line">    </span><br><span class="line">  __instanceLock__.unlock();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Capture drawParameters from delegate on main thread, if this node is displaying itself rather than recursively rasterizing.</span></span><br><span class="line">  <span class="type">id</span> drawParameters = (shouldBeginRasterizing == <span class="literal">NO</span> ? [<span class="keyword">self</span> drawParameters] : <span class="literal">nil</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Only the -display methods should be called if we can&#x27;t size the graphics buffer to use.</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">CGRectIsEmpty</span>(bounds) &amp;&amp; (shouldBeginRasterizing || shouldCreateGraphicsContext)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//..........</span></span><br><span class="line">  <span class="comment">//是否栅格化</span></span><br><span class="line">  <span class="keyword">if</span> (shouldBeginRasterizing) &#123;</span><br><span class="line">    <span class="comment">// Collect displayBlocks for all descendants.</span></span><br><span class="line">    <span class="comment">// 用于放置子节点的displayBlock在父节点的displayBlock中直接遍历各个子节点的displayBlock</span></span><br><span class="line">    <span class="built_in">NSMutableArray</span> *displayBlocks = [[<span class="built_in">NSMutableArray</span> alloc] init];</span><br><span class="line">    [<span class="keyword">self</span> _recursivelyRasterizeSelfAndSublayersWithIsCancelledBlock:isCancelledBlock displayBlocks:displayBlocks];</span><br><span class="line">    CHECK_CANCELLED_AND_RETURN_NIL();</span><br><span class="line"></span><br><span class="line">    opaque = opaque &amp;&amp; <span class="built_in">CGColorGetAlpha</span>(backgroundColor.CGColor) == <span class="number">1.0</span>f;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里会将整个container的所有子节点的displayBlock打包给displayBlock，在执行container的displayBlock后会调用这些子节点的displayBlock将其绘制到container上</span></span><br><span class="line">    displayBlock = ^<span class="type">id</span>&#123;</span><br><span class="line">      CHECK_CANCELLED_AND_RETURN_NIL();</span><br><span class="line">      <span class="built_in">UIImage</span> *image = ASGraphicsCreateImageWithOptions(bounds.size, opaque, contentsScaleForDisplay, <span class="literal">nil</span>, isCancelledBlock, ^&#123;</span><br><span class="line">        <span class="keyword">for</span> (dispatch_block_t block <span class="keyword">in</span> displayBlocks) &#123;</span><br><span class="line">          <span class="keyword">if</span> (isCancelledBlock()) <span class="keyword">return</span>;</span><br><span class="line">          block();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      ASDN_DELAY_FOR_DISPLAY();</span><br><span class="line">      <span class="keyword">return</span> image;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    </span><br><span class="line">    displayBlock = ^<span class="type">id</span>&#123;</span><br><span class="line">      </span><br><span class="line">      CHECK_CANCELLED_AND_RETURN_NIL();</span><br><span class="line"></span><br><span class="line">      __block <span class="built_in">UIImage</span> *image = <span class="literal">nil</span>;</span><br><span class="line">      <span class="type">void</span> (^workWithContext)() = ^&#123;</span><br><span class="line">        <span class="built_in">CGContextRef</span> currentContext = <span class="built_in">UIGraphicsGetCurrentContext</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (shouldCreateGraphicsContext &amp;&amp; !currentContext) &#123;</span><br><span class="line">          ASDisplayNodeAssert(<span class="literal">NO</span>, <span class="string">@&quot;Failed to create a CGContext (size: %@)&quot;</span>, <span class="built_in">NSStringFromCGSize</span>(bounds.size));</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// For -display methods, we don&#x27;t have a context, and thus will not call the _willDisplayNodeContentWithRenderingContext or</span></span><br><span class="line">        <span class="comment">// _didDisplayNodeContentWithRenderingContext blocks. It&#x27;s up to the implementation of -display... to do what it needs.</span></span><br><span class="line">        [<span class="keyword">self</span> __willDisplayNodeContentWithRenderingContext:currentContext drawParameters:drawParameters];</span><br><span class="line">        <span class="comment">//根据情况调用display方法或者drawRect方法</span></span><br><span class="line">        <span class="keyword">if</span> (usesImageDisplay) &#123;                                   <span class="comment">// If we are using a display method, we&#x27;ll get an image back directly.</span></span><br><span class="line">          image = [<span class="keyword">self</span>.class displayWithParameters:drawParameters isCancelled:isCancelledBlock];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (usesDrawRect) &#123;                                <span class="comment">// If we&#x27;re using a draw method, this will operate on the currentContext.</span></span><br><span class="line">          [<span class="keyword">self</span>.class drawRect:bounds withParameters:drawParameters isCancelled:isCancelledBlock isRasterizing:rasterizing];</span><br><span class="line">        &#125;</span><br><span class="line">        [<span class="keyword">self</span> __didDisplayNodeContentWithRenderingContext:currentContext image:&amp;image drawParameters:drawParameters backgroundColor:backgroundColor borderWidth:borderWidth borderColor:borderColor];</span><br><span class="line">        ASDN_DELAY_FOR_DISPLAY();</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (shouldCreateGraphicsContext) &#123;</span><br><span class="line">        <span class="keyword">return</span> ASGraphicsCreateImageWithOptions(bounds.size, opaque, contentsScaleForDisplay, <span class="literal">nil</span>, isCancelledBlock, workWithContext);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        workWithContext();</span><br><span class="line">        <span class="keyword">return</span> image;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...........</span></span><br><span class="line">  <span class="keyword">return</span> displayBlock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>display Block 的开始会先通过flags来判断当前的子节点是否需要栅格化，flags这个结构体变量主要用来标记该Node的一些状态属性，以及是否重载了某些方法。如果需要栅格化，那么就需要遍历各个子节点，从各个子节点中获取自身的display Block放置到一个名字为displayBlocks的数组中。这些Block负责生成自身的UIImage.根节点的displayBlock中包含着子节点的display block.在绘制页面的时候，通过这些子节点的display block在绘图的context中将自己绘制出来。这里比较关键的是_recursivelyRasterizeSelfAndSublayersWithIsCancelledBlock方法：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)_recursivelyRasterizeSelfAndSublayersWithIsCancelledBlock:(asdisplaynode_iscancelled_block_t)isCancelledBlock displayBlocks:(<span class="built_in">NSMutableArray</span> *)displayBlocks</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// Skip subtrees that are hidden or zero alpha.</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">self</span>.isHidden || <span class="keyword">self</span>.alpha &lt;= <span class="number">0.0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  __instanceLock__.lock();</span><br><span class="line">  <span class="type">BOOL</span> rasterizingFromAscendent = (_hierarchyState &amp; ASHierarchyStateRasterized);</span><br><span class="line">  __instanceLock__.unlock();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// if super node is rasterizing descendants, subnodes will not have had layout calls because they don&#x27;t have layers</span></span><br><span class="line">  <span class="keyword">if</span> (rasterizingFromAscendent) &#123;</span><br><span class="line">    [<span class="keyword">self</span> __layout];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Capture these outside the display block so they are retained.</span></span><br><span class="line">  <span class="built_in">UIColor</span> *backgroundColor = <span class="keyword">self</span>.backgroundColor;</span><br><span class="line">  <span class="built_in">CGRect</span> bounds = <span class="keyword">self</span>.bounds;</span><br><span class="line">  <span class="built_in">CGFloat</span> cornerRadius = <span class="keyword">self</span>.cornerRadius;</span><br><span class="line">  <span class="type">BOOL</span> clipsToBounds = <span class="keyword">self</span>.clipsToBounds;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">CGRect</span> frame;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// If this is the root container node, use a frame with a zero origin to draw into. If not, calculate the correct frame using the node&#x27;s position, transform and anchorPoint.</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">self</span>.rasterizesSubtree) &#123;</span><br><span class="line">    frame = <span class="built_in">CGRectMake</span>(<span class="number">0.0</span>f, <span class="number">0.0</span>f, bounds.size.width, bounds.size.height);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">CGPoint</span> position = <span class="keyword">self</span>.position;</span><br><span class="line">    <span class="built_in">CGPoint</span> anchorPoint = <span class="keyword">self</span>.anchorPoint;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Pretty hacky since full 3D transforms aren&#x27;t actually supported, but attempt to compute the transformed frame of this node so that we can composite it into approximately the right spot.</span></span><br><span class="line">    <span class="built_in">CGAffineTransform</span> transform = <span class="built_in">CATransform3DGetAffineTransform</span>(<span class="keyword">self</span>.transform);</span><br><span class="line">    <span class="built_in">CGSize</span> scaledBoundsSize = <span class="built_in">CGSizeApplyAffineTransform</span>(bounds.size, transform);</span><br><span class="line">    <span class="built_in">CGPoint</span> origin = <span class="built_in">CGPointMake</span>(position.x - scaledBoundsSize.width * anchorPoint.x,</span><br><span class="line">                                 position.y - scaledBoundsSize.height * anchorPoint.y);</span><br><span class="line">    frame = <span class="built_in">CGRectMake</span>(origin.x, origin.y, bounds.size.width, bounds.size.height);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Get the display block for this node.</span></span><br><span class="line">  asyncdisplaykit_async_transaction_operation_block_t displayBlock = [<span class="keyword">self</span> _displayBlockWithAsynchronous:<span class="literal">NO</span> isCancelledBlock:isCancelledBlock rasterizing:<span class="literal">YES</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// We&#x27;ll display something if there is a display block, clipping, translation and/or a background color.</span></span><br><span class="line">  <span class="type">BOOL</span> shouldDisplay = displayBlock || backgroundColor || <span class="built_in">CGPointEqualToPoint</span>(<span class="built_in">CGPointZero</span>, frame.origin) == <span class="literal">NO</span> || clipsToBounds;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If we should display, then push a transform, draw the background color, and draw the contents.</span></span><br><span class="line">  <span class="comment">// The transform is popped in a block added after the recursion into subnodes.</span></span><br><span class="line">  <span class="keyword">if</span> (shouldDisplay) &#123;</span><br><span class="line">    dispatch_block_t pushAndDisplayBlock = ^&#123;</span><br><span class="line">      <span class="comment">// Push transform relative to parent.</span></span><br><span class="line">      <span class="built_in">CGContextRef</span> context = <span class="built_in">UIGraphicsGetCurrentContext</span>();</span><br><span class="line">      <span class="built_in">CGContextSaveGState</span>(context);</span><br><span class="line"></span><br><span class="line">      <span class="built_in">CGContextTranslateCTM</span>(context, frame.origin.x, frame.origin.y);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//support cornerRadius</span></span><br><span class="line">      <span class="keyword">if</span> (rasterizingFromAscendent &amp;&amp; clipsToBounds) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cornerRadius) &#123;</span><br><span class="line">          [[<span class="built_in">UIBezierPath</span> bezierPathWithRoundedRect:bounds cornerRadius:cornerRadius] addClip];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="built_in">CGContextClipToRect</span>(context, bounds);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Fill background if any.</span></span><br><span class="line">      <span class="built_in">CGColorRef</span> backgroundCGColor = backgroundColor.CGColor;</span><br><span class="line">      <span class="keyword">if</span> (backgroundColor &amp;&amp; <span class="built_in">CGColorGetAlpha</span>(backgroundCGColor) &gt; <span class="number">0.0</span>) &#123;</span><br><span class="line">        <span class="built_in">CGContextSetFillColorWithColor</span>(context, backgroundCGColor);</span><br><span class="line">        <span class="built_in">CGContextFillRect</span>(context, bounds);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// If there is a display block, call it to get the image, then copy the image into the current context (which is the rasterized container&#x27;s backing store).</span></span><br><span class="line">      <span class="keyword">if</span> (displayBlock) &#123;</span><br><span class="line">        <span class="built_in">UIImage</span> *image = (<span class="built_in">UIImage</span> *)displayBlock();</span><br><span class="line">        <span class="keyword">if</span> (image) &#123;</span><br><span class="line">          <span class="type">BOOL</span> opaque = ASImageAlphaInfoIsOpaque(<span class="built_in">CGImageGetAlphaInfo</span>(image.CGImage));</span><br><span class="line">          <span class="built_in">CGBlendMode</span> blendMode = opaque ? kCGBlendModeCopy : kCGBlendModeNormal;</span><br><span class="line">          [image drawInRect:bounds blendMode:blendMode alpha:<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    [displayBlocks addObject:pushAndDisplayBlock];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Recursively capture displayBlocks for all descendants.</span></span><br><span class="line">  <span class="keyword">for</span> (ASDisplayNode *subnode <span class="keyword">in</span> <span class="keyword">self</span>.subnodes) &#123;</span><br><span class="line">    [subnode _recursivelyRasterizeSelfAndSublayersWithIsCancelledBlock:isCancelledBlock displayBlocks:displayBlocks];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If we pushed a transform, pop it by adding a display block that does nothing other than that.</span></span><br><span class="line">  <span class="keyword">if</span> (shouldDisplay) &#123;</span><br><span class="line">    <span class="comment">// Since this block is pure, we can store it statically.</span></span><br><span class="line">    <span class="keyword">static</span> dispatch_block_t popBlock;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">      popBlock = ^&#123;</span><br><span class="line">        <span class="built_in">CGContextRef</span> context = <span class="built_in">UIGraphicsGetCurrentContext</span>();</span><br><span class="line">        <span class="built_in">CGContextRestoreGState</span>(context);</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;);</span><br><span class="line">    [displayBlocks addObject:popBlock];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>_recursivelyRasterizeSelfAndSublayersWithIsCancelledBlock 这个方法中也调用_displayBlockWithAsynchronous来获取displayBlock，只不过需要注意的是rasterizing参数为YES导致_displayBlockWithAsynchronous中shouldBeginRasterizing为NO.直接走displayWithParameters&#x2F;drawRect部分。绘制子节点的工作在pushAndDisplayBlock中完成，pushAndDisplayBlock就是被添加到displayBlocks的子block。</p>
<p>如果不需要栅格化,就直接走displayWithParameters&#x2F;drawRect部分具体是displayWithParameters还是drawRect取决于flags中的标志，如果走displayWithParameters将会直接获取image返回，如果是drawRect将会在当前Context中绘制自身绘制。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (asyncdisplaykit_async_transaction_operation_block_t)_displayBlockWithAsynchronous:(<span class="type">BOOL</span>)asynchronous</span><br><span class="line">                                                                    isCancelledBlock:(asdisplaynode_iscancelled_block_t)isCancelledBlock</span><br><span class="line">                                                                         rasterizing:(<span class="type">BOOL</span>)rasterizing</span><br><span class="line">&#123;</span><br><span class="line">  ASDisplayNodeAssertMainThread();</span><br><span class="line">  <span class="comment">//........</span></span><br><span class="line">  <span class="comment">//是否实现了display方法</span></span><br><span class="line">  <span class="type">BOOL</span> usesImageDisplay = flags.implementsImageDisplay;</span><br><span class="line">  <span class="comment">//是否实现了drawRect方法</span></span><br><span class="line">  <span class="type">BOOL</span> usesDrawRect = flags.implementsDrawRect;</span><br><span class="line">  <span class="comment">//..........</span></span><br><span class="line">  <span class="comment">//是否栅格化</span></span><br><span class="line">  <span class="keyword">if</span> (shouldBeginRasterizing) &#123;</span><br><span class="line">      <span class="comment">//.......</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    displayBlock = ^<span class="type">id</span>&#123;</span><br><span class="line">      __block <span class="built_in">UIImage</span> *image = <span class="literal">nil</span>;</span><br><span class="line">      <span class="type">void</span> (^workWithContext)() = ^&#123;</span><br><span class="line">        <span class="built_in">CGContextRef</span> currentContext = <span class="built_in">UIGraphicsGetCurrentContext</span>();</span><br><span class="line">        <span class="comment">// .......</span></span><br><span class="line">        <span class="comment">// For -display methods, we don&#x27;t have a context, and thus will not call the _willDisplayNodeContentWithRenderingContext or</span></span><br><span class="line">        <span class="comment">// _didDisplayNodeContentWithRenderingContext blocks. It&#x27;s up to the implementation of -display... to do what it needs.</span></span><br><span class="line">        [<span class="keyword">self</span> __willDisplayNodeContentWithRenderingContext:currentContext drawParameters:drawParameters];</span><br><span class="line">        <span class="comment">//根据情况调用display方法或者drawRect方法</span></span><br><span class="line">        <span class="keyword">if</span> (usesImageDisplay) &#123;                                   <span class="comment">// If we are using a display method, we&#x27;ll get an image back directly.</span></span><br><span class="line">          image = [<span class="keyword">self</span>.class displayWithParameters:drawParameters isCancelled:isCancelledBlock];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (usesDrawRect) &#123;                                <span class="comment">// If we&#x27;re using a draw method, this will operate on the currentContext.</span></span><br><span class="line">          [<span class="keyword">self</span>.class drawRect:bounds withParameters:drawParameters isCancelled:isCancelledBlock isRasterizing:rasterizing];</span><br><span class="line">        &#125;</span><br><span class="line">        [<span class="keyword">self</span> __didDisplayNodeContentWithRenderingContext:currentContext image:&amp;image drawParameters:drawParameters backgroundColor:backgroundColor borderWidth:borderWidth borderColor:borderColor];</span><br><span class="line">        ASDN_DELAY_FOR_DISPLAY();</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (shouldCreateGraphicsContext) &#123;</span><br><span class="line">        <span class="keyword">return</span> ASGraphicsCreateImageWithOptions(bounds.size, opaque, contentsScaleForDisplay, <span class="literal">nil</span>, isCancelledBlock, workWithContext);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        workWithContext();</span><br><span class="line">        <span class="keyword">return</span> image;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...........</span></span><br><span class="line">  <span class="keyword">return</span> displayBlock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-Texture-布局源码分析"><a href="#1-Texture-布局源码分析" class="headerlink" title="1. Texture 布局源码分析"></a>1. Texture 布局源码分析</h5><p>最早iOS平台上的布局方式是基于frame的布局，但是后续iPhone推出了一系列不同尺寸的设备，这时候frame布局方式就显得十分麻烦，为了解决这个问题Auto Layout 就诞生了，如果使用过Auto Layout原生接口进行布局的经历，我相信一定是十分难受的，但是随着Masonry的推出，让Auto Layout逐渐被开发者所接受，<br>但是Auto Layout与frame 布局不同的是我们给出的是组件与组件之间的约束关系，然后由系统布局引擎帮我们计算出每个组件的实际frame。也就是说Auto Layout最终还是要转换成组件的frame，只不过这个转换系统帮我们做了，我们只需要给出约束条件就可以了。但是Auto Layout每个组件的约束最终都会转换为一个N元一次的线性等式或者不等式，要计算出整个页面每个组件frame的值，就需要根据这些N元一次的线性等式或者不等式组成的不等式组解出结果。这个时间是不确定的，并且界面越复杂不等式组也就越复杂，计算所耗费的时间也就越多。最要命的是它还会强制视图在主线程上布局。如果这个时间超过16.67ms就会导致界面的卡顿。</p>
<p>那么我们有没有一套可以不用手动计算布局参数，又能有较高的布局效率的布局引擎呢？我们先看下Texture的布局引擎的源码，在这里寻找下我们需要的答案。</p>
<p>Texture 布局引擎是可以在后台线程中运行的布局引擎，它采用了目前前端比较流行的FlexBox布局形式，具体的使用大家可以看下之前的介绍Texture布局使用的博客。Texture 2.X 目前采用了两套布局引擎：LayoutSpec 布局规范 和 Yoga 布局引擎，这里先介绍 LayoutSpec 布局规范引擎。</p>
<p>Texture 布局引擎比较突出的特点是能够在后台计算布局，并且能够缓存布局结果。</p>
<p>Texture中可以通过如下四种方式指定布局：</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="bullet">* </span>提供 layoutSpecBlock</span><br><span class="line"><span class="bullet">* </span>覆写 - layoutSpecThatFits: 方法</span><br><span class="line"><span class="bullet">* </span>覆写 - calculateSizeThatFits: 方法 </span><br><span class="line"><span class="bullet">* </span>覆写 - calculateLayoutThatFits: 方法</span><br></pre></td></tr></table></figure>

<ul>
<li><ul>
<li>layoutSpecThatFits: 与 layoutSpecBlock 是完全等价的只不过是实现的形式不一样而已。</li>
</ul>
</li>
<li><ul>
<li>calculateSizeThatFits: 这种方式提供了手动布局的方式，通过在该方法内对 frame 进行计算，返回一个当前视图的 CGSize,它和UIView 中的 -[UIView sizeThatFits:] 非常相似 只不过 Texture中的布局会对所有计算出的布局进行缓存来提高性能。</li>
</ul>
</li>
<li><ul>
<li>calculateLayoutThatFits: 把上面的两种布局方式：手动布局和 Spec 布局封装成了一个接口，这样，无论是 CGSize 还是 ASLayoutSpec 最后都会以 ASLayout 的形式返回给方法调用者。一般推荐calculateLayoutThatFits覆写这个方法，而不是layoutSpecThatFits。</li>
</ul>
</li>
</ul>
<p>还是老规矩在介绍流程之前先熟悉下关键对象的组成：</p>
<ol>
<li>ASLayoutElement</li>
</ol>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@protocol</span> ASLayoutElement &lt;ASLayoutElementExtensibility, ASTraitEnvironment, ASLayoutElementAsciiArtProtocol&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//包括ASLayoutElementTypeLayoutSpec以及ASLayoutElementTypeDisplayNode，前者为布局约束元素，后一个表明为显示节点元素</span></span><br><span class="line"></span><br><span class="line"><span class="variable">@property</span> (nonatomic, readonly) ASLayoutElementType layoutElementType;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 尺寸约束</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="variable">@property</span> (nonatomic, readonly) ASLayoutElementStyle *style;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当前节点的子节点集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="selector-tag">-</span> (nullable NSArray&lt;id&lt;ASLayoutElement&gt;&gt; *)<span class="selector-tag">sublayoutElements</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 要求节点基于给定的尺寸范围返回一个ASLayout布局</span></span><br><span class="line"><span class="comment"> * 这个方法会缓存约束条件和布局结果，所以子类不能覆盖它，因为它会缓存calculateLayoutThatFits获得的结果，如果没有缓存结果那么这个方法的将会十分耗时</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="selector-tag">-</span> (ASLayout *)<span class="selector-tag">layoutThatFits</span>:(ASSizeRange)<span class="selector-tag">constrainedSize</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 让子元素在calculateLayoutThatFits计算它们的布局，这个是供给内部使用的我们不应该覆写这个方法，但是可以通过覆写-calculateLayoutThatFits来代替，constrainedSize 是一个最大值和最小值的一个限制，最终得到的尺寸必须在这个范围内。这个方法也是会缓存计算的结果和约束条件</span></span><br><span class="line"><span class="comment">- (ASLayout *)layoutThatFits:(ASSizeRange)constrainedSize parentSize:(CGSize)parentSize;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过覆写这个方法来计算当前布局元素的布局</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="selector-tag">-</span> (ASLayout *)<span class="selector-tag">calculateLayoutThatFits</span>:(ASSizeRange)<span class="selector-tag">constrainedSize</span>;</span><br><span class="line"></span><br><span class="line">@<span class="selector-tag">end</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>ASLayout</li>
</ol>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ASLayout</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当前布局对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>, <span class="keyword">readonly</span>) <span class="type">id</span>&lt;ASLayoutElement&gt; layoutElement;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 节点类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) ASLayoutElementType type;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当前布局的Size</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">CGSize</span> size;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在父节点的位置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">CGPoint</span> position;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 子节点的布局</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;ASLayout *&gt; *sublayouts;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 某个节点的位置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="built_in">CGRect</span>)frameForElement:(<span class="type">id</span>&lt;ASLayoutElement&gt;)layoutElement;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据postion和size计算出来的frame</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">CGRect</span> frame;</span><br><span class="line"></span><br><span class="line"><span class="comment">//......</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Traverses the existing layout tree and generates a new tree that represents only ASDisplayNode layouts</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (ASLayout *)filteredNodeLayoutTree <span class="built_in">NS_RETURNS_RETAINED</span> AS_WARN_UNUSED_RESULT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>在介绍关键都类之后我们来看下整个布局流程：<br>我们以手动调用节点都layoutThatFits方法作为入口点。在layoutThatFits：中简单得转调了下layoutThatFits:parentSize</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">- (ASLayout *)layoutThatFits:(ASSizeRange)constrainedSize</span><br><span class="line">&#123;</span><br><span class="line">  return <span class="literal">[<span class="identifier">self</span> <span class="identifier">layoutThatFits</span>:<span class="identifier">constrainedSize</span> <span class="identifier">parentSize</span>:<span class="identifier">constrainedSize</span>.<span class="identifier">max</span>]</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (ASLayout *)layoutThatFits:(ASSizeRange)constrainedSize parentSize:(CGSize)parentSize</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//......</span></span><br><span class="line">  ASLayout *layout = nil;</span><br><span class="line">  <span class="comment">//在每次调用-setNeedsLayout / -invalidateCalculatedLayout 方法的时候_layoutVersion会+1</span></span><br><span class="line">  NSUInteger version = _layoutVersion;</span><br><span class="line">  <span class="comment">//先检查_calculatedDisplayNodeLayout是否可用，如果可用则优先使用</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="module-access"><span class="module"><span class="identifier">_calculatedDisplayNodeLayout</span>.</span></span>is<span class="constructor">Valid(<span class="params">constrainedSize</span>, <span class="params">parentSize</span>, <span class="params">version</span>)</span>) &#123;</span><br><span class="line">    layout = <span class="module-access"><span class="module"><span class="identifier">_calculatedDisplayNodeLayout</span>.</span></span>layout;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="module-access"><span class="module"><span class="identifier">_pendingDisplayNodeLayout</span>.</span></span>is<span class="constructor">Valid(<span class="params">constrainedSize</span>, <span class="params">parentSize</span>, <span class="params">version</span>)</span>) &#123;</span><br><span class="line">    <span class="comment">//检查_pendingDisplayNodeLayout是否可用，如果可用则优先使用</span></span><br><span class="line">    layout = <span class="module-access"><span class="module"><span class="identifier">_pendingDisplayNodeLayout</span>.</span></span>layout;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="comment">//如果_calculatedDisplayNodeLayout和_pendingDisplayNodeLayout都不可用则新建一个ASLayout作为_pendingDisplayNodeLayout</span></span><br><span class="line">    <span class="comment">// Create a pending display node layout for the layout pass</span></span><br><span class="line">    layout = <span class="literal">[<span class="identifier">self</span> <span class="identifier">calculateLayoutThatFits</span>:<span class="identifier">constrainedSize</span></span></span><br><span class="line"><span class="literal">                          <span class="identifier">restrictedToSize</span>:<span class="identifier">self</span>.<span class="identifier">style</span>.<span class="identifier">size</span></span></span><br><span class="line"><span class="literal">                      <span class="identifier">relativeToParentSize</span>:<span class="identifier">parentSize</span>]</span>;</span><br><span class="line">    _pendingDisplayNodeLayout = <span class="constructor">ASDisplayNodeLayout(<span class="params">layout</span>, <span class="params">constrainedSize</span>, <span class="params">parentSize</span>,<span class="params">version</span>)</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  return layout ?: <span class="literal">[ASL<span class="identifier">ayout</span> <span class="identifier">layoutWithLayoutElement</span>:<span class="identifier">self</span> <span class="identifier">size</span>:&#123;<span class="number">0</span>, <span class="number">0</span>&#125;]</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>最初的时候_calculatedDisplayNodeLayout和_pendingDisplayNodeLayout都是不可用的，所以layout是由calculateLayoutThatFits:restrictedToSize:relativeToParentSize 返回的，然后将其包裹成ASDisplayNodeLayout赋值给_pendingDisplayNodeLayout，这里需要注意的是这里的_layoutVersion，每次调用-setNeedsLayout &#x2F; -invalidateCalculatedLayout 方法的时候_layoutVersion会+1，当版本不对的时候isValid就会返回NO,这里的_calculatedDisplayNodeLayout和_pendingDisplayNodeLayout应该是一个布局缓存。这个等后续的时候进一步查看。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">- (ASLayout *)calculateLayoutThatFits:(ASSizeRange)constrainedSize</span><br><span class="line">                     restrictedToSize:(ASLayoutElementSize)size</span><br><span class="line">                 relativeToParentSize:(CGSize)parentSize</span><br><span class="line">&#123;</span><br><span class="line">  ASSizeRange styleAndParentSize = <span class="constructor">ASLayoutElementSizeResolve(<span class="params">self</span>.<span class="params">style</span>.<span class="params">size</span>, <span class="params">parentSize</span>)</span>;</span><br><span class="line">  const ASSizeRange resolvedRange = <span class="constructor">ASSizeRangeIntersect(<span class="params">constrainedSize</span>, <span class="params">styleAndParentSize</span>)</span>;</span><br><span class="line">  ASLayout *result = <span class="literal">[<span class="identifier">self</span> <span class="identifier">calculateLayoutThatFits</span>:<span class="identifier">resolvedRange</span>]</span>;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在calculateLayoutThatFits中会对限制的范围做个重新修正，再以修正后的约束范围作为参数计算布局。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (ASLayout *)calculateLayoutThatFits:(ASSizeRange)constrainedSize</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//调用方法之前的检查，必须提供layoutSpecBlock或者重写calculateLayoutThatFits，calculateSizeThatFits或者layoutSpecThatFits</span></span><br><span class="line">  __ASDisplayNodeCheckForLayoutMethodOverrides;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//根据不同布局引擎类型实现不同的布局</span></span><br><span class="line">  <span class="keyword">switch</span> (<span class="keyword">self</span>.layoutEngineType) &#123;</span><br><span class="line">    <span class="comment">//使用布局规范引擎</span></span><br><span class="line">    <span class="keyword">case</span> ASLayoutEngineTypeLayoutSpec:</span><br><span class="line">      <span class="keyword">return</span> [<span class="keyword">self</span> calculateLayoutLayoutSpec:constrainedSize];</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> YOGA</span></span><br><span class="line">    <span class="comment">//使用YOGA布局引擎</span></span><br><span class="line">    <span class="keyword">case</span> ASLayoutEngineTypeYoga:</span><br><span class="line">      <span class="keyword">return</span> [<span class="keyword">self</span> calculateLayoutYoga:constrainedSize];</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在Texture 2.0开始引入了YOGA布局引擎，YOGA布局是FaceBook推出的布局形式，我们这里以Texture 默认采用的LayoutSpec作为研究对象进行介绍。</p>
<figure class="highlight mel"><table><tr><td class="code"><pre><span class="line">- (ASLayout *)calculateLayoutLayoutSpec:(ASSizeRange)constrainedSize</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 没有通过_layoutSpecBlock也没有实现LayoutSpecThatFits指定布局则直接通过calculateSizeThatFits手动指定size</span></span><br><span class="line">  <span class="keyword">if</span> (_layoutSpecBlock == NULL &amp;&amp; (_methodOverrides &amp; ASDisplayNodeMethodOverrideLayoutSpecThatFits) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">//手动指定尺寸</span></span><br><span class="line">    CGSize <span class="keyword">size</span> = [self calculateSizeThatFits:constrainedSize.<span class="keyword">max</span>];</span><br><span class="line">    <span class="keyword">return</span> [ASLayout layoutWithLayoutElement:self <span class="keyword">size</span>:ASSizeRangeClamp(constrainedSize, <span class="keyword">size</span>) sublayouts:nil];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通过_layoutSpecBlock 或者 layoutSpecThatFits来从node中获得ASLayoutElement</span></span><br><span class="line">  id&lt;ASLayoutElement&gt; layoutElement = [self _locked_layoutElementThatFits:constrainedSize];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用ASLayoutElement的layoutThatFits:方法计算得到ASLayout。</span></span><br><span class="line">  ASLayout *<span class="keyword">layout</span> = (&#123;</span><br><span class="line">    AS::SumScopeTimer t(_layoutComputationTotalTime, measureLayoutComputation);</span><br><span class="line">    [layoutElement layoutThatFits:constrainedSize];</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//.......</span></span><br><span class="line">  <span class="keyword">layout</span> = [<span class="keyword">layout</span> filteredNodeLayoutTree];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">layout</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>首先先判断是否有设置过_layoutSpecBlock或者实现过layoutSpecThatFits:这两者其实是等效的，如果这两者都没有，那么就只能通过calculateSizeThatFits手动指定size。将用户手动指定的Size封装成ASLayout返回</p>
</li>
<li><p>如果有实现layoutSpecThatFits:或者有设置过_layoutSpecBlock那么就通过各自的方法返回实现了ASLayoutElement协议的对象。</p>
</li>
<li><p>通过调用layoutThatFits返回ASLayout，这里会调用各个ASLayoutSpec子类的calculateLayoutThatFits方法。这里以最简单的ASWrapperLayoutSpec为例子进行分析：</p>
</li>
</ol>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">- (ASLayout *)calculateLayoutThatFits:(ASSizeRange)constrainedSize</span><br><span class="line">&#123;</span><br><span class="line">  NSArray *children = self.children;</span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span> count = children.count;</span><br><span class="line">  ASLayout *rawSublayouts[count];</span><br><span class="line">  <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">  CGSize size = constrainedSize.min;</span><br><span class="line">  <span class="comment">//遍历子节点，获得子节点的ASLayout</span></span><br><span class="line">  <span class="keyword">for</span> (id&lt;ASLayoutElement&gt; child in children) &#123;</span><br><span class="line">    ASLayout *sublayout = [child layoutThatFits:constrainedSize parentSize:constrainedSize.max];</span><br><span class="line">    sublayout.position = CGPointZero;</span><br><span class="line">    <span class="comment">//获得最大的宽高</span></span><br><span class="line">    size.width = <span class="built_in">MAX</span>(size.width,  sublayout.size.width);</span><br><span class="line">    size.height = <span class="built_in">MAX</span>(size.height, sublayout.size.height);</span><br><span class="line">    <span class="comment">//将子节点的布局保存起来</span></span><br><span class="line">    rawSublayouts[i++] = sublayout;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span> sublayouts = [NSArray&lt;ASLayout *&gt; arrayByTransferring:rawSublayouts count:i];</span><br><span class="line">  <span class="comment">//将size转换为ASLayout</span></span><br><span class="line">  <span class="keyword">return</span> [ASLayout layoutWithLayoutElement:self size:size sublayouts:sublayouts];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ASWrapperLayoutSpec的功能就是用一个布局将轮廓包起开，这里会遍历每个子节点获取子节点的尺寸，获取最大的size，并通过layoutWithLayoutElement将size转换为ASLayout返回。</p>
<p>calculateLayoutLayoutSpec针对上面获得的ASLayout还有最后一步处理：</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">layout</span> <span class="operator">=</span> [layout filteredNodeLayoutTree]<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>什么是扁平化，我们之前的步骤都是针对节点的宽高。扁平化就是针对position进行修正。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">- (ASLayout *)filteredNodeLayoutTree NS_RETURNS_RETAINED</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">Context</span> &#123;</span><br><span class="line">    unowned ASLayout *layout;</span><br><span class="line">    CGPoint absolutePosition;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// Queue used to keep track of sublayouts while traversing this layout in a DFS fashion.</span></span><br><span class="line">  std::deque&lt;Context&gt; queue;</span><br><span class="line">  <span class="comment">//将_sublayouts数据先填到queue</span></span><br><span class="line">  <span class="keyword">for</span> (ASLayout *sublayout in _sublayouts) &#123;</span><br><span class="line">    queue.<span class="built_in">push_back</span>(&#123;sublayout, sublayout.position&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//这个是扁平化的子布局</span></span><br><span class="line">  std::vector&lt;ASLayout *&gt; flattenedSublayouts;</span><br><span class="line">  <span class="keyword">while</span> (!queue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="comment">//从queue中拿出数据</span></span><br><span class="line">    <span class="type">const</span> Context context = std::<span class="built_in">move</span>(queue.<span class="built_in">front</span>());</span><br><span class="line">    queue.<span class="built_in">pop_front</span>();</span><br><span class="line">    </span><br><span class="line">    unowned ASLayout *layout = context.layout;</span><br><span class="line">    <span class="comment">// Direct ivar access to avoid retain/release, use existing +1.</span></span><br><span class="line">    <span class="type">const</span> NSUInteger sublayoutsCount = layout-&gt;_sublayouts.count;</span><br><span class="line">    <span class="type">const</span> CGPoint absolutePosition = context.absolutePosition;</span><br><span class="line">    <span class="comment">//是否是DisplayNode节点，如果是节点就不需要扁平化，看absolutePosition是否和layout.position是否相同，如果不相同就需要新建一个放到flattenedSublayouts</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">ASLayoutIsDisplayNodeType</span>(layout)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (sublayoutsCount &gt; <span class="number">0</span> || <span class="built_in">CGPointEqualToPoint</span>(<span class="built_in">ASCeilPointValues</span>(absolutePosition), layout.position) == NO) &#123;</span><br><span class="line">        <span class="comment">// Only create a new layout if the existing one can&#x27;t be reused, which means it has either some sublayouts or an invalid absolute position.</span></span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span> newLayout = [ASLayout layoutWithLayoutElement:layout-&gt;_layoutElement</span><br><span class="line">                                                     size:layout.size</span><br><span class="line">                                                 position:absolutePosition</span><br><span class="line">                                               sublayouts:@[]];</span><br><span class="line">        flattenedSublayouts.<span class="built_in">push_back</span>(newLayout);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        flattenedSublayouts.<span class="built_in">push_back</span>(layout);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sublayoutsCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">//如果是一个布局容器，那么就需要根据节点之间的关系修正positon位置</span></span><br><span class="line">      <span class="comment">// Fast-reverse-enumerate the sublayouts array by copying it into a C-array and push_front&#x27;ing each into the queue.</span></span><br><span class="line">      unowned ASLayout *rawSublayouts[sublayoutsCount];</span><br><span class="line">      [layout-&gt;_sublayouts getObjects:rawSublayouts range:<span class="built_in">NSMakeRange</span>(<span class="number">0</span>, sublayoutsCount)];</span><br><span class="line">      <span class="keyword">for</span> (NSInteger i = sublayoutsCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        queue.<span class="built_in">push_front</span>(&#123;rawSublayouts[i], absolutePosition + rawSublayouts[i].position&#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//将flattenedSublayouts转换成ASLayout</span></span><br><span class="line">  NSArray *array = [NSArray arrayByTransferring:flattenedSublayouts.<span class="built_in">data</span>() count:flattenedSublayouts.<span class="built_in">size</span>()];</span><br><span class="line">  ASLayout *layout = [ASLayout layoutWithLayoutElement:_layoutElement size:_size sublayouts:array];</span><br><span class="line">  [layout retainSublayoutElements];</span><br><span class="line">  <span class="keyword">return</span> layout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那我们怎么将ASLayout应用到节点的frame完成布局呢？我们在上面介绍ASLayout的时候有提到一个方法：</p>
<figure class="highlight erlang"><table><tr><td class="code"><pre><span class="line">- <span class="params">(CGRect)</span>frameForElement:<span class="params">(id&lt;ASLayoutElement&gt;)</span>layoutElement;</span><br></pre></td></tr></table></figure>
<p>它传入一个节点或者节点容器，会返回一个frame：</p>
<figure class="highlight erlang"><table><tr><td class="code"><pre><span class="line">- <span class="params">(CGRect)</span>frameForElement:<span class="params">(id&lt;ASLayoutElement&gt;)</span>layoutElement</span><br><span class="line">&#123;</span><br><span class="line">  for <span class="params">(ASLayout *l in _sublayouts)</span> &#123;</span><br><span class="line">    if <span class="params">(l-&gt;_layoutElement == layoutElement)</span> &#123;</span><br><span class="line">      return l.frame;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return CGRectNull;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>frameForElement这个方法在ASDisplayNode+Layout.mm类中的_layoutSublayouts调用，这里遍历当前节点的子节点，将每个节点传入frameForElement，获得frame，再将frame赋给node.frame，完成布局。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)_layoutSublayouts</span><br><span class="line">&#123;</span><br><span class="line">  ASDisplayNodeAssertThreadAffinity(<span class="keyword">self</span>);</span><br><span class="line">  <span class="comment">//............</span></span><br><span class="line">  <span class="keyword">for</span> (ASDisplayNode *node <span class="keyword">in</span> <span class="keyword">self</span>.subnodes) &#123;</span><br><span class="line">    <span class="built_in">CGRect</span> frame = [layout frameForElement:node];</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">CGRectIsNull</span>(frame)) &#123;</span><br><span class="line">      <span class="comment">// There is no frame for this node in our layout.</span></span><br><span class="line">      <span class="comment">// This currently can happen if we get a CA layout pass</span></span><br><span class="line">      <span class="comment">// while waiting for the client to run animateLayoutTransition:</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      node.frame = frame;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可能大家还会有一个疑问，我们上面介绍的都是posistion，size那frame怎么得到的？其实frame 就是一个postion和size组合而来。</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">- (CGRect)frame</span><br><span class="line">&#123;</span><br><span class="line">  CGRect subnodeFrame <span class="operator">=</span> CGRectZero<span class="comment">;</span></span><br><span class="line">  CGPoint adjustedOrigin <span class="operator">=</span> _position<span class="comment">;</span></span><br><span class="line">  //.......</span><br><span class="line">  subnodeFrame.origin <span class="operator">=</span> adjustedOrigin<span class="comment">;</span></span><br><span class="line">  CGSize adjustedSize <span class="operator">=</span> _size<span class="comment">;</span></span><br><span class="line">  //......</span><br><span class="line">  subnodeFrame.size <span class="operator">=</span> adjustedSize<span class="comment">;</span></span><br><span class="line">  return subnodeFrame<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么是怎么触发_layoutSublayouts呢？我们看下ASDisplayNode.mm的__layout方法。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)__layout</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//......</span></span><br><span class="line">  <span class="type">BOOL</span> loaded = <span class="literal">NO</span>;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//........</span></span><br><span class="line">    <span class="comment">// This method will confirm that the layout is up to date (and update if needed).</span></span><br><span class="line">    <span class="comment">// Importantly, it will also APPLY the layout to all of our subnodes if (unless parent is transitioning).</span></span><br><span class="line">    l.unlock();</span><br><span class="line">    <span class="comment">// 如果过期了就会重新计算，否则使用缓存的布局</span></span><br><span class="line">    [<span class="keyword">self</span> _u_measureNodeWithBoundsIfNecessary:bounds];</span><br><span class="line">    l.lock();</span><br><span class="line">    <span class="comment">//布局占位图</span></span><br><span class="line">    [<span class="keyword">self</span> _locked_layoutPlaceholderIfNecessary];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//调用_layoutSublayouts</span></span><br><span class="line">  [<span class="keyword">self</span> _layoutSublayouts];</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (loaded) &#123;</span><br><span class="line">    ASPerformBlockOnMainThread(^&#123;</span><br><span class="line">      [<span class="keyword">self</span> layout];</span><br><span class="line">      [<span class="keyword">self</span> _layoutClipCornersIfNeeded];</span><br><span class="line">      [<span class="keyword">self</span> _layoutDidFinish];</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  [<span class="keyword">self</span> _fallbackUpdateSafeAreaOnChildren];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而__layout 是再layoutIfNeeded中调用的。</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">- (void)layoutIfNeeded</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//.......</span></span><br><span class="line">  if (shouldApply) &#123;</span><br><span class="line">    <span class="comment">// The node is loaded and we&#x27;re on main.</span></span><br><span class="line">    <span class="comment">// Message the view or layer which in turn will call __layout on us (see -[_ASDisplayLayer layoutSublayers]).</span></span><br><span class="line">    <span class="selector-attr">[viewOrLayer layoutIfNeeded]</span>;</span><br><span class="line">  &#125; else if (loaded == NO) &#123;</span><br><span class="line">    <span class="comment">// The node is not loaded and we&#x27;re not on main.</span></span><br><span class="line">    <span class="selector-attr">[self __layout]</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>提到layoutIfNeeded我们一定会联想到setNeedsLayout,再UIView中会将UIView标记为dirty需要布局。那么ASDisplayNode呢？</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">- (void)setNeedsLayout</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//.....</span></span><br><span class="line">  if (shouldApply) &#123;</span><br><span class="line">    <span class="comment">// The node is loaded and we&#x27;re on main.</span></span><br><span class="line">    <span class="comment">// Quite the opposite of setNeedsDisplay, we must call __setNeedsLayout before messaging</span></span><br><span class="line">    <span class="comment">// the view or layer to ensure that measurement and implicitly added subnodes have been handled.</span></span><br><span class="line">    <span class="selector-attr">[self __setNeedsLayout]</span>;</span><br><span class="line">    <span class="selector-attr">[viewOrLayer setNeedsLayout]</span>;</span><br><span class="line">  &#125; else if (loaded == NO) &#123;</span><br><span class="line">    <span class="comment">// The node is not loaded and we&#x27;re not on main.</span></span><br><span class="line">    <span class="selector-attr">[self __setNeedsLayout]</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">- (void)__setNeedsLayout</span><br><span class="line">&#123;</span><br><span class="line">  <span class="selector-attr">[self invalidateCalculatedLayout]</span>;</span><br><span class="line">&#125;</span><br><span class="line">- (void)invalidateCalculatedLayout</span><br><span class="line">&#123;</span><br><span class="line">  _layoutVersion++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看到了吧它只是将_layoutVersion加1，这样再使用的时候由于版本不对就将原来的布局过期处理。</p>
<p>整个布局流程如下图所示：<br><img src="/2019/11/12/Texture-%E4%BA%94-Texture%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/11111.png"></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/iOS-%E5%BC%80%E6%BA%90%E5%BA%93%E5%88%86%E6%9E%90/">iOS 开源库分析</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/iOS-开源库分析/">iOS 开源库分析</a>
  </div>

</div>



<div class="comments-count">
	
	  	<span></span>
		<a href="/2019/11/12/Texture-五-Texture源码解析/#comments" class="ds-thread-count comments-count-link" data-thread-key="2019/11/12/Texture-五-Texture源码解析/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/11/10/Texture-二-基本使用Node及布局/" title="Texture 二 基本使用Node及布局" itemprop="url">Texture 二 基本使用Node及布局</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Edgar" target="_blank" itemprop="author">Edgar</a>
		
  <p class="article-time">
    <time datetime="2019-11-10T03:26:02.000Z" itemprop="datePublished"> Published 2019-11-10</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>上一节已经提到了Texture 的布局引擎包含了如下几种布局规范，这一节将对这些布局规范进行展开</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">ASWrapperLayoutSpec</span></span><br><span class="line"><span class="attribute">ASStackLayoutSpec</span></span><br><span class="line"><span class="attribute">ASInsetLayoutSpec</span></span><br><span class="line"><span class="attribute">ASOverlayLayoutSpec</span></span><br><span class="line"><span class="attribute">ASBackgroundLayoutSpec</span></span><br><span class="line"><span class="attribute">ASCenterLayoutSpec</span></span><br><span class="line"><span class="attribute">ASRatioLayoutSpec</span></span><br><span class="line"><span class="attribute">ASRelativeLayoutSpec</span></span><br><span class="line"><span class="attribute">ASAbsoluteLayoutSpec</span></span><br><span class="line"><span class="attribute">ASCornerLayoutSpec</span></span><br></pre></td></tr></table></figure>

<h4 id="具体布局规范"><a href="#具体布局规范" class="headerlink" title="具体布局规范"></a>具体布局规范</h4><hr>
<h5 id="ASLayoutSpec"><a href="#ASLayoutSpec" class="headerlink" title="ASLayoutSpec"></a>ASLayoutSpec</h5><p>所有布局的父类，一般很少用到，但是可以作为间隔占位空间使用。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>字段名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>ASDimension</td>
<td>.style.width</td>
<td>ASLayoutElement内容区域的宽度属性，默认值是ASDimensionAuto，注意它不是最终的宽度值，最终的宽度值会受minWidth和maxWidth属性影响</td>
</tr>
<tr>
<td>ASDimension</td>
<td>.style.height</td>
<td>ASLayoutElement内容区域的高度属性，默认值是ASDimensionAuto</td>
</tr>
<tr>
<td>ASDimension</td>
<td>.style.minWidth</td>
<td>ASLayoutElement内容区域的最小宽度，默认是ASDimensionAuto</td>
</tr>
<tr>
<td>ASDimension</td>
<td>.style.maxWidth</td>
<td>ASLayoutElement内容区域的最大宽度，默认是ASDimensionAuto</td>
</tr>
<tr>
<td>ASDimension</td>
<td>.style.minHeight</td>
<td>ASLayoutElement内容区域的最小高度，默认是ASDimensionAuto</td>
</tr>
<tr>
<td>ASDimension</td>
<td>.style.maxHeight</td>
<td>ASLayoutElement内容区域的最大高度，默认是ASDimensionAuto</td>
</tr>
<tr>
<td>ASDimension</td>
<td>.style.preferredSize</td>
<td>preferredSize提供了一个建议的尺寸，如果它超过了提供的最小尺寸和最大尺寸，那么最小尺寸和最大尺寸将会强制限制，也就是说这个只是一个建议的尺寸数据，如果这个值没有提供那么节点的尺寸将会是它的固有尺寸</td>
</tr>
<tr>
<td>CGSize</td>
<td>.style.minSize</td>
<td>设置最小的尺寸边界</td>
</tr>
<tr>
<td>CGSize</td>
<td>.style.maxSize</td>
<td>设置最大的尺寸边界</td>
</tr>
<tr>
<td>ASLayoutSize</td>
<td>.style.preferredLayoutSize</td>
<td>preferredLayoutSize 为布局节点提供了一个建议的相对尺寸，ASLayoutSize 和 CGSize 的区别是它使用的是相对百分比而不是绝对的像素值，和preferredSize类似如果它超过了提供的最小尺寸和最大尺寸，那么最小尺寸和最大尺寸将会强制限制</td>
</tr>
<tr>
<td>ASLayoutSize</td>
<td>.style.minLayoutSize</td>
<td>minSize的百分比版本</td>
</tr>
<tr>
<td>ASLayoutSize</td>
<td>.style.maxLayoutSize</td>
<td>maxSize的百分比版本</td>
</tr>
</tbody></table>
<hr>
<h5 id="ASStackLayoutSpec"><a href="#ASStackLayoutSpec" class="headerlink" title="ASStackLayoutSpec"></a>ASStackLayoutSpec</h5><p>这里有一个可以比较直观体验ASStackLayoutSpec的小游戏，大家可以在看完后体验下：<br><a target="_blank" rel="noopener" href="https://huynguyen.dev/froggy-asdk-layout/">https://huynguyen.dev/froggy-asdk-layout/</a></p>
<p>如果大家对Flex不是很了解还可以通过下面的网站看下，比较直观<br><a target="_blank" rel="noopener" href="https://demos.scotch.io/visual-guide-to-css3-flexbox-flexbox-playground/demos/">https://demos.scotch.io/visual-guide-to-css3-flexbox-flexbox-playground/demos/</a><br><a target="_blank" rel="noopener" href="https://www.flexboxpatterns.com/">https://www.flexboxpatterns.com/</a></p>
<p>ASStackLayoutSpec 是 Texture Flaxbox 布局的核心，Flexbox旨在为不同屏幕尺寸提供一致的布局。在堆叠布局中，我们可以将物品以垂直或水平堆叠方式对齐。堆栈布局可以是另一个堆栈布局的子布局，这使得使用堆栈布局规范几乎可以创建任何布局。</p>
<h6 id="容器参数"><a href="#容器参数" class="headerlink" title="容器参数"></a>容器参数</h6><p>ASStackLayoutSpec 在ASLayoutElement的基础上加上了7个额外的属性：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1.</span> direction: 指明它的子元素的布局方向</span><br><span class="line"></span><br><span class="line">纵向：ASStackLayoutDirectionVertical</span><br><span class="line">横向：ASStackLayoutDirectionHorizontal</span><br><span class="line"></span><br><span class="line"><span class="bullet">2.</span> spacing:  子元素之间的间距</span><br><span class="line"></span><br><span class="line"><span class="bullet">3.</span> horizontalAlignment: 指定子项水平对齐的方式</span><br><span class="line"><span class="bullet">4.</span> verticalAlignment: 指定子项垂直对齐的方式</span><br><span class="line"><span class="bullet">5.</span> justifyContent: 它定义了沿主轴的对齐方式。</span><br><span class="line"></span><br><span class="line">ASStackLayoutJustifyContentStart 从前端往后端排列</span><br><span class="line">ASStackLayoutJustifyContentCenter 居中排列</span><br><span class="line">ASStackLayoutJustifyContentEnd 从后端往前端排列</span><br><span class="line">ASStackLayoutJustifyContentSpaceBetween 间隔排列，两端无间隔</span><br><span class="line">ASStackLayoutJustifyContentSpaceAround 间隔排列，两端有间隔</span><br><span class="line"></span><br><span class="line"><span class="bullet">6.</span> alignItems: 它定义了沿交叉轴的对齐方式。</span><br><span class="line"></span><br><span class="line">ASStackLayoutAlignItemsStart 从前往后排列</span><br><span class="line">ASStackLayoutAlignItemsEnd 从后往前排列</span><br><span class="line">ASStackLayoutAlignItemsCenter 居中排列</span><br><span class="line">ASStackLayoutAlignItemsStretch 拉伸排列</span><br><span class="line">ASStackLayoutAlignItemsBaselineFirst 以第一个文字元素基线排列（主轴是横向才可用）</span><br><span class="line">ASStackLayoutAlignItemsBaselineLast以最后一个文字元素基线排列（主轴是横向才可用）</span><br><span class="line"></span><br><span class="line">这里需要注意的是主轴和交叉轴的定义，可以看我之前的Flutter分享的内容。</span><br><span class="line"></span><br><span class="line"><span class="bullet">7.</span> flexWrap： 子元素是否堆叠到单行或者多行，默认是堆叠到单行</span><br><span class="line">8: alignContent： 多行的情况下交叉轴的对其方向</span><br></pre></td></tr></table></figure>

<h6 id="节点参数"><a href="#节点参数" class="headerlink" title="节点参数"></a>节点参数</h6><table>
<thead>
<tr>
<th>类型</th>
<th>字段名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>CGFloat</td>
<td>.style.spacingBefore</td>
<td>该对象在堆叠方向的起始部分添加一定的空间</td>
</tr>
<tr>
<td>CGFloat</td>
<td>.style.spacingAfter</td>
<td>该对象在堆叠方向的结束部分添加一定的空间</td>
</tr>
<tr>
<td>CGFloat</td>
<td>.style.flexGrow</td>
<td>如果所有的子节点在堆叠的方向尺寸和小于最小的尺寸，那么作为子节点的当前对象是否需要扩充它的大小</td>
</tr>
<tr>
<td>CGFloat</td>
<td>.style.flexShrink</td>
<td>如果所有的子节点在堆叠的方向尺寸和大于最大的尺寸，那么作为子节点的当前对象是否需要压缩它的大小</td>
</tr>
<tr>
<td>CGFloat</td>
<td>.style.flexBasis</td>
<td>为当前节点设置一个初始大小，但是这个初始大小并不是最终的大小它会受flexGrow&#x2F;flexShrink的设置所影响</td>
</tr>
<tr>
<td>ASStackLayoutAlignSelf</td>
<td>.style.alignSelf</td>
<td>为当前元素指定交叉轴的对齐方向，这个值将会覆盖alignItems</td>
</tr>
<tr>
<td>CGFloat</td>
<td>.style.ascender</td>
<td>这个用于基准线对其的方式，表示从对象的顶部距离它的基准线的尺寸</td>
</tr>
<tr>
<td>CGFloat</td>
<td>.style.descender</td>
<td>这个用于基准线对其的方式，表示从对象的基准线到节点对象底部的尺寸</td>
</tr>
</tbody></table>
<hr>
<h5 id="ASInsetLayoutSpec"><a href="#ASInsetLayoutSpec" class="headerlink" title="ASInsetLayoutSpec"></a>ASInsetLayoutSpec</h5><p>这个相当于在某个布局外面加个空白间距。如果在UIEdgeInsets中将INFINITY设置为一个值，则插入规范将仅使用子内在尺寸，也就是默认的尺寸。</p>
<hr>
<h5 id="ASOverlayLayoutSpec-amp-amp-ASBackgroundLayoutSpec"><a href="#ASOverlayLayoutSpec-amp-amp-ASBackgroundLayoutSpec" class="headerlink" title="ASOverlayLayoutSpec &amp;&amp; ASBackgroundLayoutSpec"></a>ASOverlayLayoutSpec &amp;&amp; ASBackgroundLayoutSpec</h5><p>ASOverlayLayoutSpec 和 ASBackgroundLayoutSpec 为层叠布局，将一个布局叠加在另一个布局上，他们都需要注意的是它们的尺寸是根据基准大小尺寸计算而来的，基准的尺寸会通过constrainedSize传递给它们，所以基准必须要有一个固有的尺寸或者手动设定了它的宽高。对于ASOverlayLayoutSpec它的基准元素是底部的那个元素，对于ASBackgroundLayoutSpec 它的基准元素是顶部的元素。这一点需要注意下</p>
<hr>
<h5 id="ASCenterLayoutSpec"><a href="#ASCenterLayoutSpec" class="headerlink" title="ASCenterLayoutSpec"></a>ASCenterLayoutSpec</h5><p>ASCenterLayoutSpec将其子控件中心置于其最大约束大小内。</p>
<p>如果ASCenterLayoutSpec的宽度或高度不受约束，则会缩小到子组件的大小。<br>ASCenterLayoutSpec有两个属性：</p>
<p>centeringOptions。确定子组件在中心规格内的居中方式。选项包括：无，X​​，Y，XY。<br>sizingOptions。确定ASCenterLayoutSpec将占用多少空间。选项包括：默认，最小X，最小Y，最小XY。</p>
<hr>
<h5 id="ASRatioLayoutSpec"><a href="#ASRatioLayoutSpec" class="headerlink" title="ASRatioLayoutSpec"></a>ASRatioLayoutSpec</h5><p>ASRatioLayoutSpec可以缩放的固定高宽比来布局组件,ASRatioLayoutSpec必须有宽度或高度作为constrainedSize传递给它作为缩放的基数。</p>
<hr>
<h5 id="ASRelativeLayoutSpec"><a href="#ASRelativeLayoutSpec" class="headerlink" title="ASRelativeLayoutSpec"></a>ASRelativeLayoutSpec</h5><p>顾名思义是一个相对布局规范，指定了当前节点相对另一个节点的位置。</p>
<hr>
<h5 id="ASCornerLayoutSpec"><a href="#ASCornerLayoutSpec" class="headerlink" title="ASCornerLayoutSpec"></a>ASCornerLayoutSpec</h5><p>ASCornerLayoutSpec 主要用于像小红点那样角标布局而设计的。</p>
<hr>
<h5 id="ASAbsoluteLayoutSpec"><a href="#ASAbsoluteLayoutSpec" class="headerlink" title="ASAbsoluteLayoutSpec"></a>ASAbsoluteLayoutSpec</h5><p>ASAbsoluteLayoutSpec可以通过设置它们的layoutPosition属性来指定其子项的确切位置（X&#x2F;Y坐标）。绝对布局相对来说比较不灵活很难适配到各种机型。</p>
<h6 id="节点参数-1"><a href="#节点参数-1" class="headerlink" title="节点参数"></a>节点参数</h6><table>
<thead>
<tr>
<th>类型</th>
<th>字段名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>CGFloat</td>
<td>.style.layoutPosition</td>
<td>当前节点在父节点的位置参数</td>
</tr>
</tbody></table>
<h4 id="尺寸创建"><a href="#尺寸创建" class="headerlink" title="尺寸创建"></a>尺寸创建</h4><h5 id="CGFloat-ASDimension"><a href="#CGFloat-ASDimension" class="headerlink" title="CGFloat, ASDimension"></a>CGFloat, ASDimension</h5><p>是一个可以容纳百分比值，像素值的尺寸数据</p>
<p>百分比方式</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ASDimensionMake</span>(@&quot;<span class="number">50%</span>&quot;);  </span><br><span class="line"><span class="built_in">ASDimensionMakeWithFraction</span>(<span class="number">0.5</span>);</span><br></pre></td></tr></table></figure>
<p>像素点方式</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ASDimensionMake</span>(@&quot;<span class="number">70pt</span>&quot;);</span><br><span class="line"><span class="built_in">ASDimensionMake</span>(<span class="number">70</span>);      </span><br><span class="line"><span class="built_in">ASDimensionMakeWithPoints</span>(<span class="number">70</span>);</span><br></pre></td></tr></table></figure>
<p>一般用ASDimensionMakeWithXXX会比较明确，个人比较喜欢这种方式。</p>
<h5 id="CGSize-ASLayoutSize"><a href="#CGSize-ASLayoutSize" class="headerlink" title="CGSize, ASLayoutSize"></a>CGSize, ASLayoutSize</h5><p>和ASDimension类似，它的存在也是为了兼容像素和百分比而存在的，它的宽高元素是ASDimension。它用于.preferredLayoutSize, .minLayoutSize 以及 .maxLayoutSize这些属性中</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="constructor">ASLayoutSizeMake(ASDimension <span class="params">width</span>, ASDimension <span class="params">height</span>)</span>;</span><br></pre></td></tr></table></figure>

<h5 id="ASSizeRange"><a href="#ASSizeRange" class="headerlink" title="ASSizeRange"></a>ASSizeRange</h5><p>ASSizeRange 是由两个CGSize，这两个CGSize决定了某个元素的最小尺寸和最大尺寸区间</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/iOS-%E5%BC%80%E6%BA%90%E5%BA%93%E5%88%86%E6%9E%90/">iOS 开源库分析</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/iOS-开源库分析/">iOS 开源库分析</a>
  </div>

</div>



<div class="comments-count">
	
	  	<span></span>
		<a href="/2019/11/10/Texture-二-基本使用Node及布局/#comments" class="ds-thread-count comments-count-link" data-thread-key="2019/11/10/Texture-二-基本使用Node及布局/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/11/08/Texture-一-简要介绍/" title="Texture 一 简要介绍" itemprop="url">Texture 一 简要介绍</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Edgar" target="_blank" itemprop="author">Edgar</a>
		
  <p class="article-time">
    <time datetime="2019-11-08T03:25:29.000Z" itemprop="datePublished"> Published 2019-11-08</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p><img src="/2019/11/08/Texture-%E4%B8%80-%E7%AE%80%E8%A6%81%E4%BB%8B%E7%BB%8D/texture_logo.png"><br><a target="_blank" rel="noopener" href="https://github.com/texturegroup/texture/">源码地址</a><br><a target="_blank" rel="noopener" href="https://github.com/texturegroup/texture/tree/master/examples">Examples</a><br><a target="_blank" rel="noopener" href="http://texturegroup.org/docs/resources.html">学习资源</a></p>
<h5 id="Texture-的组成"><a href="#Texture-的组成" class="headerlink" title="Texture 的组成"></a>Texture 的组成</h5><p><img src="/2019/11/08/Texture-%E4%B8%80-%E7%AE%80%E8%A6%81%E4%BB%8B%E7%BB%8D/0003.png"></p>
<h5 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h5><p>提到Texture大家可能会比较陌生，但是如果说AsyncDisplayKit估计搞iOS的很多人都会或多或少听到过，我们知道UIKit大多数的布局绘制工作都必须在主线程完成。Texture 中的Node是线程安全的我们可以在后台子线程中完成实例创建整个布局的计算。我们知道如果要保证界面流畅必须保证每秒60帧的帧率，也就是说要在16ms时间内完成所有的布局和绘制代码。但是主线程一般还有如事件相应之类的任务需要处理，所以往往留给布局绘制的时间通常小于10毫秒甚至更少。所以Texture的思路就是将Node设计成线程安全的，并将那些例如node创建，图片解码，文本尺寸计算，渲染等操作可以移到后台子线程的尽量移到后台线程，只有在必须在主线程处理的时候才切换到主线程。</p>
<h5 id="Node-Vs-UIView-Vs-CALayer："><a href="#Node-Vs-UIView-Vs-CALayer：" class="headerlink" title="Node Vs UIView Vs CALayer："></a>Node Vs UIView Vs CALayer：</h5><p>Node,UIView,CALayer 三者的关系如下图所示，详细的介绍会在后面详细张开来介绍。</p>
<p><img src="/2019/11/08/Texture-%E4%B8%80-%E7%AE%80%E8%A6%81%E4%BB%8B%E7%BB%8D/0001.png"></p>
<h5 id="节点-与-节点容器"><a href="#节点-与-节点容器" class="headerlink" title="节点 与 节点容器"></a>节点 与 节点容器</h5><p>Texture中提供的节点有如下几种：</p>
<table>
<thead>
<tr>
<th>Texture</th>
<th>UIView</th>
</tr>
</thead>
<tbody><tr>
<td>ASDisplayNode</td>
<td>等效于UIView,所有Node的父类</td>
</tr>
<tr>
<td>ASCellNode</td>
<td>等效于UITableViewCell和UICollectionViewCell，用于ASTableNode, ASCollectionNode和ASPagerNode</td>
</tr>
<tr>
<td>ASScrollNode</td>
<td>等效于UIScrollView，它用于创建一个包含其他节点的自定义滚动区域</td>
</tr>
<tr>
<td>ASEditableTextNode</td>
<td>等效于UITextView</td>
</tr>
<tr>
<td>ASTextNode</td>
<td>等效于UILabelView</td>
</tr>
<tr>
<td>ASImageNode,ASNetworkImageNode,ASMultiplexImageNode</td>
<td>等效于UIImageView</td>
</tr>
<tr>
<td>ASVideoNode</td>
<td>等效于AVPlayerLayer</td>
</tr>
<tr>
<td>ASVideoPlayerNode</td>
<td>等效于UIMoviePlayer</td>
</tr>
<tr>
<td>ASControlNode</td>
<td>等效于UIControl</td>
</tr>
<tr>
<td>ASButtonNode</td>
<td>等效于UIButton</td>
</tr>
<tr>
<td>ASMapNode</td>
<td>等效于MKMapView</td>
</tr>
</tbody></table>
<p>这些节点和UIVi布局和的区别是所有的node在后台子线程中进行布局和显示，所以主线程可以预留有充足的时间来相应用户交互事件。</p>
<p>Texture中提供的节点容器有如下几种：</p>
<table>
<thead>
<tr>
<th>Texture</th>
<th>UIView</th>
</tr>
</thead>
<tbody><tr>
<td>ASCollectionNode</td>
<td>等效于UICollectionView</td>
</tr>
<tr>
<td>ASTableNode</td>
<td>等效于UITableView</td>
</tr>
<tr>
<td>ASPagerNode</td>
<td>等效于UIPageViewController</td>
</tr>
<tr>
<td>ASViewController</td>
<td>等效于UIViewController</td>
</tr>
<tr>
<td>ASNavigationController</td>
<td>等效于UINavigationController</td>
</tr>
<tr>
<td>ASTabBarController</td>
<td>等效于UITabBarController</td>
</tr>
</tbody></table>
<p>那么节点容器和UIKit中的普通的视图容器优点在哪里呢？这就要提到Texture的智能预加载功能，在每个节点添加到一个滚动的或者翻页界面的时候，在界面滚动的时候，节点的interfaceState会不断改变，这个interfaceState属性是由ASRangeController来完成更新工作的，如果在节点容器外使用节点的话ASRangeController将不会更新节点的状态。这将导致界面上的节点不会感知到界面状态的改变，从而导致界面上闪烁的现象。<br><img src="/2019/11/08/Texture-%E4%B8%80-%E7%AE%80%E8%A6%81%E4%BB%8B%E7%BB%8D/0002.png"></p>
<table>
<thead>
<tr>
<th>状态</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>预加载</td>
<td>这个阶段是从网络或者磁盘加载资源的阶段</td>
</tr>
<tr>
<td>显示</td>
<td>这个阶段主要是完成文本珊格化和图片解码工作</td>
</tr>
<tr>
<td>可见</td>
<td>节点出现在界面上</td>
</tr>
</tbody></table>
<p>这些阶段都有对应的回调节点：</p>
<p>预加载阶段</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="deletion">-didEnterPreloadState</span></span><br><span class="line"><span class="deletion">-didExitPreloadState</span></span><br></pre></td></tr></table></figure>

<p>显示阶段</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="deletion">-didEnterDisplayState</span></span><br><span class="line"><span class="deletion">-didExitDisplayState</span></span><br></pre></td></tr></table></figure>

<p>可见阶段</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="deletion">-didEnterVisibleState</span></span><br><span class="line"><span class="deletion">-didExitVisibleState</span></span><br></pre></td></tr></table></figure>
<h5 id="布局引擎"><a href="#布局引擎" class="headerlink" title="布局引擎"></a>布局引擎</h5><p>Texture中不能使用AutoLayout布局方式，它内部实现了一套基于FlexBox的模式的布局引擎，Flex布局模式目前已经成为了前端UI框架的标配，目前比较流行的Flutter,SwiftUI都有它的影子。</p>
<p>Texture的布局性能介于手动布局和Auto Layout方式布局，并且明显快于Auto Layout,这主要是因为布局可以在后台线程中进行计算，所以不会干扰到用户交互，并且由于布局结果是不可变的数据结构，因此可以在后台预计算和缓存它们。</p>
<p>Texture的布局涉及到两个概念：</p>
<ul>
<li>Layout Specs （布局规范）</li>
</ul>
<figure class="highlight mathematica"><table><tr><td class="code"><pre><span class="line"><span class="variable">Layout</span> <span class="variable">Specs</span> 充当布局容器的角色，主要用于放置<span class="variable">Layout</span> <span class="variable">Elements</span> ，它主要关注的是<span class="variable">Layout</span> <span class="variable">Elements</span> 之间的位置关系。</span><br><span class="line"><span class="built_in">Texture</span> 提供了如下的布局容器：</span><br><span class="line"><span class="variable">ASWrapperLayoutSpec</span></span><br><span class="line"><span class="variable">ASStackLayoutSpec</span></span><br><span class="line"><span class="variable">ASInsetLayoutSpec</span></span><br><span class="line"><span class="variable">ASOverlayLayoutSpec</span></span><br><span class="line"><span class="variable">ASBackgroundLayoutSpec</span></span><br><span class="line"><span class="variable">ASCenterLayoutSpec</span></span><br><span class="line"><span class="variable">ASRatioLayoutSpec</span></span><br><span class="line"><span class="variable">ASRelativeLayoutSpec</span></span><br><span class="line"><span class="variable">ASAbsoluteLayoutSpec</span></span><br><span class="line"><span class="variable">ASCornerLayoutSpec</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>Layout Elements （布局元素）</li>
</ul>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">ASDisplayNodes</span> 和 ASLayoutSpecs 都遵循ASLayoutElement协议，所以ASDisplayNodes 和 ASLayoutSpecs 都可以作为布局元素节点。</span><br></pre></td></tr></table></figure>

<p>这里还需要了解的一个概念是布局元素的固有尺寸<br>有些元素在没有加载元素之前本身是有一个固有尺寸的，这体现在如果我们没有为它添加宽高，它本身就有一个固有宽高值这些Node元素包括：</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">ASImageNode</span></span><br><span class="line"><span class="attribute">ASTextNode</span></span><br><span class="line"><span class="attribute">ASButtonNode</span></span><br></pre></td></tr></table></figure>
<p>反之某些元素在没有加载元素之前是没有尺寸数据的，因此在数据未加载之前可能需要我们给他指定一个宽高，这类元素有：</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">ASVideoNode</span></span><br><span class="line"><span class="attribute">ASVideoPlayerNode</span></span><br><span class="line"><span class="attribute">ASNetworkImageNode</span></span><br><span class="line"><span class="attribute">ASEditableTextNode</span></span><br></pre></td></tr></table></figure>

<h4 id="资料汇总："><a href="#资料汇总：" class="headerlink" title="资料汇总："></a>资料汇总：</h4><p><a target="_blank" rel="noopener" href="https://github.com/texturegroup/texture/">源码地址</a><br><a target="_blank" rel="noopener" href="http://texturegroup.org/">官方文档地址</a><br><a target="_blank" rel="noopener" href="https://github.com/texturegroup/texture/tree/master/examples">Examples</a><br><a target="_blank" rel="noopener" href="http://texturegroup.org/docs/resources.html">官方资源</a><br><a target="_blank" rel="noopener" href="https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/">iOS 保持界面流畅的技巧</a><br><a target="_blank" rel="noopener" href="http://draveness.me/asdk-rendering/">使用 ASDK 性能调优 - 提升 iOS 界面的渲染性能</a><br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/25371361">AsyncDisplayKit 即刻技术团队系列文章</a><br><a target="_blank" rel="noopener" href="https://juejin.im/post/5987cc536fb9a03c4b374bec">AsyncDisplayKit近一年的使用体会及疑难点</a><br><a target="_blank" rel="noopener" href="https://www.raywenderlich.com/818-asyncdisplaykit-2-0-tutorial-getting-started">AsyncDisplayKit 2.0 Tutorial: Getting Started</a><br><a target="_blank" rel="noopener" href="https://blog.gocy.tech/2016/09/10/asdk-sourcecode-reading/">AsyncDisplayKit源码阅读笔记</a><br><a target="_blank" rel="noopener" href="https://farlanki.coding.me/2017/01/10/2017-01-10/">AsyncDisplayKit（一）初识</a><br><a target="_blank" rel="noopener" href="http://beelearning.cn/2017/11/ASDK/">ASDK源码剖析</a></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/iOS-%E5%BC%80%E6%BA%90%E5%BA%93%E5%88%86%E6%9E%90/">iOS 开源库分析</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/iOS-开源库分析/">iOS 开源库分析</a>
  </div>

</div>



<div class="comments-count">
	
	  	<span></span>
		<a href="/2019/11/08/Texture-一-简要介绍/#comments" class="ds-thread-count comments-count-link" data-thread-key="2019/11/08/Texture-一-简要介绍/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/11/08/YYText-使用详解/" title="YYText 使用详解" itemprop="url">YYText 使用详解</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Edgar" target="_blank" itemprop="author">Edgar</a>
		
  <p class="article-time">
    <time datetime="2019-11-07T18:08:04.000Z" itemprop="datePublished"> Published 2019-11-08</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h5 id="开源代码信息"><a href="#开源代码信息" class="headerlink" title="开源代码信息"></a>开源代码信息</h5><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/ibireme/YYText">YYText源码地址</a></li>
</ul>
<h5 id="YYText的使用"><a href="#YYText的使用" class="headerlink" title="YYText的使用"></a>YYText的使用</h5><p><strong><strong>YYLabel特性介绍</strong></strong></p>
<p>YYLabel 是一个只读TextView，它除了具备UILabel所必备的特性外，还支持如下特性：</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="bullet">* </span>支持异步布局和渲染，避免阻塞UI线程</span><br><span class="line"><span class="bullet">* </span>通过扩展CoreText属性来支持更多的文本特效</span><br><span class="line"><span class="bullet">* </span>允许文本和UIImage, UIView 和 CALayer 进行图文混排</span><br><span class="line"><span class="bullet">* </span>允许添加局部用户可交互的高亮链接</span><br><span class="line"><span class="bullet">* </span>允许添加和移除container路径来控制文本container的形状</span><br><span class="line"><span class="bullet">* </span>支持纵向布局显示文本</span><br></pre></td></tr></table></figure>

<p><strong><strong>YYTextView特性介绍</strong></strong></p>
<p>和YYLabel不同的是YYTextView是一个可滚动的，可编辑（当然也可以设置为不可编辑）多行文本控件。</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="bullet">* </span>通过扩展CoreText属性来支持更多的文本特效</span><br><span class="line"><span class="bullet">* </span>允许文本和UIImage, UIView 和 CALayer 进行图文混排</span><br><span class="line"><span class="bullet">* </span>允许添加局部用户可交互的高亮链接</span><br><span class="line"><span class="bullet">* </span>允许添加和移除container路径来控制文本container的形状</span><br><span class="line"><span class="bullet">* </span>支持纵向布局显示文本</span><br><span class="line"><span class="bullet">* </span>允许用户在text view之间复制图像和富文本</span><br><span class="line"><span class="bullet">* </span>可以将属性文本作为占位文本</span><br></pre></td></tr></table></figure>

<p><strong><strong>YYLabel&#x2F;YYTextView 常用属性</strong></strong></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 显示在label上的文本，它和attributedText是互斥的，一旦设置了attributedText 就会覆盖 text</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *text;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> text的文本字体，也会影响到attributedText</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">null_resettable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIFont</span> *font;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> text的颜色，默认是黑色，这个值的设置也会影响到attributedText</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">null_resettable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIColor</span> *textColor;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> text文本阴影的颜色，这个值的设置也会影响到attributedText</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIColor</span> *shadowColor;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 阴影的偏移，默认是CGSizeZero，这个值的设置也会影响到attributedText</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">CGSize</span> shadowOffset;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> text 阴影模糊半径，默认为0，这个值的设置也会影响到attributedText</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">CGFloat</span> shadowBlurRadius;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> text的对齐方式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">NSTextAlignment</span> textAlignment;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 垂直对齐方式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) YYTextVerticalAlignment textVerticalAlignment;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  属性文本内容</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSAttributedString</span> *attributedText;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 断行模式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">NSLineBreakMode</span> lineBreakMode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 在文本被截断的时候，作为截断文本的字符串，默认为“...”</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSAttributedString</span> *truncationToken;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  最大文本行数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">NSUInteger</span> numberOfLines;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 多行文本的推荐宽度，如果文本的宽度超过这个设定值，文本内容将会显示到新的一行或者多行，所以会增加整个文本的高度。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">CGFloat</span> preferredMaxLayoutWidth;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 可以点击的修饰样式</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> UIDataDetectorTypePhoneNumber              手机号码</span></span><br><span class="line"><span class="comment"> UIDataDetectorTypeLink                     URL链接</span></span><br><span class="line"><span class="comment"> UIDataDetectorTypeAddress                  地址</span></span><br><span class="line"><span class="comment"> UIDataDetectorTypeCalendarEvent            日历事件</span></span><br><span class="line"><span class="comment"> UIDataDetectorTypeShipmentTrackingNumber  船舶跟踪号码</span></span><br><span class="line"><span class="comment"> UIDataDetectorTypeFlightNumber            航空号码</span></span><br><span class="line"><span class="comment"> UIDataDetectorTypeLookupSuggestion        用户查询建议</span></span><br><span class="line"><span class="comment"> UIDataDetectorTypeNone                    无修饰样式</span></span><br><span class="line"><span class="comment"> UIDataDetectorTypeAll                     全部样式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">UIDataDetectorTypes</span> dataDetectorTypes;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于修改dataDetectorTypes的样式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="type">id</span>&gt; *linkTextAttributes;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 高亮文本样式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="type">id</span>&gt; *highlightTextAttributes;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户新输入的文本属性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="type">id</span>&gt; *typingAttributes;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  占位文本</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *placeholderText;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 占位文本字体</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIFont</span> *placeholderFont;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 占位文本颜色</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIColor</span> *placeholderTextColor;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 占位文本富文本属性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSAttributedString</span> *placeholderAttributedText;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 当前选择的Range</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">NSRange</span> selectedRange;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 插入的文本是否替换旧有的内容</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="type">BOOL</span> clearsOnInsertion;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 能否选择文本，编辑文本</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">getter</span>=isSelectable) <span class="type">BOOL</span> selectable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 是否可以高亮文本</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">getter</span>=isHighlightable) <span class="type">BOOL</span> highlightable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 是否可编辑</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">getter</span>=isEditable) <span class="type">BOOL</span> editable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 是否允许粘贴图片</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="type">BOOL</span> allowsPasteImage;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 是否允许粘贴富文本</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="type">BOOL</span> allowsPasteAttributedString;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 是否允许复制富文本</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="type">BOOL</span> allowsCopyAttributedString;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">是否允许重做和撤销</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="type">BOOL</span> allowsUndoAndRedo;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 撤销步骤数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">NSUInteger</span> maximumUndoLevel;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在textview获得焦点的时候取代系统键盘的自定义输入view</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readwrite</span>, <span class="keyword">strong</span>) __kindof <span class="built_in">UIView</span> *inputView;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 在textview获得焦点的时候显示在键盘上方的附加view</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readwrite</span>, <span class="keyword">strong</span>) __kindof <span class="built_in">UIView</span> *inputAccessoryView;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果不使用inputAccessoryView属性指定自定义附加view，可以使用它来指定附加view的高度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">CGFloat</span> extraAccessoryViewHeight;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong><strong>一些交互事件</strong></strong></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 点击文本的时候响应Block</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) YYTextAction textTapAction;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 长按文本的时候响应的Block</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) YYTextAction textLongPressAction;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 点击高亮文本的时候执行的动作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) YYTextAction highlightTapAction;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 长按高亮文本时候执行的动作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) YYTextAction highlightLongPressAction;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 文本内间距</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">UIEdgeInsets</span> textContainerInset;</span><br></pre></td></tr></table></figure>

<p><strong><strong>高级用法</strong></strong></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 用于控制布局和渲染代码是否运行在后台线程，默认是不运行在后台线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="type">BOOL</span> displaysAsynchronously;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 当异步显示打开的情况下，在后台渲染进程结束后，layer的内容将会更新，但是如果渲染进程在一个垂直同步时间内</span></span><br><span class="line"><span class="comment"> 不能完成渲染工作，将会保持显示显示旧的内容。我们可以在更新label属性后通过手动将layer.contents设置为nil，或者将这个值设置为YES.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="type">BOOL</span> clearContentsBeforeAsynchronouslyDisplay;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 在文本内容发生改变的时候会有一个动画</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="type">BOOL</span> fadeOnAsynchronouslyDisplay;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">在某些文本高亮的时候呈现一个动画</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="type">BOOL</span> fadeOnHighlight;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 忽略text, font, textColor, attributedText...这些通用的属性，只使用textLayout来显示文本内容</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="type">BOOL</span> ignoreCommonProperties;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>YYText中给定的建议如下：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="keyword">If</span> you <span class="keyword">only</span> need a UILabel alternative <span class="keyword">to</span> display rich <span class="type">text</span> <span class="keyword">and</span> receive link touch event, </span><br><span class="line">   you <span class="keyword">do</span> <span class="keyword">not</span> need <span class="keyword">to</span> adjust the display mode properties.</span><br><span class="line"></span><br><span class="line">   如果你只想要作为UILabel来显示富文本或者接受链接点击事件，我们不需要设置上面的显示模式属性。</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> <span class="keyword">If</span> you have performance issues, you may <span class="keyword">enable</span> the asynchronous display mode</span><br><span class="line">   <span class="keyword">by</span> setting the `displaysAsynchronously` <span class="keyword">to</span> YES.</span><br><span class="line"></span><br><span class="line">   如果我们遇到了性能问题需要提高文本的显示性能，那么可以将displaysAsynchronously设置为YES使用异步显示模式</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> <span class="keyword">If</span> you want <span class="keyword">to</span> <span class="keyword">get</span> the highest performance, you should <span class="keyword">do</span> <span class="type">text</span> layout <span class="keyword">with</span></span><br><span class="line">   `YYTextLayout` <span class="keyword">class</span> <span class="keyword">in</span> background thread. Her<span class="string">e&#x27;s an example:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">   如果我们想获得最高的性能，我们需要在后台使用YYTextLayout来做布局</span></span><br></pre></td></tr></table></figure>

<p>异步绘制会在后面给出例子：</p>
<p><strong><strong>1. 属性文本</strong></strong></p>
<p>属性文本样式设置大家可以查看NSAttributedString+YYText.h文件，我们用得比较多的是<strong><strong>NSMutableAttributedString</strong></strong>，下面只列出用得比较多的，大家使用的时候可以查看NSAttributedString+YYText.h：</p>
<p>基本文本属性:</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 设置全部文本的样式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="type">void</span>)yy_setAttribute:(<span class="built_in">NSString</span> *)name value:(<span class="keyword">nullable</span> <span class="type">id</span>)value;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 设置指定范围的文本样式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="type">void</span>)yy_setAttribute:(<span class="built_in">NSString</span> *)name value:(<span class="keyword">nullable</span> <span class="type">id</span>)value range:(<span class="built_in">NSRange</span>)range;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> The font of the text.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readwrite</span>) <span class="built_in">UIFont</span> *yy_font;</span><br><span class="line">- (<span class="type">void</span>)yy_setFont:(<span class="keyword">nullable</span> <span class="built_in">UIFont</span> *)font range:(<span class="built_in">NSRange</span>)range;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> The foreground color.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readwrite</span>) <span class="built_in">UIColor</span> *yy_color;</span><br><span class="line">- (<span class="type">void</span>)yy_setColor:(<span class="keyword">nullable</span> <span class="built_in">UIColor</span> *)color range:(<span class="built_in">NSRange</span>)range;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> The background color.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readwrite</span>) <span class="built_in">UIColor</span> *yy_backgroundColor;</span><br><span class="line">- (<span class="type">void</span>)yy_setBackgroundColor:(<span class="keyword">nullable</span> <span class="built_in">UIColor</span> *)backgroundColor range:(<span class="built_in">NSRange</span>)range;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> The stroke width.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readwrite</span>) <span class="built_in">NSNumber</span> *yy_strokeWidth;</span><br><span class="line">- (<span class="type">void</span>)yy_setStrokeWidth:(<span class="keyword">nullable</span> <span class="built_in">NSNumber</span> *)strokeWidth range:(<span class="built_in">NSRange</span>)range;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> The stroke color.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readwrite</span>) <span class="built_in">UIColor</span> *yy_strokeColor;</span><br><span class="line">- (<span class="type">void</span>)yy_setStrokeColor:(<span class="keyword">nullable</span> <span class="built_in">UIColor</span> *)strokeColor range:(<span class="built_in">NSRange</span>)range;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> The text shadow.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readwrite</span>) <span class="built_in">NSShadow</span> *yy_shadow;</span><br><span class="line">- (<span class="type">void</span>)yy_setShadow:(<span class="keyword">nullable</span> <span class="built_in">NSShadow</span> *)shadow range:(<span class="built_in">NSRange</span>)range;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> The strikethrough style.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readwrite</span>) <span class="built_in">NSUnderlineStyle</span> yy_strikethroughStyle;</span><br><span class="line">- (<span class="type">void</span>)yy_setStrikethroughStyle:(<span class="built_in">NSUnderlineStyle</span>)strikethroughStyle range:(<span class="built_in">NSRange</span>)range;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> The strikethrough color.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readwrite</span>) <span class="built_in">UIColor</span> *yy_strikethroughColor;</span><br><span class="line">- (<span class="type">void</span>)yy_setStrikethroughColor:(<span class="keyword">nullable</span> <span class="built_in">UIColor</span> *)strikethroughColor range:(<span class="built_in">NSRange</span>)range <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">7</span>_0);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> The underline style.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readwrite</span>) <span class="built_in">NSUnderlineStyle</span> yy_underlineStyle;</span><br><span class="line">- (<span class="type">void</span>)yy_setUnderlineStyle:(<span class="built_in">NSUnderlineStyle</span>)underlineStyle range:(<span class="built_in">NSRange</span>)range;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> The underline color.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readwrite</span>) <span class="built_in">UIColor</span> *yy_underlineColor;</span><br><span class="line">- (<span class="type">void</span>)yy_setUnderlineColor:(<span class="keyword">nullable</span> <span class="built_in">UIColor</span> *)underlineColor range:(<span class="built_in">NSRange</span>)range;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>段落属性</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> An NSParagraphStyle object which is used to specify things like</span></span><br><span class="line"><span class="comment"> line alignment, tab rulers, writing direction, etc.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readwrite</span>) <span class="built_in">NSParagraphStyle</span> *yy_paragraphStyle;</span><br><span class="line">- (<span class="type">void</span>)yy_setParagraphStyle:(<span class="keyword">nullable</span> <span class="built_in">NSParagraphStyle</span> *)paragraphStyle range:(<span class="built_in">NSRange</span>)range;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 文本对齐方式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readwrite</span>) <span class="built_in">NSTextAlignment</span> yy_alignment;</span><br><span class="line">- (<span class="type">void</span>)yy_setAlignment:(<span class="built_in">NSTextAlignment</span>)alignment range:(<span class="built_in">NSRange</span>)range;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 断行模式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readwrite</span>) <span class="built_in">NSLineBreakMode</span> yy_lineBreakMode;</span><br><span class="line">- (<span class="type">void</span>)yy_setLineBreakMode:(<span class="built_in">NSLineBreakMode</span>)lineBreakMode range:(<span class="built_in">NSRange</span>)range;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 行间距</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readwrite</span>) <span class="built_in">CGFloat</span> yy_lineSpacing;</span><br><span class="line">- (<span class="type">void</span>)yy_setLineSpacing:(<span class="built_in">CGFloat</span>)lineSpacing range:(<span class="built_in">NSRange</span>)range;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 段落间距</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readwrite</span>) <span class="built_in">CGFloat</span> yy_paragraphSpacing;</span><br><span class="line">- (<span class="type">void</span>)yy_setParagraphSpacing:(<span class="built_in">CGFloat</span>)paragraphSpacing range:(<span class="built_in">NSRange</span>)range;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 段落前间距</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readwrite</span>) <span class="built_in">CGFloat</span> yy_paragraphSpacingBefore;</span><br><span class="line">- (<span class="type">void</span>)yy_setParagraphSpacingBefore:(<span class="built_in">CGFloat</span>)paragraphSpacingBefore range:(<span class="built_in">NSRange</span>)range;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  首行间距</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readwrite</span>) <span class="built_in">CGFloat</span> yy_firstLineHeadIndent;</span><br><span class="line">- (<span class="type">void</span>)yy_setFirstLineHeadIndent:(<span class="built_in">CGFloat</span>)firstLineHeadIndent range:(<span class="built_in">NSRange</span>)range;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 最小高度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readwrite</span>) <span class="built_in">CGFloat</span> yy_minimumLineHeight;</span><br><span class="line">- (<span class="type">void</span>)yy_setMinimumLineHeight:(<span class="built_in">CGFloat</span>)minimumLineHeight range:(<span class="built_in">NSRange</span>)range;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 最大高度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readwrite</span>) <span class="built_in">CGFloat</span> yy_maximumLineHeight;</span><br><span class="line">- (<span class="type">void</span>)yy_setMaximumLineHeight:(<span class="built_in">CGFloat</span>)maximumLineHeight range:(<span class="built_in">NSRange</span>)range;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>简单的一个例子：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//1.创建一个属性文本</span></span><br><span class="line"><span class="type">NSMutableAttributedString</span> <span class="operator">*</span>attributeStr <span class="operator">=</span> [[<span class="type">NSMutableAttributedString</span> alloc] initWithString:@<span class="string">&quot;测试文本，测试文本测试文本测试文本测试文本测试文本测试文本测试文本&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.为文本设置属性</span></span><br><span class="line">attributeStr.yy_font <span class="operator">=</span> [<span class="type">UIFont</span> boldSystemFontOfSize:<span class="number">18.0</span>];</span><br><span class="line">[attributeStr yy_setColor:[<span class="type">UIColor</span> blueColor] range:<span class="type">NSMakeRange</span>(<span class="number">0</span>, <span class="number">50</span>)];</span><br><span class="line">attributeStr.yy_lineSpacing <span class="operator">=</span> <span class="number">20.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.赋值给YYLabel</span></span><br><span class="line"><span class="type">YYLabel</span> <span class="operator">*</span>yyLabel <span class="operator">=</span> [[<span class="type">YYLabel</span> alloc] <span class="keyword">init</span>];</span><br><span class="line">yyLabel.attributedText <span class="operator">=</span> attributeStr;</span><br><span class="line">yyLabel.numberOfLines <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">yyLabel.frame <span class="operator">=</span> <span class="type">CGRectMake</span>(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="keyword">self</span>.view.bounds.size.width, <span class="number">400.0</span>);</span><br><span class="line">[<span class="keyword">self</span>.view addSubview:yyLabel];</span><br></pre></td></tr></table></figure>

<p><strong><strong>2. 文本高亮</strong></strong></p>
<p>使用YYText还可以为某些文本指定高亮文本样式，默认的是浅蓝色的文本，如果是常见的比如电话号码之类的可以使用UIDataDetectorTypes来快速指定，但是如果是自定义的则可以有两种方式可以指定高亮文本：<br>一种是通过<strong><strong>yy_setTextHighlightRange</strong></strong>来指定，但是这种方式能设置的样式比较有限，只能设置前景色和背景色，但是对于一般的需求是足够用了：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> Convenience method to set text highlight</span></span><br><span class="line"><span class="comment"> @param range           text range</span></span><br><span class="line"><span class="comment"> @param color           text color (pass nil to ignore)</span></span><br><span class="line"><span class="comment"> @param backgroundColor text background color when highlight</span></span><br><span class="line"><span class="comment"> @param userInfo        user information dictionary (pass nil to ignore)</span></span><br><span class="line"><span class="comment"> @param tapAction       tap action when user tap the highlight (pass nil to ignore)</span></span><br><span class="line"><span class="comment"> @param longPressAction long press action when user long press the highlight (pass nil to ignore)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="type">void</span>)yy_setTextHighlightRange:(<span class="built_in">NSRange</span>)range</span><br><span class="line">                           color:(<span class="keyword">nullable</span> <span class="built_in">UIColor</span> *)color</span><br><span class="line">                 backgroundColor:(<span class="keyword">nullable</span> <span class="built_in">UIColor</span> *)backgroundColor</span><br><span class="line">                        userInfo:(<span class="keyword">nullable</span> <span class="built_in">NSDictionary</span> *)userInfo</span><br><span class="line">                       tapAction:(<span class="keyword">nullable</span> YYTextAction)tapAction</span><br><span class="line">                 longPressAction:(<span class="keyword">nullable</span> YYTextAction)longPressAction;</span><br></pre></td></tr></table></figure>

<p>另一种是借助<strong><strong>YYTextHighlight</strong></strong>，下面是YYTextHighlight所能设置的属性：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">+ (instancetype)highlightWithBackgroundColor:(nullable UIColor *)color;</span><br><span class="line">- (void)setFont:(nullable UIFont *)font;</span><br><span class="line">- (void)setColor:(nullable UIColor *)color;</span><br><span class="line">- (void)setStrokeWidth:(nullable NSNumber *)width;</span><br><span class="line">- (void)setStrokeColor:(nullable UIColor *)color;</span><br><span class="line">- (void)setShadow:(nullable YYTextShadow *)shadow;</span><br><span class="line">- (void)setInnerShadow:(nullable YYTextShadow *)shadow;</span><br><span class="line">- (void)setUnderline:(nullable YYTextDecoration *)underline;</span><br><span class="line">- (void)setStrikethrough:(nullable YYTextDecoration *)strikethrough;</span><br><span class="line">- (void)setBackgroundBorder:(nullable YYTextBorder *)border;</span><br><span class="line">- (void)setBorder:(nullable YYTextBorder *)border;</span><br><span class="line">- (void)setAttachment:(nullable YYTextAttachment *)attachment;</span><br><span class="line"><span class="keyword">@property</span> (nullable, nonatomic, copy) YYTextAction tapAction;</span><br><span class="line"><span class="keyword">@property</span> (nullable, nonatomic, copy) YYTextAction longPressAction;</span><br></pre></td></tr></table></figure>

<p>这里涉及到了YYTextBorder，它其实就是一个文本的外框，可以给选中的文本添加外框样式：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YYTextBorder</span> : <span class="title">NSObject</span> &lt;<span class="title">NSCoding</span>, <span class="title">NSCopying</span>&gt;</span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)borderWithLineStyle:(YYTextLineStyle)lineStyle lineWidth:(<span class="built_in">CGFloat</span>)width strokeColor:(<span class="keyword">nullable</span> <span class="built_in">UIColor</span> *)color;</span><br><span class="line">+ (<span class="keyword">instancetype</span>)borderWithFillColor:(<span class="keyword">nullable</span> <span class="built_in">UIColor</span> *)color cornerRadius:(<span class="built_in">CGFloat</span>)cornerRadius;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) YYTextLineStyle lineStyle;              <span class="comment">///&lt; border line style</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">CGFloat</span> strokeWidth;                    <span class="comment">///&lt; border line width</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIColor</span> *strokeColor; <span class="comment">///&lt; border line color</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">CGLineJoin</span> lineJoin;                    <span class="comment">///&lt; border line join</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">UIEdgeInsets</span> insets;                    <span class="comment">///&lt; border insets for text bounds</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">CGFloat</span> cornerRadius;                   <span class="comment">///&lt; border corder radius</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) YYTextShadow *shadow; <span class="comment">///&lt; border shadow</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIColor</span> *fillColor;   <span class="comment">///&lt; inner fill color</span></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>简单的例子：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.创建一个属性文本</span></span><br><span class="line"><span class="type">NSMutableAttributedString</span> <span class="operator">*</span>attributeStr <span class="operator">=</span> [[<span class="type">NSMutableAttributedString</span> alloc] initWithString:@<span class="string">&quot;旧时月色,算几番照我,梅边吹笛?唤起玉人,不管清寒与攀摘.何逊而今渐老,都忘却,春风词笔.但怪得,竹外疏花,春冷入瑶席.江国,正寂寂.叹寄与路遥,夜雪初积.翠尊易泣,红萼无言耿相忆.常记曾携手处,千树压.梅湖寒碧,又片片吹尽也,何时得见? &quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.为文本设置属性</span></span><br><span class="line">attributeStr.yy_font <span class="operator">=</span> [<span class="type">UIFont</span> boldSystemFontOfSize:<span class="number">18.0</span>];</span><br><span class="line">attributeStr.yy_lineSpacing <span class="operator">=</span> <span class="number">20.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.创建高亮属性</span></span><br><span class="line"><span class="type">YYTextBorder</span> <span class="operator">*</span>border <span class="operator">=</span> [<span class="type">YYTextBorder</span> borderWithFillColor:[<span class="type">UIColor</span> magentaColor] cornerRadius:<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">YYTextHighlight</span> <span class="operator">*</span>highlight <span class="operator">=</span> [[<span class="type">YYTextHighlight</span> alloc] <span class="keyword">init</span>];</span><br><span class="line">[highlight setColor:[<span class="type">UIColor</span> blueColor]];</span><br><span class="line">[highlight setBackgroundBorder:border];</span><br><span class="line">highlight.tapAction <span class="operator">=</span> <span class="operator">^</span>(<span class="type">UIView</span> <span class="operator">*</span>containerView, <span class="type">NSAttributedString</span> <span class="operator">*</span>text, <span class="type">NSRange</span> range, <span class="type">CGRect</span> rect) &#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.设置文本的高亮属性</span></span><br><span class="line">[attributeStr yy_setTextHighlight:highlight range:<span class="type">NSMakeRange</span>(<span class="number">0</span>, <span class="number">150</span>)];</span><br><span class="line"></span><br><span class="line"><span class="comment">//5.赋值给YYLabel</span></span><br><span class="line"><span class="type">YYLabel</span> <span class="operator">*</span>yyLabel <span class="operator">=</span> [[<span class="type">YYLabel</span> alloc] <span class="keyword">init</span>];</span><br><span class="line">yyLabel.attributedText <span class="operator">=</span> attributeStr;</span><br><span class="line">yyLabel.numberOfLines <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">yyLabel.frame <span class="operator">=</span> <span class="type">CGRectMake</span>(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="keyword">self</span>.view.bounds.size.width, <span class="number">400.0</span>);</span><br><span class="line">[<span class="keyword">self</span>.view addSubview:yyLabel];</span><br></pre></td></tr></table></figure>

<p><strong><strong>3. 图文混排</strong></strong></p>
<p>YYText对我个人来说最大的用途除了高亮文本外就应该属图文混排了。YYText支持将UIView,CALayer,UIImage作为富文本添加到其他富文本中。用得比较多的是如下的接口：</p>
<figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">/<span class="symbol">*</span><span class="symbol">*</span></span><br><span class="line"> Creates and returns an attachment.</span><br><span class="line"> Example: ContentMode:bottom Alignment:Top.</span><br><span class="line">      The text      The attachment holder</span><br><span class="line">         ↓                ↓</span><br><span class="line">     ─────────┌──────────────────────┐───────</span><br><span class="line">        / \   │                      │ / ___|<span class="string"></span></span><br><span class="line"><span class="string">       / _ \  │                      │</span>|<span class="string"> </span>|</span><br><span class="line">      / ___ \ │                      │|<span class="string"> </span>|<span class="string">___     ←── The text line</span></span><br><span class="line"><span class="string">     /_/   \_\│    ██████████████    │ \____</span>|</span><br><span class="line">     ─────────│    ██████████████    │───────</span><br><span class="line">              │    ██████████████    │</span><br><span class="line">              │    ██████████████ ←───────────────── The attachment content</span><br><span class="line">              │    ██████████████    │</span><br><span class="line">              └──────────────────────┘</span><br><span class="line"></span><br><span class="line"> <span class="meta">@param</span> content        The attachment (UIImage/UIView/CALayer).</span><br><span class="line"> <span class="meta">@param</span> contentMode    The attachment&#x27;s content mode in attachment holder</span><br><span class="line"> <span class="meta">@param</span> attachmentSize The attachment holder&#x27;s size in text layout.</span><br><span class="line"> <span class="meta">@param</span> fontSize       The attachment will align to this font.</span><br><span class="line"> <span class="meta">@param</span> alignment      The attachment holder&#x27;s alignment to text line.</span><br><span class="line"> </span><br><span class="line"> <span class="meta">@return</span> An attributed string, or nil if an error occurs.</span><br><span class="line"> <span class="meta">@since</span> YYText:6.0</span><br><span class="line"> <span class="symbol">*</span>/</span><br><span class="line">+ (NSMutableAttributedString <span class="symbol">*</span>)yy_attachmentStringWithContent:(nullable id)content</span><br><span class="line">                                                  contentMode:(UIViewContentMode)contentMode</span><br><span class="line">                                               attachmentSize:(CGSize)attachmentSize</span><br><span class="line">                                                  alignToFont:(UIFont <span class="symbol">*</span>)font</span><br><span class="line">                                                    alignment:(YYTextVerticalAlignment)alignment;</span><br></pre></td></tr></table></figure>

<p>下面是一个简单例子：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">NSMutableAttributedString</span> <span class="operator">*</span>text <span class="operator">=</span> [[<span class="type">NSMutableAttributedString</span> alloc] initWithString:@<span class="string">&quot;图片前面的文本&quot;</span>];</span><br><span class="line"><span class="type">UIFont</span> <span class="operator">*</span>font <span class="operator">=</span> [<span class="type">UIFont</span> systemFontOfSize:<span class="number">18</span>];</span><br><span class="line"><span class="comment">// 嵌入 UIImage</span></span><br><span class="line"><span class="type">UIImage</span> <span class="operator">*</span>image <span class="operator">=</span> [<span class="type">UIImage</span> imageNamed:@<span class="string">&quot;image&quot;</span>];</span><br><span class="line"><span class="type">NSMutableAttributedString</span> <span class="operator">*</span>attachment <span class="operator">=</span> <span class="literal">nil</span>;</span><br><span class="line">attachment <span class="operator">=</span> [<span class="type">NSMutableAttributedString</span> yy_attachmentStringWithContent:image contentMode:<span class="type">UIViewContentModeCenter</span> attachmentSize:image.size alignToFont:font alignment:<span class="type">YYTextVerticalAlignmentCenter</span>];</span><br><span class="line">[text appendAttributedString: attachment];</span><br><span class="line"></span><br><span class="line"><span class="type">NSMutableAttributedString</span> <span class="operator">*</span>text1 <span class="operator">=</span> [[<span class="type">NSMutableAttributedString</span> alloc] initWithString:@<span class="string">&quot;图片后面的文本&quot;</span>];</span><br><span class="line">[text appendAttributedString: text1];</span><br><span class="line"></span><br><span class="line"><span class="type">YYLabel</span> <span class="operator">*</span>yyLabel <span class="operator">=</span> [[<span class="type">YYLabel</span> alloc] <span class="keyword">init</span>];</span><br><span class="line">yyLabel.attributedText <span class="operator">=</span> text;</span><br><span class="line">yyLabel.numberOfLines <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">yyLabel.textColor <span class="operator">=</span> [<span class="type">UIColor</span> blueColor];</span><br><span class="line">yyLabel.font <span class="operator">=</span> [<span class="type">UIFont</span> boldSystemFontOfSize:<span class="number">20.0</span>];</span><br><span class="line">yyLabel.frame <span class="operator">=</span> <span class="type">CGRectMake</span>(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="keyword">self</span>.view.bounds.size.width, <span class="number">400.0</span>);</span><br><span class="line">[<span class="keyword">self</span>.view addSubview:yyLabel];</span><br></pre></td></tr></table></figure>

<p><strong><strong>4. 文本容器</strong></strong></p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> The YYTextContainer <span class="built_in">class</span> defines a region <span class="keyword">in</span> which <span class="built_in">text</span> <span class="keyword">is</span> laid out.</span><br><span class="line"> YYTextLayout <span class="built_in">class</span> uses one <span class="keyword">or</span> more YYTextContainer objects <span class="keyword">to</span> generate layouts.</span><br><span class="line"> </span><br><span class="line"> A YYTextContainer defines rectangular regions (`size` <span class="keyword">and</span> `insets`) <span class="keyword">or</span> </span><br><span class="line"> nonrectangular shapes (`path`), <span class="keyword">and</span> you can define exclusion paths inside <span class="keyword">the</span> </span><br><span class="line"> <span class="built_in">text</span> container&#x27;s bounding rectangle so <span class="keyword">that</span> <span class="built_in">text</span> flows <span class="keyword">around</span> <span class="keyword">the</span> exclusion </span><br><span class="line"> path <span class="keyword">as</span> <span class="keyword">it</span> <span class="keyword">is</span> laid out.</span><br><span class="line"> </span><br><span class="line"> All methods <span class="keyword">in</span> this <span class="built_in">class</span> <span class="keyword">is</span> thread-safe.</span><br><span class="line"> </span><br><span class="line"> Example:</span><br><span class="line"> </span><br><span class="line">     ┌─────────────────────────────┐  &lt;<span class="comment">------- container</span></span><br><span class="line">     │                             │</span><br><span class="line">     │    asdfasdfasdfasdfasdfa   &lt;<span class="comment">------------ container insets</span></span><br><span class="line">     │    asdfasdfa   asdfasdfa    │</span><br><span class="line">     │    asdfas         asdasd    │</span><br><span class="line">     │    asdfa        &lt;<span class="comment">----------------------- container exclusion path</span></span><br><span class="line">     │    asdfas         adfasd    │</span><br><span class="line">     │    asdfasdfa   asdfasdfa    │</span><br><span class="line">     │    asdfasdfasdfasdfasdfa    │</span><br><span class="line">     │                             │</span><br><span class="line">     └─────────────────────────────┘</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>
<p>我们的布局都是基于文本容器的，YYTextContainer可以用size和inset指定规则的文本容器，可以使用path来指定不规则的文本容器，还可以通过exclusion在已有的容器中挖去一个形状。<br>我们用得比较多的是规则的矩形：</p>
<p>可以通过下面来获得对应的YYTextContainer：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// Creates a container with the specified size and insets. @param size The size. @param insets The text insets.</span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)containerWithSize:(<span class="built_in">CGSize</span>)size insets:(<span class="built_in">UIEdgeInsets</span>)insets;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Creates a container with the specified path. @param size The path.</span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)containerWithPath:(<span class="keyword">nullable</span> <span class="built_in">UIBezierPath</span> *)path;</span><br></pre></td></tr></table></figure>

<p><strong><strong>5. 文本布局计算</strong></strong></p>
<p>YYTextLayout是负责YYText的布局的类，它可以基于上面介绍的YYTextContainer还可以基于CGSize进行布局，除了少量绘制方法外大多数的属性是只读的线程安全的。</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> YYTextLayout <span class="built_in">class</span> <span class="keyword">is</span> a readonly <span class="built_in">class</span> stores <span class="built_in">text</span> layout <span class="literal">result</span>.</span><br><span class="line"> All <span class="keyword">the</span> <span class="keyword">property</span> <span class="keyword">in</span> this <span class="built_in">class</span> <span class="keyword">is</span> readonly, <span class="keyword">and</span> should <span class="keyword">not</span> be changed.</span><br><span class="line"> The methods <span class="keyword">in</span> this <span class="built_in">class</span> <span class="keyword">is</span> thread-safe (except <span class="keyword">some</span> <span class="keyword">of</span> <span class="keyword">the</span> draw methods).</span><br><span class="line"> example: (layout <span class="keyword">with</span> a circle exclusion path)</span><br><span class="line"> </span><br><span class="line">     ┌──────────────────────────┐  &lt;<span class="comment">------ container</span></span><br><span class="line">     │ [<span class="comment">--------Line0--------]  │  &lt;- Row0</span></span><br><span class="line">     │ [<span class="comment">--------Line1--------]  │  &lt;- Row1</span></span><br><span class="line">     │ [-Line2-]     [-Line3-]  │  &lt;- Row2</span><br><span class="line">     │ [-Line4]       [Line5-]  │  &lt;- Row3</span><br><span class="line">     │ [-Line6-]     [-Line7-]  │  &lt;- Row4</span><br><span class="line">     │ [<span class="comment">--------Line8--------]  │  &lt;- Row5</span></span><br><span class="line">     │ [<span class="comment">--------Line9--------]  │  &lt;- Row6</span></span><br><span class="line">     └──────────────────────────┘</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>

<p>下面是最常用的两个布局方法：</p>
<figure class="highlight vbnet"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> Generate a layout <span class="keyword">with</span> the given container size <span class="built_in">and</span> <span class="keyword">text</span>.</span><br><span class="line"></span><br><span class="line"> @param size The <span class="keyword">text</span> container<span class="comment">&#x27;s size</span></span><br><span class="line"> @param <span class="keyword">text</span> The <span class="keyword">text</span> (<span class="keyword">if</span> nil, returns nil).</span><br><span class="line"> @<span class="keyword">return</span> A <span class="built_in">new</span> layout, <span class="built_in">or</span> nil <span class="keyword">when</span> an <span class="keyword">error</span> occurs.</span><br><span class="line">*/</span><br><span class="line">+ (nullable YYTextLayout *)layoutWithContainerSize:(CGSize)size <span class="keyword">text</span>:(NSAttributedString *)<span class="keyword">text</span>;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> Generate a layout <span class="keyword">with</span> the given container <span class="built_in">and</span> <span class="keyword">text</span>.</span><br><span class="line"> </span><br><span class="line"> @param container The <span class="keyword">text</span> container (<span class="keyword">if</span> nil, returns nil).</span><br><span class="line"> @param <span class="keyword">text</span>      The <span class="keyword">text</span> (<span class="keyword">if</span> nil, returns nil).</span><br><span class="line"> @<span class="keyword">return</span> A <span class="built_in">new</span> layout, <span class="built_in">or</span> nil <span class="keyword">when</span> an <span class="keyword">error</span> occurs.</span><br><span class="line"> */</span><br><span class="line">+ (nullable YYTextLayout *)layoutWithContainer:(YYTextContainer *)container <span class="keyword">text</span>:(NSAttributedString *)<span class="keyword">text</span>;</span><br></pre></td></tr></table></figure>

<p>第一个基于规定尺寸的，第二个是基于文本容器的。</p>
<p>布局后用得比较多的属性如下：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">///&lt; Bounding rect (glyphs)</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">CGRect</span> textBoundingRect;</span><br><span class="line"><span class="comment">///&lt; Bounding size (glyphs and insets, ceil to pixel)</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">CGSize</span> textBoundingSize;</span><br><span class="line"><span class="comment">///&lt; Number of rows</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSUInteger</span> rowCount;</span><br></pre></td></tr></table></figure>
<p>第一个是布局后文本的位置，第二个是文本的尺寸，最后一个是行数。下面是一个简单的用法：</p>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line">CGSize size = CGSizeMake(<span class="number">300</span>, CGFLOAT_MAX);</span><br><span class="line">YYTextLayout *layout = [YYTextLayout layoutWithContainerSize:size <span class="literal">text</span>:<span class="literal">text</span>];</span><br><span class="line">YYLabel *<span class="keyword">label</span> = [[YYLabel alloc] init];</span><br><span class="line"><span class="keyword">label</span>.textColor = [UIColor blueColor];</span><br><span class="line"><span class="keyword">label</span>.frame = CGRectMake(<span class="number">0.0</span>, <span class="number">0.0</span>, self.<span class="keyword">view</span>.bounds.size.<span class="literal">width</span>, <span class="number">400.0</span>);</span><br><span class="line"><span class="keyword">label</span>.attributedText= <span class="literal">text</span>;</span><br><span class="line"><span class="keyword">label</span>.textLayout = layout;</span><br><span class="line">[self.<span class="keyword">view</span> addSubview:<span class="keyword">label</span>];</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong><strong>6. 文本行位置调整</strong></strong></p>
<p>由于中文、英文、Emoji 高度不一致，或者富文本中出现了不同字号的字体；可能会造成每行文字的高度不一致。可以添加一个修改器来解决这个问题：</p>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">UILabel *<span class="keyword">label</span> = [[UILabel alloc] init];</span><br><span class="line"><span class="keyword">label</span>.<span class="literal">text</span> = @<span class="string">&quot;fsfdsfsdfsdffsfdsfsdfsdffsfdsfsdfsdffsfdsfsdfsdffsfdsfsdfsdffsfdsfsdfsdffsfdsfsdfsdffsfdsfsdfsdf我们women！！！☆★☆★☆★(=@__@=) O(∩_∩)O~我们women！！！我们women！！！我们women！！！ (*^__^*)☆★☆★☆★我们women！！！我们women！！！我们women！！！我们women！！！我们women！！！&quot;</span>;</span><br><span class="line"><span class="keyword">label</span>.numberOfLines = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">label</span>.frame = CGRectMake(<span class="number">0.0</span>, <span class="number">0.0</span>, self.<span class="keyword">view</span>.bounds.size.<span class="literal">width</span>, <span class="number">400.0</span>);</span><br><span class="line"><span class="keyword">label</span>.textColor = [UIColor blueColor];</span><br><span class="line"><span class="keyword">label</span>.font = [UIFont boldSystemFontOfSize:<span class="number">20.0</span>];</span><br><span class="line">[self.<span class="keyword">view</span> addSubview:<span class="keyword">label</span>];</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong><strong>7. 异步排版和渲染</strong></strong></p>
<p>下面是官方给出的一个例子：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">YYLabel *label = [YYLabel new];</span><br><span class="line">label.displaysAsynchronously = <span class="literal">YES</span>;</span><br><span class="line">label.ignoreCommonProperties = <span class="literal">YES</span>;</span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">    <span class="comment">// Create attributed string.</span></span><br><span class="line">    <span class="built_in">NSMutableAttributedString</span> *text = [[<span class="built_in">NSMutableAttributedString</span> alloc] initWithString:<span class="string">@&quot;Some Text&quot;</span>];</span><br><span class="line">    text.yy_font = [<span class="built_in">UIFont</span> systemFontOfSize:<span class="number">16</span>];</span><br><span class="line">    text.yy_color = [<span class="built_in">UIColor</span> grayColor];</span><br><span class="line">    [text yy_setColor:[<span class="built_in">UIColor</span> redColor] range:<span class="built_in">NSMakeRange</span>(<span class="number">0</span>, <span class="number">4</span>)];</span><br><span class="line">    <span class="comment">// Create text container</span></span><br><span class="line">    YYTextContainer *container = [YYTextContainer new];</span><br><span class="line">    container.size = <span class="built_in">CGSizeMake</span>(<span class="number">100</span>, <span class="built_in">CGFLOAT_MAX</span>);</span><br><span class="line">    container.maximumNumberOfRows = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// Generate a text layout.</span></span><br><span class="line">    YYTextLayout *layout = [YYTextLayout layoutWithContainer:container text:text];</span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        label.size = layout.textBoundingSize;</span><br><span class="line">        label.textLayout = layout;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong><strong>8. 文本解析</strong></strong></p>
<p>YYTextParser用于text的解析，YYText默认内置了<strong><strong>YYTextSimpleMarkdownParser</strong></strong>，<strong><strong>YYTextSimpleEmoticonParser</strong></strong>两种文本解析器。分别用于解析Markdown和Emoj表情。#pragma endregion<br>如果想要自定义文本解析器则只要遵循YYTextParser协议，并覆写如下方法：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 当文本改变的时候会调用这个方法</span></span><br><span class="line"><span class="comment"> @param text  最初的富文本，这个方法会解析这个文本，并且修改它的内容</span></span><br><span class="line"><span class="comment"> @param selectedRange  当前选择的文本内容</span></span><br><span class="line"><span class="comment"> 如果文本修改了就返回YES,如果没有修改则返回NO</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="type">BOOL</span>)parseText:(<span class="keyword">nullable</span> <span class="built_in">NSMutableAttributedString</span> *)text selectedRange:(<span class="keyword">nullable</span> <span class="built_in">NSRangePointer</span>)selectedRange;</span><br></pre></td></tr></table></figure>

<figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line">// 内置简单的表情解析</span><br><span class="line"><span class="symbol">YYTextSimpleEmoticonParser</span> *parser = [<span class="symbol">YYTextSimpleEmoticonParser</span> new];</span><br><span class="line"><span class="symbol">NSMutableDictionary</span> *mapper = [<span class="symbol">NSMutableDictionary</span> new];</span><br><span class="line">mapper[@<span class="string">&quot;:smile:&quot;</span>] = [<span class="symbol">UIImage</span> imageNamed:@<span class="string">&quot;smile.png&quot;</span>];</span><br><span class="line">mapper[@<span class="string">&quot;:cool:&quot;</span>] = [<span class="symbol">UIImage</span> imageNamed:@<span class="string">&quot;cool.png&quot;</span>];</span><br><span class="line">mapper[@<span class="string">&quot;:cry:&quot;</span>] = [<span class="symbol">UIImage</span> imageNamed:@<span class="string">&quot;cry.png&quot;</span>];</span><br><span class="line">mapper[@<span class="string">&quot;:wink:&quot;</span>] = [<span class="symbol">UIImage</span> imageNamed:@<span class="string">&quot;wink.png&quot;</span>];</span><br><span class="line">parser.emoticonMapper = mapper;</span><br><span class="line"></span><br><span class="line">// 内置简单的 markdown 解析</span><br><span class="line"><span class="symbol">YYTextSimpleMarkdownParser</span> *parser = [<span class="symbol">YYTextSimpleMarkdownParser</span> new];</span><br><span class="line">[parser setColorWithDarkTheme];</span><br><span class="line"></span><br><span class="line">// 实现 <span class="string">`YYTextParser`</span> 协议的自定义解析器</span><br><span class="line"><span class="symbol">MyCustomParser</span> *parser = ... </span><br><span class="line"></span><br><span class="line">// <span class="number">2.</span> 把解析器添加到 <span class="symbol">YYLabel</span> 或 <span class="symbol">YYTextView</span></span><br><span class="line"><span class="symbol">YYLabel</span> *label = ...</span><br><span class="line">label.textParser = parser;</span><br><span class="line"></span><br><span class="line"><span class="symbol">YYTextView</span> *textView = ...</span><br><span class="line">textView.textParser = parser;</span><br></pre></td></tr></table></figure>
<p><strong><strong>9. YYTextBinding</strong></strong></p>
<p>YYTextBinding 用于将某些文本绑定在一起，在文本选择或者编辑的时候看作一个字符整体对待。</p>
<figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line"><span class="symbol">UIFont</span> *font = [<span class="symbol">UIFont</span> boldSystemFontOfSize:<span class="number">16</span>];</span><br><span class="line">for (int i = <span class="number">0</span>; i &lt; tags.count; i++) &#123;</span><br><span class="line">    <span class="symbol">NSString</span> *tag = tags[i];</span><br><span class="line">    <span class="symbol">NSMutableAttributedString</span> *tagText = [[<span class="symbol">NSMutableAttributedString</span> alloc] initWithString:tag];</span><br><span class="line">    tagText.yy_font = font;</span><br><span class="line">    tagText.yy_color = [<span class="symbol">UIColor</span> whiteColor];</span><br><span class="line">    [tagText yy_setTextBinding:[<span class="symbol">YYTextBinding</span> bindingWithDeleteConfirm:<span class="symbol">NO</span>] range:tagText.yy_rangeOfAll];</span><br><span class="line">    </span><br><span class="line">    <span class="symbol">YYTextBorder</span> *border = [<span class="symbol">YYTextBorder</span> new];</span><br><span class="line">    border.strokeWidth = <span class="number">1.5</span>;</span><br><span class="line">    border.strokeColor = tagStrokeColors[i];</span><br><span class="line">    border.fillColor = tagFillColors[i];</span><br><span class="line">    border.cornerRadius = <span class="number">100</span>;</span><br><span class="line">    border.lineJoin = kCGLineJoinBevel;</span><br><span class="line">    border.insets = <span class="symbol">UIEdgeInsetsMake</span>(<span class="number">-2</span>, <span class="number">-5.5</span>, <span class="number">-2</span>, <span class="number">-8</span>);</span><br><span class="line">    </span><br><span class="line">    [tagText yy_setTextBackgroundBorder:border range:[tagText.string rangeOfString:tag]];</span><br><span class="line">    [text appendAttributedString:tagText];</span><br><span class="line">&#125;</span><br><span class="line">text.yy_lineSpacing = <span class="number">10</span>;</span><br><span class="line">text.yy_lineBreakMode = <span class="symbol">NSLineBreakByWordWrapping</span>;</span><br><span class="line">[text yy_appendString:@<span class="string">&quot;\n&quot;</span>];</span><br><span class="line">[text appendAttributedString:text]; </span><br><span class="line"><span class="symbol">_textView</span>.attributedText = text;</span><br></pre></td></tr></table></figure>

<p><strong><strong>10. YYTextShadow</strong></strong></p>
<p>YYTextShadow 是给富文本添加阴影用的：</p>
<p>添加外阴影：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSMutableAttributedString</span> *one = [[<span class="built_in">NSMutableAttributedString</span> alloc] initWithString:<span class="string">@&quot;Shadow&quot;</span>];</span><br><span class="line">one.yy_font = [<span class="built_in">UIFont</span> boldSystemFontOfSize:<span class="number">30</span>];</span><br><span class="line">one.yy_color = [<span class="built_in">UIColor</span> whiteColor];</span><br><span class="line">YYTextShadow *shadow = [YYTextShadow new];</span><br><span class="line">shadow.color = [<span class="built_in">UIColor</span> colorWithWhite:<span class="number">0.000</span> alpha:<span class="number">0.490</span>];</span><br><span class="line">shadow.offset = <span class="built_in">CGSizeMake</span>(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">shadow.radius = <span class="number">5</span>;</span><br><span class="line">one.yy_textShadow = shadow;</span><br></pre></td></tr></table></figure>

<p>添加内阴影：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSMutableAttributedString</span> *one = [[<span class="built_in">NSMutableAttributedString</span> alloc] initWithString:<span class="string">@&quot;Inner Shadow&quot;</span>];</span><br><span class="line">one.yy_font = [<span class="built_in">UIFont</span> boldSystemFontOfSize:<span class="number">30</span>];</span><br><span class="line">one.yy_color = [<span class="built_in">UIColor</span> whiteColor];</span><br><span class="line">YYTextShadow *shadow = [YYTextShadow new];</span><br><span class="line">shadow.color = [<span class="built_in">UIColor</span> colorWithWhite:<span class="number">0.000</span> alpha:<span class="number">0.40</span>];</span><br><span class="line">shadow.offset = <span class="built_in">CGSizeMake</span>(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">shadow.radius = <span class="number">1</span>;</span><br><span class="line">one.yy_textInnerShadow = shadow;</span><br></pre></td></tr></table></figure>

<p>添加子阴影：</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">NSMutableAttributedString *one = [[NSMutableAttributedString alloc] initWithString:@<span class="string">&quot;Multiple Shadows&quot;</span>];</span><br><span class="line">one.yy_font = [UIFont <span class="keyword">boldSystemFontOfSize:30];</span></span><br><span class="line"><span class="keyword"></span>one.yy_color = [UIColor colorWithRed:<span class="number">1</span>.<span class="number">000</span> green:<span class="number">0</span>.<span class="number">795</span> <span class="keyword">blue:0.014 </span>alpha:<span class="number">1</span>.<span class="number">000</span>];</span><br><span class="line"></span><br><span class="line">YYTextShadow *<span class="keyword">shadow </span>= [YYTextShadow new];</span><br><span class="line"><span class="keyword">shadow.color </span>= [UIColor colorWithWhite:<span class="number">0</span>.<span class="number">000</span> alpha:<span class="number">0</span>.<span class="number">20</span>];</span><br><span class="line"><span class="keyword">shadow.offset </span>= CGSizeMake(<span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line"><span class="keyword">shadow.radius </span>= <span class="number">1</span>.<span class="number">5</span>;</span><br><span class="line">YYTextShadow *<span class="keyword">subShadow </span>= [YYTextShadow new];</span><br><span class="line"><span class="keyword">subShadow.color </span>= [UIColor colorWithWhite:<span class="number">1</span> alpha:<span class="number">0</span>.<span class="number">99</span>];</span><br><span class="line"><span class="keyword">subShadow.offset </span>= CGSizeMake(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">subShadow.radius </span>= <span class="number">1</span>.<span class="number">5</span>;</span><br><span class="line"><span class="keyword">shadow.subShadow </span>= <span class="keyword">subShadow;</span></span><br><span class="line"><span class="keyword"></span>one.yy_textShadow = <span class="keyword">shadow;</span></span><br></pre></td></tr></table></figure>

<p>给高亮文本添加内外阴影：</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">NSMutableAttributedString *one = [[NSMutableAttributedString alloc] initWithString:@<span class="string">&quot;Yet Another Link&quot;</span>];</span><br><span class="line">one.yy_font = [UIFont <span class="keyword">boldSystemFontOfSize:30];</span></span><br><span class="line"><span class="keyword"></span>one.yy_color = [UIColor whiteColor];</span><br><span class="line"></span><br><span class="line">YYTextShadow *<span class="keyword">shadow </span>= [YYTextShadow new];</span><br><span class="line"><span class="keyword">shadow.color </span>= [UIColor colorWithWhite:<span class="number">0</span>.<span class="number">000</span> alpha:<span class="number">0</span>.<span class="number">490</span>];</span><br><span class="line"><span class="keyword">shadow.offset </span>= CGSizeMake(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">shadow.radius </span>= <span class="number">5</span>;</span><br><span class="line">one.yy_textShadow = <span class="keyword">shadow;</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line">YYTextShadow *<span class="keyword">shadow0 </span>= [YYTextShadow new];</span><br><span class="line"><span class="keyword">shadow0.color </span>= [UIColor colorWithWhite:<span class="number">0</span>.<span class="number">000</span> alpha:<span class="number">0</span>.<span class="number">20</span>];</span><br><span class="line"><span class="keyword">shadow0.offset </span>= CGSizeMake(<span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line"><span class="keyword">shadow0.radius </span>= <span class="number">1</span>.<span class="number">5</span>;</span><br><span class="line">YYTextShadow *<span class="keyword">shadow1 </span>= [YYTextShadow new];</span><br><span class="line"><span class="keyword">shadow1.color </span>= [UIColor colorWithWhite:<span class="number">1</span> alpha:<span class="number">0</span>.<span class="number">99</span>];</span><br><span class="line"><span class="keyword">shadow1.offset </span>= CGSizeMake(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">shadow1.radius </span>= <span class="number">1</span>.<span class="number">5</span>;</span><br><span class="line"><span class="keyword">shadow0.subShadow </span>= <span class="keyword">shadow1;</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line">YYTextShadow *innerShadow0 = [YYTextShadow new];</span><br><span class="line">innerShadow0.color = [UIColor colorWithRed:<span class="number">0</span>.<span class="number">851</span> green:<span class="number">0</span>.<span class="number">311</span> <span class="keyword">blue:0.000 </span>alpha:<span class="number">0</span>.<span class="number">780</span>];</span><br><span class="line">innerShadow0.offset = CGSizeMake(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">innerShadow0.radius = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">YYTextHighlight *highlight = [YYTextHighlight new];</span><br><span class="line">[highlight setColor:[UIColor colorWithRed:<span class="number">1</span>.<span class="number">000</span> green:<span class="number">0</span>.<span class="number">795</span> <span class="keyword">blue:0.014 </span>alpha:<span class="number">1</span>.<span class="number">000</span>]];</span><br><span class="line">[highlight setShadow:<span class="keyword">shadow0];</span></span><br><span class="line"><span class="keyword"></span>[highlight setInnerShadow:innerShadow0];</span><br><span class="line">[one yy_setTextHighlight:highlight range:one.yy_rangeOfAll];</span><br></pre></td></tr></table></figure>

<p><strong><strong>11. YYTextBorder</strong></strong></p>
<p>YYTextBorder用于为文本添加边框或者背景</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">YYTextBorder *<span class="built_in">border</span> = [YYTextBorder <span class="built_in">new</span>];</span><br><span class="line"><span class="built_in">border</span>.strokeColor = [UIColor colorWithRed:<span class="number">1.000</span> green:<span class="number">0.029</span> blue:<span class="number">0.651</span> alpha:<span class="number">1.000</span>];</span><br><span class="line"><span class="built_in">border</span>.strokeWidth = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">border</span>.lineStyle = YYTextLineStylePatternCircleDot;</span><br><span class="line"><span class="built_in">border</span>.cornerRadius = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">border</span>.insets = UIEdgeInsetsMake(<span class="number">0</span>, -<span class="number">4</span>, <span class="number">0</span>, -<span class="number">4</span>);</span><br><span class="line">one.yy_textBackgroundBorder = <span class="built_in">border</span>;</span><br></pre></td></tr></table></figure>

<p>作为高亮文本的填充：</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">YYTextBorder *<span class="keyword">border </span>= [YYTextBorder new];</span><br><span class="line"><span class="keyword">border.cornerRadius </span>= <span class="number">50</span>;</span><br><span class="line"><span class="keyword">border.insets </span>= UIEdgeInsetsMake(<span class="number">0</span>, -<span class="number">10</span>, <span class="number">0</span>, -<span class="number">10</span>);</span><br><span class="line"><span class="keyword">border.strokeWidth </span>= <span class="number">0</span>.<span class="number">5</span>;</span><br><span class="line"><span class="keyword">border.strokeColor </span>= one.yy_color;</span><br><span class="line"><span class="keyword">border.lineStyle </span>= YYTextLineStyleSingle;</span><br><span class="line">one.yy_textBackgroundBorder = <span class="keyword">border;</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line">YYTextBorder *highlightBorder = <span class="keyword">border.copy;</span></span><br><span class="line"><span class="keyword"></span>highlightBorder.strokeWidth = <span class="number">0</span>;</span><br><span class="line">highlightBorder.strokeColor = one.yy_color;</span><br><span class="line">highlightBorder.fillColor = one.yy_color;</span><br><span class="line"></span><br><span class="line">YYTextHighlight *highlight = [YYTextHighlight new];</span><br><span class="line">[highlight setColor:[UIColor whiteColor]];</span><br><span class="line">[highlight setBackgroundBorder:highlightBorder];</span><br><span class="line">highlight.tapAction = ^(UIView *containerView, NSAttributedString *text, NSRange range, CGRect rect) &#123;</span><br><span class="line">    [_self <span class="keyword">showMessage:[NSString </span>stringWithFormat:@<span class="string">&quot;Tap: %@&quot;</span>,[text.string <span class="keyword">substringWithRange:range]]];</span></span><br><span class="line"><span class="keyword"></span>&#125;;</span><br><span class="line">[one yy_setTextHighlight:highlight range:one.yy_rangeOfAll];</span><br></pre></td></tr></table></figure>


<p><strong><strong>12. Debug</strong></strong></p>
<figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">YYTextDebugOption *<span class="keyword">debug</span>Options = [YYTextDebugOption new];</span><br><span class="line">[YYTextDebugOption <span class="built_in">set</span>SharedDebugOption:<span class="keyword">debug</span>Options];</span><br></pre></td></tr></table></figure>

<p>下面是YYTextDebugOption的配置</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIColor</span> *baselineColor;      <span class="comment">///&lt; baseline color</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIColor</span> *<span class="built_in">CTFrameBorderColor</span>; <span class="comment">///&lt; CTFrame path border color</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIColor</span> *<span class="built_in">CTFrameFillColor</span>;   <span class="comment">///&lt; CTFrame path fill color</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIColor</span> *<span class="built_in">CTLineBorderColor</span>;  <span class="comment">///&lt; CTLine bounds border color</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIColor</span> *<span class="built_in">CTLineFillColor</span>;    <span class="comment">///&lt; CTLine bounds fill color</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIColor</span> *<span class="built_in">CTLineNumberColor</span>;  <span class="comment">///&lt; CTLine line number color</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIColor</span> *<span class="built_in">CTRunBorderColor</span>;   <span class="comment">///&lt; CTRun bounds border color</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIColor</span> *<span class="built_in">CTRunFillColor</span>;     <span class="comment">///&lt; CTRun bounds fill color</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIColor</span> *<span class="built_in">CTRunNumberColor</span>;   <span class="comment">///&lt; CTRun number color</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIColor</span> *<span class="built_in">CGGlyphBorderColor</span>; <span class="comment">///&lt; CGGlyph bounds border color</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIColor</span> *<span class="built_in">CGGlyphFillColor</span>;   <span class="comment">///&lt; CGGlyph bounds fill color</span></span><br></pre></td></tr></table></figure>

<p><strong><strong>13. 其他</strong></strong></p>
<p>用YYTextWeakProxy避免被NSTimer或者CADisplayLink持有导致循环引用：</p>
<figure class="highlight nim"><table><tr><td class="code"><pre><span class="line">@implementation <span class="type">MyView</span> &#123;</span><br><span class="line">    <span class="type">NSTimer</span> *_timer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)initTimer &#123;</span><br><span class="line">    <span class="type">YYTextWeakProxy</span> *proxy = [<span class="type">YYTextWeakProxy</span> proxyWithTarget:self];</span><br><span class="line">    _timer = [<span class="type">NSTimer</span> timerWithTimeInterval:<span class="number">0</span>.<span class="number">1</span> target:proxy selector:@selector(tick:) userInfo:<span class="keyword">nil</span> repeats:<span class="type">YES</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)tick:(<span class="type">NSTimer</span> *)timer <span class="meta">&#123;...&#125;</span></span><br><span class="line">@<span class="keyword">end</span></span><br></pre></td></tr></table></figure>





        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/iOS-%E5%BC%80%E6%BA%90%E5%BA%93%E5%88%86%E6%9E%90/">iOS 开源库分析</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/iOS-开源库分析/">iOS 开源库分析</a>
  </div>

</div>



<div class="comments-count">
	
	  	<span></span>
		<a href="/2019/11/08/YYText-使用详解/#comments" class="ds-thread-count comments-count-link" data-thread-key="2019/11/08/YYText-使用详解/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/11/05/在项目中使用Yoga-布局引擎/" title="在项目中使用Yoga 布局引擎" itemprop="url">在项目中使用Yoga 布局引擎</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Edgar" target="_blank" itemprop="author">Edgar</a>
		
  <p class="article-time">
    <time datetime="2019-11-05T15:26:08.000Z" itemprop="datePublished"> Published 2019-11-05</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h5 id="1-有帮助的链接"><a href="#1-有帮助的链接" class="headerlink" title="1. 有帮助的链接"></a>1. 有帮助的链接</h5><ul>
<li><a target="_blank" rel="noopener" href="https://yogalayout.com/">Yogalayout</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/facebook/yoga">Yoga github</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/facebook/yoga/tree/master/YogaKit">YogaKit github</a></li>
<li><a target="_blank" rel="noopener" href="https://www.raywenderlich.com/530-yoga-tutorial-using-a-cross-platform-layout-engine">raywenderlich</a></li>
<li><a target="_blank" rel="noopener" href="https://codepen.io/enxaneta/full/adLPwv/">Flex Playground</a></li>
</ul>
<h5 id="2-开始前的叨叨"><a href="#2-开始前的叨叨" class="headerlink" title="2. 开始前的叨叨"></a>2. 开始前的叨叨</h5><p>项目中最早用的是Masonry，它用起来确实十分方便，但是它是基于AutoLayout的，所以到了项目中期替换替换成了给予frame的布局方式，那么为什么要在自己的练习项目中使用Yoga呢？理由有如下几方面：</p>
<ol>
<li>Yoga是跨平台的在Android,Reactive Native,iOS 都有对应的版本，这样方便自己后续使用Android,RN时，能够少学点，统一下技术栈（还是懒 ^V^）。</li>
<li>Yoga是基于Flex布局的，Flutter,以及Web框架，小程序也都是采用这种布局方式，还是想一劳永逸，并且是基于frame的性能上面是可以接受的，何乐而不为。</li>
</ol>
<p>这篇主要关注的是Flex 以及 YogaKit，大家如果想了解frame布局，AutoLayout布局原理，以及目前iOS比较主流的布局框架，我后面还会另起一个博客来介绍。</p>
<h5 id="3-Flex布局概念"><a href="#3-Flex布局概念" class="headerlink" title="3. Flex布局概念"></a>3. Flex布局概念</h5><h6 id="3-1-Flex-容器布局属性"><a href="#3-1-Flex-容器布局属性" class="headerlink" title="3.1 Flex 容器布局属性"></a>3.1 Flex 容器布局属性</h6><p>盒子模型：</p>
<p><img src="/2019/11/05/%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8Yoga-%E5%B8%83%E5%B1%80%E5%BC%95%E6%93%8E/0000001.png"></p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">* <span class="built_in">position</span> 在当前盒子中item 的定位</span><br><span class="line">* margin item 的外边距。</span><br><span class="line">* <span class="built_in">border</span> item的边框。</span><br><span class="line">* padding item内边距。</span><br><span class="line">* <span class="built_in">width</span> &amp; <span class="built_in">height</span>，当 <span class="built_in">box</span>-sizing 为 <span class="built_in">content</span>-<span class="built_in">box</span>，指内部蓝色的区域。当 <span class="built_in">box</span>-siziong 为 boder-<span class="built_in">box</span>时，指含 <span class="built_in">border</span> 以内的区域。Yoga默认是 <span class="built_in">border</span>-<span class="built_in">box</span>。</span><br></pre></td></tr></table></figure>

<h6 id="Flex-direction"><a href="#Flex-direction" class="headerlink" title="* Flex direction"></a>* Flex direction</h6><p>Flex 布局是有两类子对象:flex item 和 flex container。flex item 和 flex container组成一个布局层级树。还包括主轴和交叉轴的概念，要解释主轴和交叉轴的概念必须知道flex direction这个概念。</p>
<p><img src="/2019/11/05/%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8Yoga-%E5%B8%83%E5%B1%80%E5%BC%95%E6%93%8E/01.png"></p>
<p>一般如果需要使用flex布局，那么需要使用display属性来开启：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">display: flex</span><br></pre></td></tr></table></figure>

<p>我们先来看下 flex direction及主轴交叉轴：<br>flex direction 就是布局方向，一般支持row,row reverse,column,clumn reverse. 也就是横轴，横轴逆向，纵轴，纵轴逆向。如果flex direction指定的是row,row reverse 那么主轴就是横轴，如果为column,clumn reverse那么主轴就是纵轴。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">flex-direction: <span class="keyword">row</span> / <span class="keyword">column</span> / <span class="keyword">row</span>-<span class="keyword">reverse</span> / <span class="keyword">column</span>-<span class="keyword">reverse</span></span><br></pre></td></tr></table></figure>

<p><img src="/2019/11/05/%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8Yoga-%E5%B8%83%E5%B1%80%E5%BC%95%E6%93%8E/02.png"><br><img src="/2019/11/05/%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8Yoga-%E5%B8%83%E5%B1%80%E5%BC%95%E6%93%8E/03.png"><br><img src="/2019/11/05/%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8Yoga-%E5%B8%83%E5%B1%80%E5%BC%95%E6%93%8E/04.png"><br><img src="/2019/11/05/%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8Yoga-%E5%B8%83%E5%B1%80%E5%BC%95%E6%93%8E/05.png"></p>
<p>有了主轴交叉轴的概念后就可以进行后续的概念的介绍了：</p>
<h6 id="Justify-content"><a href="#Justify-content" class="headerlink" title="* Justify-content"></a>* Justify-content</h6><p>Justify-content 是flex item 沿着主轴方向上的布局方式：</p>
<p>flex-start：所有的flex item 沿着主轴布局的开始方向进行布局<br>flex-end：所有的flex item 从主轴结尾开始沿着主轴逆向布局<br>center：  所有flex item 居中布局<br>space-between：所有flex item 在容器内被空白空间均匀间隔开，第一个项目在开端位置，最后一个项目在末端位置。<br>space-around：所有flex item周围以同等空间均匀间隔，它和space-between的区别是开始和结束有空白区域，并且为中间区域的一半。</p>
<p><img src="/2019/11/05/%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8Yoga-%E5%B8%83%E5%B1%80%E5%BC%95%E6%93%8E/14.png"><br><img src="/2019/11/05/%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8Yoga-%E5%B8%83%E5%B1%80%E5%BC%95%E6%93%8E/15.png"><br><img src="/2019/11/05/%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8Yoga-%E5%B8%83%E5%B1%80%E5%BC%95%E6%93%8E/16.png"><br><img src="/2019/11/05/%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8Yoga-%E5%B8%83%E5%B1%80%E5%BC%95%E6%93%8E/17.png"><br><img src="/2019/11/05/%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8Yoga-%E5%B8%83%E5%B1%80%E5%BC%95%E6%93%8E/18.png"><br><img src="/2019/11/05/%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8Yoga-%E5%B8%83%E5%B1%80%E5%BC%95%E6%93%8E/19.png"></p>
<h6 id="Align-items"><a href="#Align-items" class="headerlink" title="* Align-items"></a>* Align-items</h6><p>指定item在交叉轴的对齐方式</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">align-<span class="keyword">items</span>: stretch / flex-<span class="built_in">start</span> / flex-<span class="function"><span class="keyword">end</span> / <span class="title">center</span> / <span class="title">baseline</span></span></span><br><span class="line"></span><br><span class="line">stretch（默认）每个项目进行拉伸，直到所有<span class="keyword">item</span>大小占满父容器</span><br><span class="line">flex-<span class="built_in">start</span> 对齐交叉轴的起点</span><br><span class="line">flex-<span class="function"><span class="keyword">end</span> 对齐交叉轴的终点</span></span><br><span class="line">center 交叉轴内居中</span><br><span class="line">baseline 在一行中，所有<span class="keyword">item</span>以首个<span class="keyword">item</span>的文字排版为基线对齐，仅在 flex-direction: row / row-reverse 生效</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/2019/11/05/%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8Yoga-%E5%B8%83%E5%B1%80%E5%BC%95%E6%93%8E/09.png"><br><img src="/2019/11/05/%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8Yoga-%E5%B8%83%E5%B1%80%E5%BC%95%E6%93%8E/10.png"><br><img src="/2019/11/05/%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8Yoga-%E5%B8%83%E5%B1%80%E5%BC%95%E6%93%8E/11.png"><br><img src="/2019/11/05/%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8Yoga-%E5%B8%83%E5%B1%80%E5%BC%95%E6%93%8E/12.png"><br><img src="/2019/11/05/%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8Yoga-%E5%B8%83%E5%B1%80%E5%BC%95%E6%93%8E/13.png"></p>
<h6 id="Flex-wrap"><a href="#Flex-wrap" class="headerlink" title="* Flex-wrap"></a>* Flex-wrap</h6><p>Flex-wrap指明了当可用排版空间不足时，是否允许换行，以及换行后的顺序。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">flex-<span class="built_in">wrap</span>: <span class="built_in">wrap</span>（默认） / nowrap / <span class="built_in">wrap</span>-<span class="built_in">reverse</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">wrap</span> （默认）空间不足时，进行换行</span><br><span class="line">nowrap 不换行</span><br><span class="line"><span class="built_in">wrap</span>-<span class="built_in">reverse</span> 换行后，第一行在最下方，行排版方向向上</span><br></pre></td></tr></table></figure>

<p><img src="/2019/11/05/%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8Yoga-%E5%B8%83%E5%B1%80%E5%BC%95%E6%93%8E/06.png"><br><img src="/2019/11/05/%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8Yoga-%E5%B8%83%E5%B1%80%E5%BC%95%E6%93%8E/07.png"><br><img src="/2019/11/05/%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8Yoga-%E5%B8%83%E5%B1%80%E5%BC%95%E6%93%8E/08.png"></p>
<h6 id="Align-content"><a href="#Align-content" class="headerlink" title="* Align-content"></a>* Align-content</h6><p>指定container中存在多行情况下，在交叉轴上的布局方式，这里需要注意的是与Align-items的区别，Align-items 是单行上各个元素的对齐方式，是站在item元素的角度，Align-content是多行的情况下，整个内容在交叉轴上的分布关系。是站在交叉轴整体布局角度。</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">align-content: stretch / flex-start / flex-<span class="keyword">end</span> / center / <span class="literal">space</span>-<span class="keyword">between</span> / <span class="literal">space</span>-<span class="keyword">around</span></span><br><span class="line"></span><br><span class="line">stretch（默认）在交叉轴上的大小进行拉伸，铺满容器</span><br><span class="line">flex-start 行向交叉轴起点对齐</span><br><span class="line">flex-<span class="keyword">end</span> 行向交叉轴终点对齐</span><br><span class="line">center 行在交叉轴上居中</span><br><span class="line"><span class="literal">space</span>-<span class="keyword">between</span> 均匀排列每一行，第一行放置于起点，最后一行放置于终点</span><br><span class="line"><span class="literal">space</span>-<span class="keyword">around</span> 均匀排列每一行，每一行周围分配相同的空间</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/2019/11/05/%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8Yoga-%E5%B8%83%E5%B1%80%E5%BC%95%E6%93%8E/20.png"><br><img src="/2019/11/05/%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8Yoga-%E5%B8%83%E5%B1%80%E5%BC%95%E6%93%8E/21.png"><br><img src="/2019/11/05/%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8Yoga-%E5%B8%83%E5%B1%80%E5%BC%95%E6%93%8E/22.png"><br><img src="/2019/11/05/%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8Yoga-%E5%B8%83%E5%B1%80%E5%BC%95%E6%93%8E/23.png"><br><img src="/2019/11/05/%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8Yoga-%E5%B8%83%E5%B1%80%E5%BC%95%E6%93%8E/24.png"><br><img src="/2019/11/05/%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8Yoga-%E5%B8%83%E5%B1%80%E5%BC%95%E6%93%8E/25.png"></p>
<h6 id="3-2-Flex-item布局属性"><a href="#3-2-Flex-item布局属性" class="headerlink" title="3.2 Flex item布局属性"></a>3.2 Flex item布局属性</h6><h6 id="Align-self"><a href="#Align-self" class="headerlink" title="* Align-self"></a>* Align-self</h6><p>align-self 属性可重写flex container 的 align-items 属性。</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">align-self: auto <span class="regexp">/ stretch /</span> flex-start <span class="regexp">/ flex-end /</span> center / base-line</span><br></pre></td></tr></table></figure>

<p><img src="/2019/11/05/%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8Yoga-%E5%B8%83%E5%B1%80%E5%BC%95%E6%93%8E/26.png"><br><img src="/2019/11/05/%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8Yoga-%E5%B8%83%E5%B1%80%E5%BC%95%E6%93%8E/27.png"><br><img src="/2019/11/05/%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8Yoga-%E5%B8%83%E5%B1%80%E5%BC%95%E6%93%8E/28.png"><br><img src="/2019/11/05/%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8Yoga-%E5%B8%83%E5%B1%80%E5%BC%95%E6%93%8E/29.png"><br><img src="/2019/11/05/%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8Yoga-%E5%B8%83%E5%B1%80%E5%BC%95%E6%93%8E/30.png"><br><img src="/2019/11/05/%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8Yoga-%E5%B8%83%E5%B1%80%E5%BC%95%E6%93%8E/31.png"><br><img src="/2019/11/05/%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8Yoga-%E5%B8%83%E5%B1%80%E5%BC%95%E6%93%8E/32.png"></p>
<h6 id="Order"><a href="#Order" class="headerlink" title="* Order"></a>* Order</h6><p>指定项目的排列顺序,值越大排在越后面</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">order</span>: （默认 <span class="number">0</span>）</span><br></pre></td></tr></table></figure>
<p><img src="/2019/11/05/%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8Yoga-%E5%B8%83%E5%B1%80%E5%BC%95%E6%93%8E/36.png"></p>
<h6 id="Flex-grow"><a href="#Flex-grow" class="headerlink" title="* Flex-grow"></a>* Flex-grow</h6><p>指定item的放大比例，默认为0，即如果存在剩余空间，也不进行放大。</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">flex</span>-grow: （默认 <span class="number">0</span>）</span><br></pre></td></tr></table></figure>

<p><img src="/2019/11/05/%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8Yoga-%E5%B8%83%E5%B1%80%E5%BC%95%E6%93%8E/33.png"></p>
<h6 id="Flex-shrink"><a href="#Flex-shrink" class="headerlink" title="* Flex-shrink"></a>* Flex-shrink</h6><p>指定item的缩小比例，默认为1，即在空间不足（仅当不换行时候起效），所有item等比缩小，当设置为0，该item不进行缩小。</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">flex</span>-shrink: number （默认 <span class="number">1</span>）</span><br></pre></td></tr></table></figure>

<p><img src="/2019/11/05/%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8Yoga-%E5%B8%83%E5%B1%80%E5%BC%95%E6%93%8E/34.png"></p>
<h6 id="Flex-basis"><a href="#Flex-basis" class="headerlink" title="* Flex-basis"></a>* Flex-basis</h6><p>指定item的主轴的初始大小，auto 的含义是参考 width 或 height 的大小，</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">flex-basis: number / <span class="built_in">auto</span>（默认 <span class="built_in">auto</span>）</span><br></pre></td></tr></table></figure>
<p><img src="/2019/11/05/%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8Yoga-%E5%B8%83%E5%B1%80%E5%BC%95%E6%93%8E/35.png"></p>
<h6 id="width-height-amp-amp-max-width-max-height-amp-amp-min-width-min-height"><a href="#width-height-amp-amp-max-width-max-height-amp-amp-min-width-min-height" class="headerlink" title="width * height  &amp;&amp; max-width * max-height &amp;&amp; min-width * min-height"></a>width * height  &amp;&amp; max-width * max-height &amp;&amp; min-width * min-height</h6><p>item 的尺寸参数，最大尺寸，最小尺寸</p>
<h6 id="Aspect-Ratio"><a href="#Aspect-Ratio" class="headerlink" title="Aspect Ratio"></a>Aspect Ratio</h6><p>item 的宽高比</p>
<h5 id="4-YogaKit-使用"><a href="#4-YogaKit-使用" class="headerlink" title="4. YogaKit 使用"></a>4. YogaKit 使用</h5><p>YogaKit 有如下属性，有了上面的讲解估计都比较熟悉了</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> (nonatomic, readwrite, assign) YGDirection direction;</span><br><span class="line"><span class="keyword">@property</span> (nonatomic, readwrite, assign) YGFlexDirection flexDirection;</span><br><span class="line"><span class="keyword">@property</span> (nonatomic, readwrite, assign) YGJustify justifyContent;</span><br><span class="line"><span class="keyword">@property</span> (nonatomic, readwrite, assign) YGAlign alignContent;</span><br><span class="line"><span class="keyword">@property</span> (nonatomic, readwrite, assign) YGAlign alignItems;</span><br><span class="line"><span class="keyword">@property</span> (nonatomic, readwrite, assign) YGAlign alignSelf;</span><br><span class="line"><span class="keyword">@property</span> (nonatomic, readwrite, assign) YGPositionType position;</span><br><span class="line"><span class="keyword">@property</span> (nonatomic, readwrite, assign) YGWrap flexWrap;</span><br><span class="line"><span class="keyword">@property</span> (nonatomic, readwrite, assign) YGOverflow overflow;</span><br><span class="line"><span class="keyword">@property</span> (nonatomic, readwrite, assign) YGDisplay display;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (nonatomic, readwrite, assign) CGFloat flex;</span><br><span class="line"><span class="keyword">@property</span> (nonatomic, readwrite, assign) CGFloat flexGrow;</span><br><span class="line"><span class="keyword">@property</span> (nonatomic, readwrite, assign) CGFloat flexShrink;</span><br><span class="line"><span class="keyword">@property</span> (nonatomic, readwrite, assign) YGValue flexBasis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (nonatomic, readwrite, assign) YGValue left;</span><br><span class="line"><span class="keyword">@property</span> (nonatomic, readwrite, assign) YGValue top;</span><br><span class="line"><span class="keyword">@property</span> (nonatomic, readwrite, assign) YGValue right;</span><br><span class="line"><span class="keyword">@property</span> (nonatomic, readwrite, assign) YGValue bottom;</span><br><span class="line"><span class="keyword">@property</span> (nonatomic, readwrite, assign) YGValue start;</span><br><span class="line"><span class="keyword">@property</span> (nonatomic, readwrite, assign) YGValue end;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (nonatomic, readwrite, assign) YGValue marginLeft;</span><br><span class="line"><span class="keyword">@property</span> (nonatomic, readwrite, assign) YGValue marginTop;</span><br><span class="line"><span class="keyword">@property</span> (nonatomic, readwrite, assign) YGValue marginRight;</span><br><span class="line"><span class="keyword">@property</span> (nonatomic, readwrite, assign) YGValue marginBottom;</span><br><span class="line"><span class="keyword">@property</span> (nonatomic, readwrite, assign) YGValue marginStart;</span><br><span class="line"><span class="keyword">@property</span> (nonatomic, readwrite, assign) YGValue marginEnd;</span><br><span class="line"><span class="keyword">@property</span> (nonatomic, readwrite, assign) YGValue marginHorizontal;</span><br><span class="line"><span class="keyword">@property</span> (nonatomic, readwrite, assign) YGValue marginVertical;</span><br><span class="line"><span class="keyword">@property</span> (nonatomic, readwrite, assign) YGValue margin;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (nonatomic, readwrite, assign) YGValue paddingLeft;</span><br><span class="line"><span class="keyword">@property</span> (nonatomic, readwrite, assign) YGValue paddingTop;</span><br><span class="line"><span class="keyword">@property</span> (nonatomic, readwrite, assign) YGValue paddingRight;</span><br><span class="line"><span class="keyword">@property</span> (nonatomic, readwrite, assign) YGValue paddingBottom;</span><br><span class="line"><span class="keyword">@property</span> (nonatomic, readwrite, assign) YGValue paddingStart;</span><br><span class="line"><span class="keyword">@property</span> (nonatomic, readwrite, assign) YGValue paddingEnd;</span><br><span class="line"><span class="keyword">@property</span> (nonatomic, readwrite, assign) YGValue paddingHorizontal;</span><br><span class="line"><span class="keyword">@property</span> (nonatomic, readwrite, assign) YGValue paddingVertical;</span><br><span class="line"><span class="keyword">@property</span> (nonatomic, readwrite, assign) YGValue padding;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (nonatomic, readwrite, assign) CGFloat borderLeftWidth;</span><br><span class="line"><span class="keyword">@property</span> (nonatomic, readwrite, assign) CGFloat borderTopWidth;</span><br><span class="line"><span class="keyword">@property</span> (nonatomic, readwrite, assign) CGFloat borderRightWidth;</span><br><span class="line"><span class="keyword">@property</span> (nonatomic, readwrite, assign) CGFloat borderBottomWidth;</span><br><span class="line"><span class="keyword">@property</span> (nonatomic, readwrite, assign) CGFloat borderStartWidth;</span><br><span class="line"><span class="keyword">@property</span> (nonatomic, readwrite, assign) CGFloat borderEndWidth;</span><br><span class="line"><span class="keyword">@property</span> (nonatomic, readwrite, assign) CGFloat borderWidth;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (nonatomic, readwrite, assign) YGValue <span class="attribute">width</span>;</span><br><span class="line"><span class="keyword">@property</span> (nonatomic, readwrite, assign) YGValue <span class="attribute">height</span>;</span><br><span class="line"><span class="keyword">@property</span> (nonatomic, readwrite, assign) YGValue minWidth;</span><br><span class="line"><span class="keyword">@property</span> (nonatomic, readwrite, assign) YGValue minHeight;</span><br><span class="line"><span class="keyword">@property</span> (nonatomic, readwrite, assign) YGValue maxWidth;</span><br><span class="line"><span class="keyword">@property</span> (nonatomic, readwrite, assign) YGValue maxHeight;</span><br><span class="line"><span class="comment">//只要 width 或者 height 确定，就能确定另外一个变量。</span></span><br><span class="line"><span class="keyword">@property</span> (nonatomic, readwrite, assign) CGFloat aspectRatio;</span><br></pre></td></tr></table></figure>

<p>我们看下,一个布局实例，整个步骤分成如下4步：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1.</span> 设置view的layout</span><br><span class="line">configureLayoutWithBlock:(YGLayoutConfigurationBlock)block</span><br><span class="line"><span class="bullet">2.</span> 将layout应用到view</span><br><span class="line">applyLayoutPreservingOrigin:(BOOL)preserveOrigin</span><br><span class="line"><span class="bullet">3.</span> 计算布局</span><br><span class="line">calculateLayoutWithSize</span><br><span class="line"><span class="bullet">4.</span> 将布局应用到view层级上</span><br><span class="line">YGApplyLayoutToViewHierarchy</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中步骤1.和步骤2是我们来完成的，3，4是yoga完成的。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">-(<span class="type">void</span>)configSubViewsLayout &#123;</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span>.view configureLayoutWithBlock:^(YGLayout * layout) &#123;</span><br><span class="line">        layout.isEnabled = <span class="literal">YES</span>;</span><br><span class="line">        layout.width = YGPointValue(<span class="keyword">self</span>.view.bounds.size.width);</span><br><span class="line">        layout.height = YGPointValue(<span class="keyword">self</span>.view.bounds.size.height);</span><br><span class="line">        layout.alignItems = YGAlignCenter;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UIView</span> *contentView = [[<span class="built_in">UIView</span> alloc]init];</span><br><span class="line">    contentView.backgroundColor = [<span class="built_in">UIColor</span> lightGrayColor];</span><br><span class="line">    [contentView configureLayoutWithBlock:^(YGLayout * layout) &#123;</span><br><span class="line">        layout.isEnabled = <span class="literal">true</span>;</span><br><span class="line">        layout.flexDirection =  YGFlexDirectionRow;</span><br><span class="line">        layout.width = YGPointValue(<span class="number">320</span>);</span><br><span class="line">        layout.height = YGPointValue(<span class="number">80</span>);</span><br><span class="line">        layout.marginTop = YGPointValue(<span class="number">100</span>);</span><br><span class="line">        layout.padding =  YGPointValue(<span class="number">10</span>);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UIView</span> *child1 = [[<span class="built_in">UIView</span> alloc]init];</span><br><span class="line">    child1.backgroundColor = [<span class="built_in">UIColor</span> redColor];</span><br><span class="line">    [child1 configureLayoutWithBlock:^(YGLayout * layout) &#123;</span><br><span class="line">        layout.isEnabled = <span class="literal">YES</span>;</span><br><span class="line">        layout.width = YGPointValue(<span class="number">80</span>);</span><br><span class="line">        layout.marginRight = YGPointValue(<span class="number">10</span>);</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UIView</span> *child2 = [[<span class="built_in">UIView</span> alloc]init];</span><br><span class="line">    child2.backgroundColor = [<span class="built_in">UIColor</span> blueColor];</span><br><span class="line">    [child2 configureLayoutWithBlock:^(YGLayout * layout) &#123;</span><br><span class="line">        layout.isEnabled = <span class="literal">YES</span>;</span><br><span class="line">        layout.width = YGPointValue(<span class="number">80</span>);</span><br><span class="line">        layout.flexGrow = <span class="number">1</span>;</span><br><span class="line">        layout.height = YGPointValue(<span class="number">20</span>);</span><br><span class="line">        layout.alignSelf = YGAlignCenter;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    [contentView addSubview:child1];</span><br><span class="line">    [contentView addSubview:child2];</span><br><span class="line">    [<span class="keyword">self</span>.view addSubview:contentView];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)layoutSubViews &#123;</span><br><span class="line">    [<span class="variable language_">super</span> layoutSubViews];</span><br><span class="line">    [<span class="keyword">self</span>.view.yoga applyLayoutPreservingOrigin:<span class="literal">YES</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>是不是很像Masonry？ 下一节我们将通过源码分析来看看它具体的工作原理。</p>
<h5 id="5-YogaKit-源码解析"><a href="#5-YogaKit-源码解析" class="headerlink" title="5. YogaKit 源码解析"></a>5. YogaKit 源码解析</h5><p>当我们使用view.yoga的时候，YOGA会通过关联属性来为view添加一个YGLayout的属性，这个属性中存放的是yoga的布局约束</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">- (YGLayout *)yoga &#123;</span><br><span class="line">  YGLayout *yoga = objc<span class="constructor">_getAssociatedObject(<span class="params">self</span>, <span class="params">kYGYogaAssociatedKey</span>)</span>;</span><br><span class="line">  <span class="keyword">if</span> (!yoga) &#123;</span><br><span class="line">    yoga = <span class="literal">[[YGL<span class="identifier">ayout</span> <span class="identifier">alloc</span>]</span> initWithView:self];</span><br><span class="line">    objc<span class="constructor">_setAssociatedObject(<span class="params">self</span>, <span class="params">kYGYogaAssociatedKey</span>, <span class="params">yoga</span>, OBJC_ASSOCIATION_RETAIN_NONATOMIC)</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  return yoga;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用 configureLayoutWithBlock的时候，我们会将为当前view添加的yoga关联属性引用传出去，在bock中我们为它设置布局约束。</p>
<figure class="highlight nim"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)configureLayoutWithBlock:(<span class="type">YGLayoutConfigurationBlock</span>)<span class="keyword">block</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">block</span> != <span class="keyword">nil</span>) &#123;</span><br><span class="line">    <span class="keyword">block</span>(self.yoga);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们来看下YGLayout,，它有两个开关属性，isIncludedInLayout，isEnabled一般我们都是需要将其打开的。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 进行一次布局运算并更新view的frame。如果不保留原点，根视图的布局结果将会从&#123;0,0&#125;开始</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="type">void</span>)applyLayoutPreservingOrigin:(<span class="type">BOOL</span>)preserveOrigin;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)applyLayoutPreservingOrigin:(<span class="type">BOOL</span>)preserveOrigin</span><br><span class="line">               dimensionFlexibility:(YGDimensionFlexibility)dimensionFlexibility;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 在没有约束条件的情况下返回view的固有尺寸，这相当于调用了[self sizeThatFits:CGSizeMake(CGFLOAT_MAX, CGFLOAT_MAX)];</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">assign</span>) <span class="built_in">CGSize</span> intrinsicSize;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  根据给定的约束条件，返回view的尺寸</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="built_in">CGSize</span>)calculateLayoutWithSize:(<span class="built_in">CGSize</span>)size;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  返回在使用Flex的子view数量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">assign</span>) <span class="built_in">NSUInteger</span> numberOfChildren;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 当前视图是否有子视图</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">assign</span>) <span class="type">BOOL</span> isLeaf;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 将当前视图是否为脏视图，这些视图将会在下一次布局中进行重新布局</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">assign</span>) <span class="type">BOOL</span> isDirty;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 将当前视图标记为脏视图</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="type">void</span>)markDirty;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面只是通过block将通过关联属性添加的ASLayout类型的yoga属性传递出去，让我们在block里面设置，但是这些属性还没有应用到view上面，所以必须调用applyLayoutPreservingOrigin方法应用这些设置，我们接下来看下applyLayoutPreservingOrigin方法。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- (<span class="type">void</span>)applyLayoutPreservingOrigin:(<span class="type">BOOL</span>)preserveOrigin &#123;</span><br><span class="line">  [<span class="keyword">self</span> calculateLayoutWithSize:<span class="keyword">self</span>.view.bounds.size];</span><br><span class="line">  YGApplyLayoutToViewHierarchy(<span class="keyword">self</span>.view, preserveOrigin);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里很明确分成两步：</p>
<ol>
<li>measure 指测量item所需要的大小，以及子节点的大小，也就是确定width 和 height</li>
<li>layout  指将item确定的放置在具体的 (x, y) 点，也就是确定对应的posion</li>
</ol>
<p>二者构成了UIView的frame</p>
<p>我们来看下第一步 – 测量</p>
<p>这里首先构建出当前view为起点的节点树，然后通过YGNodeCalculateLayout来算出宽高传递出去。这里关键的是YGNodeCalculateLayout这个方法，它是yoga的算法，是用C++实现的，由于代码很长，其中核心的Flex布局算法实现函数长达几千行，占Yoga.c的 2&#x2F;3,第一次看很没有勇气看下去。所以后续会另起一篇博客来详细分析Yoga的底层实现。所以这里只要简单知道这些方法是干啥的就好。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">CGSize</span>)calculateLayoutWithSize:(<span class="built_in">CGSize</span>)size &#123;</span><br><span class="line">    </span><br><span class="line">  <span class="built_in">NSAssert</span>([<span class="built_in">NSThread</span> isMainThread], <span class="string">@&quot;Yoga calculation must be done on main.&quot;</span>);</span><br><span class="line">  <span class="built_in">NSAssert</span>(<span class="keyword">self</span>.isEnabled, <span class="string">@&quot;Yoga is not enabled for this view.&quot;</span>);</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//构建当前view为起点的节点树</span></span><br><span class="line">  YGAttachNodesFromViewHierachy(<span class="keyword">self</span>.view);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> YGNodeRef node = <span class="keyword">self</span>.node;</span><br><span class="line">  <span class="comment">//计算出节点的宽高</span></span><br><span class="line">  YGNodeCalculateLayout(</span><br><span class="line">    node,</span><br><span class="line">    size.width <span class="comment">/*约束宽度*/</span>,</span><br><span class="line">    size.height <span class="comment">/*约束高度*/</span>,</span><br><span class="line">    YGNodeStyleGetDirection(node))<span class="comment">/*方向*/</span>;</span><br><span class="line">  <span class="comment">//将宽高封装成CGSize 传递出去</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="built_in">CGSize</span>) &#123;</span><br><span class="line">    .width = YGNodeLayoutGetWidth(node),</span><br><span class="line">    .height = YGNodeLayoutGetHeight(node),</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>通过上面的计算我们获得了节点的详细参数，所以根据这些参数就可以很容易计算出对应的frame数值。下面是布局的具体代码。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">static void <span class="constructor">YGApplyLayoutToViewHierarchy(UIView <span class="operator">*</span><span class="params">view</span>, BOOL <span class="params">preserveOrigin</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">  <span class="constructor">NSCAssert([NSThread <span class="params">isMainThread</span>], @<span class="string">&quot;Framesetting should only be done on the main thread.&quot;</span>)</span>;</span><br><span class="line"></span><br><span class="line">  const YGLayout *yoga = view.yoga;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!yoga.isIncludedInLayout) &#123;</span><br><span class="line">     return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  YGNodeRef node = yoga.node;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//获得左上角的坐标</span></span><br><span class="line">  const CGPoint topLeft = &#123;</span><br><span class="line">    <span class="constructor">YGNodeLayoutGetLeft(<span class="params">node</span>)</span>,</span><br><span class="line">    <span class="constructor">YGNodeLayoutGetTop(<span class="params">node</span>)</span>,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//计算右下角的坐标</span></span><br><span class="line">  const CGPoint bottomRight = &#123;</span><br><span class="line">    topLeft.x + <span class="constructor">YGNodeLayoutGetWidth(<span class="params">node</span>)</span>,</span><br><span class="line">    topLeft.y + <span class="constructor">YGNodeLayoutGetHeight(<span class="params">node</span>)</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//如果preserveOrigin为true那么会保留原来的节点坐标</span></span><br><span class="line">  const CGPoint origin = preserveOrigin ? view.frame.origin : CGPointZero;</span><br><span class="line">  <span class="comment">//布局该节点</span></span><br><span class="line">  view.frame = (CGRect) &#123;</span><br><span class="line">    .origin = &#123;</span><br><span class="line">      .x = <span class="constructor">YGRoundPixelValue(<span class="params">topLeft</span>.<span class="params">x</span> + <span class="params">origin</span>.<span class="params">x</span>)</span>,</span><br><span class="line">      .y = <span class="constructor">YGRoundPixelValue(<span class="params">topLeft</span>.<span class="params">y</span> + <span class="params">origin</span>.<span class="params">y</span>)</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    .size = &#123;</span><br><span class="line">      .width = <span class="constructor">YGRoundPixelValue(<span class="params">bottomRight</span>.<span class="params">x</span>)</span> - <span class="constructor">YGRoundPixelValue(<span class="params">topLeft</span>.<span class="params">x</span>)</span>,</span><br><span class="line">      .height = <span class="constructor">YGRoundPixelValue(<span class="params">bottomRight</span>.<span class="params">y</span>)</span> - <span class="constructor">YGRoundPixelValue(<span class="params">topLeft</span>.<span class="params">y</span>)</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!yoga.isLeaf) &#123;</span><br><span class="line">    <span class="comment">//对子节点进行布局</span></span><br><span class="line">    <span class="keyword">for</span> (NSUInteger i=<span class="number">0</span>; i&lt;view.subviews.count; i++) &#123;</span><br><span class="line">      <span class="constructor">YGApplyLayoutToViewHierarchy(<span class="params">view</span>.<span class="params">subviews</span>[<span class="params">i</span>], NO)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到目前位置我们分析了整个YogaKit的源码，其实最核心最重要的还是Yoga底层的代码，这里由于篇幅原因将其放到下一篇博客中。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/iOS-%E5%BC%80%E6%BA%90%E5%BA%93%E5%88%86%E6%9E%90/">iOS 开源库分析</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/iOS-开源库分析/">iOS 开源库分析</a>
  </div>

</div>



<div class="comments-count">
	
	  	<span></span>
		<a href="/2019/11/05/在项目中使用Yoga-布局引擎/#comments" class="ds-thread-count comments-count-link" data-thread-key="2019/11/05/在项目中使用Yoga-布局引擎/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/11/03/基于AutoLayout的开源布局库Masonry源码解析/" title="基于AutoLayout的开源布局库Masonry源码解析" itemprop="url">基于AutoLayout的开源布局库Masonry源码解析</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Edgar" target="_blank" itemprop="author">Edgar</a>
		
  <p class="article-time">
    <time datetime="2019-11-02T17:16:07.000Z" itemprop="datePublished"> Published 2019-11-03</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h5 id="开篇叨叨"><a href="#开篇叨叨" class="headerlink" title="开篇叨叨"></a>开篇叨叨</h5><p>Masonry 是iOS目前用得比较多的一个布局框架，被广泛应用与较为简单的界面布局中，它是对iOS AutoLayout的一个封装，如果有使用过AutoLayout 原生API进行布局过我相信很难摆脱它给我们iOS职业生涯带来的阴影。经过封装过的Masonry提供了一种链式方式来描述NSLayoutConstraints，可以说经过封装后的Masonry有一种从地狱到天堂的感受。</p>
<p>我们来对比下原生AutoLayout以及使用Masonry实现同一个布局的代码效果。下面是实现在一个view中包含另外一个view，并且内部view和外部view的各个边界padding均为10</p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line">AutoLayout 版本</span><br><span class="line"></span><br><span class="line">UIView *<span class="attr">superview</span> <span class="operator">=</span> self.<span class="attr">view</span><span class="punctuation">;</span></span><br><span class="line"></span><br><span class="line">UIView *view1 = [[UIView alloc] init]<span class="punctuation">;</span></span><br><span class="line">view1.translatesAutoresizingMaskIntoC<span class="attr">onstraints</span> <span class="operator">=</span> NO<span class="punctuation">;</span></span><br><span class="line">view1.backgroundC<span class="attr">olor</span> <span class="operator">=</span> [UIColor greenColor]<span class="punctuation">;</span></span><br><span class="line">[superview addSubview:view1]<span class="punctuation">;</span></span><br><span class="line"></span><br><span class="line">UIEdgeInsets <span class="attr">padding</span> <span class="operator">=</span> UIEdgeInsetsMake(<span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>)<span class="punctuation">;</span></span><br><span class="line"></span><br><span class="line">[superview addConstraints:@[</span><br><span class="line"></span><br><span class="line">    <span class="comment">//view1 constraints</span></span><br><span class="line">    [NSLayoutConstraint constraintWithItem:view1</span><br><span class="line"><span class="symbol">                                 attribute:</span>NSLayoutAttributeTop</span><br><span class="line"><span class="symbol">                                 relatedBy:</span>NSLayoutRelationEqual</span><br><span class="line"><span class="symbol">                                    toItem:</span>superview</span><br><span class="line"><span class="symbol">                                 attribute:</span>NSLayoutAttributeTop</span><br><span class="line"><span class="symbol">                                multiplier:</span><span class="number">1.0</span></span><br><span class="line"><span class="symbol">                                  constant:</span>padding.top],</span><br><span class="line"></span><br><span class="line">    [NSLayoutConstraint constraintWithItem:view1</span><br><span class="line"><span class="symbol">                                 attribute:</span>NSLayoutAttributeLeft</span><br><span class="line"><span class="symbol">                                 relatedBy:</span>NSLayoutRelationEqual</span><br><span class="line"><span class="symbol">                                    toItem:</span>superview</span><br><span class="line"><span class="symbol">                                 attribute:</span>NSLayoutAttributeLeft</span><br><span class="line"><span class="symbol">                                multiplier:</span><span class="number">1.0</span></span><br><span class="line"><span class="symbol">                                  constant:</span>padding.left],</span><br><span class="line"></span><br><span class="line">    [NSLayoutConstraint constraintWithItem:view1</span><br><span class="line"><span class="symbol">                                 attribute:</span>NSLayoutAttributeBottom</span><br><span class="line"><span class="symbol">                                 relatedBy:</span>NSLayoutRelationEqual</span><br><span class="line"><span class="symbol">                                    toItem:</span>superview</span><br><span class="line"><span class="symbol">                                 attribute:</span>NSLayoutAttributeBottom</span><br><span class="line"><span class="symbol">                                multiplier:</span><span class="number">1.0</span></span><br><span class="line"><span class="symbol">                                  constant:</span>-padding.bottom],</span><br><span class="line"></span><br><span class="line">    [NSLayoutConstraint constraintWithItem:view1</span><br><span class="line"><span class="symbol">                                 attribute:</span>NSLayoutAttributeRight</span><br><span class="line"><span class="symbol">                                 relatedBy:</span>NSLayoutRelationEqual</span><br><span class="line"><span class="symbol">                                    toItem:</span>superview</span><br><span class="line"><span class="symbol">                                 attribute:</span>NSLayoutAttributeRight</span><br><span class="line"><span class="symbol">                                multiplier:</span><span class="number">1</span></span><br><span class="line"><span class="symbol">                                  constant:</span>-padding.right],</span><br><span class="line"></span><br><span class="line"> ]]<span class="punctuation">;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight wren"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Masonry</span> 版本</span><br><span class="line"></span><br><span class="line">[<span class="variable">view1</span> <span class="variable">mas_makeConstraints</span>:<span class="title function_">^</span>(<span class="params">MASConstraintMaker</span> *<span class="params">make</span>) &#123;</span><br><span class="line">    <span class="variable">make</span>.<span class="property">edges</span>.<span class="property">equalTo</span>(superview).<span class="property">with</span>.<span class="property">insets</span>(<span class="variable">padding</span>);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>但是碍于性能的问题在项目中还是舍弃了，但是作为对AutoLayout的学习还是值得对其进行深入分析下的。</p>
<h5 id="Masonry-源码解析"><a href="#Masonry-源码解析" class="headerlink" title="Masonry 源码解析"></a>Masonry 源码解析</h5><p>Masonry 提供了mas_makeConstraints，mas_updateConstraints，mas_remakeConstraints 三个入口。</p>
<ul>
<li>mas_makeConstraints：</li>
</ul>
<p>mas_makeConstraints 是最常用的通过它我们可以很方便得为一个UIView添加各种约束，mas_makeConstraints一般在viewDidLoad方法中调用来为view添加布局约束。</p>
<ul>
<li>mas_updateConstraints</li>
</ul>
<p>有时候我们只需要修改某个属性的值那么就需要用到mas_updateConstraints，mas_updateConstraints 一般在 updateConstraints方法中调用，这是苹果推荐的更新布局约束的地方。它会在调用setNeedsUpdateConstraints的时候被间接调用。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)updateConstraints &#123;</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span>.button mas_updateConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">        make.center.equalTo(<span class="keyword">self</span>);</span><br><span class="line">        make.width.equalTo(@(<span class="keyword">self</span>.buttonSize.width)).priorityLow();</span><br><span class="line">        make.height.equalTo(@(<span class="keyword">self</span>.buttonSize.height)).priorityLow();</span><br><span class="line">        make.width.lessThanOrEqualTo(<span class="keyword">self</span>);</span><br><span class="line">        make.height.lessThanOrEqualTo(<span class="keyword">self</span>);</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//according to apple super should be called at end of method</span></span><br><span class="line">    [<span class="variable language_">super</span> updateConstraints];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>mas_remakeConstraints</li>
</ul>
<p>mas_remakeConstraints 和mas_updateConstraints类似，也是用于改变已经拥有的布局约束，但是不同的是它会在应用约束前线移除已经应用的约束。</p>
<h6 id="mas-makeConstraints-amp-amp-mas-updateConstraints-amp-amp-mas-remakeConstraints"><a href="#mas-makeConstraints-amp-amp-mas-updateConstraints-amp-amp-mas-remakeConstraints" class="headerlink" title="mas_makeConstraints &amp;&amp; mas_updateConstraints &amp;&amp; mas_remakeConstraints"></a>mas_makeConstraints &amp;&amp; mas_updateConstraints &amp;&amp; mas_remakeConstraints</h6><h6 id="1-约束条件的构建"><a href="#1-约束条件的构建" class="headerlink" title="1. 约束条件的构建"></a>1. 约束条件的构建</h6><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">NSArray</span> *)mas_makeConstraints:(<span class="type">void</span>(^)(MASConstraintMaker *))block &#123;</span><br><span class="line">    <span class="keyword">self</span>.translatesAutoresizingMaskIntoConstraints = <span class="literal">NO</span>;</span><br><span class="line">    MASConstraintMaker *constraintMaker = [[MASConstraintMaker alloc] initWithView:<span class="keyword">self</span>];</span><br><span class="line">    block(constraintMaker);</span><br><span class="line">    <span class="keyword">return</span> [constraintMaker install];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和YogaKit类似它会在内部初始化一个MASConstraintMaker然后通过block传递出去，便于在外部对MASConstraintMaker进行设值，最后通过MASConstraintMaker的install方法应用约束。<br>代码的开头有个</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">self.translatesAutoresizingMaskIntoConstraints</span> = <span class="literal">NO</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>在translatesAutoresizingMaskIntoConstraints设置为YES的情况下会把autoresizingMask 转换为 Constraints，也就是把 frame ，bouds，center 方式布局的视图自动转化为约束形式，这在使用AutoLayout很容易引入不需要的约束，甚至带来约束冲突。在使用frame形式布局的时候不需要设置该值，使用默认的YES.但是对于AutoLayout记得要把这个值设置为no</p>
<p>在MASConstraintMaker创建方法中会创建一个constraints数组用于存放约束</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="operator">-</span> (id)initWithView:(<span class="type">MAS_VIEW</span> <span class="operator">*</span>)view &#123;</span><br><span class="line">    <span class="keyword">self</span> <span class="operator">=</span> [<span class="keyword">super</span> <span class="keyword">init</span>];</span><br><span class="line">    <span class="keyword">if</span> (<span class="operator">!</span><span class="keyword">self</span>) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">self</span>.view <span class="operator">=</span> view;</span><br><span class="line">    <span class="keyword">self</span>.constraints <span class="operator">=</span> <span class="type">NSMutableArray</span>.new;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们接下来看下我们怎么使用通过block抛出来的MASConstraintMaker，假设我们设置的约束如下：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">make.top.equal<span class="constructor">To(<span class="params">superview</span>.<span class="params">mas_top</span>)</span>.<span class="keyword">with</span>.offset(padding.top);</span><br></pre></td></tr></table></figure>

<p>MASConstraintMaker中包含了一系列的只读MASConstraint属性：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> (nonatomic, strong, readonly) MASConstraint *left;</span><br><span class="line"><span class="keyword">@property</span> (nonatomic, strong, readonly) MASConstraint *top;</span><br><span class="line"><span class="keyword">@property</span> (nonatomic, strong, readonly) MASConstraint *right;</span><br><span class="line"><span class="keyword">@property</span> (nonatomic, strong, readonly) MASConstraint *bottom;</span><br><span class="line"><span class="keyword">@property</span> (nonatomic, strong, readonly) MASConstraint *leading;</span><br><span class="line"><span class="keyword">@property</span> (nonatomic, strong, readonly) MASConstraint *trailing;</span><br><span class="line"><span class="keyword">@property</span> (nonatomic, strong, readonly) MASConstraint *<span class="attribute">width</span>;</span><br><span class="line"><span class="keyword">@property</span> (nonatomic, strong, readonly) MASConstraint *<span class="attribute">height</span>;</span><br><span class="line"><span class="keyword">@property</span> (nonatomic, strong, readonly) MASConstraint *centerX;</span><br><span class="line"><span class="keyword">@property</span> (nonatomic, strong, readonly) MASConstraint *centerY;</span><br><span class="line"><span class="keyword">@property</span> (nonatomic, strong, readonly) MASConstraint *baseline;</span><br><span class="line"><span class="keyword">@property</span> (nonatomic, strong, readonly) MASConstraint *firstBaseline;</span><br><span class="line"><span class="keyword">@property</span> (nonatomic, strong, readonly) MASConstraint *lastBaseline;</span><br><span class="line"><span class="keyword">@property</span> (nonatomic, strong, readonly) MASConstraint *leftMargin;</span><br><span class="line"><span class="keyword">@property</span> (nonatomic, strong, readonly) MASConstraint *rightMargin;</span><br><span class="line"><span class="keyword">@property</span> (nonatomic, strong, readonly) MASConstraint *topMargin;</span><br><span class="line"><span class="keyword">@property</span> (nonatomic, strong, readonly) MASConstraint *bottomMargin;</span><br><span class="line"><span class="keyword">@property</span> (nonatomic, strong, readonly) MASConstraint *leadingMargin;</span><br><span class="line"><span class="keyword">@property</span> (nonatomic, strong, readonly) MASConstraint *trailingMargin;</span><br><span class="line"><span class="keyword">@property</span> (nonatomic, strong, readonly) MASConstraint *centerXWithinMargins;</span><br><span class="line"><span class="keyword">@property</span> (nonatomic, strong, readonly) MASConstraint *centerYWithinMargins;</span><br><span class="line"><span class="keyword">@property</span> (nonatomic, strong, readonly) MASConstraint *edges;</span><br><span class="line"><span class="keyword">@property</span> (nonatomic, strong, readonly) MASConstraint *size;</span><br><span class="line"><span class="keyword">@property</span> (nonatomic, strong, readonly) MASConstraint *center;</span><br></pre></td></tr></table></figure>

<p>我们这里以top为例：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (MASConstraint *)top &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> addConstraintWithLayoutAttribute:<span class="built_in">NSLayoutAttributeTop</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (MASConstraint *)constraint:(MASConstraint *)constraint addConstraintWithLayoutAttribute:(<span class="built_in">NSLayoutAttribute</span>)layoutAttribute &#123;</span><br><span class="line">    MASViewAttribute *viewAttribute = [[MASViewAttribute alloc] initWithView:<span class="keyword">self</span>.view layoutAttribute:layoutAttribute];</span><br><span class="line">    MASViewConstraint *newConstraint = [[MASViewConstraint alloc] initWithFirstViewAttribute:viewAttribute];</span><br><span class="line">    <span class="keyword">if</span> ([constraint isKindOfClass:MASViewConstraint.class]) &#123;</span><br><span class="line">        <span class="comment">//replace with composite constraint</span></span><br><span class="line">        <span class="built_in">NSArray</span> *children = @[constraint, newConstraint];</span><br><span class="line">        MASCompositeConstraint *compositeConstraint = [[MASCompositeConstraint alloc] initWithChildren:children];</span><br><span class="line">        compositeConstraint.delegate = <span class="keyword">self</span>;</span><br><span class="line">        [<span class="keyword">self</span> constraint:constraint shouldBeReplacedWithConstraint:compositeConstraint];</span><br><span class="line">        <span class="keyword">return</span> compositeConstraint;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!constraint) &#123;</span><br><span class="line">        newConstraint.delegate = <span class="keyword">self</span>;</span><br><span class="line">        [<span class="keyword">self</span>.constraints addObject:newConstraint];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newConstraint;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们这里constraint传入的为nil 所以代码的前半部分没有走，直接将self这是为newConstraint的delegate，并将其添加到constraints数组中，并返回newConstraint。</p>
<p>MASViewAttribute这个类是用于存储view以及它相关的布局属性NSLayoutAttribute，而MASViewConstraint则是一条布局约束规则，它包含着MASViewAttribute。<br>那么这个delegate作用是啥，留到后面介绍。</p>
<p>到目前为止，我们创建了一个MASConstraintMaker，MASConstraintMaker 包含一个constraints数组，用于存储这个view相关的约束，然后将MASConstraintMaker 通过block传递出去，我们在block中为MASConstraintMaker添加各个约束，一个约束是一个MASViewConstraint对象，它是由一个包含着NSLayoutAttribute以及关联的view的MASViewAttribute对象。并将新建的newConstraint返回。</p>
<p>MASConstraint有两个子类：MASViewConstraint 和 MASCompositeConstraint。 MASViewConstraint 为单条约束，而MASCompositeConstraint是类似于edges，size, center 的约束，它是单条约束的集合，比如size 是 width和height的集合，</p>
<p>我们接下来看下equalTo方法：</p>
<figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line">- (MASConstraint * (^)<span class="built_in">(id</span>))equalTo &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">^id</span><span class="built_in">(id</span> <span class="keyword">attribute</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> self.equalToWithRelation(<span class="keyword">attribute</span>, NSLayoutRelationEqual);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>MASConstraint 是一个基类这里的部分实现都是直接抛出异常，需要子类来覆写它们。</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">- (MASConstraint * (^)(id, NSLayoutRelation))equalToWithRelation &#123; <span class="built_in">MASMethodNotImplemented</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#define</span> <span class="built_in">MASMethodNotImplemented</span>() \</span><br><span class="line">    <span class="keyword">@throw</span> [NSException <span class="attribute">exceptionWithName</span>:NSInternalInconsistencyException \</span><br><span class="line">                                   <span class="attribute">reason</span>:[NSString <span class="attribute">stringWithFormat</span>:@<span class="string">&quot;You must override %@ in a subclass.&quot;</span>, NSStringFromSelector(_cmd)] \</span><br><span class="line">                                 <span class="attribute">userInfo</span>:nil]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们看下它的子类MASViewConstraint和MASCompositeConstraint中的实现</p>
<p>MASViewConstraint中的实现</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="operator">-</span> (<span class="type">MASConstraint</span> <span class="operator">*</span> (<span class="operator">^</span>)(id, <span class="type">NSLayoutRelation</span>))equalToWithRelation &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="operator">^</span>id(id attribute, <span class="type">NSLayoutRelation</span> relation) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([attribute isKindOfClass:<span class="type">NSArray</span>.class]) &#123;</span><br><span class="line">            <span class="type">NSAssert</span>(<span class="operator">!</span><span class="keyword">self</span>.hasLayoutRelation, @<span class="string">&quot;Redefinition of constraint relation&quot;</span>);</span><br><span class="line">            <span class="type">NSMutableArray</span> <span class="operator">*</span>children <span class="operator">=</span> <span class="type">NSMutableArray</span>.new;</span><br><span class="line">            <span class="keyword">for</span> (id attr <span class="keyword">in</span> attribute) &#123;</span><br><span class="line">                <span class="type">MASViewConstraint</span> <span class="operator">*</span>viewConstraint <span class="operator">=</span> [<span class="keyword">self</span> copy];</span><br><span class="line">                viewConstraint.layoutRelation <span class="operator">=</span> relation;</span><br><span class="line">                viewConstraint.secondViewAttribute <span class="operator">=</span> attr;</span><br><span class="line">                [children addObject:viewConstraint];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">MASCompositeConstraint</span> <span class="operator">*</span>compositeConstraint <span class="operator">=</span> [[<span class="type">MASCompositeConstraint</span> alloc] initWithChildren:children];</span><br><span class="line">            compositeConstraint.delegate <span class="operator">=</span> <span class="keyword">self</span>.delegate;</span><br><span class="line">            [<span class="keyword">self</span>.delegate constraint:<span class="keyword">self</span> shouldBeReplacedWithConstraint:compositeConstraint];</span><br><span class="line">            <span class="keyword">return</span> compositeConstraint;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">NSAssert</span>(<span class="operator">!</span><span class="keyword">self</span>.hasLayoutRelation <span class="operator">||</span> <span class="keyword">self</span>.layoutRelation <span class="operator">==</span> relation <span class="operator">&amp;&amp;</span> [attribute isKindOfClass:<span class="type">NSValue</span>.class], @<span class="string">&quot;Redefinition of constraint relation&quot;</span>);</span><br><span class="line">            <span class="keyword">self</span>.layoutRelation <span class="operator">=</span> relation;</span><br><span class="line">            <span class="keyword">self</span>.secondViewAttribute <span class="operator">=</span> attribute;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们调用的时候传递进来了两个参数attribute 和 NSLayoutRelationEqual一个是关系，一个是属性。也就是说每个MASViewConstraint都有两个属性firstViewAttribute以及secondViewAttribute以及它们之间的关系layoutRelation。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, <span class="built_in">NSLayoutRelation</span>) &#123;</span><br><span class="line">    <span class="built_in">NSLayoutRelationLessThanOrEqual</span> = <span class="number">-1</span>,<span class="comment">/*小于或者等于*/</span></span><br><span class="line">    <span class="built_in">NSLayoutRelationEqual</span> = <span class="number">0</span>, <span class="comment">/*等于*/</span></span><br><span class="line">    <span class="built_in">NSLayoutRelationGreaterThanOrEqual</span> = <span class="number">1</span>,<span class="comment">/*大于等于*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里得重点看下secondViewAttribute的设置过程</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)setSecondViewAttribute:(<span class="type">id</span>)secondViewAttribute &#123;</span><br><span class="line">    <span class="comment">//1.</span></span><br><span class="line">    <span class="keyword">if</span> ([secondViewAttribute isKindOfClass:<span class="built_in">NSValue</span>.class]) &#123;</span><br><span class="line">        [<span class="keyword">self</span> setLayoutConstantWithValue:secondViewAttribute];</span><br><span class="line">    <span class="comment">//2.</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([secondViewAttribute isKindOfClass:MAS_VIEW.class]) &#123;</span><br><span class="line">        _secondViewAttribute = [[MASViewAttribute alloc] initWithView:secondViewAttribute layoutAttribute:<span class="keyword">self</span>.firstViewAttribute.layoutAttribute];</span><br><span class="line">    <span class="comment">//3.</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([secondViewAttribute isKindOfClass:MASViewAttribute.class]) &#123;</span><br><span class="line">        _secondViewAttribute = secondViewAttribute;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">NSAssert</span>(<span class="literal">NO</span>, <span class="string">@&quot;attempting to add unsupported attribute: %@&quot;</span>, secondViewAttribute);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有三个分支对应如下三种情况：</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>. <span class="selector-tag">make</span><span class="selector-class">.left</span><span class="selector-class">.equalTo</span>(<span class="variable">@150</span>); 传入 <span class="selector-tag">NSValue</span> 的时, 会直接设置 <span class="selector-tag">constraint</span></span><br><span class="line"><span class="number">2</span>. <span class="selector-tag">make</span><span class="selector-class">.left</span><span class="selector-class">.equalTo</span>(view); 这时, 就会初始化一个 <span class="selector-tag">layoutAttribute</span> 属性与 <span class="selector-tag">firstViewArribute</span> 相同的 <span class="selector-tag">MASViewAttribute</span></span><br><span class="line"><span class="number">3</span>. <span class="selector-tag">make</span><span class="selector-class">.left</span><span class="selector-class">.equalTo</span>(view.mas_right); 传入一个<span class="selector-tag">MASViewAttribute</span></span><br></pre></td></tr></table></figure>

<p>我们再回过头以下面约束为例子看下整个流程：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">make.top.equal<span class="constructor">To(<span class="params">superview</span>.<span class="params">mas_top</span>)</span>.<span class="keyword">with</span>.offset(padding.top);</span><br></pre></td></tr></table></figure>
<p>在调用make.top的时候会往通过block抛出来的MASConstraintMaker中添加一个MASViewConstraint，并将(mas_top)这个属性作为MASViewConstraint的firstViewAttribute，在调用equalTo的时候{superview.mas_top}将作为secondViewAttribute添加到刚刚创建的MASViewConstraint，并将MASViewConstraint中的layoutRelation标记为NSLayoutRelationEqual。这时候返回的是self。也就是MASViewConstraint类型。</p>
<p>调用.with的时候只是一种美观写法，实际上还是转调了self。没啥用处可以不写。</p>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line">- (MASConstraint *)<span class="keyword">with</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们再接着往下面看.offset</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">- (MASConstraint * (^)(CGFloat))<span class="built_in">offset</span> &#123;</span><br><span class="line"><span class="built_in">    return</span> ^<span class="built_in">id</span>(CGFloat <span class="built_in">offset</span>)&#123;</span><br><span class="line">        self.<span class="built_in">offset</span> = <span class="built_in">offset</span>;</span><br><span class="line"><span class="built_in">        return</span> self;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setOffset:(CGFloat)<span class="built_in">offset</span> &#123;</span><br><span class="line">    self.layoutConstant = <span class="built_in">offset</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里设置了layoutConstant的值。到目前位置应该可以梳理下各个对象之间到关系了，整个关系如下图所示：</p>
<p><img src="/2019/11/03/%E5%9F%BA%E4%BA%8EAutoLayout%E7%9A%84%E5%BC%80%E6%BA%90%E5%B8%83%E5%B1%80%E5%BA%93Masonry%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/000001.png"></p>
<p>每个view都有一个MASConstraintMaker，MASConstraintMaker里面有个数组constraints用于存放我们为view添加的各个约束条件，每个约束条件都对应一条MASConstraint,MASConstraint有两个子类MASViewConstraint和MASCompositeConstraint，.top .left 这种约束属于MASViewConstraint。.size .center一般是多个约束的简化属于MASViewConstraint。<br>我们会将mas_top和subview.mas_top分别作为firstViewAttribute和secondViewAttribute，并用layoutRelation标明之间的关系。对于offset等布局常量都存放在layoutConstant，除了这些属性外还有layoutMultiplier，layoutPriority这些重要属性。</p>
<h6 id="2-约束条件的应用"><a href="#2-约束条件的应用" class="headerlink" title="2. 约束条件的应用"></a>2. 约束条件的应用</h6><p>到目前位置我们构建了当前view到约束条件，接下来我们就看如何将这些约束条件应用到view上：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">NSArray</span> *)install &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.removeExisting) &#123;</span><br><span class="line">        <span class="built_in">NSArray</span> *installedConstraints = [MASViewConstraint installedConstraintsForView:<span class="keyword">self</span>.view];</span><br><span class="line">        <span class="keyword">for</span> (MASConstraint *constraint <span class="keyword">in</span> installedConstraints) &#123;</span><br><span class="line">            [constraint uninstall];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSArray</span> *constraints = <span class="keyword">self</span>.constraints.copy;</span><br><span class="line">    <span class="keyword">for</span> (MASConstraint *constraint <span class="keyword">in</span> constraints) &#123;</span><br><span class="line">        constraint.updateExisting = <span class="keyword">self</span>.updateExisting;</span><br><span class="line">        [constraint install];</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="keyword">self</span>.constraints removeAllObjects];</span><br><span class="line">    <span class="keyword">return</span> constraints;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先先判断removeExisting字段，这个字段在mas_remakeConstraints的时候设置为YES.也就是说在mas_remakeConstraints中应用新的约束之前会将当前view上的所有的约束给清除后再应用新的。<br>在install方法中会对constraints的每个约束调用install方法进行应用。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="operator">-</span> (void)install &#123;</span><br><span class="line">    <span class="comment">//在install之前，会做一次判断，看是否已经被install过</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.hasBeenInstalled) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果layoutConstraint支持active方法则将self.layoutConstraint.active标记为YES.</span></span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span> supportsActiveProperty] <span class="operator">&amp;&amp;</span> <span class="keyword">self</span>.layoutConstraint) &#123;</span><br><span class="line">        <span class="keyword">self</span>.layoutConstraint.active <span class="operator">=</span> <span class="type">YES</span>;</span><br><span class="line">        <span class="comment">//并将当前约束添加到mas_installedConstraints，mas_installedConstraints这里记录着已经安装的约束。</span></span><br><span class="line">        [<span class="keyword">self</span>.firstViewAttribute.view.mas_installedConstraints addObject:<span class="keyword">self</span>];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 否则，使用传统方式，把约束添加到对应位置</span></span><br><span class="line">    <span class="comment">//取出firstLayoutAttribute和secondLayoutAttribute对应的数据</span></span><br><span class="line">    <span class="type">MAS_VIEW</span> <span class="operator">*</span>firstLayoutItem <span class="operator">=</span> <span class="keyword">self</span>.firstViewAttribute.item;</span><br><span class="line">    <span class="type">NSLayoutAttribute</span> firstLayoutAttribute <span class="operator">=</span> <span class="keyword">self</span>.firstViewAttribute.layoutAttribute;</span><br><span class="line">    <span class="type">MAS_VIEW</span> <span class="operator">*</span>secondLayoutItem <span class="operator">=</span> <span class="keyword">self</span>.secondViewAttribute.item;</span><br><span class="line">    <span class="type">NSLayoutAttribute</span> secondLayoutAttribute <span class="operator">=</span> <span class="keyword">self</span>.secondViewAttribute.layoutAttribute;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// alignment attributes must have a secondViewAttribute</span></span><br><span class="line">    <span class="comment">// therefore we assume that is refering to superview</span></span><br><span class="line">    <span class="comment">// eg make.left.equalTo(@10)</span></span><br><span class="line">    <span class="comment">//对于对齐属性必须要有secondViewAttribute，也即是参照的对象。如果self.secondViewAttribute是空的</span></span><br><span class="line">    <span class="comment">//这里会将参照的对象设置为当前对象的父对象。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="operator">!</span><span class="keyword">self</span>.firstViewAttribute.isSizeAttribute <span class="operator">&amp;&amp;</span> <span class="operator">!</span><span class="keyword">self</span>.secondViewAttribute) &#123;</span><br><span class="line">        secondLayoutItem <span class="operator">=</span> <span class="keyword">self</span>.firstViewAttribute.view.superview;</span><br><span class="line">        secondLayoutAttribute <span class="operator">=</span> firstLayoutAttribute;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">MASLayoutConstraint</span> <span class="operator">*</span>layoutConstraint</span><br><span class="line">        <span class="operator">=</span> [<span class="type">MASLayoutConstraint</span> constraintWithItem:firstLayoutItem</span><br><span class="line">                                        attribute:firstLayoutAttribute</span><br><span class="line">                                        relatedBy:<span class="keyword">self</span>.layoutRelation</span><br><span class="line">                                           toItem:secondLayoutItem</span><br><span class="line">                                        attribute:secondLayoutAttribute</span><br><span class="line">                                       multiplier:<span class="keyword">self</span>.layoutMultiplier</span><br><span class="line">                                         constant:<span class="keyword">self</span>.layoutConstant];</span><br><span class="line">    </span><br><span class="line">    layoutConstraint.priority <span class="operator">=</span> <span class="keyword">self</span>.layoutPriority;</span><br><span class="line">    layoutConstraint.mas_key <span class="operator">=</span> <span class="keyword">self</span>.mas_key;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.secondViewAttribute.view) &#123;</span><br><span class="line">        <span class="type">MAS_VIEW</span> <span class="operator">*</span>closestCommonSuperview <span class="operator">=</span> [<span class="keyword">self</span>.firstViewAttribute.view mas_closestCommonSuperview:<span class="keyword">self</span>.secondViewAttribute.view];</span><br><span class="line">        <span class="keyword">self</span>.installedView <span class="operator">=</span> closestCommonSuperview;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">self</span>.firstViewAttribute.isSizeAttribute) &#123;</span><br><span class="line">        <span class="keyword">self</span>.installedView <span class="operator">=</span> <span class="keyword">self</span>.firstViewAttribute.view;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.installedView <span class="operator">=</span> <span class="keyword">self</span>.firstViewAttribute.view.superview;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">MASLayoutConstraint</span> <span class="operator">*</span>existingConstraint <span class="operator">=</span> <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.updateExisting) &#123;</span><br><span class="line">        existingConstraint <span class="operator">=</span> [<span class="keyword">self</span> layoutConstraintSimilarTo:layoutConstraint];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (existingConstraint) &#123;</span><br><span class="line">        <span class="comment">// just update the constant</span></span><br><span class="line">        existingConstraint.constant <span class="operator">=</span> layoutConstraint.constant;</span><br><span class="line">        <span class="keyword">self</span>.layoutConstraint <span class="operator">=</span> existingConstraint;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        [<span class="keyword">self</span>.installedView addConstraint:layoutConstraint];</span><br><span class="line">        <span class="keyword">self</span>.layoutConstraint <span class="operator">=</span> layoutConstraint;</span><br><span class="line">        [firstLayoutItem.mas_installedConstraints addObject:<span class="keyword">self</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们一步步来看下：</p>
<ol>
<li>先检查下是否已经应用过了，如果已经应用过了就直接返回</li>
</ol>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">self</span>.hasBeenInstalled) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>如果layoutConstraint支持active方法则将self.layoutConstraint.active标记为YES.</li>
</ol>
<p>iOS 8版本之后，Auto Layout推出新的接口。NSLayoutConstraint多了一个active属性，用于激活、失效一个约束。不需要再考虑约束安装位置。原本用于添加、移除约束的接口addConstraint&#x2F;addConstraints、removeConstraint&#x2F;removeConstraints，在后续的版本升级将会过期，这里是对iOS 8版本之后做的适配。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> ([<span class="keyword">self</span> supportsActiveProperty] &amp;&amp; <span class="keyword">self</span>.layoutConstraint) &#123;</span><br><span class="line">    <span class="keyword">self</span>.layoutConstraint.active = <span class="literal">YES</span>;</span><br><span class="line">    <span class="comment">//并将当前约束添加到mas_installedConstraints，mas_installedConstraints这里记录着已经安装的约束。</span></span><br><span class="line">    [<span class="keyword">self</span>.firstViewAttribute.view.mas_installedConstraints addObject:<span class="keyword">self</span>];</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>取出参数并对需要的参数做修正：在应用之前会将firstLayoutAttribute和secondLayoutAttribute的对应的数据取出。如果当前元素为对齐属性那么必须要有secondViewAttribute，也即是参照的对象。如果这种情况下self.secondViewAttribute是空的这里会将参照的对象设置为当前对象的父对象。</p>
</li>
<li><p>将MASViewConstraint转换成原生的AutoLayout约束条件：<br>也就是把我们在block中设置的一条条MASViewConstraint生成一个个约束</p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line">MASLayoutConstraint *layoutC<span class="attr">onstraint</span></span><br><span class="line">    <span class="operator">=</span> [MASLayoutConstraint constraintWithItem:firstLayoutItem</span><br><span class="line"><span class="symbol">                                    attribute:</span>firstLayoutAttribute</span><br><span class="line"><span class="symbol">                                    relatedBy:</span>self.layoutRelation</span><br><span class="line"><span class="symbol">                                        toItem:</span>secondLayoutItem</span><br><span class="line"><span class="symbol">                                    attribute:</span>secondLayoutAttribute</span><br><span class="line"><span class="symbol">                                    multiplier:</span>self.layoutMultiplier</span><br><span class="line"><span class="symbol">                                        constant:</span>self.layoutConstant]<span class="punctuation">;</span></span><br><span class="line"></span><br><span class="line">layoutConstraint.<span class="attr">priority</span> <span class="operator">=</span> self.layoutP<span class="attr">riority</span><span class="punctuation">;</span></span><br><span class="line">layoutConstraint.mas_<span class="attr">key</span> <span class="operator">=</span> self.mas_<span class="attr">key</span><span class="punctuation">;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>确定installedView</p>
</li>
</ol>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 例如make.left.equalTo(view) 情况</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">self</span>.secondViewAttribute.view) &#123;</span><br><span class="line">    <span class="type">MAS_VIEW</span> <span class="operator">*</span>closestCommonSuperview <span class="operator">=</span> [<span class="keyword">self</span>.firstViewAttribute.view mas_closestCommonSuperview:<span class="keyword">self</span>.secondViewAttribute.view];</span><br><span class="line">    <span class="keyword">self</span>.installedView <span class="operator">=</span> closestCommonSuperview;</span><br><span class="line"><span class="comment">// 例如make.left.equalTo(@40) 情况</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">self</span>.firstViewAttribute.isSizeAttribute) &#123;</span><br><span class="line">    <span class="keyword">self</span>.installedView <span class="operator">=</span> <span class="keyword">self</span>.firstViewAttribute.view;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">self</span>.installedView <span class="operator">=</span> <span class="keyword">self</span>.firstViewAttribute.view.superview;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这部分首先会看下self.secondViewAttribute.view是否有值，如果有的话，会通过mas_closestCommonSuperview来查找self.firstViewAttribute.view 和self.secondViewAttribute.view最近的公共父view作为self.installedView，<br>如果当前约束是尺寸约束，那么将self.firstViewAttribute.view作为self.installedView，否则将self.firstViewAttribute.view.superview作为self.installedView</p>
<ol start="5">
<li>应用或者更新installedView上的对应约束</li>
</ol>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">MASLayoutConstraint *existingConstraint = <span class="literal">nil</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">self</span>.updateExisting) &#123;</span><br><span class="line">    existingConstraint = [<span class="keyword">self</span> layoutConstraintSimilarTo:layoutConstraint];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (existingConstraint) &#123;</span><br><span class="line">    <span class="comment">// just update the constant</span></span><br><span class="line">    existingConstraint.constant = layoutConstraint.constant;</span><br><span class="line">    <span class="keyword">self</span>.layoutConstraint = existingConstraint;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    [<span class="keyword">self</span>.installedView addConstraint:layoutConstraint];</span><br><span class="line">    <span class="keyword">self</span>.layoutConstraint = layoutConstraint;</span><br><span class="line">    [firstLayoutItem.mas_installedConstraints addObject:<span class="keyword">self</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>updateExisting是在mas_updateConstraints方法中设置的，也就是说如果是更新某个约束条件的话先通过layoutConstraintSimilarTo找到对应的约束，如果找到了就将找到的约束赋值给self.layoutConstraint，如果没有相似的就调用addConstraint来应用约束。到此整个流程结束。</p>
<p>最后用一张图来结束这篇博客：</p>
<p><img src="/2019/11/03/%E5%9F%BA%E4%BA%8EAutoLayout%E7%9A%84%E5%BC%80%E6%BA%90%E5%B8%83%E5%B1%80%E5%BA%93Masonry%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/00002.png"></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/iOS-%E5%BC%80%E6%BA%90%E5%BA%93%E5%88%86%E6%9E%90/">iOS 开源库分析</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/iOS-开源库分析/">iOS 开源库分析</a>
  </div>

</div>



<div class="comments-count">
	
	  	<span></span>
		<a href="/2019/11/03/基于AutoLayout的开源布局库Masonry源码解析/#comments" class="ds-thread-count comments-count-link" data-thread-key="2019/11/03/基于AutoLayout的开源布局库Masonry源码解析/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/11/01/加解密技术概述/" title="加解密技术概述" itemprop="url">加解密技术概述</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Edgar" target="_blank" itemprop="author">Edgar</a>
		
  <p class="article-time">
    <time datetime="2019-10-31T18:27:20.000Z" itemprop="datePublished"> Published 2019-11-01</time>
    
  </p>
</header>
    <div class="article-content">
        
        
        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/iOS-%E5%BC%80%E6%BA%90%E5%BA%93%E5%88%86%E6%9E%90/">iOS 开源库分析</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/iOS-开源库分析/">iOS 开源库分析</a>
  </div>

</div>



<div class="comments-count">
	
	  	<span></span>
		<a href="/2019/11/01/加解密技术概述/#comments" class="ds-thread-count comments-count-link" data-thread-key="2019/11/01/加解密技术概述/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/10/30/图解加解密/" title="图解加解密" itemprop="url">图解加解密</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Edgar" target="_blank" itemprop="author">Edgar</a>
		
  <p class="article-time">
    <time datetime="2019-10-30T14:11:53.000Z" itemprop="datePublished"> Published 2019-10-30</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p><img src="/2019/10/30/%E5%9B%BE%E8%A7%A3%E5%8A%A0%E8%A7%A3%E5%AF%86/0001.png"></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/iOS-%E5%BC%80%E6%BA%90%E5%BA%93%E5%88%86%E6%9E%90/">iOS 开源库分析</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/iOS-开源库分析/">iOS 开源库分析</a>
  </div>

</div>



<div class="comments-count">
	
	  	<span></span>
		<a href="/2019/10/30/图解加解密/#comments" class="ds-thread-count comments-count-link" data-thread-key="2019/10/30/图解加解密/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/10/27/图解移动端日志系统/" title="图解移动端日志系统" itemprop="url">图解移动端日志系统</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Edgar" target="_blank" itemprop="author">Edgar</a>
		
  <p class="article-time">
    <time datetime="2019-10-27T15:12:54.000Z" itemprop="datePublished"> Published 2019-10-27</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p><img src="/2019/10/27/%E5%9B%BE%E8%A7%A3%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/001.png"></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/iOS-%E5%BC%80%E6%BA%90%E5%BA%93%E5%88%86%E6%9E%90/">iOS 开源库分析</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/iOS-开源库分析/">iOS 开源库分析</a>
  </div>

</div>



<div class="comments-count">
	
	  	<span></span>
		<a href="/2019/10/27/图解移动端日志系统/#comments" class="ds-thread-count comments-count-link" data-thread-key="2019/10/27/图解移动端日志系统/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>







  <nav id="page-nav" class="clearfix">
    <a class="extend prev" rel="prev" href="/page/4/">&lt;span&gt;&lt;&#x2F;span&gt;Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/page/30/">30</a><a class="extend next" rel="next" href="/page/6/">Next&lt;span&gt;&lt;&#x2F;span&gt;</a>
  </nav>

</div>
      <div class="openaside"><a class="navbutton" href="#" title="Show Sidebar"></a></div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="Hide Sidebar"></a></div>
<aside class="clearfix">
<div id="authorInfo">
	
		<div class="author-img"></div>		
	
	<div class="social-info" class="clearfix">
		
		
		<a href="https://github.com/tbfungeek" target="_blank" class="icon-github" title="github"></a>
		
		
		
		
		
		
		
		
		
		
		<a href="mailto:tbfungeek@163.com" target="_blank" class="icon-email" title="Email Me"></a>
		

	</div>
</div>

  
<div class="categorieslist">
	<p class="asidetitle">Categories</p>
		<ul>
		
		  
			<li><a href="/categories/Android-小经验/" title="Android 小经验">Android 小经验<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Android-源码分析/" title="Android 源码分析">Android 源码分析<sup>21</sup></a></li>
		  
		
		  
			<li><a href="/categories/Android其他/" title="Android其他">Android其他<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Android初步/" title="Android初步">Android初步<sup>21</sup></a></li>
		  
		
		  
			<li><a href="/categories/Android进阶/" title="Android进阶">Android进阶<sup>100</sup></a></li>
		  
		
		  
			<li><a href="/categories/Hexo-使用/" title="Hexo 使用">Hexo 使用<sup>10</sup></a></li>
		  
		
		  
			<li><a href="/categories/JavaScript理论/" title="JavaScript理论">JavaScript理论<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Objective-C-相关/" title="Objective C 相关">Objective C 相关<sup>24</sup></a></li>
		  
		
		  
			<li><a href="/categories/OpenCV/" title="OpenCV">OpenCV<sup>6</sup></a></li>
		  
		
		  
			<li><a href="/categories/ROS/" title="ROS">ROS<sup>9</sup></a></li>
		  
		
		  
			<li><a href="/categories/iOS-工具使用/" title="iOS 工具使用">iOS 工具使用<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/iOS-开源库分析/" title="iOS 开源库分析">iOS 开源库分析<sup>36</sup></a></li>
		  
		
		  
			<li><a href="/categories/iOS-理论基础/" title="iOS 理论基础">iOS 理论基础<sup>14</sup></a></li>
		  
		
		  
			<li><a href="/categories/iOS-进阶/" title="iOS 进阶">iOS 进阶<sup>4</sup></a></li>
		  
		
		  
			<li><a href="/categories/个人收藏/" title="个人收藏">个人收藏<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/代码规范/" title="代码规范">代码规范<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/其他/" title="其他">其他<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/博客分类目录/" title="博客分类目录">博客分类目录<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/叨叨系列/" title="叨叨系列">叨叨系列<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/开源代码分析/" title="开源代码分析">开源代码分析<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/开源库分析/" title="开源库分析">开源库分析<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/树莓派/" title="树莓派">树莓派<sup>4</sup></a></li>
		  
		
		  
			<li><a href="/categories/版本控制/" title="版本控制">版本控制<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/直播/" title="直播">直播<sup>6</sup></a></li>
		  
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">Tags</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/iOS-开源库分析/" title="iOS 开源库分析">iOS 开源库分析<sup>36</sup></a></li>
			
		
			
				<li><a href="/tags/Android-设计模式/" title="Android 设计模式">Android 设计模式<sup>29</sup></a></li>
			
		
			
				<li><a href="/tags/Objective-C-相关/" title="Objective C 相关">Objective C 相关<sup>24</sup></a></li>
			
		
			
				<li><a href="/tags/Android基础/" title="Android基础">Android基础<sup>21</sup></a></li>
			
		
			
				<li><a href="/tags/AOSP-源码/" title="AOSP 源码">AOSP 源码<sup>17</sup></a></li>
			
		
			
				<li><a href="/tags/Android-常用第三方库/" title="Android 常用第三方库">Android 常用第三方库<sup>15</sup></a></li>
			
		
			
				<li><a href="/tags/iOS-理论基础/" title="iOS 理论基础">iOS 理论基础<sup>14</sup></a></li>
			
		
			
				<li><a href="/tags/Hexo-使用/" title="Hexo 使用">Hexo 使用<sup>10</sup></a></li>
			
		
			
				<li><a href="/tags/ROS/" title="ROS">ROS<sup>9</sup></a></li>
			
		
			
				<li><a href="/tags/Android-动画进阶/" title="Android 动画进阶">Android 动画进阶<sup>8</sup></a></li>
			
		
			
				<li><a href="/tags/Android-JNI/" title="Android JNI">Android JNI<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/Android-绘图进阶/" title="Android 绘图进阶">Android 绘图进阶<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/Android性能优化/" title="Android性能优化">Android性能优化<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/Android-自动化测试/" title="Android 自动化测试">Android 自动化测试<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/OpenCV/" title="OpenCV">OpenCV<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/直播/" title="直播">直播<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/Android-开源源码/" title="Android 开源源码">Android 开源源码<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/Android-自定义View进阶/" title="Android 自定义View进阶">Android 自定义View进阶<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/树莓派/" title="树莓派">树莓派<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/iOS-进阶/" title="iOS 进阶">iOS 进阶<sup>4</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">Links</p>
    <ul>
        
          <li>
            
            	<a href="https://hexo.io" target="_blank" title="Hexo">Hexo</a>
            
          </li>
        
          <li>
            
            	<a href="https://pages.github.com/" target="_blank" title="GitHub">GitHub</a>
            
          </li>
        
          <li>
            
            	<a href="http://pf18.github.io/" target="_blank" title="PF18">PF18</a>
            
          </li>
        
          <li>
            
            	<a href="http://toutiao.io/" target="_blank" title="开发者头条">开发者头条</a>
            
          </li>
        
          <li>
            
            	<a href="http://www.jcodecraeer.com/" target="_blank" title="泡在网上的日子">泡在网上的日子</a>
            
          </li>
        
    </ul>
</div>

  


  <div class="rsspart">
	<a href="atom.xml" target="_blank" title="rss">RSS</a>
</div>

  
  <div class="tagcloudlist">
    <p class="asidetitle">Tag Cloud</p>
    <div class="tagcloudlist clearfix">
       <a href="/tags/AOSP-%E6%BA%90%E7%A0%81/" style="font-size: 17.14px;">AOSP 源码</a> <a href="/tags/Android-APK-%E7%AD%BE%E5%90%8D/" style="font-size: 10px;">Android APK 签名</a> <a href="/tags/Android-JNI/" style="font-size: 12.86px;">Android JNI</a> <a href="/tags/Android-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E8%BF%9B%E9%98%B6/" style="font-size: 10.71px;">Android 事件处理进阶</a> <a href="/tags/Android-%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6/" style="font-size: 13.57px;">Android 动画进阶</a> <a href="/tags/Android-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%80%E5%8F%91/" style="font-size: 10px;">Android 多线程开发</a> <a href="/tags/Android-%E5%B0%8F%E7%BB%8F%E9%AA%8C/" style="font-size: 10px;">Android 小经验</a> <a href="/tags/Android-%E5%B8%B8%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/" style="font-size: 16.43px;">Android 常用第三方库</a> <a href="/tags/Android-%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/" style="font-size: 10px;">Android 开发流程</a> <a href="/tags/Android-%E5%BC%80%E6%BA%90%E6%BA%90%E7%A0%81/" style="font-size: 12.14px;">Android 开源源码</a> <a href="/tags/Android-%E7%BB%98%E5%9B%BE%E8%BF%9B%E9%98%B6/" style="font-size: 12.86px;">Android 绘图进阶</a> <a href="/tags/Android-%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/" style="font-size: 12.86px;">Android 自动化测试</a> <a href="/tags/Android-%E8%87%AA%E5%AE%9A%E4%B9%89View%E8%BF%9B%E9%98%B6/" style="font-size: 12.14px;">Android 自定义View进阶</a> <a href="/tags/Android-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 19.29px;">Android 设计模式</a> <a href="/tags/Android%E5%85%B6%E4%BB%96/" style="font-size: 10px;">Android其他</a> <a href="/tags/Android%E5%9F%BA%E7%A1%80/" style="font-size: 17.86px;">Android基础</a> <a href="/tags/Android%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/" style="font-size: 10px;">Android开发流程</a> <a href="/tags/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" style="font-size: 12.86px;">Android性能优化</a> <a href="/tags/Android%E6%B7%B7%E6%B7%86%E6%8A%80%E6%9C%AF/" style="font-size: 10px;">Android混淆技术</a> <a href="/tags/Android%E8%B4%A8%E9%87%8F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/" style="font-size: 11.43px;">Android质量管理工具</a> <a href="/tags/Android%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/" style="font-size: 10px;">Android逆向工程</a> <a href="/tags/Git-github/" style="font-size: 10px;">Git && github</a> <a href="/tags/Hexo-%E4%BD%BF%E7%94%A8/" style="font-size: 15px;">Hexo 使用</a> <a href="/tags/JavaScript/" style="font-size: 10px;">JavaScript</a> <a href="/tags/Linux-%E4%BD%BF%E7%94%A8/" style="font-size: 10px;">Linux 使用</a> <a href="/tags/Objective-C-%E7%9B%B8%E5%85%B3/" style="font-size: 18.57px;">Objective C 相关</a> <a href="/tags/OpenCV/" style="font-size: 12.86px;">OpenCV</a> <a href="/tags/ROS/" style="font-size: 14.29px;">ROS</a> <a href="/tags/iOS-%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/" style="font-size: 10.71px;">iOS 工具使用</a> <a href="/tags/iOS-%E5%BC%80%E6%BA%90%E5%BA%93%E5%88%86%E6%9E%90/" style="font-size: 20px;">iOS 开源库分析</a> <a href="/tags/iOS-%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/" style="font-size: 15.71px;">iOS 理论基础</a> <a href="/tags/iOS-%E8%BF%9B%E9%98%B6/" style="font-size: 12.14px;">iOS 进阶</a> <a href="/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/" style="font-size: 10px;">代码规范</a> <a href="/tags/%E5%8D%9A%E5%AE%A2%E5%88%86%E7%B1%BB%E7%9B%AE%E5%BD%95/" style="font-size: 10.71px;">博客分类目录</a> <a href="/tags/%E5%8F%A8%E5%8F%A8%E7%B3%BB%E5%88%97/" style="font-size: 10px;">叨叨系列</a> <a href="/tags/%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/" style="font-size: 11.43px;">工具的使用</a> <a href="/tags/%E5%BC%80%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/" style="font-size: 10.71px;">开源代码分析</a> <a href="/tags/%E5%BC%80%E6%BA%90%E5%BA%93%E5%88%86%E6%9E%90/" style="font-size: 10px;">开源库分析</a> <a href="/tags/%E6%9D%82%E7%B1%BB/" style="font-size: 10px;">杂类</a> <a href="/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/" style="font-size: 12.14px;">树莓派</a> <a href="/tags/%E7%9B%B4%E6%92%AD/" style="font-size: 12.86px;">直播</a> <a href="/tags/%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/" style="font-size: 10.71px;">编程技巧</a> <a href="/tags/%E7%BD%91%E7%AB%99%E6%94%B6%E8%97%8F/" style="font-size: 10px;">网站收藏</a> <a href="/tags/%E9%87%8D%E8%A6%81%E6%8E%A7%E4%BB%B6/" style="font-size: 11.43px;">重要控件</a>
    </div>
  </div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
		
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/hsihohuang/kiddochan" target="_blank" title="Kiddochan">Kiddochan</a> © 2022 
		
		<a href="/about" target="_blank" title="Edgar">Edgar</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
        
    }
  });
});
</script>










<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?7c9443b0374f1cf6b1dbb5ab84d939cb";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="Back to Top"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
 </html>
