
 <!DOCTYPE HTML>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
  
    <title>Edgar&#39;s Blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="Edgar">
    

    
    <meta name="description" content="Android | 全栈工程师">
<meta property="og:type" content="website">
<meta property="og:title" content="Edgar&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="Edgar&#39;s Blog">
<meta property="og:description" content="Android | 全栈工程师">
<meta property="og:locale">
<meta property="article:author" content="Edgar">
<meta name="twitter:card" content="summary">

    
    <link rel="alternative" href="atom.xml" title="Edgar&#39;s Blog" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/unnamed4_n_mSY_icon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/profile.png">
    <link rel="apple-touch-icon-precomposed" href="/img/profile.png">
    
    
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 6.2.0"></head>

  <body>
    <header>
      
<div>
		
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="Edgar&#39;s Blog">Edgar&#39;s Blog</a></h1>
				<h2 class="blog-motto"></h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="Menu">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
					<li>
 					
					<form class="search" action="/search/index.html" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" autocomplete="off" name="q" maxlength="20" placeholder="Search" />
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main">

   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/12/24/iOS开源库源码分析之coobjc/" title="iOS开源库之coobjc使用" itemprop="url">iOS开源库之coobjc使用</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Edgar" target="_blank" itemprop="author">Edgar</a>
		
  <p class="article-time">
    <time datetime="2019-12-24T10:33:42.000Z" itemprop="datePublished"> Published 2019-12-24</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h4 id="开源信息"><a href="#开源信息" class="headerlink" title="开源信息"></a>开源信息</h4><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/alibaba/coobjc">coobjc 源码地址</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/wangjufan/coobjc/blob/master/README_cn.md">coobjc 文档地址</a></li>
<li><a target="_blank" rel="noopener" href="https://dkandalov.github.io/async-await">协程介绍</a></li>
</ul>
<p><img src="/2019/12/24/iOS%E5%BC%80%E6%BA%90%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8Bcoobjc/coobjc_icon.png"></p>
<p>coobjc 是由手淘架构团队推出的能在 iOS 上使用的协程开发框架，所以大家在了解coobjc之前必须先了解什么是协程，说到协程必定让人想起和它相关的两个概念<strong><strong>进程</strong></strong>和<strong><strong>线程</strong></strong>,<br>这里不会对这两个概念进行长篇大论，概括地讲对操作系统来说，线程是最小的执行单元，进程是最小的资源管理单元。进程负责开拓各个资源，线程共享这些资源，每个线程有单独的堆栈空间。并且无论进程还是线程，都是由操作系统所管理的。<br>而协程是用户态的微线程，协程不是被操作系统内核所管理，而完全是由程序所控制。</p>
<p>它的好处有哪些呢？</p>
<p>首先它可以以同步的方式写异步逻辑，可以避免“回调地域”现象，在性能方面调度性能更快，协程本身不需要进行内核级线程的切换，调度性能快，即使创建上万个协程也毫无压力。协程的使用以帮助开发减少锁、信号量的滥用。<br>对于经常进行高并发处理的服务端协程是很实用的。但是这不意味着移动端就不需要协程了。就iOS开发而言Objective C中基于Block 的异步编程回调也会照成比较常见的“回调地域”。如果具备同步方式编写异步代码可以极大地改善我们代码的逻辑结构，并且由于协程的引入也可以减少因为锁的使用带来的性能损耗。</p>
<h4 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h4><p>下面是coobjc的整体架构图：</p>
<p><img src="/2019/12/24/iOS%E5%BC%80%E6%BA%90%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8Bcoobjc/framework_arch.png"></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">底层是协程的核心，包括堆栈切换管理，协程调度，协程之间channel通信实现<span class="operator">。</span></span><br><span class="line">中间层是协程的封装，提供了 <span class="keyword">async</span><span class="operator">/</span><span class="keyword">await</span>, generator 和 <span class="type">Actor的支持</span><span class="operator">。</span></span><br><span class="line">顶层是对系统库的一个扩展，是对<span class="type">Foundation</span> 和 <span class="type">UIKit</span> <span class="type">IO及其他耗时操作的封装</span></span><br></pre></td></tr></table></figure>



<p>coobjec中每个协程都是可以暂停和恢复的，并且每个协程都分配一个单独的内存区域用于存储它的调用栈，它有四个状态分别是：<strong><strong>READY</strong></strong>，<strong><strong>RUNNING</strong></strong>，<strong><strong>SUSPEND</strong></strong>，<strong><strong>DEAD</strong></strong>，并且在运行过程中可以多次在<strong><strong>RUNNING</strong></strong>，<strong><strong>SUSPEND</strong></strong>状态之间进行切换。<br>下面是协程进行yield和resume操作的示意图：<br><img src="/2019/12/24/iOS%E5%BC%80%E6%BA%90%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8Bcoobjc/context.png"></p>
<p>coobjc内部使用一个调度器来负责用户所有协程的调度，它实际上是通过一个协程队列来进行管理，调度器会不断从队列中取出协程去执行。一旦队列中没有协程可以执行的时候，会切换到线程执行。所以当我们需要执行某个协程的时候，我们只需要将协程添加到某个线程的调度器队列中就可以了。<br>调度器负责执行它。</p>
<p><img src="/2019/12/24/iOS%E5%BC%80%E6%BA%90%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8Bcoobjc/scheduler.png"></p>
<p>话不多说我们来看下coobjc的具体用法：</p>
<h4 id="coobjc-的使用"><a href="#coobjc-的使用" class="headerlink" title="coobjc 的使用"></a>coobjc 的使用</h4><p><strong><strong>1 创建协程</strong></strong></p>
<p>coobjc可以在当前线程或者指定的queue创建协程，在哪里创建就会在哪个线程进行调度，当然还可以在指定的队列创建和运行协程。</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">co_launch(^&#123;</span><br><span class="line">    <span class="regexp">//</span>默认在当前线程进行调度</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">co_launch_onqueue(q, ^&#123;</span><br><span class="line">    <span class="regexp">//</span>在指定的队列中运行的协程</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong><strong>2 取消协程</strong></strong></p>
<p>在coobjc中协程是可取消的，ObjC不建议使用异常，所以coobjc中不使用异常来取消协程。要取消协程可以调用CCOCoroutine的cancel方法。通过co_isCancelled宏来查询当前协程是否被取消了。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">CCOCoroutine *co = co_launch(^&#123;</span><br><span class="line">    <span class="keyword">val</span>++;</span><br><span class="line">    co_delay(<span class="number">1.0</span>);</span><br><span class="line">    <span class="keyword">if</span>(co_isCancelled())&#123;</span><br><span class="line">        <span class="comment">//Do some cleaning operations</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span>++;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">[co cancel];</span><br></pre></td></tr></table></figure>
<p>在调用cancel后，协程的内部代码将不再继续执行，协程的内存将会被释放。</p>
<p><strong><strong>3. COPromise用法</strong></strong></p>
<p>await主要用于避免回调地狱现象，有时候我们会遇到请求两个不相关的数据接口后，将最终的数据组合后作为最终数据返回。如果不借助await的话，只能分别串行请求后最后将数据组合，这样会显得很低效。借助协程可以同时并行执行然后将数据合并。</p>
<ol>
<li>定义一个COPromise，在COPromise中通过fulfill 返回成功的结果，通过reject 返回失败的结果。返回的错误信息可以通过co_getError来获取。</li>
</ol>
<p><strong><strong>fulfill</strong></strong></p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">- (<span class="name">COPromise</span> *)testPromiseFullfill &#123;</span><br><span class="line">    COPromise *promise = [COPromise promise]<span class="comment">;</span></span><br><span class="line">    dispatch_async(<span class="name">dispatch_get_main_queue</span>(), ^&#123;</span><br><span class="line">        [promise fulfill:@<span class="string">&quot;Hello coobjc!&quot;</span>]<span class="comment">;</span></span><br><span class="line">    &#125;)<span class="comment">;</span></span><br><span class="line">    return promise<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">co_launch(^&#123;</span><br><span class="line">    id result = await([self testPromiseFullfill])<span class="comment">;</span></span><br><span class="line">    NSLog(@<span class="string">&quot;result = %@&quot;</span>,result)<span class="comment">;</span></span><br><span class="line">&#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p><strong><strong>reject</strong></strong></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (COPromise *)testPromiseReject &#123;</span><br><span class="line">    COPromise *promise = [COPromise promise];</span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        [promise reject:[<span class="built_in">NSError</span> errorWithDomain:<span class="string">@&quot;COPromise&quot;</span> code:<span class="number">-100</span> userInfo:<span class="literal">nil</span>]];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> promise;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">co_launch(^&#123;</span><br><span class="line">    <span class="type">id</span> result = await([<span class="keyword">self</span> testPromiseReject]);</span><br><span class="line">    <span class="built_in">NSError</span> *error = co_getError();</span><br><span class="line">    <span class="keyword">if</span>(error) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;Error = %@&quot;</span>,error);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;result = %@&quot;</span>,result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong><strong>fullfill &amp;&amp; reject</strong></strong> </p>
<figure class="highlight erlang"><table><tr><td class="code"><pre><span class="line">- <span class="params">(COPromise *)</span>testPromiseRejectFullfile &#123;</span><br><span class="line">    return [COPromise promise:^<span class="params">(COPromiseFulfill  _Nonnull fullfill, COPromiseReject  _Nonnull reject)</span> &#123;</span><br><span class="line">        dispatch_after<span class="params">(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">2</span> * NSEC_PER_SEC)</span>), dispatch_get_main_queue<span class="params">()</span>, ^&#123;</span><br><span class="line">            fullfill<span class="params">(@<span class="string">&quot;Say Hello To Coobjc&quot;</span>)</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">co_launch<span class="params">(^&#123;</span></span><br><span class="line"><span class="params">    id res = await([self testPromiseRejectFullfile]);</span></span><br><span class="line"><span class="params">    NSLog(@<span class="string">&quot;result = %@&quot;</span>,res);</span></span><br><span class="line"><span class="params">&#125;)</span>;</span><br></pre></td></tr></table></figure>

<p><strong><strong>cancel</strong></strong> </p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">- (<span class="name">COPromise</span> *)testPromiseCancel &#123;</span><br><span class="line">    COPromise *promise = [COPromise promise]<span class="comment">;</span></span><br><span class="line">    dispatch_async(<span class="name">dispatch_get_main_queue</span>(), ^&#123;</span><br><span class="line">        [promise cancel]<span class="comment">;</span></span><br><span class="line">    &#125;)<span class="comment">;</span></span><br><span class="line">    return promise<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">co_launch(^&#123;</span><br><span class="line">    COPromise *promise = [self testPromiseCancel];</span><br><span class="line">    [promise onCancel:^(COPromise * _Nonnull promise) &#123;</span><br><span class="line">        NSLog(@<span class="string">&quot;isCancel&quot;</span>)<span class="comment">;</span></span><br><span class="line">    &#125;]<span class="comment">;</span></span><br><span class="line">    </span><br><span class="line">    [promise catch:^(<span class="name">NSError</span> * _Nonnull error) &#123;</span><br><span class="line">        NSLog(@&quot;NSError&quot;);</span><br><span class="line">    &#125;];</span><br><span class="line">    id res = await(promise);</span><br><span class="line">    if(!res) &#123;</span><br><span class="line">        NSError *error = co_getError()<span class="comment">;</span></span><br><span class="line">        BOOL isPromiseCancel = [COPromise isPromiseCancelled<span class="symbol">:error</span>]<span class="comment">;</span></span><br><span class="line">        NSLog(@<span class="string">&quot;isPromiseCancel %ld&quot;</span>,isPromiseCancel)<span class="comment">;</span></span><br><span class="line">        return<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">    NSLog(@<span class="string">&quot;result = %@&quot;</span>,res)<span class="comment">;</span></span><br><span class="line">&#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p><strong><strong>then</strong></strong> </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">co_launch(^&#123;</span><br><span class="line">    COPromise *promise = [self testPromiseFullfill];</span><br><span class="line">    COPromise *thenPromise = [promise then:^<span class="built_in">id</span> _Nullable(<span class="built_in">id</span>  _Nullable value) &#123;</span><br><span class="line">        <span class="keyword">return</span> [self testPromiseThen];</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">id</span> res = <span class="keyword">await</span>(thenPromise);</span><br><span class="line">    <span class="keyword">if</span>(!res) &#123;</span><br><span class="line">        NSError *error = co_getError();</span><br><span class="line">        BOOL isPromiseCancel = [COPromise isPromiseCancelled:error];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    NSLog(@<span class="string">&quot;result = %@&quot;</span>,res);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong><strong>批量等待</strong></strong> </p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">co_launch(^&#123;</span><br><span class="line">    NSArray *<span class="keyword">batchFullfile </span>=</span><br><span class="line">    <span class="keyword">batch_await(@[</span></span><br><span class="line"><span class="keyword"></span>        [self testPromiseFullfill01],</span><br><span class="line">        [self testPromiseFullfill02],</span><br><span class="line">        [self testPromiseFullfill03],</span><br><span class="line">    ]);</span><br><span class="line">    </span><br><span class="line">    if(<span class="keyword">batchFullfile </span>&amp;&amp; <span class="keyword">batchFullfile.count) </span>&#123;</span><br><span class="line">        NSLog(@<span class="string">&quot;%@&quot;</span>,<span class="keyword">batchFullfile);</span></span><br><span class="line"><span class="keyword"></span>    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>我们来看下COPromise的一些关键属性和方法：</p>
<p>关键属性：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> Tell the promise is pending or not.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="type">BOOL</span> isPending;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> Tell the promise is fulfilled or not.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="type">BOOL</span> isFulfilled;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> Tell the promise is rejected or not.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="type">BOOL</span> isRejected;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> If fulfilled, value store into this property.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">nullable</span>) Value value;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> If reject, error store into this property</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">nullable</span>) <span class="built_in">NSError</span> *error;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>关键构造方法：</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> Create a promise without<span class="keyword"> constructor</span>. Which means, you should control when the job begins.</span><br><span class="line"></span><br><span class="line"> @return The `COPromise`<span class="built_in"> instance</span></span><br><span class="line"><span class="built_in"></span> */</span><br><span class="line">+ (instancetype)promise;</span><br><span class="line">/**</span><br><span class="line"> Create a promise with<span class="keyword"> constructor</span>. the job begans when someone observing on it.</span><br><span class="line"></span><br><span class="line"> @param<span class="keyword"> constructor</span> the<span class="keyword"> constructor</span> block.</span><br><span class="line"> @return The `COPromise`<span class="built_in"> instance</span></span><br><span class="line"><span class="built_in"></span> */</span><br><span class="line">+ (instancetype)promise:(COPromiseConstructor)constructor;</span><br><span class="line">/**</span><br><span class="line"> Create a promise with<span class="keyword"> constructor</span>. the job begans when someone observing on it.</span><br><span class="line"> </span><br><span class="line"> @param<span class="keyword"> constructor</span> the<span class="keyword"> constructor</span> block.</span><br><span class="line"> @param queue the dispatch_queue_t that the job run.</span><br><span class="line"> @return The `COPromise`<span class="built_in"> instance</span></span><br><span class="line"><span class="built_in"></span> */</span><br><span class="line">+ (instancetype)promise:(COPromiseConstructor)constructor onQueue:(dispatch_queue_t _Nullable )queue;</span><br></pre></td></tr></table></figure>


<p>关键方法：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> Fulfill the promise with a return value.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> <span class="doctag">@param</span> value the value fulfilled.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)fulfill:(nullable Value)value;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> Reject the promise with a error</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> <span class="doctag">@param</span> error the error.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)reject:(NSError * _Nullable)error;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> Cancel the job.</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> <span class="doctag">@discussion</span> If you want a `COPromise` be cancellable, you must make the job cancel in `onCancel:`.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)cancel;</span><br></pre></td></tr></table></figure>

<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> Set the onCancelBlock.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> <span class="doctag">@param</span> onCancelBlock will execute on the promise cancelled.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)onCancel:(COPromiseOnCancelBlock _Nullable )onCancelBlock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> Chained observe the promise fulfilled.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> <span class="doctag">@param</span> work the observer worker.</span></span><br><span class="line"><span class="comment"> <span class="doctag">@return</span> The chained promise instance.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (COPromise *)then:(COPromiseThenWorkBlock)work;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> Observe the promises rejected.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> <span class="doctag">@param</span> reject the reject dealing worker.</span></span><br><span class="line"><span class="comment"> <span class="doctag">@return</span> The chained promise instance.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (COPromise *)<span class="keyword">catch</span>:(COPromiseCatchWorkBlock)reject;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> Tell if the error is promise cancelled error</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> <span class="doctag">@param</span> error the error object</span></span><br><span class="line"><span class="comment"> <span class="doctag">@return</span> is cancellled error.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (BOOL)isPromiseCancelled:(NSError *)error;</span><br></pre></td></tr></table></figure>

<p><strong><strong>4.COProgressPromise用法</strong></strong></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> COProgressPromise* progressDownloadFileFromUrl(<span class="built_in">NSString</span> *url)&#123;</span><br><span class="line">    COProgressPromise *promise = [COProgressPromise promise];</span><br><span class="line">    [<span class="built_in">NSURLSession</span> sharedSession].configuration.requestCachePolicy = <span class="built_in">NSURLRequestReloadIgnoringCacheData</span>;</span><br><span class="line">    <span class="built_in">NSURLSessionDataTask</span> *task = [[<span class="built_in">NSURLSession</span> sharedSession] dataTaskWithURL:[<span class="built_in">NSURL</span> URLWithString:url] completionHandler:^(<span class="built_in">NSData</span> * _Nullable data, <span class="built_in">NSURLResponse</span> * _Nullable response, <span class="built_in">NSError</span> * _Nullable error) &#123;</span><br><span class="line">        <span class="keyword">if</span> (error) &#123;</span><br><span class="line">            [promise reject:error];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            [promise fulfill:data];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    [task resume];</span><br><span class="line">    <span class="keyword">if</span> (@available(iOS <span class="number">11.0</span>, *)) &#123;</span><br><span class="line">        [promise setupWithProgress:task.progress];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Fallback on earlier versions</span></span><br><span class="line">        <span class="built_in">NSProgress</span> *progress = [<span class="built_in">NSProgress</span> progressWithTotalUnitCount:<span class="number">10</span>];</span><br><span class="line">        [promise setupWithProgress:progress];</span><br><span class="line">        dispatch_source_t timer = <span class="literal">nil</span>;</span><br><span class="line">        <span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line">        timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, <span class="number">0</span>, <span class="number">0</span>, queue);</span><br><span class="line">        dispatch_source_set_timer(timer, dispatch_walltime(<span class="literal">NULL</span>, <span class="number">0</span>), <span class="number">0.1</span> * <span class="built_in">NSEC_PER_SEC</span>, <span class="number">0</span> * <span class="built_in">NSEC_PER_SEC</span>);</span><br><span class="line">        dispatch_source_set_event_handler(timer, ^&#123;</span><br><span class="line">            <span class="keyword">if</span> (progress.completedUnitCount &lt; progress.totalUnitCount) &#123;</span><br><span class="line">                progress.completedUnitCount += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                dispatch_source_cancel(timer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        dispatch_resume(timer);</span><br><span class="line">        [promise onCancel:^(COPromise * _Nonnull promise) &#123;</span><br><span class="line">            dispatch_source_cancel(timer);</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> promise;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">co_launch(^&#123;</span><br><span class="line">    <span class="type">int</span> progressCount = <span class="number">0</span>;</span><br><span class="line">    COProgressPromise *promise = progressDownloadFileFromUrl(<span class="string">@&quot;http://img17.3lian.com/d/file/201701/17/9a0d018ba683b9cbdcc5a7267b90891c.jpg&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">id</span> p <span class="keyword">in</span> promise)&#123;</span><br><span class="line">        <span class="type">double</span> v = [p doubleValue];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;current progress: %f&quot;</span>, (<span class="type">float</span>)v);</span><br><span class="line">        progressCount++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSData</span> *data = await(promise);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上述的这些co_launch都可以在任何子线程中运行。</p>
<p><strong><strong>5. COChan用法</strong></strong></p>
<p>COChan 主要用于协程之间进行数据传输，它有阻塞和非阻塞两种方式收发数据，针对channel，可以有无缓存类型，有缓存类型，以及无限缓存类型，下面会进行详细介绍。</p>
<p><img src="/2019/12/24/iOS%E5%BC%80%E6%BA%90%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8Bcoobjc/channel1.png"></p>
<p>和Promise类似的用法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">- (COChan&lt;id&gt; *)co_fetchSomething &#123;</span><br><span class="line">    COChan *<span class="keyword">chan</span> = [COChan <span class="keyword">chan</span>];</span><br><span class="line">    dispatch_async(_someQueue, ^&#123;</span><br><span class="line">       <span class="comment">// fetch result operations</span></span><br><span class="line">       ...</span><br><span class="line">       [<span class="keyword">chan</span> send_nonblock:result];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">chan</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// calling in a coroutine.</span></span><br><span class="line">co_launch(^&#123;</span><br><span class="line">    id ret = await([self co_fetchSomething]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>作为生产者消费者的用法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">COChan *<span class="keyword">chan</span> = [COChan chanWithBuffCount:<span class="number">10</span>];</span><br><span class="line">co_launch(^&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        [<span class="keyword">chan</span> send_nonblock:@(i)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">co_launch(^&#123;</span><br><span class="line">    <span class="comment">//NSArray *data = [chan receiveAll];</span></span><br><span class="line">    <span class="comment">//NSLog(@&quot;%@&quot;,data);</span></span><br><span class="line">    </span><br><span class="line">    NSArray *dataWithCount = [<span class="keyword">chan</span> receiveWithCount:<span class="number">3</span>];</span><br><span class="line">    NSLog(@<span class="string">&quot;%@&quot;</span>,dataWithCount);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>当COChan容量为0的时候，发送数据是阻塞的，只有在有人接收数据后才会执行send之后的代码</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">COChan *chan = [COChan chanWithBuffCount:<span class="number">0</span>];</span><br><span class="line">__block NSInteger step = <span class="number">0</span>;</span><br><span class="line">co_launch(^&#123;</span><br><span class="line">    step = <span class="number">1</span>;<span class="regexp">//</span>@<span class="number">1</span></span><br><span class="line">    [chan send:@<span class="number">111</span>]; <span class="regexp">//</span>代码会停在这里直到receive_nonblock消费数据后才继续往下执行 <span class="regexp">//</span>@<span class="number">2</span></span><br><span class="line">    step = <span class="number">2</span>;<span class="regexp">//</span>@<span class="number">6</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">co_launch(^&#123;</span><br><span class="line">    step = <span class="number">3</span>;<span class="regexp">//</span>@<span class="number">3</span></span><br><span class="line">    id value = [chan receive_nonblock];<span class="regexp">//</span>@<span class="number">4</span></span><br><span class="line">    step = <span class="number">4</span>;<span class="regexp">//</span>@<span class="number">5</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面数字代表的是代码的执行顺序。</p>
<p>当将COChan容量改为非0的时候执行顺序如下：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">COChan *chan = [COChan chanWithBuffCount:<span class="number">2</span>];</span><br><span class="line">__block NSInteger step = <span class="number">0</span>;</span><br><span class="line">co_launch(^&#123;</span><br><span class="line">    step = <span class="number">1</span>;<span class="regexp">//</span>@<span class="number">1</span></span><br><span class="line">    [chan send:@<span class="number">111</span>]; <span class="regexp">//</span>代码不会阻塞 <span class="regexp">//</span>@<span class="number">2</span></span><br><span class="line">    step = <span class="number">2</span>;<span class="regexp">//</span>@<span class="number">3</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">co_launch(^&#123;</span><br><span class="line">    step = <span class="number">3</span>;<span class="regexp">//</span>@<span class="number">4</span></span><br><span class="line">    id value = [chan receive_nonblock];<span class="regexp">//</span>@<span class="number">5</span></span><br><span class="line">    step = <span class="number">4</span>;<span class="regexp">//</span>@<span class="number">6</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>如果COChan中没有数据的时候调用receive将会阻塞：</p>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line">__block NSInteger step = <span class="number">0</span>;</span><br><span class="line">COChan *chan = [COChan chan];</span><br><span class="line">co_launch(^&#123;</span><br><span class="line">    step = <span class="number">1</span>;<span class="regexp">//</span>@1</span><br><span class="line">    id value = [chan receive];<span class="regexp">//</span>@2</span><br><span class="line">    step = <span class="number">2</span>;<span class="regexp">//</span>@6</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">co_launch(^&#123;</span><br><span class="line">    step = <span class="number">3</span>;<span class="regexp">//</span>@3</span><br><span class="line">    [chan <span class="keyword">send</span>:@111];<span class="regexp">//</span>@4</span><br><span class="line">    step = <span class="number">4</span>;<span class="regexp">//</span>@5</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>也就是send方法会往COChan中通道缓存中添加消息，如果满的话则会阻塞，直到数据被receive之后，才会继续执行。<br><img src="/2019/12/24/iOS%E5%BC%80%E6%BA%90%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8Bcoobjc/channel2.png"><br>receive会不断从通道缓存中获取数据，如果数据被取完后就阻塞，直到有数据send到缓存的时候，才会继续执行。这是很典型的生产者消费者模型。<br>send_nonblock会完缓存通道送数据后立刻返回，如果缓存满了就会丢弃数据，不会阻塞。看下coobjc给出的两个测试用例：</p>
<figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line">it(@<span class="string">&quot;send non blocking will not block the coroutine.&quot;</span>, ^&#123;</span><br><span class="line">    <span class="variable">__block</span> NSInteger <span class="built_in">step</span> = <span class="number">0</span>;</span><br><span class="line">    COChan *chan = [COChan chanWithBuffCount:<span class="number">1</span>];</span><br><span class="line">    co_launch(^&#123;</span><br><span class="line">        <span class="built_in">step</span> = <span class="number">1</span>;</span><br><span class="line">        [chan send_nonblock:@<span class="number">111</span>];</span><br><span class="line">        expect(<span class="built_in">step</span>).<span class="keyword">to</span>.equal(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">step</span> = <span class="number">2</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    co_launch(^&#123;</span><br><span class="line">        expect(<span class="built_in">step</span>).<span class="keyword">to</span>.equal(<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">step</span> = <span class="number">3</span>;</span><br><span class="line">        id value = [chan receive_nonblock];</span><br><span class="line">        expect(<span class="built_in">step</span>).<span class="keyword">to</span>.equal(<span class="number">3</span>);</span><br><span class="line">        expect(value).<span class="keyword">to</span>.equal(@<span class="number">111</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">waitUntil</span>(^(DoneCallback done) &#123;</span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            expect(<span class="built_in">step</span>).<span class="keyword">to</span>.equal(<span class="number">3</span>);</span><br><span class="line">            done();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">it(@<span class="string">&quot;Channel buff is full, send non blocking will abandon the value.&quot;</span>, ^&#123;</span><br><span class="line">    <span class="variable">__block</span> NSInteger <span class="built_in">step</span> = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    COChan *chan = [COChan chan];</span><br><span class="line">    co_launch(^&#123;</span><br><span class="line">        <span class="built_in">step</span> = <span class="number">1</span>;</span><br><span class="line">        [chan send_nonblock:@<span class="number">111</span>];</span><br><span class="line">        expect(<span class="built_in">step</span>).<span class="keyword">to</span>.equal(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">step</span> = <span class="number">2</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    co_launch(^&#123;</span><br><span class="line">        expect(<span class="built_in">step</span>).<span class="keyword">to</span>.equal(<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">step</span> = <span class="number">3</span>;</span><br><span class="line">        id value = [chan receive_nonblock];</span><br><span class="line">        expect(<span class="built_in">step</span>).<span class="keyword">to</span>.equal(<span class="number">3</span>);</span><br><span class="line">        expect(value).<span class="keyword">to</span>.equal(<span class="literal">nil</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">waitUntil</span>(^(DoneCallback done) &#123;</span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            expect(<span class="built_in">step</span>).<span class="keyword">to</span>.equal(<span class="number">3</span>);</span><br><span class="line">            done();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>我们看下接收被阻塞的例子：</p>
<figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line">it(@<span class="string">&quot;receive can block muti coroutine.&quot;</span>, ^&#123;</span><br><span class="line">    __block NSInteger <span class="keyword">step</span> = <span class="number">0</span><span class="comment">;</span></span><br><span class="line">    </span><br><span class="line">    COChan *chan = [COChan chanWithBuffCount:<span class="number">1</span>]<span class="comment">;</span></span><br><span class="line">    </span><br><span class="line">    co_launch(^&#123;</span><br><span class="line">        <span class="keyword">step</span> = <span class="number">1</span><span class="comment">;</span></span><br><span class="line">        id value = [chan receive]<span class="comment">;</span></span><br><span class="line">        expect(<span class="keyword">step</span>).<span class="keyword">to</span>.equal(<span class="number">7</span>)<span class="comment">;</span></span><br><span class="line">        expect(value).<span class="keyword">to</span>.equal(<span class="symbol">@111</span>)<span class="comment">;</span></span><br><span class="line">        <span class="keyword">step</span> = <span class="number">2</span><span class="comment">;</span></span><br><span class="line">    &#125;)<span class="comment">;</span></span><br><span class="line">    </span><br><span class="line">    co_launch(^&#123;</span><br><span class="line">        expect(<span class="keyword">step</span>).<span class="keyword">to</span>.equal(<span class="number">1</span>)<span class="comment">;</span></span><br><span class="line">        <span class="keyword">step</span> = <span class="number">3</span><span class="comment">;</span></span><br><span class="line">        id value = [chan receive]<span class="comment">;</span></span><br><span class="line">        expect(<span class="keyword">step</span>).<span class="keyword">to</span>.equal(<span class="number">2</span>)<span class="comment">;</span></span><br><span class="line">        expect(value).<span class="keyword">to</span>.equal(<span class="symbol">@222</span>)<span class="comment">;</span></span><br><span class="line">        <span class="keyword">step</span> = <span class="number">4</span><span class="comment">;</span></span><br><span class="line">    &#125;)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    co_launch(^&#123;</span><br><span class="line">        expect(<span class="keyword">step</span>).<span class="keyword">to</span>.equal(<span class="number">3</span>)<span class="comment">;</span></span><br><span class="line">        <span class="keyword">step</span> = <span class="number">5</span><span class="comment">;</span></span><br><span class="line">        [chan <span class="built_in">send</span>:<span class="symbol">@111]</span><span class="comment">;</span></span><br><span class="line">        expect(<span class="keyword">step</span>).<span class="keyword">to</span>.equal(<span class="number">5</span>)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">step</span> = <span class="number">6</span><span class="comment">;</span></span><br><span class="line">        [chan <span class="built_in">send</span>:<span class="symbol">@222]</span><span class="comment">;</span></span><br><span class="line">        expect(<span class="keyword">step</span>).<span class="keyword">to</span>.equal(<span class="number">6</span>)<span class="comment">;</span></span><br><span class="line">        <span class="keyword">step</span> = <span class="number">7</span><span class="comment">;</span></span><br><span class="line">    &#125;)<span class="comment">;</span></span><br><span class="line">    waitUntil(^(DoneCallback done) &#123;</span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            expect(<span class="keyword">step</span>).<span class="keyword">to</span>.equal(<span class="number">4</span>)<span class="comment">;</span></span><br><span class="line">            done()<span class="comment">;</span></span><br><span class="line">        &#125;)<span class="comment">;</span></span><br><span class="line">    &#125;)<span class="comment">;</span></span><br><span class="line">&#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>上面的例子中缓存通道容量都是指定的，还可以使用可扩展的通道expandableChan：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="built_in">it</span>(@&quot;expandableChan will not abandon values.&quot;, ^&#123;</span><br><span class="line">    __block NSInteger receiveCount = <span class="number">0</span>;</span><br><span class="line">    __block NSInteger receiveValue = <span class="number">0</span>;</span><br><span class="line">    __block NSInteger sendCount = <span class="number">0</span>;</span><br><span class="line">    COChan *chan = [COChan expandableChan];</span><br><span class="line">    for (int i = <span class="number">0</span>; i &lt; <span class="number">2000</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">co_launch</span>(^&#123;</span><br><span class="line">            [chan send:@(i)];</span><br><span class="line">            sendCount++;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for (int i = <span class="number">0</span>; i &lt; <span class="number">2000</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">co_launch</span>(^&#123;</span><br><span class="line">            id value = [chan receive];</span><br><span class="line">            receiveCount++;</span><br><span class="line">            receiveValue+=[value integerValue];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">waitUntilTimeout</span>(<span class="number">100</span>, ^(DoneCallback done) &#123;</span><br><span class="line">        <span class="built_in">dispatch_after</span>(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">10</span> * NSEC_PER_SEC)), <span class="built_in">dispatch_get_main_queue</span>(), ^&#123;</span><br><span class="line">            <span class="built_in">expect</span>(receiveCount)<span class="selector-class">.to</span><span class="selector-class">.equal</span>(<span class="number">2000</span>);</span><br><span class="line">            <span class="built_in">expect</span>(receiveValue)<span class="selector-class">.to</span><span class="selector-class">.equal</span>(<span class="number">1999000</span>);</span><br><span class="line">            <span class="built_in">expect</span>(sendCount)<span class="selector-class">.to</span><span class="selector-class">.equal</span>(<span class="number">2000</span>);</span><br><span class="line">            <span class="built_in">done</span>();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在进入下一个主题之前我们先回顾下OCChannel接口：</p>
<p>构造方法：</p>
<figure class="highlight elm"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> 容量为<span class="number">0</span>的消息通道</span><br><span class="line"> */</span><br><span class="line">+ (instance<span class="keyword">type</span>)chan;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">指定容量的消息通道</span><br><span class="line"> */</span><br><span class="line">+ (instance<span class="keyword">type</span>)chanWithBuffCount:(int32_t)buffCount;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> 创建一个可扩展的通道，通道的缓存大小是可以扩展的，这样send就不会阻塞当前进程，并且发送的数据将不会丢失</span><br><span class="line"> */</span><br><span class="line">+ (instance<span class="keyword">type</span>)expandableChan;</span><br></pre></td></tr></table></figure>

<p>往通道发送数据：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 发送一个数据到通道上，这个方法会在缓存已满，并且没有接收者的情况下阻塞当前协程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (void)send:(Value _Nullable )val;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 和上面一致，只不过会在协程取消的时候调用cancelBlock</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (void)send:(Value _Nullable )val onCancel:(COChanOnCancelBlock _Nullable)cancelBlock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 非阻塞式得向通道发送数据：</span></span><br><span class="line"><span class="comment"> 如果有接收者则发送</span></span><br><span class="line"><span class="comment"> 如果没有接收者，但是缓存还没满则存在缓存中</span></span><br><span class="line"><span class="comment"> 如果没有接收者，并且缓存已经满了，则丢弃数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (void)send_nonblock:(Value _Nullable )val;</span><br></pre></td></tr></table></figure>

<p>接收数据</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 阻塞式从通道中获取数据，这个方法会一直阻塞，直到有人往通道上发送数据为止</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (Value _Nullable )receive;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 和上面一致，只不过会在协程取消的时候调用cancelBlock</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (Value _Nullable )receiveWithOnCancel:(COChanOnCancelBlock _Nullable)cancelBlock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 非阻塞式接收数据</span></span><br><span class="line"><span class="comment"> 如果缓存中有数据则从缓存中直接取数据后返回</span></span><br><span class="line"><span class="comment"> 如果缓存是空的，但是刚好有人发送了数据，则直接接收</span></span><br><span class="line"><span class="comment"> 如果缓存是空的，但是没人发送数据，这时候返回nil</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (Value _Nullable)receive_nonblock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 阻塞接收通道的所有数据</span></span><br><span class="line"><span class="comment"> 1. 如果通道没有数据，那么会阻塞等待直到有一个数据为止</span></span><br><span class="line"><span class="comment"> 2. 如果通道内有数据则返回所有的值</span></span><br><span class="line"><span class="comment"> 3. 如果发送了nil，那么接送到数据将会是 [NSNull null]，因此需要注意检测返回数组中的类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (NSArray&lt;Value&gt; * _Nonnull)receiveAll;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 阻塞式接收指定数量的数据，如果通道缓存中没有足够的数据那么就会一直阻塞。</span></span><br><span class="line"><span class="comment"> 如果发送了nil，那么接送到数据将会是 [NSNull null]，因此需要注意检测返回数组中的类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (NSArray&lt;Value&gt; * _Nonnull)receiveWithCount:(NSUInteger)count;</span><br></pre></td></tr></table></figure>


<p><strong><strong>6. COActor用法</strong></strong></p>
<blockquote>
<p>Actor 的概念来自于 Erlang ，在 AKKA 中，可以认为一个 Actor 就是一个容器，用以存储状态、行为、Mailbox 以及子 Actor 与 Supervisor 策略。Actor 之间并不直接通信，而是通过 Mail 来互通有无</p>
</blockquote>
<p><img src="/2019/12/24/iOS%E5%BC%80%E6%BA%90%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8Bcoobjc/000001.png"></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">*</span> Mailbox: 用于存储消息的队列</span><br><span class="line"><span class="bullet">*</span> Isolated State: actor的状态以及内部变量等。</span><br><span class="line"><span class="bullet">*</span> message: 消息，类似于方法调用</span><br><span class="line">Actor模型有两个特点：</span><br><span class="line"><span class="bullet">1.</span> 在单个线程中的每个Actor顺序处理发送给它的消息</span><br><span class="line"><span class="bullet">2.</span> 不同的Actors同时并行运行</span><br></pre></td></tr></table></figure>


<p>Actor的创建：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">co<span class="constructor">_actor(^(COActorChan <span class="operator">*</span><span class="params">chan</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> = <span class="number">1</span>;</span><br><span class="line">    <span class="constructor">XCTAssert(<span class="params">chan</span> != <span class="params">nil</span>)</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">co<span class="constructor">_actor_onqueue(<span class="params">get_test_queue</span>()</span>, ^(COActorChan *chan) &#123;</span><br><span class="line">    val1 = <span class="number">1</span>;</span><br><span class="line">    <span class="constructor">XCTAssert(<span class="params">chan</span> != <span class="params">nil</span>)</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">it(@<span class="string">&quot;next in chan&quot;</span>, <span class="operator">^</span>&#123;</span><br><span class="line">    __block int val <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">COActor</span><span class="operator">*</span> <span class="keyword">actor</span> <span class="operator">=</span> co_actor(<span class="operator">^</span>(<span class="type">COActorChan</span> <span class="operator">*</span>chan) &#123;</span><br><span class="line">        int tmpVal <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">COActorMessage</span> <span class="operator">*</span>message <span class="operator">=</span> <span class="literal">nil</span>;</span><br><span class="line">        <span class="keyword">while</span>((message <span class="operator">=</span> [chan next]))&#123;</span><br><span class="line">            <span class="keyword">if</span>([message intType] <span class="operator">==</span> <span class="number">1</span>)&#123;</span><br><span class="line">                tmpVal<span class="operator">++</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>([message intType] <span class="operator">==</span> <span class="operator">-</span><span class="number">1</span>)&#123;</span><br><span class="line">                tmpVal<span class="operator">--</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>([message intType] <span class="operator">==</span> <span class="number">2</span>)&#123;</span><br><span class="line">                <span class="comment">//返回数据</span></span><br><span class="line">                message.complete(@(tmpVal));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    co_launch(<span class="operator">^</span>&#123;</span><br><span class="line">        [<span class="keyword">actor</span> sendMessage:@(<span class="number">1</span>)];</span><br><span class="line">        [<span class="keyword">actor</span> sendMessage:@(<span class="number">1</span>)];</span><br><span class="line">        [<span class="keyword">actor</span> sendMessage:@(<span class="number">1</span>)];</span><br><span class="line">        [<span class="keyword">actor</span> sendMessage:@(<span class="number">1</span>)];</span><br><span class="line">        [<span class="keyword">actor</span> sendMessage:@(<span class="number">1</span>)];</span><br><span class="line">        [<span class="keyword">actor</span> sendMessage:@(<span class="number">1</span>)];</span><br><span class="line">        </span><br><span class="line">        [<span class="keyword">actor</span> sendMessage:@(<span class="operator">-</span><span class="number">1</span>)];</span><br><span class="line">        </span><br><span class="line">        <span class="type">COActorCompletable</span> <span class="operator">*</span>completable <span class="operator">=</span> [<span class="keyword">actor</span> sendMessage:@(<span class="number">2</span>)];</span><br><span class="line">        id result <span class="operator">=</span> <span class="keyword">await</span>(completable);</span><br><span class="line">        val <span class="operator">=</span> [result intValue];</span><br><span class="line">        [<span class="keyword">actor</span> cancel];</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    waitUntil(<span class="operator">^</span>(<span class="type">DoneCallback</span> done) &#123;</span><br><span class="line">        dispatch_after(dispatch_time(<span class="type">DISPATCH_TIME_NOW</span>, (int64_t)(<span class="number">0.5</span> <span class="operator">*</span> <span class="type">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), <span class="operator">^</span>&#123;</span><br><span class="line">            <span class="type">XCTAssert</span>(val <span class="operator">==</span> <span class="number">5</span>);</span><br><span class="line">            done();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">it(@<span class="string">&quot;error example&quot;</span>, <span class="operator">^</span>&#123;</span><br><span class="line">    <span class="type">COActor</span> <span class="operator">*</span><span class="keyword">actor</span> <span class="operator">=</span> co_actor_onqueue(get_test_queue(), <span class="operator">^</span>(<span class="type">COActorChan</span> <span class="operator">*</span>channel) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">COActorMessage</span> <span class="operator">*</span>message <span class="keyword">in</span> channel)&#123;</span><br><span class="line">            message.complete(<span class="keyword">await</span>(test_promise()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    co_launch(<span class="operator">^</span>&#123;</span><br><span class="line">        id value <span class="operator">=</span> <span class="keyword">await</span>([<span class="keyword">actor</span> sendMessage:@<span class="string">&quot;test&quot;</span>]);</span><br><span class="line">        <span class="type">NSError</span> <span class="operator">*</span>error <span class="operator">=</span> co_getError();</span><br><span class="line">        <span class="type">XCTAssert</span>(error.code <span class="operator">==</span> <span class="number">100</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    waitUntilTimeout(<span class="number">3</span>, <span class="operator">^</span>(<span class="type">DoneCallback</span> done) &#123;</span><br><span class="line">        dispatch_after(dispatch_time(<span class="type">DISPATCH_TIME_NOW</span>, (int64_t)(<span class="number">3</span> <span class="operator">*</span> <span class="type">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), <span class="operator">^</span>&#123;</span><br><span class="line">            done();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong><strong>7. COTuple用法</strong></strong></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">COPromise</span>&lt;<span class="type">COTuple</span>*&gt;<span class="operator">*</span></span><br><span class="line">cotest_loadContentFromFile(<span class="type">NSString</span> <span class="operator">*</span>filePath)&#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="type">COPromise</span> promise:<span class="operator">^</span>(<span class="type">COPromiseFullfill</span>  _Nonnull resolve, <span class="type">COPromiseReject</span>  _Nonnull reject) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([[<span class="type">NSFileManager</span> defaultManager] fileExistsAtPath:filePath]) &#123;</span><br><span class="line">            <span class="type">NSData</span> <span class="operator">*</span>data <span class="operator">=</span> [[<span class="type">NSData</span> alloc] initWithContentsOfFile:filePath];</span><br><span class="line">            resolve(co_tuple(filePath, data, <span class="literal">nil</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">NSError</span> <span class="operator">*</span>error <span class="operator">=</span> [<span class="type">NSError</span> errorWithDomain:@<span class="string">&quot;fileNotFound&quot;</span> code:<span class="operator">-</span><span class="number">1</span> userInfo:<span class="literal">nil</span>];</span><br><span class="line">            resolve(co_tuple(filePath, <span class="literal">nil</span>, error));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">co_launch(<span class="operator">^</span>&#123;</span><br><span class="line">    <span class="type">NSString</span> <span class="operator">*</span>tmpFilePath <span class="operator">=</span> <span class="literal">nil</span>;</span><br><span class="line">    <span class="type">NSData</span> <span class="operator">*</span>data <span class="operator">=</span> <span class="literal">nil</span>;</span><br><span class="line">    <span class="type">NSError</span> <span class="operator">*</span>error <span class="operator">=</span> <span class="literal">nil</span>;</span><br><span class="line">    co_unpack(<span class="operator">&amp;</span>tmpFilePath, <span class="operator">&amp;</span>data, <span class="operator">&amp;</span>error) <span class="operator">=</span> <span class="keyword">await</span>(cotest_loadContentFromFile(filePath));</span><br><span class="line">    <span class="type">XCTAssert</span>([tmpFilePath isEqualToString:filePath], @<span class="string">&quot;file path is wrong&quot;</span>);</span><br><span class="line">    <span class="type">XCTAssert</span>(data.length <span class="operator">&gt;</span> <span class="number">0</span>, @<span class="string">&quot;data is wrong&quot;</span>);</span><br><span class="line">    <span class="type">XCTAssert</span>(error <span class="operator">==</span> <span class="literal">nil</span>, @<span class="string">&quot;error is wrong&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong><strong>8. 协程内延迟</strong></strong></p>
<p>co_delay 可以暂停所在的协程但是协程所在的线程不会停止运行，线程内部的其他协程也不会暂停，co_delay只能在协程内部运行，如果在外部执行的话将会抛出异常。</p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">co_launch(^&#123;</span><br><span class="line">    NSTimeInterval begin = <span class="comment">[<span class="comment">[NSDate date]</span> timeIntervalSince1970]</span>;</span><br><span class="line">    co_delay(3);</span><br><span class="line">    realDuration = <span class="comment">[<span class="comment">[NSDate date]</span> timeIntervalSince1970]</span> - begin;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong><strong>9. cokit简介</strong></strong></p>
<p>cokit 为常用的一些原生方法提供了一些常用的分类供我们使用，主要涉及到文件网络的IO</p>
<ul>
<li><strong><strong>NSDictionary+Coroutine.h</strong></strong>：主要用于将NSDictionary从文件中读取和写入文件。</li>
<li><strong><strong>NSArray+Coroutine.h</strong></strong>：主要用于读取NSPropertyList中的数组。</li>
<li><strong><strong>NSString+Coroutine.h</strong></strong>: 用于字符串从文件中读取和写入文件。</li>
<li><strong><strong>NSData+Coroutine.h</strong></strong>：主要用于将NSData数据从文件中读取和写入文件。</li>
<li><strong><strong>NSFileManager+Coroutine.h</strong></strong>w: 用于文件的操作</li>
<li><strong><strong>NSJSONSerialization+Coroutine.h</strong></strong>w: 用于JSON的序列化操作</li>
<li><strong><strong>NSKeyedArchiver+Coroutine.h</strong></strong>：用于归档类操作</li>
<li><strong><strong>NSURLConnection+Coroutine.h,NSURLSession+Coroutine.h</strong></strong>：用于网络请求操作</li>
<li><strong><strong>NSUserDefaults+Coroutine.h</strong></strong>：用于NSUserDefaults存储操作</li>
<li><strong><strong>UIImage+Coroutine.h</strong></strong>：用于获取图片操作</li>
</ul>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/iOS-%E5%BC%80%E6%BA%90%E5%BA%93%E5%88%86%E6%9E%90/">iOS 开源库分析</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/iOS-开源库分析/">iOS 开源库分析</a>
  </div>

</div>



<div class="comments-count">
	
	  	<span></span>
		<a href="/2019/12/24/iOS开源库源码分析之coobjc/#comments" class="ds-thread-count comments-count-link" data-thread-key="2019/12/24/iOS开源库源码分析之coobjc/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/12/20/fishhook-源码解析/" title="iOS开源库之fishhook 概述" itemprop="url">iOS开源库之fishhook 概述</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Edgar" target="_blank" itemprop="author">Edgar</a>
		
  <p class="article-time">
    <time datetime="2019-12-20T09:00:21.000Z" itemprop="datePublished"> Published 2019-12-20</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h4 id="源码信息"><a href="#源码信息" class="headerlink" title="源码信息"></a>源码信息</h4><p><a target="_blank" rel="noopener" href="https://github.com/facebook/fishhook">源码地址</a></p>
<p>fishhook是真正意义上精炼的代码，不管是接口还是总体代码量都十分简单，但是背后的原理以及它所具备的功能却是十分强大的。最早听说fishhook的时候，只知道它是用于hook的一个开源库，以为和Aspect同种类型所以没把它列到开源代码解析的列表中，<br>后面出于好奇看了下它居然是用于hook C函数，所以赶紧把它补上了,由于涉及底层的内容比较多，如果不是很清楚大家可以看后面推荐的文章，这里只做简单介绍。</p>
<p>那么上面叨叨了那么多，到底什么是fishhook呢,我们看下官方的解释：</p>
<blockquote>
<p>fishhook is a very simple library that enables dynamically rebinding symbols in Mach-O binaries running on iOS in the simulator and on device. </p>
</blockquote>
<p>上面的意思就是fishhook是一个用于动态修改 Mach-O 二进制文件里面symbols的一个开源库。fishhook 的强大之处在于它可以 hook 系统的静态 C 函数。我们接下来看下它是怎么做到的：</p>
<h4 id="原理介绍"><a href="#原理介绍" class="headerlink" title="原理介绍"></a>原理介绍</h4><p><strong><strong>使用情景</strong></strong></p>
<p>我们先来看下fishhook对外暴露的内容，就两大类：一个rebinding结构体，用于封装对应的绑定信息，两个接口进行对C函数进行hook：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">rebinding</span> &#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *name;  <span class="comment">// 目标符号名</span></span><br><span class="line">  <span class="type">void</span> *replacement; <span class="comment">// 用于替换的函数地址</span></span><br><span class="line">  <span class="type">void</span> **replaced;   <span class="comment">// 用来存放原来的地址值</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">FISHHOOK_VISIBILITY</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rebind_symbols</span><span class="params">(<span class="keyword">struct</span> rebinding rebindings[], <span class="type">size_t</span> rebindings_nel)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">FISHHOOK_VISIBILITY</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rebind_symbols_image</span><span class="params">(<span class="type">void</span> *header,</span></span></span><br><span class="line"><span class="params"><span class="function">                         <span class="type">intptr_t</span> slide,</span></span></span><br><span class="line"><span class="params"><span class="function">                         <span class="keyword">struct</span> rebinding rebindings[],</span></span></span><br><span class="line"><span class="params"><span class="function">                         <span class="type">size_t</span> rebindings_nel)</span></span>;</span><br></pre></td></tr></table></figure>

<p>rebind_symbols和rebind_symbols_image都用于符号重绑定，区别在于前者操作的对象是所有镜像，后者操作的对象是某个指定的镜像</p>
<p>我们先来看一个官方的例子：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">#import &lt;dlfcn.h&gt;</span><br><span class="line"></span><br><span class="line">#import &lt;UIKit/<span class="module-access"><span class="module"><span class="identifier">UIKit</span>.</span></span>h&gt;</span><br><span class="line"></span><br><span class="line">#import <span class="string">&quot;AppDelegate.h&quot;</span></span><br><span class="line"><span class="comment">//1. 引入 fishhook.h</span></span><br><span class="line">#import <span class="string">&quot;fishhook.h&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//2. 声明与原函数签名相同的函数指针：</span></span><br><span class="line">static <span class="built_in">int</span> (*orig_close)(<span class="built_in">int</span>);</span><br><span class="line">static <span class="built_in">int</span> (*orig_open)(const <span class="built_in">char</span> *, <span class="built_in">int</span>, ...);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//3. 实现用于替换的方法</span></span><br><span class="line"><span class="built_in">int</span> my<span class="constructor">_close(<span class="params">int</span> <span class="params">fd</span>)</span> &#123;</span><br><span class="line">  printf(<span class="string">&quot;Calling real close(%d)\n&quot;</span>, fd);</span><br><span class="line">  <span class="comment">//4.执行被hook的方法</span></span><br><span class="line">  return orig<span class="constructor">_close(<span class="params">fd</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//3. 实现用于替换的方法</span></span><br><span class="line"><span class="built_in">int</span> my<span class="constructor">_open(<span class="params">const</span> <span class="params">char</span> <span class="operator">*</span><span class="params">path</span>, <span class="params">int</span> <span class="params">oflag</span>, <span class="operator">...</span>)</span> &#123;</span><br><span class="line">  va_list ap = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  mode_t mode = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> ((oflag &amp; O_CREAT) != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// mode only applies to O_CREAT</span></span><br><span class="line">    va<span class="constructor">_start(<span class="params">ap</span>, <span class="params">oflag</span>)</span>;</span><br><span class="line">    mode = va<span class="constructor">_arg(<span class="params">ap</span>, <span class="params">int</span>)</span>;</span><br><span class="line">    va<span class="constructor">_end(<span class="params">ap</span>)</span>;</span><br><span class="line">    printf(<span class="string">&quot;Calling real open(&#x27;%s&#x27;, %d, %d)\n&quot;</span>, path, oflag, mode);</span><br><span class="line">    <span class="comment">//4.执行被hook的方法</span></span><br><span class="line">    return orig<span class="constructor">_open(<span class="params">path</span>, <span class="params">oflag</span>, <span class="params">mode</span>)</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    printf(<span class="string">&quot;Calling real open(&#x27;%s&#x27;, %d)\n&quot;</span>, path, oflag);</span><br><span class="line">    <span class="comment">//4.执行被hook的方法</span></span><br><span class="line">    return orig<span class="constructor">_open(<span class="params">path</span>, <span class="params">oflag</span>, <span class="params">mode</span>)</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">int</span> main(<span class="built_in">int</span> argc, <span class="built_in">char</span><span class="operator"> * </span>argv<span class="literal">[]</span>)</span><br><span class="line">&#123;</span><br><span class="line">  @autoreleasepool &#123;</span><br><span class="line">    </span><br><span class="line">    rebind<span class="constructor">_symbols((<span class="params">struct</span> <span class="params">rebinding</span>[2])</span>&#123;&#123;<span class="string">&quot;close&quot;</span>, my_close, (void *)&amp;orig_close&#125;<span class="comment">/*初始化rebinding 结构体*/</span>, &#123;<span class="string">&quot;open&quot;</span>, my_open, (void *)&amp;orig_open<span class="comment">/*初始化rebinding 结构体*/</span>&#125;&#125;, <span class="number">2</span> <span class="comment">/*rebind个数*/</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Open our own binary and print out first 4 bytes (which is the same</span></span><br><span class="line">    <span class="comment">// for all Mach-O binaries on a given architecture)</span></span><br><span class="line">    <span class="built_in">int</span> fd = <span class="keyword">open</span>(argv<span class="literal">[<span class="number">0</span>]</span>, O_RDONLY);</span><br><span class="line">    uint32_t magic_number = <span class="number">0</span>;</span><br><span class="line">    read(fd, &amp;magic_number, <span class="number">4</span>);</span><br><span class="line">    printf(<span class="string">&quot;Mach-O Magic Number: %x \n&quot;</span>, magic_number);</span><br><span class="line">    close(fd);</span><br><span class="line">    return <span class="constructor">UIApplicationMain(<span class="params">argc</span>, <span class="params">argv</span>, <span class="params">nil</span>, NSStringFromClass([AppDelegate <span class="params">class</span>])</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过上面替换后代码中的open，close都会替换为my_open，my_close。所以运行这段代码会输出：</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">Calling <span class="built_in">real</span> open(&#x27;/<span class="built_in">var</span>/mobile/Applications/161DA598-<span class="number">5B83</span>-41F5-8A44-675491AF6A2C/Test.app/Test&#x27;, <span class="number">0</span>)</span><br><span class="line">Mach-O Magic Number: feedface </span><br><span class="line">Calling <span class="built_in">real</span> <span class="built_in">close</span>(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<p><strong><strong>原理介绍</strong></strong></p>
<p>要完全弄懂fishhook需要知道Mach-O，dyld，编译过程，动态链接，静态链接的过程，这里如果展开讲的话会涉及很大的一块内容，所以这个阶段先不展开细讲，后面会开一个底层系列到时候再回过头来详细得看下fishhood的源码。</p>
<p>我们这里只简单介绍下fishhook的大致原理：</p>
<p>我们知道现在很多代码都是由多个模块构成的（比如我们的一个项目都是由多个.m&#x2F;.h文件对构成，这里的每个.m&#x2F;.h文件都相当于一个编译模块）这样有利于复用，并且由于这些模块是可以单独编译的，所以如果只是单个模块发生改变，只要单独编译改变的模块，然后在与其他模块进行链接就可以了。而从源代码到可执行文件需要通过对每个模块的源代码进行编译，生成一个个目标文件，然后再通过<br>链接器将这些中间文件链接起来，形成一个最终的可行性文件Mach O,在单个模块中C函数在编译时就确定了函数指针的地址偏移量（Offset），这个偏移量在编译好的可执行文件中是固定的，而可执行文件每次被重新装载到内存中时被系统分配的起始地址是不断变化的。运行中的静态函数指针地址其实就等于上述 Offset + Mach0 文件在内存中的首地址.<br>而在链接阶段主要负责符号决议和重定位。之所以需要链接阶段是由于存在模块间依赖，不论是依赖方法还是依赖变量，本质上都是模块间的符号引用。</p>
<p>但是C函数的指针地址是相对固定且不可修改的。所以内部非动态链接库中的C函数fishhook是hook不了的，它只能用于Mach-O外部的函数。对于这些动态链接库是不会被编译到Mach O 文件的，而是在动态链接时才去重新绑定。</p>
<p>苹果采用了PIC（Position-independent code）技术来完成代码的动态加载特性：<br>编译时在 Mach-O 文件 _DATA 段的符号表中为每一个被引用的系统 C 函数建立一个指针（8字节的数据，放的全是0），这个指针用于动态绑定时重定位到共享库中的函数实现。在运行时当系统 C 函数被第一次调用时会动态绑定一次，然后将 Mach-O 中的 _DATA 段符号表中对应的指针，指向其在共享库中的实际内存地址，也就是会将我们需要替换的C函数在这个共享库中实际的内存地址保存到 Mach-O 中的 _DATA 段符号表中。<br>经过上面的一串操作我们在调用这个方法的时候都会读取_DATA中的这个地址。我们上面提到内部非动态链接库中的代码fishhook不能hook是因为这些地址值是存放在TEXT session中，而这部分数据是只读的。而动态链接库里面的最终符号地址存在可读写的 __DATA segment 的某个 section 中，fishhook 的实现原理就是通过修改这些 section 内容，进而实现符号的 rebind。</p>
<p>嗯，大致就是这样，讲得太细节容易把自己都陷进去，这样刚好能够理解。最近正好正在看底层的原理，打算放在后面整体梳理清楚后，再补一篇。赶紧逃。^ V ^</p>
<h4 id="较好的文章"><a href="#较好的文章" class="headerlink" title="较好的文章"></a>较好的文章</h4><ul>
<li><a target="_blank" rel="noopener" href="https://draveness.me/fishhook">动态修改 C 语言函数的实现</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5c810294f265da2db91297f1">fishhook使用场景&amp;源码分析</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5c7b43976fb9a04a05406312">fishhook的实现原理浅析</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5c727262e51d457139116208">dyld背后的故事&amp;源码分析</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5c616552f265da2dd53fa4e7#heading-3">非越狱下 iOS代码注入&amp;HOOK微信登录</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/entry/5a1fceddf265da43310d9985">iOS 界的毒瘤：Method Swizzle</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5c67e7efe51d45164c75993b">MachO 文件结构详解</a></li>
<li><a target="_blank" rel="noopener" href="https://www.googleplus.party/2017/10/26/fishhook%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/">fishhook的基本使用，fishhook可以勾住系统函数</a></li>
<li><a target="_blank" rel="noopener" href="https://zhangbuhuai.com/post/macho-structure.html">Mach-O 简单分析</a></li>
<li><a target="_blank" rel="noopener" href="https://zhangbuhuai.com/post/macho-static-link.html">Mach-O 与静态链接</a></li>
<li><a target="_blank" rel="noopener" href="https://zhangbuhuai.com/post/macho-dynamic-link.html">Mach-O 与动态链接</a></li>
<li><a target="_blank" rel="noopener" href="https://zhangbuhuai.com/post/fishhook.html">分析 fishhook</a></li>
</ul>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/iOS-%E5%BC%80%E6%BA%90%E5%BA%93%E5%88%86%E6%9E%90/">iOS 开源库分析</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/iOS-开源库分析/">iOS 开源库分析</a>
  </div>

</div>



<div class="comments-count">
	
	  	<span></span>
		<a href="/2019/12/20/fishhook-源码解析/#comments" class="ds-thread-count comments-count-link" data-thread-key="2019/12/20/fishhook-源码解析/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/12/18/objection-源码解析/" title="iOS开源库之objection 源码解析" itemprop="url">iOS开源库之objection 源码解析</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Edgar" target="_blank" itemprop="author">Edgar</a>
		
  <p class="article-time">
    <time datetime="2019-12-18T09:08:08.000Z" itemprop="datePublished"> Published 2019-12-18</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h4 id="开源库信息"><a href="#开源库信息" class="headerlink" title="开源库信息"></a>开源库信息</h4><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/atomicobject/objection">objection</a></li>
</ul>
<p>objection 是一个iOS &#x2F; MacOS X 平台上的一个基于注释的依赖注入库，能够支持类方式，协议方式，实例对象方式，名称方式绑定，如果接触过Android开发大家可能会比较熟悉Butterknife，两者的功能是一致的，确切地说两者在很多特性上也都存在很多共同点：</p>
<p>我们来看下objection有哪些特性：</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">* <span class="string">&quot;Annotation&quot;</span> <span class="keyword">Based </span>Dependency Injection</span><br><span class="line">* Seamless support for integrating custom <span class="keyword">and </span><span class="keyword">external </span>dependencies</span><br><span class="line">    Custom Object Providers</span><br><span class="line">    Meta Class <span class="keyword">Bindings</span></span><br><span class="line"><span class="keyword"></span>    Protocol <span class="keyword">Bindings</span></span><br><span class="line"><span class="keyword"></span>    <span class="keyword">Instance </span><span class="keyword">Bindings</span></span><br><span class="line"><span class="keyword"></span>    Named <span class="keyword">Bindings</span></span><br><span class="line"><span class="keyword"></span>* Lazily <span class="keyword">instantiates </span>dependencies</span><br><span class="line">* Eager Singletons</span><br><span class="line">* Initializer Support</span><br><span class="line">    Default <span class="keyword">and </span>custom arguments</span><br></pre></td></tr></table></figure>

<h4 id="objection用法"><a href="#objection用法" class="headerlink" title="objection用法"></a>objection用法</h4><p>要熟悉objection的用法可以从objection的测试用例中进行了解，我们在进行源码分析的时候先从这些测试用例入手了解下objection的各个用法：</p>
<p><strong><strong>1.注入器的创建</strong></strong></p>
<p>当我们需要一个对象的时候我们都是通过JSObjectionInjector来获取，我们可以创建多个JSObjectionInjector：</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">JSObjectionInjector *injector <span class="operator">=</span> [JSObjection createInjector]<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>也可以创建一个JSObjectionInjector 并通过setDefaultInjector来将它作为默认的注入器：</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">JSObjectionInjector </span>*injector = [<span class="keyword">JSObjection </span>createInjector];</span><br><span class="line">[<span class="keyword">JSObjection </span>setDefaultInjector:injector];</span><br></pre></td></tr></table></figure>
<p>这种情况下任何地方就可以通过****[JSObjection defaultInjector]****来获取这个默认的注入器了。</p>
<p>它支持getObject以及下标获取两类方式：</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">[injector getObject:AObject.<span class="built_in">class</span>];</span><br><span class="line">injector[AObject.<span class="built_in">class</span>];  </span><br><span class="line">[injector objectForKeyedSubscript:AObject.<span class="built_in">class</span>];</span><br></pre></td></tr></table></figure>


<p><strong><strong>2.注册一个对象</strong></strong></p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">objection_register</span><span class="params">(XXXX)</span></span></span><br><span class="line"><span class="function"><span class="title">objection_register_singleton</span><span class="params">(XXXX)</span></span></span><br></pre></td></tr></table></figure>
<p>objection 可以自动完成对象的注册，但是我们也可以显式地对某个对象进行注册，objection中对象的注入有上面两种方式，最后一个是注册一个单例对象使用到的。个人建议如果不是注册单例就不用显式注册了。<br>objection_register和objection_register_singleton的区别是如果一旦有某个类被标记为objection_register_singleton，那么任何地方从注册器取出来的对象都是同一个。而注册成非单例的对象每次创建的时候都会返回一个新的对象。</p>
<p>还需要注意一点是这里的单例是针对单个注入器的，不同的注入器中返回的则是不同的对象，这点需要十分注意。</p>
<blockquote>
<p>will not return the same instance per injector if object is a singleton</p>
</blockquote>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@interface</span> <span class="attribute">Engine </span>: NSObject</span><br><span class="line"><span class="variable">@end</span></span><br><span class="line"></span><br><span class="line"><span class="variable">@implementation</span> Engine</span><br><span class="line">objection_register(Engine)</span><br><span class="line"><span class="variable">@end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@interface</span> <span class="attribute">UnregisteredCar </span>: NSObject</span><br><span class="line"><span class="variable">@property</span>(nonatomic, strong) Engine *engine;</span><br><span class="line"><span class="variable">@end</span></span><br><span class="line"></span><br><span class="line"><span class="variable">@implementation</span> UnregisteredCar</span><br><span class="line">objection_requires(@<span class="string">&quot;engine&quot;</span>)</span><br><span class="line"><span class="variable">@synthesize</span> engine;</span><br><span class="line"><span class="variable">@end</span></span><br></pre></td></tr></table></figure>

<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">it(@<span class="string">&quot;correctly builds a registered object&quot;</span>, ^&#123;</span><br><span class="line">    id engine = <span class="literal">[[JSO<span class="identifier">bjection</span> <span class="identifier">defaultInjector</span>]</span> getObject:<span class="literal">[E<span class="identifier">ngine</span> <span class="identifier">class</span>]</span>];</span><br><span class="line">    <span class="keyword">assert</span><span class="constructor">That(<span class="params">engine</span>, <span class="params">isNot</span>(<span class="params">nilValue</span>()</span>));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">it(@<span class="string">&quot;will auto register a class if it is not explicitly registered&quot;</span>, ^&#123;</span><br><span class="line">    UnregisteredCar *unregisteredCar = <span class="literal">[[JSO<span class="identifier">bjection</span> <span class="identifier">defaultInjector</span>]</span> getObject:<span class="literal">[U<span class="identifier">nregisteredCar</span> <span class="identifier">class</span>]</span>];</span><br><span class="line">    <span class="keyword">assert</span><span class="constructor">That(<span class="params">unregisteredCar</span>, <span class="params">is</span>(<span class="params">notNilValue</span>()</span>));</span><br><span class="line">    <span class="keyword">assert</span><span class="constructor">That(<span class="params">unregisteredCar</span>.<span class="params">engine</span>, <span class="params">is</span>(<span class="params">notNilValue</span>()</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>每次注入的时候都会执行awakeFromObjection</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Car</span></span></span><br><span class="line">objection_register(Car)</span><br><span class="line"></span><br><span class="line"><span class="keyword">@synthesize</span> engine, brakes, awake;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)awakeFromObjection &#123;</span><br><span class="line">  awake = <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">it(@<span class="string">&quot;calls awakeFromObjection when injecting dependencies into properties of an existing instance&quot;</span>, ^&#123;</span><br><span class="line">    Car *car = <span class="literal">[[C<span class="identifier">ar</span> <span class="identifier">alloc</span>]</span> init];</span><br><span class="line">    <span class="literal">[[JSO<span class="identifier">bjection</span> <span class="identifier">defaultInjector</span>]</span> injectDependencies:car];</span><br><span class="line">    <span class="keyword">assert</span><span class="constructor">ThatBool([<span class="params">car</span> <span class="params">awake</span>], <span class="params">isTrue</span>()</span>);</span><br><span class="line">    <span class="keyword">assert</span><span class="constructor">ThatBool([<span class="params">car</span>.<span class="params">engine</span> <span class="params">awake</span>], <span class="params">isTrue</span>()</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong><strong>3. 属性注入</strong></strong></p>
<p>如果我们需要的对象里面有其他的对象那么就需要objection_requires和objection_requires_sel指定当前类中哪些子属性需要注入了，直接看例子</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Car</span> : <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">  Engine *engine;</span><br><span class="line">  Brakes *brakes;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) Engine *engine;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) Brakes *brakes;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Car</span></span></span><br><span class="line">objection_register(Car)</span><br><span class="line"><span class="keyword">@synthesize</span> engine, brakes, awake;</span><br><span class="line"></span><br><span class="line">objection_requires(<span class="string">@&quot;engine&quot;</span>, <span class="string">@&quot;brakes&quot;</span>)</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">it(@<span class="string">&quot;correctly builds and object with dependencies&quot;</span>, ^&#123;</span><br><span class="line">    Car *car = <span class="literal">[[JSO<span class="identifier">bjection</span> <span class="identifier">defaultInjector</span>]</span> getObject:<span class="literal">[C<span class="identifier">ar</span> <span class="identifier">class</span>]</span>];</span><br><span class="line">    <span class="keyword">assert</span><span class="constructor">That(<span class="params">car</span>, <span class="params">isNot</span>(<span class="params">nilValue</span>()</span>));</span><br><span class="line">    <span class="keyword">assert</span><span class="constructor">That(<span class="params">car</span>.<span class="params">engine</span>, <span class="params">isNot</span>(<span class="params">nilValue</span>()</span>));</span><br><span class="line">    <span class="keyword">assert</span><span class="constructor">That(<span class="params">car</span>.<span class="params">engine</span>, <span class="params">is</span>(<span class="params">instanceOf</span>([Engine <span class="params">class</span>])</span>));</span><br><span class="line">    <span class="keyword">assert</span><span class="constructor">That(<span class="params">car</span>.<span class="params">brakes</span>, <span class="params">isNot</span>(<span class="params">nilValue</span>()</span>));</span><br><span class="line">    <span class="keyword">assert</span><span class="constructor">That(<span class="params">car</span>.<span class="params">brakes</span>, <span class="params">is</span>(<span class="params">instanceOf</span>([Brakes <span class="params">class</span>])</span>));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@interface</span> <span class="attribute">UnstoppableCar </span>: NSObject</span><br><span class="line"><span class="variable">@property</span>(nonatomic, strong) Engine *engine;</span><br><span class="line"><span class="variable">@end</span></span><br><span class="line"></span><br><span class="line"><span class="variable">@implementation</span> UnstoppableCar</span><br><span class="line">objection_requires_sel(<span class="variable">@selector</span>(engine))</span><br><span class="line"><span class="variable">@end</span></span><br></pre></td></tr></table></figure>

<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">it(@<span class="string">&quot;correctly builds objects with selector dependencies&quot;</span>, ^&#123;</span><br><span class="line">    UnstoppableCar *car = <span class="literal">[[JSO<span class="identifier">bjection</span> <span class="identifier">defaultInjector</span>]</span> getObject:<span class="literal">[U<span class="identifier">nstoppableCar</span> <span class="identifier">class</span>]</span>];</span><br><span class="line">    <span class="keyword">assert</span><span class="constructor">That(<span class="params">car</span>.<span class="params">engine</span>, <span class="params">is</span>(<span class="params">instanceOf</span>([Engine <span class="params">class</span>])</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这里个人建议使用objection_requires_sel，避免使用objection_requires这种以字符串作为参数的方式。</p>
<p><strong><strong>4. 指定构造方法获取对象</strong></strong></p>
<p>默认情况下getObject使用的是对象默认的构造方法来创建出注入的对象，但是一般情况下我们会使用不同的构造方法来创建对象，这种情况下我们要怎么处理呢？方法有两种：</p>
<p>方式一：<br>通过<strong><strong>objection_initializer_sel</strong></strong></p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">objection_initializer_sel</span>(<span class="variable">@selector</span>(<span class="attribute">initWithfirstName</span>:<span class="attribute">secondName</span>:))</span><br></pre></td></tr></table></figure>

<p>然后代码中可以通过如下几种方式的任意一种给构造方法指定参数：</p>
<figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line"><span class="symbol">JSObjectionInjector</span> *injector = [<span class="symbol">JSObjection</span> defaultInjector];</span><br><span class="line"><span class="symbol">JSObjectFactory</span> *factory = [injector getObject:[<span class="symbol">JSObjectFactory</span> class]];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//self.dog = [factory getObjectWithArgs:[<span class="symbol">IDLDog</span> class], @<span class="string">&quot;Piter&quot;</span>, @<span class="string">&quot;Pop&quot;</span>,nil];</span><br><span class="line">//self.dog = [injector getObjectWithArgs:[<span class="symbol">IDLDog</span> class], @<span class="string">&quot;Piter&quot;</span>, @<span class="string">&quot;Pop&quot;</span>, nil];</span><br><span class="line">//self.dog = [injector getObject:[<span class="symbol">IDLDog</span> class] argumentList:@[@<span class="string">&quot;Piter&quot;</span>, @<span class="string">&quot;Pop&quot;</span>]];</span><br></pre></td></tr></table></figure>

<p>方法二是通过在getObject的时候指定初始化方法：</p>
<figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line"><span class="symbol">IDLCar</span> *car = [[<span class="symbol">IDLCar</span> alloc] initWithName:@<span class="string">&quot;GTM&quot;</span>];</span><br><span class="line">self.dog = [injector getObject:[<span class="symbol">IDLDog</span> class] initializer:@selector(initWithCar:) argumentList:@[car]];</span><br></pre></td></tr></table></figure>

<p>这种方式就不用<strong><strong>objection_initializer_sel</strong></strong>来注解了。</p>
<p>个人比较偏向使用第二种方式，同时注意这里的参数类型可以是自定义的类型。</p>
<p><strong><strong>5. JSObjectFactory</strong></strong></p>
<p>JSObjectFactory和JSObjectionInjector处理的事情是一样的，实际上它内部持有JSObjectionInjector。所以这里在这块不做过多介绍。</p>
<p><strong><strong>6. JSObjectionModule &amp;&amp;  JSObjectionProvider</strong></strong></p>
<p>JSObjectionModule 和 JSObjectionProvider 为我们提供了一个数据集中绑定的场所。</p>
<p>我们先来看下JSObjectionModule的用法：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyModule</span> : <span class="title">JSObjectionModule</span> </span>&#123;</span><br><span class="line">  <span class="type">BOOL</span> _instrumentInvalidEagerSingleton;</span><br><span class="line">  <span class="type">BOOL</span> _instrumentInvalidMetaClass;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) Engine *engine;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="type">id</span>&lt;GearBox&gt; gearBox;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="type">BOOL</span> instrumentInvalidEagerSingleton;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="type">BOOL</span> instrumentInvalidMetaClass;</span><br><span class="line"></span><br><span class="line">- (<span class="type">id</span>)initWithEngine:(Engine *)engine andGearBox:(<span class="type">id</span>&lt;GearBox&gt;)gearBox;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>重写configure方法：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyModule</span></span></span><br><span class="line"><span class="keyword">@synthesize</span> engine = _engine;</span><br><span class="line"><span class="keyword">@synthesize</span> gearBox = _gearBox;</span><br><span class="line"><span class="keyword">@synthesize</span> instrumentInvalidEagerSingleton=_instrumentInvalidEagerSingleton;</span><br><span class="line"><span class="keyword">@synthesize</span> instrumentInvalidMetaClass = _instrumentInvalidMetaClass;</span><br><span class="line"></span><br><span class="line">- (<span class="type">id</span>)initWithEngine:(Engine *)engine andGearBox:(<span class="type">id</span>&lt;GearBox&gt;)gearBox &#123;</span><br><span class="line">  <span class="keyword">if</span> ((<span class="keyword">self</span> = [<span class="variable language_">super</span> init])) &#123;</span><br><span class="line">    _engine = engine;</span><br><span class="line">    _gearBox = gearBox;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)configure &#123;</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span> bind:_engine toClass:[Engine <span class="keyword">class</span>]];</span><br><span class="line">    [<span class="keyword">self</span> bind:_gearBox toProtocol:<span class="class"><span class="keyword">@protocol</span>(<span class="title">GearBox</span>)];</span></span><br><span class="line">    [<span class="keyword">self</span> bindClass:[VisaCCProcessor <span class="keyword">class</span>] toProtocol:<span class="class"><span class="keyword">@protocol</span>(<span class="title">CreditCardProcessor</span>)];</span></span><br><span class="line">    [<span class="keyword">self</span> bindClass:[VisaCCProcessor <span class="keyword">class</span>] toClass:[BaseCreditCardProcessor <span class="keyword">class</span>]];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.instrumentInvalidMetaClass) &#123;</span><br><span class="line">        [<span class="keyword">self</span> bindMetaClass:(<span class="type">id</span>)<span class="string">@&quot;sneaky&quot;</span> toProtocol:<span class="class"><span class="keyword">@protocol</span>(<span class="title">MetaCar</span>)];</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        [<span class="keyword">self</span> bindMetaClass:[Car <span class="keyword">class</span>] toProtocol:<span class="class"><span class="keyword">@protocol</span>(<span class="title">MetaCar</span>)];</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.instrumentInvalidEagerSingleton) &#123;</span><br><span class="line">        [<span class="keyword">self</span> registerEagerSingleton:[Car <span class="keyword">class</span>]];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        [<span class="keyword">self</span> registerEagerSingleton:[EagerSingleton <span class="keyword">class</span>]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先自定义的Module需要继承JSObjectionModule，并且重写configure方法，在configure方法中可以通过bind bindClass绑定，一个对象或者类可以绑定到Class和Protocol。</p>
<p><strong><strong>-bind:</strong></strong> 和 <strong><strong>-bindClass:</strong></strong> 的区别是：前者通过注入器会获取同一个实例，就是你所绑定的实例，后者每次通过注入器获取的对象都是不同的，因为绑定的是类。</p>
<p>通过Model方式和不通过Model方式的区别是在创建Injector的时候，使用model的时候需要在创建Injector的时候指定需要的Model:</p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">module = <span class="comment">[<span class="comment">[MyModule alloc]</span> initWithEngine:engine andGearBox:gearBox]</span>;    </span><br><span class="line">JSObjectionInjector *injector = <span class="comment">[JSObjection createInjector:module]</span>;</span><br><span class="line"><span class="comment">[JSObjection setDefaultInjector:injector]</span>;</span><br></pre></td></tr></table></figure>

<p>但是一般建议放在load方法中</p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">+(void)load&#123;</span><br><span class="line">    JSObjectionInjector* injector = <span class="comment">[JSObjection defaultInjector]</span>;</span><br><span class="line">    injector = injector ? : <span class="comment">[JSObjection createInjector]</span>;</span><br><span class="line">    injector = <span class="comment">[injector withModule:<span class="comment">[self.class new]</span>]</span>;</span><br><span class="line">    <span class="comment">[JSObjection setDefaultInjector:injector]</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><strong>6.0 Eager Singleton</strong></strong></p>
<p>一般Singleton会在使用的时候进行注入，但是被注册为Eager Singleton会在一开始的时候就进行注入：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">EagerSingleton</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">EagerSingleton</span></span></span><br><span class="line">objection_register_singleton(EagerSingleton)</span><br><span class="line">- (<span class="type">void</span>)awakeFromObjection &#123;</span><br><span class="line">  gEagerSingletonHook = <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">self</span> <span class="symbol">registerEagerSingleton:</span>[EagerSingleton <span class="class"><span class="keyword">class</span>]];</span></span><br></pre></td></tr></table></figure>

<p>这里需要注意的是必须是使用objection_register_singleton注册为单例的类才能注册为Eager Singleton</p>
<p><strong><strong>6.1 使用name区分同一类型的绑定</strong></strong></p>
<p>当你绑定相同的 class&#x2F;protocol 时，之前的绑定会被覆盖，如果不希望被覆盖，可以使用 name 进行区分:</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">[<span class="variable language_">self</span> <span class="symbol">bind:</span>_rightHeadlight <span class="symbol">toClass:</span>[Headlight <span class="keyword">class</span>] <span class="symbol">named:</span>@<span class="string">&quot;RightHeadlight&quot;</span>];</span><br><span class="line">[<span class="variable language_">self</span> <span class="symbol">bindClass:</span>[HIDHeadlight <span class="keyword">class</span>] <span class="symbol">toClass:</span>[Headlight <span class="keyword">class</span>] <span class="symbol">named:</span>@<span class="string">&quot;LeftHeadlight&quot;</span>];</span><br></pre></td></tr></table></figure>

<p>接下来就可以在注解绑定中这样用：</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@implementation</span> ShinyCar</span><br><span class="line">objection_register(ShinyCar)</span><br><span class="line">objection_requires_names((@&#123;@<span class="string">&quot;LeftHeadlight&quot;</span>:@<span class="string">&quot;leftHeadlight&quot;</span>, @<span class="string">&quot;RightHeadlight&quot;</span>:@<span class="string">&quot;rightHeadlight&quot;</span>&#125;))</span><br><span class="line">objection_requires(@<span class="string">&quot;foglight&quot;</span>)</span><br><span class="line"><span class="variable">@synthesize</span> leftHeadlight, rightHeadlight, foglight;</span><br><span class="line"><span class="variable">@end</span></span><br></pre></td></tr></table></figure>
<p>还可以在手动获取的时候这样用</p>
<figure class="highlight erlang"><table><tr><td class="code"><pre><span class="line">- <span class="params">(id)</span>getObject:<span class="params">(id)</span>classOrProtocol named:<span class="params">(NSString*)</span>name;</span><br></pre></td></tr></table></figure>

<p><strong><strong>6.2 需要介入实例创建过程的情景</strong></strong></p>
<p>如果需要介入实例的构建过程，可以使用 block 回调来配置你的实例对象：</p>
<figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line"><span class="operator">-</span> (<span class="keyword">void</span>)<span class="keyword">configure</span> &#123;</span><br><span class="line">    [self bindBlock<span class="operator">:</span><span class="operator">^</span>(JSObjectionInjector <span class="operator">*</span>context) &#123;</span><br><span class="line">        Car <span class="operator">*</span>car <span class="operator">=</span> nil;</span><br><span class="line">        <span class="keyword">if</span> (_instrumentNilBlock) &#123;</span><br><span class="line">            car <span class="operator">=</span> [context getObject<span class="operator">:</span>[SixSpeedCar <span class="keyword">class</span>]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            car <span class="operator">=</span> [context getObject<span class="operator">:</span>[FiveSpeedCar <span class="keyword">class</span>]];</span><br><span class="line">            car.engine <span class="operator">=</span> (<span class="built_in">id</span>)myEngine;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">id</span>)car;</span><br><span class="line">    &#125; toClass<span class="operator">:</span>[Car <span class="keyword">class</span>]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><strong>6.3 需要外部参数来创建实例的情景</strong></strong></p>
<p>如果需要外部的一些参数来创建该实例的时候可以使用Provider:</p>
<p>定义一个Provider遵循JSObjectionProvider协议，重写对应的方法：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">DemoObjectProvider</span> : <span class="title">NSObject</span> &lt;<span class="title">JSObjectionProvider</span>&gt;</span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">DemoObjectProvider</span></span></span><br><span class="line">-(<span class="type">id</span>)provide:(JSObjectionInjector *)context arguments:(<span class="built_in">NSArray</span> *)arguments&#123;</span><br><span class="line">    AObject* ob = AObject.new;</span><br><span class="line">    <span class="built_in">NSString</span>* name = arguments.firstObject;</span><br><span class="line">    ob.bj = [[BObject alloc] initWithName:name];</span><br><span class="line">    <span class="keyword">return</span> ob;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>在Model中绑定Provider</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">-(<span class="keyword">void</span>)configure &#123;</span><br><span class="line">    [<span class="meta">self bindProvider:[[DemoObjectProvider alloc</span>] <span class="keyword">init</span>] toClass:AObject.<span class="keyword">class</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么参数怎么传进来呢：</p>
<figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line"><span class="symbol">JSObjectionInjector</span>* injector = [<span class="symbol">JSObjection</span> defaultInjector];</span><br><span class="line"><span class="symbol">AObject</span>* ob1 = [injector getObject:<span class="symbol">AObject</span>.class argumentList:@[@<span class="string">&quot;linxiaohai&quot;</span>]];</span><br></pre></td></tr></table></figure>

<p><strong><strong>6.4 指定绑定的作用域</strong></strong></p>
<p>这个一般用在给单例绑定降级的时候使用</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Car</span></span></span><br><span class="line">objection_register(Car)</span><br><span class="line"><span class="keyword">@synthesize</span> engine, brakes, awake;</span><br><span class="line">- (<span class="type">void</span>)awakeFromObjection &#123;</span><br><span class="line">  awake = <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line">objection_requires(<span class="string">@&quot;engine&quot;</span>, <span class="string">@&quot;brakes&quot;</span>)</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">VisaCCProcessor</span></span></span><br><span class="line">objection_register_singleton(VisaCCProcessor)</span><br><span class="line">objection_initializer(initWithCreditCardNumber:, <span class="string">@&quot;Default&quot;</span>)</span><br><span class="line">objection_requires(<span class="string">@&quot;validator&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">@synthesize</span> validator = _validator;</span><br><span class="line"><span class="keyword">@synthesize</span> CCNumber;</span><br><span class="line"></span><br><span class="line">- (<span class="type">id</span>)initWithCreditCardNumber:(<span class="built_in">NSString</span> *)aCCNumber &#123;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">self</span> = [<span class="variable language_">super</span> init])) &#123;</span><br><span class="line">        <span class="keyword">self</span>.CCNumber = aCCNumber;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="type">void</span>)processNumber:(<span class="built_in">NSString</span> *)number &#123;</span><br><span class="line">    [<span class="variable language_">super</span> processNumber:number];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@implementation</span> ScopeModule</span><br><span class="line"></span><br><span class="line">- (void)configure &#123;</span><br><span class="line">    <span class="selector-attr">[self bindClass:[VisaCCProcessor class]</span> <span class="selector-tag">inScope</span>:<span class="selector-tag">JSObjectionScopeNormal</span>];</span><br><span class="line">    <span class="selector-attr">[self bindClass:[Car class]</span> <span class="selector-tag">inScope</span>:<span class="selector-tag">JSObjectionScopeSingleton</span>];</span><br><span class="line">    <span class="selector-attr">[self registerEagerSingleton:[Car class]</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">@end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>测试用例：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">it(@<span class="string">&quot;can bind a class in singleton scope&quot;</span>, ^&#123;</span><br><span class="line">    assertThat(injector<span class="string">[[Car class]]</span>, is(sameInstance(injector<span class="string">[[Car class]]</span>)));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">it(@<span class="string">&quot;can bind a class in a normal scope&quot;</span>, ^&#123;</span><br><span class="line">    assertThat(injector<span class="string">[[VisaCCProcessor class]]</span>, isNot(sameInstance(injector<span class="string">[[VisaCCProcessor class]]</span>)));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>还可以在绑定Provider&#x2F;Block的时候指定作用域：</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@implementation</span> ProviderScopeModule</span><br><span class="line">- (void)configure &#123;</span><br><span class="line">    <span class="selector-attr">[self bindProvider:[[CarProvider alloc]</span> <span class="selector-tag">init</span>] <span class="selector-tag">toClass</span>:<span class="selector-attr">[Car class]</span> <span class="selector-tag">inScope</span>:<span class="selector-tag">JSObjectionScopeSingleton</span>];</span><br><span class="line">    <span class="selector-attr">[self bindProvider:[[GearBoxProvider alloc]</span> <span class="selector-tag">init</span>] <span class="selector-tag">toProtocol</span>:@<span class="selector-tag">protocol</span>(GearBox) <span class="selector-tag">inScope</span>:<span class="selector-tag">JSObjectionScopeNormal</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">it(@<span class="string">&quot;can bind a provider in singleton scope&quot;</span>, ^&#123;</span><br><span class="line">    assertThat(injector[[Car class]], is(sameInstance(injector[[Car class]])));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">it</span>(@<span class="string">&quot;can bind a provider in a normal scope&quot;</span>, ^&#123;</span><br><span class="line">    <span class="selector-tag">assertThat</span>(injector[<span class="variable">@protocol</span>(GearBox)], isNot(sameInstance(injector[<span class="variable">@protocol</span>(GearBox)])));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@implementation</span> BlockScopeModule</span><br><span class="line"></span><br><span class="line">- (void)configure &#123;</span><br><span class="line">    [self bindBlock:^(JSObjectionInjector *context) &#123;</span><br><span class="line">        Car *car = [[Car alloc] <span class="keyword">init</span>];</span><br><span class="line">        <span class="keyword">return</span> (id)car;</span><br><span class="line">    &#125; toClass:[Car <span class="class"><span class="keyword">class</span>] <span class="title">inScope</span>:<span class="type">JSObjectionScopeSingleton];</span></span></span><br><span class="line"></span><br><span class="line">    [self bindBlock:^(JSObjectionInjector *context) &#123;</span><br><span class="line">        <span class="keyword">return</span> [[AfterMarketGearBox alloc] <span class="keyword">init</span>];</span><br><span class="line">    &#125; toProtocol:<span class="meta">@protocol(GearBox)</span> inScope:JSObjectionScopeNormal];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@end</span></span><br></pre></td></tr></table></figure>

<p><strong><strong>6.4 指定多个模块</strong></strong></p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 启用默认的注入器</span></span><br><span class="line">JSObjectionInjector* injector = [JSObjection defaultInjector];</span><br><span class="line">injector = injector ? : <span class="type"></span>[JSObjection createInjector];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加自定义的模块</span></span><br><span class="line">injector = [injector withModule:<span class="type">MyModule</span>.<span class="keyword">new</span><span class="type"></span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加更多的模块</span></span><br><span class="line">injector = [injector withModules:<span class="type">MyModule1</span>.<span class="keyword">new</span><span class="type"></span>, MyModule2.<span class="keyword">new</span><span class="type"></span>, nil];</span><br><span class="line">[JSObjection setDefaultInjector:<span class="type">injector</span>];</span><br></pre></td></tr></table></figure>

<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">-withModule:方法加入的模块，会将之前相同的绑定覆盖，如果你想更换甭定、作用域等等，就可以使用该方法加入新的绑定。</span></span><br><span class="line"><span class="section">既然能够加入，那么对应的，withoutModuleOfType: 将会移除之前的模块。</span></span><br></pre></td></tr></table></figure>

<h4 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h4><p>objection 源码不算复杂，整个思路还是蛮清晰的，下面是我重新对它目录结构进行组织后的结果：</p>
<p><img src="/2019/12/18/objection-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/00001.png"></p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">Entry/</span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">JSObjectionEntry</span>.</span></span>h</span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">JSObjectionProviderEntry</span>.</span></span>h</span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">JSObjectionInjectorEntry</span>.</span></span>h</span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">JSObjectionBindingEntry</span>.</span></span>h</span><br><span class="line">Module/</span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">JSObjectionModule</span>.</span></span>h</span><br><span class="line">Factory/</span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">JSObjectFactory</span>.</span></span>h</span><br><span class="line">Injector/</span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">JSObjectionInjector</span>.</span></span>h</span><br><span class="line">Utils/</span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">JSObjectionUtils</span>.</span></span>h</span><br></pre></td></tr></table></figure>
<p>上面是几个重要的模块：</p>
<ul>
<li>Entry是一系列用于创建对象的入口</li>
<li>Module用于绑定数据的地方，为Injector提供对象数据源</li>
<li>Injector用于从对象源中取出依赖对象</li>
<li>Factory 其实是对Injector的一个封装</li>
<li>Utils 是整个代码底层的一个支持</li>
</ul>
<p><strong><strong>1. Injector的创建</strong></strong></p>
<p>在使用Objection进行注入的时候需要先调用：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">+</span> (JSObjectionInjector <span class="emphasis">*)createInjector:(JSObjectionModule *</span>)module;</span><br></pre></td></tr></table></figure>

<p>来创建Injector</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">+ (JSObjectionInjector *)createInjector:(JSObjectionModule *)module &#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;gObjectionMutex);</span><br><span class="line">        <span class="keyword">@try</span> &#123;</span><br><span class="line">            return <span class="selector-attr">[[JSObjectionInjector alloc]</span> initWithContext:gObjectionContext andModule:module];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">@finally</span> &#123;</span><br><span class="line">            <span class="built_in">pthread_mutex_unlock</span>(&amp;gObjectionMutex); </span><br><span class="line">        &#125;</span><br><span class="line">        return nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>createInjector方法中会通过JSObjectionInjector 的 initWithContext:andModule:module来创建一个JSObjectionInjector返回，这里的Context在JSObjection的initialize方法中就完成了初始化。<br>一般我们会将createInjector创建的JSObjectionInjector 设置为默认的<strong><strong>gGlobalInjector</strong></strong>这样就可以在任何地方使用了。<br>那么传入的Context用来做什么用的？我们继续往下看：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="operator">-</span> (instancetype)initWithContext:(<span class="type">NSDictionary</span> <span class="operator">*</span>)theGlobalContext andModule:(<span class="type">JSObjectionModule</span> <span class="operator">*</span>)theModule &#123;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">self</span> <span class="operator">=</span> [<span class="keyword">self</span> initWithContext:theGlobalContext])) &#123;</span><br><span class="line">        [<span class="keyword">self</span> configureModule:theModule];</span><br><span class="line">        [<span class="keyword">self</span> initializeEagerSingletons];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="operator">-</span> (instancetype)initWithContext:(<span class="type">NSDictionary</span> <span class="operator">*</span>)theGlobalContext &#123;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">self</span> <span class="operator">=</span> [<span class="keyword">super</span> <span class="keyword">init</span>])) &#123;</span><br><span class="line">        _globalContext <span class="operator">=</span> theGlobalContext;</span><br><span class="line">        _context <span class="operator">=</span> [[<span class="type">NSMutableDictionary</span> alloc] <span class="keyword">init</span>];</span><br><span class="line">        _modules <span class="operator">=</span> [[<span class="type">NSMutableArray</span> alloc] <span class="keyword">init</span>];</span><br><span class="line">        [<span class="keyword">self</span> configureDefaultModule];</span><br><span class="line">        [<span class="keyword">self</span> initializeEagerSingletons];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="operator">-</span> (void)configureDefaultModule &#123;</span><br><span class="line">    <span class="comment">//这里绑定有JSObjectFactory</span></span><br><span class="line">    __JSObjectionInjectorDefaultModule <span class="operator">*</span>module <span class="operator">=</span> [[__JSObjectionInjectorDefaultModule alloc] initWithInjector:<span class="keyword">self</span>];</span><br><span class="line">    <span class="comment">//将__JSObjectionInjectorDefaultModule添加到_modules，调用__JSObjectionInjectorDefaultModule的configure方法（__JSObjectionInjectorDefaultModule没有重写configure）。</span></span><br><span class="line">    <span class="comment">//将__JSObjectionInjectorDefaultModule中的eagerSingletons合并到_eagerSingletons</span></span><br><span class="line">    <span class="comment">//将__JSObjectionInjectorDefaultModule中的bindings添加到_context</span></span><br><span class="line">    [<span class="keyword">self</span> configureModule:module];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="operator">-</span> (void)initializeEagerSingletons &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">NSString</span> <span class="operator">*</span>eagerSingletonKey <span class="keyword">in</span> _eagerSingletons) &#123;</span><br><span class="line">        id entry <span class="operator">=</span> [_context objectForKey:eagerSingletonKey] <span class="operator">?</span>: [_globalContext objectForKey:eagerSingletonKey];</span><br><span class="line">        <span class="keyword">if</span> ([entry lifeCycle] <span class="operator">==</span> <span class="type">JSObjectionScopeSingleton</span>) &#123;</span><br><span class="line">            <span class="comment">//创建eagerSingletonKey对象</span></span><br><span class="line">            [<span class="keyword">self</span> getObject:<span class="type">NSClassFromString</span>(eagerSingletonKey)];      </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="meta">@throw</span> [<span class="type">NSException</span> exceptionWithName:@<span class="string">&quot;JSObjectionException&quot;</span> </span><br><span class="line">                                           reason:[<span class="type">NSString</span> stringWithFormat:@<span class="string">&quot;Unable to initialize eager singleton for the class &#x27;%@&#x27; because it was never registered as a singleton&quot;</span>, eagerSingletonKey] </span><br><span class="line">                                         userInfo:<span class="literal">nil</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="operator">-</span> (void)configureModule:(<span class="type">JSObjectionModule</span> <span class="operator">*</span>)module &#123;</span><br><span class="line">    <span class="comment">//将model添加到_modules</span></span><br><span class="line">    [_modules addObject:module];</span><br><span class="line">    <span class="comment">//调用module的configure执行绑定</span></span><br><span class="line">    [module configure];</span><br><span class="line">    <span class="comment">//将当前的model的eagerSingletons合并到_eagerSingletons</span></span><br><span class="line">    <span class="type">NSSet</span> <span class="operator">*</span>mergedSet <span class="operator">=</span> [module.eagerSingletons setByAddingObjectsFromSet:_eagerSingletons];</span><br><span class="line">    _eagerSingletons <span class="operator">=</span> mergedSet;</span><br><span class="line">    <span class="comment">//将当前model的module.bindings添加到_context</span></span><br><span class="line">    [_context addEntriesFromDictionary:module.bindings];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>JSObjectionInjector初始化方法中有几个比较重要的对象_globalContext，_context，_modules<br>_globalContext用于存储全局的绑定信息，_context存储的是当前injector的绑定信息，_modules 存储的是该injector所包含的JSObjectionModule。</p>
<p>在初始化JSObjectionInjector的阶段，主要完成如下工作：</p>
<figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>. 将<span class="variable">_JSObjectionInjectorDefaultModule</span>以及外部注入的module添加到<span class="variable">_modules</span>，并调用configure 执行绑定</span><br><span class="line"><span class="number">2</span>. 将<span class="variable">_JSObjectionInjectorDefaultModule</span> 以及外部注入的module中的eagerSingletons 添加到<span class="variable">_eagerSingletons</span></span><br><span class="line"><span class="number">3</span>. 将module中的绑定信息添加到<span class="variable">_context</span></span><br><span class="line"><span class="number">4</span>. 完成EagerSingletons的初始化</span><br></pre></td></tr></table></figure>

<p><strong><strong>2. JSObjectionModule</strong></strong></p>
<p>JSObjectionModule中有两个对象_bindings，_eagerSingletons 一个用于存放所有的绑定信息，后面用于存放Eager Singletons的。</p>
<p>JSObjectionModule中的所有注册绑定信息都存放在_bindings,大致归纳了下无非就只有如下几种：</p>
<figure class="highlight erlang"><table><tr><td class="code"><pre><span class="line">- <span class="params">(void)</span>bindMetaClass:<span class="params">(Class)</span>metaClass toProtocol:<span class="params">(Protocol *)</span>aProtocol</span><br><span class="line">- <span class="params">(void)</span>bind:<span class="params">(id)</span>instance toProtocol:<span class="params">(Protocol *)</span>aProtocol named:<span class="params">(NSString *)</span>name</span><br><span class="line">- <span class="params">(void)</span>bind:<span class="params">(id)</span>instance toClass:<span class="params">(Class)</span>aClass named:<span class="params">(NSString *)</span>name </span><br><span class="line">- <span class="params">(void)</span>bindClass:<span class="params">(Class)</span>aClass toClass:<span class="params">(Class)</span>toClass inScope:<span class="params">(JSObjectionScope)</span>scope named:<span class="params">(NSString*)</span>name </span><br><span class="line">- <span class="params">(void)</span>bindClass:<span class="params">(Class)</span>aClass toProtocol:<span class="params">(Protocol *)</span>aProtocol inScope:<span class="params">(JSObjectionScope)</span>scope named:<span class="params">(NSString*)</span>name</span><br><span class="line">- <span class="params">(void)</span>bindProvider:<span class="params">(id &lt;JSObjectionProvider&gt;)</span>provider toClass:<span class="params">(Class)</span>aClass inScope:<span class="params">(JSObjectionScope)</span>scope named:<span class="params">(NSString *)</span>name</span><br><span class="line">- <span class="params">(void)</span>bindProvider:<span class="params">(id &lt;JSObjectionProvider&gt;)</span>provider toProtocol:<span class="params">(Protocol *)</span>aProtocol inScope:<span class="params">(JSObjectionScope)</span>scope named:<span class="params">(NSString *)</span>name</span><br><span class="line">- <span class="params">(void)</span>bindBlock:<span class="params">(id (^)</span><span class="params">(JSObjectionInjector *context)</span>)block toClass:<span class="params">(Class)</span>aClass inScope:<span class="params">(JSObjectionScope)</span>scope named:<span class="params">(NSString *)</span>name</span><br><span class="line">- <span class="params">(void)</span>bindBlock:<span class="params">(id (^)</span><span class="params">(JSObjectionInjector *context)</span>)block toProtocol:<span class="params">(Protocol *)</span>aProtocol inScope:<span class="params">(JSObjectionScope)</span>scope named:<span class="params">(NSString *)</span>name</span><br></pre></td></tr></table></figure>

<p>绑定实例对象，绑定类，绑定Provider,绑定block，绑定MetaClass。 绑定的目标对象主要有两类一个是Class 一个是Protocol。</p>
<p>_bindings的key有两类如果目标对象是Class则key通过方法：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">- (NSString *)classKey:(<span class="keyword">Class</span>)aClass withName:(NSString*)<span class="type">name</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> [NSString stringWithFormat:@&quot;%@%@%@&quot;, NSStringFromClass(aClass), <span class="type">name</span> ? @&quot;:&quot; : @&quot;&quot;, <span class="type">name</span> ? <span class="type">name</span> : @&quot;&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比如class名为IDLDog name为animalDomain,那么key就是@”IDLDog:animalDomain”</p>
<p>如果目标对象是Protocol则key通过方法：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">NSString</span> *)protocolKey:(Protocol *)aProtocol withName:(<span class="built_in">NSString</span>*)name&#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;&lt;%@&gt;%@%@&quot;</span>, <span class="built_in">NSStringFromProtocol</span>(aProtocol), name ? <span class="string">@&quot;:&quot;</span> : <span class="string">@&quot;&quot;</span>, name ? name : <span class="string">@&quot;&quot;</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比如Protocol名为IDLDogProtocol name为animalDomain,那么key就是@”<IDLDogProtocol>:animalDomain”</IDLDogProtocol></p>
<p>而value值是用于生成对象的Entry</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">bindMetaClass</span> ---&gt;</span> JSObjectionBindingEntry</span><br><span class="line"><span class="function"><span class="title">bind</span>          ---&gt;</span> JSObjectionBindingEntry</span><br><span class="line"><span class="function"><span class="title">bindClass</span>     ---&gt;</span> __JSC<span class="function"><span class="title">lassProvider</span> ---&gt;</span> JSObjectionProviderEntry</span><br><span class="line"><span class="function"><span class="title">bindProvider</span>  ---&gt;</span> JSObjectionProviderEntry</span><br><span class="line"><span class="function"><span class="title">bindBlock</span>     ---&gt;</span> JSObjectionProviderEntry</span><br></pre></td></tr></table></figure>

<p><strong><strong>3. getObject 向依赖注入器中获取对象</strong></strong></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">id</span>)getObject:(<span class="type">id</span>)classOrProtocol named:(<span class="built_in">NSString</span>*)name initializer:(SEL)selector argumentList:(<span class="built_in">NSArray</span> *)argumentList &#123;</span><br><span class="line">    <span class="keyword">@synchronized</span>(<span class="keyword">self</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取key</span></span><br><span class="line">        <span class="keyword">if</span> (!classOrProtocol) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">NSString</span> *key = <span class="literal">nil</span>;</span><br><span class="line">        <span class="type">BOOL</span> isClass = class_isMetaClass(object_getClass(classOrProtocol));</span><br><span class="line">        <span class="keyword">if</span> (isClass) &#123;</span><br><span class="line">            key = <span class="built_in">NSStringFromClass</span>(classOrProtocol);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            key = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;&lt;%@&gt;&quot;</span>, <span class="built_in">NSStringFromProtocol</span>(classOrProtocol)];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (name) &#123;</span><br><span class="line">            key = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;%@:%@&quot;</span>,key,name];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//从_context中获取对应的Entry</span></span><br><span class="line">        <span class="type">id</span>&lt;JSObjectionEntry&gt; injectorEntry = [_context objectForKey:key];</span><br><span class="line">        injectorEntry.injector = <span class="keyword">self</span>;</span><br><span class="line">        <span class="keyword">if</span> (!injectorEntry) &#123;</span><br><span class="line">            <span class="comment">//如果没有JSObjectionEntry 则 从_globalContext中获取</span></span><br><span class="line">            <span class="type">id</span>&lt;JSObjectionEntry&gt; entry = [_globalContext objectForKey:key];</span><br><span class="line">            <span class="keyword">if</span> (entry) &#123;</span><br><span class="line">                injectorEntry = [[entry <span class="keyword">class</span>] entryWithEntry:entry];</span><br><span class="line">                injectorEntry.injector = <span class="keyword">self</span>;</span><br><span class="line">                [_context setObject:injectorEntry forKey:key];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(isClass) &#123;</span><br><span class="line">                injectorEntry = [JSObjectionInjectorEntry entryWithClass:classOrProtocol scope:JSObjectionScopeNormal];</span><br><span class="line">                injectorEntry.injector = <span class="keyword">self</span>;</span><br><span class="line">                [_context setObject:injectorEntry forKey:key];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (classOrProtocol &amp;&amp; injectorEntry) &#123;</span><br><span class="line">            <span class="keyword">if</span> ([injectorEntry respondsToSelector:<span class="keyword">@selector</span>(extractObject:initializer:)]) &#123;</span><br><span class="line">                <span class="comment">//调用extractObject获取对象</span></span><br><span class="line">                <span class="keyword">return</span> [injectorEntry extractObject:argumentList initializer:selector];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> [injectorEntry extractObject:argumentList];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>getObject方法比较简单，就是通过classOrProtocol，name 来构建出key。先从_context中获取如果没有则从_globalContext中获取对应的JSObjectionEntry。然后通过extractObject:initializer:或者extractObject:来获取。</p>
<p><strong><strong>4. Entrys 构建对象</strong></strong></p>
<p>我们上面归纳了bind方法与JSObjectionEntry之间的对应关系：</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">bindMetaClass</span> ---&gt;</span> JSObjectionBindingEntry</span><br><span class="line"><span class="function"><span class="title">bind</span>          ---&gt;</span> JSObjectionBindingEntry</span><br><span class="line"><span class="function"><span class="title">bindClass</span>     ---&gt;</span> __JSC<span class="function"><span class="title">lassProvider</span> ---&gt;</span> JSObjectionProviderEntry</span><br><span class="line"><span class="function"><span class="title">bindProvider</span>  ---&gt;</span> JSObjectionProviderEntry</span><br><span class="line"><span class="function"><span class="title">bindBlock</span>     ---&gt;</span> JSObjectionProviderEntry</span><br></pre></td></tr></table></figure>

<p><strong><strong>JSObjectionBindingEntry</strong></strong></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">JSObjectionBindingEntry</span></span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithObject:(<span class="type">id</span>)theObject &#123;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">self</span> = [<span class="variable language_">super</span> init])) &#123;</span><br><span class="line">        _instance = theObject;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">id</span>)extractObject:(<span class="built_in">NSArray</span> *)arguments &#123;</span><br><span class="line">    <span class="keyword">return</span> _instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (JSObjectionScope)lifeCycle &#123;</span><br><span class="line">    <span class="keyword">return</span> JSObjectionScopeSingleton;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)dealloc &#123;</span><br><span class="line">     _instance = <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>JSObjectionBindingEntry 中用于绑定已经创建好的对象，extractObject方法实际上返回的就是最初传入的_instance</p>
<p><strong><strong>JSObjectionProviderEntry</strong></strong></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="meta">@implementation</span> <span class="type">JSObjectionProviderEntry</span></span><br><span class="line"><span class="meta">@synthesize</span> lifeCycle <span class="operator">=</span> _lifeCycle;</span><br><span class="line"><span class="operator">-</span> (id)initWithProvider:(id<span class="operator">&lt;</span><span class="type">JSObjectionProvider</span><span class="operator">&gt;</span>)theProvider lifeCycle:(<span class="type">JSObjectionScope</span>)theLifeCycle &#123;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">self</span> <span class="operator">=</span> [<span class="keyword">super</span> <span class="keyword">init</span>])) &#123;</span><br><span class="line">        _provider <span class="operator">=</span> theProvider;</span><br><span class="line">        _lifeCycle <span class="operator">=</span> theLifeCycle;</span><br><span class="line">        _storageCache <span class="operator">=</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="operator">-</span> (id)initWithBlock:(id(<span class="operator">^</span>)(<span class="type">JSObjectionInjector</span> <span class="operator">*</span>context))theBlock lifeCycle:(<span class="type">JSObjectionScope</span>)theLifeCycle &#123;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">self</span> <span class="operator">=</span> [<span class="keyword">super</span> <span class="keyword">init</span>])) &#123;</span><br><span class="line">        _block <span class="operator">=</span> [theBlock copy];</span><br><span class="line">        _lifeCycle <span class="operator">=</span> theLifeCycle;</span><br><span class="line">        _storageCache <span class="operator">=</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="operator">-</span> (id)extractObject:(<span class="type">NSArray</span> <span class="operator">*</span>)arguments &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.lifeCycle <span class="operator">==</span> <span class="type">JSObjectionScopeNormal</span> <span class="operator">||</span> <span class="operator">!</span>_storageCache) &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="keyword">self</span> buildObject:arguments];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _storageCache;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="operator">-</span> (void)dealloc &#123;</span><br><span class="line">    _storageCache <span class="operator">=</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="operator">-</span> (id)buildObject:(<span class="type">NSArray</span> <span class="operator">*</span>)arguments &#123;</span><br><span class="line">    id objectUnderConstruction <span class="operator">=</span> <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">if</span> (_block) &#123;</span><br><span class="line">        objectUnderConstruction <span class="operator">=</span> _block(<span class="keyword">self</span>.injector);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        objectUnderConstruction <span class="operator">=</span> [_provider provide:<span class="keyword">self</span>.injector arguments:arguments];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.lifeCycle <span class="operator">==</span> <span class="type">JSObjectionScopeSingleton</span>) &#123;</span><br><span class="line">        _storageCache <span class="operator">=</span> objectUnderConstruction;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> objectUnderConstruction;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@end</span></span><br></pre></td></tr></table></figure>

<p>JSObjectionProviderEntry 有两种构造方法，一种是通过Provider,一种是通过Block,JSObjectionProviderEntry 内部会缓存一个_storageCache，在生命周期为JSObjectionScopeSingleton<br>的情况下extractObject会使用_storageCache 否则会在buildObject中通过_block或者_provider创建创建对象返回。</p>
<p><strong><strong>5.宏定义</strong></strong></p>
<p><strong><strong>5.1 注册依赖</strong></strong></p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">#define objection_register(value)			\</span></span><br><span class="line">    + (<span class="literal">void</span>)initialize &#123; <span class="string">\</span></span><br><span class="line">        <span class="keyword">if</span> (self == [value <span class="keyword">class</span>]) &#123; <span class="string">\</span></span><br><span class="line">            [JSObjection registerClass:[value <span class="keyword">class</span>] scope: JSObjectionScopeNormal]; <span class="string">\</span></span><br><span class="line">        &#125; <span class="string">\</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#define objection_register_singleton(value) \</span></span><br><span class="line">    + (<span class="literal">void</span>)initialize &#123; <span class="string">\</span></span><br><span class="line">        <span class="keyword">if</span> (self == [value <span class="keyword">class</span>]) &#123; <span class="string">\</span></span><br><span class="line">            [JSObjection registerClass:[value <span class="keyword">class</span>] scope: JSObjectionScopeSingleton]; <span class="string">\</span></span><br><span class="line">        &#125; <span class="string">\</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>我们上面提到了注册依赖可以通过objection_register以及objection_register_singleton前者用于注册正常的类，后者用于注册单例，但是底层都是通过：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">JSObjection registerClass<span class="selector-pseudo">:scope</span>:</span><br></pre></td></tr></table></figure>
<p>来注册的只不过作用域参数不一样罢了。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">+ (void)registerClass:(Class)theClass scope:(JSObjectionScope)scope &#123;</span><br><span class="line">    pthread<span class="constructor">_mutex_lock(&amp;<span class="params">gObjectionMutex</span>)</span>;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">if</span> (theClass<span class="operator"> &amp;&amp; </span><span class="literal">[<span class="identifier">gObjectionContext</span> <span class="identifier">objectForKey</span>:NSS<span class="identifier">tringFromClass</span>(<span class="identifier">theClass</span>)]</span><span class="operator"> == </span>nil) &#123;</span><br><span class="line">        <span class="literal">[<span class="identifier">gObjectionContext</span> <span class="identifier">setObject</span>:[JSO<span class="identifier">bjectionInjectorEntry</span> <span class="identifier">entryWithClass</span>:<span class="identifier">theClass</span> <span class="identifier">scope</span>:<span class="identifier">scope</span>]</span> forKey:<span class="constructor">NSStringFromClass(<span class="params">theClass</span>)</span>];</span><br><span class="line">    &#125; </span><br><span class="line">    pthread<span class="constructor">_mutex_unlock(&amp;<span class="params">gObjectionMutex</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种情况下的Entry和上面的就不大一样了它是<strong><strong>JSObjectionInjectorEntry</strong></strong>。被添加到gObjectionContext。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">@implementation JSObjectionInjectorEntry</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">#pragma mark - Instance Methods</span><br><span class="line"></span><br><span class="line"><span class="comment">//.....</span></span><br><span class="line"></span><br><span class="line">- (instancetype) extractObject:(NSArray *)arguments <span class="keyword">initializer</span>:(SEL)<span class="keyword">initializer</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (self.lifeCycle<span class="operator"> == </span>JSObjectionScopeNormal<span class="operator"> || </span>!_storageCache) &#123;</span><br><span class="line">        return <span class="literal">[<span class="identifier">self</span> <span class="identifier">buildObject</span>:<span class="identifier">arguments</span> <span class="identifier">initializer</span>: <span class="identifier">initializer</span>]</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    return _storageCache;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">#pragma mark - Private Methods</span><br><span class="line"></span><br><span class="line">- (id)buildObject:(NSArray *)arguments <span class="keyword">initializer</span>: (SEL) <span class="keyword">initializer</span> &#123;</span><br><span class="line">    </span><br><span class="line">    id objectUnderConstruction = nil;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">initializer</span> != nil) &#123;</span><br><span class="line">        objectUnderConstruction = <span class="module-access"><span class="module"><span class="identifier">JSObjectionUtils</span>.</span></span>build<span class="constructor">ObjectWithInitializer(<span class="params">self</span>.<span class="params">classEntry</span>, <span class="params">initializer</span>, <span class="params">arguments</span>)</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="literal">[<span class="identifier">self</span>.<span class="identifier">classEntry</span> <span class="identifier">respondsToSelector</span>:@<span class="identifier">selector</span>(<span class="identifier">objectionInitializer</span>)]</span>) &#123;</span><br><span class="line">        objectUnderConstruction = <span class="module-access"><span class="module"><span class="identifier">JSObjectionUtils</span>.</span></span>build<span class="constructor">ObjectWithInitializer(<span class="params">self</span>.<span class="params">classEntry</span>, [<span class="params">self</span> <span class="params">initializerForObject</span>], [<span class="params">self</span> <span class="params">argumentsForObject</span>:<span class="params">arguments</span>])</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        objectUnderConstruction = <span class="literal">[[<span class="identifier">self</span>.<span class="identifier">classEntry</span> <span class="identifier">alloc</span>]</span> init];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (self.lifeCycle<span class="operator"> == </span>JSObjectionScopeSingleton) &#123;</span><br><span class="line">        _storageCache = objectUnderConstruction;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">JSObjectionUtils</span>.</span></span>inject<span class="constructor">DependenciesIntoProperties(<span class="params">self</span>.<span class="params">injector</span>, <span class="params">self</span>.<span class="params">classEntry</span>, <span class="params">objectUnderConstruction</span>)</span>;</span><br><span class="line">    </span><br><span class="line">    return objectUnderConstruction;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (SEL)initializerForObject &#123;</span><br><span class="line">    return <span class="constructor">NSSelectorFromString([[<span class="params">self</span>.<span class="params">classEntry</span> <span class="params">objectionInitializer</span>] <span class="params">objectForKey</span>:JSObjectionInitializerKey])</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSArray *)argumentsForObject:(NSArray *)givenArguments &#123;</span><br><span class="line">    return givenArguments.count &gt; <span class="number">0</span> ? givenArguments : <span class="literal">[[<span class="identifier">self</span>.<span class="identifier">classEntry</span> <span class="identifier">objectionInitializer</span>]</span> objectForKey:JSObjectionDefaultArgumentsKey];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#pragma mark - Class Methods</span><br><span class="line"></span><br><span class="line">+ (id)entryWithClass:(Class)theClass scope:(JSObjectionScope)theLifeCycle  &#123;</span><br><span class="line">    return <span class="literal">[[JSO<span class="identifier">bjectionInjectorEntry</span> <span class="identifier">alloc</span>]</span> initWithClass:theClass lifeCycle:theLifeCycle];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (id)entryWithEntry:(JSObjectionInjectorEntry *)entry &#123;</span><br><span class="line">    return <span class="literal">[[JSO<span class="identifier">bjectionInjectorEntry</span> <span class="identifier">alloc</span>]</span> initWithClass:entry.classEntry lifeCycle:entry.lifeCycle];  </span><br><span class="line">&#125;</span><br><span class="line">@<span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面最关键的代码在buildObject中如果没有指定参数则调用：</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">objectUnderConstruction</span> <span class="operator">=</span> [[self.classEntry alloc] init]<span class="comment">; </span></span><br></pre></td></tr></table></figure>
<p>也就是走默认构造方法。</p>
<p>如果有指定构造方法则走下面方法：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">JSObjectionUtils</span>.</span></span>build<span class="constructor">ObjectWithInitializer(<span class="params">self</span>.<span class="params">classEntry</span>, <span class="params">initializer</span>, <span class="params">arguments</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>当然还可以实现objectionInitializer方法来指定对应的构造方法。</p>
<p>JSObjectionUtils.buildObjectWithInitializer 方法很简单就是通过消息分发机制调用构造方法:</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line">static id BuildObjectWithInitializer(Class klass, SEL initializer, NSArray *arguments) &#123;</span><br><span class="line">	NSMethodSignature *signature = [klass methodSignatureForSelector:initializer];</span><br><span class="line">	__autoreleasing id<span class="built_in"> instance </span>= nil;</span><br><span class="line">    BOOL isClassMethod = signature != nil &amp;&amp; initializer != @selector(init);</span><br><span class="line">    </span><br><span class="line"><span class="built_in">	if </span>(!isClassMethod) &#123;</span><br><span class="line">	<span class="built_in">	instance </span>= [klass alloc];</span><br><span class="line">		signature = [klass instanceMethodSignatureForSelector:initializer];</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">   <span class="built_in"> if </span>(signature) &#123;</span><br><span class="line">        NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:signature];</span><br><span class="line">        [invocation setTarget:isClassMethod ? klass<span class="keyword"> :</span> instance];</span><br><span class="line">        [invocation setSelector:initializer];</span><br><span class="line">        for (int i = 0; i &lt; arguments.count; i++) &#123;</span><br><span class="line">            __unsafe_unretained id argument = [arguments objectAtIndex:i];</span><br><span class="line">            [invocation setArgument:&amp;argument atIndex:i + 2];</span><br><span class="line">        &#125;</span><br><span class="line">        [invocation invoke];</span><br><span class="line">		[invocation getReturnValue:&amp;instance];</span><br><span class="line">       <span class="built_in"> return </span>instance;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        @throw [NSException exceptionWithName:JSObjectionException reason:[NSString stringWithFormat:@<span class="string">&quot;Could not find initializer &#x27;%@&#x27; on %@&quot;</span>, NSStringFromSelector(initializer), NSStringFromClass(klass)] userInfo:nil]; </span><br><span class="line">    &#125;</span><br><span class="line">   <span class="built_in"> return </span>nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构造完需要的对象后还需要通过JSObjectionUtils.injectDependenciesIntoProperties 来使用依赖对属性进行注入：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">static void <span class="constructor">InjectDependenciesIntoProperties(JSObjectionInjector <span class="operator">*</span><span class="params">injector</span>, Class <span class="params">klass</span>, <span class="params">id</span> <span class="params">object</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果当前有通过objectionRequires指定需要注入的属性</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">[<span class="identifier">klass</span> <span class="identifier">respondsToSelector</span>:@<span class="identifier">selector</span>(<span class="identifier">objectionRequires</span>)]</span>) &#123;</span><br><span class="line">        NSSet *properties = <span class="literal">[<span class="identifier">klass</span> <span class="identifier">objectionRequires</span>]</span>;</span><br><span class="line">        NSMutableDictionary *propertiesDictionary = <span class="literal">[NSM<span class="identifier">utableDictionary</span> <span class="identifier">dictionaryWithCapacity</span>:<span class="identifier">properties</span>.<span class="identifier">count</span>]</span>;</span><br><span class="line">        <span class="keyword">for</span> (NSString *propertyName <span class="keyword">in</span> properties) &#123;</span><br><span class="line">            JSObjectionPropertyInfo propertyInfo;</span><br><span class="line">            id desiredClassOrProtocol;</span><br><span class="line">            <span class="constructor">_getPropertyInfo(<span class="params">klass</span>, <span class="params">propertyName</span>, &amp;<span class="params">propertyInfo</span>, &amp;<span class="params">desiredClassOrProtocol</span>)</span>;</span><br><span class="line">            id theObject = <span class="literal">[<span class="identifier">injector</span> <span class="identifier">getObject</span>:<span class="identifier">desiredClassOrProtocol</span>]</span>;</span><br><span class="line">            <span class="constructor">_validateObjectReturnedFromInjector(&amp;<span class="params">theObject</span>, <span class="params">propertyInfo</span>, <span class="params">desiredClassOrProtocol</span>, <span class="params">propertyName</span>)</span>;</span><br><span class="line">            <span class="literal">[<span class="identifier">propertiesDictionary</span> <span class="identifier">setObject</span>:<span class="identifier">theObject</span> <span class="identifier">forKey</span>:<span class="identifier">propertyName</span>]</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="literal">[<span class="identifier">object</span> <span class="identifier">setValuesForKeysWithDictionary</span>:<span class="identifier">propertiesDictionary</span>]</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果当前有通过objectionRequiresNames指定需要注入的属性</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">[<span class="identifier">klass</span> <span class="identifier">respondsToSelector</span>:@<span class="identifier">selector</span>(<span class="identifier">objectionRequiresNames</span>)]</span>) &#123;</span><br><span class="line">        NSDictionary *namedProperties = <span class="literal">[<span class="identifier">klass</span> <span class="identifier">objectionRequiresNames</span>]</span>;</span><br><span class="line">        NSMutableDictionary *propertiesDictionary = <span class="literal">[NSM<span class="identifier">utableDictionary</span> <span class="identifier">dictionaryWithCapacity</span>:<span class="identifier">namedProperties</span>.<span class="identifier">count</span>]</span>;</span><br><span class="line">        <span class="keyword">for</span> (NSString *namedPropertyKey <span class="keyword">in</span> <span class="literal">[<span class="identifier">namedProperties</span> <span class="identifier">allKeys</span>]</span>) &#123;</span><br><span class="line">            NSString* propertyName = <span class="literal">[<span class="identifier">namedProperties</span> <span class="identifier">valueForKey</span>:<span class="identifier">namedPropertyKey</span>]</span>;</span><br><span class="line">            JSObjectionPropertyInfo propertyInfo;</span><br><span class="line">            id desiredClassOrProtocol;</span><br><span class="line">            <span class="constructor">_getPropertyInfo(<span class="params">klass</span>, <span class="params">propertyName</span>, &amp;<span class="params">propertyInfo</span>, &amp;<span class="params">desiredClassOrProtocol</span>)</span>;</span><br><span class="line">            id theObject = <span class="literal">[<span class="identifier">injector</span> <span class="identifier">getObject</span>:<span class="identifier">desiredClassOrProtocol</span> <span class="identifier">named</span>:<span class="identifier">namedPropertyKey</span>]</span>;</span><br><span class="line">            <span class="constructor">_validateObjectReturnedFromInjector(&amp;<span class="params">theObject</span>, <span class="params">propertyInfo</span>, <span class="params">desiredClassOrProtocol</span>, <span class="params">propertyName</span>)</span>;</span><br><span class="line">            <span class="literal">[<span class="identifier">propertiesDictionary</span> <span class="identifier">setObject</span>:<span class="identifier">theObject</span> <span class="identifier">forKey</span>:<span class="identifier">propertyName</span>]</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 添加属性</span></span><br><span class="line">        <span class="literal">[<span class="identifier">object</span> <span class="identifier">setValuesForKeysWithDictionary</span>:<span class="identifier">propertiesDictionary</span>]</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//调用awakeFromObjection</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">[<span class="identifier">object</span> <span class="identifier">respondsToSelector</span>:@<span class="identifier">selector</span>(<span class="identifier">awakeFromObjection</span>)]</span>) &#123;</span><br><span class="line">        <span class="literal">[<span class="identifier">object</span> <span class="identifier">awakeFromObjection</span>]</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><strong>5.2 属性依赖</strong></strong></p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">#define objection_requires(args...) \</span></span><br><span class="line">    + (NSSet *)objectionRequires &#123; <span class="string">\</span></span><br><span class="line">        NSSet *requirements = [NSSet setWithObjects: args, nil]; <span class="string">\</span></span><br><span class="line">        <span class="keyword">return</span> JSObjectionUtils.buildDependenciesForClass(self, requirements); <span class="string">\</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#define objection_requires_sel(args...) \</span></span><br><span class="line">    + (NSSet *)objectionRequires &#123; <span class="string">\</span></span><br><span class="line">        SEL selectors[] = &#123;args&#125;; <span class="string">\</span></span><br><span class="line">        NSMutableSet *requirements = [NSMutableSet set]; <span class="string">\</span></span><br><span class="line">        <span class="keyword">for</span> (NSUInteger j = <span class="number">0</span>; j &lt; sizeof(selectors)/ sizeof(SEL); j++) &#123; <span class="string">\</span></span><br><span class="line">            SEL selector = selectors[j]; <span class="string">\</span></span><br><span class="line">            [requirements addObject:NSStringFromSelector(selector)]; <span class="string">\</span></span><br><span class="line">        &#125; <span class="string">\</span></span><br><span class="line">        <span class="keyword">return</span> JSObjectionUtils.buildDependenciesForClass(self, requirements); <span class="string">\</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#define objection_requires_names(namedDependencies) \</span></span><br><span class="line">    + (NSDictionary *)objectionRequiresNames &#123; <span class="string">\</span></span><br><span class="line">        <span class="keyword">return</span> JSObjectionUtils.buildNamedDependenciesForClass(self, namedDependencies); <span class="string">\</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里就是上面提到的用于指定需要属性注入的方法，不做展开介绍了。</p>
<p><strong><strong>5.3 指定初始化方法</strong></strong></p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">#define objection<span class="constructor">_initializer_sel(<span class="params">selectorSymbol</span>, <span class="params">args</span><span class="operator">...</span>)</span> \</span><br><span class="line">    + (NSDictionary *)objectionInitializer &#123; \</span><br><span class="line">        id objs<span class="literal">[]</span> = &#123;args&#125;; \</span><br><span class="line">        NSArray *defaultArguments = <span class="literal">[NSA<span class="identifier">rray</span> <span class="identifier">arrayWithObjects</span>: <span class="identifier">objs</span> <span class="identifier">count</span>:<span class="identifier">sizeof</span>(<span class="identifier">objs</span>)<span class="operator">/</span><span class="identifier">sizeof</span>(<span class="identifier">id</span>)]</span>; \</span><br><span class="line">        return <span class="module-access"><span class="module"><span class="identifier">JSObjectionUtils</span>.</span></span>build<span class="constructor">Initializer(<span class="params">selectorSymbol</span>, <span class="params">defaultArguments</span>)</span>; \</span><br><span class="line">    &#125;  </span><br></pre></td></tr></table></figure>

<p>这个也是为了buildObject提供的。用于指定构造方法，细节可以看buildObject中。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/iOS-%E5%BC%80%E6%BA%90%E5%BA%93%E5%88%86%E6%9E%90/">iOS 开源库分析</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/iOS-开源库分析/">iOS 开源库分析</a>
  </div>

</div>



<div class="comments-count">
	
	  	<span></span>
		<a href="/2019/12/18/objection-源码解析/#comments" class="ds-thread-count comments-count-link" data-thread-key="2019/12/18/objection-源码解析/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/12/14/iOS-开源库源码解析-组件化BeeHive/" title="iOS 开源库源码解析- 组件化BeeHive" itemprop="url">iOS 开源库源码解析- 组件化BeeHive</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Edgar" target="_blank" itemprop="author">Edgar</a>
		
  <p class="article-time">
    <time datetime="2019-12-14T13:53:24.000Z" itemprop="datePublished"> Published 2019-12-14</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h4 id="1-开源库基本信息："><a href="#1-开源库基本信息：" class="headerlink" title="1. 开源库基本信息："></a>1. 开源库基本信息：</h4><p><img src="/2019/12/14/iOS-%E5%BC%80%E6%BA%90%E5%BA%93%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E7%BB%84%E4%BB%B6%E5%8C%96BeeHive/0001.png"></p>
<p><a target="_blank" rel="noopener" href="https://github.com/alibaba/BeeHive">开源地址</a></p>
<p><img src="/2019/12/14/iOS-%E5%BC%80%E6%BA%90%E5%BA%93%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E7%BB%84%E4%BB%B6%E5%8C%96BeeHive/0002.png"><br><img src="/2019/12/14/iOS-%E5%BC%80%E6%BA%90%E5%BA%93%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E7%BB%84%E4%BB%B6%E5%8C%96BeeHive/0003.png"></p>
<h4 id="2-源码解析"><a href="#2-源码解析" class="headerlink" title="2. 源码解析"></a>2. 源码解析</h4><h5 id="BeeHive-整体结构"><a href="#BeeHive-整体结构" class="headerlink" title="BeeHive 整体结构"></a>BeeHive 整体结构</h5><p><img src="/2019/12/14/iOS-%E5%BC%80%E6%BA%90%E5%BA%93%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E7%BB%84%E4%BB%B6%E5%8C%96BeeHive/0000.png"></p>
<p>BeeHive 整个模块由上图几个模块构成：</p>
<ul>
<li><strong><strong>BeeHive:</strong></strong></li>
</ul>
<p>BeeHive是BeeHive的核心接口类，它主要用于注册Module,注册Service,查找符合某个协议的Service,以及触发自定义事件。<br>它在setContext的时候会加载一系列的静态服务和模块</p>
<ul>
<li><strong><strong>BHAppDelegate:</strong></strong></li>
</ul>
<p>BHAppDelegate负责转发系统消息的代理，项目中的代理需要继承这个方法。</p>
<ul>
<li><strong><strong>BHContext:</strong></strong></li>
</ul>
<p>BHContext用于存放公共数据的上下文，某个服务的对应的实现类对象也会缓存到这个地方。</p>
<ul>
<li><strong><strong>BHRouter:</strong></strong><br>BHRouter是BeeHive的路由，支持查找服务，跳转页面，注册服务。是基于URL的格式：目前支持的协议如下：<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">//u</span>rl - &gt;  com.alibaba.beehive:<span class="regexp">//</span>call.service.beehive<span class="regexp">/pathComponentKey.protocolName.selector/</span>...?params=&#123;&#125;(value url encode)</span><br><span class="line"><span class="regexp">//u</span>rl - &gt;  com.alibaba.beehive:<span class="regexp">//</span>register.beehive<span class="regexp">/pathComponentKey.protocolName/</span>...?params=&#123;&#125;(value url encode)</span><br><span class="line"><span class="regexp">//u</span>rl - &gt;  com.alibaba.beehive:<span class="regexp">//</span>jump.vc.beehive<span class="regexp">/pathComponentKey.protocolName.push(modal)/</span>...?params=&#123;&#125;(value url encode)<span class="comment">#push</span></span><br><span class="line"><span class="regexp">//</span>params -&gt; &#123;pathComponentKey:&#123;paramName:paramValue,...&#125;,...&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong><strong>BHModuleManager:</strong></strong></li>
</ul>
<p>BHModuleManager 主要负责管理模块和分发事件</p>
<ul>
<li><strong><strong>BHServiceManager:</strong></strong></li>
</ul>
<p>BHModuleManager 负责注册，查找，定位，删除服务</p>
<p>不论是服务还是模块，BeeHive都提供了三种不同的注册形式：静态plist，动态注册，annotation。</p>
<p>个人觉得可以将事件从BHModuleManager中独立出来会显得比较清晰，并且将路由功能也通过BeeHive暴露接口，这样用户需要什么功能都可以直接调用BeeHive接口。</p>
<p>也就是说整个项目以BeeHive为中心，BHAppDelegate持有BeeHive,并向BeeHive注入系统事件，BHContext向BeeHive注入上下文，BeeHive作为对外的门面，向外界暴露模块，服务，事件，路由管理功能，而模块功能由BHModuleManager实际管理，服务功能由BHServiceManager具体管理，事件由BHEventManager管理，路由由BHRouter管理。大体如下图所示：</p>
<p><img src="/2019/12/14/iOS-%E5%BC%80%E6%BA%90%E5%BA%93%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E7%BB%84%E4%BB%B6%E5%8C%96BeeHive/0004.png"></p>
<h5 id="模块管理器-BHModuleManager"><a href="#模块管理器-BHModuleManager" class="headerlink" title="模块管理器 BHModuleManager"></a>模块管理器 BHModuleManager</h5><p>BHModuleManager 主要负责两大类任务：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1.</span> 通过模块的静态加载，动态注册添加模块</span><br><span class="line"><span class="bullet">2.</span> 注册模块事件</span><br></pre></td></tr></table></figure>

<h6 id="模块添加移除"><a href="#模块添加移除" class="headerlink" title="模块添加移除"></a>模块添加移除</h6><p><strong><strong>模块动态注册</strong></strong>：</p>
<p>模块注册是通过registerDynamicModule函数注册的，参数是模块的Class。</p>
<figure class="highlight monkey"><table><tr><td class="code"><pre><span class="line">- (void)registerDynamicModule:(Class)moduleClass &#123;</span><br><span class="line">    [<span class="variable language_">self</span> registerDynamicModule:<span class="keyword">module</span><span class="keyword">Class</span> <span class="title class_">shouldTriggerInitEvent</span>:NO];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight monkey"><table><tr><td class="code"><pre><span class="line">- (void)registerDynamicModule:(Class)<span class="keyword">module</span><span class="keyword">Class</span></span><br><span class="line">       <span class="title class_">shouldTriggerInitEvent</span>:(BOOL)shouldTriggerInitEvent &#123;</span><br><span class="line">    [<span class="variable language_">self</span> addModuleFromObject:<span class="keyword">module</span><span class="keyword">Class</span> <span class="title class_">shouldTriggerInitEvent</span>:shouldTriggerInitEvent];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)addModuleFromObject:(<span class="type">id</span>)object</span><br><span class="line">     shouldTriggerInitEvent:(<span class="type">BOOL</span>)shouldTriggerInitEvent &#123;</span><br><span class="line">    </span><br><span class="line">    Class <span class="keyword">class</span>;</span><br><span class="line">    <span class="built_in">NSString</span> *moduleName = <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!object) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//使用传入的参数初始化关键参数</span></span><br><span class="line">    <span class="keyword">class</span> = object;</span><br><span class="line">    moduleName = <span class="built_in">NSStringFromClass</span>(<span class="keyword">class</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//遍历已经注册的Module查看是否已经添加过</span></span><br><span class="line">    __block <span class="type">BOOL</span> flag = <span class="literal">YES</span>;</span><br><span class="line">    [<span class="keyword">self</span>.BHModules enumerateObjectsUsingBlock:^(<span class="type">id</span>  _Nonnull obj, <span class="built_in">NSUInteger</span> idx, <span class="type">BOOL</span> * _Nonnull stop) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([obj isKindOfClass:<span class="keyword">class</span>]) &#123;</span><br><span class="line">            flag = <span class="literal">NO</span>;</span><br><span class="line">            *stop = <span class="literal">YES</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果已经添加过则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (!flag) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">class</span> conformsToProtocol:<span class="class"><span class="keyword">@protocol</span>(<span class="title">BHModuleProtocol</span>)]) </span>&#123;</span><br><span class="line">        <span class="built_in">NSMutableDictionary</span> *moduleInfo = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">        <span class="type">BOOL</span> responseBasicLevel = [<span class="keyword">class</span> instancesRespondToSelector:<span class="keyword">@selector</span>(basicModuleLevel)];</span><br><span class="line">        <span class="type">int</span> levelInt = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (responseBasicLevel) &#123;</span><br><span class="line">            levelInt = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//填充Module基本信息</span></span><br><span class="line">        [moduleInfo setObject:@(levelInt) forKey:kModuleInfoLevelKey];</span><br><span class="line">        <span class="keyword">if</span> (moduleName) &#123;</span><br><span class="line">            [moduleInfo setObject:moduleName forKey:kModuleInfoNameKey];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//添加到模块基本信息里面</span></span><br><span class="line">        [<span class="keyword">self</span>.BHModuleInfos addObject:moduleInfo];</span><br><span class="line">        <span class="comment">//将模块实例添加到BHModules</span></span><br><span class="line">        <span class="type">id</span>&lt;BHModuleProtocol&gt; moduleInstance = [[<span class="keyword">class</span> alloc] init];</span><br><span class="line">        [<span class="keyword">self</span>.BHModules addObject:moduleInstance];</span><br><span class="line">        [moduleInfo setObject:@(<span class="literal">YES</span>) forKey:kModuleInfoHasInstantiatedKey];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//模块排序：先根据基本模块等级 再根据模块优先级</span></span><br><span class="line">        [<span class="keyword">self</span>.BHModules sortUsingComparator:^<span class="built_in">NSComparisonResult</span>(<span class="type">id</span>&lt;BHModuleProtocol&gt; moduleInstance1, <span class="type">id</span>&lt;BHModuleProtocol&gt; moduleInstance2) &#123;</span><br><span class="line">            <span class="built_in">NSNumber</span> *module1Level = @(BHModuleNormal);</span><br><span class="line">            <span class="built_in">NSNumber</span> *module2Level = @(BHModuleNormal);</span><br><span class="line">            <span class="keyword">if</span> ([moduleInstance1 respondsToSelector:<span class="keyword">@selector</span>(basicModuleLevel)]) &#123;</span><br><span class="line">                module1Level = @(BHModuleBasic);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ([moduleInstance2 respondsToSelector:<span class="keyword">@selector</span>(basicModuleLevel)]) &#123;</span><br><span class="line">                module2Level = @(BHModuleBasic);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (module1Level.integerValue != module2Level.integerValue) &#123;</span><br><span class="line">                <span class="keyword">return</span> module1Level.integerValue &gt; module2Level.integerValue;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">NSInteger</span> module1Priority = <span class="number">0</span>;</span><br><span class="line">                <span class="built_in">NSInteger</span> module2Priority = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> ([moduleInstance1 respondsToSelector:<span class="keyword">@selector</span>(modulePriority)]) &#123;</span><br><span class="line">                    module1Priority = [moduleInstance1 modulePriority];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> ([moduleInstance2 respondsToSelector:<span class="keyword">@selector</span>(modulePriority)]) &#123;</span><br><span class="line">                    module2Priority = [moduleInstance2 modulePriority];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> module1Priority &lt; module2Priority;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;];</span><br><span class="line">        <span class="comment">//注册模块监听事件</span></span><br><span class="line">        [<span class="keyword">self</span> registerEventsByModuleInstance:moduleInstance];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//触发基本的事件</span></span><br><span class="line">        <span class="keyword">if</span> (shouldTriggerInitEvent) &#123;</span><br><span class="line">            <span class="comment">//触发启动</span></span><br><span class="line">            [<span class="keyword">self</span> handleModuleEvent:BHMSetupEvent forTarget:moduleInstance withSeletorStr:<span class="literal">nil</span> andCustomParam:<span class="literal">nil</span>];</span><br><span class="line">            <span class="comment">//触发初始化</span></span><br><span class="line">            [<span class="keyword">self</span> handleModulesInitEventForTarget:moduleInstance withCustomParam:<span class="literal">nil</span>];</span><br><span class="line">            <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                <span class="comment">//触发闪现</span></span><br><span class="line">                [<span class="keyword">self</span> handleModuleEvent:BHMSplashEvent forTarget:moduleInstance withSeletorStr:<span class="literal">nil</span> andCustomParam:<span class="literal">nil</span>];</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>模块注册涉及到两个数组BHModuleInfos 以及 BHModules一个用于存放模块的信息，一个用于存放模块，模块信息包括：模块名（kModuleInfoNameKey），模块等级（kModuleInfoLevelKey），模块是否有实例对象（kModuleInfoHasInstantiatedKey）。每个模块都必须遵循BHModuleProtocol协议。在每次添加的时候都会按照模块level以及模块优先级进行排序。</p>
<p>然后在通过registerEventsByModuleInstance来注册消息事件的监听，如果shouldTriggerInitEvent为YES那么就会触发BHMSetupEvent，BHMInitEvent，BHMSplashEvent事件。</p>
<p><strong><strong>模块移除</strong></strong>：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)unRegisterDynamicModule:(Class)moduleClass &#123;</span><br><span class="line">    <span class="keyword">if</span> (!moduleClass) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="keyword">self</span>.BHModuleInfos filterUsingPredicate:[<span class="built_in">NSPredicate</span> predicateWithFormat:<span class="string">@&quot;%@!=%@&quot;</span>, kModuleInfoNameKey, <span class="built_in">NSStringFromClass</span>(moduleClass)]];</span><br><span class="line">    __block <span class="built_in">NSInteger</span> index = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//查找要移除的模块</span></span><br><span class="line">    [<span class="keyword">self</span>.BHModules enumerateObjectsUsingBlock:^(<span class="type">id</span>  _Nonnull obj, <span class="built_in">NSUInteger</span> idx, <span class="type">BOOL</span> * _Nonnull stop) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([obj isKindOfClass:moduleClass]) &#123;</span><br><span class="line">            index = idx;</span><br><span class="line">            *stop = <span class="literal">YES</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    <span class="comment">//移除模块</span></span><br><span class="line">    <span class="keyword">if</span> (index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        [<span class="keyword">self</span>.BHModules removeObjectAtIndex:index];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历每个事件，有关于当前实例的就从某个事件的监听列表中移除</span></span><br><span class="line">    [<span class="keyword">self</span>.BHModulesByEvent enumerateKeysAndObjectsUsingBlock:^(<span class="built_in">NSNumber</span> * _Nonnull key, <span class="built_in">NSMutableArray</span>&lt;<span class="type">id</span>&lt;BHModuleProtocol&gt;&gt; * _Nonnull obj, <span class="type">BOOL</span> * _Nonnull stop) &#123;</span><br><span class="line">        __block <span class="built_in">NSInteger</span> index = <span class="number">-1</span>;</span><br><span class="line">        [obj enumerateObjectsUsingBlock:^(<span class="type">id</span>&lt;BHModuleProtocol&gt;  _Nonnull obj, <span class="built_in">NSUInteger</span> idx, <span class="type">BOOL</span> * _Nonnull stop) &#123;</span><br><span class="line">            <span class="keyword">if</span> ([obj isKindOfClass:moduleClass]) &#123;</span><br><span class="line">                index = idx;</span><br><span class="line">                *stop = <span class="literal">NO</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;];</span><br><span class="line">        <span class="comment">//从事件中移除</span></span><br><span class="line">        <span class="keyword">if</span> (index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            [obj removeObjectAtIndex:index];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>模块移除也遵循上面的步骤，首先是会从BHModules中移除，而后再从事件中移除，后者会放在后面介绍事件的时候进行详细介绍。</p>
<p><strong><strong>全部模块注册</strong></strong>：</p>
<p>全部模块注册的任务是对模块信息中没有实例化的模块进行实例化后添加到self.BHModules，并对这些模块同一监听系统事件。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)registedAllModules &#123;</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span>.BHModuleInfos sortUsingComparator:^<span class="built_in">NSComparisonResult</span>(<span class="built_in">NSDictionary</span> *module1, <span class="built_in">NSDictionary</span> *module2) &#123;</span><br><span class="line">        <span class="built_in">NSNumber</span> *module1Level = (<span class="built_in">NSNumber</span> *)[module1 objectForKey:kModuleInfoLevelKey];</span><br><span class="line">        <span class="built_in">NSNumber</span> *module2Level =  (<span class="built_in">NSNumber</span> *)[module2 objectForKey:kModuleInfoLevelKey];</span><br><span class="line">        <span class="keyword">if</span> (module1Level.integerValue != module2Level.integerValue) &#123;</span><br><span class="line">            <span class="keyword">return</span> module1Level.integerValue &gt; module2Level.integerValue;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">NSNumber</span> *module1Priority = (<span class="built_in">NSNumber</span> *)[module1 objectForKey:kModuleInfoPriorityKey];</span><br><span class="line">            <span class="built_in">NSNumber</span> *module2Priority = (<span class="built_in">NSNumber</span> *)[module2 objectForKey:kModuleInfoPriorityKey];</span><br><span class="line">            <span class="keyword">return</span> module1Priority.integerValue &lt; module2Priority.integerValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *tmpArray = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">    <span class="comment">//对于模块信息中没有实例化的模块进行实例化后添加到self.BHModules，并对这些模块同一监听系统事件</span></span><br><span class="line">    [<span class="keyword">self</span>.BHModuleInfos enumerateObjectsUsingBlock:^(<span class="built_in">NSDictionary</span> *module, <span class="built_in">NSUInteger</span> idx, <span class="type">BOOL</span> * _Nonnull stop) &#123;</span><br><span class="line">        <span class="built_in">NSString</span> *classStr = [module objectForKey:kModuleInfoNameKey];</span><br><span class="line">        Class moduleClass = <span class="built_in">NSClassFromString</span>(classStr);</span><br><span class="line">        <span class="type">BOOL</span> hasInstantiated = ((<span class="built_in">NSNumber</span> *)[module objectForKey:kModuleInfoHasInstantiatedKey]).boolValue;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">NSStringFromClass</span>(moduleClass) &amp;&amp; !hasInstantiated) &#123;</span><br><span class="line">            <span class="type">id</span>&lt;BHModuleProtocol&gt; moduleInstance = [[moduleClass alloc] init];</span><br><span class="line">            [tmpArray addObject:moduleInstance];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span>.BHModules addObjectsFromArray:tmpArray];</span><br><span class="line">    [<span class="keyword">self</span> registerAllSystemEvents];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么哪些模块是不会在注册的时候实例化呢？其实我们刚刚看到了，注册方法中有个Dynamic关键字表示动态注册，相对的BeeHive支持从plist文件中静态注册，这些静态注册的模块需要调用registedAllModules进行实例化，并注册事件。</p>
<p><strong><strong>模块静态注册</strong></strong>：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)loadLocalModules &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//从plist中加载Module</span></span><br><span class="line">    <span class="built_in">NSString</span> *plistPath = [[<span class="built_in">NSBundle</span> mainBundle] pathForResource:[BHContext shareInstance].moduleConfigName ofType:<span class="string">@&quot;plist&quot;</span>];</span><br><span class="line">    <span class="keyword">if</span> (![[<span class="built_in">NSFileManager</span> defaultManager] fileExistsAtPath:plistPath]) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSDictionary</span> *moduleList = [[<span class="built_in">NSDictionary</span> alloc] initWithContentsOfFile:plistPath];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSArray</span>&lt;<span class="built_in">NSDictionary</span> *&gt; *modulesArray = [moduleList objectForKey:kModuleArrayKey];</span><br><span class="line">    <span class="built_in">NSMutableDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="built_in">NSNumber</span> *&gt; *moduleInfoByClass = @&#123;&#125;.mutableCopy;</span><br><span class="line">    <span class="comment">//构建出一个key --&gt; XXXXClass  value--&gt; @(1) 便于查询，其实这里感觉BHModuleInfos设计不是很合理，为什么不用Dictionary</span></span><br><span class="line">    [<span class="keyword">self</span>.BHModuleInfos enumerateObjectsUsingBlock:^(<span class="built_in">NSDictionary</span> * _Nonnull obj, <span class="built_in">NSUInteger</span> idx, <span class="type">BOOL</span> * _Nonnull stop) &#123;</span><br><span class="line">        [moduleInfoByClass setObject:@<span class="number">1</span> forKey:[obj objectForKey:kModuleInfoNameKey]]; <span class="comment">//key --&gt; XXXXClass  value--&gt; @(1)</span></span><br><span class="line">    &#125;];</span><br><span class="line">    <span class="comment">//没有的话添加到self.BHModuleInfos</span></span><br><span class="line">    [modulesArray enumerateObjectsUsingBlock:^(<span class="built_in">NSDictionary</span> * _Nonnull obj, <span class="built_in">NSUInteger</span> idx, <span class="type">BOOL</span> * _Nonnull stop) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!moduleInfoByClass[[obj objectForKey:kModuleInfoNameKey]]) &#123;</span><br><span class="line">            [<span class="keyword">self</span>.BHModuleInfos addObject:obj];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="模块事件"><a href="#模块事件" class="headerlink" title="模块事件"></a>模块事件</h6><p>BeeHive的事件分成两类：系统事件以及自定义事件，自定义事件的值规定大于1000.<br>整个实现涉及到两个字典：<strong><strong>BHSelectorByEvent</strong></strong>，<strong><strong>BHSelectorByEvent</strong></strong>，两个字典的key都是EventType,可以通过EventType在BHSelectorByEvent找到响应selector，通过BHSelectorByEvent能够找到对应的模块。我们知道事件的三要素要明确：<em><strong>哪个实例？ 监听哪个事件？ 用哪个selector处理</strong></em>*，这些都可以通过这两个字典串起来。</p>
<p><strong><strong>事件注册</strong></strong>:</p>
<p>系统事件是默认添加的，但是注册是需要手动注册的，在注册模块的时候可以选择默认注册BHMSetupEvent，BHMInitEvent，BHMSplashEvent事件。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">- (NSMutableDictionary&lt;NSNumber *, NSString *&gt; *)BHSelectorByEvent &#123;</span><br><span class="line">    <span class="keyword">if</span> (!_BHSelectorByEvent) &#123;</span><br><span class="line">        _BHSelectorByEvent = @&#123;</span><br><span class="line"><span class="meta">                               @(<span class="params">BHMSetupEvent</span>):kSetupSelector,</span></span><br><span class="line"><span class="meta">                               @(<span class="params">BHMInitEvent</span>):kInitSelector,</span></span><br><span class="line"><span class="meta">                               @(<span class="params">BHMTearDownEvent</span>):kTearDownSelector,</span></span><br><span class="line"><span class="meta">                               @(<span class="params">BHMSplashEvent</span>):kSplashSeletor,</span></span><br><span class="line"><span class="meta">                               @(<span class="params">BHMWillResignActiveEvent</span>):kWillResignActiveSelector,</span></span><br><span class="line"><span class="meta">                               @(<span class="params">BHMDidEnterBackgroundEvent</span>):kDidEnterBackgroundSelector,</span></span><br><span class="line"><span class="meta">                               @(<span class="params">BHMWillEnterForegroundEvent</span>):kWillEnterForegroundSelector,</span></span><br><span class="line"><span class="meta">                               @(<span class="params">BHMDidBecomeActiveEvent</span>):kDidBecomeActiveSelector,</span></span><br><span class="line"><span class="meta">                               @(<span class="params">BHMWillTerminateEvent</span>):kWillTerminateSelector,</span></span><br><span class="line"><span class="meta">                               @(<span class="params">BHMUnmountEvent</span>):kUnmountEventSelector,</span></span><br><span class="line"><span class="meta">                               @(<span class="params">BHMOpenURLEvent</span>):kOpenURLSelector,</span></span><br><span class="line"><span class="meta">                               @(<span class="params">BHMDidReceiveMemoryWarningEvent</span>):kDidReceiveMemoryWarningSelector,</span></span><br><span class="line"><span class="meta">                               @(<span class="params">BHMDidReceiveRemoteNotificationEvent</span>):kDidReceiveRemoteNotificationsSelector,</span></span><br><span class="line"><span class="meta">                               @(<span class="params">BHMWillPresentNotificationEvent</span>):kWillPresentNotificationSelector,</span></span><br><span class="line"><span class="meta">                               @(<span class="params">BHMDidReceiveNotificationResponseEvent</span>):kDidReceiveNotificationResponseSelector,</span></span><br><span class="line"><span class="meta">                               @(<span class="params">BHMDidFailToRegisterForRemoteNotificationsEvent</span>):kFailToRegisterForRemoteNotificationsSelector,</span></span><br><span class="line"><span class="meta">                               @(<span class="params">BHMDidRegisterForRemoteNotificationsEvent</span>):kDidRegisterForRemoteNotificationsSelector,</span></span><br><span class="line"><span class="meta">                               @(<span class="params">BHMDidReceiveLocalNotificationEvent</span>):kDidReceiveLocalNotificationsSelector,</span></span><br><span class="line"><span class="meta">                               @(<span class="params">BHMWillContinueUserActivityEvent</span>):kWillContinueUserActivitySelector,</span></span><br><span class="line"><span class="meta">                               @(<span class="params">BHMContinueUserActivityEvent</span>):kContinueUserActivitySelector,</span></span><br><span class="line"><span class="meta">                               @(<span class="params">BHMDidFailToContinueUserActivityEvent</span>):kFailToContinueUserActivitySelector,</span></span><br><span class="line"><span class="meta">                               @(<span class="params">BHMDidUpdateUserActivityEvent</span>):kDidUpdateContinueUserActivitySelector,</span></span><br><span class="line"><span class="meta">                               @(<span class="params">BHMQuickActionEvent</span>):kQuickActionSelector,</span></span><br><span class="line"><span class="meta">                               @(<span class="params">BHMHandleWatchKitExtensionRequestEvent</span>):kHandleWatchKitExtensionRequestSelector,</span></span><br><span class="line"><span class="meta">                               @(<span class="params">BHMDidCustomEvent</span>):kAppCustomSelector,</span></span><br><span class="line">                               &#125;.mutableCopy;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _BHSelectorByEvent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们先来看下事件的注册方法：</p>
<p>首先会做一些预先判断：要注册的实例是否能够响应指定的selector，如果不能就不注册了，如果可以响应那么将eventType为key，selectorStr为value添加到BHSelectorByEvent，然后在查看BHModulesByEvent对应的eventType下面是否添加了当前的实例。添加后再按照modelLevel以及priority对实例进行排序，保证BHModulesByEvent中每个事件的实例列表是按照优先级排序的，优先级高的优先收到事件。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)registerEvent:(<span class="built_in">NSInteger</span>)eventType</span><br><span class="line">         withModuleInstance:(<span class="type">id</span>)moduleInstance</span><br><span class="line">             andSelectorStr:(<span class="built_in">NSString</span> *)selectorStr &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断当前实例是否能够响应selector</span></span><br><span class="line">    SEL selector = <span class="built_in">NSSelectorFromString</span>(selectorStr);</span><br><span class="line">    <span class="keyword">if</span> (!selector || ![moduleInstance respondsToSelector:selector]) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//添加到BHSelectorByEvent key--&gt;eventTypeNumber value selectorStr</span></span><br><span class="line">    <span class="built_in">NSNumber</span> *eventTypeNumber = @(eventType);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>.BHSelectorByEvent[eventTypeNumber]) &#123;</span><br><span class="line">        [<span class="keyword">self</span>.BHSelectorByEvent setObject:selectorStr forKey:eventTypeNumber];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//添加到事件实例上</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>.BHModulesByEvent[eventTypeNumber]) &#123;</span><br><span class="line">        [<span class="keyword">self</span>.BHModulesByEvent setObject:@[].mutableCopy forKey:eventTypeNumber];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//拿到module</span></span><br><span class="line">    <span class="built_in">NSMutableArray</span> *eventModules = [<span class="keyword">self</span>.BHModulesByEvent objectForKey:eventTypeNumber];</span><br><span class="line">    <span class="comment">//不包含的情况下添加到eventModules，并排序</span></span><br><span class="line">    <span class="keyword">if</span> (![eventModules containsObject:moduleInstance]) &#123;</span><br><span class="line">        [eventModules addObject:moduleInstance];</span><br><span class="line">        [eventModules sortUsingComparator:^<span class="built_in">NSComparisonResult</span>(<span class="type">id</span>&lt;BHModuleProtocol&gt; moduleInstance1, <span class="type">id</span>&lt;BHModuleProtocol&gt; moduleInstance2) &#123;</span><br><span class="line">            <span class="built_in">NSNumber</span> *module1Level = @(BHModuleNormal);</span><br><span class="line">            <span class="built_in">NSNumber</span> *module2Level = @(BHModuleNormal);</span><br><span class="line">            <span class="keyword">if</span> ([moduleInstance1 respondsToSelector:<span class="keyword">@selector</span>(basicModuleLevel)]) &#123;</span><br><span class="line">                module1Level = @(BHModuleBasic);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ([moduleInstance2 respondsToSelector:<span class="keyword">@selector</span>(basicModuleLevel)]) &#123;</span><br><span class="line">                module2Level = @(BHModuleBasic);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (module1Level.integerValue != module2Level.integerValue) &#123;</span><br><span class="line">                <span class="keyword">return</span> module1Level.integerValue &gt; module2Level.integerValue;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">NSInteger</span> module1Priority = <span class="number">0</span>;</span><br><span class="line">                <span class="built_in">NSInteger</span> module2Priority = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> ([moduleInstance1 respondsToSelector:<span class="keyword">@selector</span>(modulePriority)]) &#123;</span><br><span class="line">                    module1Priority = [moduleInstance1 modulePriority];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> ([moduleInstance2 respondsToSelector:<span class="keyword">@selector</span>(modulePriority)]) &#123;</span><br><span class="line">                    module2Priority = [moduleInstance2 modulePriority];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> module1Priority &lt; module2Priority;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><strong>事件触发</strong></strong></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)triggerEvent:(<span class="built_in">NSInteger</span>)eventType</span><br><span class="line">     withCustomParam:(<span class="built_in">NSDictionary</span> *)customParam &#123;</span><br><span class="line">    [<span class="keyword">self</span> handleModuleEvent:eventType forTarget:<span class="literal">nil</span> withCustomParam:customParam];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)handleModuleEvent:(<span class="built_in">NSInteger</span>)eventType</span><br><span class="line">                forTarget:(<span class="type">id</span>&lt;BHModuleProtocol&gt;)target</span><br><span class="line">           withSeletorStr:(<span class="built_in">NSString</span> *)selectorStr</span><br><span class="line">           andCustomParam:(<span class="built_in">NSDictionary</span> *)customParam &#123;</span><br><span class="line">    </span><br><span class="line">    BHContext *context = [BHContext shareInstance].copy;</span><br><span class="line">    context.customParam = customParam;</span><br><span class="line">    context.customEvent = eventType;</span><br><span class="line">    <span class="comment">//首先尝试使用传入的selectorStr来处理，如果不行都去BHSelectorByEvent里面去获取对应的selector</span></span><br><span class="line">    <span class="keyword">if</span> (!selectorStr.length) &#123;</span><br><span class="line">        selectorStr = [<span class="keyword">self</span>.BHSelectorByEvent objectForKey:@(eventType)];</span><br><span class="line">    &#125;</span><br><span class="line">    SEL seletor = <span class="built_in">NSSelectorFromString</span>(selectorStr);</span><br><span class="line">    <span class="keyword">if</span> (!seletor) &#123;</span><br><span class="line">        selectorStr = [<span class="keyword">self</span>.BHSelectorByEvent objectForKey:@(eventType)];</span><br><span class="line">        seletor = <span class="built_in">NSSelectorFromString</span>(selectorStr);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果target有传入特定的，那么直接触发特定实例中的方法就好，否则触发能够响应当前事件的所有实例的selector方法</span></span><br><span class="line">    <span class="built_in">NSArray</span>&lt;<span class="type">id</span>&lt;BHModuleProtocol&gt;&gt; *moduleInstances;</span><br><span class="line">    <span class="keyword">if</span> (target) &#123;</span><br><span class="line">        moduleInstances = @[target];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        moduleInstances = [<span class="keyword">self</span>.BHModulesByEvent objectForKey:@(eventType)];</span><br><span class="line">    &#125;</span><br><span class="line">    [moduleInstances enumerateObjectsUsingBlock:^(<span class="type">id</span>&lt;BHModuleProtocol&gt; moduleInstance, <span class="built_in">NSUInteger</span> idx, <span class="type">BOOL</span> * _Nonnull stop) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([moduleInstance respondsToSelector:seletor]) &#123;</span><br><span class="line">            <span class="comment">//通过performSelector触发方法</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> clang diagnostic push</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> clang diagnostic ignored <span class="string">&quot;-Warc-performSelector-leaks&quot;</span></span></span><br><span class="line">            [moduleInstance performSelector:seletor withObject:context];</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> clang diagnostic pop</span></span><br><span class="line">            <span class="comment">//记录时间</span></span><br><span class="line">            [[BHTimeProfiler sharedTimeProfiler] recordEventTime:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;%@ --- %@&quot;</span>, [moduleInstance <span class="keyword">class</span>], <span class="built_in">NSStringFromSelector</span>(seletor)]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>事件触发实际上是通过performSelector来完成的，它需要知道要触发哪个实例的哪个事件，介绍了上面的注册流程后就可以很清楚得了解到整个事件的组织结构，那么事件的触发就是通过上面介绍的两个字典，找到事件的响应方法，以及需要触发哪些实例的对应方法了。BeeHive将模块初始化以及模块销毁独立开来是因为这两个事件有特殊之处，模块初始化有些模块是支持异步的，有些则是同步的，模块销毁的特别之处在于要按照优先级从低到高销毁。</p>
<h5 id="服务管理器-BHServiceManager"><a href="#服务管理器-BHServiceManager" class="headerlink" title="服务管理器 BHServiceManager"></a>服务管理器 BHServiceManager</h5><p>在BeeHive中另一个比较重要的就是Servic了，它类似于一个提供某个处理的接口，BHServiceManager负责服务的注册，服务的移除，服务的搜索，同样BHServiceManager也提供了动态和静态注册服务的两种方式，BeeHive的服务实际上是Protocal - Class(Instance) 模式，Protocal提供了服务能够提供哪些服务的外在接口协议，而Class(Instance) 实际上则是这些服务的真正提供实例。</p>
<h6 id="服务添加，移除，定位"><a href="#服务添加，移除，定位" class="headerlink" title="服务添加，移除，定位"></a>服务添加，移除，定位</h6><p><strong><strong>服务动态注册</strong></strong>：</p>
<p>这没啥好说的一看就懂：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)registerService:(Protocol *)service implClass:(Class)implClass &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSParameterAssert</span>(service != <span class="literal">nil</span>);</span><br><span class="line">    <span class="built_in">NSParameterAssert</span>(implClass != <span class="literal">nil</span>);</span><br><span class="line">    <span class="comment">//添加前判断</span></span><br><span class="line">    <span class="keyword">if</span> (![implClass conformsToProtocol:service]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.enableException) &#123;</span><br><span class="line">            <span class="keyword">@throw</span> [<span class="built_in">NSException</span> exceptionWithName:<span class="built_in">NSInternalInconsistencyException</span> reason:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;%@ module does not comply with %@ protocol&quot;</span>, <span class="built_in">NSStringFromClass</span>(implClass), <span class="built_in">NSStringFromProtocol</span>(service)] userInfo:<span class="literal">nil</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span> checkValidService:service]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.enableException) &#123;</span><br><span class="line">            <span class="keyword">@throw</span> [<span class="built_in">NSException</span> exceptionWithName:<span class="built_in">NSInternalInconsistencyException</span> reason:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;%@ protocol has been registed&quot;</span>, <span class="built_in">NSStringFromProtocol</span>(service)] userInfo:<span class="literal">nil</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSString</span> *key = <span class="built_in">NSStringFromProtocol</span>(service);</span><br><span class="line">    <span class="built_in">NSString</span> *value = <span class="built_in">NSStringFromClass</span>(implClass);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//加入BHModuleManager key 为 Protocol value 为 实现类Class</span></span><br><span class="line">    <span class="keyword">if</span> (key.length &gt; <span class="number">0</span> &amp;&amp; value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        [<span class="keyword">self</span>.lock lock];</span><br><span class="line">        [<span class="keyword">self</span>.allServicesDict addEntriesFromDictionary:@&#123;key:value&#125;];</span><br><span class="line">        [<span class="keyword">self</span>.lock unlock];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><strong>服务静态注册</strong></strong>：</p>
<p>还是不说哼哼哈哈^V^</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)registerLocalServices &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSString</span> *serviceConfigName = [BHContext shareInstance].serviceConfigName;</span><br><span class="line">    <span class="built_in">NSString</span> *plistPath = [[<span class="built_in">NSBundle</span> mainBundle] pathForResource:serviceConfigName ofType:<span class="string">@&quot;plist&quot;</span>];</span><br><span class="line">    <span class="keyword">if</span> (!plistPath) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSArray</span> *serviceList = [[<span class="built_in">NSArray</span> alloc] initWithContentsOfFile:plistPath];</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span>.lock lock];</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSDictionary</span> *dict <span class="keyword">in</span> serviceList) &#123;</span><br><span class="line">        <span class="built_in">NSString</span> *protocolKey = [dict objectForKey:<span class="string">@&quot;service&quot;</span>];</span><br><span class="line">        <span class="built_in">NSString</span> *protocolImplClass = [dict objectForKey:<span class="string">@&quot;impl&quot;</span>];</span><br><span class="line">        <span class="keyword">if</span> (protocolKey.length &gt; <span class="number">0</span> &amp;&amp; protocolImplClass.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            [<span class="keyword">self</span>.allServicesDict addEntriesFromDictionary:@&#123;protocolKey:protocolImplClass&#125;];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="keyword">self</span>.lock unlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><strong>服务定位</strong></strong>：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">id</span>)createService:(Protocol *)service withServiceName:(<span class="built_in">NSString</span> *)serviceName shouldCache:(<span class="type">BOOL</span>)shouldCache<span class="comment">/*是否从缓存中找*/</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!serviceName.length) &#123;</span><br><span class="line">        serviceName = <span class="built_in">NSStringFromProtocol</span>(service);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">id</span> implInstance = <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//没有对应的实现</span></span><br><span class="line">    <span class="keyword">if</span> (![<span class="keyword">self</span> checkValidService:service]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.enableException) &#123;</span><br><span class="line">            <span class="keyword">@throw</span> [<span class="built_in">NSException</span> exceptionWithName:<span class="built_in">NSInternalInconsistencyException</span> reason:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;%@ protocol does not been registed&quot;</span>, <span class="built_in">NSStringFromProtocol</span>(service)] userInfo:<span class="literal">nil</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSString</span> *serviceStr = serviceName;</span><br><span class="line">    <span class="comment">//是否从缓存中查找，如果允许的话则从BHContext中找，找到直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (shouldCache) &#123;</span><br><span class="line">        <span class="type">id</span> protocolImpl = [[BHContext shareInstance] getServiceInstanceFromServiceName:serviceStr];</span><br><span class="line">        <span class="keyword">if</span> (protocolImpl) &#123;</span><br><span class="line">            <span class="keyword">return</span> protocolImpl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果没有在BHContext中则从serviceImplClass找</span></span><br><span class="line">    Class implClass = [<span class="keyword">self</span> serviceImplClass:service];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ([[implClass <span class="keyword">class</span>] respondsToSelector:<span class="keyword">@selector</span>(singleton)]) &#123;</span><br><span class="line">        <span class="comment">//是否是单例如果是单例则通过shareInstance创建对象，否则通过alloc创建</span></span><br><span class="line">        <span class="keyword">if</span> ([[implClass <span class="keyword">class</span>] singleton]) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> ([[implClass <span class="keyword">class</span>] respondsToSelector:<span class="keyword">@selector</span>(shareInstance)])</span><br><span class="line">                implInstance = [[implClass <span class="keyword">class</span>] shareInstance];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                implInstance = [[implClass alloc] init];</span><br><span class="line">            <span class="comment">//如果shouldCache 则添加到BHContext</span></span><br><span class="line">            <span class="keyword">if</span> (shouldCache) &#123;</span><br><span class="line">                [[BHContext shareInstance] addServiceWithImplInstance:implInstance serviceName:serviceStr];</span><br><span class="line">                <span class="keyword">return</span> implInstance;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> implInstance;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [[implClass alloc] init];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于createService这个方法名起得个人觉得不是很好，刚看到这个方法名的时候我的第一印象是：服务不是通过regist方法注册了吗，为什么需要create，实际上这只是通过服务协议来找到服务提供对象而已，个人建议可以叫做：</p>
<figure class="highlight erlang"><table><tr><td class="code"><pre><span class="line">- <span class="params">(id)</span>serviceConfirmToProtocol:<span class="params">(Protocol *)</span>service withServiceName:<span class="params">(NSString *)</span>serviceName shouldCache:<span class="params">(BOOL)</span>shouldCache;</span><br></pre></td></tr></table></figure>

<p>这里有一个需要注意的是我们这里返回的是提供服务的实例，而我们注册的提供服务的Class,为了避免每次都根据Class创建实例 ，BHContext 中有提供对应的缓存存储在[BHContext shareInstance].servicesByName中，而我们注册的服务存储在serviceImplClass中，所以每次我们要做的就是通过Protocal从先从[BHContext shareInstance].servicesByName中找，如果有之前已经缓存的实例的话就不需要重新创建了，直接返回就可以了，如果没有那么从serviceImplClass中找到对应的class，然后初始化出实例，然后添加到[BHContext shareInstance].servicesByName中缓存。</p>
<h4 id="3-Annotation-注解"><a href="#3-Annotation-注解" class="headerlink" title="3.Annotation 注解"></a>3.Annotation 注解</h4><p>这是我看BeeHive眼前一亮的一块代码，本来想将这块内容放到服务和模块注册地方来介绍的，因为BeeHive注解主要用于注册模块和服务，之所以单独成一块来介绍主要是它有一定的通用性。</p>
<p>我们就开始看这块内容：</p>
<p>注册模块的时候使用的宏定义</p>
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line">#define BeeHiveMod(name) \</span><br><span class="line"><span class="keyword">class</span> BeeHive; char * k##name##_mod BeeHiveDATA(BeehiveMods) = <span class="string">&quot;&quot;</span>#name<span class="string">&quot;&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>注册服务时候使用的宏定义：</p>
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line">#define BeeHiveService(servicename,impl) \</span><br><span class="line"><span class="keyword">class</span> BeeHive; char * k##servicename##_service BeeHiveDATA(BeehiveServices) = <span class="string">&quot;&#123; \&quot;&quot;</span>#servicename<span class="string">&quot;\&quot; : \&quot;&quot;</span>#impl<span class="string">&quot;\&quot;&#125;&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>在项目中可以这样使用：</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@BeeHiveMod</span>(ShopModule)</span><br><span class="line"><span class="variable">@interface</span> ShopModule() &lt;BHModuleProtocol&gt;</span><br><span class="line"><span class="variable">@end</span></span><br></pre></td></tr></table></figure>

<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@BeeHiveService</span>(HomeServiceProtocol,BHViewController)</span><br><span class="line"><span class="variable">@interface</span> BHViewController ()&lt;HomeServiceProtocol&gt;</span><br><span class="line"></span><br><span class="line"><span class="variable">@end</span></span><br></pre></td></tr></table></figure>

<p>我们专注来看BeeHiveMod:</p>
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line">#define BeeHiveMod(name) \</span><br><span class="line"><span class="keyword">class</span> BeeHive; char * k##name##_mod BeeHiveDATA(BeehiveMods) = <span class="string">&quot;&quot;</span>#name<span class="string">&quot;&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>@BeeHiveMod(ShopModule) 替换后会变成：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BeeHive</span>; <span class="function"><span class="type">char</span> * kShopModule_mod <span class="title">BeeHiveDATA</span><span class="params">(BeehiveMods)</span> </span>= <span class="string">&quot;&quot;</span>ShopModule<span class="string">&quot;&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>再来看下：BeeHiveDATA</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">#define <span class="constructor">BeeHiveDATA(<span class="params">sectname</span>)</span> <span class="constructor">__attribute((<span class="params">used</span>, <span class="params">section</span>(<span class="string">&quot;__DATA,&quot;</span>#<span class="params">sectname</span><span class="string">&quot; &quot;</span>)</span>))</span><br></pre></td></tr></table></figure>

<p>替换后变成：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@class BeeHive; char * kShopModule_mod __attribute(<span class="params">(<span class="params">used, section(<span class="params"><span class="string">&quot;__DATA,&quot;</span><span class="string">&quot;BeehiveMods&quot;</span><span class="string">&quot; &quot;</span></span>)</span>)</span>) = <span class="string">&quot;&quot;&quot;ShopModule&quot;&quot;&quot;</span>;</span></span><br></pre></td></tr></table></figure>
<p>去掉__attribute的属性，相当于：</p>
<figure class="highlight ceylon"><table><tr><td class="code"><pre><span class="line"><span class="meta">@class</span> BeeHive; char * kShopModule<span class="number">_m</span>od = <span class="string">&quot;&quot;&quot;ShopModule&quot;&quot;&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>这里最重要的关键字是__attribute，由于kShopModule_mod字符串没有使用到，在Release包的时候会被优化掉所以需要使用used来避免被编译器优化，section用于指定kShopModule_mod存放的位置，section(“__DATA,””BeehiveMods”” “)表示，将kShopModule_mod存储在__DATA数据段里面的”BeehiveMods”section中。</p>
<p>那如何读取到这些字段呢？我们看下<strong><strong>BHAnnotation</strong></strong>类，我们先看下initProphet，</p>
<figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line">__attribute__((<span class="function"><span class="keyword">constructor</span>))</span></span><br><span class="line"><span class="function"><span class="title">void</span> <span class="title">initProphet</span><span class="params">()</span> <span class="comment">&#123;</span></span></span><br><span class="line"><span class="comment"><span class="function">    _dyld_register_func_for_add_image(dyld_callback);</span></span></span><br><span class="line"><span class="comment"><span class="function">&#125;</span></span></span><br></pre></td></tr></table></figure>

<p>它用编译标记__attribute__((constructor))进行标记，****<strong>attribute</strong>((constructor))**** 的用法大家可以看下：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/dd425b9dc9db"><strong>attribute</strong>((constructor))用法解析</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.sunnyxx.com/2016/05/14/clang-attributes/">Clang Attributes 黑魔法小记</a></li>
<li><a target="_blank" rel="noopener" href="http://liumh.com/2018/08/18/ios-attribute-section/"><strong>attribute</strong></a></li>
</ul>
<p><strong>attribute</strong>((constructor))是在main函数之前,执行一个函数,也就是initProphet会在编译之前执行，_dyld_register_func_for_add_image(dyld_callback);回来镜像加载后调用dyld_callback。在这里面可以对加载完的镜像文件进行处理，读取出我们写到指定Session中的数据。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function">NSArray&lt;NSString *&gt;* <span class="title">BHReadConfiguration</span><span class="params">(<span class="type">char</span> *sectionName,<span class="type">const</span> <span class="keyword">struct</span> mach_header *mhp)</span> </span>&#123;</span><br><span class="line">    NSMutableArray *configs = [NSMutableArray array];</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> size = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __LP64__</span></span><br><span class="line">    <span class="type">uintptr_t</span> *memory = (<span class="type">uintptr_t</span>*)<span class="built_in">getsectiondata</span>(mhp, SEG_DATA, sectionName, &amp;size);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">mach_header_64</span> *mhp64 = (<span class="type">const</span> <span class="keyword">struct</span> mach_header_64 *)mhp;</span><br><span class="line">    <span class="type">uintptr_t</span> *memory = (<span class="type">uintptr_t</span>*)<span class="built_in">getsectiondata</span>(mhp64, SEG_DATA, sectionName, &amp;size);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> counter = size/<span class="built_in">sizeof</span>(<span class="type">void</span>*);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> idx = <span class="number">0</span>; idx &lt; counter; ++idx)&#123;</span><br><span class="line">        <span class="type">char</span> *string = (<span class="type">char</span>*)memory[idx];</span><br><span class="line">        NSString *str = [NSString stringWithUTF8String:string];</span><br><span class="line">        <span class="keyword">if</span>(!str)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">BHLog</span>(@<span class="string">&quot;config = %@&quot;</span>, str);</span><br><span class="line">        <span class="keyword">if</span>(str) [configs addObject:str];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> configs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>BHReadConfiguration 用于从__DATA中读取指定session下的数据。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">void</span> dyld_callback(<span class="keyword">const</span> <span class="keyword">struct</span> mach_header *mhp, intptr_t vmaddr_slide) &#123;</span><br><span class="line">    <span class="built_in">NSArray</span> *mods = BHReadConfiguration(BeehiveModSectName, mhp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSString</span> *modName <span class="keyword">in</span> mods) &#123;</span><br><span class="line">        Class cls;</span><br><span class="line">        <span class="keyword">if</span> (modName) &#123;</span><br><span class="line">            cls = <span class="built_in">NSClassFromString</span>(modName);</span><br><span class="line">            <span class="keyword">if</span> (cls) &#123;</span><br><span class="line">                [[BHModuleManager sharedManager] registerDynamicModule:cls];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//register services</span></span><br><span class="line">    <span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *services = BHReadConfiguration(BeehiveServiceSectName,mhp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSString</span> *map <span class="keyword">in</span> services) &#123;</span><br><span class="line">        <span class="built_in">NSData</span> *jsonData =  [map dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">        <span class="built_in">NSError</span> *error = <span class="literal">nil</span>;</span><br><span class="line">        <span class="type">id</span> json = [<span class="built_in">NSJSONSerialization</span> JSONObjectWithData:jsonData options:<span class="number">0</span> error:&amp;error];</span><br><span class="line">        <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">            <span class="keyword">if</span> ([json isKindOfClass:[<span class="built_in">NSDictionary</span> <span class="keyword">class</span>]] &amp;&amp; [json allKeys].count) &#123;</span><br><span class="line">                <span class="built_in">NSString</span> *protocol = [json allKeys][<span class="number">0</span>];</span><br><span class="line">                <span class="built_in">NSString</span> *clsName  = [json allValues][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">if</span> (protocol &amp;&amp; clsName) &#123;</span><br><span class="line">                    [[BHServiceManager sharedManager] registerService:<span class="built_in">NSProtocolFromString</span>(protocol) implClass:<span class="built_in">NSClassFromString</span>(clsName)];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是在镜像文件加载完毕后，通过BHReadConfiguration将上面注解方式添加的字符串读取出来，并使用这些数据进行注册服务和模块。</p>
<h4 id="4-较好的文章推荐"><a href="#4-较好的文章推荐" class="headerlink" title="4.较好的文章推荐"></a>4.较好的文章推荐</h4><ul>
<li><a target="_blank" rel="noopener" href="https://juejin.im/entry/5be28e1f6fb9a049c84eee1d">阿里组件化框架BeeHive解析</a></li>
<li><a target="_blank" rel="noopener" href="https://halfrost.com/beehive/">BeeHive —— 一个优雅但还在完善中的解耦框架</a></li>
</ul>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/iOS-%E5%BC%80%E6%BA%90%E5%BA%93%E5%88%86%E6%9E%90/">iOS 开源库分析</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/iOS-开源库分析/">iOS 开源库分析</a>
  </div>

</div>



<div class="comments-count">
	
	  	<span></span>
		<a href="/2019/12/14/iOS-开源库源码解析-组件化BeeHive/#comments" class="ds-thread-count comments-count-link" data-thread-key="2019/12/14/iOS-开源库源码解析-组件化BeeHive/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/12/08/IGKListKit-使用及源码分析/" title="IGKListKit 使用及源码分析" itemprop="url">IGKListKit 使用及源码分析</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Edgar" target="_blank" itemprop="author">Edgar</a>
		
  <p class="article-time">
    <time datetime="2019-12-07T17:23:15.000Z" itemprop="datePublished"> Published 2019-12-08</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p><img src="/2019/12/08/IGKListKit-%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/00001.gif"></p>
<h5 id="开源信息"><a href="#开源信息" class="headerlink" title="开源信息"></a>开源信息</h5><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/Instagram/IGListKit">IGKListKit 源码地址</a></li>
<li><a target="_blank" rel="noopener" href="https://instagram.github.io/IGListKit/">IGKListKit 文档地址</a></li>
</ul>
<p><strong><strong>IGKListKit 是一个数据驱动的用于快速创建列表的框架，它有如下特点：</strong></strong></p>
<ul>
<li>🙅 Never call performBatchUpdates(_:, completion:) or reloadData() again</li>
<li>🏠 Better architecture with reusable cells and components</li>
<li>🔠 Create collections with multiple data types</li>
<li>🔑 Decoupled diffing algorithm</li>
<li>✅	Fully unit tested</li>
<li>🔍 Customize your diffing behavior for your models</li>
<li>📱 Simply UICollectionView at its core</li>
<li>🚀 Extendable API</li>
<li>🐦 Written in Objective-C with full Swift interop support</li>
</ul>
<h5 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h5><p>整个IGKListKit代码还是蛮多的，我们在进行源码解析之前先对这些代码进行整理下，看下整个IGKListKit是由哪些部分构成的：</p>
<p><img src="/2019/12/08/IGKListKit-%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/00002.png"></p>
<p>这里大致将整个代码分成两大部分：</p>
<ol>
<li>IGListDiffKit 里面存放的是IGListKit的diff 算法相关类</li>
<li>IGListKit 里面存放的是整个框架代码，它是由如下几部分构成：</li>
</ol>
<ul>
<li>Adapter: 这是最核心的部分，是它将CollectionView,SessionController,Updater,Context关联起来。它从SessionController获取每个session的数据，通过Updater将数据加载到CollectionView。</li>
<li>Updater: 负责将数据加载到CollectionView</li>
<li>CollectionView: 负责数据的展示</li>
<li>Context: 一些环境上下文全局内容</li>
<li>Debug: 用于辅助调试的内容</li>
</ul>
<p>这篇博客会从数据源开始，从数据源的提供，根据数据源选择SessionController,再通过Updater将数据加载到UICollectionView.</p>
<p><img src="/2019/12/08/IGKListKit-%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/00003.png"></p>
<p><strong><strong>数据源</strong></strong></p>
<p>IGListKit 数据源都必须遵循<strong><strong>IGListAdapterDataSource</strong></strong>协议：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 根据传入的IGListAdapter来返回要展示的数据源，注意这里的数组中的每个元素对应的是一个session中要展示的数据集，返回的是多个session数据集的集合。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (NSArray&lt;id &lt;IGListDiffable&gt;&gt; *)objectsForListAdapter:(IGListAdapter *)listAdapter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 传入特定的对象，也就是一个session的数据集合，返回它对应的sessionController，我们可以在这里建立sessionController与对象数据集合的对应关系。这里也是新建sessionController的地方，我们可以在这里传数据给sessionController</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (IGListSectionController *)listAdapter:(IGListAdapter *)listAdapter sectionControllerForObject:(id)object;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 当列表的数据集合为空的时候可以通过这个位置返回空页面需要展示的内容</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (nullable UIView *)emptyViewForListAdapter:(IGListAdapter *)listAdapter;</span><br></pre></td></tr></table></figure>

<p>在<strong><strong>IGListAdapterDataSource</strong></strong>中我们可以提供数据，空数据时候所要展示的界面，以及session数据与sessionController之间的映射关系。</p>
<p><strong><strong>IGListAdapter的初始化工作</strong></strong></p>
<p>IGListAdapter是整个IGListKit的核心部分，它负责调度各个类来完成从数据源获取数据，数据与sessionController的映射关系，使用Updater将数据加载到UICollectionView,分发各个代理事件等等功能，所以我们先来看下它是由哪些重要的组件构成，以及这些组件都有哪些功能：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 容纳适配器的视图控制器。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">nullable</span>, <span class="keyword">weak</span>) <span class="built_in">UIViewController</span> *viewController;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 适配器使用的UICollectionView</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">nullable</span>, <span class="keyword">weak</span>) <span class="built_in">UICollectionView</span> *collectionView;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> IGListAdapter的数据源</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">nullable</span>, <span class="keyword">weak</span>) <span class="type">id</span> &lt;IGListAdapterDataSource&gt; dataSource;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 某些对象将要显示或者已经显示完毕后的通知</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">nullable</span>, <span class="keyword">weak</span>) <span class="type">id</span> &lt;IGListAdapterDelegate&gt; delegate;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 接受UICollectionView 代理事件的delegate</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">nullable</span>, <span class="keyword">weak</span>) <span class="type">id</span> &lt;<span class="built_in">UICollectionViewDelegate</span>&gt; collectionViewDelegate;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 接受UIScrollView代理事件的delegate</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">nullable</span>, <span class="keyword">weak</span>) <span class="type">id</span> &lt;<span class="built_in">UIScrollViewDelegate</span>&gt; scrollViewDelegate;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 重排session代理事件的delegate</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">nullable</span>, <span class="keyword">weak</span>) <span class="type">id</span> &lt;IGListAdapterMoveDelegate&gt; moveDelegate <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">9</span>_0);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 用于性能检测点的的delegate</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">nullable</span>, <span class="keyword">weak</span>) <span class="type">id</span> &lt;IGListAdapterPerformanceDelegate&gt; performanceDelegate;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> Adapter的更新器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="type">id</span> &lt;IGListUpdatingDelegate&gt; updater;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 对象与SessionController的映射关系</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) IGListSectionMap *sectionMap;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 显示cell的管理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) IGListDisplayHandler *displayHandler;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 用于可见范围的管理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) IGListWorkingRangeHandler *workingRangeHandler;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 负责代理事件的分发</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">nullable</span>) IGListAdapterProxy *delegateProxy;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 空视图界面</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">nullable</span>) <span class="built_in">UIView</span> *emptyBackgroundView;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 用于注册Cell</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableSet</span>&lt;<span class="built_in">NSString</span> *&gt; *registeredCellIdentifiers;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableSet</span>&lt;<span class="built_in">NSString</span> *&gt; *registeredNibNames;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableSet</span>&lt;<span class="built_in">NSString</span> *&gt; *registeredSupplementaryViewIdentifiers;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableSet</span>&lt;<span class="built_in">NSString</span> *&gt; *registeredSupplementaryViewNibNames;</span><br></pre></td></tr></table></figure>

<p>上面列出了比较重要的组件，但是从整体功能上看最主要的组件包括：</p>
<p><strong><strong>UICollectionView</strong></strong>:UICollectionView是整个列表的界面承载实体<br><strong><strong>IGListAdapterDataSource</strong></strong>:IGListAdapterDataSource为整个IGListAdapter提供数据对象，并且指定每个session对应的sessionController,以及空数据时候的界面<br><strong><strong>IGListUpdatingDelegate</strong></strong>:用于将数据加载到UICollectionView<br>****IGListAdapterDelegate&#x2F;UICollectionViewDelegate&#x2F;UIScrollViewDelegate&#x2F;****：提供事件处理代理方法<br><strong><strong>IGListAdapterProxy</strong></strong>:负责事件分发<br><strong><strong>IGListSectionMap</strong></strong>:维护数据集与sessionController的映射关系<br><strong><strong>IGListDisplayHandler</strong></strong>:负责可见对象的控制，这些可见对象存储于visibleViewObjectMap<br><strong><strong>IGListWorkingRangeHandler</strong></strong>:负责工作区的管理<br><strong><strong>IGListAdapterMoveDelegate&#x2F;IGListAdapterPerformanceDelegate</strong></strong>：移动sessionController以及性能检测埋点的代理</p>
<p>我们看下 <strong><strong>IGListAdapter</strong></strong> 的初始化阶段：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)initWithUpdater:(<span class="type">id</span> &lt;IGListUpdatingDelegate&gt;)updater</span><br><span class="line">                 viewController:(<span class="built_in">UIViewController</span> *)viewController</span><br><span class="line">               workingRangeSize:(<span class="built_in">NSInteger</span>)workingRangeSize &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//........</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="variable language_">super</span> init]) &#123; </span><br><span class="line">        <span class="comment">//初始化重要组件</span></span><br><span class="line">        <span class="built_in">NSPointerFunctions</span> *keyFunctions = [updater objectLookupPointerFunctions];</span><br><span class="line">        <span class="built_in">NSPointerFunctions</span> *valueFunctions = [<span class="built_in">NSPointerFunctions</span> pointerFunctionsWithOptions:<span class="built_in">NSPointerFunctionsStrongMemory</span>];</span><br><span class="line">        <span class="built_in">NSMapTable</span> *table = [[<span class="built_in">NSMapTable</span> alloc] initWithKeyPointerFunctions:keyFunctions valuePointerFunctions:valueFunctions capacity:<span class="number">0</span>];</span><br><span class="line">        _sectionMap = [[IGListSectionMap alloc] initWithMapTable:table];</span><br><span class="line">        _displayHandler = [IGListDisplayHandler new];</span><br><span class="line">        _workingRangeHandler = [[IGListWorkingRangeHandler alloc] initWithWorkingRangeSize:workingRangeSize];</span><br><span class="line">        _updateListeners = [<span class="built_in">NSHashTable</span> weakObjectsHashTable];</span><br><span class="line">        _viewSectionControllerMap = [<span class="built_in">NSMapTable</span> mapTableWithKeyOptions:<span class="built_in">NSMapTableObjectPointerPersonality</span> | <span class="built_in">NSMapTableStrongMemory</span></span><br><span class="line">                                                          valueOptions:<span class="built_in">NSMapTableStrongMemory</span>];</span><br><span class="line">        _updater = updater;</span><br><span class="line">        _viewController = viewController;</span><br><span class="line">        [IGListDebugger trackAdapter:<span class="keyword">self</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化任务中完成了大部分重要组件的初始化，上面已经介绍了这些组件的功能，这里就不重复介绍了。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)setCollectionView:(<span class="built_in">UICollectionView</span> *)collectionView &#123;</span><br><span class="line">    <span class="comment">// 如果collectionView 被用于另一个adapter，那么我们需要对它进行重置，断开与之前adapter之间的关联，避免会被之前对adapter错误更新。</span></span><br><span class="line">    <span class="keyword">if</span> (_collectionView != collectionView || _collectionView.dataSource != <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="comment">//每个UICollectionView 都对应一个 IGListAdapter，globalCollectionViewAdapterMap 里面存放的是之间的对应关系</span></span><br><span class="line">        <span class="keyword">static</span> <span class="built_in">NSMapTable</span>&lt;<span class="built_in">UICollectionView</span> *, IGListAdapter *&gt; *globalCollectionViewAdapterMap = <span class="literal">nil</span>;</span><br><span class="line">        <span class="keyword">if</span> (globalCollectionViewAdapterMap == <span class="literal">nil</span>) &#123;</span><br><span class="line">            globalCollectionViewAdapterMap = [<span class="built_in">NSMapTable</span> weakToWeakObjectsMapTable];</span><br><span class="line">        &#125;</span><br><span class="line">        [globalCollectionViewAdapterMap removeObjectForKey:_collectionView];</span><br><span class="line">        [[globalCollectionViewAdapterMap objectForKey:collectionView] setCollectionView:<span class="literal">nil</span>];</span><br><span class="line">        [globalCollectionViewAdapterMap setObject:<span class="keyword">self</span> forKey:collectionView];</span><br><span class="line">        <span class="comment">//globalCollectionViewAdapterMap ---&gt; key:UICollectionView  value:IGListAdapter</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//注册cell之类的名字</span></span><br><span class="line">        _registeredCellIdentifiers = [<span class="built_in">NSMutableSet</span> new];</span><br><span class="line">        _registeredNibNames = [<span class="built_in">NSMutableSet</span> new];</span><br><span class="line">        _registeredSupplementaryViewIdentifiers = [<span class="built_in">NSMutableSet</span> new];</span><br><span class="line">        _registeredSupplementaryViewNibNames = [<span class="built_in">NSMutableSet</span> new];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">const</span> <span class="type">BOOL</span> settingFirstCollectionView = _collectionView == <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//持有collectionView，并将adapter作为它的数据源</span></span><br><span class="line">        _collectionView = collectionView;</span><br><span class="line">        _collectionView.dataSource = <span class="keyword">self</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//.....</span></span><br><span class="line">        <span class="comment">//将adapter保存到collectionViewLayout</span></span><br><span class="line">        [_collectionView.collectionViewLayout ig_hijackLayoutInteractiveReorderingMethodForAdapter:<span class="keyword">self</span>];</span><br><span class="line">        [_collectionView.collectionViewLayout invalidateLayout];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//CollectionViewDelegate 要么设置为 delegateProxy 要么设置为adapter</span></span><br><span class="line">        [<span class="keyword">self</span> _updateCollectionViewDelegate];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// only construct</span></span><br><span class="line">        <span class="keyword">if</span> (!IGListExperimentEnabled(<span class="keyword">self</span>.experiments, IGListExperimentGetCollectionViewAtUpdate)</span><br><span class="line">            || settingFirstCollectionView) &#123;</span><br><span class="line">            [<span class="keyword">self</span> _updateAfterPublicSettingsChange];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)_updateCollectionViewDelegate &#123;</span><br><span class="line">    _collectionView.delegate = (<span class="type">id</span>&lt;<span class="built_in">UICollectionViewDelegate</span>&gt;)<span class="keyword">self</span>.delegateProxy ?: <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>为IGListAdapter设置collectionView的时候要注意如果globalCollectionViewAdapterMap中已经存在了一个映射关系，需要重新移除后添加，之后为collectionView重新设置当前的Adapter作为新的dataSource，以及delegateProxy的设置，对于第一次创建的时候还需要调用_updateAfterPublicSettingsChange从datasource中取出属于当前adapter的数据，进行相关的更新。这部分在接下来的设置数据源也会涉及，我们就来看下数据源的设置：</p>
<p><strong><strong>IGListAdapter数据源的设置</strong></strong></p>
<figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line">- (void)setDataSource:(id&lt;IGListAdapterDataSource&gt;)dataSource &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">_dataSource</span> != dataSource) &#123;</span><br><span class="line">        <span class="variable">_dataSource</span> = dataSource;</span><br><span class="line">        <span class="comment">//数据源改变的时候会剔除重复数据后更新数据</span></span><br><span class="line">        [self <span class="variable">_updateAfterPublicSettingsChange</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)<span class="variable">_updateAfterPublicSettingsChange</span> &#123;</span><br><span class="line">    id&lt;IGListAdapterDataSource&gt; dataSource = <span class="variable">_dataSource</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">_collectionView</span> != <span class="literal">nil</span> &amp;&amp; dataSource != <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="comment">//去除当前Adapter中重复的元素</span></span><br><span class="line">        NSArray *uniqueObjects = objectsWithDuplicateIdentifiersRemoved([dataSource objectsForListAdapter:self]);</span><br><span class="line">        <span class="comment">//更新数据源</span></span><br><span class="line">        [self <span class="variable">_updateObjects</span>:uniqueObjects dataSource:dataSource];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里会通过[dataSource objectsForListAdapter:self]，取出属于该adapter的数据对象。然后通过objectsWithDuplicateIdentifiersRemoved剔除掉重复的数据后，通过_updateObjects更新adapter中的其他模块数据，我们重点看下这个部分：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)_updateObjects:(<span class="built_in">NSArray</span> *)objects dataSource:(<span class="type">id</span>&lt;IGListAdapterDataSource&gt;)dataSource &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//.......</span></span><br><span class="line">    <span class="built_in">NSMutableArray</span>&lt;IGListSectionController *&gt; *sectionControllers = [<span class="built_in">NSMutableArray</span> new];</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *validObjects = [<span class="built_in">NSMutableArray</span> new];</span><br><span class="line"></span><br><span class="line">    IGListSectionMap *map = <span class="keyword">self</span>.sectionMap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// collect items that have changed since the last update</span></span><br><span class="line">    <span class="built_in">NSMutableSet</span> *updatedObjects = [<span class="built_in">NSMutableSet</span> new];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历从数据源获取到的每个数据,注意这里的object其实是一个数据集，每个数据集针对一个sessionController</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">id</span> object <span class="keyword">in</span> objects) &#123;</span><br><span class="line">        <span class="comment">// 查看是否之前已经创建了sectionController，如果有就直接使用</span></span><br><span class="line">        IGListSectionController *sectionController = [map sectionControllerForObject:object];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果之前没有我们就询问dataSource返回一个指定数据集对应的sessionController</span></span><br><span class="line">        <span class="keyword">if</span> (sectionController == <span class="literal">nil</span>) &#123;</span><br><span class="line">            sectionController = [dataSource listAdapter:<span class="keyword">self</span> sectionControllerForObject:object];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果再没有直接报错</span></span><br><span class="line">        <span class="keyword">if</span> (sectionController == <span class="literal">nil</span>) &#123;</span><br><span class="line">            IGLKLog(<span class="string">@&quot;WARNING: Ignoring nil section controller returned by data source %@ for object %@.&quot;</span>,</span><br><span class="line">                    dataSource, object);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将一些环境变量赋给sectionController，比如将当前的adapter作为collectionContext赋给sectionController</span></span><br><span class="line">        sectionController.collectionContext = <span class="keyword">self</span>;</span><br><span class="line">        sectionController.viewController = <span class="keyword">self</span>.viewController;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查当前的对象是全新的还是对已经有的对象进行更新</span></span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">NSInteger</span> oldSection = [map sectionForObject:object];</span><br><span class="line">        <span class="keyword">if</span> (oldSection == <span class="built_in">NSNotFound</span> || [map objectForSection:oldSection] != object) &#123;</span><br><span class="line">            <span class="comment">//更新的对象</span></span><br><span class="line">            [updatedObjects addObject:object];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//将结果记录到sectionControllers 与 validObjects</span></span><br><span class="line">        [sectionControllers addObject:sectionController];</span><br><span class="line">        [validObjects addObject:object];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// clear the view controller and collection context</span></span><br><span class="line">    IGListSectionControllerPopThread();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//更新到IGListSectionMap IGListSectionMap用于维护object 与sessionController的之间的关系</span></span><br><span class="line">    [map updateWithObjects:validObjects sectionControllers:sectionControllers];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// object 与 sessionController之间的关系已经建立，这时候可以认为sessionController已经加载完毕，加载完成后sessionController会收到didUpdateToObject的通知</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">id</span> object <span class="keyword">in</span> updatedObjects) &#123;</span><br><span class="line">        [[map sectionControllerForObject:object] didUpdateToObject:object];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算总数量</span></span><br><span class="line">    <span class="built_in">NSInteger</span> itemCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (IGListSectionController *sectionController <span class="keyword">in</span> sectionControllers) &#123;</span><br><span class="line">        itemCount += [sectionController numberOfItems];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据总数量决定显示空界面还是正常的UICollectionView</span></span><br><span class="line">    [<span class="keyword">self</span> _updateBackgroundViewShouldHide:itemCount &gt; <span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)_updateBackgroundViewShouldHide:(<span class="type">BOOL</span>)shouldHide &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果还在更新那么先返回,在update block执行结束之后还会调用</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.isInUpdateBlock) &#123;</span><br><span class="line">        <span class="keyword">return</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据itemCount数量决定是否显示空白页面</span></span><br><span class="line">    <span class="built_in">UIView</span> *backgroundView = [<span class="keyword">self</span>.dataSource emptyViewForListAdapter:<span class="keyword">self</span>];</span><br><span class="line">    <span class="comment">// don&#x27;t do anything if the client is using the same view</span></span><br><span class="line">    <span class="keyword">if</span> (backgroundView != _collectionView.backgroundView) &#123;</span><br><span class="line">        <span class="comment">// collection view will just stack the background views underneath each other if we do not remove the previous</span></span><br><span class="line">        <span class="comment">// one first. also fine if it is nil</span></span><br><span class="line">        [_collectionView.backgroundView removeFromSuperview];</span><br><span class="line">        _collectionView.backgroundView = backgroundView;</span><br><span class="line">    &#125;</span><br><span class="line">    _collectionView.backgroundView.hidden = shouldHide;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们上面传入_updateObjects的objects是整个adapter所对应的数据集的数组，那么在_updateObjects中首先需要遍历数组中的每个数据集，我们知道object与sessionController的对应关系存在于两个地方IGListSectionMap以及IGListAdapter。首先我们会从IGListSectionMap中去检查是否有缓存了这种关系，如果没有再从IGListAdapter去获取。拿到之后再更新到IGListSectionMap以供下次使用。对于数据有变动的情况还会调用sessionController的didUpdateToObject方法。最后计算整个adapter的数据总数，如果数据总数为0那么会调用emptyViewForListAdapter获取空界面进行展示。</p>
<p><strong><strong>IGListAdapter代理设置</strong></strong></p>
<figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line">- (void)setCollectionViewDelegate:(id&lt;UICollectionViewDelegate&gt;)collectionViewDelegate &#123;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">    <span class="comment">//_collectionViewDelegate 这个会传递到IGListAdapterProxy</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">_collectionViewDelegate</span> != collectionViewDelegate) &#123;</span><br><span class="line">        <span class="variable">_collectionViewDelegate</span> = collectionViewDelegate;</span><br><span class="line">        <span class="comment">//创建IGListAdapterProxy并设置为delegate</span></span><br><span class="line">        [self <span class="variable">_createProxyAndUpdateCollectionViewDelegate</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setScrollViewDelegate:(id&lt;UIScrollViewDelegate&gt;)scrollViewDelegate &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">_scrollViewDelegate</span> != scrollViewDelegate) &#123;</span><br><span class="line">        <span class="variable">_scrollViewDelegate</span> = scrollViewDelegate;</span><br><span class="line">        <span class="comment">//_scrollViewDelegate 这个会传递到IGListAdapterProxy</span></span><br><span class="line">        [self <span class="variable">_createProxyAndUpdateCollectionViewDelegate</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)<span class="variable">_createProxyAndUpdateCollectionViewDelegate</span> &#123;</span><br><span class="line">    <span class="variable">_collectionView</span>.delegate = <span class="literal">nil</span>;</span><br><span class="line">    self.delegateProxy = [[IGListAdapterProxy alloc] initWithCollectionViewTarget:<span class="variable">_collectionViewDelegate</span></span><br><span class="line">                                                                 scrollViewTarget:<span class="variable">_scrollViewDelegate</span></span><br><span class="line">                                                                      interceptor:self];</span><br><span class="line">    [self <span class="variable">_updateCollectionViewDelegate</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面代码看IGListAdapterProxy接受三个对象_collectionViewDelegate，_scrollViewDelegate以及adapter。然后再将IGListAdapterProxy作为collectionView的delegate。这样做的好处是可以通过IGListAdapterProxy进行统一管理，IGListAdapterProxy负责这些代理事件的集中分发。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">BOOL</span>)respondsToSelector:(SEL)aSelector &#123;</span><br><span class="line">    <span class="keyword">return</span> isInterceptedSelector(aSelector)</span><br><span class="line">    || [_collectionViewTarget respondsToSelector:aSelector]</span><br><span class="line">    || [_scrollViewTarget respondsToSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">id</span>)forwardingTargetForSelector:(SEL)aSelector &#123;</span><br><span class="line">    <span class="keyword">if</span> (isInterceptedSelector(aSelector)) &#123;</span><br><span class="line">        <span class="keyword">return</span> _interceptor;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [_scrollViewTarget respondsToSelector:aSelector] ? _scrollViewTarget : _collectionViewTarget;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)invocation &#123;</span><br><span class="line">    <span class="type">void</span> *nullPointer = <span class="literal">NULL</span>;</span><br><span class="line">    [invocation setReturnValue:&amp;nullPointer];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)selector &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSObject</span> instanceMethodSignatureForSelector:<span class="keyword">@selector</span>(init)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在IGListAdapterProxy中会对这些代理方法进行拦截，如果在拦截清单内的话会将这些代理方法转到_interceptor也就是adapter，其他的则会根据_scrollViewTarget以及_collectionViewTarget是否有响应的方法来确定转发给谁,下面是拦截的方法：</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">static</span> <span class="selector-tag">BOOL</span> <span class="selector-tag">isInterceptedSelector</span>(SEL sel) &#123;</span><br><span class="line">    <span class="selector-tag">return</span> (</span><br><span class="line">            <span class="comment">// UIScrollViewDelegate</span></span><br><span class="line">            sel == <span class="variable">@selector</span>(<span class="attribute">scrollViewDidScroll</span>:) ||</span><br><span class="line">            sel == <span class="variable">@selector</span>(<span class="attribute">scrollViewWillBeginDragging</span>:) ||</span><br><span class="line">            sel == <span class="variable">@selector</span>(<span class="attribute">scrollViewDidEndDragging</span>:<span class="attribute">willDecelerate</span>:) ||</span><br><span class="line">            sel == <span class="variable">@selector</span>(<span class="attribute">scrollViewDidEndDecelerating</span>:) ||</span><br><span class="line">            <span class="comment">// UICollectionViewDelegate</span></span><br><span class="line">            sel == <span class="variable">@selector</span>(<span class="attribute">collectionView</span>:<span class="attribute">willDisplayCell</span>:<span class="attribute">forItemAtIndexPath</span>:) ||</span><br><span class="line">            sel == <span class="variable">@selector</span>(<span class="attribute">collectionView</span>:<span class="attribute">didEndDisplayingCell</span>:<span class="attribute">forItemAtIndexPath</span>:) ||</span><br><span class="line">            sel == <span class="variable">@selector</span>(<span class="attribute">collectionView</span>:<span class="attribute">didSelectItemAtIndexPath</span>:) ||</span><br><span class="line">            sel == <span class="variable">@selector</span>(<span class="attribute">collectionView</span>:<span class="attribute">didDeselectItemAtIndexPath</span>:) ||</span><br><span class="line">            sel == <span class="variable">@selector</span>(<span class="attribute">collectionView</span>:<span class="attribute">didHighlightItemAtIndexPath</span>:) ||</span><br><span class="line">            sel == <span class="variable">@selector</span>(<span class="attribute">collectionView</span>:<span class="attribute">didUnhighlightItemAtIndexPath</span>:) ||</span><br><span class="line">            <span class="comment">// UICollectionViewDelegateFlowLayout</span></span><br><span class="line">            sel == <span class="variable">@selector</span>(<span class="attribute">collectionView</span>:<span class="attribute">layout</span>:<span class="attribute">sizeForItemAtIndexPath</span>:) ||</span><br><span class="line">            sel == <span class="variable">@selector</span>(<span class="attribute">collectionView</span>:<span class="attribute">layout</span>:<span class="attribute">insetForSectionAtIndex</span>:) ||</span><br><span class="line">            sel == <span class="variable">@selector</span>(<span class="attribute">collectionView</span>:<span class="attribute">layout</span>:<span class="attribute">minimumInteritemSpacingForSectionAtIndex</span>:) ||</span><br><span class="line">            sel == <span class="variable">@selector</span>(<span class="attribute">collectionView</span>:<span class="attribute">layout</span>:<span class="attribute">minimumLineSpacingForSectionAtIndex</span>:) ||</span><br><span class="line">            sel == <span class="variable">@selector</span>(<span class="attribute">collectionView</span>:<span class="attribute">layout</span>:<span class="attribute">referenceSizeForFooterInSection</span>:) ||</span><br><span class="line">            sel == <span class="variable">@selector</span>(<span class="attribute">collectionView</span>:<span class="attribute">layout</span>:<span class="attribute">referenceSizeForHeaderInSection</span>:) ||</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// IGListCollectionViewDelegateLayout</span></span><br><span class="line">            sel == <span class="variable">@selector</span>(<span class="attribute">collectionView</span>:<span class="attribute">layout</span>:<span class="attribute">customizedInitialLayoutAttributes</span>:<span class="attribute">atIndexPath</span>:) ||</span><br><span class="line">            sel == <span class="variable">@selector</span>(<span class="attribute">collectionView</span>:<span class="attribute">layout</span>:<span class="attribute">customizedFinalLayoutAttributes</span>:<span class="attribute">atIndexPath</span>:)</span><br><span class="line">            );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><strong>Object &amp;&amp; sessionController 之间的映射关系</strong></strong></p>
<p>目前在IGListKit可以完成如下几种对象之间的映射关系：</p>
<figure class="highlight brainfuck"><table><tr><td class="code"><pre><span class="line"><span class="comment">* indexPath</span> &lt;<span class="literal">--</span><span class="comment">indexPath</span><span class="string">.</span><span class="comment">section</span><span class="literal">--</span>&gt; <span class="comment">section</span> &lt;<span class="literal">---</span><span class="comment">sectionControllerForSection/sectionForSectionController</span><span class="literal">---</span>&gt; <span class="comment">IGListSectionController</span> &lt;<span class="literal">--</span><span class="comment">sectionControllerForObject/objectForSection</span><span class="literal">--</span>&gt;<span class="comment">object</span></span><br><span class="line"></span><br><span class="line"><span class="comment">* indexPath</span> <span class="literal">--</span><span class="comment">sectionControllerForSection</span><span class="literal">--</span><span class="comment">supplementaryViewSource</span><span class="literal">--</span>&gt; <span class="comment">IGListSupplementaryViewSource</span></span><br></pre></td></tr></table></figure>

<p>这部分代码就不贴出来了，最底层逻辑在sectionMap上，大家可以查看对应的源码。</p>
<p><strong><strong>可见性通知</strong></strong></p>
<p>这部分主要涉及<strong><strong>IGListDisplayDelegate</strong></strong>，<strong><strong>IGListAdapterDelegate</strong></strong>，<strong><strong>IGListDisplayHandler</strong></strong>这三个类，我们可以指定IGListAdapter的delegate来监听可见性情况：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">IGListAdapterDelegate</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 通知delegate某个数据集即将显示</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="type">void</span>)listAdapter:(IGListAdapter *)listAdapter willDisplayObject:(<span class="type">id</span>)object atIndex:(<span class="built_in">NSInteger</span>)index;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 通知delegate某个数据集合将不在显示范围内</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="type">void</span>)listAdapter:(IGListAdapter *)listAdapter didEndDisplayingObject:(<span class="type">id</span>)object atIndex:(<span class="built_in">NSInteger</span>)index;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>IGListAdapterDelegate其实和IGListDisplayDelegate是一样的，只不过一个是在adapter上层监听，一个是在sessionController监听。IGListDisplayDelegate其实监听的是更细粒度的可以通过代理知道具体哪个cell进入可见区域，我们在看下IGListDisplayDelegate：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">IGListDisplayDelegate</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">指定的sessionController进入到可见区域</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="type">void</span>)listAdapter:(IGListAdapter *)listAdapter willDisplaySectionController:(IGListSectionController *)sectionController;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">指定的sessionController离开可见区域</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="type">void</span>)listAdapter:(IGListAdapter *)listAdapter didEndDisplayingSectionController:(IGListSectionController *)sectionController;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">在某个sessionController的某个cell进入到可见区域</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="type">void</span>)listAdapter:(IGListAdapter *)listAdapter willDisplaySectionController:(IGListSectionController *)sectionController</span><br><span class="line">               cell:(<span class="built_in">UICollectionViewCell</span> *)cell</span><br><span class="line">            atIndex:(<span class="built_in">NSInteger</span>)index;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">某个sessionController的某个cell离开可见区域</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="type">void</span>)listAdapter:(IGListAdapter *)listAdapter didEndDisplayingSectionController:(IGListSectionController *)sectionController</span><br><span class="line">               cell:(<span class="built_in">UICollectionViewCell</span> *)cell</span><br><span class="line">            atIndex:(<span class="built_in">NSInteger</span>)index;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>IGListAdapterDelegate和IGListDisplayDelegate对应的方法是在IGListDisplayHandler中被调用的。IGListDisplayHandler中维护着一份visibleListSections以及visibleViewObjectMap；visibleListSections里面存储着当前可见的sessionController,visibleViewObjectMap里面存储的是数据对象以及CellView的映射关系。在sessionController进入离开可见区域的时候都会维护这两个对象里面的内容，并且通知adapter以及sessionController中的对应delegate。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)_willDisplayReusableView:(<span class="built_in">UICollectionReusableView</span> *)view</span><br><span class="line">                 forListAdapter:(IGListAdapter *)listAdapter</span><br><span class="line">              sectionController:(IGListSectionController *)sectionController</span><br><span class="line">                         object:(<span class="type">id</span>)object</span><br><span class="line">                      indexPath:(<span class="built_in">NSIndexPath</span> *)indexPath &#123;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">    <span class="comment">//self.visibleViewObjectMap 中存储的是数据对象以及CellView</span></span><br><span class="line">    [<span class="keyword">self</span>.visibleViewObjectMap setObject:object forKey:view];</span><br><span class="line">    <span class="comment">//可见的session部分</span></span><br><span class="line">    <span class="built_in">NSCountedSet</span> *visibleListSections = <span class="keyword">self</span>.visibleListSections;</span><br><span class="line">    <span class="keyword">if</span> ([visibleListSections countForObject:sectionController] == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/*如果当前的sectionController没有在可见session列表中则触发通知给sectionController以及listAdapter*/</span></span><br><span class="line">        [sectionController.displayDelegate listAdapter:listAdapter willDisplaySectionController:sectionController];</span><br><span class="line">        [listAdapter.delegate listAdapter:listAdapter willDisplayObject:object atIndex:indexPath.section];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将当前的sectionController添加到visibleListSections 避免重复通知</span></span><br><span class="line">    [visibleListSections addObject:sectionController];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)_didEndDisplayingReusableView:(<span class="built_in">UICollectionReusableView</span> *)view</span><br><span class="line">                      forListAdapter:(IGListAdapter *)listAdapter</span><br><span class="line">                   sectionController:(IGListSectionController *)sectionController</span><br><span class="line">                              object:(<span class="type">id</span>)object</span><br><span class="line">                           indexPath:(<span class="built_in">NSIndexPath</span> *)indexPath &#123;</span><br><span class="line">    IGParameterAssert(view != <span class="literal">nil</span>);</span><br><span class="line">    IGParameterAssert(listAdapter != <span class="literal">nil</span>);</span><br><span class="line">    IGParameterAssert(indexPath != <span class="literal">nil</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (object == <span class="literal">nil</span> || sectionController == <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">NSInteger</span> section = indexPath.section;</span><br><span class="line">    <span class="comment">//移除sectionController并通知sectionController以及listAdapter</span></span><br><span class="line">    <span class="built_in">NSCountedSet</span> *visibleSections = <span class="keyword">self</span>.visibleListSections;</span><br><span class="line">    [visibleSections removeObject:sectionController];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ([visibleSections countForObject:sectionController] == <span class="number">0</span>) &#123;</span><br><span class="line">        [sectionController.displayDelegate listAdapter:listAdapter didEndDisplayingSectionController:sectionController];</span><br><span class="line">        [listAdapter.delegate listAdapter:listAdapter didEndDisplayingObject:object atIndex:section];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么IGListDisplayHandler这些方法是谁触发的呢？嗯，是Adapter触发的，我们上面介绍IGListAdapterProxy的时候讲到Adapter会拦截部分的代理方法，在这部分代理方法中就可以调用IGListDisplayHandler发出通知。这部分代码在<strong><strong>IGListAdapter+UICollectionView</strong></strong>,这里面包括了可见区域的通知，以及工作区相关的处理。由于同时需要注意的是由于在IGListAdapterProxy会对这部分代理方法进行拦截，所以这里还需要将事件通知到collectionViewDelegate</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="operator">-</span> (void)collectionView:(<span class="type">UICollectionView</span> <span class="operator">*</span>)collectionView willDisplayCell:(<span class="type">UICollectionViewCell</span> <span class="operator">*</span>)cell forItemAtIndexPath:(<span class="type">NSIndexPath</span> <span class="operator">*</span>)indexPath &#123;</span><br><span class="line">    id<span class="operator">&lt;</span><span class="type">IGListAdapterPerformanceDelegate</span><span class="operator">&gt;</span> performanceDelegate <span class="operator">=</span> <span class="keyword">self</span>.performanceDelegate;</span><br><span class="line">    [performanceDelegate listAdapterWillCallDisplayCell:<span class="keyword">self</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 由于在IGListAdapterProxy会对这部分请求进行拦截，所以这里还需要将事件通知到collectionViewDelegate</span></span><br><span class="line">    id<span class="operator">&lt;</span><span class="type">UICollectionViewDelegate</span><span class="operator">&gt;</span> collectionViewDelegate <span class="operator">=</span> <span class="keyword">self</span>.collectionViewDelegate;</span><br><span class="line">    <span class="keyword">if</span> ([collectionViewDelegate respondsToSelector:<span class="meta">@selector</span>(collectionView:willDisplayCell:forItemAtIndexPath:)]) &#123;</span><br><span class="line">        [collectionViewDelegate collectionView:collectionView willDisplayCell:cell forItemAtIndexPath:indexPath];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取到sessionController</span></span><br><span class="line">    <span class="type">IGListSectionController</span> <span class="operator">*</span>sectionController <span class="operator">=</span> [<span class="keyword">self</span> sectionControllerForView:cell];</span><br><span class="line">    <span class="comment">// if the section controller relationship was destroyed, reconnect it</span></span><br><span class="line">    <span class="comment">// this happens with iOS 10 UICollectionView display range changes</span></span><br><span class="line">    <span class="keyword">if</span> (sectionController <span class="operator">==</span> <span class="literal">nil</span>) &#123;</span><br><span class="line">        sectionController <span class="operator">=</span> [<span class="keyword">self</span> sectionControllerForSection:indexPath.section];</span><br><span class="line">        <span class="comment">//这里为了建立cell与sessionController之间的关系，供sectionControllerForView使用</span></span><br><span class="line">        [<span class="keyword">self</span> mapView:cell toSectionController:sectionController];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//取出当前sessionController对应的数据集</span></span><br><span class="line">    id object <span class="operator">=</span> [<span class="keyword">self</span>.sectionMap objectForSection:indexPath.section];</span><br><span class="line">    <span class="comment">//通知对应的delegate</span></span><br><span class="line">    [<span class="keyword">self</span>.displayHandler willDisplayCell:cell forListAdapter:<span class="keyword">self</span> sectionController:sectionController object:object indexPath:indexPath];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//工作区相关更新</span></span><br><span class="line">    _isSendingWorkingRangeDisplayUpdates <span class="operator">=</span> <span class="type">YES</span>;</span><br><span class="line">    [<span class="keyword">self</span>.workingRangeHandler willDisplayItemAtIndexPath:indexPath forListAdapter:<span class="keyword">self</span>];</span><br><span class="line">    _isSendingWorkingRangeDisplayUpdates <span class="operator">=</span> <span class="type">NO</span>;</span><br><span class="line"></span><br><span class="line">    [performanceDelegate listAdapter:<span class="keyword">self</span> didCallDisplayCell:cell onSectionController:sectionController atIndex:indexPath.item];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="operator">-</span> (void)collectionView:(<span class="type">UICollectionView</span> <span class="operator">*</span>)collectionView didEndDisplayingCell:(<span class="type">UICollectionViewCell</span> <span class="operator">*</span>)cell forItemAtIndexPath:(<span class="type">NSIndexPath</span> <span class="operator">*</span>)indexPath &#123;</span><br><span class="line">    id<span class="operator">&lt;</span><span class="type">IGListAdapterPerformanceDelegate</span><span class="operator">&gt;</span> performanceDelegate <span class="operator">=</span> <span class="keyword">self</span>.performanceDelegate;</span><br><span class="line">    [performanceDelegate listAdapterWillCallEndDisplayCell:<span class="keyword">self</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 由于在IGListAdapterProxy会对这部分请求进行拦截，所以这里还需要将事件通知到collectionViewDelegate</span></span><br><span class="line">    id<span class="operator">&lt;</span><span class="type">UICollectionViewDelegate</span><span class="operator">&gt;</span> collectionViewDelegate <span class="operator">=</span> <span class="keyword">self</span>.collectionViewDelegate;</span><br><span class="line">    <span class="keyword">if</span> ([collectionViewDelegate respondsToSelector:<span class="meta">@selector</span>(collectionView:didEndDisplayingCell:forItemAtIndexPath:)]) &#123;</span><br><span class="line">        [collectionViewDelegate collectionView:collectionView didEndDisplayingCell:cell forItemAtIndexPath:indexPath];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取到sessionController</span></span><br><span class="line">    <span class="type">IGListSectionController</span> <span class="operator">*</span>sectionController <span class="operator">=</span> [<span class="keyword">self</span> sectionControllerForView:cell];</span><br><span class="line">    <span class="comment">//通知对应的delegate</span></span><br><span class="line">    [<span class="keyword">self</span>.displayHandler didEndDisplayingCell:cell forListAdapter:<span class="keyword">self</span> sectionController:sectionController indexPath:indexPath];</span><br><span class="line">    <span class="comment">//工作区相关更新</span></span><br><span class="line">    [<span class="keyword">self</span>.workingRangeHandler didEndDisplayingItemAtIndexPath:indexPath forListAdapter:<span class="keyword">self</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// break the association between the cell and the section controller</span></span><br><span class="line">    [<span class="keyword">self</span> removeMapForView:cell];</span><br><span class="line"></span><br><span class="line">    [performanceDelegate listAdapter:<span class="keyword">self</span> didCallEndDisplayCell:cell onSectionController:sectionController atIndex:indexPath.item];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="operator">-</span> (void)collectionView:(<span class="type">UICollectionView</span> <span class="operator">*</span>)collectionView willDisplaySupplementaryView:(<span class="type">UICollectionReusableView</span> <span class="operator">*</span>)view forElementKind:(<span class="type">NSString</span> <span class="operator">*</span>)elementKind atIndexPath:(<span class="type">NSIndexPath</span> <span class="operator">*</span>)indexPath &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 由于在IGListAdapterProxy会对这部分请求进行拦截，所以这里还需要将事件通知到collectionViewDelegate</span></span><br><span class="line">    id<span class="operator">&lt;</span><span class="type">UICollectionViewDelegate</span><span class="operator">&gt;</span> collectionViewDelegate <span class="operator">=</span> <span class="keyword">self</span>.collectionViewDelegate;</span><br><span class="line">    <span class="keyword">if</span> ([collectionViewDelegate respondsToSelector:<span class="meta">@selector</span>(collectionView:willDisplaySupplementaryView:forElementKind:atIndexPath:)]) &#123;</span><br><span class="line">        [collectionViewDelegate collectionView:collectionView willDisplaySupplementaryView:view forElementKind:elementKind atIndexPath:indexPath];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">IGListSectionController</span> <span class="operator">*</span>sectionController <span class="operator">=</span> [<span class="keyword">self</span> sectionControllerForView:view];</span><br><span class="line">    <span class="comment">// if the section controller relationship was destroyed, reconnect it</span></span><br><span class="line">    <span class="comment">// this happens with iOS 10 UICollectionView display range changes</span></span><br><span class="line">    <span class="keyword">if</span> (sectionController <span class="operator">==</span> <span class="literal">nil</span>) &#123;</span><br><span class="line">        sectionController <span class="operator">=</span> [<span class="keyword">self</span>.sectionMap sectionControllerForSection:indexPath.section];</span><br><span class="line">        [<span class="keyword">self</span> mapView:view toSectionController:sectionController];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    id object <span class="operator">=</span> [<span class="keyword">self</span>.sectionMap objectForSection:indexPath.section];</span><br><span class="line">    <span class="comment">//通知对应的delegate</span></span><br><span class="line">    [<span class="keyword">self</span>.displayHandler willDisplaySupplementaryView:view forListAdapter:<span class="keyword">self</span> sectionController:sectionController object:object indexPath:indexPath];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="operator">-</span> (void)collectionView:(<span class="type">UICollectionView</span> <span class="operator">*</span>)collectionView didEndDisplayingSupplementaryView:(<span class="type">UICollectionReusableView</span> <span class="operator">*</span>)view forElementOfKind:(<span class="type">NSString</span> <span class="operator">*</span>)elementKind atIndexPath:(<span class="type">NSIndexPath</span> <span class="operator">*</span>)indexPath &#123;</span><br><span class="line">    <span class="comment">// 由于在IGListAdapterProxy会对这部分请求进行拦截，所以这里还需要将事件通知到collectionViewDelegate</span></span><br><span class="line">    id<span class="operator">&lt;</span><span class="type">UICollectionViewDelegate</span><span class="operator">&gt;</span> collectionViewDelegate <span class="operator">=</span> <span class="keyword">self</span>.collectionViewDelegate;</span><br><span class="line">    <span class="keyword">if</span> ([collectionViewDelegate respondsToSelector:<span class="meta">@selector</span>(collectionView:didEndDisplayingSupplementaryView:forElementOfKind:atIndexPath:)]) &#123;</span><br><span class="line">        [collectionViewDelegate collectionView:collectionView didEndDisplayingSupplementaryView:view forElementOfKind:elementKind atIndexPath:indexPath];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">IGListSectionController</span> <span class="operator">*</span>sectionController <span class="operator">=</span> [<span class="keyword">self</span> sectionControllerForView:view];</span><br><span class="line">    <span class="comment">//通知对应的delegate</span></span><br><span class="line">    [<span class="keyword">self</span>.displayHandler didEndDisplayingSupplementaryView:view forListAdapter:<span class="keyword">self</span> sectionController:sectionController indexPath:indexPath];</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span> removeMapForView:view];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong><strong>工作区管理</strong></strong></p>
<p>对于工作区管理会在进入显示区的时候将当前的indexPath 信息添加到_visibleSectionIndices，退出可视区域的时候从_visibleSectionIndices中删除。然后根据workingRangeSize来确定起始和结束的index，根据确定的起始index和结束index将可见的sessionController添加到workingRangeSectionControllers，再通过新的workingRangeSectionControllers与旧的workingRangeSectionControllers进行对比，如果只出现再新的，而在老的没出现，这时候表示当前的sessionController为新进入工作区的，反之则为退出工作区的。</p>
<figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line">- (void)willDisplayItemAtIndexPath:(NSIndexPath *)indexPath</span><br><span class="line">                    forListAdapter:(IGListAdapter *)listAdapter &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 往_visibleSectionIndices中插入可见的NSIndexPath信息</span></span><br><span class="line">    <span class="variable">_visibleSectionIndices</span>.<span class="built_in">insert</span>(&#123;</span><br><span class="line">        .section = indexPath.section,</span><br><span class="line">        .row = indexPath.row,</span><br><span class="line">        .hash = indexPath.hash</span><br><span class="line">    &#125;);</span><br><span class="line">    [self <span class="variable">_updateWorkingRangesWithListAdapter</span>:listAdapter];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)didEndDisplayingItemAtIndexPath:(NSIndexPath *)indexPath</span><br><span class="line">                         forListAdapter:(IGListAdapter *)listAdapter &#123;</span><br><span class="line">    <span class="comment">//将将要移除到可见范围之外的cell的NSIndexPath从_visibleSectionIndices中移除</span></span><br><span class="line">    <span class="variable">_visibleSectionIndices</span>.erase(&#123;</span><br><span class="line">        .section = indexPath.section,</span><br><span class="line">        .row = indexPath.row,</span><br><span class="line">        .hash = indexPath.hash</span><br><span class="line">    &#125;);</span><br><span class="line">    [self <span class="variable">_updateWorkingRangesWithListAdapter</span>:listAdapter];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - Working Ranges</span></span><br><span class="line"></span><br><span class="line">- (void)<span class="variable">_updateWorkingRangesWithListAdapter</span>:(IGListAdapter *)listAdapter &#123;</span><br><span class="line">    IGAssertMainThread();</span><br><span class="line">    <span class="comment">// This method is optimized C++ to improve straight-line speed of these operations. Change at your peril.</span></span><br><span class="line">    <span class="comment">// We use a std::set because it is ordered.</span></span><br><span class="line">    std::<span class="built_in">set</span>&lt;NSInteger&gt; visibleSectionSet = std::<span class="built_in">set</span>&lt;NSInteger&gt;();</span><br><span class="line">    <span class="keyword">for</span> (const <span class="variable">_IGListWorkingRangeHandlerIndexPath</span> &amp;indexPath : <span class="variable">_visibleSectionIndices</span>) &#123;</span><br><span class="line">        visibleSectionSet.<span class="built_in">insert</span>(indexPath.section);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据workingRangeSize计算workingRange的start 和 end</span></span><br><span class="line">    NSInteger start;</span><br><span class="line">    NSInteger end;</span><br><span class="line">    <span class="keyword">if</span> (visibleSectionSet.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// We&#x27;re now devoid of any visible sections. Bail</span></span><br><span class="line">        start = <span class="number">0</span>;</span><br><span class="line">        end = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        start = <span class="built_in">MAX</span>(*visibleSectionSet.begin() - <span class="variable">_workingRangeSize</span>, <span class="number">0</span>);</span><br><span class="line">        end = <span class="built_in">MIN</span>(*visibleSectionSet.rbegin() + <span class="number">1</span> + <span class="variable">_workingRangeSize</span>, (NSInteger)listAdapter.objects.<span class="built_in">count</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Build the current set of working range section controllers</span></span><br><span class="line">    <span class="comment">// 构建新的可见sessionController 集合</span></span><br><span class="line">    <span class="variable">_IGListWorkingRangeSectionControllerSet</span> workingRangeSectionControllers (visibleSectionSet.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">for</span> (NSInteger idx = start; idx &lt; end; idx++) &#123;</span><br><span class="line">        <span class="comment">//取出工作区中的sessionController</span></span><br><span class="line">        id item = [listAdapter objectAtSection:idx];</span><br><span class="line">        IGListSectionController *sectionController = [listAdapter sectionControllerForObject:item];</span><br><span class="line">        workingRangeSectionControllers.<span class="built_in">insert</span>(&#123;sectionController&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//工作区不能大于1000</span></span><br><span class="line">    IGAssert(workingRangeSectionControllers.<span class="built_in">size</span>() &lt; <span class="number">1000</span>, @<span class="string">&quot;This algorithm is way too slow with so many objects:%lu&quot;</span>, workingRangeSectionControllers.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Tell any new section controllers that they have entered the working range</span></span><br><span class="line">    <span class="comment">// 从新的可见sessionController 集合中遍历每个元素看下是否在旧的存在，如果在旧的不存在 说明这个是新进入工作区的通知对应的sessionController</span></span><br><span class="line">    <span class="keyword">for</span> (const <span class="variable">_IGListWorkingRangeHandlerSectionControllerWrapper</span> &amp;wrapper : workingRangeSectionControllers) &#123;</span><br><span class="line">        <span class="comment">// Check if the item exists in the old working range item array.</span></span><br><span class="line">        auto it = <span class="variable">_workingRangeSectionControllers</span>.<span class="built_in">find</span>(wrapper);</span><br><span class="line">        <span class="keyword">if</span> (it == <span class="variable">_workingRangeSectionControllers</span>.end()) &#123;</span><br><span class="line">            <span class="comment">// The section controller isn&#x27;t in the existing list, so it&#x27;s new.</span></span><br><span class="line">            id &lt;IGListWorkingRangeDelegate&gt; workingRangeDelegate = wrapper.sectionController.workingRangeDelegate;</span><br><span class="line">            [workingRangeDelegate listAdapter:listAdapter sectionControllerWillEnterWorkingRange:wrapper.sectionController];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同理处理退出工作区的事件</span></span><br><span class="line">    <span class="comment">// Tell any removed section controllers that they have exited the working range</span></span><br><span class="line">    <span class="keyword">for</span> (const <span class="variable">_IGListWorkingRangeHandlerSectionControllerWrapper</span> &amp;wrapper : <span class="variable">_workingRangeSectionControllers</span>) &#123;</span><br><span class="line">        <span class="comment">// Check if the item exists in the new list of section controllers</span></span><br><span class="line">        auto it = workingRangeSectionControllers.<span class="built_in">find</span>(wrapper);</span><br><span class="line">        <span class="keyword">if</span> (it == workingRangeSectionControllers.end()) &#123;</span><br><span class="line">            <span class="comment">// If the item does not exist in the new list, then it&#x27;s been removed.</span></span><br><span class="line">            id &lt;IGListWorkingRangeDelegate&gt; workingRangeDelegate = wrapper.sectionController.workingRangeDelegate;</span><br><span class="line">            [workingRangeDelegate listAdapter:listAdapter sectionControllerDidExitWorkingRange:wrapper.sectionController];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="variable">_workingRangeSectionControllers</span> = workingRangeSectionControllers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><strong>加载数据到UICollectionView</strong></strong></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)reloadDataWithCompletion:(<span class="keyword">nullable</span> IGListUpdaterCompletion)completion &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">id</span>&lt;IGListAdapterDataSource&gt; dataSource = <span class="keyword">self</span>.dataSource;</span><br><span class="line">    <span class="built_in">UICollectionView</span> *collectionView = <span class="keyword">self</span>.collectionView;</span><br><span class="line">    <span class="comment">//.......</span></span><br><span class="line">    <span class="comment">//从数据源里面获取当前adapter的全部数据集</span></span><br><span class="line">    <span class="built_in">NSArray</span> *uniqueObjects = objectsWithDuplicateIdentifiersRemoved([dataSource objectsForListAdapter:<span class="keyword">self</span>]);</span><br><span class="line">    __<span class="keyword">weak</span> __typeof__(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</span><br><span class="line">    <span class="comment">//调用updater 加载数据</span></span><br><span class="line">    [<span class="keyword">self</span>.updater reloadDataWithCollectionViewBlock:[<span class="keyword">self</span> _collectionViewBlock]</span><br><span class="line">                                  reloadUpdateBlock:^&#123;</span><br><span class="line">                                      <span class="comment">// purge all section controllers from the item map so that they are regenerated</span></span><br><span class="line">                                      [weakSelf.sectionMap reset];</span><br><span class="line">                                      [weakSelf _updateObjects:uniqueObjects dataSource:dataSource];</span><br><span class="line">                                  &#125; completion:^(<span class="type">BOOL</span> finished) &#123;</span><br><span class="line">                                      [weakSelf _notifyDidUpdate:IGListAdapterUpdateTypeReloadData animated:<span class="literal">NO</span>];</span><br><span class="line">                                      <span class="keyword">if</span> (completion) &#123;</span><br><span class="line">                                          completion(finished);</span><br><span class="line">                                      &#125;</span><br><span class="line">                                  &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在adapter调用加载数据的时候会先从datasource中获取到当前adapter全部sessionConstroller所需要的全部数据集。这些数据数据集被包裹reloadUpdateBlock，等到需要执行reloadUpdateBlock的时候更新Adapter里面的sessionMap等相关等数据集合，因为后面调用UICollectionView reloadData后会通过UICollectionView 的dateSource也就是 adapter中通过对应的代理方法从sessionController中获取数据。</p>
<p>完成上面的设置后就可以调用updater的reloadDataWithCollectionViewBlock进行数据加载。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)reloadDataWithCollectionViewBlock:(IGListCollectionViewBlock)collectionViewBlock</span><br><span class="line">                   reloadUpdateBlock:(IGListReloadUpdateBlock)reloadUpdateBlock</span><br><span class="line">                          completion:(<span class="keyword">nullable</span> IGListUpdatingCompletion)completion &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//.......</span></span><br><span class="line">    <span class="comment">//将完成所需要调用的结束回调添加到completionBlocks</span></span><br><span class="line">    IGListUpdatingCompletion localCompletion = completion;</span><br><span class="line">    <span class="keyword">if</span> (localCompletion) &#123;</span><br><span class="line">        [<span class="keyword">self</span>.completionBlocks addObject:localCompletion];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">self</span>.reloadUpdates = reloadUpdateBlock;</span><br><span class="line">    <span class="keyword">self</span>.queuedReloadData = <span class="literal">YES</span>;</span><br><span class="line">    [<span class="keyword">self</span> _queueUpdateWithCollectionViewBlock:collectionViewBlock];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>reloadDataWithCollectionViewBlock中会将queuedReloadData设置为YES,然后触发_queueUpdateWithCollectionViewBlock，在_queueUpdateWithCollectionViewBlock中由于queuedReloadData设置为YES，所以执行performReloadDataWithCollectionViewBlock</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- (void)_queueUpdateWithCollectionViewBlock:(IGListCollectionViewBlock)collectionViewBlock &#123;</span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        <span class="comment">//如果正在处于批量更新数据中，或者没有新的变更则直接返回</span></span><br><span class="line">        if (weakSelf.state != IGListBatchUpdateStateIdle</span><br><span class="line">            || ![weakSelf hasChanges]) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (weakSelf.hasQueuedReloadData) &#123;</span><br><span class="line">            <span class="comment">//执行加载</span></span><br><span class="line">            <span class="selector-attr">[weakSelf performReloadDataWithCollectionViewBlock:collectionViewBlock]</span>;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            <span class="comment">//批量加载</span></span><br><span class="line">            <span class="selector-attr">[weakSelf performBatchUpdatesWithCollectionViewBlock:collectionViewBlock]</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><strong>加载数据到UICollectionView</strong></strong></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)performReloadDataWithCollectionViewBlock:(IGListCollectionViewBlock)collectionViewBlock &#123;</span><br><span class="line">    IGAssertMainThread();</span><br><span class="line"></span><br><span class="line">    <span class="type">id</span>&lt;IGListAdapterUpdaterDelegate&gt; delegate = <span class="keyword">self</span>.delegate;</span><br><span class="line">    <span class="type">void</span> (^reloadUpdates)(<span class="type">void</span>) = <span class="keyword">self</span>.reloadUpdates;</span><br><span class="line">    IGListBatchUpdates *batchUpdates = <span class="keyword">self</span>.batchUpdates;</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *completionBlocks = [<span class="keyword">self</span>.completionBlocks mutableCopy];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//开始加载前清除相关的状态变量</span></span><br><span class="line">    [<span class="keyword">self</span> cleanStateBeforeUpdates];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//加载结束之后执行全部的completeBlock,并且将状态改为IGListBatchUpdateStateIdle</span></span><br><span class="line">    <span class="type">void</span> (^executeCompletionBlocks)(<span class="type">BOOL</span>) = ^(<span class="type">BOOL</span> finished) &#123;</span><br><span class="line">        <span class="keyword">for</span> (IGListUpdatingCompletion block <span class="keyword">in</span> completionBlocks) &#123;</span><br><span class="line">            block(finished);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">self</span>.state = IGListBatchUpdateStateIdle;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 在更新任务还在队列的时候如果返回执行的时候发现collection已经被释放则重置对应的状态并调用completeBlock，将状态设置为IGListBatchUpdateStateIdle</span></span><br><span class="line">    <span class="built_in">UICollectionView</span> *collectionView = collectionViewBlock();</span><br><span class="line">    <span class="keyword">if</span> (collectionView == <span class="literal">nil</span>) &#123;</span><br><span class="line">        [<span class="keyword">self</span> _cleanStateAfterUpdates];</span><br><span class="line">        executeCompletionBlocks(<span class="literal">NO</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// item updates must not send mutations to the collection view while we are reloading</span></span><br><span class="line">    <span class="comment">// 将状态设置为正在加载数据</span></span><br><span class="line">    <span class="keyword">self</span>.state = IGListBatchUpdateStateExecutingBatchUpdateBlock;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用_updateObjects 重建object 和 sessionController之间的关系</span></span><br><span class="line">    <span class="keyword">if</span> (reloadUpdates) &#123;</span><br><span class="line">        reloadUpdates();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行批量更新中的单个更新block</span></span><br><span class="line">    <span class="comment">// execute all stored item update blocks even if we are just calling reloadData. the actual collection view</span></span><br><span class="line">    <span class="comment">// mutations will be discarded, but clients are encouraged to put their actual /data/ mutations inside the</span></span><br><span class="line">    <span class="comment">// update block as well, so if we don&#x27;t execute the block the changes will never happen</span></span><br><span class="line">    <span class="keyword">for</span> (IGListItemUpdateBlock itemUpdateBlock <span class="keyword">in</span> batchUpdates.itemUpdateBlocks) &#123;</span><br><span class="line">        itemUpdateBlock();</span><br><span class="line">    &#125;</span><br><span class="line">    [completionBlocks addObjectsFromArray:batchUpdates.itemCompletionBlocks];</span><br><span class="line">    <span class="keyword">self</span>.state = IGListBatchUpdateStateExecutedBatchUpdateBlock;</span><br><span class="line">    <span class="comment">//将状态设置为批量更新执行完毕</span></span><br><span class="line">    [<span class="keyword">self</span> _cleanStateAfterUpdates];</span><br><span class="line">    <span class="comment">//通知外部当前的UICollectionView即将开始加载数据</span></span><br><span class="line">    [delegate listAdapterUpdater:<span class="keyword">self</span> willReloadDataWithCollectionView:collectionView];</span><br><span class="line">    <span class="comment">//加载数据</span></span><br><span class="line">    [collectionView reloadData];</span><br><span class="line">    [collectionView.collectionViewLayout invalidateLayout];</span><br><span class="line">    [collectionView layoutIfNeeded];</span><br><span class="line">    <span class="comment">//通知外部当前的UICollectionView已经加载完数据</span></span><br><span class="line">    [delegate listAdapterUpdater:<span class="keyword">self</span> didReloadDataWithCollectionView:collectionView];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行完成后的block</span></span><br><span class="line">    executeCompletionBlocks(<span class="literal">YES</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>performReloadDataWithCollectionViewBlock方法中会执行传入的reloadUpdates以及batchUpdates.itemUpdateBlocks中对应的更新block然后在调用对应的<br>delegate 通知UICollectionView将要开始进行数据加载。然后调用[collectionView reloadData]加载数据。</p>
<p>调用[collectionView reloadData] 后便会触发UICollectionView的对应代理，由于IGListAdapter会对UICollectionView 的UICollectionViewDataSource 代理进行拦截，所以这些处理出现在IGListAdapter中：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">NSInteger</span>)numberOfSectionsInCollectionView:(<span class="built_in">UICollectionView</span> *)collectionView &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.sectionMap.objects.count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSInteger</span>)collectionView:(<span class="built_in">UICollectionView</span> *)collectionView numberOfItemsInSection:(<span class="built_in">NSInteger</span>)section &#123;</span><br><span class="line">    IGListSectionController * sectionController = [<span class="keyword">self</span> sectionControllerForSection:section];</span><br><span class="line">    IGAssert(sectionController != <span class="literal">nil</span>, <span class="string">@&quot;Nil section controller for section %li for item %@. Check your -diffIdentifier and -isEqual: implementations.&quot;</span>,</span><br><span class="line">             (<span class="type">long</span>)section, [<span class="keyword">self</span>.sectionMap objectForSection:section]);</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">NSInteger</span> numberOfItems = [sectionController numberOfItems];</span><br><span class="line">    IGAssert(numberOfItems &gt;= <span class="number">0</span>, <span class="string">@&quot;Cannot return negative number of items %li for section controller %@.&quot;</span>, (<span class="type">long</span>)numberOfItems, sectionController);</span><br><span class="line">    <span class="keyword">return</span> numberOfItems;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">UICollectionViewCell</span> *)collectionView:(<span class="built_in">UICollectionView</span> *)collectionView cellForItemAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath &#123;</span><br><span class="line">    <span class="type">id</span>&lt;IGListAdapterPerformanceDelegate&gt; performanceDelegate = <span class="keyword">self</span>.performanceDelegate;</span><br><span class="line">    [performanceDelegate listAdapterWillCallDequeueCell:<span class="keyword">self</span>];</span><br><span class="line">    IGListSectionController *sectionController = [<span class="keyword">self</span> sectionControllerForSection:indexPath.section];</span><br><span class="line">    <span class="comment">// flag that a cell is being dequeued in case it tries to access a cell in the process</span></span><br><span class="line">    _isDequeuingCell = <span class="literal">YES</span>;</span><br><span class="line">    <span class="built_in">UICollectionViewCell</span> *cell = [sectionController cellForItemAtIndex:indexPath.item];</span><br><span class="line">    _isDequeuingCell = <span class="literal">NO</span>;</span><br><span class="line">    IGAssert(cell != <span class="literal">nil</span>, <span class="string">@&quot;Returned a nil cell at indexPath &lt;%@&gt; from section controller: &lt;%@&gt;&quot;</span>, indexPath, sectionController);</span><br><span class="line">    <span class="comment">// associate the section controller with the cell so that we know which section controller is using it</span></span><br><span class="line">    [<span class="keyword">self</span> mapView:cell toSectionController:sectionController];</span><br><span class="line">    [performanceDelegate listAdapter:<span class="keyword">self</span> didCallDequeueCell:cell onSectionController:sectionController atIndex:indexPath.item];</span><br><span class="line">    <span class="keyword">return</span> cell;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这些方法大致思路是通过indexPath获取到对应的SessionController然后再通过SessionController中的方法获取对应的数据。</p>
<p><strong><strong>批量更新UICollectionView数据</strong></strong></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)performUpdatesAnimated:(<span class="type">BOOL</span>)animated completion:(IGListUpdaterCompletion)completion &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//.......</span></span><br><span class="line">    <span class="type">id</span>&lt;IGListAdapterDataSource&gt; dataSource = <span class="keyword">self</span>.dataSource;</span><br><span class="line">    <span class="built_in">UICollectionView</span> *collectionView = <span class="keyword">self</span>.collectionView;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">    <span class="comment">//旧的数据源</span></span><br><span class="line">    <span class="built_in">NSArray</span> *fromObjects = <span class="keyword">self</span>.sectionMap.objects;</span><br><span class="line"></span><br><span class="line">    IGListToObjectBlock toObjectsBlock;</span><br><span class="line">    __<span class="keyword">weak</span> __typeof__(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</span><br><span class="line">    <span class="keyword">if</span> (IGListExperimentEnabled(<span class="keyword">self</span>.experiments, IGListExperimentDeferredToObjectCreation)) &#123;</span><br><span class="line">        toObjectsBlock = ^<span class="built_in">NSArray</span> *&#123;</span><br><span class="line">            __typeof__(<span class="keyword">self</span>) strongSelf = weakSelf;</span><br><span class="line">            <span class="keyword">if</span> (strongSelf == <span class="literal">nil</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> [dataSource objectsForListAdapter:strongSelf];</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//从dataSource中获取最新的数据源</span></span><br><span class="line">        <span class="built_in">NSArray</span> *newObjects = [dataSource objectsForListAdapter:<span class="keyword">self</span>];</span><br><span class="line">        toObjectsBlock = ^<span class="built_in">NSArray</span> *&#123;</span><br><span class="line">            <span class="keyword">return</span> newObjects;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span> _enterBatchUpdates];</span><br><span class="line">    [<span class="keyword">self</span>.updater performUpdateWithCollectionViewBlock:[<span class="keyword">self</span> _collectionViewBlock]</span><br><span class="line">                                           fromObjects:fromObjects</span><br><span class="line">                                        toObjectsBlock:toObjectsBlock</span><br><span class="line">                                              animated:animated</span><br><span class="line">                                 objectTransitionBlock:^(<span class="built_in">NSArray</span> *toObjects) &#123;</span><br><span class="line">                                     <span class="comment">// 更新数据源</span></span><br><span class="line">                                     weakSelf.previousSectionMap = [weakSelf.sectionMap <span class="keyword">copy</span>];</span><br><span class="line">                                     [weakSelf _updateObjects:toObjects dataSource:dataSource];</span><br><span class="line">                                 &#125; completion:^(<span class="type">BOOL</span> finished) &#123;</span><br><span class="line">                                     weakSelf.previousSectionMap = <span class="literal">nil</span>;</span><br><span class="line">                                     [weakSelf _notifyDidUpdate:IGListAdapterUpdateTypePerformUpdates animated:animated];</span><br><span class="line">                                     <span class="keyword">if</span> (completion) &#123;</span><br><span class="line">                                         completion(finished);</span><br><span class="line">                                     &#125;</span><br><span class="line">                                     [weakSelf _exitBatchUpdates];</span><br><span class="line">                                 &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">- (void)performUpdateWithCollectionViewBlock:(IGListCollectionViewBlock)collectionViewBlock</span><br><span class="line">                            <span class="keyword">from</span>Objects:(NSArray *)<span class="keyword">from</span>Objects</span><br><span class="line">                         <span class="keyword">to</span>ObjectsBlock:(IGListToObjectBlock)<span class="keyword">to</span>ObjectsBlock</span><br><span class="line">                               animated:(BOOL)animated</span><br><span class="line">                  objectTransitionBlock:(IGListObjectTransitionBlock)objectTransitionBlock</span><br><span class="line">                             completion:(IGListUpdatingCompletion)completion &#123;</span><br><span class="line">    </span><br><span class="line">    //........</span><br><span class="line">    <span class="literal">self</span>.<span class="keyword">from</span>Objects = <span class="literal">self</span>.<span class="keyword">from</span>Objects ?: <span class="literal">self</span>.pendingTransitionToObjects ?: <span class="keyword">from</span>Objects;</span><br><span class="line">    <span class="literal">self</span>.<span class="keyword">to</span>ObjectsBlock = <span class="keyword">to</span>ObjectsBlock;</span><br><span class="line"></span><br><span class="line">    <span class="literal">self</span>.queuedUpdateIsAnimated = <span class="literal">self</span>.queuedUpdateIsAnimated &amp;&amp; animated;</span><br><span class="line">    <span class="literal">self</span>.objectTransitionBlock = objectTransitionBlock;</span><br><span class="line"></span><br><span class="line">    IGListUpdatingCompletion localCompletion = completion;</span><br><span class="line">    if (localCompletion) &#123;</span><br><span class="line">        [<span class="literal">self</span>.completionBlocks addObject:localCompletion];</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="literal">self</span> _queueUpdateWithCollectionViewBlock:collectionViewBlock];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)_queueUpdateWithCollectionViewBlock:(IGListCollectionViewBlock)collectionViewBlock &#123;</span><br><span class="line">    __weak __typeof__(<span class="literal">self</span>) weakSelf = <span class="literal">self</span>;</span><br><span class="line">    dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        if (weakSelf.<span class="keyword">state</span> != IGListBatchUpdateStateIdle</span><br><span class="line">            || ![weakSelf hasChanges]) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (weakSelf.hasQueuedReloadData) &#123;</span><br><span class="line">            [weakSelf performReloadDataWithCollectionViewBlock:collectionViewBlock];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //更新的时候走这里</span><br><span class="line">            [weakSelf performBatchUpdatesWithCollectionViewBlock:collectionViewBlock];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)performBatchUpdatesWithCollectionViewBlock:(IGListCollectionViewBlock)collectionViewBlock &#123;</span><br><span class="line">    <span class="comment">//........</span></span><br><span class="line">    <span class="comment">// create local variables so we can immediately clean our state but pass these items into the batch update block</span></span><br><span class="line">    <span class="type">id</span>&lt;IGListAdapterUpdaterDelegate&gt; delegate = <span class="keyword">self</span>.delegate;</span><br><span class="line">    <span class="built_in">NSArray</span> *fromObjects = [<span class="keyword">self</span>.fromObjects <span class="keyword">copy</span>];</span><br><span class="line">    IGListToObjectBlock toObjectsBlock = [<span class="keyword">self</span>.toObjectsBlock <span class="keyword">copy</span>];</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *completionBlocks = [<span class="keyword">self</span>.completionBlocks mutableCopy];</span><br><span class="line">    <span class="type">void</span> (^objectTransitionBlock)(<span class="built_in">NSArray</span> *) = [<span class="keyword">self</span>.objectTransitionBlock <span class="keyword">copy</span>];</span><br><span class="line">    <span class="keyword">const</span> <span class="type">BOOL</span> animated = <span class="keyword">self</span>.queuedUpdateIsAnimated;</span><br><span class="line">    IGListBatchUpdates *batchUpdates = <span class="keyword">self</span>.batchUpdates;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在更新前重置状态为初始状态</span></span><br><span class="line">    <span class="comment">// clean up all state so that new updates can be coalesced while the current update is in flight</span></span><br><span class="line">    [<span class="keyword">self</span> cleanStateBeforeUpdates];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新完成之后的回调</span></span><br><span class="line">    <span class="type">void</span> (^executeCompletionBlocks)(<span class="type">BOOL</span>) = ^(<span class="type">BOOL</span> finished) &#123;</span><br><span class="line">        <span class="keyword">self</span>.applyingUpdateData = <span class="literal">nil</span>;</span><br><span class="line">        <span class="keyword">self</span>.state = IGListBatchUpdateStateIdle;</span><br><span class="line">        <span class="keyword">for</span> (IGListUpdatingCompletion block <span class="keyword">in</span> completionBlocks) &#123;</span><br><span class="line">            block(finished);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//.......</span></span><br><span class="line">    <span class="built_in">NSArray</span> *toObjects = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">if</span> (toObjectsBlock != <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="comment">//剔除掉重复数据</span></span><br><span class="line">        toObjects = objectsWithDuplicateIdentifiersRemoved(toObjectsBlock());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数据刷新的闭包</span></span><br><span class="line">    <span class="type">void</span> (^executeUpdateBlocks)(<span class="type">void</span>) = ^&#123;</span><br><span class="line">        <span class="keyword">self</span>.state = IGListBatchUpdateStateExecutingBatchUpdateBlock;</span><br><span class="line">        <span class="comment">// 更新包括 IGListAdapter 的 sectionController 和 objects 的映射关系等数据，保证执行刷新前数据已经是最新的</span></span><br><span class="line">        <span class="keyword">if</span> (objectTransitionBlock != <span class="literal">nil</span>) &#123;</span><br><span class="line">            objectTransitionBlock(toObjects);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 触发批量刷新任务的数据更新闭包（包括插入、删除、刷新单个 section 的数据）objectTransitionBlock 之后执行是为了保证 section 级别的刷新在 item 级别刷新之前进行</span></span><br><span class="line">        <span class="keyword">for</span> (IGListItemUpdateBlock itemUpdateBlock <span class="keyword">in</span> batchUpdates.itemUpdateBlocks) &#123;</span><br><span class="line">            itemUpdateBlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//收集批量刷新完成的回调，后续所有操作完了之后一并处理</span></span><br><span class="line">        [completionBlocks addObjectsFromArray:batchUpdates.itemCompletionBlocks];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.state = IGListBatchUpdateStateExecutedBatchUpdateBlock;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行全量的数据更新并刷新 UI</span></span><br><span class="line">    <span class="type">void</span> (^reloadDataFallback)(<span class="type">void</span>) = ^&#123;</span><br><span class="line">        <span class="comment">//执行更新</span></span><br><span class="line">        executeUpdateBlocks();</span><br><span class="line">        <span class="comment">//清除batchUpdates</span></span><br><span class="line">        [<span class="keyword">self</span> _cleanStateAfterUpdates];</span><br><span class="line">        [<span class="keyword">self</span> _performBatchUpdatesItemBlockApplied];</span><br><span class="line">        <span class="comment">//加载数据</span></span><br><span class="line">        [collectionView reloadData];</span><br><span class="line">        [collectionView layoutIfNeeded];</span><br><span class="line">        executeCompletionBlocks(<span class="literal">YES</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.allowsBackgroundReloading &amp;&amp; collectionView.window == <span class="literal">nil</span>) &#123;</span><br><span class="line">        [<span class="keyword">self</span> _beginPerformBatchUpdatesToObjects:toObjects];</span><br><span class="line">        reloadDataFallback();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// disables multiple performBatchUpdates: from happening at the same time</span></span><br><span class="line">    [<span class="keyword">self</span> _beginPerformBatchUpdatesToObjects:toObjects];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> IGListExperiment experiments = <span class="keyword">self</span>.experiments;</span><br><span class="line"></span><br><span class="line">    IGListIndexSetResult *(^performDiff)(<span class="type">void</span>) = ^&#123;</span><br><span class="line">        <span class="keyword">return</span> IGListDiffExperiment(fromObjects, toObjects, IGListDiffEquality, experiments);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// block executed in the first param block of -[UICollectionView performBatchUpdates:completion:]</span></span><br><span class="line">    <span class="type">void</span> (^batchUpdatesBlock)(IGListIndexSetResult *result) = ^(IGListIndexSetResult *result)&#123;</span><br><span class="line">        <span class="comment">//执行更新</span></span><br><span class="line">        executeUpdateBlocks();</span><br><span class="line">        <span class="keyword">self</span>.applyingUpdateData = [<span class="keyword">self</span> _flushCollectionView:collectionView</span><br><span class="line">                                              withDiffResult:result</span><br><span class="line">                                                batchUpdates:<span class="keyword">self</span>.batchUpdates</span><br><span class="line">                                                 fromObjects:fromObjects];</span><br><span class="line">        <span class="comment">//重置状态</span></span><br><span class="line">        [<span class="keyword">self</span> _cleanStateAfterUpdates];</span><br><span class="line">        [<span class="keyword">self</span> _performBatchUpdatesItemBlockApplied];</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// block used as the second param of -[UICollectionView performBatchUpdates:completion:]</span></span><br><span class="line">    <span class="type">void</span> (^batchUpdatesCompletionBlock)(<span class="type">BOOL</span>) = ^(<span class="type">BOOL</span> finished) &#123;</span><br><span class="line">        IGListBatchUpdateData *oldApplyingUpdateData = <span class="keyword">self</span>.applyingUpdateData;</span><br><span class="line">        executeCompletionBlocks(finished);</span><br><span class="line"></span><br><span class="line">        [delegate listAdapterUpdater:<span class="keyword">self</span> didPerformBatchUpdates:oldApplyingUpdateData collectionView:collectionView];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// queue another update in case something changed during batch updates. this method will bail next runloop if</span></span><br><span class="line">        <span class="comment">// there are no changes</span></span><br><span class="line">        [<span class="keyword">self</span> _queueUpdateWithCollectionViewBlock:collectionViewBlock];</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// block that executes the batch update and exception handling</span></span><br><span class="line">    <span class="type">void</span> (^performUpdate)(IGListIndexSetResult *) = ^(IGListIndexSetResult *result)&#123;</span><br><span class="line">        [collectionView layoutIfNeeded];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">@try</span> &#123;</span><br><span class="line">            <span class="comment">// 对外通知即将进行 batch update</span></span><br><span class="line">            [delegate  listAdapterUpdater:<span class="keyword">self</span></span><br><span class="line">willPerformBatchUpdatesWithCollectionView:collectionView</span><br><span class="line">                              fromObjects:fromObjects</span><br><span class="line">                                toObjects:toObjects</span><br><span class="line">                       listIndexSetResult:result];</span><br><span class="line">            <span class="keyword">if</span> (collectionView.dataSource == <span class="literal">nil</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果数据源为空则不再刷新的 UICollectionview</span></span><br><span class="line">                batchUpdatesCompletionBlock(<span class="literal">NO</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (result.changeCount &gt; <span class="number">100</span> &amp;&amp; IGListExperimentEnabled(experiments, IGListExperimentReloadDataFallback)) &#123;</span><br><span class="line">                <span class="comment">// 如果变化数量超过100，进行全量刷新</span></span><br><span class="line">                reloadDataFallback();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (animated) &#123;</span><br><span class="line">                <span class="comment">//执行更新的批量动画</span></span><br><span class="line">                [collectionView performBatchUpdates:^&#123;</span><br><span class="line">                    batchUpdatesBlock(result);</span><br><span class="line">                &#125; completion:batchUpdatesCompletionBlock];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                [<span class="built_in">CATransaction</span> begin];</span><br><span class="line">                [<span class="built_in">CATransaction</span> setDisableActions:<span class="literal">YES</span>];</span><br><span class="line">                [collectionView performBatchUpdates:^&#123;</span><br><span class="line">                    batchUpdatesBlock(result);</span><br><span class="line">                &#125; completion:^(<span class="type">BOOL</span> finished) &#123;</span><br><span class="line">                    [<span class="built_in">CATransaction</span> commit];</span><br><span class="line">                    batchUpdatesCompletionBlock(finished);</span><br><span class="line">                &#125;];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">@catch</span> (<span class="built_in">NSException</span> *exception) &#123;</span><br><span class="line">            [delegate listAdapterUpdater:<span class="keyword">self</span></span><br><span class="line">                          collectionView:collectionView</span><br><span class="line">                  willCrashWithException:exception</span><br><span class="line">                             fromObjects:fromObjects</span><br><span class="line">                               toObjects:toObjects</span><br><span class="line">                              diffResult:result</span><br><span class="line">                                 updates:(<span class="type">id</span>)<span class="keyword">self</span>.applyingUpdateData];</span><br><span class="line">            <span class="keyword">@throw</span> exception;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (IGListExperimentEnabled(experiments, IGListExperimentBackgroundDiffing)) &#123;</span><br><span class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(QOS_CLASS_USER_INITIATED, <span class="number">0</span>), ^&#123;</span><br><span class="line">            IGListIndexSetResult *result = performDiff();</span><br><span class="line">            <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                performUpdate(result);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        IGListIndexSetResult *result = performDiff();</span><br><span class="line">        performUpdate(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>批量更新这部分细节有点多，这里归纳如下：</p>
<p>如果allowsBackgroundReloading为YES,也就是说允许后台加载数据的情况下如果collectionView不显示，则跳过数据diff和批量更新直接进行全量加载刷新。否则在子线程调用performDiff() 通过 IGListDiffExperiment 计算数据的变化，然后在主线程调用performUpdate进行批量更新操作：<br>在performUpdate开始的时候先通过代理对外通知即将进行 batch update 批量更新，紧接着判断如果 collectionView 的 dataSource 为 nil，结束更新过程，如果变化的数据个数超过100，就不进行批量更新了直接调用 reloadData 全量刷新数据；如果变化数据小于100，则调用 <strong><strong>-[UICollectionView performBatchUpdates:completion:]</strong></strong> 批量刷新数据，刷新过程中会调用 <strong><strong>-_flushCollectionView:withDiffResult:batchUpdates:fromObjects:</strong></strong> 将数据源提供的数据和 diff 结果包装成批量更新的数据类型 IGListBatchUpdateData 以便 UICollectionView 进行读取。这里最关键的代码在****_flushCollectionView****</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="operator">-</span> (<span class="type">IGListBatchUpdateData</span> <span class="operator">*</span>)_flushCollectionView:(<span class="type">UICollectionView</span> <span class="operator">*</span>)collectionView</span><br><span class="line">                                withDiffResult:(<span class="type">IGListIndexSetResult</span> <span class="operator">*</span>)diffResult</span><br><span class="line">                                  batchUpdates:(<span class="type">IGListBatchUpdates</span> <span class="operator">*</span>)batchUpdates</span><br><span class="line">                                   fromObjects:(<span class="type">NSArray</span> <span class="operator">&lt;</span>id<span class="operator">&lt;</span><span class="type">IGListDiffable</span><span class="operator">&gt;&gt;</span> <span class="operator">*</span>)fromObjects &#123;</span><br><span class="line">    <span class="comment">//移动session</span></span><br><span class="line">    <span class="type">NSSet</span> <span class="operator">*</span>moves <span class="operator">=</span> [[<span class="type">NSSet</span> alloc] initWithArray:diffResult.moves];</span><br><span class="line">    <span class="comment">//reload的item：合并通过diff和通过reloadItems手动reloads的session</span></span><br><span class="line">    <span class="type">NSMutableIndexSet</span> <span class="operator">*</span>reloads <span class="operator">=</span> [diffResult.updates mutableCopy];</span><br><span class="line">    [reloads addIndexes:batchUpdates.sectionReloads];</span><br><span class="line">    <span class="comment">//插入的session</span></span><br><span class="line">    <span class="type">NSMutableIndexSet</span> <span class="operator">*</span>inserts <span class="operator">=</span> [diffResult.inserts mutableCopy];</span><br><span class="line">    <span class="comment">//删除的session</span></span><br><span class="line">    <span class="type">NSMutableIndexSet</span> <span class="operator">*</span>deletes <span class="operator">=</span> [diffResult.deletes mutableCopy];</span><br><span class="line">    <span class="type">NSMutableArray</span>&lt;<span class="type">NSIndexPath</span> *&gt; <span class="operator">*</span>itemUpdates <span class="operator">=</span> [<span class="type">NSMutableArray</span> new];</span><br><span class="line">    <span class="comment">//如果movesAsDeletesInserts = YES 那么就将moves中的转换为deletes和inserts操作</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.movesAsDeletesInserts) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">IGListMoveIndex</span> <span class="operator">*</span>move <span class="keyword">in</span> moves) &#123;</span><br><span class="line">            [deletes addIndex:move.from];</span><br><span class="line">            [inserts addIndex:move.to];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// clear out all moves</span></span><br><span class="line">        moves <span class="operator">=</span> [<span class="type">NSSet</span> new];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Item reloads are not safe, if any section moves happened or there are inserts/deletes.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.preferItemReloadsForSectionReloads</span><br><span class="line">        <span class="operator">&amp;&amp;</span> moves.count <span class="operator">==</span> <span class="number">0</span> <span class="operator">&amp;&amp;</span> inserts.count <span class="operator">==</span> <span class="number">0</span> <span class="operator">&amp;&amp;</span> deletes.count <span class="operator">==</span> <span class="number">0</span> <span class="operator">&amp;&amp;</span> reloads.count <span class="operator">&gt;</span> <span class="number">0</span>) &#123;</span><br><span class="line">        [reloads enumerateIndexesUsingBlock:<span class="operator">^</span>(<span class="type">NSUInteger</span> sectionIndex, <span class="type">BOOL</span> <span class="operator">*</span> _Nonnull stop) &#123;</span><br><span class="line">            <span class="type">NSMutableIndexSet</span> <span class="operator">*</span>localIndexSet <span class="operator">=</span> [<span class="type">NSMutableIndexSet</span> indexSetWithIndex:sectionIndex];</span><br><span class="line">            <span class="keyword">if</span> (sectionIndex <span class="operator">&lt;</span> [collectionView numberOfSections]</span><br><span class="line">                <span class="operator">&amp;&amp;</span> sectionIndex <span class="operator">&lt;</span> [collectionView.dataSource numberOfSectionsInCollectionView:collectionView]</span><br><span class="line">                <span class="operator">&amp;&amp;</span> [collectionView numberOfItemsInSection:sectionIndex] <span class="operator">==</span> [collectionView.dataSource collectionView:collectionView numberOfItemsInSection:sectionIndex]) &#123;</span><br><span class="line">                <span class="comment">// Perfer to do item reloads instead, if the number of items in section is unchanged.</span></span><br><span class="line">                [itemUpdates addObjectsFromArray:convertSectionReloadToItemUpdates(localIndexSet, collectionView)];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Otherwise, fallback to convert into delete+insert section operation.</span></span><br><span class="line">                convertReloadToDeleteInsert(localIndexSet, deletes, inserts, diffResult, fromObjects);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 在performBatchUpdates中使用reloadSections是不安全的，所以需要将reloads转换为deletes+inserts</span></span><br><span class="line">        convertReloadToDeleteInsert(reloads, deletes, inserts, diffResult, fromObjects);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//插入，删除，移动 item处理</span></span><br><span class="line">    <span class="type">NSMutableArray</span>&lt;<span class="type">NSIndexPath</span> *&gt; <span class="operator">*</span>itemInserts <span class="operator">=</span> batchUpdates.itemInserts;</span><br><span class="line">    <span class="type">NSMutableArray</span>&lt;<span class="type">NSIndexPath</span> *&gt; <span class="operator">*</span>itemDeletes <span class="operator">=</span> batchUpdates.itemDeletes;</span><br><span class="line">    <span class="type">NSMutableArray</span>&lt;<span class="type">IGListMoveIndexPath</span> *&gt; <span class="operator">*</span>itemMoves <span class="operator">=</span> batchUpdates.itemMoves;</span><br><span class="line"></span><br><span class="line">    <span class="type">NSSet</span>&lt;<span class="type">NSIndexPath</span> *&gt; <span class="operator">*</span>uniqueDeletes <span class="operator">=</span> [<span class="type">NSSet</span> setWithArray:itemDeletes];</span><br><span class="line">    <span class="type">NSMutableSet</span>&lt;<span class="type">NSIndexPath</span> *&gt; <span class="operator">*</span>reloadDeletePaths <span class="operator">=</span> [<span class="type">NSMutableSet</span> new];</span><br><span class="line">    <span class="type">NSMutableSet</span>&lt;<span class="type">NSIndexPath</span> *&gt; <span class="operator">*</span>reloadInsertPaths <span class="operator">=</span> [<span class="type">NSMutableSet</span> new];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">IGListReloadIndexPath</span> <span class="operator">*</span>reload <span class="keyword">in</span> batchUpdates.itemReloads) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="operator">!</span>[uniqueDeletes containsObject:reload.fromIndexPath]) &#123;</span><br><span class="line">            [reloadDeletePaths addObject:reload.fromIndexPath];</span><br><span class="line">            [reloadInsertPaths addObject:reload.toIndexPath];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    [itemDeletes addObjectsFromArray:[reloadDeletePaths allObjects]];</span><br><span class="line">    [itemInserts addObjectsFromArray:[reloadInsertPaths allObjects]];</span><br><span class="line"></span><br><span class="line">    const <span class="type">BOOL</span> fixIndexPathImbalance <span class="operator">=</span> <span class="type">IGListExperimentEnabled</span>(<span class="keyword">self</span>.experiments, <span class="type">IGListExperimentFixIndexPathImbalance</span>);</span><br><span class="line">    <span class="type">IGListBatchUpdateData</span> <span class="operator">*</span>updateData <span class="operator">=</span> [[<span class="type">IGListBatchUpdateData</span> alloc] initWithInsertSections:inserts</span><br><span class="line">                                                                               deleteSections:deletes</span><br><span class="line">                                                                                 moveSections:moves</span><br><span class="line">                                                                             insertIndexPaths:itemInserts</span><br><span class="line">                                                                             deleteIndexPaths:itemDeletes</span><br><span class="line">                                                                             updateIndexPaths:itemUpdates</span><br><span class="line">                                                                               moveIndexPaths:itemMoves</span><br><span class="line">                                                                        fixIndexPathImbalance:fixIndexPathImbalance];</span><br><span class="line">    [collectionView ig_applyBatchUpdateData:updateData];</span><br><span class="line">    <span class="keyword">return</span> updateData;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="operator">-</span> (void)ig_applyBatchUpdateData:(<span class="type">IGListBatchUpdateData</span> <span class="operator">*</span>)updateData &#123;    </span><br><span class="line">    [<span class="keyword">self</span> deleteItemsAtIndexPaths:updateData.deleteIndexPaths];</span><br><span class="line">    [<span class="keyword">self</span> insertItemsAtIndexPaths:updateData.insertIndexPaths];</span><br><span class="line">    [<span class="keyword">self</span> reloadItemsAtIndexPaths:updateData.updateIndexPaths];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">IGListMoveIndexPath</span> <span class="operator">*</span>move <span class="keyword">in</span> updateData.moveIndexPaths) &#123;</span><br><span class="line">        [<span class="keyword">self</span> moveItemAtIndexPath:move.from toIndexPath:move.to];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">IGListMoveIndex</span> <span class="operator">*</span>move <span class="keyword">in</span> updateData.moveSections) &#123;</span><br><span class="line">        [<span class="keyword">self</span> moveSection:move.from toSection:move.to];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span> deleteSections:updateData.deleteSections];</span><br><span class="line">    [<span class="keyword">self</span> insertSections:updateData.insertSections];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在_flushCollectionView中会对手动添加的批量操作和通过diff算法确定的更新操作统一转换为对session的insert,delete,reload的操作，最后调用UICollectionView的<strong><strong>deleteItemsAtIndexPaths</strong></strong>，<strong><strong>insertItemsAtIndexPaths</strong></strong>，<strong><strong>reloadItemsAtIndexPaths</strong></strong>，<strong><strong>moveItemAtIndexPath</strong></strong>，<strong><strong>moveSection</strong></strong>，<strong><strong>deleteSections</strong></strong>，<strong><strong>insertSections</strong></strong>。对UICollectionView进行更新。</p>
<p><strong><strong>IGListSectionController</strong></strong></p>
<p>IGListSectionController 在IGListKit中也是一个十分关键的对象，我们先来看下它拥有的属性：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">IGListSectionController</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> Session中的item数量</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">- (<span class="built_in">NSInteger</span>)numberOfItems;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 指定index位置上的item尺寸</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="built_in">CGSize</span>)sizeForItemAtIndex:(<span class="built_in">NSInteger</span>)index;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  返回指定位置的Cell对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (__kindof <span class="built_in">UICollectionViewCell</span> *)cellForItemAtIndex:(<span class="built_in">NSInteger</span>)index;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  从外界注入该Session所拥有的整个对象数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="type">void</span>)didUpdateToObject:(<span class="type">id</span>)object;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)didSelectItemAtIndex:(<span class="built_in">NSInteger</span>)index;</span><br><span class="line">- (<span class="type">void</span>)didDeselectItemAtIndex:(<span class="built_in">NSInteger</span>)index;</span><br><span class="line">- (<span class="type">void</span>)didHighlightItemAtIndex:(<span class="built_in">NSInteger</span>)index;</span><br><span class="line">- (<span class="type">void</span>)didUnhighlightItemAtIndex:(<span class="built_in">NSInteger</span>)index;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">- (<span class="type">BOOL</span>)canMoveItemAtIndex:(<span class="built_in">NSInteger</span>)index;</span><br><span class="line">- (<span class="type">void</span>)moveObjectFromIndex:(<span class="built_in">NSInteger</span>)sourceIndex toIndex:(<span class="built_in">NSInteger</span>)destinationIndex <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">9</span>_0);</span><br><span class="line">    </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 持有创建该SessionController的Adapter的ViewController</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>, <span class="keyword">nullable</span>, <span class="keyword">readonly</span>) <span class="built_in">UIViewController</span> *viewController;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 与collectionView 交互的上下文</span></span><br><span class="line"><span class="comment"> Use this property for accessing the collection size, dequeuing cells, reloading, inserting, deleting, etc.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>, <span class="keyword">nullable</span>, <span class="keyword">readonly</span>) <span class="type">id</span> &lt;IGListCollectionContext&gt; collectionContext;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 当前sessionController对应的session</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>, <span class="keyword">readonly</span>) <span class="built_in">NSInteger</span> section;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>, <span class="keyword">readonly</span>) <span class="type">BOOL</span> isFirstSection;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>, <span class="keyword">readonly</span>) <span class="type">BOOL</span> isLastSection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">UIEdgeInsets</span> inset;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">CGFloat</span> minimumLineSpacing;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">CGFloat</span> minimumInteritemSpacing;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>, <span class="keyword">nullable</span>) <span class="type">id</span> &lt;IGListSupplementaryViewSource&gt; supplementaryViewSource;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    section controller 的显示事件代理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>, <span class="keyword">nullable</span>) <span class="type">id</span> &lt;IGListDisplayDelegate&gt; displayDelegate;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    section controller 的working range事件代理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>, <span class="keyword">nullable</span>) <span class="type">id</span> &lt;IGListWorkingRangeDelegate&gt; workingRangeDelegate;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    section controller 的滚动事件代理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>, <span class="keyword">nullable</span>) <span class="type">id</span> &lt;IGListScrollDelegate&gt; scrollDelegate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>, <span class="keyword">nullable</span>) <span class="type">id</span>&lt;IGListTransitionDelegate&gt; transitionDelegate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>从上面上看外部主要通过didUpdateToObject将数据注入到IGListSectionController，然后通过<strong><strong>numberOfItems</strong></strong>，<strong><strong>sizeForItemAtIndex</strong></strong>，<strong><strong>cellForItemAtIndex</strong></strong>，<strong><strong>supplementaryViewSource</strong></strong> 分别指定item数量，尺寸，cell实例，SessionController的header，footer。以及通过collectionContext和UICollectionView进行交互，</p>
<p>我们最后来看下IGListCollectionContext，它也是一个比较重要的类，我们在确定sessionController的时候用得比较多。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">IGListCollectionContext</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">CGSize</span> containerSize;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">UIEdgeInsets</span> containerInset;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">UIEdgeInsets</span> adjustedContainerInset;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">CGSize</span> insetContainerSize;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">CGSize</span>)containerSizeForSectionController:(IGListSectionController *)sectionController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) IGListCollectionScrollingTraits scrollingTraits;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) IGListExperiment experiments;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSInteger</span>)indexForCell:(<span class="built_in">UICollectionViewCell</span> *)cell</span><br><span class="line">        sectionController:(IGListSectionController *)sectionController;</span><br><span class="line">- (<span class="keyword">nullable</span> __kindof <span class="built_in">UICollectionViewCell</span> *)cellForItemAtIndex:(<span class="built_in">NSInteger</span>)index</span><br><span class="line">                                             sectionController:(IGListSectionController *)sectionController;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSArray</span>&lt;<span class="built_in">UICollectionViewCell</span> *&gt; *)visibleCellsForSectionController:(IGListSectionController *)sectionController;</span><br><span class="line">- (<span class="built_in">NSArray</span>&lt;<span class="built_in">NSIndexPath</span> *&gt; *)visibleIndexPathsForSectionController:(IGListSectionController *) sectionController;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)deselectItemAtIndex:(<span class="built_in">NSInteger</span>)index</span><br><span class="line">          sectionController:(IGListSectionController *)sectionController</span><br><span class="line">                   animated:(<span class="type">BOOL</span>)animated;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)selectItemAtIndex:(<span class="built_in">NSInteger</span>)index</span><br><span class="line">        sectionController:(IGListSectionController *)sectionController</span><br><span class="line">                 animated:(<span class="type">BOOL</span>)animated</span><br><span class="line">           scrollPosition:(<span class="built_in">UICollectionViewScrollPosition</span>)scrollPosition;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (__kindof <span class="built_in">UICollectionViewCell</span> *)dequeueReusableCellOfClass:(Class)cellClass</span><br><span class="line">                                          withReuseIdentifier:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)reuseIdentifier</span><br><span class="line">                                         forSectionController:(IGListSectionController *)sectionController</span><br><span class="line">                                                      atIndex:(<span class="built_in">NSInteger</span>)index;</span><br><span class="line">- (__kindof <span class="built_in">UICollectionViewCell</span> *)dequeueReusableCellOfClass:(Class)cellClass</span><br><span class="line">                                         forSectionController:(IGListSectionController *)sectionController</span><br><span class="line">                                                      atIndex:(<span class="built_in">NSInteger</span>)index;</span><br><span class="line">- (__kindof <span class="built_in">UICollectionViewCell</span> *)dequeueReusableCellWithNibName:(<span class="built_in">NSString</span> *)nibName</span><br><span class="line">                                                           bundle:(<span class="keyword">nullable</span> <span class="built_in">NSBundle</span> *)bundle</span><br><span class="line">                                             forSectionController:(IGListSectionController *)sectionController</span><br><span class="line">                                                          atIndex:(<span class="built_in">NSInteger</span>)index;</span><br><span class="line">- (__kindof <span class="built_in">UICollectionViewCell</span> *)dequeueReusableCellFromStoryboardWithIdentifier:(<span class="built_in">NSString</span> *)identifier</span><br><span class="line">                                                              forSectionController:(IGListSectionController *)sectionController</span><br><span class="line">                                                                           atIndex:(<span class="built_in">NSInteger</span>)index;</span><br><span class="line">- (__kindof <span class="built_in">UICollectionReusableView</span> *)dequeueReusableSupplementaryViewOfKind:(<span class="built_in">NSString</span> *)elementKind</span><br><span class="line">                                                         forSectionController:(IGListSectionController *)sectionController</span><br><span class="line">                                                                        <span class="keyword">class</span>:(Class)viewClass</span><br><span class="line">                                                                      atIndex:(<span class="built_in">NSInteger</span>)index;</span><br><span class="line">- (__kindof <span class="built_in">UICollectionReusableView</span> *)dequeueReusableSupplementaryViewFromStoryboardOfKind:(<span class="built_in">NSString</span> *)elementKind</span><br><span class="line">                                                                             withIdentifier:(<span class="built_in">NSString</span> *)identifier</span><br><span class="line">                                                                       forSectionController:(IGListSectionController *)sectionController</span><br><span class="line">                                                                                    atIndex:(<span class="built_in">NSInteger</span>)index;</span><br><span class="line">- (__kindof <span class="built_in">UICollectionReusableView</span> *)dequeueReusableSupplementaryViewOfKind:(<span class="built_in">NSString</span> *)elementKind</span><br><span class="line">                                                         forSectionController:(IGListSectionController *)sectionController</span><br><span class="line">                                                                      nibName:(<span class="built_in">NSString</span> *)nibName</span><br><span class="line">                                                                       bundle:(<span class="keyword">nullable</span> <span class="built_in">NSBundle</span> *)bundle</span><br><span class="line">                                                                      atIndex:(<span class="built_in">NSInteger</span>)index;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)invalidateLayoutForSectionController:(IGListSectionController *)sectionController</span><br><span class="line">                                  completion:(<span class="keyword">nullable</span> <span class="type">void</span> (^)(<span class="type">BOOL</span> finished))completion;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)performBatchAnimated:(<span class="type">BOOL</span>)animated</span><br><span class="line">                     updates:(<span class="type">void</span> (^)(<span class="type">id</span>&lt;IGListBatchContext&gt; batchContext))updates</span><br><span class="line">                  completion:(<span class="keyword">nullable</span> <span class="type">void</span> (^)(<span class="type">BOOL</span> finished))completion;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)scrollToSectionController:(IGListSectionController *)sectionController</span><br><span class="line">                          atIndex:(<span class="built_in">NSInteger</span>)index</span><br><span class="line">                   scrollPosition:(<span class="built_in">UICollectionViewScrollPosition</span>)scrollPosition</span><br><span class="line">                         animated:(<span class="type">BOOL</span>)animated;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<h5 id="相关文章推荐"><a href="#相关文章推荐" class="headerlink" title="相关文章推荐"></a>相关文章推荐</h5><ul>
<li><a target="_blank" rel="noopener" href="https://chipengliu.github.io/2019/11/05/IGListKit/">IGListKit 源码解析</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5dc966bb6fb9a04a837ba7d7">IGListKit 源码解析</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/entry/5bee4514e51d4556a633c6c9">iOS — 快速上手 Instagram&#x2F;IGListKit 框架</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/entry/59e075256fb9a044fb06c569">大规模重构——重写 Instagram Feed 的经验之谈</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/entry/58650058128fe10069f8f92a">Instagram&#x2F;IGListKit 实践谈</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/entry/5c42fe08518825261c1b9808">IGListKit框架详细解析</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/3517619085f7">IGListKit框架解析</a></li>
<li><a target="_blank" rel="noopener" href="https://xiangwangfeng.com/2017/03/16/IGListKit-diff-%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%9E%90/">IGListKit diff 实现简析</a></li>
</ul>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/iOS-%E5%BC%80%E6%BA%90%E5%BA%93%E5%88%86%E6%9E%90/">iOS 开源库分析</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/iOS-开源库分析/">iOS 开源库分析</a>
  </div>

</div>



<div class="comments-count">
	
	  	<span></span>
		<a href="/2019/12/08/IGKListKit-使用及源码分析/#comments" class="ds-thread-count comments-count-link" data-thread-key="2019/12/08/IGKListKit-使用及源码分析/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/12/06/MJRefresh-使用及源码分析/" title="MJRefresh 使用及源码分析" itemprop="url">MJRefresh 使用及源码分析</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Edgar" target="_blank" itemprop="author">Edgar</a>
		
  <p class="article-time">
    <time datetime="2019-12-05T17:23:45.000Z" itemprop="datePublished"> Published 2019-12-06</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h5 id="开源库信息："><a href="#开源库信息：" class="headerlink" title="开源库信息："></a>开源库信息：</h5><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/CoderMJLee/MJRefresh">MJRefresh</a></li>
</ul>
<p>MJRefresh是目前用得比较多的下拉刷新，上拉加载开源库了，它支持<strong><strong>UIScrollView</strong></strong>、<strong><strong>UITableView</strong></strong>、<strong><strong>UICollectionView</strong></strong>、<strong><strong>UIWebView</strong></strong></p>
<p>整个类结构图如下：</p>
<p><img src="/2019/12/06/MJRefresh-%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/0000001.png"></p>
<p>下面是在网上找的比较好的一张图，也附带给大家</p>
<p><img src="/2019/12/06/MJRefresh-%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/0000002.png"></p>
<p>在开始讲解MJRefresh源码之前大家最好对UIScrollView的各个尺寸数据有个明确的认识，下面是在网上找的一个比较好的图大家可以对照着这个来看：</p>
<p><img src="/2019/12/06/MJRefresh-%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/0000003.png"></p>
<p><strong><strong>MJRefreshComponent</strong></strong> </p>
<p>MJRefreshComponent是所有上拉下拉控件的基类，它主要是通过KVO实现对scrollView <strong><strong>contentOffset</strong></strong>，<strong><strong>contentSize</strong></strong>，以及scrollView 手势状态也就是: self.scrollView.panGestureRecognizer <strong><strong>state</strong></strong>的监听，来分别触发下面的对应方法，这些方法在不同的子类都有自己的实现，这个后面会具体展开介绍：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// scrollView ContentOffset改变的时候触发</span></span><br><span class="line">- (<span class="type">void</span>)scrollViewContentOffsetDidChange:(<span class="built_in">NSDictionary</span> *)change&#123;&#125;</span><br><span class="line"><span class="comment">// scrollView ContentSize改变的时候触发</span></span><br><span class="line">- (<span class="type">void</span>)scrollViewContentSizeDidChange:(<span class="built_in">NSDictionary</span> *)change&#123;&#125;</span><br><span class="line"><span class="comment">// scrollView 手势状态改变的时候触发</span></span><br><span class="line">- (<span class="type">void</span>)scrollViewPanStateDidChange:(<span class="built_in">NSDictionary</span> *)change&#123;&#125;</span><br></pre></td></tr></table></figure>

<p><strong><strong>MJRefreshHeader</strong></strong></p>
<p>MJRefreshHeader主要负责通过ContentOffset的变化以及是否正在滑动状态来确定上拉，下滑控件的状态。并负责上一次刷新时间的记录。</p>
<p><strong><strong>MJRefreshStateHeader</strong></strong></p>
<p>MJRefreshStateHeader 负责状态文本以及上一次更新时间文本的显示。</p>
<p><strong><strong>MJRefreshNormalHeader</strong></strong></p>
<p>MJRefreshNormalHeader 负责箭头和加载菊花的状态显示。</p>
<p><strong><strong>MJRefreshGifHeader</strong></strong></p>
<p>MJRefreshGifHeader 负责加载Gif图片的状态控制</p>
<p><strong><strong>MJRefreshFooter</strong></strong></p>
<p>MJRefreshFooter 主要负责上拉控件状态的维护</p>
<p><strong><strong>MJRefreshAutoFooter</strong></strong></p>
<p>MJRefreshAutoFooter 负责维护ContentOffset 与 state的对应关系。</p>
<p><strong><strong>MJRefreshAutoStateFooter</strong></strong></p>
<p>MJRefreshAutoStateFooter 主要负责状态文本的控制。</p>
<p><strong><strong>MJRefreshAutoNormalFooter</strong></strong></p>
<p>MJRefreshAutoNormalFooter 主要负责加载菊花的状态控制</p>
<p><strong><strong>MJRefreshAutoGifFooter</strong></strong></p>
<p>MJRefreshAutoGifFooter 主要负责Gif类型的加载动画控制</p>
<p><strong><strong>MJRefreshBackStateFooter</strong></strong></p>
<p>MJRefreshBackStateFooter 负责自动返回类型上拉控件的状态文本控制。</p>
<p><strong><strong>MJRefreshBackNormalFooter</strong></strong></p>
<p>MJRefreshBackNormalFooter负责自动返回类型上拉控件的加载菊花状态控制。</p>
<p><strong><strong>MJRefreshBackGifFooter</strong></strong></p>
<p>MJRefreshBackGifFooter 负责自动返回类型上拉控件加载Gif动画的播放控制。</p>
<p><strong><strong>MJRefreshConst</strong></strong></p>
<p>MJRefreshConst 里面放置的是整个MJRefresh的常量以及关键宏定义。</p>
<p><strong><strong>UIScrollView+MJExtension</strong></strong></p>
<p>UIScrollView+MJExtension存放的是UIScrollView尺寸位置数据的便捷方法</p>
<p><strong><strong>UIView+MJExtension</strong></strong><br>UIView+MJExtension 和 UIScrollView+MJExtension类似存放的是UIView尺寸位置数据的便捷方法</p>
<p><strong><strong>UIScrollView+MJRefresh</strong></strong></p>
<p>UIScrollView+MJRefresh 中通过关联属性方式为UIScrollView添加了MJRefreshHeader和MJRefreshFooter</p>
<p><strong><strong>NSBundle+MJRefresh</strong></strong></p>
<p>NSBundle+MJRefresh 是 MJRefresh 内的文本以及图片资源获取方法。</p>
<p><strong><strong>MJRefreshConfig</strong></strong><br>用于存放MJRefresh的配置的类，目前只存放languageCode，暂时没多大用处。</p>
<p>其实整个大的方向还是遵循</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">手动滑动S<span class="function"><span class="title">crollView</span> --&gt;</span> S<span class="function"><span class="title">crollView</span> ContentOffset / 滑动状态 发生变化 --&gt;</span> MJR<span class="function"><span class="title">efresh</span> 状态发生变化 --&gt;</span> 触发对应的改变，比如上一次更新时间，状态文本，菊花状态等等。</span><br></pre></td></tr></table></figure>

<p>下面就顺着这个思路来对MJRefresh源码进行解析：</p>
<h5 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h5><p><strong><strong>MJRefreshComponent</strong></strong></p>
<p><strong><strong>状态常量的定义</strong></strong></p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">/** 刷新控件的状态 */</span></span><br><span class="line">typedef NS_ENUM(NSInteger, MJRefreshState) &#123;</span><br><span class="line">    <span class="regexp">/** 普通闲置状态 */</span></span><br><span class="line">    MJRefreshStateIdle = <span class="number">1</span>,</span><br><span class="line">    <span class="regexp">/** 松开就可以进行刷新的状态 */</span></span><br><span class="line">    MJRefreshStatePulling,</span><br><span class="line">    <span class="regexp">/** 正在刷新中的状态 */</span></span><br><span class="line">    MJRefreshStateRefreshing,</span><br><span class="line">    <span class="regexp">/** 即将刷新的状态 */</span></span><br><span class="line">    MJRefreshStateWillRefresh,</span><br><span class="line">    <span class="regexp">/** 所有数据加载完毕，没有更多的数据了 */</span></span><br><span class="line">    MJRefreshStateNoMoreData</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong><strong>状态改变的回调类型定义</strong></strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 进入刷新状态的回调 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">void</span> (^MJRefreshComponentRefreshingBlock)(<span class="built_in">void</span>);</span><br><span class="line"><span class="comment">/** 开始刷新后的回调(进入刷新状态后的回调) */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">void</span> (^MJRefreshComponentBeginRefreshingCompletionBlock)(<span class="built_in">void</span>);</span><br><span class="line"><span class="comment">/** 结束刷新后的回调 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">void</span> (^MJRefreshComponentEndRefreshingCompletionBlock)(<span class="built_in">void</span>);</span><br></pre></td></tr></table></figure>

<p><strong><strong>关键属性</strong></strong></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 刷新状态 一般交给子类内部实现 */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) MJRefreshState state;</span><br><span class="line"><span class="comment">/** 记录scrollView刚开始的inset */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">UIEdgeInsets</span> scrollViewOriginalInset;</span><br><span class="line"><span class="comment">/** 父控件 */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">UIScrollView</span> *scrollView;</span><br><span class="line"><span class="comment">/** 拉拽的百分比(交给子类重写) */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">CGFloat</span> pullingPercent;</span><br><span class="line"><span class="comment">/** 根据拖拽比例自动切换透明度 */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>, <span class="keyword">getter</span>=isAutomaticallyChangeAlpha) <span class="type">BOOL</span> automaticallyChangeAlpha;</span><br><span class="line"><span class="comment">/** 是否正在刷新 */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">getter</span>=isRefreshing) <span class="type">BOOL</span> refreshing;</span><br></pre></td></tr></table></figure>

<p><strong><strong>状态触发，及状态关键节点回调</strong></strong></p>
<p>状态触发：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 进入刷新状态 */</span></span><br><span class="line">- (<span class="built_in">void</span>)beginRefreshing;</span><br><span class="line">- (<span class="built_in">void</span>)beginRefreshingWithCompletionBlock:(<span class="built_in">void</span> (^)(<span class="built_in">void</span>))completionBlock;</span><br><span class="line"><span class="comment">/** 结束刷新状态 */</span></span><br><span class="line">- (<span class="built_in">void</span>)endRefreshing;</span><br><span class="line">- (<span class="built_in">void</span>)endRefreshingWithCompletionBlock:(<span class="built_in">void</span> (^)(<span class="built_in">void</span>))completionBlock;</span><br></pre></td></tr></table></figure>
<p>状态关键节点回调:</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 正在刷新的回调 */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">copy</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nullable</span>) MJRefreshComponentRefreshingBlock refreshingBlock;</span><br><span class="line"><span class="comment">/** 开始刷新后的回调(进入刷新状态后的回调) */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">copy</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nullable</span>) MJRefreshComponentBeginRefreshingCompletionBlock beginRefreshingCompletionBlock;</span><br><span class="line"><span class="comment">/** 带动画的结束刷新的回调 */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">copy</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nullable</span>) MJRefreshComponentEndRefreshingCompletionBlock endRefreshingAnimateCompletionBlock;</span><br><span class="line"><span class="comment">/** 结束刷新的回调 */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">copy</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nullable</span>) MJRefreshComponentEndRefreshingCompletionBlock endRefreshingCompletionBlock;</span><br></pre></td></tr></table></figure>

<p><strong><strong>供给子类实现的方法</strong></strong></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 初始化 */</span></span><br><span class="line">- (<span class="type">void</span>)prepare <span class="built_in">NS_REQUIRES_SUPER</span>;</span><br><span class="line"><span class="comment">/** 摆放子控件frame */</span></span><br><span class="line">- (<span class="type">void</span>)placeSubviews <span class="built_in">NS_REQUIRES_SUPER</span>;</span><br><span class="line"><span class="comment">/** 当scrollView的contentOffset发生改变的时候调用 */</span></span><br><span class="line">- (<span class="type">void</span>)scrollViewContentOffsetDidChange:(<span class="keyword">nullable</span> <span class="built_in">NSDictionary</span> *)change <span class="built_in">NS_REQUIRES_SUPER</span>;</span><br><span class="line"><span class="comment">/** 当scrollView的contentSize发生改变的时候调用 */</span></span><br><span class="line">- (<span class="type">void</span>)scrollViewContentSizeDidChange:(<span class="keyword">nullable</span> <span class="built_in">NSDictionary</span> *)change <span class="built_in">NS_REQUIRES_SUPER</span>;</span><br><span class="line"><span class="comment">/** 当scrollView的拖拽状态发生改变的时候调用 */</span></span><br><span class="line">- (<span class="type">void</span>)scrollViewPanStateDidChange:(<span class="keyword">nullable</span> <span class="built_in">NSDictionary</span> *)change <span class="built_in">NS_REQUIRES_SUPER</span>;</span><br></pre></td></tr></table></figure>


<p>我们截取官方Demo例子作为一个场景来对整个代码解析:</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">__<span class="keyword">unsafe_unretained</span> <span class="built_in">UITableView</span> *tableView = <span class="keyword">self</span>.tableView;</span><br><span class="line">tableView.mj_header= [MJRefreshNormalHeader headerWithRefreshingBlock:^&#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<p>当然我们会先将注意力聚焦在MJRefreshComponent。</p>
<p><strong><strong>1. MJRefreshComponent初始化</strong></strong></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)initWithFrame:(<span class="built_in">CGRect</span>)frame &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="variable language_">super</span> initWithFrame:frame]) &#123;</span><br><span class="line">        <span class="comment">// 准备工作</span></span><br><span class="line">        [<span class="keyword">self</span> prepare];</span><br><span class="line">        <span class="comment">// 默认是普通状态</span></span><br><span class="line">        <span class="keyword">self</span>.state = MJRefreshStateIdle;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="type">void</span>)prepare &#123;</span><br><span class="line">    <span class="comment">// 基本属性</span></span><br><span class="line">    <span class="keyword">self</span>.autoresizingMask = <span class="built_in">UIViewAutoresizingFlexibleWidth</span>;</span><br><span class="line">    <span class="keyword">self</span>.backgroundColor = [<span class="built_in">UIColor</span> clearColor];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这部分的工作主要是初始状态的设置。在设置状态的时候会调用state的setter。这里面会触发布局,这也是为什么autoresizingMask一定要在prepare进行设置的原因：</p>
<figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">- (void)<span class="built_in">set</span>State:(MJRefreshState)<span class="keyword">state</span>&#123;</span><br><span class="line">    _state = <span class="keyword">state</span>;</span><br><span class="line">    // 加入主队列的目的是等<span class="built_in">set</span>State:方法调用完毕、设置完文字后再去布局子控件</span><br><span class="line">    MJRefreshDispatchAsyncOnMainQueue([<span class="literal">self</span> <span class="built_in">set</span>NeedsLayout];)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于MJRefreshComponent这里面，placeSubviews是空的。主要是对子类placeSubviews的触发。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">void</span>)layoutSubviews &#123;</span><br><span class="line"><span class="string">    [self placeSubviews]</span>;</span><br><span class="line"><span class="string">    [super layoutSubviews]</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以初始化过程主要完成如下任务：</p>
<ul>
<li>调用prepare做一些准备工作</li>
<li>设置MJRefresh的状态为Idle状态</li>
<li>触发布局</li>
</ul>
<p><strong><strong>2. MJRefreshComponent添加到父控件：</strong></strong></p>
<p>新建MJRefreshComponent子类成功后会通过<strong><strong>setMj_header</strong></strong>添加到UIScrollView或者它的子类上。</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">- (void)setMj_header:(MJRefreshHeader *)mj_header &#123;</span><br><span class="line">    if (mj_header != self.mj_header) &#123;</span><br><span class="line">        <span class="comment">// 删除旧的，添加新的</span></span><br><span class="line">        <span class="selector-attr">[self.mj_header removeFromSuperview]</span>;</span><br><span class="line">        <span class="selector-attr">[self insertSubview:mj_header atIndex:0]</span>;</span><br><span class="line">        <span class="comment">// 存储新的</span></span><br><span class="line">        <span class="built_in">objc_setAssociatedObject</span>(self, &amp;MJRefreshHeaderKey,</span><br><span class="line">                                 mj_header, OBJC_ASSOCIATION_RETAIN);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在调用insertSubview 的时候 MJRefreshComponent的 willMoveToSuperview:</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">- (void)willMoveToSuperview:<span class="type"></span>(UIView *)<span class="keyword">new</span><span class="type">Superview</span> &#123;</span><br><span class="line">    [<span class="keyword">super</span> willMoveToSuperview:<span class="type">newSuperview</span>];</span><br><span class="line">    <span class="comment">// 如果不是UIScrollView，不做任何事情</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">new</span><span class="type">Superview</span> &amp;&amp; ![<span class="keyword">new</span><span class="type">Superview</span> isKindOfClass:<span class="type"></span>[UIScrollView class]]) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 旧的父控件移除监听</span></span><br><span class="line">    [self removeObservers];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">new</span><span class="type">Superview</span>) &#123; <span class="comment">// 新的父控件</span></span><br><span class="line">        <span class="comment">// 记录UIScrollView</span></span><br><span class="line">        _scrollView = (UIScrollView *)<span class="keyword">new</span><span class="type">Superview</span>;</span><br><span class="line">        <span class="comment">// 设置宽度</span></span><br><span class="line">        self.mj_w = _scrollView.mj_w;</span><br><span class="line">        <span class="comment">// 设置位置</span></span><br><span class="line">        self.mj_x = -_scrollView.mj_insetL;</span><br><span class="line">        <span class="comment">// 设置永远支持垂直弹簧效果</span></span><br><span class="line">        _scrollView.alwaysBounceVertical = YES;</span><br><span class="line">        <span class="comment">// 记录UIScrollView最开始的contentInset</span></span><br><span class="line">        _scrollViewOriginalInset = _scrollView.mj_inset;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 添加监听</span></span><br><span class="line">        [self addObservers];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>willMoveToSuperview 中会先移除对旧父控件的关键事件监听，监听新的父UIScollView的关键事件，并记录下UIScrollView最开始的contentInset。</p>
<p>addObservers 方法中主要通过KVO方式让MJRefreshComponent监听父控件scrollView的ContentOffset，ContentSize 以及<br>scrollView的手势状态。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)addObservers &#123;</span><br><span class="line">    <span class="built_in">NSKeyValueObservingOptions</span> options = <span class="built_in">NSKeyValueObservingOptionNew</span> | <span class="built_in">NSKeyValueObservingOptionOld</span>;</span><br><span class="line">    [<span class="keyword">self</span>.scrollView addObserver:<span class="keyword">self</span> forKeyPath:MJRefreshKeyPathContentOffset options:options context:<span class="literal">nil</span>];</span><br><span class="line">    [<span class="keyword">self</span>.scrollView addObserver:<span class="keyword">self</span> forKeyPath:MJRefreshKeyPathContentSize options:options context:<span class="literal">nil</span>];</span><br><span class="line">    <span class="keyword">self</span>.pan = <span class="keyword">self</span>.scrollView.panGestureRecognizer;</span><br><span class="line">    [<span class="keyword">self</span>.pan addObserver:<span class="keyword">self</span> forKeyPath:MJRefreshKeyPathPanState options:options context:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一旦监听的变量发生变化那么就会到observeValueForKeyPath中进行处理：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="type">id</span>)object change:(<span class="built_in">NSDictionary</span> *)change context:(<span class="type">void</span> *)context &#123;</span><br><span class="line">    <span class="comment">// 遇到这些情况就直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>.userInteractionEnabled) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这个就算看不见也需要处理</span></span><br><span class="line">    <span class="keyword">if</span> ([keyPath isEqualToString:MJRefreshKeyPathContentSize]) &#123;</span><br><span class="line">        [<span class="keyword">self</span> scrollViewContentSizeDidChange:change];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 看不见</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.hidden) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> ([keyPath isEqualToString:MJRefreshKeyPathContentOffset]) &#123;</span><br><span class="line">        [<span class="keyword">self</span> scrollViewContentOffsetDidChange:change];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([keyPath isEqualToString:MJRefreshKeyPathPanState]) &#123;</span><br><span class="line">        [<span class="keyword">self</span> scrollViewPanStateDidChange:change];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)scrollViewContentOffsetDidChange:(<span class="built_in">NSDictionary</span> *)change&#123;&#125;</span><br><span class="line">- (<span class="type">void</span>)scrollViewContentSizeDidChange:(<span class="built_in">NSDictionary</span> *)change&#123;&#125;</span><br><span class="line">- (<span class="type">void</span>)scrollViewPanStateDidChange:(<span class="built_in">NSDictionary</span> *)change&#123;&#125;</span><br><span class="line"></span><br><span class="line">````</span><br><span class="line"></span><br><span class="line">其中ContentOffset 以及scrollView的手势状态 只有在可见的时候才会触发子类对应的方法。</span><br><span class="line"></span><br><span class="line">****<span class="number">3.</span> 状态的管理：****</span><br><span class="line"></span><br><span class="line">MJRefreshComponent 中的setState主要是提供给子类设置的，但是在MJRefreshComponent中的beginRefreshing以及endRefreshing也会触发MJRefresh的状态，beginRefreshing会将状态设置为MJRefreshStateRefreshing，endRefreshing中会将状态设置为MJRefreshStateIdle。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><p>(void)beginRefreshing {<br>  [UIView animateWithDuration:MJRefreshFastAnimationDuration animations:^{<br>  self.alpha &#x3D; 1.0;<br>  }];<br>  self.pullingPercent &#x3D; 1.0;<br>  &#x2F;&#x2F; 只要正在刷新，就完全显示<br>  if (self.window) {<br>  self.state &#x3D; MJRefreshStateRefreshing;<br>  } else {<br>  &#x2F;&#x2F;…..<br>  }<br>}</p>
</li>
<li><p>(void)endRefreshing {<br>  MJRefreshDispatchAsyncOnMainQueue(self.state &#x3D; MJRefreshStateIdle;)<br>}</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="strong">****</span>4. 下拉进度的管理：<span class="strong">****</span></span><br><span class="line"></span><br><span class="line">和setState一样下拉进度也是受contentOffset影响的，所以下拉进度的设置也是提供给子类调用的。下拉进度的改变会导致下拉控件透明度的同步变化。</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>(void)setPullingPercent:(CGFloat)pullingPercent {<br>  _pullingPercent &#x3D; pullingPercent;<br>  if (self.isRefreshing) return;<br>  if (self.isAutomaticallyChangeAlpha) {<br>  self.alpha &#x3D; pullingPercent;<br>  }<br>}</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="strong">****</span>MJRefreshStateHeader<span class="strong">****</span></span><br><span class="line"></span><br><span class="line">MJRefreshComponent像是一个没有灵魂的父类，它只负责监听scrollView的contentOffset，contentSize，以及触摸状态的变化，将这些变化传递给子类。</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>(void)scrollViewContentOffsetDidChange:(NSDictionary *)change {</p>
<p>  [super scrollViewContentOffsetDidChange:change];<br>  &#x2F;&#x2F; 在刷新的refreshing状态<br>  if (self.state &#x3D;&#x3D; MJRefreshStateRefreshing) {<br>  [self resetInset];<br>  return;<br>  }<br>  &#x2F;&#x2F; 跳转到下一个控制器时，contentInset可能会变, 这时候将最初的contentInset保存在_scrollViewOriginalInset<br>  _scrollViewOriginalInset &#x3D; self.scrollView.mj_inset;</p>
<p>  &#x2F;&#x2F; 当前的contentOffset<br>  CGFloat offsetY &#x3D; self.scrollView.mj_offsetY;<br>  &#x2F;&#x2F; 头部控件刚好出现的offsetY，这里由于UIScrollView默认是贴着可见的边缘，也就是导航栏的底部。所以可以用- self.scrollViewOriginalInset.top来表示。<br>  CGFloat happenOffsetY &#x3D; - self.scrollViewOriginalInset.top;</p>
<p>  &#x2F;&#x2F; 如果是向上滚动到看不见头部控件，直接返回<br>  &#x2F;&#x2F; &gt;&#x3D; -&gt; &gt;<br>  if (offsetY &gt; happenOffsetY) return;</p>
<p>  &#x2F;&#x2F; 普通 和 即将刷新 的临界点，normal2pullingOffsetY 表示MJRefreshHeader完全露出来的位置<br>  CGFloat normal2pullingOffsetY &#x3D; happenOffsetY - self.mj_h;<br>  &#x2F;&#x2F; 这个是MJRefreshHeader露出来的百分比<br>  CGFloat pullingPercent &#x3D; (happenOffsetY - offsetY) &#x2F; self.mj_h;</p>
<p>  if (self.scrollView.isDragging) { &#x2F;&#x2F; 如果正在拖拽<br>  self.pullingPercent &#x3D; pullingPercent;<br>  &#x2F;&#x2F; 如果当前是空闲状态，并且偏移量超过了完全露出来的距离，但是由于当前正在处于拖拽状态则状态还是MJRefreshStatePulling<br>  if (self.state &#x3D;&#x3D; MJRefreshStateIdle &amp;&amp; offsetY &lt; normal2pullingOffsetY) {<br>      &#x2F;&#x2F; 转为即将刷新状态<br>      self.state &#x3D; MJRefreshStatePulling;<br>  &#x2F;&#x2F;如果当前处于MJRefreshStatePulling状态，偏移量小于完全露出来的距离，那么状态改为MJRefreshStateIdle<br>  } else if (self.state &#x3D;&#x3D; MJRefreshStatePulling &amp;&amp; offsetY &gt;&#x3D; normal2pullingOffsetY) {<br>      &#x2F;&#x2F; 转为普通状态<br>      self.state &#x3D; MJRefreshStateIdle;<br>  }<br>  &#x2F;&#x2F;如果松收那么就切换到MJRefreshStateRefreshing状态<br>  } else if (self.state &#x3D;&#x3D; MJRefreshStatePulling) {&#x2F;&#x2F; 即将刷新 &amp;&amp; 手松开<br>  &#x2F;&#x2F; 开始刷新<br>  [self beginRefreshing];<br>  } else if (pullingPercent &lt; 1) {<br>  self.pullingPercent &#x3D; pullingPercent;<br>  }</p>
</li>
</ul>
<p>}</p>
<figure class="highlight pf"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">scrollViewContentOffsetDidChange 主要负责设置MJRefreshHeader的<span class="keyword">state</span>。影响到<span class="keyword">state</span>的有两方面原因：</span><br></pre></td></tr></table></figure>
<ol>
<li>是否处于拖拽状态</li>
<li>当前UIScrollView的offset与下拉头完全露出来的位置的关系<figure class="highlight erlang"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">如果当前是空闲状态，并且偏移量超过了下拉头部完全露出来的距离，但是由于当前正在处于拖拽状态则状态还是MJRefreshStatePulling，在处于拖拽状态下，如果当前处于MJRefreshStatePulling状态，偏移量小于完全露出来的距离，那么状态改为MJRefreshStateIdle。如果松手那么就切换到MJRefreshStateRefreshing状态。并触发<span class="keyword">begin</span>Refreshing调用上层业务进行刷新。</span><br><span class="line"></span><br><span class="line">下面我们来看下状态的设置：</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>(void)setState:(MJRefreshState)state {<br>  MJRefreshCheckState<br>  &#x2F;&#x2F; 根据状态做事情<br>  if (state &#x3D;&#x3D; MJRefreshStateIdle) {<br>  if (oldState !&#x3D; MJRefreshStateRefreshing) return;<br><br>  &#x2F;&#x2F; 保存刷新时间<br>  [[NSUserDefaults standardUserDefaults] setObject:[NSDate date] forKey:self.lastUpdatedTimeKey];<br>  [[NSUserDefaults standardUserDefaults] synchronize];<br><br>  &#x2F;&#x2F; 恢复inset和offset<br>  [UIView animateWithDuration:MJRefreshSlowAnimationDuration animations:^{<br>      self.scrollView.mj_insetT +&#x3D; self.insetTDelta;<br>      if (self.endRefreshingAnimateCompletionBlock) {<br>          self.endRefreshingAnimateCompletionBlock();<br>      }<br>      &#x2F;&#x2F; 自动调整透明度<br>      if (self.isAutomaticallyChangeAlpha) self.alpha &#x3D; 0.0;<br>  } completion:^(BOOL finished) {<br>      self.pullingPercent &#x3D; 0.0;<br>      if (self.endRefreshingCompletionBlock) {<br>          self.endRefreshingCompletionBlock();<br>      }<br>  }];<br>  } else if (state &#x3D;&#x3D; MJRefreshStateRefreshing) {<br>  MJRefreshDispatchAsyncOnMainQueue({<br>      [UIView animateWithDuration:MJRefreshFastAnimationDuration animations:^{<br>          if (self.scrollView.panGestureRecognizer.state !&#x3D; UIGestureRecognizerStateCancelled) {<br>              CGFloat top &#x3D; self.scrollViewOriginalInset.top + self.mj_h;<br>              &#x2F;&#x2F; 增加滚动区域top<br>              self.scrollView.mj_insetT &#x3D; top;<br>              &#x2F;&#x2F; 设置滚动位置<br>              CGPoint offset &#x3D; self.scrollView.contentOffset;<br>              offset.y &#x3D; -top;<br>              [self.scrollView setContentOffset:offset animated:NO];<br>          }<br>      } completion:^(BOOL finished) {<br>          [self executeRefreshingCallback];<br>      }];<br>  })<br>  }</li>
</ul>
<p>}</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">如果上一次为MJRefreshStateRefreshing，当前状态为MJRefreshStateIdle，表示一次刷新结束。这时候会将当前时间记录为上一次刷新时间记录在本地。并且以动画的形式将header隐藏，并在动画结束以及完全隐藏的时候调用<span class="strong">****</span>endRefreshingAnimateCompletionBlock<span class="strong">****</span>，<span class="strong">****</span>endRefreshingCompletionBlock<span class="strong">****</span>，如果状态要设置为MJRefreshStateRefreshing，那么需要通过setContentOffset将头部显示出来。并在完成后调用executeRefreshingCallback。</span><br><span class="line"></span><br><span class="line">也就是说在进入refreshing状态的时候会调用refreshingBlock以及beginRefreshingCompletionBlock，在回到idle状态的时候会调用endRefreshingAnimateCompletionBlock以及endRefreshingCompletionBlock。</span><br><span class="line"></span><br><span class="line"><span class="strong">****</span>MJRefreshAutoFooter<span class="strong">****</span></span><br><span class="line"></span><br><span class="line">我们看到MJRefreshFooter有两类MJRefreshAutoFooter以及MJRefreshBackFooter，MJRefreshAutoFooter的特点是在内容超过一个屏幕的时候，不松手的情况下只要footer露出来了就会自动启动刷新，这会持续autoTriggerTimes次，当然我们可以设置autoTriggerTimes为负数来支持无限次自动加载。在松手的情况下则会在指定的条件下触发刷新。</span><br><span class="line">MJRefreshBackFooter的footer只会出现在UIScrollView的底部，并且只有在松手的情况下才会启动刷新。</span><br><span class="line"></span><br><span class="line">我们先来看下MJRefreshAutoFooter，在新建MJRefreshAutoFooter的时候会先调用prepare方法：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><p>(void)prepare {<br>  [super prepare];<br>  &#x2F;&#x2F; 默认底部控件100%出现时才会自动刷新<br>  self.triggerAutomaticallyRefreshPercent &#x3D; 1.0;<br>  &#x2F;&#x2F; 设置为默认状态<br>  self.automaticallyRefresh &#x3D; YES;<br>  &#x2F;&#x2F; 自动刷新的次数<br>  self.autoTriggerTimes &#x3D; 1;<br>}</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">在prepare方法中设置了触发自动刷新的百分比，以及将触发状态设置为自动刷新状态，<span class="built_in">auto</span>TriggerTimes被设置为<span class="number">1</span>次。<span class="built_in">auto</span>TriggerTimes是上拉不松手的情况下触发自动刷新的次数超过这个次数，上拉只有松手的情况下才会触发刷新，如果要自动刷新次数不受限那么将<span class="built_in">auto</span>TriggerTimes设置为<span class="number">-1</span>即可。</span><br><span class="line"></span><br><span class="line">创建好后在我们将MJRefreshAutoFooter添加到UIScrollView上面的时候会调用willMoveToSuperview，这时候ContentInset Bottom会相应地增加mj_h，如果newSuperview = nil 表示从父控件中移除，ContentInset Bottom会减少mj_h。</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>(void)willMoveToSuperview:(UIView *)newSuperview {<br>  [super willMoveToSuperview:newSuperview];<br>  if (newSuperview) { &#x2F;&#x2F; 新的父控件<br>  if (self.hidden &#x3D;&#x3D; NO) {<br>      self.scrollView.mj_insetB +&#x3D; self.mj_h;<br>  }<br>  &#x2F;&#x2F; 设置位置<br>  self.mj_y &#x3D; _scrollView.mj_contentH;<br>  } else { &#x2F;&#x2F; 被移除了<br>  if (self.hidden &#x3D;&#x3D; NO) {<br>      self.scrollView.mj_insetB -&#x3D; self.mj_h;<br>  }<br>  }<br>}</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">mj_h是在MJRefreshFooter prepare方法中设置的。</span><br><span class="line"></span><br><span class="line">一旦<span class="built_in">UIScrollView</span>完成数据的加载就会触发ContentSize发生变化，scrollViewContentSizeDidChange会被调用，这时候MJRefreshAutoFooter的位置就会重新被设置，它会被追加到<span class="built_in">UIScrollView</span> 内容的最底部，注意不是<span class="built_in">UIScrollView</span>的最底部。</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>(void)scrollViewContentSizeDidChange:(NSDictionary *)change {<br>  [super scrollViewContentSizeDidChange:change];<br>  &#x2F;&#x2F; 设置位置<br>  self.mj_y &#x3D; self.scrollView.mj_contentH + self.ignoredScrollViewContentInsetBottom;<br>}</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">在内容超过一个屏幕后，如果我们向上拉页面，拉到<span class="selector-tag">footer</span>显示出triggerAutomaticallyRefreshPercent百分比后即使我们不松手的情况下也会自动触发beginRefreshing进行刷新。</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>(void)scrollViewContentOffsetDidChange:(NSDictionary *)change {<br>  [super scrollViewContentOffsetDidChange:change];</p>
<p>  if (self.state !&#x3D; MJRefreshStateIdle || !self.automaticallyRefresh || self.mj_y &#x3D;&#x3D; 0) return;</p>
<p>  if (_scrollView.mj_insetT + _scrollView.mj_contentH &gt; _scrollView.mj_h) { &#x2F;&#x2F; 内容超过一个屏幕<br>  &#x2F;&#x2F; 这里的_scrollView.mj_contentH替换掉self.mj_y更为合理<br>  if (_scrollView.mj_offsetY &gt;&#x3D; _scrollView.mj_contentH - _scrollView.mj_h + self.mj_h * self.triggerAutomaticallyRefreshPercent + _scrollView.mj_insetB - self.mj_h) {<br>      &#x2F;&#x2F; 防止手松开时连续调用<br>      CGPoint old &#x3D; [change[@”old”] CGPointValue];<br>      CGPoint new &#x3D; [change[@”new”] CGPointValue];<br>      if (new.y &lt;&#x3D; old.y) return;<br><br>      if (_scrollView.isDragging) {<br>          self.triggerByDrag &#x3D; YES;<br>      }<br>      &#x2F;&#x2F; 当底部刷新控件完全出现时，才刷新<br>      [self beginRefreshing];<br>  }<br>  }</p>
</li>
</ul>
<p>}</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">如果我们手松开的时候,如果不够一个屏幕，那么在拉到offsetY超过顶部insetTop的时候开始刷新，如果超出一个屏幕，也会在拉到见到<span class="selector-tag">footer</span>的时候开始刷新。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><p>(void)scrollViewPanStateDidChange:(NSDictionary *)change {<br>  [super scrollViewPanStateDidChange:change];<br>  if (self.state !&#x3D; MJRefreshStateIdle) return;<br>  UIGestureRecognizerState panState &#x3D; _scrollView.panGestureRecognizer.state;<br>  switch (panState) {<br>  &#x2F;&#x2F; 手松开<br>  case UIGestureRecognizerStateEnded: {<br>      if (_scrollView.mj_insetT + _scrollView.mj_contentH &lt;&#x3D; _scrollView.mj_h) {  &#x2F;&#x2F; 不够一个屏幕<br>          if (_scrollView.mj_offsetY &gt;&#x3D; - _scrollView.mj_insetT) { &#x2F;&#x2F; 向上拽<br>              self.triggerByDrag &#x3D; YES;<br>              [self beginRefreshing];<br>          }<br>      } else { &#x2F;&#x2F; 超出一个屏幕<br>          if (_scrollView.mj_offsetY &gt;&#x3D; _scrollView.mj_contentH + _scrollView.mj_insetB - _scrollView.mj_h) {<br>              self.triggerByDrag &#x3D; YES;<br>              [self beginRefreshing];<br>          }<br>      }<br>  } break;<br>  case UIGestureRecognizerStateBegan: {<br>      [self resetTriggerTimes];<br>  } break;<br>  default: break;<br>  }<br>}</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">状态设置：</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>(void)setState:(MJRefreshState)state {<br>  MJRefreshCheckState</p>
<p>  if (state &#x3D;&#x3D; MJRefreshStateRefreshing) {<br>  [self executeRefreshingCallback];<br>  } else if (state &#x3D;&#x3D; MJRefreshStateNoMoreData || state &#x3D;&#x3D; MJRefreshStateIdle) {<br>  if (self.triggerByDrag) {<br>      if (!self.unlimitedTrigger) {<br>          self.leftTriggerTimes -&#x3D; 1;<br>      }<br>      self.triggerByDrag &#x3D; NO;<br>  }<br>  if (MJRefreshStateRefreshing &#x3D;&#x3D; oldState) {<br>      if (self.scrollView.pagingEnabled) {<br>          CGPoint offset &#x3D; self.scrollView.contentOffset;<br>          offset.y -&#x3D; self.scrollView.mj_insetB;<br>          [UIView animateWithDuration:MJRefreshSlowAnimationDuration animations:^{<br>              self.scrollView.contentOffset &#x3D; offset;<br>              if (self.endRefreshingAnimateCompletionBlock) {<br>                  self.endRefreshingAnimateCompletionBlock();<br>              }<br>          } completion:^(BOOL finished) {<br>              if (self.endRefreshingCompletionBlock) {<br>                  self.endRefreshingCompletionBlock();<br>              }<br>          }];<br>          return;<br>      }<br>      if (self.endRefreshingCompletionBlock) {<br>          self.endRefreshingCompletionBlock();<br>      }<br>  }<br>  }</p>
</li>
</ul>
<p>}</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="strong">****</span>MJRefreshBackFooter<span class="strong">****</span></span><br><span class="line"></span><br><span class="line">MJRefreshBackFooter 和 MJRefreshAutoFooter不同的是它会永远出现在UIScrollView的最底部，为啥？我们看下代码：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><p>(void)scrollViewContentSizeDidChange:(NSDictionary *)change {<br>  [super scrollViewContentSizeDidChange:change];<br>  &#x2F;&#x2F; 内容的高度<br>  CGFloat contentHeight &#x3D; self.scrollView.mj_contentH + self.ignoredScrollViewContentInsetBottom;<br>  &#x2F;&#x2F; 表格的高度<br>  CGFloat scrollHeight &#x3D; self.scrollView.mj_h - self.scrollViewOriginalInset.top - self.scrollViewOriginalInset.bottom + self.ignoredScrollViewContentInsetBottom;<br>  &#x2F;&#x2F; 设置位置和尺寸<br>  self.mj_y &#x3D; MAX(contentHeight, scrollHeight);<br>}</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">在内容高度大于<span class="built_in">UIScrollView</span>的时候，它会追加在内容最后面，这时候MJRefreshBackFooter也是在<span class="built_in">UIScrollView</span>的外面，在滑到<span class="built_in">UIScrollView</span>的时候开始加载。如果<span class="built_in">UIScrollView</span>的高度大于内容高度，那么它会被加在<span class="built_in">UIScrollView</span>最底部。</span><br><span class="line"></span><br><span class="line">我们接下来看下MJRefreshBackFooter的状态变化：</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>(void)scrollViewContentOffsetDidChange:(NSDictionary *)change {<br>  [super scrollViewContentOffsetDidChange:change];</p>
<p>  &#x2F;&#x2F; 如果正在刷新，直接返回<br>  if (self.state &#x3D;&#x3D; MJRefreshStateRefreshing) return;</p>
<p>  _scrollViewOriginalInset &#x3D; self.scrollView.mj_inset;</p>
<p>  &#x2F;&#x2F; 当前的contentOffset<br>  CGFloat currentOffsetY &#x3D; self.scrollView.mj_offsetY;<br>  &#x2F;&#x2F; 尾部控件刚好出现的offsetY<br>  CGFloat happenOffsetY &#x3D; [self happenOffsetY];<br>  &#x2F;&#x2F; 如果是向下滚动到看不见尾部控件，直接返回<br>  if (currentOffsetY &lt;&#x3D; happenOffsetY) return;</p>
<p>  CGFloat pullingPercent &#x3D; (currentOffsetY - happenOffsetY) &#x2F; self.mj_h;</p>
<p>  &#x2F;&#x2F; 如果已全部加载，仅设置pullingPercent，然后返回<br>  if (self.state &#x3D;&#x3D; MJRefreshStateNoMoreData) {<br>  self.pullingPercent &#x3D; pullingPercent;<br>  return;<br>  }</p>
<p>  if (self.scrollView.isDragging) {<br>  self.pullingPercent &#x3D; pullingPercent;<br>  &#x2F;&#x2F; 普通 和 即将刷新 的临界点<br>  CGFloat normal2pullingOffsetY &#x3D; happenOffsetY + self.mj_h;<br><br>  if (self.state &#x3D;&#x3D; MJRefreshStateIdle &amp;&amp; currentOffsetY &gt; normal2pullingOffsetY) {<br>      &#x2F;&#x2F; 转为即将刷新状态<br>      self.state &#x3D; MJRefreshStatePulling;<br>  } else if (self.state &#x3D;&#x3D; MJRefreshStatePulling &amp;&amp; currentOffsetY &lt;&#x3D; normal2pullingOffsetY) {<br>      &#x2F;&#x2F; 转为普通状态<br>      self.state &#x3D; MJRefreshStateIdle;<br>  }<br>  } else if (self.state &#x3D;&#x3D; MJRefreshStatePulling) {&#x2F;&#x2F; 即将刷新 &amp;&amp; 手松开<br>  &#x2F;&#x2F; 开始刷新<br>  [self beginRefreshing];<br>  } else if (pullingPercent &lt; 1) {<br>  self.pullingPercent &#x3D; pullingPercent;<br>  }</p>
</li>
</ul>
<p>}</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">这里有两个比较关键的offset:</span><br><span class="line"></span><br><span class="line"><span class="strong">****</span>happenOffsetY<span class="strong">****</span>: 它是MJRefreshBackFooter刚好露出来时候UIScrollView的ContentOffset.</span><br><span class="line"><span class="strong">****</span>normal2pullingOffsetY<span class="strong">****</span>: 它是MJRefreshBackFooter完全露出来时候UIScrollView的ContentOffset.</span><br><span class="line"></span><br><span class="line">所以 currentOffsetY但凡大于happenOffsetY就表示MJRefreshBackFooter已经露出来了，这时候，如果scrollView处于拖拽状态，并且currentOffsetY &gt; normal2pullingOffsetY 表示整个MJRefreshBackFooter已经完全露出来了，这时候会切换到MJRefreshStatePulling状态，如果currentOffsetY &lt;= normal2pullingOffsetY那么当前状态为MJRefreshStateIdle。如果处于MJRefreshStatePulling状态，也就是MJRefreshBackFooter已经完全露出来的情况下，松手的话就会触发刷新。</span><br><span class="line"></span><br><span class="line">下面是状态改变的过程：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>(void)setState:(MJRefreshState)state {<br>  MJRefreshCheckState<br>  &#x2F;&#x2F; 根据状态来设置属性<br>  if (state &#x3D;&#x3D; MJRefreshStateNoMoreData || state &#x3D;&#x3D; MJRefreshStateIdle) {<br>  &#x2F;&#x2F; 刷新完毕<br>  if (MJRefreshStateRefreshing &#x3D;&#x3D; oldState) {<br>      [UIView animateWithDuration:MJRefreshSlowAnimationDuration animations:^{<br>          self.scrollView.mj_insetB -&#x3D; self.lastBottomDelta;<br>          if (self.endRefreshingAnimateCompletionBlock) {<br>              self.endRefreshingAnimateCompletionBlock();<br>          }<br>          &#x2F;&#x2F; 自动调整透明度<br>          if (self.isAutomaticallyChangeAlpha) self.alpha &#x3D; 0.0;<br>      } completion:^(BOOL finished) {<br>          self.pullingPercent &#x3D; 0.0;<br>          if (self.endRefreshingCompletionBlock) {<br>              self.endRefreshingCompletionBlock();<br>          }<br>      }];<br>  }<br>  CGFloat deltaH &#x3D; [self heightForContentBreakView];<br>  &#x2F;&#x2F; 刚刷新完毕<br>  if (MJRefreshStateRefreshing &#x3D;&#x3D; oldState &amp;&amp; deltaH &gt; 0 &amp;&amp; self.scrollView.mj_totalDataCount !&#x3D; self.lastRefreshCount) {<br>      self.scrollView.mj_offsetY &#x3D; self.scrollView.mj_offsetY;<br>  }<br>  } else if (state &#x3D;&#x3D; MJRefreshStateRefreshing) {<br>  &#x2F;&#x2F; 记录刷新前的数量<br>  self.lastRefreshCount &#x3D; self.scrollView.mj_totalDataCount;<br>  [UIView animateWithDuration:MJRefreshFastAnimationDuration animations:^{<br>      CGFloat bottom &#x3D; self.mj_h + self.scrollViewOriginalInset.bottom;<br>      CGFloat deltaH &#x3D; [self heightForContentBreakView];<br>      if (deltaH &lt; 0) { &#x2F;&#x2F; 如果内容高度小于view的高度<br>          bottom -&#x3D; deltaH;<br>      }<br>      self.lastBottomDelta &#x3D; bottom - self.scrollView.mj_insetB;<br>      self.scrollView.mj_insetB &#x3D; bottom;<br>      self.scrollView.mj_offsetY &#x3D; [self happenOffsetY] + self.mj_h;<br>  } completion:^(BOOL finished) {<br>      [self executeRefreshingCallback];<br>  }];<br>  }<br>}<br>&#96;&#96;&#96;</li>
</ul>
<p>MJRefresh最核心的部分代码已经介绍完毕了，后续的一些，比如包含State的Header以及Footer 都是用于处理与状态文本相关的类，包含Normal的Header以及Footer都是用于处理箭头和菊花状态的类，而包含Gif的Header以及Footer都是用于处理Gif动画的类，这些类都是基于state, pullingPercent 这些关键属性的变化而改变的，所以理解上面介绍的如何根据Content Offset 变化 确定state以及pullingPercent是理解MJRefresh的核心。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/iOS-%E5%BC%80%E6%BA%90%E5%BA%93%E5%88%86%E6%9E%90/">iOS 开源库分析</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/iOS-开源库分析/">iOS 开源库分析</a>
  </div>

</div>



<div class="comments-count">
	
	  	<span></span>
		<a href="/2019/12/06/MJRefresh-使用及源码分析/#comments" class="ds-thread-count comments-count-link" data-thread-key="2019/12/06/MJRefresh-使用及源码分析/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/12/05/Tencent-Mars-源码解析/" title="Tencent Mars 源码解析" itemprop="url">Tencent Mars 源码解析</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Edgar" target="_blank" itemprop="author">Edgar</a>
		
  <p class="article-time">
    <time datetime="2019-12-05T13:17:29.000Z" itemprop="datePublished"> Published 2019-12-05</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h5 id="源码信息"><a href="#源码信息" class="headerlink" title="源码信息"></a>源码信息</h5><p>Mars 是微信官方的终端基础组件，是一个使用 C++ 编写的业务性无关，平台性无关的基础组件，目前已经开源，下面是官方的源码以及文档地址：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/Tencent/mars">Mars</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/Tencent/mars/wiki">Mars 文档地址</a></li>
</ul>
<h5 id="Mars-概览"><a href="#Mars-概览" class="headerlink" title="Mars 概览"></a>Mars 概览</h5><p><img src="/2019/12/05/Tencent-Mars-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/00001.png"></p>
<p>整个项目主要包含如下几个模块：</p>
<p><strong><strong>COMM</strong></strong>：基础库，包括socket、线程、消息队列、协程等基础工具；<br><strong><strong>XLOG</strong></strong>：通用日志模块，充分考虑移动终端的特点，提供高性能、高可用、安全性、容错性的日志功能；<br><strong><strong>SDT</strong></strong>：网络诊断模块；<br><strong><strong>STN</strong></strong>：是微信的信令传输网络模块,它是基于Socket层的网络解决方案（它并不支持完整的 HTTP 协议），负责终端与服务器的小数据信令通道。是微信日常中使用最频繁的网络通道，STN中包含了很多其他方面的实用设计：包括自定义DNS、容灾设计、负载考量、APP的前后台考量、休眠机制考量、省电机制等等。网络通道上，目前STN提供了长连、短连两种类型的通道，用于满足不同的需求。使用STN后，应用开发者只需关注业务开发。<br><strong><strong>CDN</strong></strong>: 数据分发网络，负责大数据传输，这部分涉及具体的业务，所以未开源</p>
<p>下面是几种网络开源库的对比：</p>
<p><img src="/2019/12/05/Tencent-Mars-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/00002.png"></p>
<h5 id="Mars-Sample-代码分析"><a href="#Mars-Sample-代码分析" class="headerlink" title="Mars Sample 代码分析"></a>Mars Sample 代码分析</h5><p><strong><strong>1. 让Sample项目跑起来</strong></strong></p>
<p>微信官方有专门的接入文档:<br><a target="_blank" rel="noopener" href="https://github.com/Tencent/mars/wiki/Mars-iOS%EF%BC%8FOS-X-%E6%8E%A5%E5%85%A5%E6%8C%87%E5%8D%97">Mars iOS／OS X 接入指南</a> 一种是以framework形式引入的，一般实际开发项目中会以这种方式接入，另一种是调试模式，初期分析Mars Sample代码的时候需要以这种方式引入，这里需要注意的是编译成功后需要将mars.framework拷贝到项目文件夹下再添加到项目中。不然会提示找不到某些头文件。</p>
<p>这里还需要注意的是如果要以调试模式进行接入，运行编译脚本的时候需要选择3,否则找不到<strong><strong>mars.xcodeproj</strong></strong></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">Enter menu:</span><br><span class="line"><span class="bullet">1.</span> Clean &amp;&amp; build mars.</span><br><span class="line"><span class="bullet">2.</span> Clean &amp;&amp; build xlog.</span><br><span class="line"><span class="bullet">3.</span> Gen iOS mars Project.</span><br><span class="line"><span class="bullet">4.</span> Exit</span><br></pre></td></tr></table></figure>

<p>下面就以调试模式来开始我们mars源码的分析：</p>
<p><strong><strong>2. Sample代码分析</strong></strong></p>
<p>Mars Sample 业务层核心部分主要由<strong><strong>NetworkStatus</strong></strong>，<strong><strong>NetworkService</strong></strong>，<strong><strong>NetworkEvent</strong></strong> 三大部分构成，在介绍Mars Sample 业务层代码之前我们先过下这部分功能。</p>
<p><strong><strong>NetworkStatus</strong></strong></p>
<p>这个类用于监听网络状态的，具体的思想和AFNetWorking 里面的AFNetworkReachabilityManager思路是一致的，只不过代码有点…..所以不贴代码了。大家可以看下之前介绍AFNetWorking的源码分析博客。</p>
<p>只要调用了Start方法之后在网络状态改变后都会调用它的<strong><strong>ChangeReach</strong></strong>方法。</p>
<p>这里我们在Appdelegate类中将<strong><strong>NetworkService</strong></strong>作为Start参数,也就是说在网络状态改变的时候会调用NetworkService的<strong><strong>ChangeReach</strong></strong>方法。</p>
<p><strong><strong>NetworkService</strong></strong></p>
<p>是整个业务层比较重要的一个类，它和底层mars关系最为密切。它主要有如下功能：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1.</span> Mars 的上层调用</span><br><span class="line"><span class="bullet">2.</span> 网络状态NetworkStatus的监听器，并将这个网络状态传递给Mars底层的mars::baseevent</span><br><span class="line"><span class="bullet">3.</span> 将Mars底层的callback通知到<span class="strong">****</span>NetworkEvent<span class="strong">****</span></span><br></pre></td></tr></table></figure>

<p><strong><strong>NetworkEvent</strong></strong></p>
<p>NetworkEvent 管理着<strong><strong>tasks</strong></strong>，<strong><strong>controllers</strong></strong> 和 <strong><strong>pushrecvers</strong></strong>：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="meta">@interface</span> <span class="type">NetworkEvent</span> : <span class="type">NSObject</span>&lt;<span class="type">NetworkDelegate</span>&gt; &#123;</span><br><span class="line">    <span class="type">NSMutableDictionary</span>   <span class="operator">*</span>tasks;</span><br><span class="line">    <span class="type">NSMutableDictionary</span><span class="operator">*</span> controllers;</span><br><span class="line">    <span class="type">NSMutableDictionary</span><span class="operator">*</span> pushrecvers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在有数据需要分发下去的时候可以通过它来分发，一般事件的起源都是从Mars底层callback产生的，然后经过<strong><strong>NetworkService</strong></strong>传递给<strong><strong>NetworkEvent</strong></strong>，<strong><strong>NetworkEvent</strong></strong>负责分发给对应的对象。下面是这三者之间的关系，整体如下图所示：</p>
<p><img src="/2019/12/05/Tencent-Mars-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/00003.png"></p>
<p><strong><strong>NetworkService</strong></strong> 负责设置 <strong><strong>Mars</strong></strong>,由于在<strong><strong>NetworkService</strong></strong> setCallBack中设置了对应的回调所以<strong><strong>Mars</strong></strong>一旦有回调就传给<strong><strong>NetworkService</strong></strong>，<strong><strong>NetworkService</strong></strong> 将 Mars上传的事件传递给<strong><strong>NetworkEvent</strong></strong>，<strong><strong>NetworkEvent</strong></strong>再将事件传递给对应的controllers，pushrecvers。</p>
<p>接下来我们会以如下几个部分对业务层代码进行解析:</p>
<p><strong><strong>2.1 Mars 网络层初始化</strong></strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置NetworkEvent为NetworkService的代理以便将NetworkService感知的事件传递给NetworkEvent进行分发</span></span><br><span class="line"><span class="string">    [NetworkService sharedInstance]</span>.delegate = [[NetworkEvent alloc] init];</span><br><span class="line">    <span class="comment">// 监听Mars的底层回调，在Mars有关键事件发生的时候可以通知到NetworkService</span></span><br><span class="line"><span class="string">    [[NetworkService sharedInstance]</span> setCallBack];</span><br><span class="line">    <span class="comment">// 创建Mars</span></span><br><span class="line"><span class="string">    [[NetworkService sharedInstance]</span> createMars];</span><br><span class="line">    <span class="comment">// 设置客户端版本</span></span><br><span class="line"><span class="string">    [[NetworkService sharedInstance]</span> setClientVersion:<span class="number">200</span>];</span><br><span class="line">    <span class="comment">// 添加长链接地址和端口</span></span><br><span class="line"><span class="string">    [[NetworkService sharedInstance]</span> setLongLinkAddress:@<span class="string">&quot;localhost&quot;</span> port:<span class="number">8081</span>];</span><br><span class="line">    <span class="comment">// 添加短链接监听端口</span></span><br><span class="line"><span class="string">    [[NetworkService sharedInstance]</span> setShortLinkPort:<span class="number">8080</span>];</span><br><span class="line">    <span class="comment">// 上报当前应用处于前台状态</span></span><br><span class="line"><span class="string">    [[NetworkService sharedInstance]</span> reportEvent_OnForeground:YES];</span><br><span class="line">    <span class="comment">// 确保长链接已经连接上</span></span><br><span class="line"><span class="string">    [[NetworkService sharedInstance]</span> makesureLongLinkConnect];</span><br><span class="line">    <span class="comment">// 启动网络状态监听</span></span><br><span class="line"><span class="string">    [[NetworkStatus sharedInstance]</span> Start:[NetworkService sharedInstance]];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> YES;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">void</span>)applicationDidEnterBackground:(UIApplication *)application &#123;</span><br><span class="line">    <span class="comment">//上报当前应用处于后台状态</span></span><br><span class="line"><span class="string">    [[NetworkService sharedInstance]</span> reportEvent_OnForeground:NO];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">void</span>)applicationWillEnterForeground:(UIApplication *)application &#123;</span><br><span class="line">    <span class="comment">//上报当前应用处于前端状态</span></span><br><span class="line"><span class="string">    [[NetworkService sharedInstance]</span> reportEvent_OnForeground:YES];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">void</span>)applicationWillTerminate:(UIApplication *)application &#123;</span><br><span class="line">    <span class="comment">// 销毁Mars</span></span><br><span class="line"><span class="string">    [[NetworkService sharedInstance]</span> destroyMars];</span><br><span class="line">    appender_close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这部分我们先埋个坑，在介绍Mars底层代码的时候我们再展开介绍。</p>
<p><strong><strong>2.2 通过Mars 拉取数据</strong></strong></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)loadView &#123;</span><br><span class="line">    [<span class="variable language_">super</span> loadView];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    converSations = [[<span class="built_in">NSArray</span> alloc] init];</span><br><span class="line">    <span class="built_in">CGITask</span> *convlstCGI = [[<span class="built_in">CGITask</span> alloc] initAll:ChannelType_ShortConn AndCmdId:kConvLst AndCGIUri:<span class="string">@&quot;/mars/getconvlist&quot;</span> AndHost:<span class="string">@&quot;localhost&quot;</span>];</span><br><span class="line">    [[NetworkService sharedInstance] startTask:convlstCGI ForUI:<span class="keyword">self</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSData</span>*)requestSendData &#123;</span><br><span class="line">    ConversationListRequest *convlstRequest = [ConversationListRequest new];</span><br><span class="line">    convlstRequest.type = <span class="number">0</span>;</span><br><span class="line">    convlstRequest.accessToken = <span class="string">@&quot;123456&quot;</span>;</span><br><span class="line">    <span class="built_in">NSData</span> *data = [convlstRequest data];</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">int</span>)onPostDecode:(<span class="built_in">NSData</span>*)responseData &#123;</span><br><span class="line">    convlstResponse = [ConversationListResponse parseFromData:responseData error:<span class="literal">nil</span>];</span><br><span class="line">    <span class="keyword">self</span>-&gt;converSations = convlstResponse.listArray;</span><br><span class="line">    LOG_INFO(kModuleViewController, <span class="string">@&quot;recv conversation list, size: %lu&quot;</span>, (<span class="type">unsigned</span> <span class="type">long</span>)[<span class="keyword">self</span>-&gt;converSations count]);</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span>-&gt;converSations count] &gt; <span class="number">0</span> ? <span class="number">0</span> : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">int</span>)onTaskEnd:(uint32_t)tid errType:(uint32_t)errtype errCode:(uint32_t)errcode &#123;</span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        [<span class="keyword">self</span>.tableView reloadData];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong><strong>2.2 通过Mars 监听下发的数据</strong></strong></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="variable language_">super</span> viewDidLoad];</span><br><span class="line">    <span class="keyword">self</span>.title = _conversation.notice;</span><br><span class="line">    <span class="comment">//.......</span></span><br><span class="line">    _messages = [<span class="built_in">NSMutableArray</span> new];</span><br><span class="line">    [[NetworkService sharedInstance] addPushObserver:<span class="keyword">self</span> withCmdId:kPushMessageCmdId];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(<span class="built_in">NSData</span>*)requestSendData &#123;</span><br><span class="line">    SendMessageRequest *sendMsgRequest = [SendMessageRequest new];</span><br><span class="line">    sendMsgRequest.from = [<span class="keyword">self</span> username];</span><br><span class="line">    sendMsgRequest.to = <span class="string">@&quot;all&quot;</span>;</span><br><span class="line">    sendMsgRequest.text = _textField.text;</span><br><span class="line">    sendMsgRequest.accessToken = <span class="string">@&quot;123456&quot;</span>;</span><br><span class="line">    sendMsgRequest.topic = _conversation.topic;</span><br><span class="line">    LOG_INFO(kModuleViewController, <span class="string">@&quot;send msg to topic:%@&quot;</span>, _conversation.notice);</span><br><span class="line">    <span class="built_in">NSData</span>* data = [sendMsgRequest data];</span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        _textField.text = <span class="string">@&quot;&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(<span class="type">int</span>)onPostDecode:(<span class="built_in">NSData</span>*)responseData &#123;</span><br><span class="line">    SendMessageResponse *sendMsgResponse = [SendMessageResponse parseFromData:responseData error:<span class="literal">nil</span>];</span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        <span class="built_in">NSString</span> *recvtext = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;%@ : %@&quot;</span>, sendMsgResponse.from, sendMsgResponse.text];</span><br><span class="line">        [<span class="keyword">self</span>.messages addObject:recvtext];</span><br><span class="line">        [<span class="keyword">self</span>.tableView reloadData];</span><br><span class="line">        <span class="built_in">NSIndexPath</span> *indexPath = [<span class="built_in">NSIndexPath</span> indexPathForRow:<span class="keyword">self</span>.messages.count<span class="number">-1</span> inSection:<span class="number">0</span>];</span><br><span class="line">        [<span class="keyword">self</span>.tableView scrollToRowAtIndexPath:indexPath atScrollPosition:<span class="built_in">UITableViewScrollPositionBottom</span> animated:<span class="literal">YES</span>];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> sendMsgResponse.errCode == <span class="number">0</span> ? <span class="number">0</span> : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)sendMessage &#123;</span><br><span class="line">    <span class="built_in">CGITask</span> *sendMsgCGI = [[<span class="built_in">CGITask</span> alloc] initAll:ChannelType_LongConn AndCmdId:kSendMsg AndCGIUri:<span class="string">@&quot;/mars/sendmessage&quot;</span> AndHost:<span class="string">@&quot;localhost&quot;</span>];</span><br><span class="line">    [[NetworkService sharedInstance] startTask:sendMsgCGI ForUI:<span class="keyword">self</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)notifyPushMessage:(<span class="built_in">NSData</span>*)pushData withCmdId:(<span class="type">int</span>)cmdId &#123;</span><br><span class="line">    MessagePush* messagePush = [MessagePush parseFromData:pushData error:<span class="literal">nil</span>];</span><br><span class="line">    <span class="keyword">if</span> (messagePush != <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            <span class="built_in">NSString</span> *recvtext = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;%@ : %@&quot;</span>, messagePush.from, messagePush.content];</span><br><span class="line">            [<span class="keyword">self</span>.messages addObject:recvtext];</span><br><span class="line">            [<span class="keyword">self</span>.tableView reloadData];</span><br><span class="line">            <span class="built_in">NSIndexPath</span> *indexPath = [<span class="built_in">NSIndexPath</span> indexPathForRow:<span class="keyword">self</span>.messages.count<span class="number">-1</span> inSection:<span class="number">0</span>];</span><br><span class="line">            [<span class="keyword">self</span>.tableView scrollToRowAtIndexPath:indexPath atScrollPosition:<span class="built_in">UITableViewScrollPositionBottom</span> animated:<span class="literal">YES</span>];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">int</span>)onTaskEnd:(uint32_t)tid errType:(uint32_t)errtype errCode:(uint32_t)errcode &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在Sameple 例子中每个请求都被定义成一个<strong><strong>CGITask</strong></strong>，这里面包含了任务id，长链接，短链接通道的选择，用于表示标示某个请求的id，url 以及host地址。</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@interface</span> <span class="attribute">CGITask </span>: NSObject</span><br><span class="line"></span><br><span class="line"><span class="variable">@property</span>(nonatomic) uint32_t           taskid;</span><br><span class="line"><span class="variable">@property</span>(nonatomic) ChannelType        channel_select;</span><br><span class="line"><span class="variable">@property</span>(nonatomic) uint32_t           cmdid;</span><br><span class="line"><span class="variable">@property</span>(nonatomic, copy) NSString     *cgi;</span><br><span class="line"><span class="variable">@property</span>(nonatomic, copy) NSString     *host;</span><br><span class="line"></span><br><span class="line"><span class="variable">@end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>紧接着调用startTask启动任务：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-attr">[[NetworkService sharedInstance]</span> startTask:convlstCGI ForUI:self];</span><br></pre></td></tr></table></figure>

<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">int</span>)startTask:(CGITask *)<span class="keyword">task</span> ForUI:(id&lt;UINotifyDelegate&gt;)delegateUI &#123;</span><br><span class="line">    Task ctask;</span><br><span class="line">    ctask<span class="variable">.cmdid</span> = <span class="keyword">task</span><span class="variable">.cmdid</span>;</span><br><span class="line">    ctask<span class="variable">.channel_select</span> = <span class="keyword">task</span><span class="variable">.channel_select</span>;</span><br><span class="line">    ctask<span class="variable">.cgi</span> = std::<span class="keyword">string</span>(<span class="keyword">task</span><span class="variable">.cgi</span><span class="variable">.UTF8String</span>);</span><br><span class="line">    ctask<span class="variable">.shortlink_host_list</span><span class="variable">.push_back</span>(std::<span class="keyword">string</span>(<span class="keyword">task</span><span class="variable">.host</span><span class="variable">.UTF8String</span>));</span><br><span class="line">    ctask<span class="variable">.user_context</span> = (__bridge <span class="keyword">void</span>*)<span class="keyword">task</span>;</span><br><span class="line">    </span><br><span class="line">    mars::stn::StartTask(ctask);</span><br><span class="line">    </span><br><span class="line">    NSString *taskIdKey = [NSString stringWithFormat:@<span class="string">&quot;%d&quot;</span>, ctask<span class="variable">.taskid</span>];</span><br><span class="line">    [_delegate addObserver:delegateUI forKey:taskIdKey];</span><br><span class="line">    [_delegate addCGITasks:<span class="keyword">task</span> forKey:taskIdKey];</span><br><span class="line">    <span class="keyword">return</span> ctask<span class="variable">.taskid</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在startTask方法中会将CGITask转换为Task，并调用<strong><strong>mars::stn::StartTask</strong></strong> 然后将当前当前对象，以及task添加到NetworkEvent中，这样一旦有事件就会通知到它们。我们看下<strong><strong>NetworkEvent</strong></strong> 中与controllers有关的方法，这些方法都是task请求触发的。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">NSData</span>*)Request2BufferWithTaskID:(uint32_t)tid task:(<span class="built_in">CGITask</span> *)task &#123;</span><br><span class="line">    <span class="built_in">NSData</span>* data = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">NSString</span> *taskIdKey = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;%d&quot;</span>, tid];</span><br><span class="line">    <span class="type">id</span>&lt;<span class="built_in">UINotifyDelegate</span>&gt; uiObserver = [controllers objectForKey:taskIdKey];</span><br><span class="line">    <span class="keyword">if</span> (uiObserver != <span class="literal">nil</span>) &#123;</span><br><span class="line">        data = [uiObserver requestSendData];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSInteger</span>)Buffer2ResponseWithTaskID:(uint32_t)tid responseData:(<span class="built_in">NSData</span> *)data task:(<span class="built_in">CGITask</span> *)task &#123;</span><br><span class="line">    <span class="type">int</span> returnType = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">NSString</span> *taskIdKey = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;%d&quot;</span>, tid];</span><br><span class="line">    <span class="type">id</span>&lt;<span class="built_in">UINotifyDelegate</span>&gt; uiObserver = [controllers objectForKey:taskIdKey];</span><br><span class="line">    <span class="keyword">if</span> (uiObserver != <span class="literal">nil</span>) &#123;</span><br><span class="line">        returnType = [uiObserver onPostDecode:data];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        returnType = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> returnType;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSInteger</span>)OnTaskEndWithTaskID:(uint32_t)tid task:(<span class="built_in">CGITask</span> *)task errType:(uint32_t)errtype errCode:(uint32_t)errcode &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *taskIdKey = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;%d&quot;</span>, tid];</span><br><span class="line">    [tasks removeObjectForKey:taskIdKey];</span><br><span class="line">    <span class="type">id</span>&lt;<span class="built_in">UINotifyDelegate</span>&gt; uiObserver = [controllers objectForKey:taskIdKey];</span><br><span class="line">    [uiObserver onTaskEnd:tid errType:errtype errCode:errcode];</span><br><span class="line">    [controllers removeObjectForKey:taskIdKey];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说在<strong><strong>Request2BufferWithTaskID</strong></strong>，<strong><strong>Buffer2ResponseWithTaskID</strong></strong>，<strong><strong>OnTaskEndWithTaskID</strong></strong> 会分别触发 发起 Task类的<strong><strong>requestSendData</strong></strong>，<strong><strong>onPostDecode</strong></strong>，<strong><strong>OnTaskEndWithTaskID</strong></strong>方法。</p>
<p>而这三者在会在<strong><strong>stn_callback.mm</strong></strong>中的<strong><strong>StnCallBack::Req2Buf</strong></strong>，<strong><strong>StnCallBack::Buf2Resp</strong></strong>，<strong><strong>StnCallBack::OnTaskEnd</strong></strong> 调用NetworkService的<strong><strong>Request2BufferWithTaskID</strong></strong>，<strong><strong>Buffer2ResponseWithTaskID</strong></strong>，<strong><strong>OnTaskEndWithTaskID</strong></strong>方法。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="built_in">bool</span> StnCallBack::<span class="constructor">Req2Buf(<span class="params">uint32_t</span> <span class="params">_taskid</span>, <span class="params">void</span><span class="operator">*</span> <span class="params">const</span> <span class="params">_user_context</span>, AutoBuffer&amp; <span class="params">_outbuffer</span>, AutoBuffer&amp; <span class="params">_extend</span>, <span class="params">int</span>&amp; <span class="params">_error_code</span>, <span class="params">const</span> <span class="params">int</span> <span class="params">_channel_select</span>)</span> &#123;</span><br><span class="line">    NSData* requestData =  <span class="literal">[[N<span class="identifier">etworkService</span> <span class="identifier">sharedInstance</span>]</span> Request2BufferWithTaskID:_taskid userContext:_user_context];</span><br><span class="line">    <span class="keyword">if</span> (requestData<span class="operator"> == </span>nil) &#123;</span><br><span class="line">        requestData = <span class="literal">[[NSD<span class="identifier">ata</span> <span class="identifier">alloc</span>]</span> init];</span><br><span class="line">    &#125;</span><br><span class="line">    _outbuffer.<span class="constructor">AllocWrite(<span class="params">requestData</span>.<span class="params">length</span>)</span>;</span><br><span class="line">    _outbuffer.<span class="constructor">Write(<span class="params">requestData</span>.<span class="params">bytes</span>,<span class="params">requestData</span>.<span class="params">length</span>)</span>;</span><br><span class="line">    return requestData.length &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> StnCallBack::<span class="constructor">Buf2Resp(<span class="params">uint32_t</span> <span class="params">_taskid</span>, <span class="params">void</span><span class="operator">*</span> <span class="params">const</span> <span class="params">_user_context</span>, <span class="params">const</span> AutoBuffer&amp; <span class="params">_inbuffer</span>, <span class="params">const</span> AutoBuffer&amp; <span class="params">_extend</span>, <span class="params">int</span>&amp; <span class="params">_error_code</span>, <span class="params">const</span> <span class="params">int</span> <span class="params">_channel_select</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">int</span> handle_type = mars::stn::kTaskFailHandleNormal;</span><br><span class="line">    NSData* responseData = <span class="literal">[NSD<span class="identifier">ata</span> <span class="identifier">dataWithBytes</span>:(<span class="identifier">const</span> <span class="identifier">void</span> <span class="operator">*</span>) <span class="identifier">_inbuffer</span>.P<span class="identifier">tr</span>() <span class="identifier">length</span>:<span class="identifier">_inbuffer</span>.L<span class="identifier">ength</span>()]</span>;</span><br><span class="line">    NSInteger errorCode = <span class="literal">[[N<span class="identifier">etworkService</span> <span class="identifier">sharedInstance</span>]</span> Buffer2ResponseWithTaskID:_taskid ResponseData:responseData userContext:_user_context];</span><br><span class="line">    <span class="keyword">if</span> (errorCode != <span class="number">0</span>) &#123;</span><br><span class="line">        handle_type = mars::stn::kTaskFailHandleDefault;</span><br><span class="line">    &#125;</span><br><span class="line">    return handle_type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> StnCallBack::<span class="constructor">OnTaskEnd(<span class="params">uint32_t</span> <span class="params">_taskid</span>, <span class="params">void</span><span class="operator">*</span> <span class="params">const</span> <span class="params">_user_context</span>, <span class="params">int</span> <span class="params">_error_type</span>, <span class="params">int</span> <span class="params">_error_code</span>)</span> &#123;</span><br><span class="line">    return (<span class="built_in">int</span>)<span class="literal">[[N<span class="identifier">etworkService</span> <span class="identifier">sharedInstance</span>]</span> OnTaskEndWithTaskID:_taskid userContext:_user_context errType:_error_type errCode:_error_code];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至于stn_callback什么时候被调用这里先不做过多的介绍，后续介绍底层的时候再来揭开这个答案。</p>
<p>现在我们看下通过上层拉取一个接口是怎样的一个过程：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 构建一个CGITask,传入使用哪种渠道：长链接？短链接？地址，域名，命令id</span><br><span class="line"><span class="number">2.</span> 调用mars::stn::StartTask</span><br><span class="line"><span class="number">3.</span> 将当前类添加到NetWorkEvent的controller列表，</span><br><span class="line"><span class="number">4.</span> 调用mars::stn::StartTask后，Mars 对应的事件会从底层传给NetWorkService,再通过NetWorkEvent分发给对应的controller，我们可以在requestSendData，onPostDecode，OnTaskEndWithTaskID做响应的处理。</span><br></pre></td></tr></table></figure>

<p>看完拉取请求后，其实接收推送的过程也差不多类似：</p>
<p><strong><strong>stn_callback.mm</strong></strong></p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void StnCallBack::<span class="constructor">OnPush(<span class="params">uint64_t</span> <span class="params">_channel_id</span>, <span class="params">uint32_t</span> <span class="params">_cmdid</span>, <span class="params">uint32_t</span> <span class="params">_taskid</span>, <span class="params">const</span> AutoBuffer&amp; <span class="params">_body</span>, <span class="params">const</span> AutoBuffer&amp; <span class="params">_extend</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (_body.<span class="constructor">Length()</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        NSData* recvData = <span class="literal">[NSD<span class="identifier">ata</span> <span class="identifier">dataWithBytes</span>:(<span class="identifier">const</span> <span class="identifier">void</span> <span class="operator">*</span>) <span class="identifier">_body</span>.P<span class="identifier">tr</span>() <span class="identifier">length</span>:<span class="identifier">_body</span>.L<span class="identifier">ength</span>()]</span>;</span><br><span class="line">        <span class="literal">[[N<span class="identifier">etworkService</span> <span class="identifier">sharedInstance</span>]</span> OnPushWithCmd:_cmdid data:recvData];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><strong>NetworkService.m</strong></strong></p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line">- (void)<span class="type">OnPushWithCmd</span>:(<span class="type">NSInteger</span>)cid <span class="class"><span class="keyword">data</span>:(<span class="type">NSData</span> *)<span class="keyword">data</span> &#123;</span></span><br><span class="line"><span class="class">    <span class="title">return</span> [<span class="title">_delegate</span> <span class="type">OnPushWithCmd</span>:<span class="title">cid</span> <span class="title">data</span>:<span class="title">data</span>];</span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong><strong>NetworkEvent.m</strong></strong></p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line">- (void)<span class="type">OnPushWithCmd</span>:(<span class="type">NSInteger</span>)cid <span class="class"><span class="keyword">data</span>:(<span class="type">NSData</span> *)<span class="keyword">data</span> &#123;</span></span><br><span class="line"><span class="class">    <span class="title">id</span>&lt;<span class="type">PushNotifyDelegate</span>&gt; <span class="title">pushObserver</span> = [<span class="title">pushrecvers</span> <span class="title">objectForKey</span>:[<span class="type">NSString</span> <span class="title">stringWithFormat</span>:@&quot;%<span class="title">d</span>&quot;, <span class="title">cid</span>]];</span></span><br><span class="line"><span class="class">    <span class="title">if</span> (<span class="title">pushObserver</span> != <span class="title">nil</span>) &#123;</span></span><br><span class="line"><span class="class">        [<span class="title">pushObserver</span> <span class="title">notifyPushMessage</span>:<span class="title">data</span> <span class="title">withCmdId</span>:<span class="title">cid</span>];</span></span><br><span class="line"><span class="class">    &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><strong>注册监听下发对象</strong></strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-attr">[[NetworkService sharedInstance]</span> addPushObserver:self withCmdId:kPushMessageCmdId];</span><br></pre></td></tr></table></figure>

<p><strong><strong>3. Mars 底层源码解析</strong></strong></p>
<p><strong><strong>3.1 回调设置</strong></strong></p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line">- (<span class="literal">void</span>)setCallBack &#123;</span><br><span class="line">    mars<span class="type">::stn</span><span class="type">::SetCallback</span>(mars<span class="type">::stn</span><span class="type">::StnCallBack</span><span class="type">::Instance</span>());</span><br><span class="line">    mars<span class="type">::app</span><span class="type">::SetCallback</span>(mars<span class="type">::app</span><span class="type">::AppCallBack</span><span class="type">::Instance</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在PublicComponentV2 文件夹下面有 <strong><strong>app_callback</strong></strong> 以及 <strong><strong>stn_callback</strong></strong>两组文件：</p>
<p><strong><strong>stn_callback</strong></strong>这个文件是STN模块的回调接口，<strong><strong>app_callback</strong></strong>是应用相关的回调接口，Mars 通过这些回调接口从上层获取对应的定制化服务，从而将部分可定制的内容放在应用层来做，将这部分业务相关的从底层抽取出来。我们来看下这部分接口，至于具体的时候在介绍到对应的逻辑的时候再介绍，这里主要是了解，回调有哪些接口，这些接口在底层怎么使用：</p>
<p>StnCallBack 接口定义如下：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> StnCallBack : public Callback &#123;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line">public:</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="comment">//流量统计</span></span><br><span class="line">    <span class="keyword">virtual</span> void <span class="constructor">TrafficData(<span class="params">ssize_t</span> <span class="params">_send</span>, <span class="params">ssize_t</span> <span class="params">_recv</span>)</span>;</span><br><span class="line">    <span class="comment">//底层询问上层该host对应的ip列表</span></span><br><span class="line">    <span class="keyword">virtual</span> std::vector&lt;std::<span class="built_in">string</span>&gt; <span class="constructor">OnNewDns(<span class="params">const</span> <span class="params">std</span>::<span class="params">string</span>&amp; <span class="params">_host</span>)</span>;</span><br><span class="line">    <span class="comment">//网络层收到push消息回调</span></span><br><span class="line">    <span class="keyword">virtual</span> void <span class="constructor">OnPush(<span class="params">uint64_t</span> <span class="params">_channel_id</span>, <span class="params">uint32_t</span> <span class="params">_cmdid</span>, <span class="params">uint32_t</span> <span class="params">_taskid</span>, <span class="params">const</span> AutoBuffer&amp; <span class="params">_body</span>, <span class="params">const</span> AutoBuffer&amp; <span class="params">_extend</span>)</span>;</span><br><span class="line">    <span class="comment">//底层获取task要发送的数据</span></span><br><span class="line">    <span class="keyword">virtual</span> <span class="built_in">bool</span> <span class="constructor">Req2Buf(<span class="params">uint32_t</span> <span class="params">_taskid</span>, <span class="params">void</span><span class="operator">*</span> <span class="params">const</span> <span class="params">_user_context</span>, AutoBuffer&amp; <span class="params">_outbuffer</span>, AutoBuffer&amp; <span class="params">_extend</span>, <span class="params">int</span>&amp; <span class="params">_error_code</span>, <span class="params">const</span> <span class="params">int</span> <span class="params">_channel_select</span>)</span>;</span><br><span class="line">    <span class="comment">//底层回包返回给上层解析</span></span><br><span class="line">    <span class="keyword">virtual</span> <span class="built_in">int</span> <span class="constructor">Buf2Resp(<span class="params">uint32_t</span> <span class="params">_taskid</span>, <span class="params">void</span><span class="operator">*</span> <span class="params">const</span> <span class="params">_user_context</span>, <span class="params">const</span> AutoBuffer&amp; <span class="params">_inbuffer</span>, <span class="params">const</span> AutoBuffer&amp; <span class="params">_extend</span>, <span class="params">int</span>&amp; <span class="params">_error_code</span>, <span class="params">const</span> <span class="params">int</span> <span class="params">_channel_select</span>)</span>;</span><br><span class="line">    <span class="comment">//任务执行结束</span></span><br><span class="line">    <span class="keyword">virtual</span> <span class="built_in">int</span>  <span class="constructor">OnTaskEnd(<span class="params">uint32_t</span> <span class="params">_taskid</span>, <span class="params">void</span><span class="operator">*</span> <span class="params">const</span> <span class="params">_user_context</span>, <span class="params">int</span> <span class="params">_error_type</span>, <span class="params">int</span> <span class="params">_error_code</span>)</span>;</span><br><span class="line">    <span class="comment">//上报网络连接状态</span></span><br><span class="line">    <span class="keyword">virtual</span> void <span class="constructor">ReportConnectStatus(<span class="params">int</span> <span class="params">_status</span>, <span class="params">int</span> <span class="params">longlink_status</span>)</span>;</span><br><span class="line">    <span class="comment">//长连信令校验 ECHECK_NOW, ECHECK_NEVER = 1, ECHECK_NEXT = 2</span></span><br><span class="line">    <span class="keyword">virtual</span> <span class="built_in">int</span>  <span class="constructor">GetLonglinkIdentifyCheckBuffer(AutoBuffer&amp; <span class="params">_identify_buffer</span>, AutoBuffer&amp; <span class="params">_buffer_hash</span>, <span class="params">int32_t</span>&amp; <span class="params">_cmdid</span>)</span>;</span><br><span class="line">    <span class="comment">//长连信令校验回包</span></span><br><span class="line">    <span class="keyword">virtual</span> <span class="built_in">bool</span> <span class="constructor">OnLonglinkIdentifyResponse(<span class="params">const</span> AutoBuffer&amp; <span class="params">_response_buffer</span>, <span class="params">const</span> AutoBuffer&amp; <span class="params">_identify_buffer_hash</span>)</span>;</span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    static StnCallBack* instance_;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>AppCallBack 接口定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AppCallBack</span> : <span class="keyword">public</span> Callback &#123;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line">    <span class="comment">//获取应用路径</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">GetAppFilePath</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//获取当前用户信息</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> AccountInfo <span class="title">GetAccountInfo</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//获取版本信息</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">GetClientVersion</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//获取设备信息</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> DeviceInfo <span class="title">GetDeviceInfo</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> AppCallBack* instance_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>调用SetCallback后就会将对应的callback保存到sg_callback中：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SetCallback</span><span class="params">(Callback* <span class="type">const</span> callback)</span> </span>&#123;</span><br><span class="line">	sg_callback = callback;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>StnCallBack 将会在<strong><strong>stn_logic.cc</strong></strong>被注册到Mars底层的stn模块中，AppCallBack 将会在 <strong><strong>app_logic.cc</strong></strong>中被注入到Mars底层的app模块中，至于这些模块的作用我们后面会具体介绍。设置完回调之后就可以通过这些回调就可以将与业务相关的逻辑交给业务层，比如流量统计这部分在Mars的stn模块就可以通过如下方式调用上层逻辑：</p>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">void (*TrafficData)(ssize_t _send, ssize_t _recv)</span><br><span class="line">= [](ssize_t _send, ssize_t _recv) &#123;</span><br><span class="line">    xassert2(sg_callback != NULL);</span><br><span class="line">    return sg_callback-&gt;TrafficData(_send, _recv);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong><strong>3.2 创建Mars</strong></strong></p>
<p>Mars的创建是通过createMars方法进行创建的：</p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line"><span class="comment">[<span class="comment">[NetworkService sharedInstance]</span> createMars]</span>;</span><br></pre></td></tr></table></figure>

<p>这里调用了mars::baseevent的OnCreate</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>) createMars &#123;</span><br><span class="line">    mars::baseevent::<span class="built_in">OnCreate</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在继续介绍Mars创建的过程之前我们先看下mars::baseevent的工作机制：</p>
<p>mars::baseevent里面除了OnCreate外还有如下几个方法，它们的用法看方法名就可以看出，我们这里不介绍这些方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">OnCreate</span><span class="params">()</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">OnDestroy</span><span class="params">()</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">OnSingalCrash</span><span class="params">(<span class="type">int</span> _sig)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">OnExceptionCrash</span><span class="params">()</span> </span><br><span class="line"><span class="keyword">void</span> <span class="title function_">OnForeground</span><span class="params">(bool _isforeground)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">OnNetworkChange</span><span class="params">()</span></span><br></pre></td></tr></table></figure>


<p>mars::baseevent::OnCreate() 实现如下：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">void <span class="built_in">OnCreate</span>() &#123;</span><br><span class="line">    <span class="built_in">GetSignalOnCreate</span>()();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<strong><strong>baseprjevent.cc</strong></strong>实现如下，这里利用了boost这个c++库的signals2信号槽的机制，接触过qt编程的大家都会理解信号槽这个概念。它相当于将一个信号与一个方法绑定在一起，只要发起那个信号，对应绑定的方法就会触发。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">boost::<span class="variable constant_">signals2</span>::<span class="variable constant_">signal</span>&lt;<span class="keyword">void</span> ()&gt;&amp; <span class="title function_ invoke__">GetSignalOnCreate</span>() &#123;</span><br><span class="line">	<span class="built_in">static</span> boost::<span class="variable constant_">signals2</span>::<span class="variable constant_">signal</span>&lt;<span class="keyword">void</span> ()&gt; SignalOnCreate;</span><br><span class="line">	<span class="keyword">return</span> SignalOnCreate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么这个绑定关系是在哪里绑定的呢？</p>
<p>我们可以看到BOOT_RUN_STARTUP宏的定义，这些方法是会在启动的时候执行，</p>
<figure class="highlight hsp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BOOT_RUN_STARTUP(<span class="keyword">func</span>) VARIABLE_IS_NOT_USED static int __anonymous_run_variable_startup_##<span class="keyword">func</span> = __boot_run_atstartup(<span class="keyword">func</span>)</span></span><br></pre></td></tr></table></figure>

<p>下面罗列出了包含BOOT_RUN_STARTUP的类</p>
<p><strong><strong>message_queue.cc</strong></strong></p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="constructor">BOOT_RUN_STARTUP(<span class="params">__RgisterANRCheckCallback</span>)</span>;</span><br></pre></td></tr></table></figure>

<p><strong><strong>app_logic.cc</strong></strong></p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="constructor">BOOT_RUN_STARTUP(<span class="params">__InitbindBaseprjevent</span>)</span>;</span><br></pre></td></tr></table></figure>

<p><strong><strong>active_logic.cc</strong></strong></p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="constructor">BOOT_RUN_STARTUP(<span class="params">__initbind_baseprjevent</span>)</span>;</span><br></pre></td></tr></table></figure>

<p><strong><strong>active_logic.cc</strong></strong></p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="constructor">BOOT_RUN_STARTUP(<span class="params">__initbind_baseprjevent</span>)</span>;</span><br></pre></td></tr></table></figure>

<p><strong><strong>sdt_logic.cc</strong></strong></p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="constructor">BOOT_RUN_STARTUP(<span class="params">__initbind_baseprjevent</span>)</span>;</span><br></pre></td></tr></table></figure>

<p><strong><strong>stn_logic.cc</strong></strong></p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="constructor">BOOT_RUN_STARTUP(<span class="params">__initbind_baseprjevent</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>我们可以看到:<strong><strong>sdt_logic.cc</strong></strong></p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">static void <span class="built_in">__initbind_baseprjevent</span>() &#123;</span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line">    <span class="built_in">GetSignalOnCreate</span>()<span class="selector-class">.connect</span>(&amp;onCreate);</span><br><span class="line">    <span class="built_in">GetSignalOnDestroy</span>()<span class="selector-class">.connect</span>(<span class="number">5</span>, &amp;onDestroy);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>以及<strong><strong>stn_logic.cc</strong></strong></p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">static void <span class="built_in">__initbind_baseprjevent</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line">    <span class="built_in">GetSignalOnCreate</span>()<span class="selector-class">.connect</span>(&amp;onCreate);</span><br><span class="line">    <span class="built_in">GetSignalOnDestroy</span>()<span class="selector-class">.connect</span>(&amp;onDestroy);   <span class="comment">//low priority signal func</span></span><br><span class="line">    <span class="built_in">GetSignalOnSingalCrash</span>()<span class="selector-class">.connect</span>(&amp;onSingalCrash);</span><br><span class="line">    <span class="built_in">GetSignalOnExceptionCrash</span>()<span class="selector-class">.connect</span>(&amp;onExceptionCrash);</span><br><span class="line">    <span class="built_in">GetSignalOnNetworkChange</span>()<span class="selector-class">.connect</span>(<span class="number">5</span>, &amp;onNetworkChange);    <span class="comment">//define group 5</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="built_in">GetSignalOnNetworkDataChange</span>()<span class="selector-class">.connect</span>(&amp;OnNetworkDataChange);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>都包含将GetSignalOnCreate信号通过信号槽与对应方法进行绑定的工作：因此sdt_logic.cc以及stn_logic.cc中的onCreate方法就是我们调用createMars时候底层的所有操作：</p>
<p><strong><strong>sdt_logic.cc</strong></strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">    SdtCore::Singleton::<span class="built_in">Instance</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SdtCore 模块的初始化：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">SdtCore::<span class="constructor">SdtCore()</span></span><br><span class="line">    : thread<span class="constructor">_(<span class="params">boost</span>::<span class="params">bind</span>(&amp;SdtCore::<span class="params">__RunOn</span>, <span class="params">this</span>)</span>)</span><br><span class="line">    , check<span class="constructor">_list_(<span class="params">std</span>::<span class="params">list</span>&lt;BaseChecker<span class="operator">*</span>&gt;()</span>)</span><br><span class="line">    , cancel<span class="constructor">_(<span class="params">false</span>)</span></span><br><span class="line">    , checking<span class="constructor">_(<span class="params">false</span>)</span> &#123;</span><br><span class="line">    xinfo<span class="constructor">_function()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><strong>stn_logic.cc</strong></strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">    ActiveLogic::Singleton::<span class="built_in">Instance</span>();</span><br><span class="line">    NetCore::Singleton::<span class="built_in">Instance</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">ActiveLogic::<span class="constructor">ActiveLogic()</span></span><br><span class="line">: isforeground<span class="constructor">_(<span class="params">false</span>)</span>, isactive<span class="constructor">_(<span class="params">true</span>)</span></span><br><span class="line">, alarm<span class="constructor">_(<span class="params">boost</span>::<span class="params">bind</span>(&amp;ActiveLogic::<span class="params">__OnInActive</span>, <span class="params">this</span>)</span>, <span class="literal">false</span>)</span><br><span class="line">, lastforegroundchangetime<span class="constructor">_(::<span class="params">gettickcount</span>()</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">NetCore::<span class="constructor">NetCore()</span></span><br><span class="line">    : messagequeue<span class="constructor">_creater_(<span class="params">true</span>, XLOGGER_TAG)</span></span><br><span class="line">    <span class="comment">//很长很长的初始化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这两个文件中分别初始化了<strong><strong>SdtCore</strong></strong>，<strong><strong>NetCore</strong></strong>，<strong><strong>ActiveLogic</strong></strong>模块。</p>
<p><strong><strong>3.3 设置长链接地址和短链接地址</strong></strong></p>
<p>设置长链接地址：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-attr">[[NetworkService sharedInstance]</span> setLongLinkAddress:@<span class="string">&quot;localhost&quot;</span> port:<span class="number">8081</span>];</span><br></pre></td></tr></table></figure>

<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> (*SetLonglinkSvrAddr)(<span class="keyword">const</span> <span class="variable constant_">std</span>::<span class="variable constant_">string</span>&amp; host, <span class="keyword">const</span> <span class="variable constant_">std</span>::<span class="variable constant_">vector</span>&lt;uint16_t&gt; ports, <span class="keyword">const</span> <span class="variable constant_">std</span>::<span class="variable constant_">string</span>&amp; debugip)</span><br><span class="line">= [](<span class="keyword">const</span> <span class="variable constant_">std</span>::<span class="variable constant_">string</span>&amp; host, <span class="keyword">const</span> <span class="variable constant_">std</span>::<span class="variable constant_">vector</span>&lt;uint16_t&gt; ports, <span class="keyword">const</span> <span class="variable constant_">std</span>::<span class="variable constant_">string</span>&amp; debugip) &#123;</span><br><span class="line">	std::<span class="variable constant_">vector</span>&lt;std::<span class="variable constant_">string</span>&gt; hosts;</span><br><span class="line">	<span class="keyword">if</span> (!host.<span class="keyword">empty</span>()) &#123;</span><br><span class="line">		hosts.<span class="title function_ invoke__">push_back</span>(host);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="title class_">NetSource</span>::<span class="title function_ invoke__">SetLongLink</span>(hosts, ports, debugip);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>设置短链接地址：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-attr">[[NetworkService sharedInstance]</span> setShortLinkPort:<span class="number">8080</span>];</span><br></pre></td></tr></table></figure>

<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">void (*SetShortlinkSvrAddr)(const uint16_t port, const s<span class="symbol">td:</span><span class="symbol">:st</span>ring&amp; debugip)</span><br><span class="line">= [](const uint16_t port, const s<span class="symbol">td:</span><span class="symbol">:st</span>ring&amp; debugip) &#123;</span><br><span class="line">	NetSour<span class="symbol">ce:</span><span class="symbol">:Se</span>tShortlink(port, debugip);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void NetSource::<span class="constructor">SetLongLink(<span class="params">const</span> <span class="params">std</span>::<span class="params">vector</span>&lt;<span class="params">std</span>::<span class="params">string</span>&gt;&amp; <span class="params">_hosts</span>, <span class="params">const</span> <span class="params">std</span>::<span class="params">vector</span>&lt;<span class="params">uint16_t</span>&gt;&amp; <span class="params">_ports</span>, <span class="params">const</span> <span class="params">std</span>::<span class="params">string</span>&amp; <span class="params">_debugip</span>)</span> &#123;</span><br><span class="line">	ScopedLock lock(sg_ip_mutex);</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="module-access"><span class="module"><span class="identifier">_hosts</span>.</span></span>empty<span class="literal">()</span>) &#123;</span><br><span class="line">    	sg_longlink_hosts = _hosts;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">    	<span class="comment">//.......</span></span><br><span class="line">    &#125;</span><br><span class="line">	sg_longlink_ports = _ports;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void NetSource::<span class="constructor">SetShortlink(<span class="params">const</span> <span class="params">uint16_t</span> <span class="params">_port</span>, <span class="params">const</span> <span class="params">std</span>::<span class="params">string</span>&amp; <span class="params">_debugip</span>)</span> &#123;</span><br><span class="line">	ScopedLock lock(sg_ip_mutex);</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">	sg_shortlink_port = _port;</span><br><span class="line">    sg_shortlink_debugip = _debugip;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终会将长链接，短链接的host以及port存到NetSource的<strong><strong>sg_longlink_hosts</strong></strong>，<strong><strong>sg_longlink_ports</strong></strong>，<strong><strong>sg_shortlink_port</strong></strong>数组中。</p>
<p><strong><strong>3.3 上报处于前台后台的状态</strong></strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-attr">[[NetworkService sharedInstance]</span> reportEvent_OnForeground:YES/NO];</span><br></pre></td></tr></table></figure>

<p>同样它也是依靠信号来触发的，最终的绑定在<strong><strong>active_logic.cc</strong></strong>中：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">static void <span class="built_in">__initbind_baseprjevent</span>() &#123;</span><br><span class="line">    <span class="built_in">GetSignalOnForeground</span>()<span class="selector-class">.connect</span>(&amp;onForeground);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void <span class="built_in">onForeground</span>(bool _isforeground) &#123;</span><br><span class="line">    ActiveLogic::Singleton::Instance()-&gt;OnForeground(_isforeground);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">void ActiveLogic::<span class="constructor">OnForeground(<span class="params">bool</span> <span class="params">_isforeground</span>)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">    <span class="keyword">if</span> (_isforeground<span class="operator"> == </span>isforeground_) return;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bool</span> oldisactive = isactive_;</span><br><span class="line">    isactive_ = <span class="literal">true</span>;</span><br><span class="line">    isforeground_ = _isforeground;</span><br><span class="line">    lastforegroundchangetime_ = ::gettickcount<span class="literal">()</span>;</span><br><span class="line">    alarm_.<span class="constructor">Cancel()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line">    <span class="built_in">bool</span> isnotify = oldisactive!=isactive_;</span><br><span class="line">    <span class="constructor">SignalForeground(<span class="params">isforeground_</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isnotify) &#123;</span><br><span class="line">    	<span class="constructor">SignalActive(<span class="params">isactive_</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<strong><strong>ActiveLogic::OnForeground</strong></strong>方法中最重要的就是<strong><strong>SignalForeground</strong></strong>，以及<strong><strong>SignalActive</strong></strong>的调用,这也是通过信号来发送的，所以直接略过中间的环境，看下最终的底层调用：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">LongLinkConnectMonitor::<span class="constructor">LongLinkConnectMonitor(ActiveLogic&amp; <span class="params">_activelogic</span>, LongLink&amp; <span class="params">_longlink</span>, MessageQueue::MessageQueue_t <span class="params">_id</span>)</span></span><br><span class="line">    : asyncreg<span class="constructor">_(MessageQueue::InstallAsyncHandler(<span class="params">_id</span>)</span>)</span><br><span class="line">    , activelogic<span class="constructor">_(<span class="params">_activelogic</span>)</span>, longlink<span class="constructor">_(<span class="params">_longlink</span>)</span>, alarm<span class="constructor">_(<span class="params">boost</span>::<span class="params">bind</span>(&amp;LongLinkConnectMonitor::<span class="params">__OnAlarm</span>, <span class="params">this</span>)</span>, _id)</span><br><span class="line">    , status<span class="constructor">_(LongLink::<span class="params">kDisConnected</span>)</span></span><br><span class="line">    , last<span class="constructor">_connect_time_(0)</span></span><br><span class="line">    , last<span class="constructor">_connect_net_type_(<span class="params">kNoNet</span>)</span></span><br><span class="line">    , thread<span class="constructor">_(<span class="params">boost</span>::<span class="params">bind</span>(&amp;LongLinkConnectMonitor::<span class="params">__Run</span>, <span class="params">this</span>)</span>, XLOGGER_TAG<span class="string">&quot;::con_mon&quot;</span>)</span><br><span class="line">    , conti<span class="constructor">_suc_count_(0)</span></span><br><span class="line">    , isstart<span class="constructor">_(<span class="params">false</span>)</span> &#123;</span><br><span class="line">    <span class="comment">/*SignalActive 信号绑定*/</span></span><br><span class="line">    activelogic_.<span class="module-access"><span class="module"><span class="identifier">SignalActive</span>.</span></span>connect(boost::bind(&amp;LongLinkConnectMonitor::__OnSignalActive, this, _1));</span><br><span class="line">    <span class="comment">/*SignalForeground 信号绑定*/</span></span><br><span class="line">    activelogic_.<span class="module-access"><span class="module"><span class="identifier">SignalForeground</span>.</span></span>connect(boost::bind(&amp;LongLinkConnectMonitor::__OnSignalForeground, this, _1));</span><br><span class="line">    longlink_.<span class="module-access"><span class="module"><span class="identifier">SignalConnection</span>.</span></span>connect(boost::bind(&amp;LongLinkConnectMonitor::__OnLongLinkStatuChanged, this, _1));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void LongLinkConnectMonitor::<span class="constructor">__OnSignalForeground(<span class="params">bool</span> <span class="params">_isForeground</span>)</span> &#123;</span><br><span class="line">    <span class="comment">//.......</span></span><br><span class="line">    <span class="keyword">if</span> (_isForeground) &#123;</span><br><span class="line">        longlink_.<span class="constructor">GetLastRecvTime()</span>.get<span class="literal">()</span>, <span class="built_in">int64</span><span class="constructor">_t(<span class="params">tickcount_t</span>()</span>.gettickcount<span class="literal">()</span> - longlink_.<span class="constructor">GetLastRecvTime()</span>));</span><br><span class="line">        <span class="keyword">if</span> ((longlink_.<span class="constructor">ConnectStatus()</span><span class="operator"> == </span>LongLink::kConnected)<span class="operator"> &amp;&amp;</span></span><br><span class="line"><span class="operator">                </span>(tickcount<span class="constructor">_t()</span>.gettickcount<span class="literal">()</span> - longlink_.<span class="constructor">GetLastRecvTime()</span> &gt; tickcountdiff<span class="constructor">_t(4.5 <span class="operator">*</span> 60 <span class="operator">*</span> 1000)</span>)) &#123;</span><br><span class="line">            <span class="comment">//如果超过4.5 分钟的话就会重新连接</span></span><br><span class="line">            <span class="constructor">__ReConnect()</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    /.......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SignalForeground 只有应用在前台的情况下如果当前时间与上一次长链接接收时间超过4.5 分钟的话就会重新连接</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void LongLinkConnectMonitor::<span class="constructor">__OnSignalActive(<span class="params">bool</span> <span class="params">_isactive</span>)</span> &#123;</span><br><span class="line">    <span class="constructor">__AutoIntervalConnect()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">uint64_t LongLinkConnectMonitor::<span class="constructor">__AutoIntervalConnect()</span> &#123;</span><br><span class="line">    alarm_.<span class="constructor">Cancel()</span>;</span><br><span class="line">    uint64_t remain = <span class="constructor">__IntervalConnect(<span class="params">kLongLinkConnect</span>)</span>;</span><br><span class="line">    alarm_.<span class="constructor">Start((<span class="params">int</span>)</span>remain);</span><br><span class="line">    return remain;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SignalActive 会在__IntervalConnect 间隔时间内自动连接，__IntervalConnect 会根据连接类型，以及当前的应用的状态来查询下面的表格，进而确定间隔时间。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">                            kForgroundOneMinute | kForgroundTenMinute | kForgroundActive | kBackgroundActive | kInactive</span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">const</span> sg_interval[][<span class="number">5</span>]  = &#123;</span><br><span class="line">    kTaskConnect:           &#123;   <span class="number">5</span>,                         <span class="number">10</span>,                 <span class="number">20</span>,                 <span class="number">30</span>,             <span class="number">300</span>&#125;,</span><br><span class="line">    kLongLinkConnect:       &#123;   <span class="number">15</span>,                        <span class="number">30</span>,                 <span class="number">240</span>,                <span class="number">300</span>,            <span class="number">600</span>&#125;,</span><br><span class="line">    kNetworkChangeConnect:  &#123;   <span class="number">0</span>,                          <span class="number">0</span>,                   <span class="number">0</span>,                  <span class="number">0</span>,              <span class="number">0</span>&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>整个重连机制会在介绍长链接的时候进一步介绍。</p>
<p><strong><strong>3.4 检测长链接状态,保证长链接处于连接状态</strong></strong></p>
<p>我们继续来看Appdelegate中的Mars初始化最后一步<strong><strong>makesureLongLinkConnect</strong></strong>：</p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line"><span class="comment">[<span class="comment">[NetworkService sharedInstance]</span> makesureLongLinkConnect]</span>;</span><br></pre></td></tr></table></figure>

<p>下面是层层的调用关系：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)makesureLongLinkConnect &#123;</span><br><span class="line">    mars::stn::<span class="built_in">MakesureLonglinkConnected</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line">void (*MakesureLonglinkConnected)()</span><br><span class="line"><span class="section">= []() &#123;</span></span><br><span class="line"><span class="code">   STN_WEAK_CALL(MakeSureLongLinkConnect());</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">NetCore::MakeSureLongLinkConnect</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> USE_LONG_LINK</span></span><br><span class="line">    ASYNC_BLOCK_START</span><br><span class="line">    longlink_task_manager_-&gt;<span class="built_in">LongLinkChannel</span>().<span class="built_in">MakeSureConnected</span>();</span><br><span class="line">    ASYNC_BLOCK_END</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">bool LongLink:<span class="type"></span>:MakeSureConnected(bool* _new<span class="type">one</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (_new<span class="type">one</span>) *_new<span class="type">one</span> = <span class="literal">false</span>;</span><br><span class="line">    ScopedLock lock(mutex_);</span><br><span class="line">    <span class="keyword">if</span> (kConnected == ConnectStatus()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    bool <span class="keyword">new</span><span class="type">one</span> = <span class="literal">false</span>;</span><br><span class="line">    thread_.start(&amp;<span class="keyword">new</span><span class="type">one</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">new</span><span class="type">one</span>) &#123;</span><br><span class="line">        <span class="comment">//.....</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (_new<span class="type">one</span>) *_new<span class="type">one</span> = <span class="keyword">new</span><span class="type">one</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>LongLink::MakeSureConnected中最关键的是调用了<strong><strong>thread_.start(&amp;newone)</strong></strong></p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">LongLink::<span class="constructor">LongLink(<span class="params">const</span> <span class="params">mq</span>::MessageQueue_t&amp; <span class="params">_messagequeueid</span>, NetSource&amp; <span class="params">_netsource</span>)</span></span><br><span class="line">    : asyncreg<span class="constructor">_(MessageQueue::InstallAsyncHandler(<span class="params">_messagequeueid</span>)</span>)</span><br><span class="line">    , netsource<span class="constructor">_(<span class="params">_netsource</span>)</span></span><br><span class="line">    <span class="comment">/*绑定__Run方法*/</span></span><br><span class="line">    , thread<span class="constructor">_(<span class="params">boost</span>::<span class="params">bind</span>(&amp;LongLink::<span class="params">__Run</span>, <span class="params">this</span>)</span>, XLOGGER_TAG <span class="string">&quot;::lonklink&quot;</span>)</span><br><span class="line">	, connectstatus<span class="constructor">_(<span class="params">kConnectIdle</span>)</span></span><br><span class="line">	, disconnectinternalcode<span class="constructor">_(<span class="params">kNone</span>)</span></span><br><span class="line">    , smartheartbeat<span class="constructor">_(NULL)</span></span><br><span class="line">    , wakelock<span class="constructor">_(NULL)</span></span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在初始化LongLink的时候已经通过boost::bind将thread_绑定到了__Run所以，在调用start的时候调用的是__Run方法：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void LongLink::<span class="constructor">__Run()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//.......</span></span><br><span class="line">    </span><br><span class="line">    SOCKET sock = <span class="constructor">__RunConnect(<span class="params">conn_profile</span>)</span>;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    ErrCmdType errtype = kEctOK;</span><br><span class="line">    <span class="built_in">int</span> errcode = <span class="number">0</span>;</span><br><span class="line">    <span class="constructor">__RunReadWrite(<span class="params">sock</span>, <span class="params">errtype</span>, <span class="params">errcode</span>, <span class="params">conn_profile</span>)</span>;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>__Run中最关键的部分是__RunConnect以及__RunReadWrite：前者是执行socket连接，后者是在一个循环中等待执行数据的读写。关于数据的读写后面会专门介绍。</p>
<p><strong><strong>3.5 发起请求</strong></strong></p>
<p>我们上面代码可以看出发起请求是通过如下代码来实现的：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">int</span>)startTask:(CGITask *)<span class="keyword">task</span> ForUI:(id&lt;UINotifyDelegate&gt;)delegateUI &#123;</span><br><span class="line">    Task ctask;</span><br><span class="line">    ctask<span class="variable">.cmdid</span> = <span class="keyword">task</span><span class="variable">.cmdid</span>;</span><br><span class="line">    ctask<span class="variable">.channel_select</span> = <span class="keyword">task</span><span class="variable">.channel_select</span>;</span><br><span class="line">    ctask<span class="variable">.cgi</span> = std::<span class="keyword">string</span>(<span class="keyword">task</span><span class="variable">.cgi</span><span class="variable">.UTF8String</span>);</span><br><span class="line">    ctask<span class="variable">.shortlink_host_list</span><span class="variable">.push_back</span>(std::<span class="keyword">string</span>(<span class="keyword">task</span><span class="variable">.host</span><span class="variable">.UTF8String</span>));</span><br><span class="line">    ctask<span class="variable">.user_context</span> = (__bridge <span class="keyword">void</span>*)<span class="keyword">task</span>;</span><br><span class="line">    </span><br><span class="line">    mars::stn::StartTask(ctask);</span><br><span class="line">    </span><br><span class="line">    NSString *taskIdKey = [NSString stringWithFormat:@<span class="string">&quot;%d&quot;</span>, ctask<span class="variable">.taskid</span>];</span><br><span class="line">    [_delegate addObserver:delegateUI forKey:taskIdKey];</span><br><span class="line">    [_delegate addCGITasks:<span class="keyword">task</span> forKey:taskIdKey];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ctask<span class="variable">.taskid</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面创建了一个Task对象，将请求所需要的全部数据都放在Task上，然后通过<strong><strong>mars::stn::StartTask(ctask)</strong></strong> 调用Mars发起请求：</p>
<p><strong><strong>stn_logic.cc</strong></strong></p>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">bool (*StartTask)(const Task&amp; _task)</span><br><span class="line">= [](const Task&amp; _task) &#123;</span><br><span class="line">    STN_RETURN_WEAK_CALL(StartTask(_task));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong><strong>stn_logic.cc</strong></strong></p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void NetCore::<span class="constructor">StartTask(<span class="params">const</span> Task&amp; <span class="params">_task</span>)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    Task task = _task;</span><br><span class="line">    <span class="comment">//判断当前请求是否有效，如果是下面的情况下就会返回错误</span></span><br><span class="line">    <span class="comment">//1. 服务端处理时间超过2分钟</span></span><br><span class="line">    <span class="comment">//2. 尝试次数超过30次</span></span><br><span class="line">    <span class="comment">//3. 超时10分钟</span></span><br><span class="line">    <span class="comment">//4. 长连接cmdid为0</span></span><br><span class="line">    <span class="comment">//5. 短连接cgi为空</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="constructor">__ValidAndInitDefault(<span class="params">task</span>, <span class="params">group</span>)</span>) &#123;</span><br><span class="line">        <span class="constructor">OnTaskEnd(<span class="params">task</span>.<span class="params">taskid</span>, <span class="params">task</span>.<span class="params">user_context</span>, <span class="params">kEctLocal</span>, <span class="params">kEctLocalTaskParam</span>)</span>;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span><span class="operator"> == </span>task.channel_select) &#123;</span><br><span class="line">        <span class="comment">//通道类型错误 </span></span><br><span class="line">        <span class="constructor">OnTaskEnd(<span class="params">task</span>.<span class="params">taskid</span>, <span class="params">task</span>.<span class="params">user_context</span>, <span class="params">kEctLocal</span>, <span class="params">kEctLocalChannelSelect</span>)</span>;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//没有网络，并且在长链接的情况下未连接</span></span><br><span class="line">    <span class="keyword">if</span> (task.network_status_sensitive<span class="operator"> &amp;&amp; </span>kNoNet ==::get<span class="constructor">NetInfo()</span></span><br><span class="line">#ifdef USE_LONG_LINK<span class="operator"></span></span><br><span class="line"><span class="operator">        &amp;&amp; </span>LongLink::kConnected != longlink_task_manager_-&gt;<span class="constructor">LongLinkChannel()</span>.<span class="constructor">ConnectStatus()</span></span><br><span class="line">#endif</span><br><span class="line">        ) &#123;</span><br><span class="line">        <span class="constructor">OnTaskEnd(<span class="params">task</span>.<span class="params">taskid</span>, <span class="params">task</span>.<span class="params">user_context</span>, <span class="params">kEctLocal</span>, <span class="params">kEctLocalNoNet</span>)</span>;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">bool</span> start_ok = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果发现长链接未连接，并且在前台超过15分钟没有发送消息了，就必须重新连接长链接。</span></span><br><span class="line">    <span class="keyword">if</span> (LongLink::kConnected != longlink_task_manager_-&gt;<span class="constructor">LongLinkChannel()</span>.<span class="constructor">ConnectStatus()</span><span class="operator"></span></span><br><span class="line"><span class="operator">            &amp;&amp; </span>(Task::kChannelLong &amp; task.channel_select)<span class="operator"> &amp;&amp; </span>ActiveLogic::Singleton::<span class="constructor">Instance()</span>-&gt;<span class="constructor">IsForeground()</span><span class="operator"></span></span><br><span class="line"><span class="operator">            &amp;&amp; </span>(<span class="number">15</span><span class="operator"> * </span><span class="number">60</span><span class="operator"> * </span><span class="number">1000</span> &gt;= gettickcount<span class="literal">()</span> - ActiveLogic::Singleton::<span class="constructor">Instance()</span>-&gt;<span class="constructor">LastForegroundChangeTime()</span>))</span><br><span class="line">        longlink_task_manager_-&gt;get<span class="constructor">LongLinkConnectMonitor()</span>.<span class="constructor">MakeSureConnected()</span>;</span><br><span class="line"></span><br><span class="line">    switch (task.channel_select) &#123;</span><br><span class="line">    case Task::kChannelBoth: &#123;</span><br><span class="line"></span><br><span class="line">#ifdef USE_LONG_LINK</span><br><span class="line">        <span class="comment">// 长链接已经连接并且当前长链接任务数目小于长链接所能支持的最大任务数，如果连接策略为kChannelFastStrategy的情况下使用长链接，</span></span><br><span class="line">        <span class="comment">// 也就是说在长链接允许的情况下优先使用长链接。</span></span><br><span class="line">        <span class="built_in">bool</span> bUseLongLink = LongLink::kConnected<span class="operator"> == </span>longlink_task_manager_-&gt;<span class="constructor">LongLinkChannel()</span>.<span class="constructor">ConnectStatus()</span>;</span><br><span class="line">        <span class="keyword">if</span> (bUseLongLink<span class="operator"> &amp;&amp; </span>task.channel_strategy<span class="operator"> == </span>Task::kChannelFastStrategy) &#123;</span><br><span class="line">            bUseLongLink = bUseLongLink<span class="operator"> &amp;&amp; </span>(longlink_task_manager_-&gt;<span class="constructor">GetTaskCount()</span> &lt;= kFastSendUseLonglinkTaskCntLimit);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (bUseLongLink)</span><br><span class="line">            start_ok = longlink_task_manager_-&gt;<span class="constructor">StartTask(<span class="params">task</span>)</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">#endif</span><br><span class="line">            start_ok = shortlink_task_manager_-&gt;<span class="constructor">StartTask(<span class="params">task</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    break;</span><br><span class="line">#ifdef USE_LONG_LINK</span><br><span class="line"></span><br><span class="line">    case Task::kChannelLong:</span><br><span class="line">        start_ok = longlink_task_manager_-&gt;<span class="constructor">StartTask(<span class="params">task</span>)</span>;</span><br><span class="line">        break;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    case Task::kChannelShort:</span><br><span class="line">        start_ok = shortlink_task_manager_-&gt;<span class="constructor">StartTask(<span class="params">task</span>)</span>;</span><br><span class="line">        break;</span><br><span class="line"></span><br><span class="line">    default:</span><br><span class="line">        xassert2(<span class="literal">false</span>);</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//.......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在NetCore::StartTask中最主要的工作就是根据channel_select来选择调用长链接模块还是短链接模块的StartTask。当channel_select为kChannelBoth的时候在长链接允许的情况下优先使用长链接。</p>
<p><strong><strong>3.5.1 短链接StartTask</strong></strong></p>
<p>我们先看下短链接的情况下的StartTask：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ShortLinkTaskManager::StartTask</span><span class="params">(<span class="type">const</span> <span class="built_in">Task</span>&amp; _task)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line">    <span class="function">TaskProfile <span class="title">task</span><span class="params">(_task)</span></span>;</span><br><span class="line">    task.link_type = <span class="built_in">Task</span>::kChannelShort;</span><br><span class="line">    <span class="comment">//添加到列表中，并按照优先级排序</span></span><br><span class="line">    lst_cmd_.<span class="built_in">push_back</span>(task);</span><br><span class="line">    lst_cmd_.<span class="built_in">sort</span>(__CompareTask);</span><br><span class="line">    <span class="comment">//在__RunLoop中处理请求</span></span><br><span class="line">    __RunLoop();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>短链接的情况下的StartTask会将Task添加到lst_cmd_然后启动__RunLoop中处理task，我们再来看下__RunLoop</p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line"><span class="literal">void</span> ShortLinkTaskManager<span class="type">::__RunLoop</span>() &#123;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">    __RunOnTimeout();</span><br><span class="line">    __RunOnStartTask();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!lst_cmd_.empty()) &#123;</span><br><span class="line">        MessageQueue<span class="type">::FasterMessage</span>(asyncreg_.Get(),</span><br><span class="line">                                    MessageQueue<span class="type">::Message</span>((MessageQueue<span class="type">::MessageTitle_t</span>)this, boost<span class="type">::bind</span>(&amp;ShortLinkTaskManager<span class="type">::__RunLoop</span>, this), <span class="string">&quot;ShortLinkTaskManager::__RunLoop&quot;</span>),</span><br><span class="line">                                    MessageQueue<span class="type">::MessageTiming</span>(<span class="number">1000</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在__RunLoop方法中主要调用了****__RunOnTimeout<strong><strong>，</strong></strong>__RunOnStartTask****然后如果lst_cmd_不为空的话会在间隔1秒后重新执行__RunLoop，从而形成一个循环。<br>__RunOnTimeout 主要处理请求超时的任务。而__RunOnStartTask才是发起请求的关键：</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">void ShortLinkTaskManager::__RunOnStartTask() &#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="keyword">while</span> (first != last) &#123;</span><br><span class="line">        std::list&lt;TaskProfile&gt;::iterator next = first;</span><br><span class="line">        ++next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果当前任务正在执行</span></span><br><span class="line">        <span class="function"><span class="title">if</span> (first-&gt;</span>running_id) &#123;</span><br><span class="line">            ++sent_count;</span><br><span class="line">            first = next;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当前间隔时间小于重试间隔时间</span></span><br><span class="line">        <span class="function"><span class="title">if</span> (first-&gt;</span><span class="function"><span class="title">retry_time_interval</span> &gt; curtime - first-&gt;</span>retry_start_time) &#123;</span><br><span class="line">            <span class="function"><span class="title">xdebug2</span>(TSF&quot;retry interval, taskid:%0, task retry late task, wait:%1&quot;, first-&gt;</span><span class="function"><span class="title">task</span>.taskid, (curtime - first-&gt;</span>transfer_profile.loop_start_task_time) / <span class="number">1000</span>);</span><br><span class="line">            first = next;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果需要登录的话，确保登录成功</span></span><br><span class="line">        <span class="function"><span class="title">if</span> (first-&gt;</span>task.need_authed) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!ismakesureauthruned) &#123;</span><br><span class="line">                ismakesureauthruned = <span class="literal">true</span>;</span><br><span class="line">                ismakesureauthsuccess = MakesureAuthed();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!ismakesureauthsuccess) &#123;</span><br><span class="line">                xinfo2_if(curtime % <span class="number">3</span> == <span class="number">1</span>, TSF<span class="string">&quot;makeSureAuth retsult=%0&quot;</span>, ismakesureauthsuccess);</span><br><span class="line">                first = next;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        AutoBuffer bufreq;</span><br><span class="line">        AutoBuffer buffer_extension;</span><br><span class="line">        int error_code = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用上层方法构建请求</span></span><br><span class="line">        <span class="function"><span class="title">if</span> (!Req2Buf(first-&gt;</span><span class="function"><span class="title">task</span>.taskid, first-&gt;</span>task.user_context, bufreq, buffer_extension, error_code, Task::kChannelShort)) &#123;</span><br><span class="line">            __S<span class="function"><span class="title">ingleRespHandle</span>(first, kEctEnDecode, error_code, kTaskFailHandleTaskEnd, 0, first-&gt;</span><span class="function"><span class="title">running_id</span> ? ((ShortLinkInterface*)first-&gt;</span><span class="function"><span class="title">running_id</span>)-&gt;</span>Profile() : ConnectProfile());</span><br><span class="line">            first = next;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//雪崩检测</span></span><br><span class="line">        xassert2(fun_anti_avalanche_check_);</span><br><span class="line">        <span class="function"><span class="title">if</span> (!fun_anti_avalanche_check_(first-&gt;</span>task, bufreq.Ptr(), (int)bufreq.Length())) &#123;</span><br><span class="line">            __S<span class="function"><span class="title">ingleRespHandle</span>(first, kEctLocal, kEctLocalAntiAvalanche, kTaskFailHandleTaskEnd, 0, first-&gt;</span><span class="function"><span class="title">running_id</span> ? ((ShortLinkInterface*)first-&gt;</span><span class="function"><span class="title">running_id</span>)-&gt;</span>Profile() : ConnectProfile());</span><br><span class="line">            first = next;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">first</span>-&gt;</span>transfer_profile.loop_start_task_time = ::gettickcount();</span><br><span class="line">        <span class="function"><span class="title">first</span>-&gt;</span><span class="function"><span class="title">transfer_profile</span>.first_pkg_timeout = __FirstPkgTimeout(first-&gt;</span>task.server_process_cost, bufreq.Length(), sent_count, dynamic_timeout_.GetStatus());</span><br><span class="line">        <span class="function"><span class="title">first</span>-&gt;</span><span class="function"><span class="title">current_dyntime_status</span> = (first-&gt;</span>task.server_process_cost &lt;= <span class="number">0</span>) ? dynamic_timeout_.GetStatus() : kEValuating;</span><br><span class="line">        <span class="function"><span class="title">first</span>-&gt;</span><span class="function"><span class="title">transfer_profile</span>.read_write_timeout = __ReadWriteTimeout(first-&gt;</span>transfer_profile.first_pkg_timeout);</span><br><span class="line">        <span class="function"><span class="title">first</span>-&gt;</span>transfer_profile.send_data_size = bufreq.Length();</span><br><span class="line">        <span class="function"><span class="title">first</span>-&gt;</span><span class="function"><span class="title">use_proxy</span> =  (first-&gt;</span><span class="function"><span class="title">remain_retry_count</span> == 0 &amp;&amp; first-&gt;</span>task.retry_count &gt; <span class="number">0</span>) ? !default_use_proxy_ : default_use_proxy_;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//创建短链接接口</span></span><br><span class="line">        S<span class="function"><span class="title">hortLinkInterface</span>* worker = ShortLinkChannelFactory::Create(MessageQueue::Handler2Queue(asyncreg_.Get()), net_source_, first-&gt;</span><span class="function"><span class="title">task</span>, first-&gt;</span>use_proxy);</span><br><span class="line">        <span class="comment">//将ShortLinkTaskManager 的 __OnSend，__OnRecv， __OnResponse 绑定到ShortLinkInterface</span></span><br><span class="line">        <span class="function"><span class="title">worker</span>-&gt;</span>OnSend.set(boost::bind(&amp;ShortLinkTaskManager::__OnSend, this, _1), AYNC_HANDLER);</span><br><span class="line">        <span class="function"><span class="title">worker</span>-&gt;</span>OnRecv.set(boost::bind(&amp;ShortLinkTaskManager::__OnRecv, this, _1, _2, _3), AYNC_HANDLER);</span><br><span class="line">        <span class="function"><span class="title">worker</span>-&gt;</span>OnResponse.set(boost::bind(&amp;ShortLinkTaskManager::__OnResponse, this, _1, _2, _3, _4, _5, _6, _7), AYNC_HANDLER);</span><br><span class="line">        <span class="comment">//设置running_id，也就是发起请求后会有一个非0的running_id</span></span><br><span class="line">        <span class="function"><span class="title">first</span>-&gt;</span>running_id = (intptr_t)worker;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">worker</span>-&gt;</span>func_network_report.set(fun_notify_network_err_);</span><br><span class="line">        <span class="comment">//调用SendRequest发送请求</span></span><br><span class="line">        <span class="function"><span class="title">worker</span>-&gt;</span>SendRequest(bufreq, buffer_extension);</span><br><span class="line">        <span class="comment">//......</span></span><br><span class="line">        <span class="comment">//发送计数+1</span></span><br><span class="line">        ++sent_count;</span><br><span class="line">        first = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面是给出的详细代码注释，我们接下来看下当中的关键代码：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"> <span class="comment">//调用上层方法构建请求</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="constructor">Req2Buf(<span class="params">first</span>-&gt;<span class="params">task</span>.<span class="params">taskid</span>, <span class="params">first</span>-&gt;<span class="params">task</span>.<span class="params">user_context</span>, <span class="params">bufreq</span>, <span class="params">buffer_extension</span>, <span class="params">error_code</span>, Task::<span class="params">kChannelShort</span>)</span>) &#123;</span><br><span class="line">    <span class="constructor">__SingleRespHandle(<span class="params">first</span>, <span class="params">kEctEnDecode</span>, <span class="params">error_code</span>, <span class="params">kTaskFailHandleTaskEnd</span>, 0, <span class="params">first</span>-&gt;<span class="params">running_id</span> ? ((ShortLinkInterface<span class="operator">*</span>)</span>first-&gt;running_id)-&gt;<span class="constructor">Profile()</span> : <span class="constructor">ConnectProfile()</span>);</span><br><span class="line">    first = next;</span><br><span class="line">    continue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建短链接接口</span></span><br><span class="line">ShortLinkInterface* worker = ShortLinkChannelFactory::<span class="constructor">Create(MessageQueue::Handler2Queue(<span class="params">asyncreg_</span>.Get()</span>), net_source_, first-&gt;task, first-&gt;use_proxy);</span><br><span class="line"><span class="comment">//将ShortLinkTaskManager 的 __OnSend，__OnRecv， __OnResponse 绑定到ShortLinkInterface</span></span><br><span class="line">worker-&gt;<span class="module-access"><span class="module"><span class="identifier">OnSend</span>.</span></span>set(boost::bind(&amp;ShortLinkTaskManager::__OnSend, this, _1), AYNC_HANDLER);</span><br><span class="line">worker-&gt;<span class="module-access"><span class="module"><span class="identifier">OnRecv</span>.</span></span>set(boost::bind(&amp;ShortLinkTaskManager::__OnRecv, this, _1, _2, _3), AYNC_HANDLER);</span><br><span class="line">worker-&gt;<span class="module-access"><span class="module"><span class="identifier">OnResponse</span>.</span></span>set(boost::bind(&amp;ShortLinkTaskManager::__OnResponse, this, _1, _2, _3, _4, _5, _6, _7), AYNC_HANDLER);</span><br><span class="line"><span class="comment">//设置running_id，也就是发起请求后会有一个非0的running_id</span></span><br><span class="line">first-&gt;running_id = (intptr_t)worker;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="comment">//调用SendRequest发送请求</span></span><br><span class="line">worker-&gt;<span class="constructor">SendRequest(<span class="params">bufreq</span>, <span class="params">buffer_extension</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>从上面可以看出在经过一系列的检查后调用上层的<strong><strong>Req2Buf</strong></strong>方法，然后会通过<strong><strong>ShortLinkChannelFactory</strong></strong>创建<strong><strong>ShortLinkInterface</strong></strong>（ShortLink 对象）然后将ShortLinkInterface的OnSend，OnRecv，OnResponse与ShortLinkTaskManager进行绑定，然后为当前任务分配一个running_id，最后调用SendRequest将请求数据发送出去。</p>
<p>我们继续看<strong><strong>ShortLink::SendRequest</strong></strong></p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void ShortLink::<span class="constructor">SendRequest(AutoBuffer&amp; <span class="params">_buf_req</span>, AutoBuffer&amp; <span class="params">_buffer_extend</span>)</span> &#123;</span><br><span class="line">    send_body_.<span class="constructor">Attach(<span class="params">_buf_req</span>)</span>;</span><br><span class="line">    send_extend_.<span class="constructor">Attach(<span class="params">_buffer_extend</span>)</span>;</span><br><span class="line">    thread_.start<span class="literal">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ShortLink::SendRequest最关键的就是调用了thread_.start()方法，从而运行__Run方法：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void ShortLink::<span class="constructor">__Run()</span> &#123;</span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line"></span><br><span class="line">    SOCKET fd_socket = <span class="constructor">__RunConnect(<span class="params">conn_profile</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (INVALID_SOCKET<span class="operator"> == </span>fd_socket) return;</span><br><span class="line">    <span class="keyword">if</span> (OnSend) &#123;</span><br><span class="line">        <span class="constructor">OnSend(<span class="params">this</span>)</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//....</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">    <span class="constructor">__RunReadWrite(<span class="params">fd_socket</span>, <span class="params">errtype</span>, <span class="params">errcode</span>, <span class="params">conn_profile</span>)</span>;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">    socket<span class="constructor">_close(<span class="params">fd_socket</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ShortLink::__Run 紧接着调用****__RunConnect<strong><strong>，</strong></strong>__RunReadWrite****,在****__RunConnect****方法中主要任务是创建短链接，用于发送请求：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">SOCKET ShortLink::<span class="constructor">__RunConnect(ConnectProfile&amp; <span class="params">_conn_profile</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line">    ShortLinkConnectObserver connect<span class="constructor">_observer(<span class="operator">*</span><span class="params">this</span>)</span>;</span><br><span class="line">	ComplexConnect conn(kShortlinkConnTimeout, kShortlinkConnInterval);</span><br><span class="line">    </span><br><span class="line">    SOCKET sock = conn.<span class="constructor">ConnectImpatient(<span class="params">vecaddr</span>, <span class="params">breaker_</span>, &amp;<span class="params">connect_observer</span>, <span class="params">_conn_profile</span>.<span class="params">proxy_info</span>.<span class="params">type</span>, <span class="params">proxy_addr</span>, <span class="params">_conn_profile</span>.<span class="params">proxy_info</span>.<span class="params">username</span>, <span class="params">_conn_profile</span>.<span class="params">proxy_info</span>.<span class="params">password</span>)</span>;</span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line">    return sock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><strong>__RunConnect</strong></strong>同样方法很长，我们只看最关键的部分它调用ComplexConnect::ConnectImpatient来创建一个SOCKET返回：</p>
<figure class="highlight zephir"><table><tr><td class="code"><pre><span class="line">SOCKET ComplexConnect::ConnectImpatient(<span class="keyword">const</span> std::vector&lt;socket_address&gt;&amp; _vecaddr, SocketBreaker&amp; _breaker, MComplexConnect* _observer,</span><br><span class="line">                                            mars::comm::ProxyType _proxy_type, <span class="keyword">const</span> socket_address* _proxy_addr,</span><br><span class="line">                                            <span class="keyword">const</span> std::string&amp; _proxy_username, <span class="keyword">const</span> std::string&amp; _proxy_pwd) &#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; _vecaddr.size(); ++i) &#123;</span><br><span class="line">        ConnectCheckFSM* ic = NULL;</span><br><span class="line">        <span class="keyword">if</span> (mars::comm::kProxyHttpTunel == _proxy_type &amp;&amp; _proxy_addr) &#123;</span><br><span class="line">            ic = <span class="keyword">new</span> ConnectHttpTunelCheckFSM(_vecaddr[i], *_proxy_addr, _proxy_username, _proxy_pwd, timeout_, i, _observer);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mars::comm::kProxySocks5 == _proxy_type &amp;&amp; _proxy_addr) &#123;</span><br><span class="line">            ic = <span class="keyword">new</span> ConnectSocks5CheckFSM(_vecaddr[i], *_proxy_addr, _proxy_username, _proxy_pwd, timeout_, i, _observer);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ic = <span class="keyword">new</span> ConnectCheckFSM(_vecaddr[i], timeout_, i, _observer);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建 ConnectCheckFSM 添加到vecsocketfsm</span></span><br><span class="line">        vecsocketfsm.push_back(ic);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    SOCKET retsocket = INVALID_SOCKET;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">//......</span></span><br><span class="line">   </span><br><span class="line">        <span class="comment">// socket</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; ++i) &#123;</span><br><span class="line">            <span class="comment">//......</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (TcpClientFSM::EReadWrite == vecsocketfsm[i]-&gt;Status() &amp;&amp; ConnectCheckFSM::ECheckOK == vecsocketfsm[i]-&gt;CheckStatus()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (_observer) _observer-&gt;OnFinished(i, socket_address(&amp;vecsocketfsm[i]-&gt;Address()), vecsocketfsm[i]-&gt;Socket(), vecsocketfsm[i]-&gt;Error(),</span><br><span class="line">                                                         vecsocketfsm[i]-&gt;Rtt(), vecsocketfsm[i]-&gt;TotalRtt(), (<span class="keyword">int</span>)(gettickcount() - starttime));</span><br><span class="line">                <span class="comment">//....</span></span><br><span class="line">                retsocket = vecsocketfsm[i]-&gt;Socket();</span><br><span class="line">                <span class="comment">//....</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//......</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">//........</span></span><br><span class="line">    <span class="keyword">return</span> retsocket;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来就是最关键的收发数据的阶段了，我们看下<strong><strong>ShortLink::__RunReadWrite</strong></strong>:</p>
<figure class="highlight zephir"><table><tr><td class="code"><pre><span class="line">void ShortLink::__RunReadWrite(SOCKET _socket, <span class="keyword">int</span>&amp; _err_type, <span class="keyword">int</span>&amp; _err_code, ConnectProfile&amp; _conn_profile) &#123;</span><br><span class="line">	xmessage2_define(message)(TSF<span class="string">&quot;taskid:%_, cgi:%_, @%_&quot;</span>, task_.taskid, task_.cgi, this);</span><br><span class="line"></span><br><span class="line">	std::string url;</span><br><span class="line">	std::map&lt;std::string, std::string&gt; headers;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line">	<span class="keyword">if</span> (kIPSourceProxy == _conn_profile.ip_type) &#123;</span><br><span class="line">		url += <span class="string">&quot;http://&quot;</span>;</span><br><span class="line">		url += _conn_profile.host;</span><br><span class="line">	&#125;</span><br><span class="line">	url += task_.cgi;</span><br><span class="line">    <span class="comment">//http:// + _conn_profile.host + task_.cgi</span></span><br><span class="line">	headers[http::HeaderFields::KStringHost] = _conn_profile.host;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//.......</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//构建出请求后，将请求输出到out_buff</span></span><br><span class="line">	AutoBuffer out_buff;</span><br><span class="line">    shortlink_pack(url, headers, send_body_, send_extend_, out_buff, tracker_.get());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发送请求数据</span></span><br><span class="line">	<span class="keyword">int</span> send_ret = block_socket_send(_socket, (<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>*)out_buff.Ptr(), (<span class="keyword">unsigned</span> <span class="keyword">int</span>)out_buff.Length(), breaker_, _err_code);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line">	<span class="comment">//recv response</span></span><br><span class="line">    AutoBuffer body;</span><br><span class="line">	AutoBuffer recv_buf;</span><br><span class="line">	AutoBuffer extension;</span><br><span class="line">    <span class="keyword">int</span>        status_code = <span class="number">-1</span>;</span><br><span class="line">	off_t recv_pos = <span class="number">0</span>;</span><br><span class="line">	MemoryBodyReceiver* receiver = <span class="keyword">new</span> MemoryBodyReceiver(body);</span><br><span class="line">	http::Parser parser(receiver, <span class="keyword">true</span>);</span><br><span class="line">	<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">		<span class="keyword">int</span> recv_ret = block_socket_recv(_socket, recv_buf, KBufferSize, breaker_, _err_code, <span class="number">5000</span>);</span><br><span class="line">		<span class="comment">//错误校验</span></span><br><span class="line">		Parser::TRecvStatus parse_status = parser.Recv(recv_buf.Ptr(recv_buf.Length() - recv_ret), recv_ret);</span><br><span class="line">        <span class="keyword">if</span> (parser.FirstLineReady()) &#123;</span><br><span class="line">            <span class="comment">//获取状态码</span></span><br><span class="line">            status_code = parser.Status().StatusCode();</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="keyword">if</span> (parse_status == http::Parser::kFirstLineError) &#123;</span><br><span class="line">            <span class="comment">//....</span></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (parse_status == http::Parser::kHeaderFieldsError) &#123;</span><br><span class="line">            <span class="comment">//....</span></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (parse_status == http::Parser::kBodyError) &#123;</span><br><span class="line">            <span class="comment">//.....</span></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (parse_status == http::Parser::kEnd) &#123;</span><br><span class="line">			<span class="keyword">if</span> (status_code != <span class="number">200</span>) &#123;</span><br><span class="line">                <span class="comment">//......</span></span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				__OnResponse(kEctOK, status_code, body, extension, _conn_profile, <span class="keyword">true</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">//........</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><strong>ShortLink::__RunReadWrite</strong></strong> 会先调用shortlink_pack将所有的请求打包，然后通过block_socket_send发出去，然后不断轮询调用block_socket_recv获得请求，如果获得成功那么调用__OnResponse，我们之前在介绍创建ShortLink的时候会将ShortLink的__OnResponse方法与ShortLinkTaskManager::__OnResponse进行绑定，所以这里会触发ShortLinkTaskManager::__OnResponse的调用。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void ShortLinkTaskManager::<span class="constructor">__OnResponse(ShortLinkInterface<span class="operator">*</span> <span class="params">_worker</span>, ErrCmdType <span class="params">_err_type</span>, <span class="params">int</span> <span class="params">_status</span>, AutoBuffer&amp; <span class="params">_body</span>, AutoBuffer&amp; <span class="params">_extension</span>, <span class="params">bool</span> <span class="params">_cancel_retry</span>, ConnectProfile&amp; <span class="params">_conn_profile</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//.......</span></span><br><span class="line">    <span class="built_in">int</span> handle_type = <span class="constructor">Buf2Resp(<span class="params">it</span>-&gt;<span class="params">task</span>.<span class="params">taskid</span>, <span class="params">it</span>-&gt;<span class="params">task</span>.<span class="params">user_context</span>, <span class="params">_body</span>, <span class="params">_extension</span>, <span class="params">err_code</span>, Task::<span class="params">kChannelShort</span>)</span>;</span><br><span class="line"></span><br><span class="line">    switch(handle_type)&#123;</span><br><span class="line">        case kTaskFailHandleNoError: &#123;</span><br><span class="line">            <span class="comment">//.....</span></span><br><span class="line">        &#125; break;</span><br><span class="line">        case kTaskFailHandleSessionTimeout:&#123;</span><br><span class="line">            <span class="comment">//....</span></span><br><span class="line">        &#125; break;</span><br><span class="line">        case kTaskFailHandleRetryAllTasks: &#123;</span><br><span class="line">            <span class="comment">//.....</span></span><br><span class="line">        &#125; break;</span><br><span class="line">        case kTaskFailHandleTaskEnd: &#123;</span><br><span class="line">           <span class="comment">//.....</span></span><br><span class="line">        &#125; break;</span><br><span class="line">        case kTaskFailHandleDefault: &#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125; break;</span><br><span class="line">        default: &#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的方法中通过Buf2Resp回调将底层Socket 返回数据传递到业务逻辑层进行处理。</p>
<p><strong><strong>短链接的收发数据大致流程如下图所示</strong></strong>：</p>
<p><img src="/2019/12/05/Tencent-Mars-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/00004.png"></p>
<p><strong><strong>3.5.2 长链接StartTask</strong></strong></p>
<p>介绍了短链接的整个数据通信流程后再来看长链接会显得相对轻松点，在长链接部分我们最需要注意的是心跳包的处理，为了完整起见这里还是从NetWorkService的StartTask开始介绍：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="built_in">bool</span> LongLinkTaskManager::<span class="constructor">StartTask(<span class="params">const</span> Task&amp; <span class="params">_task</span>)</span> &#123;</span><br><span class="line">    <span class="comment">//将task放置到lst_cmd_数组</span></span><br><span class="line">    lst_cmd_.push<span class="constructor">_back(<span class="params">task</span>)</span>;</span><br><span class="line">    lst_cmd_.sort(__CompareTask);</span><br><span class="line">    <span class="comment">//执行RunLoop</span></span><br><span class="line">    <span class="constructor">__RunLoop()</span>;</span><br><span class="line">    return <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong><strong>LongLinkTaskManager::StartTask</strong></strong> 和 <strong><strong>ShortLinkTaskManager::StartTask</strong></strong> 一样都是将任务添加到lst_cmd_，然后执行__RunLoop。</p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="literal">void</span> LongLinkTaskManager<span class="type">::__RunLoop</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line">    __RunOnTimeout();</span><br><span class="line">    __RunOnStartTask();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!lst_cmd_.empty()) &#123;</span><br><span class="line">      <span class="comment">//........</span></span><br><span class="line">      MessageQueue<span class="type">::FasterMessage</span>(asyncreg_.Get(),</span><br><span class="line">                                  MessageQueue<span class="type">::Message</span>((MessageQueue<span class="type">::MessageTitle_t</span>)this, boost<span class="type">::bind</span>(&amp;LongLinkTaskManager<span class="type">::__RunLoop</span>, this), <span class="string">&quot;LongLinkTaskManager::__RunLoop&quot;</span>),</span><br><span class="line">                                  MessageQueue<span class="type">::MessageTiming</span>(<span class="number">1000</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//......</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><strong>__RunLoop</strong></strong>和短连接也没啥两样，最主要的工作还是放在__RunOnStartTask中，然后每间隔1秒重新发送一个FasterMessage。继续执行__RunLoop：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">void LongLinkTaskManager::<span class="constructor">__RunOnStartTask()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//.......</span></span><br><span class="line">    <span class="built_in">bool</span> canretry = curtime - lastbatcherrortime_ &gt;= retry_interval_;<span class="comment">//超时间隔是否达到指定的要求</span></span><br><span class="line">    <span class="built_in">bool</span> canprint = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">int</span> sent_count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (first != last) &#123;</span><br><span class="line">        std::<span class="built_in">list</span>&lt;TaskProfile&gt;::iterator next = first;</span><br><span class="line">        ++next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当前任务已经在运行了</span></span><br><span class="line">        <span class="comment">//.......</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//重试间隔, 不影响第一次发送的任务</span></span><br><span class="line">        <span class="comment">//.......</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 登录处理</span></span><br><span class="line">        <span class="comment">//.....</span></span><br><span class="line"></span><br><span class="line">        AutoBuffer bufreq;</span><br><span class="line">        AutoBuffer buffer_extension;</span><br><span class="line">        <span class="built_in">int</span> error_code = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果未进行雪崩检测则进行一次雪崩检测</span></span><br><span class="line">        <span class="keyword">if</span> (!first-&gt;antiavalanche_checked) &#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">           first-&gt;antiavalanche_checked = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//确保长链接处于连接状态</span></span><br><span class="line">		<span class="keyword">if</span> (!longlinkconnectmon_-&gt;<span class="constructor">MakeSureConnected()</span>) &#123;</span><br><span class="line">            <span class="comment">//........</span></span><br><span class="line">		&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果当前请求缓存是空的则再次通过Req2Buf从上层拿到上层构建的请求</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="number">0</span><span class="operator"> == </span>bufreq.<span class="constructor">Length()</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!<span class="constructor">Req2Buf(<span class="params">first</span>-&gt;<span class="params">task</span>.<span class="params">taskid</span>, <span class="params">first</span>-&gt;<span class="params">task</span>.<span class="params">user_context</span>, <span class="params">bufreq</span>, <span class="params">buffer_extension</span>, <span class="params">error_code</span>, Task::<span class="params">kChannelLong</span>)</span>) &#123;</span><br><span class="line">				<span class="constructor">__SingleRespHandle(<span class="params">first</span>, <span class="params">kEctEnDecode</span>, <span class="params">error_code</span>, <span class="params">kTaskFailHandleTaskEnd</span>, <span class="params">longlink_</span>-&gt;Profile()</span>);</span><br><span class="line">				first = next;</span><br><span class="line">				continue;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 雪崩检测</span></span><br><span class="line">            <span class="comment">//......</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		first-&gt;transfer_profile.loop_start_task_time = ::gettickcount<span class="literal">()</span>;</span><br><span class="line">        first-&gt;transfer_profile.first_pkg_timeout = <span class="constructor">__FirstPkgTimeout(<span class="params">first</span>-&gt;<span class="params">task</span>.<span class="params">server_process_cost</span>, <span class="params">bufreq</span>.Length()</span>, sent_count, dynamic_timeout_.<span class="constructor">GetStatus()</span>);</span><br><span class="line">        first-&gt;current_dyntime_status = (first-&gt;task.server_process_cost &lt;= <span class="number">0</span>) ? dynamic_timeout_.<span class="constructor">GetStatus()</span> : kEValuating;</span><br><span class="line">        first-&gt;transfer_profile.read_write_timeout = <span class="constructor">__ReadWriteTimeout(<span class="params">first</span>-&gt;<span class="params">transfer_profile</span>.<span class="params">first_pkg_timeout</span>)</span>;</span><br><span class="line">        first-&gt;transfer_profile.send_data_size = bufreq.<span class="constructor">Length()</span>;</span><br><span class="line">        <span class="comment">//调用longlink_-&gt;Send 发送数据</span></span><br><span class="line">        first-&gt;running_id = longlink_-&gt;<span class="constructor">Send(<span class="params">bufreq</span>, <span class="params">buffer_extension</span>, <span class="params">first</span>-&gt;<span class="params">task</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//.......</span></span><br><span class="line">        ++sent_count;</span><br><span class="line">        first = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>__RunOnStartTask 中最关键的部分在于<strong><strong>MakeSureConnected</strong></strong>* 以及 <strong><strong>LongLink::Send</strong></strong></p>
<p>MakeSureConnected 起始在初始化Mars的时候已经简单介绍过了，我们这里展开介绍下，主要还是看，心跳包的控制：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="built_in">bool</span> LongLinkConnectMonitor::<span class="constructor">MakeSureConnected()</span> &#123;</span><br><span class="line">    <span class="constructor">__IntervalConnect(<span class="params">kTaskConnect</span>)</span>;</span><br><span class="line">    return LongLink::kConnected<span class="operator"> == </span>longlink_.<span class="constructor">ConnectStatus()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uint64_t LongLinkConnectMonitor::<span class="constructor">__IntervalConnect(<span class="params">int</span> <span class="params">_type</span>)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果连接状态为正在连接或者已经连接的情况下返回0，这时候不会自动重连</span></span><br><span class="line">    <span class="keyword">if</span> (LongLink::kConnecting<span class="operator"> == </span>longlink_.<span class="constructor">ConnectStatus()</span><span class="operator"> || </span>LongLink::kConnected<span class="operator"> == </span>longlink_.<span class="constructor">ConnectStatus()</span>) return <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//获取下一次心跳时间</span></span><br><span class="line">    uint64_t interval =  <span class="constructor">__Interval(<span class="params">_type</span>, <span class="params">activelogic_</span>)</span><span class="operator"> * </span><span class="number">1000</span>ULL;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">    <span class="keyword">if</span> (posttime &gt;= interval) &#123;</span><br><span class="line">        <span class="built_in">bool</span> ret = longlink_.<span class="constructor">MakeSureConnected(&amp;<span class="params">newone</span>)</span>;</span><br><span class="line">        <span class="comment">//....</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//....</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们重点看下****__Interval*****：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">static unsigned long __Interval(<span class="built_in">int</span> _type, <span class="keyword">const</span> ActiveLogic&amp; _activelogic) &#123;</span><br><span class="line">    </span><br><span class="line">    unsigned long <span class="built_in">int</span>erval = sg_interval[_type][__CurActiveState(_activelogic)];<span class="comment">/*获得间隔时间*/</span></span><br><span class="line">    <span class="keyword">if</span> (kLongLinkConnect != _type) <span class="keyword">return</span> <span class="built_in">int</span>erval;</span><br><span class="line">    <span class="keyword">if</span> (__CurActiveState(_activelogic) == kInactive || __CurActiveState(_activelogic) == kForgroundActive) &#123;  <span class="comment">// now - LastForegroundChangeTime&gt;10min</span></span><br><span class="line">        <span class="comment">//不活跃的情况下用户名为空</span></span><br><span class="line">        <span class="keyword">if</span> (!_activelogic.IsActive() &amp;&amp; GetAccountInfo().username.empty()) &#123;</span><br><span class="line">            <span class="built_in">int</span>erval = kNoAccountInfoInactiveInterval;</span><br><span class="line">            xwarn2(TSF<span class="string">&quot;no account info and inactive, interval:%_&quot;</span>, <span class="built_in">int</span>erval);</span><br><span class="line">        <span class="comment">//无网络的情况下</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (kNoNet == getNetInfo()) &#123;</span><br><span class="line">            <span class="built_in">int</span>erval = <span class="built_in">int</span>erval * kNoNetSaltRate + kNoNetSaltRise;</span><br><span class="line">            xinfo2(TSF<span class="string">&quot;no net, interval:%0&quot;</span>, <span class="built_in">int</span>erval);</span><br><span class="line">        <span class="comment">//无用户名的情况下</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (GetAccountInfo().username.empty()) &#123;</span><br><span class="line">            <span class="built_in">int</span>erval = <span class="built_in">int</span>erval * kNoAccountInfoSaltRate + kNoAccountInfoSaltRise;</span><br><span class="line">            xinfo2(TSF<span class="string">&quot;no account info, interval:%0&quot;</span>, <span class="built_in">int</span>erval);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// default value</span></span><br><span class="line">			<span class="built_in">int</span>erval += rand() % (<span class="number">20</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>erval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它会根据连接类型，当前设备活跃状态设置下一次心跳的时间，它的值存在二维数组sg_interval中：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">                            kForgroundOneMinute | kForgroundTenMinute | kForgroundActive | kBackgroundActive | kInactive</span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">const</span> sg_interval[][<span class="number">5</span>]  = &#123;</span><br><span class="line">    kTaskConnect:           &#123;   <span class="number">5</span>,                         <span class="number">10</span>,                 <span class="number">20</span>,                 <span class="number">30</span>,             <span class="number">300</span>&#125;,</span><br><span class="line">    kLongLinkConnect:       &#123;   <span class="number">15</span>,                        <span class="number">30</span>,                 <span class="number">240</span>,                <span class="number">300</span>,            <span class="number">600</span>&#125;,</span><br><span class="line">    kNetworkChangeConnect:  &#123;   <span class="number">0</span>,                          <span class="number">0</span>,                   <span class="number">0</span>,                  <span class="number">0</span>,              <span class="number">0</span>&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们继续回到<strong><strong>LongLink::MakeSureConnected</strong></strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">LongLink::MakeSureConnected</span><span class="params">(<span class="type">bool</span>* _newone)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//.......</span></span><br><span class="line">    thread_.<span class="built_in">start</span>(&amp;newone);</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><strong>LongLink::MakeSureConnected</strong></strong>的处理非常简单只是调用了thread_.start，实际上会执行<strong><strong>LongLink::__Run</strong></strong>方法：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void LongLink::<span class="constructor">__Run()</span> &#123;</span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line">    SOCKET sock = <span class="constructor">__RunConnect(<span class="params">conn_profile</span>)</span>;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="constructor">__RunReadWrite(<span class="params">sock</span>, <span class="params">errtype</span>, <span class="params">errcode</span>, <span class="params">conn_profile</span>)</span>;</span><br><span class="line">    </span><br><span class="line">    socket<span class="constructor">_close(<span class="params">sock</span>)</span>;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><strong>LongLink::__Run</strong></strong>方法和短链接一样都只执行两个方法****__RunConnect<strong><strong>创建SOCKET，</strong></strong>__RunReadWrite****开始运行读写循环。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">SOCKET LongLink::<span class="constructor">__RunConnect(ConnectProfile&amp; <span class="params">_conn_profile</span>)</span> &#123;</span><br><span class="line">    <span class="comment">//........</span></span><br><span class="line">    LongLinkConnectObserver connect<span class="constructor">_observer(<span class="operator">*</span><span class="params">this</span>, <span class="params">ip_items</span>)</span>;</span><br><span class="line">    ComplexConnect com<span class="constructor">_connect(<span class="params">kLonglinkConnTimeout</span>, <span class="params">kLonglinkConnInteral</span>, <span class="params">kLonglinkConnInteral</span>, <span class="params">kLonglinkConnMax</span>)</span>;</span><br><span class="line">    SOCKET sock = com_connect.<span class="constructor">ConnectImpatient(<span class="params">vecaddr</span>, <span class="params">connectbreak_</span>, &amp;<span class="params">connect_observer</span>, <span class="params">proxy_info</span>.<span class="params">type</span>, <span class="params">proxy_addr</span>, <span class="params">proxy_info</span>.<span class="params">username</span>, <span class="params">proxy_info</span>.<span class="params">password</span>)</span>;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    return sock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>长短链接最大的区别还是在****__RunReadWrite****方法上：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void LongLink::<span class="constructor">__RunReadWrite(SOCKET <span class="params">_sock</span>, ErrCmdType&amp; <span class="params">_errtype</span>, <span class="params">int</span>&amp; <span class="params">_errcode</span>, ConnectProfile&amp; <span class="params">_profile</span>)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//心跳间隔时间一到就执行__OnAlarm</span></span><br><span class="line">    Alarm alarmnoopinterval(boost::bind(&amp;LongLink::__OnAlarm, this), <span class="literal">false</span>);</span><br><span class="line">    <span class="comment">//超时定时器</span></span><br><span class="line">    Alarm alarmnooptimeout(boost::bind(&amp;LongLink::__OnAlarm, this), <span class="literal">false</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//.......</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!alarmnoopinterval.<span class="constructor">IsWaiting()</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first_noop_sent<span class="operator"> &amp;&amp; </span>alarmnoopinterval.<span class="constructor">Status()</span> != Alarm::kOnAlarm) &#123;</span><br><span class="line">                xassert2(<span class="literal">false</span>, <span class="string">&quot;noop interval alarm not running&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">          </span><br><span class="line">            <span class="keyword">if</span>(first_noop_sent<span class="operator"> &amp;&amp; </span>alarmnoopinterval.<span class="constructor">Status()</span><span class="operator"> == </span>Alarm::kOnAlarm) &#123;</span><br><span class="line">              <span class="constructor">__NotifySmartHeartbeatJudgeDozeStyle()</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            xgroup2<span class="constructor">_define(<span class="params">noop_xlog</span>)</span>;</span><br><span class="line">            uint64_t last_noop_interval = alarmnoopinterval.<span class="constructor">After()</span>;</span><br><span class="line">            uint64_t last_noop_actual_interval = (alarmnoopinterval.<span class="constructor">Status()</span><span class="operator"> == </span>Alarm::kOnAlarm) ? alarmnoopinterval.<span class="constructor">ElapseTime()</span> : <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">bool</span> has_late_toomuch = (last_noop_actual_interval &gt;= (<span class="number">15</span>*<span class="number">60</span>*<span class="number">1000</span>));</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//发送起始心跳</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="constructor">__NoopReq(<span class="params">noop_xlog</span>, <span class="params">alarmnooptimeout</span>, <span class="params">has_late_toomuch</span>)</span>) &#123;</span><br><span class="line">                nooping = <span class="literal">true</span>;</span><br><span class="line">                <span class="constructor">__NotifySmartHeartbeatHeartReq(<span class="params">_profile</span>, <span class="params">last_noop_interval</span>, <span class="params">last_noop_actual_interval</span>)</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            first_noop_sent = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">//获得下一个心跳时间</span></span><br><span class="line">            uint64_t noop_interval = <span class="constructor">__GetNextHeartbeatInterval()</span>;</span><br><span class="line">            alarmnoopinterval.<span class="constructor">Cancel()</span>;</span><br><span class="line">            <span class="comment">//启动心跳计时</span></span><br><span class="line">            alarmnoopinterval.<span class="constructor">Start((<span class="params">int</span>)</span>noop_interval);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//.........    </span></span><br><span class="line">        <span class="keyword">if</span> (sel.<span class="constructor">Write_FD_ISSET(<span class="params">_sock</span>)</span><span class="operator"> &amp;&amp; </span>!lstsenddata_.empty<span class="literal">()</span>) &#123;</span><br><span class="line">            xgroup2<span class="constructor">_define(<span class="params">xlog_group</span>)</span>;</span><br><span class="line">            xinfo2(TSF<span class="string">&quot;task socket send sock:%0, &quot;</span>, _sock) &gt;&gt; xlog_group;</span><br><span class="line">            </span><br><span class="line">            iovec* vecwrite = (iovec*)calloc(lstsenddata_.size<span class="literal">()</span>, sizeof(iovec));</span><br><span class="line">            unsigned <span class="built_in">int</span> offset = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//将数据放到缓存中，lstsenddata_是Send方法添加的。</span></span><br><span class="line">            <span class="keyword">for</span> (auto it = lstsenddata_.<span class="keyword">begin</span><span class="literal">()</span>; it != lstsenddata_.<span class="keyword">end</span><span class="literal">()</span>; ++it) &#123;</span><br><span class="line">                vecwrite<span class="literal">[<span class="identifier">offset</span>]</span>.iov_base = it-&gt;second-&gt;<span class="constructor">PosPtr()</span>;</span><br><span class="line">                vecwrite<span class="literal">[<span class="identifier">offset</span>]</span>.iov_len = it-&gt;second-&gt;<span class="constructor">PosLength()</span>;</span><br><span class="line">                ++offset;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//写到发送端口，将数据发送出去</span></span><br><span class="line">            ssize_t writelen = writev(_sock, vecwrite, (<span class="built_in">int</span>)lstsenddata_.size<span class="literal">()</span>);</span><br><span class="line">            free(vecwrite);</span><br><span class="line">            <span class="comment">//获得下一个心跳时间</span></span><br><span class="line">            unsigned long long noop_interval = <span class="constructor">__GetNextHeartbeatInterval()</span>;</span><br><span class="line">            alarmnoopinterval.<span class="constructor">Cancel()</span>;</span><br><span class="line">            alarmnoopinterval.<span class="constructor">Start((<span class="params">int</span>)</span>noop_interval);</span><br><span class="line"></span><br><span class="line">            auto it = lstsenddata_.<span class="keyword">begin</span><span class="literal">()</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> (it != lstsenddata_.<span class="keyword">end</span><span class="literal">()</span><span class="operator"> &amp;&amp; </span><span class="number">0</span> &lt; writelen) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="number">0</span><span class="operator"> == </span>it-&gt;second-&gt;<span class="constructor">Pos()</span><span class="operator"> &amp;&amp; </span>OnSend) <span class="constructor">OnSend(<span class="params">it</span>-&gt;<span class="params">first</span>.<span class="params">taskid</span>)</span>;</span><br><span class="line">                <span class="keyword">if</span> ((size_t)writelen &gt;= it-&gt;second-&gt;<span class="constructor">PosLength()</span>) &#123;</span><br><span class="line">                   <span class="comment">//......</span></span><br><span class="line">                    LongLinkNWriteData nwrite(it-&gt;second-&gt;<span class="constructor">Length()</span>, it-&gt;first);</span><br><span class="line">                    nsent_datas.push<span class="constructor">_back(<span class="params">nwrite</span>)</span>;</span><br><span class="line">                    it = lstsenddata_.erase(it);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//......</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (sel.<span class="constructor">Read_FD_ISSET(<span class="params">_sock</span>)</span>) &#123;</span><br><span class="line">            bufrecv.<span class="constructor">AllocWrite(64 <span class="operator">*</span> 1024, <span class="params">false</span>)</span>;</span><br><span class="line">            ssize_t recvlen = recv(_sock, bufrecv.<span class="constructor">PosPtr()</span>, <span class="number">64</span><span class="operator"> * </span><span class="number">1024</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="comment">//.......</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="number">0</span> &lt; bufrecv.<span class="constructor">Length()</span>) &#123;</span><br><span class="line">                uint32_t cmdid = <span class="number">0</span>;</span><br><span class="line">                uint32_t taskid = Task::kInvalidTaskID;</span><br><span class="line">                size_t packlen = <span class="number">0</span>;</span><br><span class="line">                AutoBuffer body;</span><br><span class="line">                AutoBuffer extension;</span><br><span class="line">                <span class="comment">//读取数据，解压数据</span></span><br><span class="line">                <span class="built_in">int</span> unpackret = longlink<span class="constructor">_unpack(<span class="params">bufrecv</span>, <span class="params">cmdid</span>, <span class="params">taskid</span>, <span class="params">packlen</span>, <span class="params">body</span>, <span class="params">extension</span>, <span class="params">tracker_</span>.<span class="params">get</span>()</span>);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//.......</span></span><br><span class="line">                <span class="keyword">if</span> (LONGLINK_UNPACK_STREAM_PACKAGE<span class="operator"> == </span>unpackret) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (OnRecv)</span><br><span class="line">                        <span class="constructor">OnRecv(<span class="params">taskid</span>, <span class="params">packlen</span>, <span class="params">packlen</span>)</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="constructor">__NoopResp(<span class="params">cmdid</span>, <span class="params">taskid</span>, <span class="params">stream_resp</span>.<span class="params">stream</span>, <span class="params">stream_resp</span>.<span class="params">extension</span>, <span class="params">alarmnooptimeout</span>, <span class="params">nooping</span>, <span class="params">_profile</span>)</span>) &#123;</span><br><span class="line">                    <span class="comment">//交给上层处理</span></span><br><span class="line">                    <span class="keyword">if</span> (OnResponse)</span><br><span class="line">                        <span class="constructor">OnResponse(<span class="params">kEctOK</span>, 0, <span class="params">cmdid</span>, <span class="params">taskid</span>, <span class="params">stream_resp</span>.<span class="params">stream</span>, <span class="params">stream_resp</span>.<span class="params">extension</span>, <span class="params">_profile</span>)</span>;</span><br><span class="line">					sent_taskids.erase(taskid);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="comment">//............</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="built_in">bool</span> LongLink::<span class="constructor">Send(<span class="params">const</span> AutoBuffer&amp; <span class="params">_body</span>, <span class="params">const</span> AutoBuffer&amp; <span class="params">_extension</span>, <span class="params">const</span> Task&amp; <span class="params">_task</span>)</span> &#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    lstsenddata_.push<span class="constructor">_back(<span class="params">std</span>::<span class="params">make_pair</span>(<span class="params">_task</span>, <span class="params">move_wrapper</span>&lt;AutoBuffer&gt;(AutoBuffer()</span>)));</span><br><span class="line">    longlink<span class="constructor">_pack(<span class="params">_task</span>.<span class="params">cmdid</span>, <span class="params">_task</span>.<span class="params">taskid</span>, <span class="params">_body</span>, <span class="params">_extension</span>, <span class="params">lstsenddata_</span>.<span class="params">back</span>()</span>.second, tracker_.get<span class="literal">()</span>);</span><br><span class="line">    lstsenddata_.back<span class="literal">()</span>.second-&gt;<span class="constructor">Seek(0, AutoBuffer::ESeekStart)</span>;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    return <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于长链接的数据收发，在发送的时候会调用<strong><strong>LongLink::Send</strong></strong>这时候会将数据放置到lstsenddata_，在有写数据的socket的时候，会将lstsenddata_的数据调用writev写到网络端口，从而发送出去，而读数据和短链接流程类似都是将数据从端口读出，然后通过onResponse将数据交给LongLink,再由LongLink将数据交给LongLinkManager,LongLinkManager再将数据通过持有的Req2Buf callback，将数据传递到应用层。</p>
<p>整个Mars的流程图如下所示：<br><img src="/2019/12/05/Tencent-Mars-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/00005.png"></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/iOS-%E5%BC%80%E6%BA%90%E5%BA%93%E5%88%86%E6%9E%90/">iOS 开源库分析</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/iOS-开源库分析/">iOS 开源库分析</a>
  </div>

</div>



<div class="comments-count">
	
	  	<span></span>
		<a href="/2019/12/05/Tencent-Mars-源码解析/#comments" class="ds-thread-count comments-count-link" data-thread-key="2019/12/05/Tencent-Mars-源码解析/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/12/04/YYAsyncLayer-源码解析/" title="YYAsyncLayer 源码解析" itemprop="url">YYAsyncLayer 源码解析</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Edgar" target="_blank" itemprop="author">Edgar</a>
		
  <p class="article-time">
    <time datetime="2019-12-03T18:08:30.000Z" itemprop="datePublished"> Published 2019-12-04</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h5 id="开源库信息"><a href="#开源库信息" class="headerlink" title="开源库信息"></a>开源库信息</h5><ul>
<li>开源地址: <a target="_blank" rel="noopener" href="https://github.com/ibireme/YYAsyncLayer">YYAsyncLayer</a></li>
</ul>
<h5 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h5><p>我们在分析代码之前先看下YYAsyncLayer应用层的用法，下面是官网上给出的一个例子：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YYLabel</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)setText:(<span class="built_in">NSString</span> *)text &#123;</span><br><span class="line">    _text = text.copy;</span><br><span class="line">    [[YYTransaction transactionWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(contentsNeedUpdated)] commit];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)layoutSubviews &#123;</span><br><span class="line">    [<span class="variable language_">super</span> layoutSubviews];</span><br><span class="line">    [[YYTransaction transactionWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(contentsNeedUpdated)] commit];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)contentsNeedUpdated &#123;</span><br><span class="line">    [<span class="keyword">self</span>.layer setNeedsDisplay];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> mark - YYAsyncLayer</span></span><br><span class="line"></span><br><span class="line">+ (Class)layerClass &#123;</span><br><span class="line">    <span class="keyword">return</span> YYAsyncLayer.class;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (YYAsyncLayerDisplayTask *)newAsyncDisplayTask &#123;</span><br><span class="line"></span><br><span class="line">    YYAsyncLayerDisplayTask *task = [YYAsyncLayerDisplayTask new];</span><br><span class="line">    task.willDisplay = ^(<span class="built_in">CALayer</span> *layer) &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    task.display = ^(<span class="built_in">CGContextRef</span> context, <span class="built_in">CGSize</span> size, <span class="type">BOOL</span>(^isCancelled)(<span class="type">void</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isCancelled()) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//.......</span></span><br><span class="line">        这里完成界面的绘制</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    task.didDisplay = ^(<span class="built_in">CALayer</span> *layer, <span class="type">BOOL</span> finished) &#123;</span><br><span class="line">        <span class="keyword">if</span> (finished) &#123;</span><br><span class="line">            <span class="comment">// finished</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// cancelled</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> task;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>在每个需要更新界面的地方，都需要调用：</p>
<figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line">[[YYTransaction transactionWithTarget:<span class="keyword">self</span> <span class="keyword">selector</span>:@<span class="keyword">selector</span>(contentsNeedUpdated)] commit]<span class="punctuation">;</span></span><br></pre></td></tr></table></figure>

<p>contentsNeedUpdated方法如下:</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">void</span>)contentsNeedUpdated &#123;</span><br><span class="line"><span class="string">    [self.layer setNeedsDisplay]</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它会调用setNeedsDisplay触发layer的绘制。而我们要绘制的内容都放在<strong><strong>newAsyncDisplayTask</strong></strong>方法中，在<strong><strong>newAsyncDisplayTask</strong></strong>方法中返回一个新建的YYAsyncLayerDisplayTask。在YYAsyncLayerDisplayTask的willDisplay，display，didDisplay中分别覆写对应的block在整个绘制过程中插入操作：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">- (YYAsyncLayerDisplayTask *)newAsyncDisplayTask &#123;</span><br><span class="line"></span><br><span class="line">    YYAsyncLayerDisplayTask *<span class="keyword">task</span> = [YYAsyncLayerDisplayTask <span class="keyword">new</span>];</span><br><span class="line">    <span class="keyword">task</span><span class="variable">.willDisplay</span> = ^(CALayer *layer) &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">task</span><span class="variable">.display</span> = ^(CGContextRef <span class="keyword">context</span>, CGSize size, BOOL(^isCancelled)(<span class="keyword">void</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isCancelled()) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//.......</span></span><br><span class="line">        这里完成界面的绘制</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">task</span><span class="variable">.didDisplay</span> = ^(CALayer *layer, BOOL finished) &#123;</span><br><span class="line">        <span class="keyword">if</span> (finished) &#123;</span><br><span class="line">            <span class="comment">// finished</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// cancelled</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">task</span>;</span><br><span class="line">&#125;</span><br><span class="line">@<span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>YYAsyncLayer代码量不多，我们下面就顺着上面的例子过下整个源码，整个过程分成两部分：YYTransaction的提交，以及异步绘制过程。</p>
<h5 id="1-YYTransaction的提交"><a href="#1-YYTransaction的提交" class="headerlink" title="1.YYTransaction的提交"></a>1.YYTransaction的提交</h5><p>首先是YYTransaction的创建，每个YYTransaction代表一个提交的操作，它有两个属性target，selector，这个不用过多解释吧，用于指定当前提交的操作是哪个对象中的哪个操作。</p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line">+ (YYTransaction *)transactionWithTarget:(id)<span class="keyword">target</span> selector:(SEL)selector&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">target</span> || !selector) <span class="keyword">return</span> nil;</span><br><span class="line">    YYTransaction *t = [YYTransaction <span class="keyword">new</span>];</span><br><span class="line">    t.<span class="keyword">target</span> = <span class="keyword">target</span>;</span><br><span class="line">    t.selector = selector;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们最关键的是要了解这些操作是提交到哪里？会在什么时候触发。我们继续往下看：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)commit &#123;</span><br><span class="line">    <span class="keyword">if</span> (!_target || !_selector) <span class="keyword">return</span>;</span><br><span class="line">    YYTransactionSetup();</span><br><span class="line">    [transactionSet addObject:<span class="keyword">self</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="type">void</span> YYTransactionSetup() &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        transactionSet = [<span class="built_in">NSMutableSet</span> new];</span><br><span class="line">        <span class="built_in">CFRunLoopRef</span> runloop = <span class="built_in">CFRunLoopGetMain</span>();</span><br><span class="line">        <span class="built_in">CFRunLoopObserverRef</span> observer;</span><br><span class="line">        observer = <span class="built_in">CFRunLoopObserverCreate</span>(<span class="built_in">CFAllocatorGetDefault</span>(),</span><br><span class="line">                                           kCFRunLoopBeforeWaiting | kCFRunLoopExit,</span><br><span class="line">                                           <span class="literal">true</span>,      <span class="comment">// repeat</span></span><br><span class="line">                                           <span class="number">0xFFFFFF</span>,  <span class="comment">// after CATransaction(2000000)</span></span><br><span class="line">                                           YYRunLoopObserverCallBack, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">CFRunLoopAddObserver</span>(runloop, observer, kCFRunLoopCommonModes);</span><br><span class="line">        <span class="built_in">CFRelease</span>(observer);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看过之前介绍RunLoop的文章会对上面的代码比较熟悉，<strong><strong>YYTransactionSetup</strong></strong>方法中，向主RunLoop中注册了一个Observer，在主RunLoop 进入休眠之前（<strong><strong>kCFRunLoopBeforeWaiting</strong></strong>）以及 主RunLoop退出（<strong><strong>kCFRunLoopExit</strong></strong>）之前会回调YYRunLoopObserverCallBack，这个observer的优先级为0xFFFFFF，CATransaction为2000000，也就是在CATransaction之后。我们看YYRunLoopObserverCallBack中的任务吧：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">void</span> YYRunLoopObserverCallBack(<span class="built_in">CFRunLoopObserverRef</span> observer, <span class="built_in">CFRunLoopActivity</span> activity, <span class="type">void</span> *info) &#123;</span><br><span class="line">    <span class="keyword">if</span> (transactionSet.count == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">NSSet</span> *currentSet = transactionSet;</span><br><span class="line">    transactionSet = [<span class="built_in">NSMutableSet</span> new];</span><br><span class="line">    [currentSet enumerateObjectsUsingBlock:^(YYTransaction *transaction, <span class="type">BOOL</span> *stop) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> clang diagnostic push</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> clang diagnostic ignored <span class="string">&quot;-Warc-performSelector-leaks&quot;</span></span></span><br><span class="line">        [transaction.target performSelector:transaction.selector];</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> clang diagnostic pop</span></span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><strong>YYRunLoopObserverCallBack</strong></strong> 方法中会遍历transactionSet中每个YYTransaction，通过performSelector执行提交的selector。<br>也就是在主RunLoop进入休眠，退出之前会将遍历当前提交的所有YYTransaction，执行里面的selector。在上面的例子中我们在selector中调用了[self.layer setNeedsDisplay]，也就是启动了layer的绘制，我们来看下绘制过程。</p>
<h5 id="2-异步绘制过程"><a href="#2-异步绘制过程" class="headerlink" title="2.异步绘制过程"></a>2.异步绘制过程</h5><p>在UIKit 中界面渲染是发生在主线程的，我们来看下YYAsyncLayer的异步绘制过程：</p>
<p>我们上面提到了在主RunLoop进入休眠，退出之前会将遍历当前提交的所有YYTransaction，执行里面的selector从而调用[self.layer setNeedsDisplay]，在YYAsyncLayer方法中覆写了setNeedsDisplay，它在调用父类的setNeedsDisplay之前，会调用****_cancelAsyncDisplay****：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">void</span>)setNeedsDisplay &#123;</span><br><span class="line"><span class="string">    [self _cancelAsyncDisplay]</span>;</span><br><span class="line"><span class="string">    [super setNeedsDisplay]</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>_cancelAsyncDisplay 只有一行代码：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">void</span>)_cancelAsyncDisplay &#123;</span><br><span class="line"><span class="string">    [_sentinel increase]</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>_sentinel其实是用来标记每次操作，增加了这个值之前的所有操作都会失效。在绘制代码中有如下的一行代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">YYSentinel</span> *sentinel = _sentinel;</span><br><span class="line">int32_t value = sentinel.<span class="property">value</span>;</span><br><span class="line"><span class="variable constant_">BOOL</span> (^isCancelled)(<span class="keyword">void</span>) = ^<span class="title function_">BOOL</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> value != sentinel.<span class="property">value</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>所以每次调用_cancelAsyncDisplay 就会导致 <strong><strong>value !&#x3D; sentinel.value</strong></strong>。从而isCancelled是YES,就会取消过期的操作。</p>
<p>我们继续往下看，在[super setNeedsDisplay]之后，会触发绘制过程：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">void</span>)display &#123;</span><br><span class="line">    <span class="keyword">super</span>.contents = <span class="keyword">super</span>.contents;</span><br><span class="line"><span class="string">    [self _displayAsync:_displaysAsynchronously]</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>display方法中会调用_displayAsync：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">- (void)_displayAsync:(BOOL)async &#123;</span><br><span class="line">    __strong id&lt;YYAsyncLayerDelegate&gt; delegate = (id)self.delegate;</span><br><span class="line">    YYAsyncLayerDisplayTask *task = <span class="literal">[<span class="identifier">delegate</span> <span class="identifier">newAsyncDisplayTask</span>]</span>;</span><br><span class="line">    <span class="keyword">if</span> (!task.display) &#123;</span><br><span class="line">        <span class="keyword">if</span> (task.willDisplay) task.will<span class="constructor">Display(<span class="params">self</span>)</span>;</span><br><span class="line">        self.contents = nil;</span><br><span class="line">        <span class="keyword">if</span> (task.didDisplay) task.did<span class="constructor">Display(<span class="params">self</span>, YES)</span>;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (async) &#123;</span><br><span class="line">        <span class="keyword">if</span> (task.willDisplay) task.will<span class="constructor">Display(<span class="params">self</span>)</span>;</span><br><span class="line">        YYSentinel *sentinel = _sentinel;</span><br><span class="line">        int32_t value = sentinel.value;</span><br><span class="line">        BOOL (^isCancelled)(void) = ^<span class="constructor">BOOL()</span> &#123;</span><br><span class="line">            return value != sentinel.value;</span><br><span class="line">        &#125;;</span><br><span class="line">        CGSize size = self.bounds.size;</span><br><span class="line">        BOOL opaque = self.opaque;</span><br><span class="line">        CGFloat scale = self.contentsScale;</span><br><span class="line">        CGColorRef backgroundColor = (opaque<span class="operator"> &amp;&amp; </span>self.backgroundColor) ? <span class="constructor">CGColorRetain(<span class="params">self</span>.<span class="params">backgroundColor</span>)</span> : NULL;</span><br><span class="line">        <span class="keyword">if</span> (size.width &lt; <span class="number">1</span><span class="operator"> || </span>size.height &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            CGImageRef image = (__bridge_retained CGImageRef)(self.contents);</span><br><span class="line">            self.contents = nil;</span><br><span class="line">            <span class="keyword">if</span> (image) &#123;</span><br><span class="line">                dispatch<span class="constructor">_async(YYAsyncLayerGetReleaseQueue()</span>, ^&#123;</span><br><span class="line">                    <span class="constructor">CFRelease(<span class="params">image</span>)</span>;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (task.didDisplay) task.did<span class="constructor">Display(<span class="params">self</span>, YES)</span>;</span><br><span class="line">            <span class="constructor">CGColorRelease(<span class="params">backgroundColor</span>)</span>;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        dispatch<span class="constructor">_async(YYAsyncLayerGetDisplayQueue()</span>, ^&#123;</span><br><span class="line">            <span class="keyword">if</span> (is<span class="constructor">Cancelled()</span>) &#123;</span><br><span class="line">                <span class="constructor">CGColorRelease(<span class="params">backgroundColor</span>)</span>;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="constructor">UIGraphicsBeginImageContextWithOptions(<span class="params">size</span>, <span class="params">opaque</span>, <span class="params">scale</span>)</span>;</span><br><span class="line">            CGContextRef context = <span class="constructor">UIGraphicsGetCurrentContext()</span>;</span><br><span class="line">            <span class="keyword">if</span> (opaque) &#123;</span><br><span class="line">                <span class="constructor">CGContextSaveGState(<span class="params">context</span>)</span>; &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!backgroundColor<span class="operator"> || </span><span class="constructor">CGColorGetAlpha(<span class="params">backgroundColor</span>)</span> &lt; <span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="constructor">CGContextSetFillColorWithColor(<span class="params">context</span>, [UIColor <span class="params">whiteColor</span>].CGColor)</span>;</span><br><span class="line">                        <span class="constructor">CGContextAddRect(<span class="params">context</span>, CGRectMake(0, 0, <span class="params">size</span>.<span class="params">width</span> <span class="operator">*</span> <span class="params">scale</span>, <span class="params">size</span>.<span class="params">height</span> <span class="operator">*</span> <span class="params">scale</span>)</span>);</span><br><span class="line">                        <span class="constructor">CGContextFillPath(<span class="params">context</span>)</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (backgroundColor) &#123;</span><br><span class="line">                        <span class="constructor">CGContextSetFillColorWithColor(<span class="params">context</span>, <span class="params">backgroundColor</span>)</span>;</span><br><span class="line">                        <span class="constructor">CGContextAddRect(<span class="params">context</span>, CGRectMake(0, 0, <span class="params">size</span>.<span class="params">width</span> <span class="operator">*</span> <span class="params">scale</span>, <span class="params">size</span>.<span class="params">height</span> <span class="operator">*</span> <span class="params">scale</span>)</span>);</span><br><span class="line">                        <span class="constructor">CGContextFillPath(<span class="params">context</span>)</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="constructor">CGContextRestoreGState(<span class="params">context</span>)</span>;</span><br><span class="line">                <span class="constructor">CGColorRelease(<span class="params">backgroundColor</span>)</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            task.display(context, size, isCancelled);</span><br><span class="line">            <span class="keyword">if</span> (is<span class="constructor">Cancelled()</span>) &#123;</span><br><span class="line">                <span class="constructor">UIGraphicsEndImageContext()</span>;</span><br><span class="line">                dispatch<span class="constructor">_async(<span class="params">dispatch_get_main_queue</span>()</span>, ^&#123;</span><br><span class="line">                    <span class="keyword">if</span> (task.didDisplay) task.did<span class="constructor">Display(<span class="params">self</span>, NO)</span>;</span><br><span class="line">                &#125;);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            UIImage *image = <span class="constructor">UIGraphicsGetImageFromCurrentImageContext()</span>;</span><br><span class="line">            <span class="constructor">UIGraphicsEndImageContext()</span>;</span><br><span class="line">            <span class="keyword">if</span> (is<span class="constructor">Cancelled()</span>) &#123;</span><br><span class="line">                dispatch<span class="constructor">_async(<span class="params">dispatch_get_main_queue</span>()</span>, ^&#123;</span><br><span class="line">                    <span class="keyword">if</span> (task.didDisplay) task.did<span class="constructor">Display(<span class="params">self</span>, NO)</span>;</span><br><span class="line">                &#125;);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            dispatch<span class="constructor">_async(<span class="params">dispatch_get_main_queue</span>()</span>, ^&#123;</span><br><span class="line">                <span class="keyword">if</span> (is<span class="constructor">Cancelled()</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (task.didDisplay) task.did<span class="constructor">Display(<span class="params">self</span>, NO)</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    self.contents = (__bridge id)(image.CGImage);</span><br><span class="line">                    <span class="keyword">if</span> (task.didDisplay) task.did<span class="constructor">Display(<span class="params">self</span>, YES)</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//..........</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>_displayAsync 代码很长我们只看异步绘制的情况：</p>
<figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line">__strong <span class="built_in">id</span><span class="operator">&lt;</span>YYAsyncLayerDelegate<span class="operator">&gt;</span> <span class="keyword">delegate</span> <span class="operator">=</span> (<span class="built_in">id</span>)self.<span class="keyword">delegate</span>;</span><br><span class="line">YYAsyncLayerDisplayTask <span class="operator">*</span>task <span class="operator">=</span> [<span class="keyword">delegate</span> newAsyncDisplayTask];</span><br></pre></td></tr></table></figure>

<p>在_displayAsync的开始会调用上层的newAsyncDisplayTask，来创建一个<strong><strong>YYAsyncLayerDisplayTask</strong></strong></p>
<p>接下来就进行异步绘制：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">dispatch<span class="constructor">_async(YYAsyncLayerGetDisplayQueue()</span>, ^&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (is<span class="constructor">Cancelled()</span>) &#123;</span><br><span class="line">        <span class="comment">//取消绘制</span></span><br><span class="line">        <span class="constructor">CGColorRelease(<span class="params">backgroundColor</span>)</span>;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建绘制上下文</span></span><br><span class="line">    <span class="constructor">UIGraphicsBeginImageContextWithOptions(<span class="params">size</span>, <span class="params">opaque</span>, <span class="params">scale</span>)</span>;</span><br><span class="line">    CGContextRef context = <span class="constructor">UIGraphicsGetCurrentContext()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (opaque<span class="comment">/*不透明*/</span>) &#123;</span><br><span class="line">        <span class="comment">//背景绘制</span></span><br><span class="line">        <span class="constructor">CGContextSaveGState(<span class="params">context</span>)</span>; &#123;</span><br><span class="line">            <span class="keyword">if</span> (!backgroundColor<span class="operator"> || </span><span class="constructor">CGColorGetAlpha(<span class="params">backgroundColor</span>)</span> &lt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="constructor">CGContextSetFillColorWithColor(<span class="params">context</span>, [UIColor <span class="params">whiteColor</span>].CGColor)</span>;</span><br><span class="line">                <span class="constructor">CGContextAddRect(<span class="params">context</span>, CGRectMake(0, 0, <span class="params">size</span>.<span class="params">width</span> <span class="operator">*</span> <span class="params">scale</span>, <span class="params">size</span>.<span class="params">height</span> <span class="operator">*</span> <span class="params">scale</span>)</span>);</span><br><span class="line">                <span class="constructor">CGContextFillPath(<span class="params">context</span>)</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (backgroundColor) &#123;</span><br><span class="line">                <span class="constructor">CGContextSetFillColorWithColor(<span class="params">context</span>, <span class="params">backgroundColor</span>)</span>;</span><br><span class="line">                <span class="constructor">CGContextAddRect(<span class="params">context</span>, CGRectMake(0, 0, <span class="params">size</span>.<span class="params">width</span> <span class="operator">*</span> <span class="params">scale</span>, <span class="params">size</span>.<span class="params">height</span> <span class="operator">*</span> <span class="params">scale</span>)</span>);</span><br><span class="line">                <span class="constructor">CGContextFillPath(<span class="params">context</span>)</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="constructor">CGContextRestoreGState(<span class="params">context</span>)</span>;</span><br><span class="line">        <span class="constructor">CGColorRelease(<span class="params">backgroundColor</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将绘制上下文传递出去调用YYAsyncLayerDisplayTask的display方法在上下文进行绘制</span></span><br><span class="line">    task.display(context, size, isCancelled);</span><br><span class="line">    <span class="comment">//.........</span></span><br><span class="line">    <span class="comment">//取出task.display绘制的图片image</span></span><br><span class="line">    UIImage *image = <span class="constructor">UIGraphicsGetImageFromCurrentImageContext()</span>;</span><br><span class="line">    <span class="constructor">UIGraphicsEndImageContext()</span>;</span><br><span class="line">    <span class="comment">//........</span></span><br><span class="line">    dispatch<span class="constructor">_async(<span class="params">dispatch_get_main_queue</span>()</span>, ^&#123;</span><br><span class="line">        <span class="keyword">if</span> (is<span class="constructor">Cancelled()</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (task.didDisplay) task.did<span class="constructor">Display(<span class="params">self</span>, NO)</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//在主线程中将image内容设置到self.contents</span></span><br><span class="line">            self.contents = (__bridge id)(image.CGImage);</span><br><span class="line">            <span class="keyword">if</span> (task.didDisplay) task.did<span class="constructor">Display(<span class="params">self</span>, YES)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面的代码中绘制部分都放在<strong><strong>YYAsyncLayerGetDisplayQueue</strong></strong>队列中完成，具体绘制的部分看上面的注释，最后在<strong><strong>dispatch_get_main_queue</strong></strong>队列中将绘制的界面image设置到self.contents。</p>
<p>那YYAsyncLayerGetDisplayQueue又是怎么组织的呢？</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">dispatch_queue_t</span> YYAsyncLayerGetDisplayQueue() &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> YYDispatchQueuePool_h</span></span><br><span class="line">    <span class="keyword">return</span> YYDispatchQueueGetForQOS(<span class="built_in">NSQualityOfServiceUserInitiated</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_QUEUE_COUNT 16</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> queueCount;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_queue_t</span> queues[MAX_QUEUE_COUNT];</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="keyword">static</span> int32_t counter = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        <span class="comment">//队列长度设置为处理器的数量</span></span><br><span class="line">        queueCount = (<span class="type">int</span>)[<span class="built_in">NSProcessInfo</span> processInfo].activeProcessorCount;</span><br><span class="line">        queueCount = queueCount &lt; <span class="number">1</span> ? <span class="number">1</span> : queueCount &gt; MAX_QUEUE_COUNT ? MAX_QUEUE_COUNT : queueCount;</span><br><span class="line">        <span class="keyword">if</span> ([<span class="built_in">UIDevice</span> currentDevice].systemVersion.floatValue &gt;= <span class="number">8.0</span>) &#123;</span><br><span class="line">            <span class="comment">// 比如我们电脑是四核的那么就创建四个串行dispatch_queue。</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>; i &lt; queueCount; i++) &#123;</span><br><span class="line">                dispatch_queue_attr_t attr = dispatch_queue_attr_make_with_qos_class(DISPATCH_QUEUE_SERIAL, QOS_CLASS_USER_INITIATED, <span class="number">0</span>);</span><br><span class="line">                queues[i] = dispatch_queue_create(<span class="string">&quot;com.ibireme.yykit.render&quot;</span>, attr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//.....</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    int32_t cur = OSAtomicIncrement32(&amp;counter);</span><br><span class="line">    <span class="keyword">if</span> (cur &lt; <span class="number">0</span>) cur = -cur;</span><br><span class="line">    <span class="comment">//每次在取队列的时候就会从queues[0]，queues[1]，queues[2]，queues[3] 选择一个串行队列返回，在上面完成绘制。</span></span><br><span class="line">    <span class="keyword">return</span> queues[(cur) % queueCount];</span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> MAX_QUEUE_COUNT</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里其实可以使用YYDispatchQueuePool，但是我们这里先看下不使用YYDispatchQueuePool的情景。上面代码中创建了和处理器数量相同的串行queues。每次会循环从这些队列中取出一个queues，在上面完成绘制，这样的好处是为了避免某些时候某些线程卡住了，导致不断为后来任务不断创建新的线程，导致线程爆炸。这个问题会在YYDispatchQueuePool中进行详细介绍。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/iOS-%E5%BC%80%E6%BA%90%E5%BA%93%E5%88%86%E6%9E%90/">iOS 开源库分析</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/iOS-开源库分析/">iOS 开源库分析</a>
  </div>

</div>



<div class="comments-count">
	
	  	<span></span>
		<a href="/2019/12/04/YYAsyncLayer-源码解析/#comments" class="ds-thread-count comments-count-link" data-thread-key="2019/12/04/YYAsyncLayer-源码解析/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/12/02/SRWebSocket介绍/" title="iOS开源库之SRWebSocket源码分析" itemprop="url">iOS开源库之SRWebSocket源码分析</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Edgar" target="_blank" itemprop="author">Edgar</a>
		
  <p class="article-time">
    <time datetime="2019-12-01T18:26:16.000Z" itemprop="datePublished"> Published 2019-12-02</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h4 id="开源库信息"><a href="#开源库信息" class="headerlink" title="开源库信息"></a>开源库信息</h4><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/facebook/SocketRocket">SRWebSocket</a></li>
</ul>
<h4 id="为什么需要WebSocket"><a href="#为什么需要WebSocket" class="headerlink" title="为什么需要WebSocket"></a>为什么需要WebSocket</h4><p>对于一个应用来说Http协议几乎是必备的协议，当客户端需要数据的时候通过Http协议发起请求，服务端响应请求返回对应的数据给客户端，但是如果客户端需要实时知道服务的某个状态变化怎么办？在不借助WebSocket的情况下，只能通过轮询来不断向服务端查询这个状态，这种方式对服务端和客户端都会带来资源上的损耗，客户端要不断地发送请求给服务端来请求当前的状态，这种方式一来耗费了大量CPU时间，二来带来了不必要的流量损耗。对于服务端来说多出了一系列的无用的请求，给服务器带来了不必要的负担。最后的结果还是没办法做到真正的实时，当然这里可以做些优化，在某次拉取数据发现状态没有改变的时候，增加下一次请求的时间，直到达到某个阈值后再减小两次请求的间隔时间。还可以使用长轮询：客户端发送一个超时时间很长的请求，服务端长时间持有这个请求，在服务端状态改变的时候通过这个请求返回，长轮询这种方式虽然省去了大量无效请求，减少了服务器压力和一定的网络带宽的占用，但是还是需要保持大量的连接。</p>
<p>但是这里还需要明确一个问题：<strong><strong>Http长连接和WebSocket长连接的区别</strong></strong></p>
<p>要弄清楚这个问题必须要明确三个概念<strong><strong>HTTP keep-alive</strong></strong>,<strong><strong>Comet</strong></strong>,<strong><strong>WebSocket</strong></strong></p>
<p>在之前的HTTP 1.0 之前默认使用的是短连接，短连接的特点是客户端和服务端每进行一次通信就会建立一次连接，这里的连接指的是传输层的TCP连接，也就是说每次请求都会建立一次TCP连接，然后发送请求，等待收到服务端返回的请求后，断开这个连接。整个过程是由客户端驱动的，服务端只能响应某个具体的请求，不能主动和客户端建立连接发送数据。</p>
<p>HTTP 1.1之后就默认使用长连接，它会在响应头加入如下属性：</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">Connection:</span><span class="meta">keep</span>-alive；</span><br></pre></td></tr></table></figure>

<p>那么这种长连接是不是就可以实现客户端和服务端全双工通信呢？其实不能的，因为这里的长连接还是传输层的长连接并不是应用层面的长连接，它相对于HTTP 1.0 来说，每次请求客户端收到来自服务端的返回体之后，底层的TCP连接不会立马断掉，如果后续有 HTTP 请求还是会复用这个底层的TCP连接。但是应用层面上还是遵循了HTTP协议规定的一个Request，一个Response的过程。一个请求获得一个响应后应用层必定会断掉。而且只有客户端发起的请求才会有响应，也就是说整个过程还是客户端来驱动的，客户端索要数据，服务端响应请求返回数据。即使采用keep-alive技术来保证TCP连接不会断，如果服务端也无法主动给客户端发起一个HTTP请求。</p>
<p>Comet是指客户端发送一个HTTP请求，但是服务端不会立刻返回，而是一直持有着这个请求直到有客户端需要的内容后再返回，在这个期间这个 HTTP请求可以连接维持比较长的时间。类似一种服务端推送机制：客户端发起请求相当于先把连接建立好，等服务端有消息需要返回时再返回给客户端，但是本质还是不变的，服务器的每次数据下发都是针对客户端先前发起的某次请求，服务端不能无缘无故地向客户端下发数据。</p>
<p>而 <strong><strong>WebSocket</strong></strong>和<strong><strong>HTTP</strong></strong>两个协议在协议堆栈里面其实是两个对等的协议，都是位于应用层，是两个完全不同的概念，WebSocket可以不用像HTTP协议那样，要先有请求后服务端才能向客户端返回数据，它的长链接是应用层上的长连接，而不再单单是传输层上TCP上的长连接，但是它和HTTP协议都是基于TCP基础之上的。在WebSocket连接建立后，服务端可以主动地向客户端发送数据，从而实现全双工通讯。</p>
<p>所以什么是WebSocket,为什么需要有WebSocket? <strong><strong>WebSocket</strong></strong> 实际上是一个与Http协议一样都是基于TCP协议之上的应用层协议，它和Http协议的区别在于它不再遵循客户端主动发起请求，服务端响应的Request-Response 机制，而是可以在客户端没有发送请求的情况下，服务端主动下发数据给客户端。实现客户端和服务端的全双工通讯，也就是说WebSocket是为了弥补Http不能全双工数据通信的不足而推出的，连接一旦建立，双方可以随时向对方发送数据。</p>
<h4 id="WebSocket-协议简要介绍"><a href="#WebSocket-协议简要介绍" class="headerlink" title="WebSocket 协议简要介绍"></a>WebSocket 协议简要介绍</h4><p>WebSocket的默认端口是80和443,分别对应的协议为<strong><strong>ws:&#x2F;&#x2F;</strong></strong>,<strong><strong>wss:&#x2F;&#x2F;</strong></strong>,整个协议包含三大部分：<br><strong><strong>建立连接</strong></strong>，<strong><strong>握手</strong></strong>和<strong><strong>数据通信</strong></strong>。</p>
<p><strong><strong>建立连接</strong></strong></p>
<p>在客户端与服务端进行握手之前，客户端和服务端需要建立好连接：</p>
<ul>
<li><p>一个客户端对于相同的目标地址（这里简单理解成一个服务器IP），同一时刻只能有一个处于CONNECTING状态的连接。如果当前已有指向目标地址的连接处于CONNECTING状态，就要等待这个连接成功，或者建立失败之后才能建立新的连接。</p>
</li>
<li><p>如果客户端处于一个代理环境中，它首先要请求它的代理来建立一个到达目标地址的TCP连接。例如，如果客户端处于代理环境中，它想要连接某目标地址的80端口，它可能要首先发送以下消息：</p>
</li>
</ul>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CONNECT</span> <span class="string">example.com:80</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>example.com</span><br></pre></td></tr></table></figure>
<ul>
<li>如果客户端没有处于代理环境中，那么就需要建立一个到达目标地址的<strong><strong>直接</strong></strong>的TCP连接</li>
</ul>
<p><strong><strong>握手</strong></strong></p>
<p>建立好客户端和服务端的连接后，客户端就可以向服务端发起握手请求了。握手请求消息的方法必须是GET，HTTP版本必须大于1.1 。</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/chat</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>server.example.com</span><br><span class="line"><span class="attribute">Upgrade</span><span class="punctuation">: </span>websocket</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>Upgrade</span><br><span class="line"><span class="attribute">Sec-WebSocket-Key</span><span class="punctuation">: </span>dGhlIHNhbXBsZSBub25jZQ==</span><br><span class="line"><span class="attribute">Origin</span><span class="punctuation">: </span>http://example.com</span><br><span class="line"><span class="attribute">Sec-WebSocket-Protocol</span><span class="punctuation">: </span>chat, superchat</span><br><span class="line"><span class="attribute">Sec-WebSocket-Version</span><span class="punctuation">: </span>13</span><br></pre></td></tr></table></figure>

<p>出于兼容性的考虑，WS的建立连接还是依赖HTTP来实现，这种方式的好处是：握手时不容易被屏蔽，能通过各种 HTTP 代理服务器。</p>
<p>下面针对上述给出的包一一进行介绍：</p>
<ul>
<li>****Upgrade ****</li>
</ul>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Upgrade</span>是HTTP <span class="number">1</span>.<span class="number">1</span>中用于定义转换协议的header域，它表示如果服务器支持的话，客户端希望从已建立好的连接协议，切换到另外一个应用层协议，这里是从HTTP协议切换到WebSocket协议。</span><br></pre></td></tr></table></figure>

<ul>
<li>**** Connection ****</li>
</ul>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">HTTP</span> <span class="number">1</span>.<span class="number">1</span>中规定Upgrade只能应用在直接连接中，也就是说WS的连接不能通过中间人来转发，它必须是一个直接连接。如果客户端和服务器之间是通过代理连接的，那么在发送这个握手消息之前首先要发送CONNECT消息来建立直接连接。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>**** Sec-WebSocket-Key ****</li>
</ul>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">请求消息中的<span class="string">&quot;Sec-WebSocket-Key&quot;</span>是一个Base64编码的<span class="number">16</span>位随机字符，服务器端会用这些数据来构造出一个SHA-<span class="number">1</span>的信息摘要，把<span class="string">&quot;Sec-WebSocket-Key&quot;</span>加上一个魔幻字符串<span class="string">&quot;258EAFA5-E914-47DA-95CA-C5AB0DC85B11&quot;</span>。使用SHA-<span class="number">1</span>加密，然后进行<span class="built_in">BASE</span>-<span class="number">64</span>编码，将结果做为<span class="string">&quot;Sec-WebSocket-Accept&quot;</span>头的值，返回给客户端。</span><br></pre></td></tr></table></figure>

<ul>
<li>**** Origin ****</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">用于防止跨站攻击，客户端会使用这个来标识原始域。</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><strong>Sec-WebSocket-Protocol</strong></strong></li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">客户端支持的子协议的列表,这个字段用于协商应用子协议，在创建 WebSocket 对象的时候，可以传递一个可选的子协议数组，告诉服务器，客户端可以理解哪些协议。服务器必须从数据里面选择几个支持的协议进行返回，如果一个都不支持，那么会直接导致握手失败。客户端可以不发送子协议，但是一旦发送，服务器无法支持其中任意一个都会导致握手失败。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><strong><strong>Sec-WebSocket-Version</strong></strong></li>
</ul>
<figure class="highlight mathematica"><table><tr><td class="code"><pre><span class="line">客户端支持的<span class="variable">WS</span>协议的版本列表<span class="operator">,</span>客户端可以初始请求它选择的 <span class="variable">WebSocket</span> 协议版本<span class="operator">,</span>如果服务器支持请求的版本服务器将接受该版本。如果服务器不支持请求的版本，它会返回一个包含所有它所能支持的<span class="built_in">Sec</span><span class="operator">-</span><span class="variable">WebSocket</span><span class="operator">-</span><span class="built_in">Version</span>头字段。 在这时候客户端可以根据服务端返回的服务端支持的版本，重新构建请求发起握手。</span><br><span class="line">下面是一个服务端返回的响应头信息：</span><br><span class="line"></span><br><span class="line"><span class="variable">HTTP</span><span class="operator">/</span><span class="number">1.1</span> <span class="number">400</span> <span class="variable">Bad</span> <span class="variable">Request</span></span><br><span class="line"><span class="built_in">Sec</span><span class="operator">-</span><span class="variable">WebSocket</span><span class="operator">-</span><span class="built_in">Version</span><span class="operator">:</span> <span class="number">13</span><span class="operator">,</span> <span class="number">8</span></span><br></pre></td></tr></table></figure>

<p>在收到请求后服务端作为回应会返回如下的报文：</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">101</span> Switching Protocols</span><br><span class="line"><span class="attribute">Upgrade</span><span class="punctuation">: </span>websocket</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>Upgrade</span><br><span class="line"><span class="attribute">Sec-WebSocket-Accept</span><span class="punctuation">: </span>s3pPLMBiTxaQ9kYGzzhZRbK+xOo=  </span><br><span class="line"><span class="attribute">Sec-WebSocket-Protocol</span><span class="punctuation">: </span>chat</span><br></pre></td></tr></table></figure>

<p>101表示服务器收到了客户端切换协议的请求，并且同意切换到此协议，Sec-WebSocket-Accept的生成方式在上面已经介绍过了，通过这个步骤，客户端和服务端会建立起一个长连接。</p>
<p>客户端收到服务端发送过来的应答数据后，如果返回的状态码为101，则可以开始解析header域：</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="bullet">* </span>判断是否含有Upgrade头，且内容包含websocket。</span><br><span class="line"><span class="bullet">* </span>判断是否含有Connection头，且内容包含Upgrade</span><br><span class="line"><span class="bullet">* </span>判断是否含有Sec-WebSocket-Accept头，并对这个字段进行校验。</span><br><span class="line"><span class="bullet">* </span>如果含有Sec-WebSocket-Extensions头，要判断是否之前的Request握手带有此内容，如果没有，则连接失败。</span><br><span class="line"><span class="bullet">* </span>如果含有Sec-WebSocket-Protocol头，要判断是否之前的Request握手带有此协议，如果没有，则连接失败。</span><br></pre></td></tr></table></figure>

<p>上面最关键的就是Sec-WebSocket-Accept字段的校验。</p>
<p><strong><strong>WebSocket数据通信</strong></strong></p>
<p>WebSocket 会把应用的消息分割成一个或多个帧，接收方接到到多个帧会进行组装，等到接收到完整消息之后再通知接收端。</p>
<figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">0                   1                   2                   3</span><br><span class="line">0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">+-+-+-+-+-------+-+-------------+-------------------------------+</span><br><span class="line">|<span class="string">F</span>|<span class="string">R</span>|<span class="string">R</span>|<span class="string">R</span>|<span class="string"> opcode</span>|<span class="string">M</span>|<span class="string"> Payload len </span>|<span class="string">    Extended payload length    </span>|</span><br><span class="line">|<span class="string">I</span>|<span class="string">S</span>|<span class="string">S</span>|<span class="string">S</span>|<span class="string">  (4)  </span>|<span class="string">A</span>|<span class="string">     (7)     </span>|<span class="string">             (16/64)           </span>|</span><br><span class="line">|<span class="string">N</span>|<span class="string">V</span>|<span class="string">V</span>|<span class="string">V</span>|<span class="string">       </span>|<span class="string">S</span>|<span class="string">             </span>|<span class="string">   (if payload len==126/127)   </span>|</span><br><span class="line">|<span class="string"> </span>|<span class="string">1</span>|<span class="string">2</span>|<span class="string">3</span>|<span class="string">       </span>|<span class="string">K</span>|<span class="string">             </span>|<span class="string">                               </span>|</span><br><span class="line">+-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +</span><br><span class="line">|<span class="string">     Extended payload length continued, if payload len == 127  </span>|</span><br><span class="line">+ - - - - - - - - - - - - - - - +-------------------------------+</span><br><span class="line">|<span class="string">                               </span>|<span class="string">Masking-key, if MASK set to 1  </span>|</span><br><span class="line">+-------------------------------+-------------------------------+</span><br><span class="line">|<span class="string"> Masking-key (continued)       </span>|<span class="string">          Payload Data         </span>|</span><br><span class="line">+-------------------------------- - - - - - - - - - - - - - - - +</span><br><span class="line">:                     Payload Data continued ...                :</span><br><span class="line">+ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +</span><br><span class="line">|<span class="string">                     Payload Data continued ...                </span>|</span><br><span class="line">+---------------------------------------------------------------+</span><br></pre></td></tr></table></figure>

<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">FIN</span>      <span class="number">1</span>bit 表示信息的最后一帧，flag，也就是标记符</span><br><span class="line"><span class="attribute">RSV</span> <span class="number">1</span>-<span class="number">3</span>  <span class="number">1</span>bit each 以后备用的 默认都为 <span class="number">0</span></span><br><span class="line"><span class="attribute">Opcode</span>   <span class="number">4</span>bit 帧类型，稍后细说</span><br><span class="line"><span class="attribute">Mask</span>     <span class="number">1</span>bit 掩码，是否加密数据，只适用于客户端发给服务器的消息，客户端给服务器发送消息，这里一定为 <span class="number">1</span></span><br><span class="line"><span class="attribute">Payload</span>  <span class="number">7</span>bit 数据的长度</span><br><span class="line"><span class="attribute">Masking</span>-key      <span class="number">1</span> or <span class="number">4</span> bit 掩码Key</span><br><span class="line"><span class="attribute">Payload</span> data     (x + y) bytes 数据</span><br><span class="line"><span class="attribute">Extension</span> data   x bytes  扩展数据</span><br><span class="line"><span class="attribute">Application</span> data y bytes  程序数据</span><br></pre></td></tr></table></figure>

<p>Opcode 字段代表的意思如下所示：</p>
<figure class="highlight haml"><table><tr><td class="code"><pre><span class="line"><span class="tag">%<span class="selector-tag">x0</span></span>：表示一个延续帧。当Opcode为0时，表示本次数据传输采用了数据分片，当前收到的数据帧为其中一个数据分片。</span><br><span class="line"><span class="tag">%<span class="selector-tag">x1</span></span>：表示这是一个文本帧（frame）</span><br><span class="line"><span class="tag">%<span class="selector-tag">x2</span></span>：表示这是一个二进制帧（frame）</span><br><span class="line"><span class="tag">%<span class="selector-tag">x3</span></span>-7：保留的操作代码，用于后续定义的非控制帧。</span><br><span class="line"><span class="tag">%<span class="selector-tag">x8</span></span>：表示连接断开。</span><br><span class="line"><span class="tag">%<span class="selector-tag">x9</span></span>：表示这是一个ping操作。</span><br><span class="line"><span class="tag">%<span class="selector-tag">xA</span></span>：表示这是一个pong操作。</span><br><span class="line"><span class="tag">%<span class="selector-tag">xB</span></span>-F：保留的操作代码，用于后续定义的控制帧。</span><br></pre></td></tr></table></figure>

<p><strong><strong>WebSocket分帧规则</strong></strong></p>
<p>分帧是通过将消息分割为更小的一个个分段以更好地共享输出通道。</p>
<p>RFC 6455 规定的分帧规则如下：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">1</span>. 一个没有分片的消息由一个带有FIN值为<span class="number">1</span>以及一个非<span class="number">0</span>操作码的帧组成。</span><br><span class="line"><span class="attribute">2</span>. 一个分片的消息由单个带有FIN为<span class="number">0</span> 和一个非<span class="number">0</span>操作码的帧组成，跟随零个或多个带有FIN位为<span class="number">0</span>和操作码设置为<span class="number">0</span>的帧，且终止于一个带有FIN等于<span class="number">1</span>且操作码为<span class="number">0</span>的帧。 </span><br><span class="line"><span class="attribute">3</span>. 消息分片必须按发送者发送顺序交付给接收者，片段中的消息不能与片段中的另一个消息交替。</span><br><span class="line"><span class="attribute">4</span>. 控制帧本身必须不被分割，中间件必须不尝试改变控制帧的分片。</span><br><span class="line"><span class="attribute">5</span>. 一个端点必须能处理一个分片消息中间的控制帧。</span><br></pre></td></tr></table></figure>

<p>也就是说一个分帧后的数据可能会以如下形式呈现：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">开始帧 ：单个帧，FIN 设为 0，opcode 非 0；</span><br><span class="line">中间帧 ：0 个或多个帧，FIN 设为 0，opcode 设为 0；</span><br><span class="line">结束帧：单个帧，FIN 设为 1，opcode 设为 0的帧。</span><br><span class="line"></span><br><span class="line">其中开始帧和结束帧可以带数据也可以不带数据</span><br></pre></td></tr></table></figure>

<p>WebSocket采用排队的机制，希望发送出去的数据会先丢到数据缓存区中，然后按照排队的顺序进行发送。</p>
<h4 id="SRWebSocket-源码解析"><a href="#SRWebSocket-源码解析" class="headerlink" title="SRWebSocket 源码解析"></a>SRWebSocket 源码解析</h4><p><strong><strong>上层使用方法</strong></strong></p>
<p>SRWebSocket 整个代码量其实不多，就两个文件，在使用上也十分方便，几行代码就可以完成SRWebSocket的接入：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)connectWebSocketServer:(<span class="built_in">NSString</span> *)server port:(<span class="built_in">NSString</span> *)port &#123;</span><br><span class="line">    <span class="built_in">NSURLRequest</span> *request = [<span class="built_in">NSURLRequest</span> requestWithURL:[<span class="built_in">NSURL</span> URLWithString:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;ws://%@:%@&quot;</span>,server,port]]];</span><br><span class="line">    _socket = [[SRWebSocket alloc] initWithURLRequest:request];</span><br><span class="line">    _socket.delegate = <span class="keyword">self</span>;</span><br><span class="line">    [_socket open];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)webSocket:(SRWebSocket *)webSocket didReceiveMessage:(<span class="type">id</span>)message &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)webSocketDidOpen:(SRWebSocket *)webSocket&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)webSocket:(SRWebSocket *)webSocket didFailWithError:(<span class="built_in">NSError</span> *)error &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)webSocket:(SRWebSocket *)webSocket didCloseWithCode:(<span class="built_in">NSInteger</span>)code reason:(<span class="built_in">NSString</span> *)reason wasClean:(<span class="type">BOOL</span>)wasClean &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有了上面WebSocket原理的介绍对整个代码的理解会轻松很多，接下来我们就逐步对SRWebSocket进行解析：</p>
<p><strong><strong>1. SRWebSocket初始化</strong></strong></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">id</span>)initWithURLRequest:(<span class="built_in">NSURLRequest</span> *)request</span><br><span class="line">               protocols:(<span class="built_in">NSArray</span> *)protocols</span><br><span class="line">allowsUntrustedSSLCertificates:(<span class="type">BOOL</span>)allowsUntrustedSSLCertificates &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="variable language_">super</span> init]) &#123;</span><br><span class="line">        assert(request.URL);</span><br><span class="line">        _url = request.URL;</span><br><span class="line">        _urlRequest = request;</span><br><span class="line">        _allowsUntrustedSSLCertificates = allowsUntrustedSSLCertificates;</span><br><span class="line">        _requestedProtocols = [protocols <span class="keyword">copy</span>];</span><br><span class="line">        [<span class="keyword">self</span> _SR_commonInit];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>initWithURLRequest最关键的部分在于对****_SR_commonInit****方法的调用，其中_allowsUntrustedSSLCertificates表示是否允许未经信任的SSL证书，_requestedProtocols就是上面提到的WebSocket子协议。</p>
<figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line">- (void)<span class="variable">_SR_commonInit</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//校验URL的scheme，必须是ws，http，wss，https</span></span><br><span class="line">    NSString *scheme = <span class="variable">_url</span>.scheme.lowercaseString;</span><br><span class="line">    <span class="built_in">assert</span>([scheme isEqualToString:@<span class="string">&quot;ws&quot;</span>] || [scheme isEqualToString:@<span class="string">&quot;http&quot;</span>] || [scheme isEqualToString:@<span class="string">&quot;wss&quot;</span>] || [scheme isEqualToString:@<span class="string">&quot;https&quot;</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//是否是安全的请求</span></span><br><span class="line">    <span class="keyword">if</span> ([scheme isEqualToString:@<span class="string">&quot;wss&quot;</span>] || [scheme isEqualToString:@<span class="string">&quot;https&quot;</span>]) &#123;</span><br><span class="line">        <span class="variable">_secure</span> = YES;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化状态为SR_CONNECTING</span></span><br><span class="line">    <span class="variable">_readyState</span> = SR_CONNECTING;</span><br><span class="line">    <span class="variable">_consumerStopped</span> = YES;</span><br><span class="line">    <span class="comment">//webSocket 版本</span></span><br><span class="line">    <span class="variable">_webSocketVersion</span> = <span class="number">13</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//初始化串行工作队列</span></span><br><span class="line">    <span class="variable">_workQueue</span> = dispatch_queue_create(NULL, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    dispatch_queue_set_specific(<span class="variable">_workQueue</span>, (<span class="variable">__bridge</span> void *)self, maybe_bridge(<span class="variable">_workQueue</span>), NULL);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置代理queue为主队列</span></span><br><span class="line">    <span class="variable">_delegateDispatchQueue</span> = dispatch_get_main_queue();</span><br><span class="line">    sr_dispatch_retain(<span class="variable">_delegateDispatchQueue</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//读写缓存</span></span><br><span class="line">    <span class="variable">_readBuffer</span> = [[NSMutableData alloc] init];</span><br><span class="line">    <span class="variable">_outputBuffer</span> = [[NSMutableData alloc] init];</span><br><span class="line">    <span class="comment">//当前数据帧</span></span><br><span class="line">    <span class="variable">_currentFrameData</span> = [[NSMutableData alloc] init];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//消费者队列</span></span><br><span class="line">    <span class="variable">_consumers</span> = [[NSMutableArray alloc] init];</span><br><span class="line"></span><br><span class="line">    <span class="variable">_consumerPool</span> = [[SRIOConsumerPool alloc] init];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//RunLoopes</span></span><br><span class="line">    <span class="variable">_scheduledRunloops</span> = [[NSMutableSet alloc] init];</span><br><span class="line">    [self <span class="variable">_initializeStreams</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>_SR_commonInit 在最开始的时候对当前协议进行了校验，如果不是ws，http，wss，https，就会报错。而后就是WebSocket状态的设置，以及WebSocket版本的设置。紧接着初始化工作队列_workQueue，WebSocket工作在串行队列中，后续在介绍到数据收发的时候会介绍到这个队列。至于为什么是串行队列，通过上面的理论介绍估计大家心里已经有答案了，但是不急后面会给大家详细介绍_workQueue在数据收发过程中的使用。再接着就是_delegateDispatchQueue的初始化，它是一个运行在主线程上的一个队列。再接着就是读写缓存的初始化，以及消费者数组，对应Runloop 的初始化。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)_initializeStreams &#123;</span><br><span class="line">    <span class="comment">//断言 port值小于UINT32_MAX</span></span><br><span class="line">    assert(_url.port.unsignedIntValue &lt;= <span class="built_in">UINT32_MAX</span>);</span><br><span class="line">    uint32_t port = _url.port.unsignedIntValue;</span><br><span class="line">    <span class="comment">//如果没有指定port值则使用webSocket默认的端口值</span></span><br><span class="line">    <span class="keyword">if</span> (port == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!_secure) &#123;</span><br><span class="line">            port = <span class="number">80</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            port = <span class="number">443</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSString</span> *host = _url.host;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CFReadStreamRef</span> readStream = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">CFWriteStreamRef</span> writeStream = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//CFStreamCreatePairWithSocketToHost接口用于创建一对Socket stream，一个用于读取，一个用于写入</span></span><br><span class="line">    <span class="built_in">CFStreamCreatePairWithSocketToHost</span>(<span class="literal">NULL</span>, (__bridge <span class="built_in">CFStringRef</span>)host, port, &amp;readStream, &amp;writeStream);</span><br><span class="line"></span><br><span class="line">    _outputStream = <span class="built_in">CFBridgingRelease</span>(writeStream);</span><br><span class="line">    _inputStream = <span class="built_in">CFBridgingRelease</span>(readStream);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//代理设为自己</span></span><br><span class="line">    _inputStream.delegate = <span class="keyword">self</span>;</span><br><span class="line">    _outputStream.delegate = <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>_initializeStreams 最主要的是通过CFStreamCreatePairWithSocketToHost接口创建一对Socket stream，一个用于读取（readStream），一个用于写入（writeStream）并为读写stream。设置对应的代理。</p>
<p>到此为止整个初始化过程结束，最主要的工作如下：</p>
<ol>
<li>串行工作队列_workQueue的创建</li>
<li>代理分发队列_delegateDispatchQueue的创建</li>
<li>输入输出缓存 _readBuffer，_outputBuffer的创建</li>
<li>消费者数组_consumers的创建</li>
<li>WebSocket 相关的runloop的创建</li>
<li>输入输出流的创建,以及对应代理NSStreamDelegate的设置</li>
</ol>
<p>NSStreamDelegate定义如下所示：</p>
<p>&#96;&#96;&#96;&#96;<br>@protocol NSStreamDelegate <NSObject><br>@optional</NSObject></p>
<ul>
<li>(void)stream:(NSStream *)aStream handleEvent:(NSStreamEvent)eventCode;<br>@end</li>
</ul>
<p>typedef NS_OPTIONS(NSUInteger, NSStreamEvent) {<br>    NSStreamEventNone &#x3D; 0,<br>    NSStreamEventOpenCompleted &#x3D; 1UL &lt;&lt; 0,<br>    NSStreamEventHasBytesAvailable &#x3D; 1UL &lt;&lt; 1,<br>    NSStreamEventHasSpaceAvailable &#x3D; 1UL &lt;&lt; 2,<br>    NSStreamEventErrorOccurred &#x3D; 1UL &lt;&lt; 3,<br>    NSStreamEventEndEncountered &#x3D; 1UL &lt;&lt; 4<br>};</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="strong">****</span>2. 开启连接<span class="strong">****</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><p>(void)open {</p>
<p>  assert(_url);<br>  NSAssert(_readyState &#x3D;&#x3D; SR_CONNECTING, @”Cannot call -(void)open on SRWebSocket more than once”);</p>
<p>  &#x2F;&#x2F;如果有指定超时时间则延迟指定超时时间后查看状态是否还是SR_CONNECTING 如果是则返回超时消息<br>  _selfRetain &#x3D; self;<br>  if (_urlRequest.timeoutInterval &gt; 0) {<br>  dispatch_time_t popTime &#x3D; dispatch_time(DISPATCH_TIME_NOW, _urlRequest.timeoutInterval * NSEC_PER_SEC);<br>  dispatch_after(popTime, dispatch_get_main_queue(), ^(void){<br>      if (self.readyState &#x3D;&#x3D; SR_CONNECTING)<br>          [self _failWithError:[NSError errorWithDomain:@”com.squareup.SocketRocket” code:504 userInfo:@{NSLocalizedDescriptionKey: @”Timeout Connecting to Server”}]];<br>  });<br>  }</p>
<p>  &#x2F;&#x2F;执行连接任务<br>  [self openConnection];</p>
</li>
</ul>
<p>}</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><p>(void)openConnection {</p>
<p>  &#x2F;&#x2F;更新安全、流配置<br>  [self _updateSecureStreamOptions];</p>
<p>  &#x2F;&#x2F;判断有没有runloop,如果没有的话就新建对应的runloop<br>  if (!_scheduledRunloops.count) {<br>  [self scheduleInRunLoop:[NSRunLoop SR_networkRunLoop] forMode:NSDefaultRunLoopMode];<br>  }</p>
<p>  &#x2F;&#x2F;开启输入输出流<br>  [_outputStream open];<br>  [_inputStream open];</p>
</li>
</ul>
<p>}</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">这里最关键有三个部分：</span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> <span class="strong">****</span><span class="emphasis">_updateSecureStreamOptions<span class="strong">****</span></span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">如果是<span class="strong">****</span>wss://<span class="strong">****</span>类型的WebSocket</span></span><br></pre></td></tr></table></figure>
<ul>
<li>(void)_updateSecureStreamOptions {<br>  if (_secure) {<br>  NSMutableDictionary *SSLOptions &#x3D; [[NSMutableDictionary alloc] init];<br>  [_outputStream setProperty:(__bridge id)kCFStreamSocketSecurityLevelNegotiatedSSL<br>                      forKey:(__bridge id)kCFStreamPropertySocketSecurityLevel];<br>  &#x2F;&#x2F; 如果我们正在使用pinned certs 我们将不对证书链进行验证<br>  if ([_urlRequest SR_SSLPinnedCertificates].count) {<br>      [SSLOptions setValue:@NO forKey:(__bridge id)kCFStreamSSLValidatesCertificateChain];<br>  }<br>#if DEBUG<br>  &#x2F;&#x2F;如果是debug模式则允许非信任的证书<br>  self.allowsUntrustedSSLCertificates &#x3D; YES;<br>#endif<br>  &#x2F;&#x2F;如果允许非信任的证书则将配置设置到SSLOptions<br>  if (self.allowsUntrustedSSLCertificates) {<br>      [SSLOptions setValue:@NO forKey:(__bridge id)kCFStreamSSLValidatesCertificateChain];<br>      SRFastLog(@”Allowing connection to any root cert”);<br>  }<br>  &#x2F;&#x2F;将SSLOptions设置为输出流设置属性<br>  [_outputStream setProperty:SSLOptions<br>                      forKey:(__bridge id)kCFStreamPropertySSLSettings];<br>  }<br>  &#x2F;&#x2F;重新设置输入流和输出流的delegate<br>  _inputStream.delegate &#x3D; self;<br>  _outputStream.delegate &#x3D; self;<br>  &#x2F;&#x2F;为输入流和输出流设置networkServiceType<br>  [self setupNetworkServiceType:_urlRequest.networkServiceType];<br>}</li>
</ul>
<figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line"><span class="variable">_updateSecureStreamOptions</span> 只针对安全流才需要设置的，在这里会根据SR_SSLPinnedCertificates是否存在，以及allowsUntrustedSSLCertificates值设置<span class="variable">_outputStream</span>的SSL设置。然后重新设置<span class="variable">_inputStream</span>以及<span class="variable">_outputStream</span>的delegate。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>(void)setupNetworkServiceType:(NSURLRequestNetworkServiceType)requestNetworkServiceType {<br>  NSString *networkServiceType;<br>  switch (requestNetworkServiceType) {<br>  case NSURLNetworkServiceTypeDefault:<br>      break;<br>  case NSURLNetworkServiceTypeVoIP: {<br>      networkServiceType &#x3D; NSStreamNetworkServiceTypeVoIP;<br>#if TARGET_OS_IPHONE &amp;&amp; __IPHONE_9_0<br>      if (floor(NSFoundationVersionNumber) &gt; NSFoundationVersionNumber_iOS_8_3) {<br>          static dispatch_once_t predicate;<br>          dispatch_once(&amp;predicate, ^{<br>              NSLog(@”SocketRocket: %@ - this service type is deprecated in favor of using PushKit for VoIP control”, networkServiceType);<br>          });<br>      }<br>#endif<br>      break;<br>  }<br>  case NSURLNetworkServiceTypeVideo:<br>      networkServiceType &#x3D; NSStreamNetworkServiceTypeVideo;<br>      break;<br>  case NSURLNetworkServiceTypeBackground:<br>      networkServiceType &#x3D; NSStreamNetworkServiceTypeBackground;<br>      break;<br>  case NSURLNetworkServiceTypeVoice:<br>      networkServiceType &#x3D; NSStreamNetworkServiceTypeVoice;<br>      break;<br>  }<br>  if (networkServiceType !&#x3D; nil) {<br>  [_inputStream setProperty:networkServiceType forKey:NSStreamNetworkServiceType];<br>  [_outputStream setProperty:networkServiceType forKey:NSStreamNetworkServiceType];<br>  }<br>}<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">然后再设置<span class="emphasis">_inputStream 以及 _</span>outputStream 的 NSStreamNetworkServiceType属性。</span><br><span class="line"></span><br><span class="line"><span class="bullet">2.</span> <span class="strong">****</span><span class="emphasis">_scheduledRunloops<span class="strong">****</span></span></span><br><span class="line"><span class="emphasis"></span></span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li>(NSRunLoop *)SR_networkRunLoop {<br>  static dispatch_once_t onceToken;<br>  dispatch_once(&amp;onceToken, ^{<br>  networkThread &#x3D; [[_SRRunLoopThread alloc] init];<br>  networkThread.name &#x3D; @”com.squareup.SocketRocket.NetworkThread”;<br>  [networkThread start];<br>  networkRunLoop &#x3D; networkThread.runLoop;<br>  });<br>  return networkRunLoop;<br>}<figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">在SR_networkRunLoop方法中会新创建一个NSThread的线程，然后持有这个线程的runLoop作为networkRunLoop，由于这个线程是通过单例创建的所以，在整个应用生命周期都会存在。提到networkThread不得不提<span class="variable">_workQueue</span>，networkThread主要用于支持读写的工作线程，<span class="variable">_workQueue</span>是用于处理控制任务的队列，两者单独分开，各司其职。这样做的目的主要是为了避免数据的读写任务阻塞了控制任务，从而影响了事件的实时性。</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>. ****<span class="variable">_outputStream</span>/<span class="variable">_inputStream</span> open****</span><br><span class="line"></span><br><span class="line">调用<span class="variable">_outputStream</span>/<span class="variable">_inputStream</span> open之后端口就会被打开，这时候输入输出流就会有数据通过代理传递进来。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">****<span class="number">3</span>. 通过代理处理数据****</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><p>(void)stream:(NSStream *)aStream handleEvent:(NSStreamEvent)eventCode {<br>  __weak typeof(self) weakSelf &#x3D; self;</p>
<p>  &#x2F;&#x2F;如果协议是wss:&#x2F;&#x2F;类型而且_pinnedCertFound 为NO，并且事件类型是有可读数据未读，或者事件类型是还有空余空间可写<br>  if (_secure &amp;&amp; !_pinnedCertFound &amp;&amp; (eventCode &#x3D;&#x3D; NSStreamEventHasBytesAvailable || eventCode &#x3D;&#x3D; NSStreamEventHasSpaceAvailable)) {<br>  &#x2F;&#x2F;获取到SSLPinnedCertificates<br>  NSArray *sslCerts &#x3D; [_urlRequest SR_SSLPinnedCertificates];<br>  if (sslCerts) {<br>      将NSStream中的证书与服务端请求中的SSLPinnedCertificates一个一个进行比较，查看是否有找到匹配的。<br>      SecTrustRef secTrust &#x3D; (__bridge SecTrustRef)[aStream propertyForKey:(__bridge id)kCFStreamPropertySSLPeerTrust];<br>      if (secTrust) {<br>          NSInteger numCerts &#x3D; SecTrustGetCertificateCount(secTrust);<br>          for (NSInteger i &#x3D; 0; i &lt; numCerts &amp;&amp; !_pinnedCertFound; i++) {<br>              SecCertificateRef cert &#x3D; SecTrustGetCertificateAtIndex(secTrust, i);<br>              NSData *certData &#x3D; CFBridgingRelease(SecCertificateCopyData(cert));<br><br>              for (id ref in sslCerts) {<br>                  SecCertificateRef trustedCert &#x3D; (__bridge SecCertificateRef)ref;<br>                  NSData *trustedCertData &#x3D; CFBridgingRelease(SecCertificateCopyData(trustedCert));<br><br>                  if ([trustedCertData isEqualToData:certData]) {<br>                      _pinnedCertFound &#x3D; YES;<br>                      break;<br>                  }<br>              }<br>          }<br>      }<br>      if (!_pinnedCertFound) {<br>          &#x2F;&#x2F;服务端证书无效<br>          dispatch_async(_workQueue, ^{<br>              NSDictionary *userInfo &#x3D; @{ NSLocalizedDescriptionKey : @”Invalid server cert” };<br>              [weakSelf _failWithError:[NSError errorWithDomain:@”org.lolrus.SocketRocket” code:23556 userInfo:userInfo]];<br>          });<br>          return;<br>      } else if (aStream &#x3D;&#x3D; _outputStream) {<br>          &#x2F;&#x2F;如果流是输出流，则打开流成功<br>          dispatch_async(_workQueue, ^{<br>              [self didConnect];<br>          });<br>      }<br>  }<br>  }</p>
<p>  dispatch_async(_workQueue, ^{<br>  &#x2F;&#x2F;将当前数据交给_workQueue处理<br>  [weakSelf safeHandleEvent:eventCode stream:aStream];<br>  });</p>
</li>
</ul>
<p>}</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><p>(void)stream:(NSStream *)aStream handleEvent:(NSStreamEvent)eventCode</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">是数据的主要集中地，对于未认证的请求，会先对服务端的证书进行认证，如果认证成功会调用<span class="keyword">didConnect进行握手，然后不论是什么类型的请求，都会进过safeHandleEvent将数据分发出去。接下来我们重点看下didConnect以及safeHandleEvent：</span></span><br><span class="line"><span class="keyword"></span></span><br></pre></td></tr></table></figure></li>
<li><p>(void)didConnect {</p>
<p> &#x2F;&#x2F; 设置GET请求，并指定HTTP 协议版本为1.1<br>  CFHTTPMessageRef request &#x3D; CFHTTPMessageCreateRequest(NULL, CFSTR(“GET”), (__bridge CFURLRef)_url, kCFHTTPVersion1_1);</p>
<p>  &#x2F;&#x2F; 设置Host字段<br>  CFHTTPMessageSetHeaderFieldValue(request, CFSTR(“Host”), (__bridge CFStringRef)(_url.port ? [NSString stringWithFormat:@”%@:%@”, _url.host, _url.port] : _url.host));</p>
<p>  &#x2F;&#x2F;生成随机数<br>  NSMutableData *keyBytes &#x3D; [[NSMutableData alloc] initWithLength:16];<br>  SecRandomCopyBytes(kSecRandomDefault, keyBytes.length, keyBytes.mutableBytes);</p>
<p>  &#x2F;&#x2F;Base64加密<br>  if ([keyBytes respondsToSelector:@selector(base64EncodedStringWithOptions:)]) {<br>  _secKey &#x3D; [keyBytes base64EncodedStringWithOptions:0];<br>  } else {</p>
</li>
</ul>
<p>#pragma clang diagnostic push<br>#pragma clang diagnostic ignored “-Wdeprecated-declarations”<br>        _secKey &#x3D; [keyBytes base64Encoding];<br>#pragma clang diagnostic pop<br>    }</p>
<pre><code>assert([_secKey length] == 24);

// Apply cookies if any have been provided
NSDictionary * cookies = [NSHTTPCookie requestHeaderFieldsWithCookies:[self requestCookies]];
for (NSString * cookieKey in cookies) &#123;
    NSString * cookieValue = [cookies objectForKey:cookieKey];
    if ([cookieKey length] &amp;&amp; [cookieValue length]) &#123;
        CFHTTPMessageSetHeaderFieldValue(request, (__bridge CFStringRef)cookieKey, (__bridge CFStringRef)cookieValue);
    &#125;
&#125;

// 添加认证字段
if (_url.user.length &amp;&amp; _url.password.length) &#123;
    NSData *userAndPassword = [[NSString stringWithFormat:@&quot;%@:%@&quot;, _url.user, _url.password] dataUsingEncoding:NSUTF8StringEncoding];
    NSString *userAndPasswordBase64Encoded;
    if ([keyBytes respondsToSelector:@selector(base64EncodedStringWithOptions:)]) &#123;
        userAndPasswordBase64Encoded = [userAndPassword base64EncodedStringWithOptions:0];
    &#125; else &#123;
</code></pre>
<p>#pragma clang diagnostic push<br>#pragma clang diagnostic ignored “-Wdeprecated-declarations”<br>            userAndPasswordBase64Encoded &#x3D; [userAndPassword base64Encoding];<br>#pragma clang diagnostic pop<br>        }<br>        _basicAuthorizationString &#x3D; [NSString stringWithFormat:@”Basic %@”, userAndPasswordBase64Encoded];<br>        CFHTTPMessageSetHeaderFieldValue(request, CFSTR(“Authorization”), (__bridge CFStringRef)_basicAuthorizationString);<br>    }</p>
<pre><code>CFHTTPMessageSetHeaderFieldValue(request, CFSTR(&quot;Upgrade&quot;), CFSTR(&quot;websocket&quot;));
CFHTTPMessageSetHeaderFieldValue(request, CFSTR(&quot;Connection&quot;), CFSTR(&quot;Upgrade&quot;));
CFHTTPMessageSetHeaderFieldValue(request, CFSTR(&quot;Sec-WebSocket-Key&quot;), (__bridge CFStringRef)_secKey);
CFHTTPMessageSetHeaderFieldValue(request, CFSTR(&quot;Sec-WebSocket-Version&quot;), (__bridge CFStringRef)[NSString stringWithFormat:@&quot;%ld&quot;, (long)_webSocketVersion]);
CFHTTPMessageSetHeaderFieldValue(request, CFSTR(&quot;Origin&quot;), (__bridge CFStringRef)_url.SR_origin);

//追加子协议
if (_requestedProtocols) &#123;
    CFHTTPMessageSetHeaderFieldValue(request, CFSTR(&quot;Sec-WebSocket-Protocol&quot;), (__bridge CFStringRef)[_requestedProtocols componentsJoinedByString:@&quot;, &quot;]);
&#125;

//添加http头
[_urlRequest.allHTTPHeaderFields enumerateKeysAndObjectsUsingBlock:^(id key, id obj, BOOL *stop) &#123;
    CFHTTPMessageSetHeaderFieldValue(request, (__bridge CFStringRef)key, (__bridge CFStringRef)obj);
&#125;];

NSData *message = CFBridgingRelease(CFHTTPMessageCopySerializedMessage(request));

CFRelease(request);

//将数据送出
[self _writeData:message];
//指派数据消费者等待响应头部准备就绪后读取HttpHeader
[self _readHTTPHeader];
</code></pre>
<p>}</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">上述的<span class="strong">****</span>didConnect<span class="strong">****</span>其实就是之前介绍的WebSocket握手阶段。它会构建出一个Http 1.1 的请求头，然后发送出去，并分配数据消费者，等待消费服务端返回的应答头部。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><p>(void)_readHTTPHeader {<br>  if (_receivedHTTPHeaders &#x3D;&#x3D; NULL) {<br>  _receivedHTTPHeaders &#x3D; CFHTTPMessageCreateEmpty(NULL, NO);<br>  }<br>  &#x2F;&#x2F;等待头数据读取完毕后执行下面的block<br>  [self _readUntilHeaderCompleteWithCallback:^(SRWebSocket *self,  NSData *data) {<br>  &#x2F;&#x2F;将获取到的数据追加到_receivedHTTPHeaders<br>  CFHTTPMessageAppendBytes(_receivedHTTPHeaders, (const UInt8 *)data.bytes, data.length);<br>  &#x2F;&#x2F;判断请求头响应部分是否已经读取完毕<br>  if (CFHTTPMessageIsHeaderComplete(_receivedHTTPHeaders)) {<br>      &#x2F;&#x2F; 如果读取完毕则调用_HTTPHeadersDidFinish<br>      [self _HTTPHeadersDidFinish];<br>  } else {<br>      &#x2F;&#x2F; 否则继续读返回的头部数据<br>      [self _readHTTPHeader];<br>  }<br>  }];<br>}</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>(void)_HTTPHeadersDidFinish {</p>
<p>  &#x2F;&#x2F;获取返回的状态码<br>  NSInteger responseCode &#x3D; CFHTTPMessageGetResponseStatusCode(_receivedHTTPHeaders);</p>
<p>  &#x2F;&#x2F;如果大于400 表示握手失败<br>  if (responseCode &gt;&#x3D; 400) {<br>  SRFastLog(@”Request failed with response code %d”, responseCode);<br>  [self _failWithError:[NSError errorWithDomain:SRWebSocketErrorDomain code:2132 userInfo:@{NSLocalizedDescriptionKey:[NSString stringWithFormat:@”received bad response code from server %ld”, (long)responseCode], SRHTTPResponseErrorKey:@(responseCode)}]];<br>  return;<br>  }</p>
<p>  &#x2F;&#x2F;检查服务器返回的Sec-WebSocket-Accept字段是否正确<br>  if(![self _checkHandshake:_receivedHTTPHeaders]) {<br>  [self _failWithError:[NSError errorWithDomain:SRWebSocketErrorDomain code:2133 userInfo:[NSDictionary dictionaryWithObject:[NSString stringWithFormat:@”Invalid Sec-WebSocket-Accept response”] forKey:NSLocalizedDescriptionKey]]];<br>  return;<br>  }</p>
<p>  &#x2F;&#x2F;对子协议进行校验<br>  NSString *negotiatedProtocol &#x3D; CFBridgingRelease(CFHTTPMessageCopyHeaderFieldValue(_receivedHTTPHeaders, CFSTR(“Sec-WebSocket-Protocol”)));<br>  if (negotiatedProtocol) {<br>  &#x2F;&#x2F; Make sure we requested the protocol<br>  if ([_requestedProtocols indexOfObject:negotiatedProtocol] &#x3D;&#x3D; NSNotFound) {<br>      [self _failWithError:[NSError errorWithDomain:SRWebSocketErrorDomain code:2133 userInfo:[NSDictionary dictionaryWithObject:[NSString stringWithFormat:@”Server specified Sec-WebSocket-Protocol that wasn’t requested”] forKey:NSLocalizedDescriptionKey]]];<br>      return;<br>  }<br><br>  _protocol &#x3D; negotiatedProtocol;<br>  }</p>
<p>  &#x2F;&#x2F;上述校验结束后代表整个WebSocket已经打开了<br>  self.readyState &#x3D; SR_OPEN;</p>
<p>  &#x2F;&#x2F;如果没有错误发生则读取新的帧<br>  if (!_didFail) {<br>  [self _readFrameNew];<br>  }</p>
<p>  &#x2F;&#x2F;通过代理通知业务层WebSocket已经打开了<br>  [self _performDelegateBlock:^{<br>  if ([self.delegate respondsToSelector:@selector(webSocketDidOpen:)]) {<br>      [self.delegate webSocketDidOpen:self];<br>  };<br>  }];</p>
</li>
</ul>
<p>}</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">我们接下来看下每次数据进来是怎么进行交付的。我们再回到：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>(void)stream:(NSStream *)aStream handleEvent:(NSStreamEvent)eventCode<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">除了上述的认证过程外，还有个十分重要的方法safeHandleEvent:<span class="keyword">stream</span>,每个数据进来都会通过这个方法进行处理：</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>(void)safeHandleEvent:(NSStreamEvent)eventCode stream:(NSStream *)aStream {<br>  switch (eventCode) {<br>      case NSStreamEventOpenCompleted: {<br>          SRFastLog(@”NSStreamEventOpenCompleted %@”, aStream);<br>          if (self.readyState &gt;&#x3D; SR_CLOSING) {<br>              return;<br>          }<br>          assert(_readBuffer);<br><br>          &#x2F;&#x2F; didConnect fires after certificate verification if we’re using pinned certificates.<br>          BOOL usingPinnedCerts &#x3D; [[_urlRequest SR_SSLPinnedCertificates] count] &gt; 0;<br>          if ((!_secure || !usingPinnedCerts) &amp;&amp; self.readyState &#x3D;&#x3D; SR_CONNECTING &amp;&amp; aStream &#x3D;&#x3D; _inputStream) {<br>              [self didConnect];<br>          }<br>          [self _pumpWriting];<br>          [self _pumpScanner];<br>          break;<br>      }<br><br>      case NSStreamEventErrorOccurred: {<br>          SRFastLog(@”NSStreamEventErrorOccurred %@ %@”, aStream, [[aStream streamError] copy]);<br>          &#x2F;&#x2F;&#x2F; TODO specify error better!<br>          [self _failWithError:aStream.streamError];<br>          _readBufferOffset &#x3D; 0;<br>          [_readBuffer setLength:0];<br>          break;<br><br>      }<br><br>      case NSStreamEventEndEncountered: {<br>          [self _pumpScanner];<br>          SRFastLog(@”NSStreamEventEndEncountered %@”, aStream);<br>          if (aStream.streamError) {<br>              [self _failWithError:aStream.streamError];<br>          } else {<br>              dispatch_async(_workQueue, ^{<br>                  if (self.readyState !&#x3D; SR_CLOSED) {<br>                      self.readyState &#x3D; SR_CLOSED;<br>                      [self _scheduleCleanup];<br>                  }<br><br>                  if (!_sentClose &amp;&amp; !_failed) {<br>                      _sentClose &#x3D; YES;<br>                      &#x2F;&#x2F; If we get closed in this state it’s probably not clean because we should be sending this when we send messages<br>                      [self _performDelegateBlock:^{<br>                          if ([self.delegate respondsToSelector:@selector(webSocket:didCloseWithCode:reason:wasClean:)]) {<br>                              [self.delegate webSocket:self didCloseWithCode:SRStatusCodeGoingAway reason:@”Stream end encountered” wasClean:NO];<br>                          }<br>                      }];<br>                  }<br>              });<br>          }<br><br>          break;<br>      }<br><br>      case NSStreamEventHasBytesAvailable: {<br>          SRFastLog(@”NSStreamEventHasBytesAvailable %@”, aStream);<br>          const int bufferSize &#x3D; 2048;<br>          uint8_t buffer[bufferSize];<br><br>          while (_inputStream.hasBytesAvailable) {<br>              NSInteger bytes_read &#x3D; [_inputStream read:buffer maxLength:bufferSize];<br><br>              if (bytes_read &gt; 0) {<br>                  [_readBuffer appendBytes:buffer length:bytes_read];<br>              } else if (bytes_read &lt; 0) {<br>                  [self _failWithError:_inputStream.streamError];<br>              }<br><br>              if (bytes_read !&#x3D; bufferSize) {<br>                  break;<br>              }<br>          };<br>          [self _pumpScanner];<br>          break;<br>      }<br><br>      case NSStreamEventHasSpaceAvailable: {<br>          SRFastLog(@”NSStreamEventHasSpaceAvailable %@”, aStream);<br>          [self _pumpWriting];<br>          break;<br>      }<br><br>      default:<br>          SRFastLog(@”(default)  %@”, aStream);<br>          break;<br>  }</li>
</ul>
<p>}</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">这里有个十分关键的类型：<span class="strong">****</span>NSStreamEvent<span class="strong">****</span>用于表示当前消息的类型：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>typedef NS_OPTIONS(NSUInteger, NSStreamEvent) {<br>    NSStreamEventNone &#x3D; 0,<br>    NSStreamEventOpenCompleted &#x3D; 1UL &lt;&lt; 0,          &#x2F;&#x2F;打开完成<br>    NSStreamEventHasBytesAvailable &#x3D; 1UL &lt;&lt; 1,      &#x2F;&#x2F;流中有数据可读<br>    NSStreamEventHasSpaceAvailable &#x3D; 1UL &lt;&lt; 2,      &#x2F;&#x2F;缓存中有空间可写<br>    NSStreamEventErrorOccurred &#x3D; 1UL &lt;&lt; 3,          &#x2F;&#x2F;遇到错误<br>    NSStreamEventEndEncountered &#x3D; 1UL &lt;&lt; 4          &#x2F;&#x2F;遇到结束符<br>};</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">我们这里先看下 <span class="strong">****</span>NSStreamEventOpenCompleted<span class="strong">****</span>，后面介绍读写的时候还会接着介绍<span class="strong">****</span>NSStreamEventHasBytesAvailable<span class="strong">****</span>，<span class="strong">****</span>NSStreamEventHasSpaceAvailable<span class="strong">****</span>这两个事件。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>&#x2F;&#x2F;连接完成<br>case NSStreamEventOpenCompleted: {<br>    SRFastLog(@”NSStreamEventOpenCompleted %@”, aStream);<br>     &#x2F;&#x2F;如果就绪状态为关闭或者正在关闭，直接返回<br>    if (self.readyState &gt;&#x3D; SR_CLOSING) {<br>        return;<br>    }<br>    assert(_readBuffer);</p>
<pre><code>//如果是ws，或者无自签证书，而且是正准备连接，而且aStream是输入流
// didConnect fires after certificate verification if we&#39;re using pinned certificates.
BOOL usingPinnedCerts = [[_urlRequest SR_SSLPinnedCertificates] count] &gt; 0;
if ((!_secure || !usingPinnedCerts) &amp;&amp; self.readyState == SR_CONNECTING &amp;&amp; aStream == _inputStream) &#123;
    //进行握手连接
    [self didConnect];
&#125;
//开始写数据
[self _pumpWriting];
//读取应答数据
[self _pumpScanner];
break;
</code></pre>
<p>}</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">之前介绍的是wss协议类型的情况，这里则是<span class="keyword">ws</span>或者无自签名证书的情形，主要流程还是类似的。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">上面介绍了从初始化，到建立连接，再到握手的整个流程，在介绍WebSocket读写数据之前，我们再从头梳理下这个阶段的关键过程：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol>
<li>最开始我们会对协议类型进行校验，判断是否是ws，http，wss，https这些类型的一种</li>
<li>设置当前状态为SR_CONNECTING</li>
<li>创建_workQueue，networkThread以及_delegateDispatchQueue</li>
<li>初始化读写缓存_readBuffer，_outputBuffer，消费者数组_consumers以及消费对象池_consumerPool。</li>
<li>通过CFStreamCreatePairWithSocketToHost创建读写数据流readStream，writeStream。并设置读写流代理,指定对应的Runloop,如果是wss协议，还要更新流的安全属性, 上面设置完毕后调用输入输出流的open方法打开流。</li>
<li>流打开后就会有数据从代理进来，对于wss类型的协议，如果证书还没找到，那么会进行证书的匹配，如果匹配成功则调用didConnect，在didConnect中发送握手消息头到服务端，进行握手通信。</li>
<li>通过数据消费者从缓存中读取应答头数据，这时候分别对服务端返回的头部的状态码，Sec-WebSocket-Accept，子协议进行校验，如果校验通过则将状态设置为SR_OPEN并通过代理webSocketDidOpen通知业务层websocket已经成功连接。</li>
</ol>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="strong">****</span>3. 数据读写<span class="strong">****</span></span><br><span class="line"></span><br><span class="line">最后剩下一个问题，数据是怎样从输入流读入，怎样从输出流发出，数据消费者在整个过程中扮演的角色，workQueue,networkThread在整个过程扮演的角色。</span><br><span class="line"></span><br><span class="line">我们来看下<span class="strong">****</span>NSStreamEventHasBytesAvailable<span class="strong">****</span>用于表示可以从缓存中读取数据了：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>case NSStreamEventHasBytesAvailable: {<br>    SRFastLog(@”NSStreamEventHasBytesAvailable %@”, aStream);<br>    const int bufferSize &#x3D; 2048;<br>    uint8_t buffer[bufferSize];</p>
<pre><code>while (_inputStream.hasBytesAvailable) &#123;
    //从输入流中读取数据到缓存中
    NSInteger bytes_read = [_inputStream read:buffer maxLength:bufferSize];
    if (bytes_read &gt; 0) &#123;
        //将数据追加到读缓存中
        [_readBuffer appendBytes:buffer length:bytes_read];
    &#125; else if (bytes_read &lt; 0) &#123;
        [self _failWithError:_inputStream.streamError];
    &#125;
    //如果读取的不等于最大的，说明读完了，跳出循环
    if (bytes_read != bufferSize) &#123;
        break;
    &#125;
&#125;;
//开始扫描，看消费者什么时候消费数据
[self _pumpScanner];
break;
</code></pre>
<p>}</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<p>-(void)_pumpScanner {<br>    [self assertOnWorkQueue];<br>    &#x2F;&#x2F;判断是否在扫描<br>    if (!_isPumping) {<br>        _isPumping &#x3D; YES;<br>    } else {<br>        return;<br>    }<br>    while ([self _innerPumpScanner]) {}<br>    _isPumping &#x3D; NO;<br>}</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><p>(BOOL)_innerPumpScanner {</p>
<p>  BOOL didWork &#x3D; NO;<br>  &#x2F;&#x2F;如果当前状态为已关闭 返回NO<br>  if (self.readyState &gt;&#x3D; SR_CLOSED) {<br>  return didWork;<br>  }<br>  &#x2F;&#x2F;如果数据消费者列表为空，返回NO<br>  if (!_consumers.count) {<br>  return didWork;<br>  }</p>
<p>  &#x2F;&#x2F;读取的buffer长度 - 偏移量  &#x3D;  可以被读取的数据帧的长度<br>  size_t curSize &#x3D; _readBuffer.length - _readBufferOffset;<br>  &#x2F;&#x2F;如果未读为空，返回NO<br>  if (!curSize) {<br>  return didWork;<br>  }</p>
<p>  &#x2F;&#x2F;取出数据消费者队列中的第一个消费者<br>  SRIOConsumer *consumer &#x3D; [_consumers objectAtIndex:0];<br>  &#x2F;&#x2F;得到需要的字节数<br>  size_t bytesNeeded &#x3D; consumer.bytesNeeded;<br>  &#x2F;&#x2F;消费者本次找到的要读取的数据大小<br>  size_t foundSize &#x3D; 0;</p>
<p>  &#x2F;&#x2F; 确定foundSize 大小<br>  &#x2F;&#x2F;consumer.consumer是指定了用于查找要读取数据的规则。<br>  if (consumer.consumer) {<br>  &#x2F;&#x2F;把未读数据从readBuffer中赋值到tempView里，待consumer.consumer按照它的规则进行查找要读取的数据<br>  NSData *tempView &#x3D; [NSData dataWithBytesNoCopy:(char *)_readBuffer.bytes + _readBufferOffset length:_readBuffer.length - _readBufferOffset freeWhenDone:NO];<br>  &#x2F;&#x2F;得到要读取的数据大小<br>  foundSize &#x3D; consumer.consumer(tempView);<br>  } else {<br>  &#x2F;&#x2F;如果没有指定查找规则则按bytesNeeded来确定foundSize<br>  assert(consumer.bytesNeeded);<br>  &#x2F;&#x2F;如果未读字节大于需要字节，直接等于需要字节<br>  if (curSize &gt;&#x3D; bytesNeeded) {<br>      foundSize &#x3D; bytesNeeded;<br>  }<br>  &#x2F;&#x2F;如果为读取当前帧<br>  else if (consumer.readToCurrentFrame) {<br>      &#x2F;&#x2F;消费大小等于当前未读字节<br>      foundSize &#x3D; curSize;<br>  }<br>  }</p>
<p>  &#x2F;&#x2F;通过上面的foundSize得到需要读取的数据，并且释放已读的空间<br>  NSData *slice &#x3D; nil;<br>  &#x2F;&#x2F;如果读取当前帧或者foundSize大于0<br>  if (consumer.readToCurrentFrame || foundSize) {<br>  &#x2F;&#x2F;从已读偏移到要读的字节处<br>  NSRange sliceRange &#x3D; NSMakeRange(_readBufferOffset, foundSize);<br>  &#x2F;&#x2F;得到data<br>  slice &#x3D; [_readBuffer subdataWithRange:sliceRange];<br>  &#x2F;&#x2F;增加已读偏移<br>  _readBufferOffset +&#x3D; foundSize;<br>  &#x2F;&#x2F;如果读取偏移的大小大于4096，或者读取偏移大于 1&#x2F;2的buffer大小<br>  if (_readBufferOffset &gt; 4096 &amp;&amp; _readBufferOffset &gt; (_readBuffer.length &gt;&gt; 1)) {<br>      &#x2F;&#x2F;重新创建，释放已读那部分的data空间<br>      _readBuffer &#x3D; [[NSMutableData alloc] initWithBytes:(char *)_readBuffer.bytes + _readBufferOffset length:_readBuffer.length - _readBufferOffset];            _readBufferOffset &#x3D; 0;<br>  }<br><br>  &#x2F;&#x2F;如果用户未掩码的数据<br>  if (consumer.unmaskBytes) {<br>      &#x2F;&#x2F;copy切片<br>      NSMutableData *mutableSlice &#x3D; [slice mutableCopy];<br>      &#x2F;&#x2F;得到长度字节数<br>      NSUInteger len &#x3D; mutableSlice.length;<br>      uint8_t *bytes &#x3D; mutableSlice.mutableBytes;<br><br>      for (NSUInteger i &#x3D; 0; i &lt; len; i++) {<br>          &#x2F;&#x2F;得到一个读取掩码key，为偏移量_currentReadMaskOffset取余_currentReadMaskKey，当前掩码key，<br>          &#x2F;&#x2F;再和字节异或运算（相同为0，不同为1）<br>          bytes[i] &#x3D; bytes[i] ^ _currentReadMaskKey[_currentReadMaskOffset % sizeof(_currentReadMaskKey)];<br>          &#x2F;&#x2F;偏移量+1<br>          _currentReadMaskOffset +&#x3D; 1;<br>      }<br>      &#x2F;&#x2F;把数据改成掩码后的<br>      slice &#x3D; mutableSlice;<br>  }<br><br>  &#x2F;&#x2F;如果读取当前帧<br>  if (consumer.readToCurrentFrame) {<br>      &#x2F;&#x2F;拼接数据<br>      [_currentFrameData appendData:slice];<br>      &#x2F;&#x2F;+1<br>      _readOpCount +&#x3D; 1;<br>      &#x2F;&#x2F;判断Opcode，如果是文本帧<br>      if (_currentFrameOpcode &#x3D;&#x3D; SROpCodeTextFrame) {<br>          &#x2F;&#x2F; Validate UTF8 stuff.<br>          &#x2F;&#x2F;得到当前帧数据的长度<br>          size_t currentDataSize &#x3D; _currentFrameData.length;<br>          &#x2F;&#x2F;如果currentDataSize 大于0<br>          if (_currentFrameOpcode &#x3D;&#x3D; SROpCodeTextFrame &amp;&amp; currentDataSize &gt; 0) {<br>              &#x2F;&#x2F; TODO: Optimize the crap out of this.  Don’t really have to copy all the data each time<br>              &#x2F;&#x2F;判断需要scan的大小<br>              size_t scanSize &#x3D; currentDataSize - _currentStringScanPosition;<br>              &#x2F;&#x2F;得到要sacn的data<br>              NSData *scan_data &#x3D; [_currentFrameData subdataWithRange:NSMakeRange(_currentStringScanPosition, scanSize)];<br>              &#x2F;&#x2F;验证数据<br>              int32_t valid_utf8_size &#x3D; validate_dispatch_data_partial_string(scan_data);<br><br>              &#x2F;&#x2F;-1为错误，关闭连接<br>              if (valid_utf8_size &#x3D;&#x3D; -1) {<br>                  [self closeWithCode:SRStatusCodeInvalidUTF8 reason:@”Text frames must be valid UTF-8”];<br>                  dispatch_async(_workQueue, ^{<br>                      [self closeConnection];<br>                  });<br>                  return didWork;<br>              } else {<br>                  &#x2F;&#x2F;扫描的位置+上合法数据的size<br>                  _currentStringScanPosition +&#x3D; valid_utf8_size;<br>              }<br>          }<br><br>      }<br>      &#x2F;&#x2F;需要的size - 已操作的size<br>      consumer.bytesNeeded -&#x3D; foundSize;<br>      &#x2F;&#x2F;如果还需要的字节数 &#x3D; 0，移除消费者<br>      if (consumer.bytesNeeded &#x3D;&#x3D; 0) {<br>          [_consumers removeObjectAtIndex:0];<br>          &#x2F;&#x2F;回调读取完成<br>          consumer.handler(self, nil);&#x2F;&#x2F;由于读取当前帧的时候数据存放在_currentFrameData，所以这里返回为nil<br>          &#x2F;&#x2F;把要返回的consumer，先放在_consumerPool缓冲池中<br>          [_consumerPool returnConsumer:consumer];<br>          &#x2F;&#x2F;已经工作为YES<br>          didWork &#x3D; YES;<br>      }<br>  } else if (foundSize) {<br>      &#x2F;&#x2F;移除消费者<br>      [_consumers removeObjectAtIndex:0];<br>      &#x2F;&#x2F;回调回去当前接受到的数据<br>      consumer.handler(self, slice);<br><br>      [_consumerPool returnConsumer:consumer];<br>      didWork &#x3D; YES;<br>  }<br>  }<br>  return didWork;</p>
</li>
</ul>
<p>}</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">上面是比较详细的代码注释，接下来我们抠出这段代码中关键的部分，让大家对这部分流程更加清晰：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><p>(BOOL)_innerPumpScanner {</p>
<p>  &#x2F;&#x2F;第一部分： 前置条件判断<br>  &#x2F;&#x2F;…………….</p>
<p>  &#x2F;&#x2F;取出数据消费者队列中的第一个消费者<br>  SRIOConsumer *consumer &#x3D; [_consumers objectAtIndex:0];</p>
<p>  &#x2F;&#x2F;第二部分：得到需要的字节数foundSize<br>  size_t bytesNeeded &#x3D; consumer.bytesNeeded;<br>  &#x2F;&#x2F;消费者本次找到的要读取的数据大小<br>  size_t foundSize &#x3D; 0;<br>  &#x2F;&#x2F; 确定foundSize 大小<br>  &#x2F;&#x2F;consumer.consumer是指定了用于查找要读取数据的规则。<br>  if (consumer.consumer) {<br>  &#x2F;&#x2F;指定了用于查找要读取数据的规则的情况<br>  } else {<br>  &#x2F;&#x2F;读取当前帧或者读取部分数据的情况<br>  }</p>
<p>  &#x2F;&#x2F;第三部分：通过上面的foundSize得到需要读取的数据，并且释放已读的空间<br>  &#x2F;&#x2F;如果读取当前帧或者foundSize大于0<br>  if (consumer.readToCurrentFrame || foundSize) {<br>  &#x2F;&#x2F;从已读偏移到要读的字节处<br>  NSRange sliceRange &#x3D; NSMakeRange(_readBufferOffset, foundSize);<br>  &#x2F;&#x2F;得到data<br>  slice &#x3D; [_readBuffer subdataWithRange:sliceRange];<br>  &#x2F;&#x2F;…………….<br><br>  &#x2F;&#x2F;如果读取当前帧<br>  if (consumer.readToCurrentFrame) {<br>      &#x2F;&#x2F;拼接数据<br>      [_currentFrameData appendData:slice];<br>      &#x2F;&#x2F;…………..<br>      &#x2F;&#x2F;当前帧已经读取完毕<br>      if (consumer.bytesNeeded &#x3D;&#x3D; 0) {<br>          [_consumers removeObjectAtIndex:0];<br>          &#x2F;&#x2F;回调读取完成<br>          consumer.handler(self, nil);&#x2F;&#x2F;由于读取当前帧的时候数据存放在_currentFrameData，所以这里返回为nil<br>          &#x2F;&#x2F;把要返回的consumer，先放在_consumerPool缓冲池中<br>          [_consumerPool returnConsumer:consumer];<br>          &#x2F;&#x2F;已经工作为YES<br>          didWork &#x3D; YES;<br>      }<br>  }<br>  &#x2F;&#x2F;非当前帧的情况<br>  else if (foundSize) {<br>      &#x2F;&#x2F;第四部分：将得到所需要数据的消费者从消费者列表中移除，并通过对应的block交付数据，将consumer放到对象池中。<br>      [_consumers removeObjectAtIndex:0];<br>      &#x2F;&#x2F;回调回去当前接受到的数据<br>      consumer.handler(self, slice);<br>      [_consumerPool returnConsumer:consumer];<br>      didWork &#x3D; YES;<br>  }<br>  }<br>  return didWork;</p>
</li>
</ul>
<p>}</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">整个流程分成四个步骤：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>第一部分：前置条件判断<br>第二部分：确定消费者需要的字节数foundSize<br>第三部分：通过上面的foundSize得到需要读取的数据，并且释放已读的空间<br>第四部分：将得到所需要数据的消费者从消费者列表中移除，并通过对应的block交付数据，将consumer放到对象池中。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">再回到<span class="built_in">NSStreamEventHasBytesAvailable</span>事件的处理中做个总结：</span><br><span class="line"></span><br><span class="line">这个事件中，首先将数据从数据流中取出数据然后添加到读缓存中，然后从数据消费者队列中取出一个消费者，让它再读缓存中按需读取出它所需要的数据，并通过block交付给应用层。至于消费者是何时添加的我们放在后面集中介绍，我们接下来看<span class="built_in">NSStreamEventHasSpaceAvailable</span>。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>case NSStreamEventHasSpaceAvailable: {<br>    SRFastLog(@”NSStreamEventHasSpaceAvailable %@”, aStream);<br>    [self _pumpWriting];<br>    break;<br>}</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">写相对读来说相对简单，这里就不做过多介绍，大家可以直接看下面注释：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><p>(void)_writeData:(NSData *)data {<br>  [self assertOnWorkQueue];</p>
<p>  if (_closeWhenFinishedWriting) {<br>      return;<br>  }<br>  [_outputBuffer appendData:data];<br>  [self _pumpWriting];</p>
</li>
</ul>
<p>}</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><p>(void)_pumpWriting {<br>  [self assertOnWorkQueue];<br>  &#x2F;&#x2F;输出缓存大小<br>  NSUInteger dataLength &#x3D; _outputBuffer.length;<br>  &#x2F;&#x2F;输出缓存和输出流都还有空间剩余<br>  if (dataLength - _outputBufferOffset &gt; 0 &amp;&amp; _outputStream.hasSpaceAvailable) {<br>  &#x2F;&#x2F;通过输出缓存输出数据<br>  NSInteger bytesWritten &#x3D; [_outputStream write:_outputBuffer.bytes + _outputBufferOffset maxLength:dataLength - _outputBufferOffset];<br>  &#x2F;&#x2F;………..<br>  &#x2F;&#x2F;修改缓存偏移<br>  _outputBufferOffset +&#x3D; bytesWritten;<br>  &#x2F;&#x2F;……….<br>  }<br>  &#x2F;&#x2F;如果_closeWhenFinishedWriting表示写完数据后关闭连接则走下面流程<br>  if (_closeWhenFinishedWriting &amp;&amp;<br>  _outputBuffer.length - _outputBufferOffset &#x3D;&#x3D; 0 &amp;&amp;<br>  (_inputStream.streamStatus !&#x3D; NSStreamStatusNotOpen &amp;&amp;<br>   _inputStream.streamStatus !&#x3D; NSStreamStatusClosed) &amp;&amp;<br>  !_sentClose) {<br>  _sentClose &#x3D; YES;<br>  @synchronized(self) {<br>      [_outputStream close];<br>      [_inputStream close];<br>      for (NSArray *runLoop in [_scheduledRunloops copy]) {<br>          [self unscheduleFromRunLoop:[runLoop objectAtIndex:0] forMode:[runLoop objectAtIndex:1]];<br>      }<br>  }<br>  if (!_failed) {<br>      &#x2F;&#x2F;通过代理告诉应用层关闭的原因<br>      [self _performDelegateBlock:^{<br>          if ([self.delegate respondsToSelector:@selector(webSocket:didCloseWithCode:reason:wasClean:)]) {<br>              [self.delegate webSocket:self didCloseWithCode:_closeCode reason:_closeReason wasClean:YES];<br>          }<br>      }];<br>  }<br>  [self _scheduleCleanup];<br>  }<br>}</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">我们接下来看下数据消费者是如何管理的：</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>(void)_addConsumerWithDataLength:(size_t)dataLength<br>                    callback:(data_callback)callback<br>          readToCurrentFrame:(BOOL)readToCurrentFrame<br>                 unmaskBytes:(BOOL)unmaskBytes {<br>  [self assertOnWorkQueue];<br>  assert(dataLength);</p>
<p>  [_consumers addObject:[_consumerPool consumerWithScanner:nil<br>                                               handler:callback<br>                                            bytesNeeded:dataLength<br>                                     readToCurrentFrame:readToCurrentFrame<br>                                            unmaskBytes:unmaskBytes]];<br>  [self _pumpScanner];</p>
</li>
</ul>
<p>}</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><p>(SRIOConsumer *)consumerWithScanner:(stream_scanner)scanner<br>                        handler:(data_callback)handler<br>                    bytesNeeded:(size_t)bytesNeeded<br>             readToCurrentFrame:(BOOL)readToCurrentFrame<br>                    unmaskBytes:(BOOL)unmaskBytes {<br>  SRIOConsumer *consumer &#x3D; nil;<br>  if (_bufferedConsumers.count) {<br>  consumer &#x3D; [_bufferedConsumers lastObject];<br>  [_bufferedConsumers removeLastObject];<br>  } else {<br>  consumer &#x3D; [[SRIOConsumer alloc] init];<br>  }</p>
<p>  [consumer setupWithScanner:scanner handler:handler bytesNeeded:bytesNeeded readToCurrentFrame:readToCurrentFrame unmaskBytes:unmaskBytes];</p>
<p>  return consumer;</p>
</li>
</ul>
<p>}</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><p>(void)returnConsumer:(SRIOConsumer *)consumer {<br>  if (_bufferedConsumers.count &lt; _poolSize) {<br>  [_bufferedConsumers addObject:consumer];<br>  }<br>}</p>
<figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">数据消费者是通过****<span class="variable">_addConsumerWithDataLength</span>****添加到消费者数组<span class="variable">_consumers</span>中的，同时为了避免频繁创建消费者对象这里使用了对象池，默认消费者对象池中的对象为<span class="number">8</span>个，每次用完都会归还到对象池，在需要的时候会从对象池中拿取最后一个返回。</span><br><span class="line"></span><br><span class="line">所以添加消费者对象的时候会从消费者对象池中取出一个闲置的消费者对象，然后添加到消费者队列中，然后调用<span class="variable">_pumpScanner</span>，从消费者列表中取出第一个消费者，让它从读缓存中读取需要的数据，并通过handler交付读到的数据。</span><br><span class="line"></span><br><span class="line">SRWebSocket会在如下情况下添加消费者：</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>(void)_readUntilHeaderCompleteWithCallback:(data_callback)dataHandler; &#x2F;&#x2F; 握手阶段，发送完握手头信息后会去读取服务端返回的响应头</p>
</li>
<li><p>(void)_readFrameContinue；持续读帧信息的时候</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">也就是每次需要数据的时候都会往消费者队列中添加一个消费者，等到有数据之后会去除这些消费者读取数据，并通过block交付。</span><br><span class="line"></span><br><span class="line"><span class="strong">****</span>读取接收到的连续帧<span class="strong">****</span></span><br><span class="line"></span><br><span class="line">介绍了缓存的读写，读消费者的管理，以及帧格式的介绍后下面我们来看下怎样读取帧和发送帧，首先看下读取连续帧：</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>(void)_readFrameContinue {</p>
<p>  assert((_currentFrameCount &#x3D;&#x3D; 0 &amp;&amp; _currentFrameOpcode &#x3D;&#x3D; 0) || (_currentFrameCount &gt; 0 &amp;&amp; _currentFrameOpcode &gt; 0));</p>
<p>  [self _addConsumerWithDataLength:2 callback:^(SRWebSocket *self, NSData *data) {</p>
<pre><code>  __block frame_header header = &#123;0&#125;;
  
  const uint8_t *headerBuffer = data.bytes;
  assert(data.length &gt;= 2);
  
  //读取RSV,默认必须是0
  if (headerBuffer[0] &amp; SRRsvMask) &#123;
      [self _closeWithProtocolError:@&quot;Server used RSV bits&quot;];
      return;
  &#125;
  //获取操作码
  uint8_t receivedOpcode = (SROpCodeMask &amp; headerBuffer[0]);
  //当前帧是否是控制帧
  BOOL isControlFrame = (receivedOpcode == SROpCodePing || receivedOpcode == SROpCodePong || receivedOpcode == SROpCodeConnectionClose);
  
  //中间帧的操作码必须为0
  if (!isControlFrame &amp;&amp; receivedOpcode != 0 &amp;&amp; self-&gt;_currentFrameCount &gt; 0) &#123;
      [self _closeWithProtocolError:@&quot;all data frames after the initial data frame must have opcode 0&quot;];
      return;
  &#125;
  if (receivedOpcode == 0 &amp;&amp; self-&gt;_currentFrameCount == 0) &#123;
      [self _closeWithProtocolError:@&quot;cannot continue a message&quot;];
      return;
  &#125;
  //操作码赋给header
  header.opcode = receivedOpcode == 0 ? self-&gt;_currentFrameOpcode : receivedOpcode;
  //fin结束码赋给header
  header.fin = !!(SRFinMask &amp; headerBuffer[0]);
  //是否mask字段
  header.masked = !!(SRMaskMask &amp; headerBuffer[1]);
  //内容长度
  header.payload_length = SRPayloadLenMask &amp; headerBuffer[1];
  headerBuffer = NULL;
  //客户端收到的数据必须是unmasked数据
  if (header.masked) &#123;
      [self _closeWithProtocolError:@&quot;Client must receive unmasked data&quot;];
  &#125;
  //额外内容
  size_t extra_bytes_needed = header.masked ? sizeof(_currentReadMaskKey) : 0;
  //.........
  if (extra_bytes_needed == 0) &#123;
      [self _handleFrameHeader:header curData:self-&gt;_currentFrameData];
  &#125; else &#123;
      //..........
  &#125;
</code></pre>
<p>  } readToCurrentFrame:NO unmaskBytes:NO];</p>
</li>
</ul>
<p>}</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><p>(void)_handleFrameHeader:(frame_header)frame_header curData:(NSData *)curData {</p>
<p>  &#x2F;&#x2F;当前状态检查<br>  if (self.readyState &#x3D;&#x3D; SR_CLOSED) {<br>  return;<br>  }</p>
<p>  &#x2F;&#x2F;是否是控制帧<br>  BOOL isControlFrame &#x3D; (frame_header.opcode &#x3D;&#x3D; SROpCodePing || frame_header.opcode &#x3D;&#x3D; SROpCodePong || frame_header.opcode &#x3D;&#x3D; SROpCodeConnectionClose);</p>
<p>  &#x2F;&#x2F;控制帧不能分片<br>  if (isControlFrame &amp;&amp; !frame_header.fin) {<br>  [self _closeWithProtocolError:@”Fragmented control frames not allowed”];<br>  return;<br>  }</p>
<p>  &#x2F;&#x2F;控制帧大小不能大于126<br>  if (isControlFrame &amp;&amp; frame_header.payload_length &gt;&#x3D; 126) {<br>  [self _closeWithProtocolError:@”Control frames cannot have payloads larger than 126 bytes”];<br>  return;<br>  }</p>
<p>  if (!isControlFrame) {<br>  _currentFrameOpcode &#x3D; frame_header.opcode;<br>  _currentFrameCount +&#x3D; 1;<br>  }</p>
<p>  if (frame_header.payload_length &#x3D;&#x3D; 0) {<br>  &#x2F;&#x2F;是控制帧的情况<br>  if (isControlFrame) {<br>      [self _handleFrameWithData:curData opCode:frame_header.opcode];<br>  } else {<br>      if (frame_header.fin) {<br>          &#x2F;&#x2F;数据帧读取完毕<br>          [self _handleFrameWithData:_currentFrameData opCode:frame_header.opcode];<br>      } else {<br>          &#x2F;&#x2F;数据帧还未读取完毕<br>          [self _readFrameContinue];<br>      }<br>  }<br>  } else {<br>  &#x2F;&#x2F;有负载数据<br>  assert(frame_header.payload_length &lt;&#x3D; SIZE_T_MAX);<br>  [self _addConsumerWithDataLength:(size_t)frame_header.payload_length callback:^(SRWebSocket *self, NSData *newData) {<br>      &#x2F;&#x2F;是控制帧的情况<br>      if (isControlFrame) {<br>          [self _handleFrameWithData:newData opCode:frame_header.opcode];<br>      } else {<br>          if (frame_header.fin) {<br>              &#x2F;&#x2F;数据帧读取完毕<br>              [self _handleFrameWithData:self-&gt;_currentFrameData opCode:frame_header.opcode];<br>          } else {<br>              &#x2F;&#x2F;数据帧还未读取完毕<br>              [self _readFrameContinue];<br>          }<br><br>      }<br>  } readToCurrentFrame:!isControlFrame unmaskBytes:frame_header.masked];<br>  }</p>
</li>
</ul>
<p>}</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><p>(void)_handleFrameWithData:(NSData *)frameData opCode:(NSInteger)opcode {<br>  &#x2F;&#x2F; Check that the current data is valid UTF8</p>
<p>  BOOL isControlFrame &#x3D; (opcode &#x3D;&#x3D; SROpCodePing || opcode &#x3D;&#x3D; SROpCodePong || opcode &#x3D;&#x3D; SROpCodeConnectionClose);<br>  &#x2F;&#x2F;………….<br>  switch (opcode) {<br>  &#x2F;&#x2F;文本流<br>  case SROpCodeTextFrame: {<br>      &#x2F;&#x2F;如果当前类型为文本类型，是否转为string<br>      if ([self.delegate respondsToSelector:@selector(webSocketShouldConvertTextFrameToString:)] &amp;&amp; ![self.delegate webSocketShouldConvertTextFrameToString:self]) {<br>          &#x2F;&#x2F;不转为string<br>          [self _handleMessage:[frameData copy]];<br>      } else {<br>          &#x2F;&#x2F;转为string<br>          NSString *str &#x3D; [[NSString alloc] initWithData:frameData encoding:NSUTF8StringEncoding];<br>          &#x2F;&#x2F;有数据但是转换后string为空，表明转换失败<br>          if (str &#x3D;&#x3D; nil &amp;&amp; frameData) {<br>              [self closeWithCode:SRStatusCodeInvalidUTF8 reason:@”Text frames must be valid UTF-8”];<br>              dispatch_async(_workQueue, ^{<br>                  [self closeConnection];<br>              });<br>              return;<br>          }<br>          [self _handleMessage:str];<br>      }<br>      break;<br>  }<br>  case SROpCodeBinaryFrame:<br>      &#x2F;&#x2F;二进制流<br>      [self _handleMessage:[frameData copy]];<br>      break;<br>      &#x2F;&#x2F;关闭消息<br>  case SROpCodeConnectionClose:<br>      [self handleCloseWithData:[frameData copy]];<br>      break;<br>      &#x2F;&#x2F; ping<br>  case SROpCodePing:<br>      [self handlePing:[frameData copy]];<br>      break;<br>      &#x2F;&#x2F; pong<br>  case SROpCodePong:<br>      [self handlePong:[frameData copy]];<br>      break;<br>  default:<br>      [self _closeWithProtocolError:[NSString stringWithFormat:@”Unknown opcode %ld”, (long)opcode]];<br>      &#x2F;&#x2F; TODO: Handle invalid opcode<br>      break;<br>  }</p>
</li>
</ul>
<p>}</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>(void)_handleMessage:(id)message {<br>  SRFastLog(@”Received message”);<br>  [self _performDelegateBlock:^{<br>  [self.delegate webSocket:self didReceiveMessage:message];<br>  }];<br>}<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">上面将所有读连续帧的代码都贴出来了，并做了对应的注释，下面我们来做个总结，<span class="strong">****</span><span class="emphasis">_readFrameContinue<span class="strong">****</span>会先读取帧的前两个字节取出fin,rsv,opcode,payload len,并对这些字段进行校验。<span class="strong">****</span>_</span>handleFrameHeader<span class="strong">****</span>继续读取payload数据，再将数据以及opcode送到<span class="strong">****</span><span class="emphasis">_handleFrameWithData<span class="strong">****</span> 通过 <span class="strong">****</span>_</span>handleMessage<span class="strong">****</span> 将消息送到业务层。从这里可以看出虽然WebSocket会将数据进行分包，但是SRWebSocket会再底层将这些分包进行拼接后将一个完整的数据交付给业务层。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="strong">****</span>发送帧数据<span class="strong">****</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>(void)send:(id)data {<br>  data &#x3D; [data copy];<br>  dispatch_async(_workQueue, ^{<br>  if ([data isKindOfClass:[NSString class]]) {<br>      [self _sendFrameWithOpcode:SROpCodeTextFrame data:[(NSString *)data dataUsingEncoding:NSUTF8StringEncoding]];<br>  } else if ([data isKindOfClass:[NSData class]]) {<br>      [self _sendFrameWithOpcode:SROpCodeBinaryFrame data:data];<br>  } else if (data &#x3D;&#x3D; nil) {<br>      [self _sendFrameWithOpcode:SROpCodeTextFrame data:data];<br>  } else {<br>      assert(NO);<br>  }<br>  });<br>}</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><p>(void)_sendFrameWithOpcode:(SROpCode)opcode data:(id)data {</p>
<p>  &#x2F;&#x2F;….</p>
<p>  size_t payloadLength &#x3D; [data isKindOfClass:[NSString class]] ? [(NSString *)data lengthOfBytesUsingEncoding:NSUTF8StringEncoding] : [data length];</p>
<p>  NSMutableData *frame &#x3D; [[NSMutableData alloc] initWithLength:payloadLength + SRFrameHeaderOverhead];</p>
<p>  &#x2F;&#x2F;…..</p>
<p>  uint8_t *frame_buffer &#x3D; (uint8_t *)[frame mutableBytes];</p>
<p>  &#x2F;&#x2F; 设置fin<br>  frame_buffer[0] &#x3D; SRFinMask | opcode;</p>
<p>  BOOL useMask &#x3D; YES;</p>
</li>
</ul>
<p>#ifdef NOMASK<br>    useMask &#x3D; NO;<br>#endif</p>
<pre><code>// 客户端发送给服务端的必须使用mask
if (useMask) &#123;
// set the mask and header
    frame_buffer[1] |= SRMaskMask;
&#125;

size_t frame_buffer_size = 2;

//填充数据
const uint8_t *unmasked_payload = NULL;
if ([data isKindOfClass:[NSData class]]) &#123;
    unmasked_payload = (uint8_t *)[data bytes];
&#125; else if ([data isKindOfClass:[NSString class]]) &#123;
    unmasked_payload =  (const uint8_t *)[data UTF8String];
&#125; else &#123;
    return;
&#125;

//设置payload字段
if (payloadLength &lt; 126) &#123;
    frame_buffer[1] |= payloadLength;
&#125; else if (payloadLength &lt;= UINT16_MAX) &#123;
    frame_buffer[1] |= 126;
    *((uint16_t *)(frame_buffer + frame_buffer_size)) = EndianU16_BtoN((uint16_t)payloadLength);
    frame_buffer_size += sizeof(uint16_t);
&#125; else &#123;
    frame_buffer[1] |= 127;
    *((uint64_t *)(frame_buffer + frame_buffer_size)) = EndianU64_BtoN((uint64_t)payloadLength);
    frame_buffer_size += sizeof(uint64_t);
&#125;
    
if (!useMask) &#123;
    for (size_t i = 0; i &lt; payloadLength; i++) &#123;
        frame_buffer[frame_buffer_size] = unmasked_payload[i];
        frame_buffer_size += 1;
    &#125;
&#125; else &#123;
    //对数据进行mark 处理
    uint8_t *mask_key = frame_buffer + frame_buffer_size;
    SecRandomCopyBytes(kSecRandomDefault, sizeof(uint32_t), (uint8_t *)mask_key);
    frame_buffer_size += sizeof(uint32_t);
    
    // TODO: could probably optimize this with SIMD
    for (size_t i = 0; i &lt; payloadLength; i++) &#123;
        frame_buffer[frame_buffer_size] = unmasked_payload[i] ^ mask_key[i % sizeof(uint32_t)];
        frame_buffer_size += 1;
    &#125;
&#125;

assert(frame_buffer_size &lt;= [frame length]);
frame.length = frame_buffer_size;

//调用_writeData 写到流当中
[self _writeData:frame];
</code></pre>
<p>}</p>
<p>&#96;&#96;&#96;</p>
<p>发送帧流程比较简单，就是构造帧数据，然后将数据塞入帧中，往输出流写。</p>
<p>之前再规划这篇博客的时候本来只想简单介绍下SRWebSocket的但是写着写着，发现它还是满有意思的，特别是数据消费者部分的设计提起了兴趣，所以还是硬着头皮看将整个代码过了一遍，下面是一些比较好的文章，可以供大家深入阅读，个人觉得只要弄清楚了WebSocket理论基础后看这部分代码会显得十分轻松，希望这篇博客能够帮助到大家。好了今天就到这里。</p>
<h4 id="较好的文章推荐"><a href="#较好的文章推荐" class="headerlink" title="较好的文章推荐"></a>较好的文章推荐</h4><ul>
<li><a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc2616">Hypertext Transfer Protocol – HTTP&#x2F;1.1</a></li>
<li><a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc6455">The WebSocket Protocol</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/2dbb360886a8">iOS即时通讯，从入门到“放弃”？</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/cdb7a886789a">SRWebSocket源码浅析</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5bf37b766fb9a04a0163edb2">SRWebSocket 源码介绍</a></li>
<li><a target="_blank" rel="noopener" href="https://halfrost.com/websocket/">全双工通信的 WebSocket</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/bcefda55bce4">微信,QQ这类IM app怎么做——谈谈Websocket</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/0e5b946880b4">刨根问底HTTP和WebSocket协议(一）</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/f666da1b1835">刨根问底HTTP和WebSocket协议(二）</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/99610d84ab2a">刨根问底HTTP和WebSocket协议(三）</a></li>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/7620620/whats-the-behavioral-difference-between-http-stay-alive-and-websockets">What’s the behavioral difference between HTTP Stay-Alive and Websockets?</a></li>
<li><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000015122195">WebSocket与http长连接的区别</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/entry/5a5c559c518825734859ee5e">理论联系实际：从零理解WebSocket的通信原理、协议格式、安全性</a></li>
</ul>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/iOS-%E5%BC%80%E6%BA%90%E5%BA%93%E5%88%86%E6%9E%90/">iOS 开源库分析</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/iOS-开源库分析/">iOS 开源库分析</a>
  </div>

</div>



<div class="comments-count">
	
	  	<span></span>
		<a href="/2019/12/02/SRWebSocket介绍/#comments" class="ds-thread-count comments-count-link" data-thread-key="2019/12/02/SRWebSocket介绍/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/11/30/AFNetWorking源码解析/" title="AFNetWorking源码解析" itemprop="url">AFNetWorking源码解析</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Edgar" target="_blank" itemprop="author">Edgar</a>
		
  <p class="article-time">
    <time datetime="2019-11-29T18:23:27.000Z" itemprop="datePublished"> Published 2019-11-30</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h4 id="开源库信息"><a href="#开源库信息" class="headerlink" title="开源库信息"></a>开源库信息</h4><p><img src="/2019/11/30/AFNetWorking%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/00004.png"></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/AFNetworking/AFNetworking">AFNetworking</a></li>
</ul>
<h4 id="AFNetWorking-源码解析"><a href="#AFNetWorking-源码解析" class="headerlink" title="AFNetWorking 源码解析"></a>AFNetWorking 源码解析</h4><h5 id="AFNetWorking-组成"><a href="#AFNetWorking-组成" class="headerlink" title="AFNetWorking 组成"></a>AFNetWorking 组成</h5><p>AFNetWorking 主要由如下图几个部分构成</p>
<ul>
<li>AFURLSessionManager</li>
</ul>
<p>AFURLSessionManager 是整个开源库的核心，它连接着AFNetWorking其他几个重要部分，它是AFHTTPSessionManager的父类，一般我们在使用的时候一般使用AFHTTPSessionManager。但是核心部分还是集中在AFURLSessionManager中。AFURLSessionManager遵循了NSURLSessionDelegate, NSURLSessionTaskDelegate, NSURLSessionDataDelegate, NSURLSessionDownloadDelegate一大堆的协议,并将AFHTTPSessionManager作为URLSession 的 delegate。这样在URLSession 触发一系列关键事件的时候，够可以交给AFURLSessionManager接管处理。</p>
<ul>
<li>AFHTTPRequestSerializer</li>
<li>AFHTTPResponseSerializer</li>
</ul>
<p>AFHTTPRequestSerializer，AFHTTPResponseSerializer 分别是请求序列化器和返回体序列化器，引入序列化器后，序列化器就相当于一个插件一样，这样做的好处不言而喻，增加了整个系统的灵活性，比如我们应用中可能会对接不同的后端，这些后端可能有着不同的数据交付格式，有了序列化器后就可以针对不同的后端数据交付格式实现一对序列化器。整个框架就显得十分灵活，AFNetworking 也根据常见的需求实现了一些常用的序列化器,例如 AFJSONRequestSerializer，AFPropertyListRequestSerializer这两类请求序列化器;AFJSONResponseSerializer，AFXMLParserResponseSerializer,AFXMLDocumentResponseSerializer,<br>AFPropertyListResponseSerializer,AFImageResponseSerializer,AFCompoundResponseSerializer 这几类返回体序列化器。</p>
<ul>
<li>AFNetworkReachabilityManager</li>
</ul>
<p>AFNetworkReachabilityManager 主要用于检测网络可用性，这对于应用来说也是非常常用的一项功能。</p>
<ul>
<li>AFSecurityPolicy</li>
</ul>
<p>AFSecurityPolicy 主要用于提供安全认证相关的处理，</p>
<p><img src="/2019/11/30/AFNetWorking%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/00002.png"></p>
<h5 id="AFNetWorking-框架总览"><a href="#AFNetWorking-框架总览" class="headerlink" title="AFNetWorking 框架总览"></a>AFNetWorking 框架总览</h5><p>下面是AFNetWorking 整个框架重要流程的大致结构图，下面将针对这张图对源码进行进一步解析：</p>
<p><img src="/2019/11/30/AFNetWorking%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/00001.png"></p>
<ul>
<li><strong><strong>AFURLSessionManager的组成</strong></strong></li>
</ul>
<p>上面提到AFURLSessionManager是整个AFNetWorking的核心部分，在iOS中我们如果需要执行网络请求需要URLSession，AFNetWorking也一样，它只不过是对URLSession的一个封装，最核心的部分还是借助URLSession来完成，因此我们最先要弄清楚AFURLSessionManager是如何串起来的，我们上面提到了AFURLSessionManager实现了一系列的协议，并作为URLSession的delegate。这样我们在使用URLSession进行网络请求的时候就会触发delegate的对应方法进行处理，从而将流程交接给AFURLSessionManager。然后再由AFURLSessionManager调用其他的部件对数据进行后续处理。我们来看下AFURLSessionManager的初始化代码，看下AFURLSessionManager是由哪些部分组成：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="operator">-</span> (instancetype)initWithSessionConfiguration:(<span class="type">NSURLSessionConfiguration</span> <span class="operator">*</span>)configuration &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//.......</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// sessionConfiguration URLSession 配置类，通过它可以对URLSession进行配置</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="operator">!</span>configuration) &#123;</span><br><span class="line">        configuration <span class="operator">=</span> [<span class="type">NSURLSessionConfiguration</span> defaultSessionConfiguration];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">self</span>.sessionConfiguration <span class="operator">=</span> configuration;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//operationQueue:代理执行的OperationQueue，通过maxConcurrentOperationCount 限制每次只执行一个任务。</span></span><br><span class="line">    <span class="keyword">self</span>.operationQueue <span class="operator">=</span> [[<span class="type">NSOperationQueue</span> alloc] <span class="keyword">init</span>];</span><br><span class="line">    <span class="keyword">self</span>.operationQueue.maxConcurrentOperationCount <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//session: AFURLSessionManager 最核心的部分，在这里将AFURLSessionManager 作为NSURLSession delegate，并指定代理的执行队列</span></span><br><span class="line">    <span class="keyword">self</span>.session <span class="operator">=</span> [<span class="type">NSURLSession</span> sessionWithConfiguration:<span class="keyword">self</span>.sessionConfiguration delegate:<span class="keyword">self</span> delegateQueue:<span class="keyword">self</span>.operationQueue];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//指定返回体序列化器</span></span><br><span class="line">    <span class="keyword">self</span>.responseSerializer <span class="operator">=</span> [<span class="type">AFJSONResponseSerializer</span> serializer];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//指定安全认证相关类</span></span><br><span class="line">    <span class="keyword">self</span>.securityPolicy <span class="operator">=</span> [<span class="type">AFSecurityPolicy</span> defaultPolicy];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化网络状态检测对象</span></span><br><span class="line">    <span class="keyword">self</span>.reachabilityManager <span class="operator">=</span> [<span class="type">AFNetworkReachabilityManager</span> sharedManager];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个是task与AFURLSessionManagerTaskDelegate映射的表格，AFURLSessionManagerTaskDelegate后面会详细介绍。</span></span><br><span class="line">    <span class="keyword">self</span>.mutableTaskDelegatesKeyedByTaskIdentifier <span class="operator">=</span> [[<span class="type">NSMutableDictionary</span> alloc] <span class="keyword">init</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在初始化方法中，主要初始化了self.session，self.responseSerializer，self.securityPolicy，self.reachabilityManager 这些对象，并给self.session指定了delegate，delegate执行的队列，以及配置。</p>
<p>介绍了AFURLSessionManager接下来就按照应用场景对AFNetWorking进行介绍:</p>
<ul>
<li><strong><strong>发起数据请求</strong></strong></li>
</ul>
<p>这部分我们会以常见的GET请求为例子来过下整个流程：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">NSURLSessionDataTask</span> *)GET:(<span class="built_in">NSString</span> *)URLString</span><br><span class="line">                   parameters:(<span class="type">id</span>)parameters</span><br><span class="line">                     progress:(<span class="type">void</span> (^)(<span class="built_in">NSProgress</span> * _Nonnull))downloadProgress</span><br><span class="line">                      success:(<span class="type">void</span> (^)(<span class="built_in">NSURLSessionDataTask</span> * _Nonnull, <span class="type">id</span> _Nullable))success</span><br><span class="line">                      failure:(<span class="type">void</span> (^)(<span class="built_in">NSURLSessionDataTask</span> * _Nullable, <span class="built_in">NSError</span> * _Nonnull))failure &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSURLSessionDataTask</span> *dataTask = [<span class="keyword">self</span> dataTaskWithHTTPMethod:<span class="string">@&quot;GET&quot;</span></span><br><span class="line">                                                        URLString:URLString</span><br><span class="line">                                                       parameters:parameters</span><br><span class="line">                                                   uploadProgress:<span class="literal">nil</span></span><br><span class="line">                                                 downloadProgress:downloadProgress</span><br><span class="line">                                                          success:success</span><br><span class="line">                                                          failure:failure];</span><br><span class="line"></span><br><span class="line">    [dataTask resume];</span><br><span class="line">    <span class="keyword">return</span> dataTask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在GET中主要通过dataTaskWithHTTPMethod创建了一个NSURLSessionDataTask对象，然后通过resume执行这个task。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">NSURLSessionDataTask</span> *)dataTaskWithHTTPMethod:(<span class="built_in">NSString</span> *)method</span><br><span class="line">                                       URLString:(<span class="built_in">NSString</span> *)URLString</span><br><span class="line">                                      parameters:(<span class="type">id</span>)parameters</span><br><span class="line">                                  uploadProgress:(<span class="keyword">nullable</span> <span class="type">void</span> (^)(<span class="built_in">NSProgress</span> *uploadProgress)) uploadProgress</span><br><span class="line">                                downloadProgress:(<span class="keyword">nullable</span> <span class="type">void</span> (^)(<span class="built_in">NSProgress</span> *downloadProgress)) downloadProgress</span><br><span class="line">                                         success:(<span class="type">void</span> (^)(<span class="built_in">NSURLSessionDataTask</span> *, <span class="type">id</span>))success</span><br><span class="line">                                         failure:(<span class="type">void</span> (^)(<span class="built_in">NSURLSessionDataTask</span> *, <span class="built_in">NSError</span> *))failure &#123;</span><br><span class="line">    <span class="built_in">NSError</span> *serializationError = <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">NSMutableURLRequest</span> *request = [<span class="keyword">self</span>.requestSerializer requestWithMethod:method URLString:[[<span class="built_in">NSURL</span> URLWithString:URLString relativeToURL:<span class="keyword">self</span>.baseURL] absoluteString] parameters:parameters error:&amp;serializationError];</span><br><span class="line">    <span class="keyword">if</span> (serializationError) &#123;</span><br><span class="line">        <span class="keyword">if</span> (failure) &#123;</span><br><span class="line">            <span class="built_in">dispatch_async</span>(<span class="keyword">self</span>.completionQueue ?: dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                failure(<span class="literal">nil</span>, serializationError);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    __block <span class="built_in">NSURLSessionDataTask</span> *dataTask = <span class="literal">nil</span>;</span><br><span class="line">    dataTask = [<span class="keyword">self</span> dataTaskWithRequest:request</span><br><span class="line">                          uploadProgress:uploadProgress</span><br><span class="line">                        downloadProgress:downloadProgress</span><br><span class="line">                       completionHandler:^(<span class="built_in">NSURLResponse</span> * __unused response, <span class="type">id</span> responseObject, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">        <span class="keyword">if</span> (error) &#123;</span><br><span class="line">            <span class="keyword">if</span> (failure) &#123;</span><br><span class="line">                failure(dataTask, error);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (success) &#123;</span><br><span class="line">                success(dataTask, responseObject);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dataTask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>dataTaskWithHTTPMethod 方法中主要分成两大部分：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1.</span> 构建NSMutableURLRequest</span><br><span class="line"><span class="bullet">2.</span> 构建NSURLSessionDataTask</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><strong>构建NSMutableURLRequest</strong></strong></li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">NSMutableURLRequest</span> *)requestWithMethod:(<span class="built_in">NSString</span> *)method</span><br><span class="line">                                 URLString:(<span class="built_in">NSString</span> *)URLString</span><br><span class="line">                                parameters:(<span class="type">id</span>)parameters</span><br><span class="line">                                     error:(<span class="built_in">NSError</span> *__autoreleasing *)error &#123;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">    <span class="comment">//使用URLString 创建 NSURL</span></span><br><span class="line">    <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:URLString];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//url 创建 NSMutableURLRequest</span></span><br><span class="line">    <span class="built_in">NSMutableURLRequest</span> *mutableRequest = [[<span class="built_in">NSMutableURLRequest</span> alloc] initWithURL:url];</span><br><span class="line">    <span class="comment">//NSMutableURLRequest method</span></span><br><span class="line">    mutableRequest.HTTPMethod = method;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将属性映射到NSMutableURLRequest</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSString</span> *keyPath <span class="keyword">in</span> AFHTTPRequestSerializerObservedKeyPaths()) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([<span class="keyword">self</span>.mutableObservedChangedKeyPaths containsObject:keyPath]) &#123;</span><br><span class="line">            [mutableRequest setValue:[<span class="keyword">self</span> valueForKeyPath:keyPath] forKey:keyPath];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将参数添加到NSMutableURLRequest</span></span><br><span class="line">    mutableRequest = [[<span class="keyword">self</span> requestBySerializingRequest:mutableRequest withParameters:parameters error:error] mutableCopy];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> mutableRequest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>NSMutableURLRequest 主要由NSURL,HTTPMethod,HTTPBody,allHTTPHeaderFields,parameters 以及一些配置属性构成。这里有个比较关键的点，如何将对当前属性的设置同步到mutableRequest中。这里用的是KVO来实现，下面这部分的关键代码：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">for (NSString *keyPath in AFHTTPRequestSerializerObservedKeyPaths()) &#123;</span><br><span class="line">        if ([self.mutableObservedChangedKeyPaths containsObject:keyPath]) &#123;</span><br><span class="line">            <span class="selector-attr">[mutableRequest setValue:[self valueForKeyPath:keyPath]</span> forKey:keyPath];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>首先会遍历AFHTTPRequestSerializerObservedKeyPaths，如果有在mutableObservedChangedKeyPaths中，mutableRequest就对这个属性进行监听。下面是AFHTTPRequestSerializerObservedKeyPaths的定义：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">NSArray</span> * AFHTTPRequestSerializerObservedKeyPaths() &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">NSArray</span> *_AFHTTPRequestSerializerObservedKeyPaths = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        _AFHTTPRequestSerializerObservedKeyPaths = @[</span><br><span class="line">                                                     </span><br><span class="line">                                                     <span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(allowsCellularAccess)),</span><br><span class="line">                                                     <span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(cachePolicy)),</span><br><span class="line">                                                     <span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(HTTPShouldHandleCookies)),</span><br><span class="line">                                                     <span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(HTTPShouldUsePipelining)),</span><br><span class="line">                                                     <span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(networkServiceType)),</span><br><span class="line">                                                     <span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(timeoutInterval))</span><br><span class="line">                                                     </span><br><span class="line">                                                    ];</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> _AFHTTPRequestSerializerObservedKeyPaths;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么mutableObservedChangedKeyPaths是怎么来的？这部分在AFHTTPRequestSerializer请求序列化器的初始化方法中有做处理，我们看下这部分代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="operator">-</span> (instancetype)<span class="keyword">init</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//.......</span></span><br><span class="line">    <span class="comment">// 指定字符编码格式</span></span><br><span class="line">    <span class="keyword">self</span>.stringEncoding <span class="operator">=</span> <span class="type">NSUTF8StringEncoding</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于存储请求头</span></span><br><span class="line">    <span class="keyword">self</span>.mutableHTTPRequestHeaders <span class="operator">=</span> [<span class="type">NSMutableDictionary</span> dictionary];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求头更新队列</span></span><br><span class="line">    <span class="keyword">self</span>.requestHeaderModificationQueue <span class="operator">=</span> dispatch_queue_create(<span class="string">&quot;requestHeaderModificationQueue&quot;</span>, <span class="type">DISPATCH_QUEUE_CONCURRENT</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --- Accept-Language 设置 ----</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Accept-Language HTTP Header; see http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.4</span></span><br><span class="line">    <span class="type">NSMutableArray</span> <span class="operator">*</span>acceptLanguagesComponents <span class="operator">=</span> [<span class="type">NSMutableArray</span> array];</span><br><span class="line">    [[<span class="type">NSLocale</span> preferredLanguages] enumerateObjectsUsingBlock:<span class="operator">^</span>(id obj, <span class="type">NSUInteger</span> idx, <span class="type">BOOL</span> <span class="operator">*</span>stop) &#123;</span><br><span class="line">        float q <span class="operator">=</span> <span class="number">1</span>.0f <span class="operator">-</span> (idx <span class="operator">*</span> <span class="number">0</span>.1f); <span class="comment">/*0 ， 1 ，2 ，3 ，4 */</span></span><br><span class="line">        [acceptLanguagesComponents addObject:[<span class="type">NSString</span> stringWithFormat:@<span class="string">&quot;%@;q=%0.1g&quot;</span>, obj, q]];</span><br><span class="line">        <span class="operator">*</span>stop <span class="operator">=</span> q <span class="operator">&lt;=</span> <span class="number">0</span>.5f;</span><br><span class="line">    &#125;];</span><br><span class="line">    [<span class="keyword">self</span> setValue:[acceptLanguagesComponents componentsJoinedByString:@<span class="string">&quot;, &quot;</span>] forHTTPHeaderField:@<span class="string">&quot;Accept-Language&quot;</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ----- User-Agent 设置 -------</span></span><br><span class="line">    <span class="type">NSString</span> <span class="operator">*</span>userAgent <span class="operator">=</span> <span class="literal">nil</span>;</span><br><span class="line">    <span class="comment">// User-Agent Header; see http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.43</span></span><br><span class="line">    userAgent <span class="operator">=</span> [<span class="type">NSString</span> stringWithFormat:@<span class="string">&quot;%@/%@ (%@; iOS %@; Scale/%0.2f)&quot;</span>, [[<span class="type">NSBundle</span> mainBundle] infoDictionary][(__bridge <span class="type">NSString</span> <span class="operator">*</span>)kCFBundleExecutableKey] <span class="operator">?</span>: [[<span class="type">NSBundle</span> mainBundle] infoDictionary][(__bridge <span class="type">NSString</span> <span class="operator">*</span>)kCFBundleIdentifierKey], [[<span class="type">NSBundle</span> mainBundle] infoDictionary][@<span class="string">&quot;CFBundleShortVersionString&quot;</span>] <span class="operator">?</span>: [[<span class="type">NSBundle</span> mainBundle] infoDictionary][(__bridge <span class="type">NSString</span> <span class="operator">*</span>)kCFBundleVersionKey], [[<span class="type">UIDevice</span> currentDevice] model], [[<span class="type">UIDevice</span> currentDevice] systemVersion], [[<span class="type">UIScreen</span> mainScreen] scale]];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (userAgent) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="operator">!</span>[userAgent canBeConvertedToEncoding:<span class="type">NSASCIIStringEncoding</span>]) &#123;</span><br><span class="line">            <span class="type">NSMutableString</span> <span class="operator">*</span>mutableUserAgent <span class="operator">=</span> [userAgent mutableCopy];</span><br><span class="line">            <span class="keyword">if</span> (<span class="type">CFStringTransform</span>((__bridge <span class="type">CFMutableStringRef</span>)(mutableUserAgent), <span class="type">NULL</span>, (__bridge <span class="type">CFStringRef</span>)@<span class="string">&quot;Any-Latin; Latin-ASCII; [:^ASCII:] Remove&quot;</span>, <span class="literal">false</span>)) &#123;</span><br><span class="line">                userAgent <span class="operator">=</span> mutableUserAgent;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        [<span class="keyword">self</span> setValue:userAgent forHTTPHeaderField:@<span class="string">&quot;User-Agent&quot;</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ------ 指定哪些请求的parameter添加到URL上 -------</span></span><br><span class="line">    <span class="comment">// HTTP Method Definitions; see http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html</span></span><br><span class="line">    <span class="keyword">self</span>.<span class="type">HTTPMethodsEncodingParametersInURI</span> <span class="operator">=</span> [<span class="type">NSSet</span> setWithObjects:@<span class="string">&quot;GET&quot;</span>, @<span class="string">&quot;HEAD&quot;</span>, @<span class="string">&quot;DELETE&quot;</span>, <span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ------- 通过keyPath 方式设置  -------</span></span><br><span class="line">    <span class="keyword">self</span>.mutableObservedChangedKeyPaths <span class="operator">=</span> [<span class="type">NSMutableSet</span> <span class="keyword">set</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">NSString</span> <span class="operator">*</span>keyPath <span class="keyword">in</span> <span class="type">AFHTTPRequestSerializerObservedKeyPaths</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([<span class="keyword">self</span> respondsToSelector:<span class="type">NSSelectorFromString</span>(keyPath)]) &#123;</span><br><span class="line">            [<span class="keyword">self</span> addObserver:<span class="keyword">self</span> forKeyPath:keyPath options:<span class="type">NSKeyValueObservingOptionNew</span> context:<span class="type">AFHTTPRequestSerializerObserverContext</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里主要对请求的字符串编码格式，请求头进行设置，以及通过keyPath方式往mutableObservedChangedKeyPaths中添加要监听的keyPath。KVO 方式监听的方式是NSKeyValueObservingOptionNew，也就是这些被监听的属性新建的时候就会被通知，我们接下来看下收到通知后的处理：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath</span><br><span class="line">                      ofObject:(__unused <span class="type">id</span>)object</span><br><span class="line">                        change:(<span class="built_in">NSDictionary</span> *)change</span><br><span class="line">                       context:(<span class="type">void</span> *)context &#123;</span><br><span class="line">    <span class="keyword">if</span> (context == AFHTTPRequestSerializerObserverContext) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([change[<span class="built_in">NSKeyValueChangeNewKey</span>] isEqual:[<span class="built_in">NSNull</span> null]]) &#123;</span><br><span class="line">            [<span class="keyword">self</span>.mutableObservedChangedKeyPaths removeObject:keyPath];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            [<span class="keyword">self</span>.mutableObservedChangedKeyPaths addObject:keyPath];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看到这里大家就可以明白了mutableObservedChangedKeyPaths是怎么来的：一旦我们监听的属性被创建后，就会跑到observeValueForKeyPath中，在observeValueForKeyPath方法中，会根据该属性是否为nil来决定是从mutableObservedChangedKeyPaths删除还是添加到mutableObservedChangedKeyPaths中。</p>
<p>我们这里对这部分做个总结：<br>在AFHTTPRequestSerializer请求序列化器初始化过程中会对AFHTTPRequestSerializerObservedKeyPaths中指定的属性通过KVO进行监听，监听这些对象的新建事件，一旦新建就会添加到mutableObservedChangedKeyPaths，然后每次发起请求前构造NSMutableRequest的时候，对存在于mutableObservedChangedKeyPaths中的属性进行KVO监听。这样一旦我们设置了序列化器中的对应属性，这些属性的状态就会同步到NSMutableRequest中。</p>
<p>我们接下来再回到请求的构建过程中：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">NSURLRequest</span> *)requestBySerializingRequest:(<span class="built_in">NSURLRequest</span> *)request</span><br><span class="line">                               withParameters:(<span class="type">id</span>)parameters</span><br><span class="line">                                        error:(<span class="built_in">NSError</span> *__autoreleasing *)error &#123;</span><br><span class="line">    <span class="built_in">NSParameterAssert</span>(request);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//复制一份request</span></span><br><span class="line">    <span class="built_in">NSMutableURLRequest</span> *mutableRequest = [request mutableCopy];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将原始的Header添加到新的request</span></span><br><span class="line">    [<span class="keyword">self</span>.HTTPRequestHeaders enumerateKeysAndObjectsUsingBlock:^(<span class="type">id</span> field, <span class="type">id</span> value, <span class="type">BOOL</span> * __unused stop) &#123;</span><br><span class="line">        <span class="keyword">if</span> (![request valueForHTTPHeaderField:field]) &#123;</span><br><span class="line">            [mutableRequest setValue:value forHTTPHeaderField:field];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSString</span> *query = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">if</span> (parameters) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.queryStringSerialization) &#123;</span><br><span class="line">            <span class="built_in">NSError</span> *serializationError;</span><br><span class="line">            query = <span class="keyword">self</span>.queryStringSerialization(request, parameters, &amp;serializationError);</span><br><span class="line">            <span class="keyword">if</span> (serializationError) &#123;</span><br><span class="line">                <span class="keyword">if</span> (error) &#123;</span><br><span class="line">                    <span class="comment">//通过error传出</span></span><br><span class="line">                    *error = serializationError;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">switch</span> (<span class="keyword">self</span>.queryStringSerializationStyle) &#123;</span><br><span class="line">                <span class="keyword">case</span> AFHTTPRequestQueryStringDefaultStyle:</span><br><span class="line">                    <span class="comment">//将参数转换成key1 = value1 &amp; key2 = value2的形式</span></span><br><span class="line">                    query = AFQueryStringFromParameters(parameters);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果需要将参数添加到URL最尾部，默认`GET`, `HEAD`, `DELETE` 这些是需要将参数添加到URL尾部的</span></span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span>.HTTPMethodsEncodingParametersInURI containsObject:[[request HTTPMethod] uppercaseString]]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (query &amp;&amp; query.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            mutableRequest.URL = [<span class="built_in">NSURL</span> URLWithString:[[mutableRequest.URL absoluteString] stringByAppendingFormat:mutableRequest.URL.query ? <span class="string">@&quot;&amp;%@&quot;</span> : <span class="string">@&quot;?%@&quot;</span>, query]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// #2864: an empty string is a valid x-www-form-urlencoded payload</span></span><br><span class="line">        <span class="keyword">if</span> (!query) &#123;</span><br><span class="line">            query = <span class="string">@&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (![mutableRequest valueForHTTPHeaderField:<span class="string">@&quot;Content-Type&quot;</span>]) &#123;</span><br><span class="line">            [mutableRequest setValue:<span class="string">@&quot;application/x-www-form-urlencoded&quot;</span> forHTTPHeaderField:<span class="string">@&quot;Content-Type&quot;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将参数添加到body部分</span></span><br><span class="line">        [mutableRequest setHTTPBody:[query dataUsingEncoding:<span class="keyword">self</span>.stringEncoding]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mutableRequest;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在这部分中我们会将初始化序列化器方法中指定的UA Accept-Language 这些头信息放置到请求中。<br>接着根据queryStringSerialization来决定需要对parameters进行序列化处理还是转换成“<strong><strong>key1 &#x3D; value1 &amp; key2 &#x3D; value2的形式</strong></strong>”形式。再根据self.HTTPMethodsEncodingParametersInURI决定是将参数放到url上还是body中。到此为止请求对象构建完毕。</p>
<ul>
<li><strong><strong>构建NSURLSessionDataTask</strong></strong></li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">NSURLSessionDataTask</span> *)dataTaskWithRequest:(<span class="built_in">NSURLRequest</span> *)request</span><br><span class="line">                               uploadProgress:(<span class="keyword">nullable</span> <span class="type">void</span> (^)(<span class="built_in">NSProgress</span> *uploadProgress)) uploadProgressBlock</span><br><span class="line">                             downloadProgress:(<span class="keyword">nullable</span> <span class="type">void</span> (^)(<span class="built_in">NSProgress</span> *downloadProgress)) downloadProgressBlock</span><br><span class="line">                            completionHandler:(<span class="keyword">nullable</span> <span class="type">void</span> (^)(<span class="built_in">NSURLResponse</span> *response, <span class="type">id</span> _Nullable responseObject,  <span class="built_in">NSError</span> * _Nullable error))completionHandler &#123;</span><br><span class="line"></span><br><span class="line">    __block <span class="built_in">NSURLSessionDataTask</span> *dataTask = <span class="literal">nil</span>;</span><br><span class="line">    url_session_manager_create_task_safely(^&#123;</span><br><span class="line">        <span class="comment">//通过一个request让session创建一个dataTask</span></span><br><span class="line">        dataTask = [<span class="keyword">self</span>.session dataTaskWithRequest:request];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//为这个dataTask添加uploadProgressBlock，downloadProgressBlock，completionHandler 并创建一个AFURLSessionManagerTaskDelegate与dataTask关联</span></span><br><span class="line">    [<span class="keyword">self</span> addDelegateForDataTask:dataTask uploadProgress:uploadProgressBlock downloadProgress:downloadProgressBlock completionHandler:completionHandler];</span><br><span class="line">    <span class="keyword">return</span> dataTask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>NSURLSessionDataTask的创建是通过URLSession创建并管理的，要创建NSURLSessionDataTask需要将上个步骤创建的NSMutableRequest传给URLSession通过dataTaskWithRequest方法返回NSURLSessionDataTask实例，然后再通过addDelegateForDataTask，往task中添加<br>uploadProgressBlock,downloadProgressBlock,completionHandler 这些都是AFNetWorking向外面传递数据的接口，我们接下来看下<strong><strong>addDelegateForDataTask</strong></strong>：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)addDelegateForDataTask:(<span class="built_in">NSURLSessionDataTask</span> *)dataTask</span><br><span class="line">                uploadProgress:(<span class="keyword">nullable</span> <span class="type">void</span> (^)(<span class="built_in">NSProgress</span> *uploadProgress)) uploadProgressBlock</span><br><span class="line">              downloadProgress:(<span class="keyword">nullable</span> <span class="type">void</span> (^)(<span class="built_in">NSProgress</span> *downloadProgress)) downloadProgressBlock</span><br><span class="line">             completionHandler:(<span class="type">void</span> (^)(<span class="built_in">NSURLResponse</span> *response, <span class="type">id</span> responseObject, <span class="built_in">NSError</span> *error))completionHandler &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//新建一个AFURLSessionManagerTaskDelegate每个AFURLSessionManagerTaskDelegate持有uploadProgressBlock，downloadProgressBlock，completionHandler以及AFURLSessionManager</span></span><br><span class="line">    AFURLSessionManagerTaskDelegate *delegate = [[AFURLSessionManagerTaskDelegate alloc] initWithTask:dataTask];</span><br><span class="line">    delegate.manager = <span class="keyword">self</span>;</span><br><span class="line">    delegate.completionHandler = completionHandler;</span><br><span class="line"></span><br><span class="line">    dataTask.taskDescription = <span class="keyword">self</span>.taskDescriptionForSessionTasks;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将taskidentify 作为key delegate为value 存到 mutableTaskDelegatesKeyedByTaskIdentifier字典中</span></span><br><span class="line">    [<span class="keyword">self</span> setDelegate:delegate forTask:dataTask];</span><br><span class="line"></span><br><span class="line">    delegate.uploadProgressBlock = uploadProgressBlock;</span><br><span class="line">    delegate.downloadProgressBlock = downloadProgressBlock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个方法中会创建一个AFURLSessionManagerTaskDelegate，每个NSURLSessionDataTask都会与一个AFURLSessionManagerTaskDelegate相关联，这是通过****[self setDelegate:delegate forTask:dataTask]****来完成的，在setDelegate方法中将taskidentify 作为key delegate为value 存到 mutableTaskDelegatesKeyedByTaskIdentifier字典中。<br>AFURLSessionManagerTaskDelegate主要负责两个任务，一个是负责进度的更新，一个是的网络数据mutableData的管理。这个会在后面进行介绍。每个AFURLSessionManagerTaskDelegate持有uploadProgressBlock，downloadProgressBlock，completionHandler以及AFURLSessionManager，在进度发生变化的时候都会通过uploadProgressBlock，downloadProgressBlock传出，当网络数据结束后，通过completionHandler传出。</p>
<p>那么AFURLSessionManagerTaskDelegate又是怎么和AFURLSessionManager产生关联的？<br>我们上面提到，所有的事件源于URLSession的各个代理，而通过将AFURLSessionManager设置为URLSession从而将事件传递到AFURLSessionManager，那么怎么将这些事件传给AFURLSessionManagerTaskDelegate呢？</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)URLSession:(NSURLSession *)session</span><br><span class="line">              <span class="keyword">task</span>:(NSURLSessionTask *)<span class="keyword">task</span></span><br><span class="line">didCompleteWithError:(NSError *)error &#123;</span><br><span class="line">    AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:<span class="keyword">task</span>];</span><br><span class="line">    <span class="comment">// delegate may be nil when completing a task in the background</span></span><br><span class="line">    <span class="keyword">if</span> (delegate) &#123;</span><br><span class="line">        [delegate URLSession:session <span class="keyword">task</span>:<span class="keyword">task</span> didCompleteWithError:error];</span><br><span class="line">        [self removeDelegateForTask:<span class="keyword">task</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (self.taskDidComplete) &#123;</span><br><span class="line">        self.taskDidComplete(session, <span class="keyword">task</span>, error);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就涉及到上面提到的mutableTaskDelegatesKeyedByTaskIdentifier，我们每个dataTask被新建的时候，都会同时新建一个AFURLSessionManagerTaskDelegate，并添加到mutableTaskDelegatesKeyedByTaskIdentifier，建立起以taskidentify为key AFURLSessionManagerTaskDelegate为value的映射关系。我们看上面的代理方法，会将task作为参数传进来，来表示具体是哪个task的回调，这时候通过task就可以找到对应的AFURLSessionManagerTaskDelegate 对象，并调用对应的方法进行处理，这就完成了AFURLSessionManager向AFURLSessionManagerTaskDelegate关联的环节。</p>
<ul>
<li><strong><strong>接受数据请求，交付数据</strong></strong></li>
</ul>
<p>在介绍这部分之前我们先来看下<strong><strong>NSURLSessionDataDelegate</strong></strong></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> mark - NSURLSessionDataDelegate</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//接收到服务器响应后会先调用这个方法，在这个方法中判定该次任务是否继续执行，或者转化为其他类型的任务</span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session </span><br><span class="line">          dataTask:(<span class="built_in">NSURLSessionDataTask</span> *)dataTask</span><br><span class="line">didReceiveResponse:(<span class="built_in">NSURLResponse</span> *)response</span><br><span class="line"> completionHandler:(<span class="type">void</span> (^)(<span class="built_in">NSURLSessionResponseDisposition</span> disposition))completionHandler&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        判定该次任务是否继续执行，或者转化为其他类型的任务</span></span><br><span class="line"><span class="comment">        typedef NS_ENUM(NSInteger, NSURLSessionResponseDisposition) &#123;</span></span><br><span class="line"><span class="comment">            NSURLSessionResponseCancel = 0,         //取消本次task任务</span></span><br><span class="line"><span class="comment">            NSURLSessionResponseAllow = 1,          //本次task任务继续</span></span><br><span class="line"><span class="comment">            NSURLSessionResponseBecomeDownload = 2, //转变本次dataTask任务为一个downloadTask下载任务</span></span><br><span class="line"><span class="comment">            NSURLSessionResponseBecomeStream        //转变本次dataTask任务为一个StreamTask流任务</span></span><br><span class="line"><span class="comment">        &#125; NS_ENUM_AVAILABLE(NSURLSESSION_AVAILABLE, 7_0);</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">//允许本次task继续执行</span></span><br><span class="line">    completionHandler(<span class="built_in">NSURLSessionResponseAllow</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据传输的过程中该方法会被调用 如果返回数据特别长，该方法会被多次调用</span></span><br><span class="line">- (<span class="type">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session </span><br><span class="line">          dataTask:(<span class="built_in">NSURLSessionDataTask</span> *)dataTask</span><br><span class="line">    didReceiveData:(<span class="built_in">NSData</span> *)data &#123;</span><br><span class="line">    <span class="comment">//拼接返回的数据</span></span><br><span class="line">    [<span class="keyword">self</span>.receiveData appendData:data];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数据传输完成最后该方法会被调用 不管最后该次请求成功或者失败该方法都会调用</span></span><br><span class="line">- (<span class="type">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session task:(<span class="built_in">NSURLSessionTask</span> *)task didCompleteWithError:(<span class="built_in">NSError</span> *)error&#123;</span><br><span class="line">    <span class="keyword">if</span>(error)&#123;</span><br><span class="line">        <span class="comment">// 请求失败</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;error = %@\n&quot;</span>,error);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 请求成功</span></span><br><span class="line">        <span class="comment">//解析返回的数据</span></span><br><span class="line">        <span class="built_in">NSDictionary</span> *dic = [<span class="built_in">NSJSONSerialization</span> JSONObjectWithData:<span class="keyword">self</span>.receiveData options:<span class="built_in">NSJSONReadingMutableContainers</span> | <span class="built_in">NSJSONReadingAllowFragments</span> error:<span class="literal">nil</span>];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;response content = %@&quot;</span>,dic);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在收到数据的时候会首先调用<strong><strong>URLSession:dataTask:didReceiveResponse:completionHandler</strong></strong>这个代理方法，可以在这个方法中根据返回的response来决定该任务是继续执行，还是转化为其他类型的任务。然后在 <strong><strong>URLSession:dataTask:didReceiveData</strong></strong>中接送回传的数据，最后走 <strong><strong>URLSession: task: didCompleteWithError</strong></strong> 对数据进行交付。</p>
<p>我们紧接着就来看下AFNetWorking中是如何处理这部分流程的：</p>
<p><strong><strong>URLSession:dataTask:didReceiveResponse:completionHandler</strong></strong> 方法中，AFURLSessionManager会通过block介入整个流程来决定到底是继续执行还是转换为其他类型任务。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</span><br><span class="line">          dataTask:(<span class="built_in">NSURLSessionDataTask</span> *)dataTask</span><br><span class="line">didReceiveResponse:(<span class="built_in">NSURLResponse</span> *)response</span><br><span class="line"> completionHandler:(<span class="type">void</span> (^)(<span class="built_in">NSURLSessionResponseDisposition</span> disposition))completionHandler &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSURLSessionResponseDisposition</span> disposition = <span class="built_in">NSURLSessionResponseAllow</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.dataTaskDidReceiveResponse) &#123;</span><br><span class="line">        disposition = <span class="keyword">self</span>.dataTaskDidReceiveResponse(session, dataTask, response);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (completionHandler) &#123;</span><br><span class="line">        completionHandler(disposition);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在接到数据后先通过delegateForTask方法拿到当前task对应的AFURLSessionManagerTaskDelegate，然后交给它进行处理。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</span><br><span class="line">          dataTask:(<span class="built_in">NSURLSessionDataTask</span> *)dataTask</span><br><span class="line">    didReceiveData:(<span class="built_in">NSData</span> *)data &#123;</span><br><span class="line"></span><br><span class="line">    AFURLSessionManagerTaskDelegate *delegate = [<span class="keyword">self</span> delegateForTask:dataTask];</span><br><span class="line">    [delegate URLSession:session dataTask:dataTask didReceiveData:data];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.dataTaskDidReceiveData) &#123;</span><br><span class="line">        <span class="keyword">self</span>.dataTaskDidReceiveData(session, dataTask, data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在NSURLSessionDataDelegate 中将该次到达的数据通过appendData添加到self.mutableData，到数据接收完毕后就会将self.mutableData交付出去。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)URLSession:(__unused <span class="built_in">NSURLSession</span> *)session</span><br><span class="line">          dataTask:(__unused <span class="built_in">NSURLSessionDataTask</span> *)dataTask</span><br><span class="line">    didReceiveData:(<span class="built_in">NSData</span> *)data &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span>.downloadProgress.totalUnitCount = dataTask.countOfBytesExpectedToReceive;</span><br><span class="line">    <span class="keyword">self</span>.downloadProgress.completedUnitCount = dataTask.countOfBytesReceived;</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span>.mutableData appendData:data];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>等到数据接收结束后会回调<strong><strong>URLSession: task: didCompleteWithError</strong></strong>这里同样会将流程转到task对应的AFURLSessionManagerTaskDelegate进行处理，最后将task从字典中移除。</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)URLSession:(NSURLSession *)session</span><br><span class="line">              <span class="keyword">task</span>:(NSURLSessionTask *)<span class="keyword">task</span></span><br><span class="line">didCompleteWithError:(NSError *)error &#123;</span><br><span class="line">    AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:<span class="keyword">task</span>];</span><br><span class="line">    <span class="comment">// delegate may be nil when completing a task in the background</span></span><br><span class="line">    <span class="keyword">if</span> (delegate) &#123;</span><br><span class="line">        [delegate URLSession:session <span class="keyword">task</span>:<span class="keyword">task</span> didCompleteWithError:error];</span><br><span class="line">        [self removeDelegateForTask:<span class="keyword">task</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (self.taskDidComplete) &#123;</span><br><span class="line">        self.taskDidComplete(session, <span class="keyword">task</span>, error);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在AFURLSessionManagerTaskDelegate中会将数据传递给responseSerializer，对数据进行预先处理后，通过bock以及通知将数据交付给应用层。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">- (void)URLSession:(__unused NSURLSession *)session</span><br><span class="line">              task:(NSURLSessionTask *)task</span><br><span class="line">didCompleteWithError:(NSError *)error &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line"></span><br><span class="line">        userInfo<span class="literal">[AFN<span class="identifier">etworkingTaskDidCompleteErrorKey</span>]</span> = error;</span><br><span class="line"></span><br><span class="line">        dispatch<span class="constructor">_group_async(<span class="params">manager</span>.<span class="params">completionGroup</span> ?: <span class="params">url_session_manager_completion_group</span>()</span>, manager.completionQueue ?: dispatch<span class="constructor">_get_main_queue()</span>, ^&#123;</span><br><span class="line">            <span class="keyword">if</span> (self.completionHandler) &#123;</span><br><span class="line">                self.completion<span class="constructor">Handler(<span class="params">task</span>.<span class="params">response</span>, <span class="params">responseObject</span>, <span class="params">error</span>)</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            dispatch<span class="constructor">_async(<span class="params">dispatch_get_main_queue</span>()</span>, ^&#123;</span><br><span class="line">                <span class="literal">[[NSN<span class="identifier">otificationCenter</span> <span class="identifier">defaultCenter</span>]</span> postNotificationName:AFNetworkingTaskDidCompleteNotification <span class="keyword">object</span>:task userInfo:userInfo];</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dispatch<span class="constructor">_async(<span class="params">url_session_manager_processing_queue</span>()</span>, ^&#123;</span><br><span class="line">            NSError *serializationError = nil;</span><br><span class="line">            <span class="comment">//使用responseSerializer 进行处理</span></span><br><span class="line">            responseObject = <span class="literal">[<span class="identifier">manager</span>.<span class="identifier">responseSerializer</span> <span class="identifier">responseObjectForResponse</span>:<span class="identifier">task</span>.<span class="identifier">response</span> <span class="identifier">data</span>:<span class="identifier">data</span> <span class="identifier">error</span>:&amp;<span class="identifier">serializationError</span>]</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (self.downloadFileURL) &#123;</span><br><span class="line">                responseObject = self.downloadFileURL;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (responseObject) &#123;</span><br><span class="line">                userInfo<span class="literal">[AFN<span class="identifier">etworkingTaskDidCompleteSerializedResponseKey</span>]</span> = responseObject;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (serializationError) &#123;</span><br><span class="line">                userInfo<span class="literal">[AFN<span class="identifier">etworkingTaskDidCompleteErrorKey</span>]</span> = serializationError;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            dispatch<span class="constructor">_group_async(<span class="params">manager</span>.<span class="params">completionGroup</span> ?: <span class="params">url_session_manager_completion_group</span>()</span>, manager.completionQueue ?: dispatch<span class="constructor">_get_main_queue()</span>, ^&#123;</span><br><span class="line">                <span class="keyword">if</span> (self.completionHandler) &#123;</span><br><span class="line">                    self.completion<span class="constructor">Handler(<span class="params">task</span>.<span class="params">response</span>, <span class="params">responseObject</span>, <span class="params">serializationError</span>)</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                dispatch<span class="constructor">_async(<span class="params">dispatch_get_main_queue</span>()</span>, ^&#123;</span><br><span class="line">                    <span class="literal">[[NSN<span class="identifier">otificationCenter</span> <span class="identifier">defaultCenter</span>]</span> postNotificationName:AFNetworkingTaskDidCompleteNotification <span class="keyword">object</span>:task userInfo:userInfo];</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看下返回体序列化器的处理过程，这里以最常用的<strong><strong>AFJSONResponseSerializer</strong></strong>来进行分析：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">id</span>)responseObjectForResponse:(<span class="built_in">NSURLResponse</span> *)response</span><br><span class="line">                           data:(<span class="built_in">NSData</span> *)data</span><br><span class="line">                          error:(<span class="built_in">NSError</span> *__autoreleasing *)error &#123;</span><br><span class="line">    <span class="keyword">if</span> (![<span class="keyword">self</span> validateResponse:(<span class="built_in">NSHTTPURLResponse</span> *)response data:data error:error]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!error || AFErrorOrUnderlyingErrorHasCodeInDomain(*error, <span class="built_in">NSURLErrorCannotDecodeContentData</span>, AFURLResponseSerializationErrorDomain)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">    <span class="built_in">NSError</span> *serializationError = <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">id</span> responseObject = [<span class="built_in">NSJSONSerialization</span> JSONObjectWithData:data options:<span class="keyword">self</span>.readingOptions error:&amp;serializationError];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> responseObject;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>responseObjectForResponse 方法就完成两件事情：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1.</span> 对返回response数据进行合法性校验</span><br><span class="line"><span class="bullet">2.</span> 对NSData 进行对应处理后（序列化）后返回</span><br></pre></td></tr></table></figure>

<p>在validateResponse 中主要完成contentType 以及 statusCode校验。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">BOOL</span>)validateResponse:(<span class="built_in">NSHTTPURLResponse</span> *)response</span><br><span class="line">                    data:(<span class="built_in">NSData</span> *)data</span><br><span class="line">                   error:(<span class="built_in">NSError</span> * __autoreleasing *)error &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">BOOL</span> responseIsValid = <span class="literal">YES</span>;</span><br><span class="line">    <span class="built_in">NSError</span> *validationError = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">if</span> (response &amp;&amp; [response isKindOfClass:[<span class="built_in">NSHTTPURLResponse</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="comment">//对返回体中的contentType 进行校验</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.acceptableContentTypes &amp;&amp; ![<span class="keyword">self</span>.acceptableContentTypes containsObject:[response MIMEType]] &amp;&amp;</span><br><span class="line">            !([response MIMEType] == <span class="literal">nil</span> &amp;&amp; [data length] == <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> ([data length] &gt; <span class="number">0</span> &amp;&amp; [response URL]) &#123;</span><br><span class="line">                <span class="comment">//.....</span></span><br><span class="line">            &#125;</span><br><span class="line">            responseIsValid = <span class="literal">NO</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//对返回体中的StatusCodes进行校验</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.acceptableStatusCodes &amp;&amp; ![<span class="keyword">self</span>.acceptableStatusCodes containsIndex:(<span class="built_in">NSUInteger</span>)response.statusCode] &amp;&amp; [response URL]) &#123;</span><br><span class="line">            <span class="comment">//.....</span></span><br><span class="line">            responseIsValid = <span class="literal">NO</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (error &amp;&amp; !responseIsValid) &#123;</span><br><span class="line">        *error = validationError;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> responseIsValid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><strong>进度的更新</strong></strong></li>
</ul>
<p>在上传数据或者下载数据的时候会分别回调didSendBodyData，didWriteData进行处理，在这两个代理回调中都会将数据传递到AFURLSessionManagerTaskDelegate中。</p>
<figure class="highlight erlang"><table><tr><td class="code"><pre><span class="line">- <span class="params">(void)</span>URLSession:<span class="params">(NSURLSession *)</span>session</span><br><span class="line">      downloadTask:<span class="params">(NSURLSessionDownloadTask *)</span>downloadTask</span><br><span class="line">      didWriteData:<span class="params">(int64_t)</span>bytesWritten</span><br><span class="line"> totalBytesWritten:<span class="params">(int64_t)</span>totalBytesWritten</span><br><span class="line">totalBytesExpectedToWrite:<span class="params">(int64_t)</span>totalBytesExpectedToWrite &#123;</span><br><span class="line">    </span><br><span class="line">    AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:downloadTask];</span><br><span class="line">    if <span class="params">(delegate)</span> &#123;</span><br><span class="line">        [delegate URLSession:session downloadTask:downloadTask didWriteData:bytesWritten totalBytesWritten:totalBytesWritten totalBytesExpectedToWrite:totalBytesExpectedToWrite];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if <span class="params">(self.downloadTaskDidWriteData)</span> &#123;</span><br><span class="line">        self.downloadTaskDidWriteData(session, downloadTask, bytesWritten, totalBytesWritten, totalBytesExpectedToWrite);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(NSURLSession *)session</span><br><span class="line">              <span class="keyword">task</span>:(NSURLSessionTask *)<span class="keyword">task</span></span><br><span class="line">   didSendBodyData:(int64_t)bytesSent</span><br><span class="line">    totalBytesSent:(int64_t)totalBytesSent</span><br><span class="line">totalBytesExpectedToSend:(int64_t)totalBytesExpectedToSend &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果返回的数据不知道大小，则从Content-Length字段中获取。</span></span><br><span class="line">    int64_t totalUnitCount = totalBytesExpectedToSend;</span><br><span class="line">    <span class="keyword">if</span>(totalUnitCount == NSURLSessionTransferSizeUnknown) &#123;</span><br><span class="line">        NSString *contentLength = [<span class="keyword">task</span>.originalRequest valueForHTTPHeaderField:@<span class="string">&quot;Content-Length&quot;</span>];</span><br><span class="line">        <span class="keyword">if</span>(contentLength) &#123;</span><br><span class="line">            totalUnitCount = (int64_t) [contentLength longLongValue];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:<span class="keyword">task</span>];</span><br><span class="line">    <span class="keyword">if</span> (delegate) &#123;</span><br><span class="line">        [delegate URLSession:session <span class="keyword">task</span>:<span class="keyword">task</span> didSendBodyData:bytesSent totalBytesSent:totalBytesSent totalBytesExpectedToSend:totalBytesExpectedToSend];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (self.taskDidSendBodyData) &#123;</span><br><span class="line">        self.taskDidSendBodyData(session, <span class="keyword">task</span>, bytesSent, totalBytesSent, totalUnitCount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在AFURLSessionManagerTaskDelegate中分别更新self.uploadProgress以及self.downloadProgress</p>
<figure class="highlight erlang"><table><tr><td class="code"><pre><span class="line">- <span class="params">(void)</span>URLSession:<span class="params">(NSURLSession *)</span>session task:<span class="params">(NSURLSessionTask *)</span>task</span><br><span class="line">   didSendBodyData:<span class="params">(int64_t)</span>bytesSent</span><br><span class="line">    totalBytesSent:<span class="params">(int64_t)</span>totalBytesSent</span><br><span class="line">totalBytesExpectedToSend:<span class="params">(int64_t)</span>totalBytesExpectedToSend&#123;</span><br><span class="line">    </span><br><span class="line">    self.uploadProgress.totalUnitCount = task.countOfBytesExpectedToSend;</span><br><span class="line">    self.uploadProgress.completedUnitCount = task.countOfBytesSent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- <span class="params">(void)</span>URLSession:<span class="params">(NSURLSession *)</span>session downloadTask:<span class="params">(NSURLSessionDownloadTask *)</span>downloadTask</span><br><span class="line">      didWriteData:<span class="params">(int64_t)</span>bytesWritten</span><br><span class="line"> totalBytesWritten:<span class="params">(int64_t)</span>totalBytesWritten</span><br><span class="line">totalBytesExpectedToWrite:<span class="params">(int64_t)</span>totalBytesExpectedToWrite&#123;</span><br><span class="line">    </span><br><span class="line">    self.downloadProgress.totalUnitCount = totalBytesExpectedToWrite;</span><br><span class="line">    self.downloadProgress.completedUnitCount = totalBytesWritten;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是我们并没看到进度数据的交付啊，这部分其实是在初始化AFURLSessionManagerTaskDelegate的时候利用KVO将进度数据与对应的Block的调用进行了关联：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)initWithTask:(<span class="built_in">NSURLSessionTask</span> *)task &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//.....    </span></span><br><span class="line">    _uploadProgress = [[<span class="built_in">NSProgress</span> alloc] initWithParent:<span class="literal">nil</span> userInfo:<span class="literal">nil</span>];</span><br><span class="line">    _downloadProgress = [[<span class="built_in">NSProgress</span> alloc] initWithParent:<span class="literal">nil</span> userInfo:<span class="literal">nil</span>];</span><br><span class="line">    __<span class="keyword">weak</span> __typeof__(task) weakTask = task;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSProgress</span> *progress <span class="keyword">in</span> @[ _uploadProgress, _downloadProgress ])&#123;</span><br><span class="line">        progress.totalUnitCount = <span class="built_in">NSURLSessionTransferSizeUnknown</span>;</span><br><span class="line">        progress.cancellable = <span class="literal">YES</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//.....</span></span><br><span class="line">        [progress addObserver:<span class="keyword">self</span></span><br><span class="line">                   forKeyPath:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(fractionCompleted))</span><br><span class="line">                      options:<span class="built_in">NSKeyValueObservingOptionNew</span></span><br><span class="line">                      context:<span class="literal">NULL</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在initWithTask中利用KVO监听progress 的 fractionCompleted。一旦有数据变动，都会触发KVO:</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)<span class="keyword">object</span> change:(NSDictionary&lt;NSString *,id&gt; *)change context:(<span class="keyword">void</span> *)context &#123;</span><br><span class="line">   <span class="keyword">if</span> ([<span class="keyword">object</span> isEqual:<span class="built_in">self</span>.downloadProgress]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">self</span>.downloadProgressBlock) &#123;</span><br><span class="line">            <span class="built_in">self</span>.<span class="title function_ invoke__">downloadProgressBlock</span>(<span class="keyword">object</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ([<span class="keyword">object</span> isEqual:<span class="built_in">self</span>.uploadProgress]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">self</span>.uploadProgressBlock) &#123;</span><br><span class="line">            <span class="built_in">self</span>.<span class="title function_ invoke__">uploadProgressBlock</span>(<span class="keyword">object</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在observeValueForKeyPath中调用对应的downloadProgressBlock以及uploadProgressBlock 进行数据交付。<br>扯个不是非常必要的一个问题：为什么需要<strong><strong>AFURLSessionManagerTaskDelegate</strong></strong>，<strong><strong>AFURLSessionManagerTaskDelegate</strong></strong><br>的职责是什么？直接说答案吧：AFURLSessionManagerTaskDelegate 主要处理与task相关的代理，因为不同的task有不同的进度，不同task完成数据接收的时刻也不同，AFURLSessionManagerTaskDelegate就是用来与task相关的代理。</p>
<ul>
<li><strong><strong>resume &amp;&amp; suspend 请求</strong></strong></li>
</ul>
<p>这部分主要在调用默认的resume以及suspend方法的时候增加<strong><strong>AFNSURLSessionTaskDidResumeNotification</strong></strong>， <strong><strong>AFNSURLSessionTaskDidSuspendNotification</strong></strong>的通知，实现方式是通过在load方法中替换resume以及suspand的实现，为自己的af_resume以及af_suspend，在这里添加对应的通知。那么为什么要添加这两个通知？我们在介绍任务创建的时候会调用setDelegate:forTask方法。在这里会调用****[self addNotificationObserverForTask:task]****</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setDelegate:(AFURLSessionManagerTaskDelegate *)<span class="built_in">delegate</span></span><br><span class="line">            forTask:(NSURLSessionTask *)task &#123;</span><br><span class="line">    [<span class="meta">self.lock lock</span>];</span><br><span class="line">    self.mutableTaskDelegatesKeyedByTaskIdentifier[@(task.taskIdentifier)] = <span class="built_in">delegate</span>;</span><br><span class="line">    [<span class="meta">self addNotificationObserverForTask:task</span>];</span><br><span class="line">    [<span class="meta">self.lock unlock</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在addNotificationObserverForTask方法中会让NSURLSessionTask监听<strong><strong>AFNSURLSessionTaskDidResumeNotification</strong></strong>，以及<strong><strong>AFNSURLSessionTaskDidSuspendNotification</strong></strong></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)addNotificationObserverForTask:(<span class="built_in">NSURLSessionTask</span> *)task &#123;</span><br><span class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(taskDidResume:) name:AFNSURLSessionTaskDidResumeNotification object:task];</span><br><span class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(taskDidSuspend:) name:AFNSURLSessionTaskDidSuspendNotification object:task];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在这里会将task通过通知传递出去，交给业务层进行处理：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)taskDidResume:(<span class="built_in">NSNotification</span> *)notification &#123;</span><br><span class="line">    <span class="built_in">NSURLSessionTask</span> *task = notification.object;</span><br><span class="line">    <span class="keyword">if</span> ([task respondsToSelector:<span class="keyword">@selector</span>(taskDescription)]) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([task.taskDescription isEqualToString:<span class="keyword">self</span>.taskDescriptionForSessionTasks]) &#123;</span><br><span class="line">            <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:AFNetworkingTaskDidResumeNotification object:task];</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)taskDidSuspend:(<span class="built_in">NSNotification</span> *)notification &#123;</span><br><span class="line">    <span class="built_in">NSURLSessionTask</span> *task = notification.object;</span><br><span class="line">    <span class="keyword">if</span> ([task respondsToSelector:<span class="keyword">@selector</span>(taskDescription)]) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([task.taskDescription isEqualToString:<span class="keyword">self</span>.taskDescriptionForSessionTasks]) &#123;</span><br><span class="line">            <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:AFNetworkingTaskDidSuspendNotification object:task];</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><strong>通过 AFSecurityPolicy 保证请求安全</strong></strong></li>
</ul>
<p>AFSecurityPolicy AFSecurityPolicy 作为 AFURLSessionManager一个主要的组件，主要用于验证 HTTPS 请求的证书是否有效。它有三种模式：</p>
<figure class="highlight elm"><table><tr><td class="code"><pre><span class="line">typedef <span class="type">NS_ENUM</span>(<span class="type">NSUInteger</span>, <span class="type">AFSSLPinningMode</span>) &#123;</span><br><span class="line">    <span class="type">AFSSLPinningModeNone</span>,</span><br><span class="line">    <span class="type">AFSSLPinningModePublicKey</span>,</span><br><span class="line">    <span class="type">AFSSLPinningModeCertificate</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">*</span> AFSSLPinningModeNone          不使用<span class="strong">****</span>pinned certificates<span class="strong">****</span>进行认证,只会在系统的信任的证书列表中对服务端返回的证书进行验证</span><br><span class="line"><span class="bullet">*</span> AFSSLPinningModeCertificate   需要客户端保存服务端的证书</span><br><span class="line"><span class="bullet">*</span> AFSSLPinningModePublicKey     也需要预先保存服务端发送的证书，但是这里只会验证证书中的公钥是否正确</span><br></pre></td></tr></table></figure>

<p>我们先来看下在AFURLSessionManager中什么时机使用AFSecurityPolicy,在发起某个请求的时候如果需要认证的时候会回调NSURLSession中的didReceiveChallenge方法，同样这里也会将该处理转发给AFURLSessionManager，下面是AFURLSessionManager对didReceiveChallenge的处理：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</span><br><span class="line">              task:(<span class="built_in">NSURLSessionTask</span> *)task</span><br><span class="line">didReceiveChallenge:(<span class="built_in">NSURLAuthenticationChallenge</span> *)challenge</span><br><span class="line"> completionHandler:(<span class="type">void</span> (^)(<span class="built_in">NSURLSessionAuthChallengeDisposition</span> disposition, <span class="built_in">NSURLCredential</span> *credential))completionHandler &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSURLSessionAuthChallengeDisposition</span> disposition = <span class="built_in">NSURLSessionAuthChallengePerformDefaultHandling</span>;</span><br><span class="line">    __block <span class="built_in">NSURLCredential</span> *credential = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里会将处理流程转到taskDidReceiveAuthenticationChallenge，通过业务层对认证进行处理，并返回disposition</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.taskDidReceiveAuthenticationChallenge) &#123;</span><br><span class="line">        disposition = <span class="keyword">self</span>.taskDidReceiveAuthenticationChallenge(session, task, challenge, &amp;credential);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果SecTrustRef validation 是必须对就走下面的流程：</span></span><br><span class="line">        <span class="keyword">if</span> ([challenge.protectionSpace.authenticationMethod isEqualToString:<span class="built_in">NSURLAuthenticationMethodServerTrust</span>]) &#123;</span><br><span class="line">            <span class="comment">//调用evaluateServerTrust方法进行处理</span></span><br><span class="line">            <span class="keyword">if</span> ([<span class="keyword">self</span>.securityPolicy evaluateServerTrust:challenge.protectionSpace.serverTrust forDomain:challenge.protectionSpace.host]) &#123;</span><br><span class="line">                <span class="comment">//如果认证成功生成disposition，credential</span></span><br><span class="line">                disposition = <span class="built_in">NSURLSessionAuthChallengeUseCredential</span>;</span><br><span class="line">                credential = [<span class="built_in">NSURLCredential</span> credentialForTrust:challenge.protectionSpace.serverTrust];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                disposition = <span class="built_in">NSURLSessionAuthChallengeCancelAuthenticationChallenge</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            disposition = <span class="built_in">NSURLSessionAuthChallengePerformDefaultHandling</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将生成的disposition，以及credential传递出去</span></span><br><span class="line">    <span class="keyword">if</span> (completionHandler) &#123;</span><br><span class="line">        completionHandler(disposition, credential);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以整个环节中最重要的就是evaluateServerTrust方法了，在看这个方法之前我们先看下AFSecurityPolicy是怎么初始化的：</p>
<p>如果我们没有人为指定证书文件，AFNetWorking 会使用<strong><strong>defaultPolicy</strong></strong></p>
<figure class="highlight elm"><table><tr><td class="code"><pre><span class="line">+ (instance<span class="keyword">type</span>)defaultPolicy &#123;</span><br><span class="line">    <span class="type">AFSecurityPolicy</span> *securityPolicy = [[self alloc] init];</span><br><span class="line">    securityPolicy.<span class="type">SSLPinningMode</span> = <span class="type">AFSSLPinningModeNone</span>;</span><br><span class="line">    return securityPolicy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>defaultPolicy实现十分简单，就是创建了一个AFSecurityPolicy对象后指定对应的SSLPinningMode为AFSSLPinningModeNone。</p>
<p>紧接着我们看下evaluateServerTrust这个方法，关键的地方已经加了注释，大家可以对照注释进行理解，这里就不再展开介绍了：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">BOOL</span>)evaluateServerTrust:(SecTrustRef)serverTrust</span><br><span class="line">                  forDomain:(<span class="built_in">NSString</span> *)domain &#123;</span><br><span class="line">    <span class="keyword">if</span> (domain &amp;&amp; <span class="keyword">self</span>.allowInvalidCertificates &amp;&amp; <span class="keyword">self</span>.validatesDomainName &amp;&amp; (<span class="keyword">self</span>.SSLPinningMode == AFSSLPinningModeNone || [<span class="keyword">self</span>.pinnedCertificates count] == <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="comment">// https://developer.apple.com/library/mac/documentation/NetworkingInternet/Conceptual/NetworkingTopics/Articles/OverridingSSLChainValidationCorrectly.html</span></span><br><span class="line">        <span class="comment">//  According to the docs, you should only trust your provided certs for evaluation.</span></span><br><span class="line">        <span class="comment">//  Pinned certificates are added to the trust. Without pinned certificates,</span></span><br><span class="line">        <span class="comment">//  there is nothing to evaluate against.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">//  From Apple Docs:</span></span><br><span class="line">        <span class="comment">//          &quot;Do not implicitly trust self-signed certificates as anchors (kSecTrustOptionImplicitAnchors).</span></span><br><span class="line">        <span class="comment">//           Instead, add your own (self-signed) CA certificate to the list of trusted anchors.&quot;</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;In order to validate a domain name for self signed certificates, you MUST use pinning.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSMutableArray</span> *policies = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.validatesDomainName) &#123;</span><br><span class="line">        <span class="comment">//需要验证域名的情况</span></span><br><span class="line">        <span class="comment">//返回用于验证SSL证书链的policy对象，当第一个参数传入的是true的时候会创建一个SSL服务端证书。</span></span><br><span class="line">        [policies addObject:(__bridge_transfer <span class="type">id</span>)SecPolicyCreateSSL(<span class="literal">true</span>, (__bridge <span class="built_in">CFStringRef</span>)domain)];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//不需要验证域名的情况</span></span><br><span class="line">        <span class="comment">//创建一个默认的X.509 policy</span></span><br><span class="line">        [policies addObject:(__bridge_transfer <span class="type">id</span>)SecPolicyCreateBasicX509()];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置验证serverTrust所需要的policies</span></span><br><span class="line">    SecTrustSetPolicies(serverTrust, (__bridge <span class="built_in">CFArrayRef</span>)policies);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里应该是进行系统认证[不确定]</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.SSLPinningMode == AFSSLPinningModeNone) &#123;</span><br><span class="line">        <span class="comment">//如果SSLPinningMode为AFSSLPinningModeNone如果允许无效的证书或者调用AFServerTrustIsValid返回YES的时候返回YES 表示认证通过</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.allowInvalidCertificates || AFServerTrustIsValid(serverTrust);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!AFServerTrustIsValid(serverTrust) &amp;&amp; !<span class="keyword">self</span>.allowInvalidCertificates) &#123;</span><br><span class="line">        <span class="comment">/*模式不是AFSSLPinningModeNone 不允许无效证书的情况下如果AFServerTrustIsValid返回NO 则返回NO，表示认证不通过*/</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (<span class="keyword">self</span>.SSLPinningMode) &#123;</span><br><span class="line">        <span class="keyword">case</span> AFSSLPinningModeNone:</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">        <span class="keyword">case</span> AFSSLPinningModeCertificate: &#123;</span><br><span class="line">            <span class="built_in">NSMutableArray</span> *pinnedCertificates = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">            <span class="comment">//使用self.pinnedCertificates通过SecCertificateCreateWithData方法创建证书数据</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">NSData</span> *certificateData <span class="keyword">in</span> <span class="keyword">self</span>.pinnedCertificates) &#123;</span><br><span class="line">                [pinnedCertificates addObject:(__bridge_transfer <span class="type">id</span>)SecCertificateCreateWithData(<span class="literal">NULL</span>, (__bridge <span class="built_in">CFDataRef</span>)certificateData)];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//使用 SecTrustSetAnchorCertificates 为serverTrust设置证书</span></span><br><span class="line">            SecTrustSetAnchorCertificates(serverTrust, (__bridge <span class="built_in">CFArrayRef</span>)pinnedCertificates);</span><br><span class="line">            <span class="comment">//使用证书认证</span></span><br><span class="line">            <span class="keyword">if</span> (!AFServerTrustIsValid(serverTrust)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//使用 AFCertificateTrustChainForServerTrust 获取serverTrust中的全部 DER 表示的证书</span></span><br><span class="line">            <span class="built_in">NSArray</span> *serverCertificates = AFCertificateTrustChainForServerTrust(serverTrust);</span><br><span class="line">            <span class="comment">//如果 pinnedCertificates 中有相同的证书，就会返回 YES</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">NSData</span> *trustChainCertificate <span class="keyword">in</span> [serverCertificates reverseObjectEnumerator]) &#123;</span><br><span class="line">                <span class="keyword">if</span> ([<span class="keyword">self</span>.pinnedCertificates containsObject:trustChainCertificate]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> AFSSLPinningModePublicKey: &#123;</span><br><span class="line">            <span class="built_in">NSUInteger</span> trustedPublicKeyCount = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//从serverTrust中获取公钥</span></span><br><span class="line">            <span class="built_in">NSArray</span> *publicKeys = AFPublicKeyTrustChainForServerTrust(serverTrust);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">id</span> trustChainPublicKey <span class="keyword">in</span> publicKeys) &#123;</span><br><span class="line">                <span class="comment">//pinnedPublicKeys 中的公钥包含serverTrust中的公钥的时候认证通过</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">id</span> pinnedPublicKey <span class="keyword">in</span> <span class="keyword">self</span>.pinnedPublicKeys) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (AFSecKeyIsEqualToKey((__bridge SecKeyRef)trustChainPublicKey, (__bridge SecKeyRef)pinnedPublicKey)) &#123;</span><br><span class="line">                        trustedPublicKeyCount += <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> trustedPublicKeyCount &gt; <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那如果我们需要添加证书文件要怎么实现呢？下面是一个例子供大家参考</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)setSecurityPolicyWithCerPath:(<span class="built_in">NSString</span> *)cerPath validatesDomainName:(<span class="type">BOOL</span>)validatesDomainName &#123;</span><br><span class="line">    <span class="built_in">NSData</span> *cerData = [<span class="built_in">NSData</span> dataWithContentsOfFile:cerPath];</span><br><span class="line">    <span class="comment">// 使用证书验证模式</span></span><br><span class="line">    AFSecurityPolicy *securityPolicy = [AFSecurityPolicy policyWithPinningMode:AFSSLPinningModeCertificate];</span><br><span class="line">    <span class="comment">// 如果需要验证自建证书(无效证书)，需要设置为YES</span></span><br><span class="line">    securityPolicy.allowInvalidCertificates = <span class="literal">YES</span>;</span><br><span class="line">    <span class="comment">// 是否需要验证域名，默认为YES;</span></span><br><span class="line">    securityPolicy.validatesDomainName = validatesDomainName;</span><br><span class="line">    securityPolicy.pinnedCertificates = [[<span class="built_in">NSSet</span> alloc] initWithObjects:cerData, <span class="literal">nil</span>];</span><br><span class="line">    [<span class="keyword">self</span> setSecurityPolicy:securityPolicy];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><strong>通过AFNetworkReachabilityManager 监控网络状态</strong></strong></li>
</ul>
<p>一般我们应用都会有个应用场景：在网络断开或者异常的时候，显示重试页面，当网络恢复的时候自动调用数据获取接口，恢复正常界面。这个功能就可以通过AFNetworkReachabilityManager来实现了。</p>
<ul>
<li>AFNetworkReachabilityManager实例的创建：</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">+ (<span class="keyword">instancetype</span>)sharedManager &#123;</span><br><span class="line">    <span class="keyword">static</span> AFNetworkReachabilityManager *_sharedManager = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        _sharedManager = [<span class="keyword">self</span> manager];</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> _sharedManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不解释，嗯！</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)startMonitoring &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//开始监听之前先取消之前的监听，重新开始网络监听</span></span><br><span class="line">    [<span class="keyword">self</span> stopMonitoring];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果没有设置networkReachability 直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>.networkReachability) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//网络状态变更的时候传递出去的Block</span></span><br><span class="line">    __<span class="keyword">weak</span> __<span class="keyword">typeof</span>(<span class="keyword">self</span>)weakSelf = <span class="keyword">self</span>;</span><br><span class="line">    AFNetworkReachabilityStatusBlock callback = ^(AFNetworkReachabilityStatus status) &#123;</span><br><span class="line">        __<span class="keyword">strong</span> __<span class="keyword">typeof</span>(weakSelf)strongSelf = weakSelf;</span><br><span class="line">        strongSelf.networkReachabilityStatus = status;</span><br><span class="line">        <span class="keyword">if</span> (strongSelf.networkReachabilityStatusBlock) &#123;</span><br><span class="line">            strongSelf.networkReachabilityStatusBlock(status);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建SCNetworkReachabilityContext，这里最关键是callback，而AFNetworkReachabilityRetainCallback，AFNetworkReachabilityReleaseCallback是用于管理AFNetworkReachabilityStatusBlock内存的回调。</span></span><br><span class="line">    <span class="built_in">SCNetworkReachabilityContext</span> context = &#123;<span class="number">0</span>, (__bridge <span class="type">void</span> *)callback, AFNetworkReachabilityRetainCallback, AFNetworkReachabilityReleaseCallback, <span class="literal">NULL</span>&#125;;</span><br><span class="line">    <span class="built_in">SCNetworkReachabilitySetCallback</span>(<span class="keyword">self</span>.networkReachability, AFNetworkReachabilityCallback, &amp;context);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在 Main Runloop 中对应的模式开启监控网络状态</span></span><br><span class="line">    <span class="built_in">SCNetworkReachabilityScheduleWithRunLoop</span>(<span class="keyword">self</span>.networkReachability, <span class="built_in">CFRunLoopGetMain</span>(), kCFRunLoopCommonModes);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, <span class="number">0</span>),^&#123;</span><br><span class="line">        <span class="built_in">SCNetworkReachabilityFlags</span> flags;</span><br><span class="line">        <span class="comment">//获取当前的网络状态</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">SCNetworkReachabilityGetFlags</span>(<span class="keyword">self</span>.networkReachability, &amp;flags)) &#123;</span><br><span class="line">            AFPostReachabilityStatusChange(flags, callback);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上述设置后，每次网络状态改变就会调用 AFNetworkReachabilityCallback 函数，在这里会调用AFPostReachabilityStatusChange抛出状态改变的通知：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">static void <span class="constructor">AFNetworkReachabilityCallback(SCNetworkReachabilityRef <span class="params">__unused</span> <span class="params">target</span>, SCNetworkReachabilityFlags <span class="params">flags</span>, <span class="params">void</span> <span class="operator">*</span><span class="params">info</span>)</span> &#123;</span><br><span class="line">    <span class="constructor">AFPostReachabilityStatusChange(<span class="params">flags</span>, (<span class="params">__bridge</span> AFNetworkReachabilityStatusBlock)</span>info);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们知道状态抛出是通过开启监听之前设置的AFNetworkReachabilityStatusBlock 类型的callback block 传递到业务层的。</p>
<figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">static void AFPostReachabilityStatusChange(SCNetworkReachabilityFlags <span class="keyword">flags</span>, AFNetworkReachabilityStatusBlock <span class="built_in">block</span>) &#123;</span><br><span class="line">    AFNetworkReachabilityStatus status = AFNetworkReachabilityStatusForFlags(<span class="keyword">flags</span>);</span><br><span class="line">    dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        if (<span class="built_in">block</span>) &#123;</span><br><span class="line">            <span class="built_in">block</span>(status);</span><br><span class="line">        &#125;</span><br><span class="line">        NSNotificationCenter *notificationCenter = [NSNotificationCenter <span class="keyword">default</span>Center];</span><br><span class="line">        NSDictionary *<span class="keyword">user</span>Info = @&#123; AFNetworkingReachabilityNotificationStatusItem: @(status) &#125;;</span><br><span class="line">        [notificationCenter postNotificationName:AFNetworkingReachabilityDidChangeNotification object:nil <span class="keyword">user</span>Info:<span class="keyword">user</span>Info];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AFPostReachabilityStatusChange会先通过AFNetworkReachabilityStatusForFlags从SCNetworkReachabilityFlags中提取对应的标志生成AFNetworkReachabilityStatus对象，在使用AFNetworkReachabilityStatusBlock传递出去，同时通过AFNetworkingReachabilityDidChangeNotification广播通知其他部件。</p>
<p>上述的flag是一个kSCNetworkReachabilityFlagsReachable类型，不同的位代表不同的状态。</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">static</span> AFNetworkReachabilityStatus AFNetworkReachabilityStatusForFlags(SCNetworkReachabilityFlags flags) &#123;</span><br><span class="line">    <span class="attribute">BOOL</span> isReachable = ((flags &amp; kSCNetworkReachabilityFlagsReachable) != <span class="number">0</span>);</span><br><span class="line">    <span class="attribute">BOOL</span> needsConnection = ((flags &amp; kSCNetworkReachabilityFlagsConnectionRequired) != <span class="number">0</span>);</span><br><span class="line">    <span class="attribute">BOOL</span> canConnectionAutomatically = (((flags &amp; kSCNetworkReachabilityFlagsConnectionOnDemand ) != <span class="number">0</span>) || ((flags &amp; kSCNetworkReachabilityFlagsConnectionOnTraffic) != <span class="number">0</span>));</span><br><span class="line">    <span class="attribute">BOOL</span> canConnectWithoutUserInteraction = (canConnectionAutomatically &amp;&amp; (flags &amp; kSCNetworkReachabilityFlagsInterventionRequired) == <span class="number">0</span>);</span><br><span class="line">    <span class="attribute">BOOL</span> isNetworkReachable = (isReachable &amp;&amp; (!needsConnection || canConnectWithoutUserInteraction));</span><br><span class="line"></span><br><span class="line">    <span class="attribute">AFNetworkReachabilityStatus</span> status = AFNetworkReachabilityStatusUnknown;</span><br><span class="line">    <span class="attribute">if</span> (isNetworkReachable == NO) &#123;</span><br><span class="line">        <span class="attribute">status</span> = AFNetworkReachabilityStatusNotReachable;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">#if	TARGET_OS_IPHONE</span></span><br><span class="line">    <span class="attribute">else</span> if ((flags &amp; kSCNetworkReachabilityFlagsIsWWAN) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="attribute">status</span> = AFNetworkReachabilityStatusReachableViaWWAN;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">    <span class="section">else</span> &#123;</span><br><span class="line">        <span class="attribute">status</span> = AFNetworkReachabilityStatusReachableViaWiFi;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好了好了，说好不熬夜的又2点了，不早了就这样吧。……(^_^)v</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/iOS-%E5%BC%80%E6%BA%90%E5%BA%93%E5%88%86%E6%9E%90/">iOS 开源库分析</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/iOS-开源库分析/">iOS 开源库分析</a>
  </div>

</div>



<div class="comments-count">
	
	  	<span></span>
		<a href="/2019/11/30/AFNetWorking源码解析/#comments" class="ds-thread-count comments-count-link" data-thread-key="2019/11/30/AFNetWorking源码解析/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>







  <nav id="page-nav" class="clearfix">
    <a class="extend prev" rel="prev" href="/page/2/">&lt;span&gt;&lt;&#x2F;span&gt;Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/30/">30</a><a class="extend next" rel="next" href="/page/4/">Next&lt;span&gt;&lt;&#x2F;span&gt;</a>
  </nav>

</div>
      <div class="openaside"><a class="navbutton" href="#" title="Show Sidebar"></a></div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="Hide Sidebar"></a></div>
<aside class="clearfix">
<div id="authorInfo">
	
		<div class="author-img"></div>		
	
	<div class="social-info" class="clearfix">
		
		
		<a href="https://github.com/tbfungeek" target="_blank" class="icon-github" title="github"></a>
		
		
		
		
		
		
		
		
		
		
		<a href="mailto:tbfungeek@163.com" target="_blank" class="icon-email" title="Email Me"></a>
		

	</div>
</div>

  
<div class="categorieslist">
	<p class="asidetitle">Categories</p>
		<ul>
		
		  
			<li><a href="/categories/Android-小经验/" title="Android 小经验">Android 小经验<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Android-源码分析/" title="Android 源码分析">Android 源码分析<sup>21</sup></a></li>
		  
		
		  
			<li><a href="/categories/Android其他/" title="Android其他">Android其他<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Android初步/" title="Android初步">Android初步<sup>21</sup></a></li>
		  
		
		  
			<li><a href="/categories/Android进阶/" title="Android进阶">Android进阶<sup>100</sup></a></li>
		  
		
		  
			<li><a href="/categories/Hexo-使用/" title="Hexo 使用">Hexo 使用<sup>10</sup></a></li>
		  
		
		  
			<li><a href="/categories/JavaScript理论/" title="JavaScript理论">JavaScript理论<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Objective-C-相关/" title="Objective C 相关">Objective C 相关<sup>24</sup></a></li>
		  
		
		  
			<li><a href="/categories/OpenCV/" title="OpenCV">OpenCV<sup>6</sup></a></li>
		  
		
		  
			<li><a href="/categories/ROS/" title="ROS">ROS<sup>9</sup></a></li>
		  
		
		  
			<li><a href="/categories/iOS-工具使用/" title="iOS 工具使用">iOS 工具使用<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/iOS-开源库分析/" title="iOS 开源库分析">iOS 开源库分析<sup>36</sup></a></li>
		  
		
		  
			<li><a href="/categories/iOS-理论基础/" title="iOS 理论基础">iOS 理论基础<sup>14</sup></a></li>
		  
		
		  
			<li><a href="/categories/iOS-进阶/" title="iOS 进阶">iOS 进阶<sup>4</sup></a></li>
		  
		
		  
			<li><a href="/categories/个人收藏/" title="个人收藏">个人收藏<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/代码规范/" title="代码规范">代码规范<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/其他/" title="其他">其他<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/博客分类目录/" title="博客分类目录">博客分类目录<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/叨叨系列/" title="叨叨系列">叨叨系列<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/开源代码分析/" title="开源代码分析">开源代码分析<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/开源库分析/" title="开源库分析">开源库分析<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/树莓派/" title="树莓派">树莓派<sup>4</sup></a></li>
		  
		
		  
			<li><a href="/categories/版本控制/" title="版本控制">版本控制<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/直播/" title="直播">直播<sup>6</sup></a></li>
		  
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">Tags</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/iOS-开源库分析/" title="iOS 开源库分析">iOS 开源库分析<sup>36</sup></a></li>
			
		
			
				<li><a href="/tags/Android-设计模式/" title="Android 设计模式">Android 设计模式<sup>29</sup></a></li>
			
		
			
				<li><a href="/tags/Objective-C-相关/" title="Objective C 相关">Objective C 相关<sup>24</sup></a></li>
			
		
			
				<li><a href="/tags/Android基础/" title="Android基础">Android基础<sup>21</sup></a></li>
			
		
			
				<li><a href="/tags/AOSP-源码/" title="AOSP 源码">AOSP 源码<sup>17</sup></a></li>
			
		
			
				<li><a href="/tags/Android-常用第三方库/" title="Android 常用第三方库">Android 常用第三方库<sup>15</sup></a></li>
			
		
			
				<li><a href="/tags/iOS-理论基础/" title="iOS 理论基础">iOS 理论基础<sup>14</sup></a></li>
			
		
			
				<li><a href="/tags/Hexo-使用/" title="Hexo 使用">Hexo 使用<sup>10</sup></a></li>
			
		
			
				<li><a href="/tags/ROS/" title="ROS">ROS<sup>9</sup></a></li>
			
		
			
				<li><a href="/tags/Android-动画进阶/" title="Android 动画进阶">Android 动画进阶<sup>8</sup></a></li>
			
		
			
				<li><a href="/tags/Android-JNI/" title="Android JNI">Android JNI<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/Android-绘图进阶/" title="Android 绘图进阶">Android 绘图进阶<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/Android性能优化/" title="Android性能优化">Android性能优化<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/Android-自动化测试/" title="Android 自动化测试">Android 自动化测试<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/OpenCV/" title="OpenCV">OpenCV<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/直播/" title="直播">直播<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/Android-开源源码/" title="Android 开源源码">Android 开源源码<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/Android-自定义View进阶/" title="Android 自定义View进阶">Android 自定义View进阶<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/树莓派/" title="树莓派">树莓派<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/iOS-进阶/" title="iOS 进阶">iOS 进阶<sup>4</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">Links</p>
    <ul>
        
          <li>
            
            	<a href="https://hexo.io" target="_blank" title="Hexo">Hexo</a>
            
          </li>
        
          <li>
            
            	<a href="https://pages.github.com/" target="_blank" title="GitHub">GitHub</a>
            
          </li>
        
          <li>
            
            	<a href="http://pf18.github.io/" target="_blank" title="PF18">PF18</a>
            
          </li>
        
          <li>
            
            	<a href="http://toutiao.io/" target="_blank" title="开发者头条">开发者头条</a>
            
          </li>
        
          <li>
            
            	<a href="http://www.jcodecraeer.com/" target="_blank" title="泡在网上的日子">泡在网上的日子</a>
            
          </li>
        
    </ul>
</div>

  


  <div class="rsspart">
	<a href="atom.xml" target="_blank" title="rss">RSS</a>
</div>

  
  <div class="tagcloudlist">
    <p class="asidetitle">Tag Cloud</p>
    <div class="tagcloudlist clearfix">
       <a href="/tags/AOSP-%E6%BA%90%E7%A0%81/" style="font-size: 17.14px;">AOSP 源码</a> <a href="/tags/Android-APK-%E7%AD%BE%E5%90%8D/" style="font-size: 10px;">Android APK 签名</a> <a href="/tags/Android-JNI/" style="font-size: 12.86px;">Android JNI</a> <a href="/tags/Android-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E8%BF%9B%E9%98%B6/" style="font-size: 10.71px;">Android 事件处理进阶</a> <a href="/tags/Android-%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6/" style="font-size: 13.57px;">Android 动画进阶</a> <a href="/tags/Android-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%80%E5%8F%91/" style="font-size: 10px;">Android 多线程开发</a> <a href="/tags/Android-%E5%B0%8F%E7%BB%8F%E9%AA%8C/" style="font-size: 10px;">Android 小经验</a> <a href="/tags/Android-%E5%B8%B8%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/" style="font-size: 16.43px;">Android 常用第三方库</a> <a href="/tags/Android-%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/" style="font-size: 10px;">Android 开发流程</a> <a href="/tags/Android-%E5%BC%80%E6%BA%90%E6%BA%90%E7%A0%81/" style="font-size: 12.14px;">Android 开源源码</a> <a href="/tags/Android-%E7%BB%98%E5%9B%BE%E8%BF%9B%E9%98%B6/" style="font-size: 12.86px;">Android 绘图进阶</a> <a href="/tags/Android-%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/" style="font-size: 12.86px;">Android 自动化测试</a> <a href="/tags/Android-%E8%87%AA%E5%AE%9A%E4%B9%89View%E8%BF%9B%E9%98%B6/" style="font-size: 12.14px;">Android 自定义View进阶</a> <a href="/tags/Android-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 19.29px;">Android 设计模式</a> <a href="/tags/Android%E5%85%B6%E4%BB%96/" style="font-size: 10px;">Android其他</a> <a href="/tags/Android%E5%9F%BA%E7%A1%80/" style="font-size: 17.86px;">Android基础</a> <a href="/tags/Android%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/" style="font-size: 10px;">Android开发流程</a> <a href="/tags/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" style="font-size: 12.86px;">Android性能优化</a> <a href="/tags/Android%E6%B7%B7%E6%B7%86%E6%8A%80%E6%9C%AF/" style="font-size: 10px;">Android混淆技术</a> <a href="/tags/Android%E8%B4%A8%E9%87%8F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/" style="font-size: 11.43px;">Android质量管理工具</a> <a href="/tags/Android%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/" style="font-size: 10px;">Android逆向工程</a> <a href="/tags/Git-github/" style="font-size: 10px;">Git && github</a> <a href="/tags/Hexo-%E4%BD%BF%E7%94%A8/" style="font-size: 15px;">Hexo 使用</a> <a href="/tags/JavaScript/" style="font-size: 10px;">JavaScript</a> <a href="/tags/Linux-%E4%BD%BF%E7%94%A8/" style="font-size: 10px;">Linux 使用</a> <a href="/tags/Objective-C-%E7%9B%B8%E5%85%B3/" style="font-size: 18.57px;">Objective C 相关</a> <a href="/tags/OpenCV/" style="font-size: 12.86px;">OpenCV</a> <a href="/tags/ROS/" style="font-size: 14.29px;">ROS</a> <a href="/tags/iOS-%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/" style="font-size: 10.71px;">iOS 工具使用</a> <a href="/tags/iOS-%E5%BC%80%E6%BA%90%E5%BA%93%E5%88%86%E6%9E%90/" style="font-size: 20px;">iOS 开源库分析</a> <a href="/tags/iOS-%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/" style="font-size: 15.71px;">iOS 理论基础</a> <a href="/tags/iOS-%E8%BF%9B%E9%98%B6/" style="font-size: 12.14px;">iOS 进阶</a> <a href="/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/" style="font-size: 10px;">代码规范</a> <a href="/tags/%E5%8D%9A%E5%AE%A2%E5%88%86%E7%B1%BB%E7%9B%AE%E5%BD%95/" style="font-size: 10.71px;">博客分类目录</a> <a href="/tags/%E5%8F%A8%E5%8F%A8%E7%B3%BB%E5%88%97/" style="font-size: 10px;">叨叨系列</a> <a href="/tags/%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/" style="font-size: 11.43px;">工具的使用</a> <a href="/tags/%E5%BC%80%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/" style="font-size: 10.71px;">开源代码分析</a> <a href="/tags/%E5%BC%80%E6%BA%90%E5%BA%93%E5%88%86%E6%9E%90/" style="font-size: 10px;">开源库分析</a> <a href="/tags/%E6%9D%82%E7%B1%BB/" style="font-size: 10px;">杂类</a> <a href="/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/" style="font-size: 12.14px;">树莓派</a> <a href="/tags/%E7%9B%B4%E6%92%AD/" style="font-size: 12.86px;">直播</a> <a href="/tags/%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/" style="font-size: 10.71px;">编程技巧</a> <a href="/tags/%E7%BD%91%E7%AB%99%E6%94%B6%E8%97%8F/" style="font-size: 10px;">网站收藏</a> <a href="/tags/%E9%87%8D%E8%A6%81%E6%8E%A7%E4%BB%B6/" style="font-size: 11.43px;">重要控件</a>
    </div>
  </div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
		
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/hsihohuang/kiddochan" target="_blank" title="Kiddochan">Kiddochan</a> © 2022 
		
		<a href="/about" target="_blank" title="Edgar">Edgar</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
        
    }
  });
});
</script>










<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?7c9443b0374f1cf6b1dbb5ab84d939cb";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="Back to Top"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
 </html>
