
 <!DOCTYPE HTML>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
  
    <title>Edgar&#39;s Blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="Edgar">
    

    
    <meta name="description" content="Android | 全栈工程师">
<meta property="og:type" content="website">
<meta property="og:title" content="Edgar&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/page/6/index.html">
<meta property="og:site_name" content="Edgar&#39;s Blog">
<meta property="og:description" content="Android | 全栈工程师">
<meta property="og:locale">
<meta property="article:author" content="Edgar">
<meta name="twitter:card" content="summary">

    
    <link rel="alternative" href="atom.xml" title="Edgar&#39;s Blog" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/unnamed4_n_mSY_icon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/profile.png">
    <link rel="apple-touch-icon-precomposed" href="/img/profile.png">
    
    
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 6.2.0"></head>

  <body>
    <header>
      
<div>
		
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="Edgar&#39;s Blog">Edgar&#39;s Blog</a></h1>
				<h2 class="blog-motto"></h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="Menu">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
					<li>
 					
					<form class="search" action="/search/index.html" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" autocomplete="off" name="q" maxlength="20" placeholder="Search" />
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main">

   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/10/23/iOS-基于JLRoute-改造的路由/" title="iOS 基于JLRoute 改造的路由" itemprop="url">iOS 基于JLRoute 改造的路由</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Edgar" target="_blank" itemprop="author">Edgar</a>
		
  <p class="article-time">
    <time datetime="2019-10-23T09:29:47.000Z" itemprop="datePublished"> Published 2019-10-23</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p><img src="/2019/10/23/iOS-%E5%9F%BA%E4%BA%8EJLRoute-%E6%94%B9%E9%80%A0%E7%9A%84%E8%B7%AF%E7%94%B1/001.png"></p>
<h4 id="iOS路由汇总"><a href="#iOS路由汇总" class="headerlink" title="iOS路由汇总"></a>iOS路由汇总</h4><p><a target="_blank" rel="noopener" href="https://github.com/joeldev/JLRoutes">JLRoutes 5029 star</a><br><a target="_blank" rel="noopener" href="https://github.com/casatwy/CTMediator">CTMediator 2638 star</a><br><a target="_blank" rel="noopener" href="https://github.com/meili/MGJRouter">MGJRouter 1946 star</a><br><a target="_blank" rel="noopener" href="https://github.com/clayallsopp/routable-ios">routable-ios 1773 star</a><br><a target="_blank" rel="noopener" href="https://github.com/button/DeepLinkKit">DeepLinkKit 3236 star</a><br><a target="_blank" rel="noopener" href="https://github.com/aaronbrethorst/ABRouter">ABRouter 136 star</a><br><a target="_blank" rel="noopener" href="https://github.com/lightory/HHRouter">HHRouter 1574 star</a><br><a target="_blank" rel="noopener" href="https://github.com/imlifengfeng/FFRouter">FFRouter 157 star</a><br><a target="_blank" rel="noopener" href="https://github.com/chenxiancai/STCRouter">STCRouter 19 star</a></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>



<div class="comments-count">
	
	  	<span></span>
		<a href="/2019/10/23/iOS-基于JLRoute-改造的路由/#comments" class="ds-thread-count comments-count-link" data-thread-key="2019/10/23/iOS-基于JLRoute-改造的路由/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/10/22/JRLRoute-源码解析/" title="JLRoutes 源码解析" itemprop="url">JLRoutes 源码解析</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Edgar" target="_blank" itemprop="author">Edgar</a>
		
  <p class="article-time">
    <time datetime="2019-10-22T09:24:47.000Z" itemprop="datePublished"> Published 2019-10-22</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h5 id="开源库信息"><a href="#开源库信息" class="headerlink" title="开源库信息"></a>开源库信息</h5><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/joeldev/JLRoutes">JLRoutes地址</a></li>
</ul>
<p>之前有写了一篇博客《iOS 基于JLRoutes 改造的路由》那时候比较忙所以只是简单地画了一个大致的框图，这段时间有时间所以抽空再写一篇针对JRLRoute源码解析的文章。<br>JLRoute代码量不大，建议大家可以跟着这篇博客简单过下整个代码：</p>
<h5 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h5><p>在对源码进行分析之前需要先了解下JLRoutes的大致结构，JLRoutes通过sheme将整个路由空间分隔开，每个sheme相当于一个命名空间，每个sheme对应一个JLRoutes，每个JLRoutes有一个属性mutableRoutes 用于存放它所能匹配的JLRRouteDefinition。每个JLRRouteDefinition针对一个路由匹配规则，负责路由的匹配。每个路由匹配都被封装为JLRRouteRequest，交给JLRRouteDefinition进行匹配，JLRRouteDefinition会针对该request 输出一个匹配结果JLRRouteResponse。里面包含了是否匹配的信息。大体就是这么一个流程。</p>
<p>我们下面将针对上面介绍的结构一步一步进行介绍：</p>
<p><strong><strong>通过sheme分隔路由空间</strong></strong></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">+ (<span class="keyword">instancetype</span>)routesForScheme:(<span class="built_in">NSString</span> *)scheme &#123;</span><br><span class="line">    JLRoutes *routesController = <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        JLRGlobal_routeControllersMap = [[<span class="built_in">NSMutableDictionary</span> alloc] init];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//如果之前没有注册当前scheme，则创建JLRoutes</span></span><br><span class="line">    <span class="keyword">if</span> (!JLRGlobal_routeControllersMap[scheme]) &#123;</span><br><span class="line">        routesController = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">        routesController.scheme = scheme;</span><br><span class="line">        JLRGlobal_routeControllersMap[scheme] = routesController;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> JLRGlobal_routeControllersMap[scheme];;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">instancetype</span>)globalRoutes &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> routesForScheme:JLRoutesGlobalRoutesScheme];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个路由都要被添加到指定的scheme空间，存储在JLRGlobal_routeControllersMap中，JLRGlobal_routeControllersMap是一个字典类型，key为scheme，value为指定的JLRoutes。默认的情况下JLRoutes帮我们提供了一个全局的命名空间globalRoutes。</p>
<p><strong><strong>注册指定的路由匹配规则</strong></strong></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)addRoute:(<span class="built_in">NSString</span> *)routePattern handler:(<span class="type">BOOL</span> (^)(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="type">id</span>&gt; *parameters))handlerBlock &#123;</span><br><span class="line">    [<span class="keyword">self</span> addRoute:routePattern priority:<span class="number">0</span> handler:handlerBlock];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)addRoute:(<span class="built_in">NSString</span> *)routePattern priority:(<span class="built_in">NSUInteger</span>)priority handler:(<span class="type">BOOL</span> (^)(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="type">id</span>&gt; *parameters))handlerBlock &#123;</span><br><span class="line">    <span class="comment">//从路由模式中匹配可选的路由模式</span></span><br><span class="line">    <span class="built_in">NSArray</span> &lt;<span class="built_in">NSString</span> *&gt; *optionalRoutePatterns = [JLRParsingUtilities expandOptionalRoutePatternsForPattern:routePattern];</span><br><span class="line">    JLRRouteDefinition *route = [[JLRGlobal_routeDefinitionClass alloc] initWithPattern:routePattern priority:priority handlerBlock:handlerBlock];</span><br><span class="line">    <span class="keyword">if</span> (optionalRoutePatterns.count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// there are optional params, parse and add them</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSString</span> *pattern <span class="keyword">in</span> optionalRoutePatterns) &#123;</span><br><span class="line">            JLRRouteDefinition *optionalRoute = [[JLRGlobal_routeDefinitionClass alloc] initWithPattern:pattern priority:priority handlerBlock:handlerBlock];</span><br><span class="line">            [<span class="keyword">self</span> _registerRoute:optionalRoute];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="keyword">self</span> _registerRoute:route];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们以****&#x2F;path&#x2F;:thing&#x2F;(&#x2F;a)(&#x2F;b)(&#x2F;c)**** 为例子，这里有固定path <strong><strong>&#x2F;path&#x2F;</strong></strong> 带参数的path <strong>**&#x2F;:thing&#x2F;<strong>*<em>，可选的path <strong>**&#x2F;(&#x2F;a)(&#x2F;b)(&#x2F;c)<strong><strong>。首先我们会通过</strong></strong>expandOptionalRoutePatternsForPattern**</strong> 将可选的部分转换成固定的或者带参数的path。比如上面的</em>*</strong>&#x2F;path&#x2F;:thing&#x2F;(&#x2F;a)(&#x2F;b)(&#x2F;c)**</strong> 会转换为如下几种：</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line">/path/<span class="symbol">:thing/a/b/c</span></span><br><span class="line">/path/<span class="symbol">:thing/a/b</span></span><br><span class="line">/path/<span class="symbol">:thing/a/c</span></span><br><span class="line">/path/<span class="symbol">:thing/b/a</span></span><br><span class="line">/path/<span class="symbol">:thing/a</span></span><br><span class="line">/path/<span class="symbol">:thing/b</span></span><br><span class="line">/path/<span class="symbol">:thing/c</span></span><br></pre></td></tr></table></figure>
<p>然后再通过_registerRoute注册上面的routePattern。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)_registerRoute:(JLRRouteDefinition *)route &#123;</span><br><span class="line">    <span class="comment">//如果是最高优先级或者之前都没注册过就直接添加</span></span><br><span class="line">    <span class="keyword">if</span> (route.priority == <span class="number">0</span> || <span class="keyword">self</span>.mutableRoutes.count == <span class="number">0</span>) &#123;</span><br><span class="line">        [<span class="keyword">self</span>.mutableRoutes addObject:route];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">NSUInteger</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="type">BOOL</span> addedRoute = <span class="literal">NO</span>;</span><br><span class="line">        <span class="comment">// 按照优先级进行排序</span></span><br><span class="line">        <span class="comment">// search through existing routes looking for a lower priority route than this one</span></span><br><span class="line">        <span class="keyword">for</span> (JLRRouteDefinition *existingRoute <span class="keyword">in</span> [<span class="keyword">self</span>.mutableRoutes <span class="keyword">copy</span>]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (existingRoute.priority &lt; route.priority) &#123;</span><br><span class="line">                <span class="comment">// if found, add the route after it</span></span><br><span class="line">                [<span class="keyword">self</span>.mutableRoutes insertObject:route atIndex:index];</span><br><span class="line">                addedRoute = <span class="literal">YES</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果没有找到则直接插在最后</span></span><br><span class="line">        <span class="comment">// if we weren&#x27;t able to find a lower priority route, this is the new lowest priority route (or same priority as self.routes.lastObject) and should just be added</span></span><br><span class="line">        <span class="keyword">if</span> (!addedRoute) &#123;</span><br><span class="line">            [<span class="keyword">self</span>.mutableRoutes addObject:route];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    [route didBecomeRegisteredForScheme:<span class="keyword">self</span>.scheme];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所有的routePattern 都会被封装到JLRRouteDefinition 然后按照优先级添加到mutableRoutes中。</p>
<p><strong><strong>路由匹配</strong></strong></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">BOOL</span>)routeURL:(<span class="built_in">NSURL</span> *)URL withParameters:(<span class="built_in">NSDictionary</span> *)parameters &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> _routeURL:URL withParameters:parameters executeRouteBlock:<span class="literal">YES</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">BOOL</span>)_routeURL:(<span class="built_in">NSURL</span> *)URL withParameters:(<span class="built_in">NSDictionary</span> *)parameters executeRouteBlock:(<span class="type">BOOL</span>)executeRouteBlock &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line"></span><br><span class="line">    <span class="type">BOOL</span> didRoute = <span class="literal">NO</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//路由选项</span></span><br><span class="line">    JLRRouteRequestOptions options = [<span class="keyword">self</span> _routeRequestOptions];</span><br><span class="line">    <span class="comment">//构建路由请求</span></span><br><span class="line">    JLRRouteRequest *request = [[JLRRouteRequest alloc] initWithURL:URL options:options additionalParameters:parameters];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (JLRRouteDefinition *route <span class="keyword">in</span> [<span class="keyword">self</span>.mutableRoutes <span class="keyword">copy</span>]) &#123;</span><br><span class="line">        <span class="comment">// check each route for a matching response</span></span><br><span class="line">        <span class="comment">// 通过请求返回一个内部匹配的结果</span></span><br><span class="line">        JLRRouteResponse *response = [route routeResponseForRequest:request];</span><br><span class="line">        <span class="comment">//不匹配继续</span></span><br><span class="line">        <span class="keyword">if</span> (!response.isMatch) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//匹配了但是强制不执行直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (!executeRouteBlock) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//调用路由block传入参数，进行处理</span></span><br><span class="line">        didRoute = [route callHandlerBlockWithParameters:response.parameters];</span><br><span class="line">        <span class="keyword">if</span> (didRoute) &#123;</span><br><span class="line">            <span class="comment">//已经处理退出循环</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//没有匹配</span></span><br><span class="line">    <span class="keyword">if</span> (!didRoute) &#123;</span><br><span class="line">        [<span class="keyword">self</span> _verboseLog:<span class="string">@&quot;Could not find a matching route&quot;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果没有找到匹配的，并且允许转到Globle路由则调用全局路由</span></span><br><span class="line">    <span class="keyword">if</span> (!didRoute &amp;&amp; <span class="keyword">self</span>.shouldFallbackToGlobalRoutes &amp;&amp; ![<span class="keyword">self</span> _isGlobalRoutesController]) &#123;</span><br><span class="line">        didRoute = [[JLRoutes globalRoutes] _routeURL:URL withParameters:parameters executeRouteBlock:executeRouteBlock];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果没有则调用unmatchedURLHandler</span></span><br><span class="line">    <span class="keyword">if</span> (!didRoute &amp;&amp; executeRouteBlock &amp;&amp; <span class="keyword">self</span>.unmatchedURLHandler) &#123;</span><br><span class="line">        <span class="keyword">self</span>.unmatchedURLHandler(<span class="keyword">self</span>, URL, parameters);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> didRoute;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果说路由规则是一个固定的内容，那么路由匹配则是拿着一个个具体的URL去规则里面去匹配：</p>
<p>路由匹配有几个阶段：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="bullet">1.</span> 将路由URL以及参数封装成一个JLRRouteRequest</span><br><span class="line"><span class="bullet">2.</span> 使用已经注册好的JLRRouteDefinition去和JLRRouteRequest进行匹配，并生成一个JLRRouteResponse,如果匹配，则调用相应的回调。</span><br><span class="line"><span class="bullet">3.</span> 如果不匹配则根据我们的需求选择是否允许转到Globle路由去匹配，如果还没找到则选择是否调用unmatchedURLHandler</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong><strong>JLRRouteRequest路由请求</strong></strong></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)initWithURL:(<span class="built_in">NSURL</span> *)URL options:(JLRRouteRequestOptions)options additionalParameters:(<span class="keyword">nullable</span> <span class="built_in">NSDictionary</span> *)additionalParameters &#123;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">self</span> = [<span class="variable language_">super</span> init])) &#123;</span><br><span class="line">        <span class="keyword">self</span>.URL                    = URL;                      <span class="comment">// URL</span></span><br><span class="line">        <span class="keyword">self</span>.options                = options;                  <span class="comment">// options</span></span><br><span class="line">        <span class="keyword">self</span>.additionalParameters   = additionalParameters;     <span class="comment">// 额外参数</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">BOOL</span> treatsHostAsPathComponent = ((options &amp; JLRRouteRequestOptionTreatHostAsPathComponent) == JLRRouteRequestOptionTreatHostAsPathComponent);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//取出路径的各个部分</span></span><br><span class="line">        <span class="built_in">NSURLComponents</span> *components = [<span class="built_in">NSURLComponents</span> componentsWithString:[<span class="keyword">self</span>.URL absoluteString]];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//是否将host作为path</span></span><br><span class="line">        <span class="keyword">if</span> (components.host.length &gt; <span class="number">0</span> </span><br><span class="line">            &amp;&amp; (treatsHostAsPathComponent || (![components.host isEqualToString:<span class="string">@&quot;localhost&quot;</span>] &amp;&amp; [components.host rangeOfString:<span class="string">@&quot;.&quot;</span>].location == <span class="built_in">NSNotFound</span>))) &#123;</span><br><span class="line">            <span class="comment">// convert the host to &quot;/&quot; so that the host is considered a path component</span></span><br><span class="line">            <span class="built_in">NSString</span> *host = [components.percentEncodedHost <span class="keyword">copy</span>];</span><br><span class="line">            components.host = <span class="string">@&quot;/&quot;</span>;</span><br><span class="line">            components.percentEncodedPath = [host stringByAppendingPathComponent:(components.percentEncodedPath ?: <span class="string">@&quot;&quot;</span>)];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//格式化后的路径</span></span><br><span class="line">        <span class="built_in">NSString</span> *path = [components percentEncodedPath];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// handle fragment if needed</span></span><br><span class="line">        <span class="keyword">if</span> (components.fragment != <span class="literal">nil</span>) &#123;</span><br><span class="line">            <span class="type">BOOL</span> fragmentContainsQueryParams = <span class="literal">NO</span>;</span><br><span class="line">            <span class="built_in">NSURLComponents</span> *fragmentComponents = [<span class="built_in">NSURLComponents</span> componentsWithString:components.percentEncodedFragment];</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (fragmentComponents.query == <span class="literal">nil</span> &amp;&amp; fragmentComponents.path != <span class="literal">nil</span>) &#123;</span><br><span class="line">                fragmentComponents.query = fragmentComponents.path;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (fragmentComponents.queryItems.count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// determine if this fragment is only valid query params and nothing else</span></span><br><span class="line">                fragmentContainsQueryParams = fragmentComponents.queryItems.firstObject.value.length &gt; <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (fragmentContainsQueryParams) &#123;</span><br><span class="line">                <span class="comment">// include fragment query params in with the standard set</span></span><br><span class="line">                components.queryItems = [(components.queryItems ?: @[]) arrayByAddingObjectsFromArray:fragmentComponents.queryItems];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (fragmentComponents.path != <span class="literal">nil</span> &amp;&amp; (!fragmentContainsQueryParams || ![fragmentComponents.path isEqualToString:fragmentComponents.query])) &#123;</span><br><span class="line">                <span class="comment">// handle fragment by include fragment path as part of the main path</span></span><br><span class="line">                path = [path stringByAppendingString:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;#%@&quot;</span>, fragmentComponents.percentEncodedPath]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// strip off leading slash so that we don&#x27;t have an empty first path component</span></span><br><span class="line">        <span class="keyword">if</span> (path.length &gt; <span class="number">0</span> &amp;&amp; [path characterAtIndex:<span class="number">0</span>] == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">            path = [path substringFromIndex:<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// strip off trailing slash for the same reason</span></span><br><span class="line">        <span class="keyword">if</span> (path.length &gt; <span class="number">0</span> &amp;&amp; [path characterAtIndex:path.length - <span class="number">1</span>] == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">            path = [path substringToIndex:path.length - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// split apart into path components</span></span><br><span class="line">        <span class="keyword">self</span>.pathComponents = [path componentsSeparatedByString:<span class="string">@&quot;/&quot;</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// convert query items into a dictionary</span></span><br><span class="line">        <span class="built_in">NSArray</span> &lt;<span class="built_in">NSURLQueryItem</span> *&gt; *queryItems = [components queryItems] ?: @[];</span><br><span class="line">        <span class="built_in">NSMutableDictionary</span> *queryParams = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSURLQueryItem</span> *item <span class="keyword">in</span> queryItems) &#123;</span><br><span class="line">            <span class="keyword">if</span> (item.value == <span class="literal">nil</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (queryParams[item.name] == <span class="literal">nil</span>) &#123;</span><br><span class="line">                <span class="comment">// first time seeing a param with this name, set it</span></span><br><span class="line">                queryParams[item.name] = item.value;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([queryParams[item.name] isKindOfClass:[<span class="built_in">NSArray</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">                <span class="comment">// already an array of these items, append it</span></span><br><span class="line">                <span class="built_in">NSArray</span> *values = (<span class="built_in">NSArray</span> *)(queryParams[item.name]);</span><br><span class="line">                queryParams[item.name] = [values arrayByAddingObject:item.value];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// existing non-array value for this key, create an array</span></span><br><span class="line">                <span class="type">id</span> existingValue = queryParams[item.name];</span><br><span class="line">                queryParams[item.name] = @[existingValue, item.value];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">self</span>.queryParams = [queryParams <span class="keyword">copy</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">JLRRouteRequest</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// The URL being routed. 需要被路由的URL</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">readonly</span>) <span class="built_in">NSURL</span>                     *URL;</span><br><span class="line"><span class="comment">/// The URL&#x27;s path components. URL的路径部分</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span>                 *pathComponents;</span><br><span class="line"><span class="comment">/// The URL&#x27;s query parameters. URL的请求参数部分</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="built_in">NSDictionary</span>            *queryParams;</span><br><span class="line"><span class="comment">/// Route request options, generally configured from the framework global options. 请求的可选部分</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>, <span class="keyword">readonly</span>) JLRRouteRequestOptions  options;</span><br><span class="line"><span class="comment">/// Additional parameters to pass through as part of the match parameters dictionary. 额外参数</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">nullable</span>, <span class="keyword">readonly</span>) <span class="built_in">NSDictionary</span>    *additionalParameters;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>每个JLRRouteRequest包含了URL它是JLRRouteRequest其他部分的来源，pathComponents是URL中的path部分，queryParams是URL中的query部分，options是外部注入的选项配置，additionalParameters是外部注入的额外参数。进入下一阶段匹配的时候都是将这些参数与JLRRouteDefinition中定义的模版进行匹配。</p>
<p><strong><strong>JLRRouteDefinition 路由规则定义</strong></strong></p>
<p>我们接下来看下JLRRouts中的路由规则定义部分，以及路由匹配过程：</p>
<p>在JLRoutes中每个路由规则被定义为一个JLRRouteDefinition对象，我们先来看下它的结构：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 当前route 的 URL scheme</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">readonly</span>) <span class="built_in">NSString</span>                  *scheme;</span><br><span class="line"><span class="comment">/// 当前route匹配模版.</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">readonly</span>) <span class="built_in">NSString</span>                  *pattern;</span><br><span class="line"><span class="comment">/// 当前路由的优先级</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>, <span class="keyword">readonly</span>) <span class="built_in">NSUInteger</span>              priority;</span><br><span class="line"><span class="comment">/// 当前路由的匹配模版分隔后的Components，它通过‘/’对pattern字符串进行分隔后存到patternPathComponents</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span> &lt;<span class="built_in">NSString</span> *&gt;      *patternPathComponents;</span><br><span class="line"><span class="comment">/// 在每次匹配的时候都会触发这个handlerBlock</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">readonly</span>) <span class="type">BOOL</span>                      (^handlerBlock)(<span class="built_in">NSDictionary</span> *parameters);</span><br></pre></td></tr></table></figure>

<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)initWithPattern:(<span class="built_in">NSString</span> *)pattern priority:(<span class="built_in">NSUInteger</span>)priority handlerBlock:(<span class="type">BOOL</span> (^)(<span class="built_in">NSDictionary</span> *parameters))handlerBlock &#123;</span><br><span class="line">    <span class="built_in">NSParameterAssert</span>(pattern != <span class="literal">nil</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">self</span> = [<span class="variable language_">super</span> init])) &#123;</span><br><span class="line">        <span class="keyword">self</span>.pattern = pattern;</span><br><span class="line">        <span class="keyword">self</span>.priority = priority;</span><br><span class="line">        <span class="keyword">self</span>.handlerBlock = handlerBlock;</span><br><span class="line">        <span class="keyword">if</span> ([pattern characterAtIndex:<span class="number">0</span>] == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">            pattern = [pattern substringFromIndex:<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">self</span>.patternPathComponents = [pattern componentsSeparatedByString:<span class="string">@&quot;/&quot;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>pattern 是当前路由的匹配规则比如&#x2F;path&#x2F;:things&#x2F;a&#x2F;b&#x2F;c,而patternPathComponents则是通过‘&#x2F;’对pattern字符串进行分隔后的子pathPattern。我们接下来看下最重要的路由匹配过程。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (JLRRouteResponse *)routeResponseForRequest:(JLRRouteRequest *)request &#123;</span><br><span class="line">    <span class="type">BOOL</span> patternContainsWildcard = [<span class="keyword">self</span>.patternPathComponents containsObject:<span class="string">@&quot;*&quot;</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//不包含通配符的情况下传入的request与当前的pathComponents长度不相等，这种情况确定是不匹配的</span></span><br><span class="line">    <span class="keyword">if</span> (request.pathComponents.count != <span class="keyword">self</span>.patternPathComponents.count &amp;&amp; !patternContainsWildcard) &#123;</span><br><span class="line">        <span class="keyword">return</span> [JLRRouteResponse invalidMatchResponse];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//通过patternPathComponents模版定义从request pathComponents取出具体的参数值来填充routeVariables，routeVariables就是匹配出的变量值</span></span><br><span class="line">    <span class="built_in">NSDictionary</span> *routeVariables = [<span class="keyword">self</span> routeVariablesForRequest:request];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (routeVariables != <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="comment">// It&#x27;s a match, set up the param dictionary and create a valid match response</span></span><br><span class="line">        <span class="comment">//匹配的情况下将所有的参数放到JLRRouteResponse返回</span></span><br><span class="line">        <span class="built_in">NSDictionary</span> *matchParams = [<span class="keyword">self</span> matchParametersForRequest:request routeVariables:routeVariables];</span><br><span class="line">        <span class="keyword">return</span> [JLRRouteResponse validMatchResponseWithParameters:matchParams];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// nil variables indicates no match, so return an invalid match response</span></span><br><span class="line">        <span class="keyword">return</span> [JLRRouteResponse invalidMatchResponse];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>routeResponseForRequest 中最关键的部分在于routeVariablesForRequest，它会在提取path中变量的过程中，一边针对path进行匹配，一边提取，一旦发现不匹配就直接返回。所以我们重点来看下routeVariablesForRequest部分：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">NSDictionary</span> &lt;<span class="built_in">NSString</span> *, <span class="built_in">NSString</span> *&gt; *)routeVariablesForRequest:(JLRRouteRequest *)request &#123;</span><br><span class="line">    <span class="built_in">NSMutableDictionary</span> *routeVariables = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">    </span><br><span class="line">    <span class="type">BOOL</span> isMatch = <span class="literal">YES</span>;</span><br><span class="line">    <span class="built_in">NSUInteger</span> index = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSString</span> *patternComponent <span class="keyword">in</span> <span class="keyword">self</span>.patternPathComponents <span class="comment">/*这里存着变量名*/</span>) &#123;</span><br><span class="line">        <span class="built_in">NSString</span> *URLComponent = <span class="literal">nil</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//是否是通配符</span></span><br><span class="line">        <span class="type">BOOL</span> isPatternComponentWildcard = [patternComponent isEqualToString:<span class="string">@&quot;*&quot;</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 1. 取出request中同样位置的pathComponents</span></span><br><span class="line">        <span class="keyword">if</span> (index &lt; [request.pathComponents count]) &#123;</span><br><span class="line">            URLComponent = request.pathComponents[index]<span class="comment">/*请求这里存着变量值*/</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!isPatternComponentWildcard) &#123;</span><br><span class="line">            <span class="comment">// 请求路径参数小于或者等于的时候还包含有通配符是不可能的</span></span><br><span class="line">            <span class="comment">// URLComponent is not a wildcard and index is &gt;= request.pathComponents.count, so bail</span></span><br><span class="line">            isMatch = <span class="literal">NO</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//从patternPathComponent看当前的path是否是带参数的path，带参数的path之前都是 :xxx这种以冒号开头</span></span><br><span class="line">        <span class="keyword">if</span> ([patternComponent hasPrefix:<span class="string">@&quot;:&quot;</span>]) &#123;</span><br><span class="line">            <span class="comment">// this is a variable, set it in the params</span></span><br><span class="line">            <span class="built_in">NSAssert</span>(URLComponent != <span class="literal">nil</span>, <span class="string">@&quot;URLComponent cannot be nil&quot;</span>);</span><br><span class="line">            <span class="comment">// 获取变量名---&gt; 将开头的冒号以及结尾的#去掉</span></span><br><span class="line">            <span class="built_in">NSString</span> *variableName = [<span class="keyword">self</span> routeVariableNameForValue:patternComponent];</span><br><span class="line">            <span class="comment">// 变量值 ---&gt; 将结尾的#去掉</span></span><br><span class="line">            <span class="built_in">NSString</span> *variableValue = [<span class="keyword">self</span> routeVariableValueForValue:URLComponent];</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// Consult the parsing utilities as well to do any other standard variable transformations</span></span><br><span class="line">            <span class="type">BOOL</span> decodePlusSymbols = ((request.options &amp; JLRRouteRequestOptionDecodePlusSymbols) == JLRRouteRequestOptionDecodePlusSymbols);</span><br><span class="line">            variableValue = [JLRParsingUtilities variableValueFrom:variableValue decodePlusSymbols:decodePlusSymbols];</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//将变量名为key，值为value 存在 routeVariables中</span></span><br><span class="line">            routeVariables[variableName] = variableValue;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isPatternComponentWildcard <span class="comment">/*包含通配符的情况*/</span>) &#123;</span><br><span class="line">            <span class="comment">// match wildcards</span></span><br><span class="line">            <span class="built_in">NSUInteger</span> minRequiredParams = index;</span><br><span class="line">            <span class="keyword">if</span> (request.pathComponents.count &gt;= minRequiredParams) &#123;</span><br><span class="line">                <span class="comment">// match: /a/b/c/* has to be matched by at least /a/b/c</span></span><br><span class="line">                <span class="comment">// 将通配的部分统一放到routeVariables[JLRouteWildcardComponentsKey]中</span></span><br><span class="line">                routeVariables[JLRouteWildcardComponentsKey] = [request.pathComponents subarrayWithRange:<span class="built_in">NSMakeRange</span>(index, request.pathComponents.count - index)];</span><br><span class="line">                isMatch = <span class="literal">YES</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// not a match: /a/b/c/* cannot be matched by URL /a/b/</span></span><br><span class="line">                isMatch = <span class="literal">NO</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (![patternComponent isEqualToString:URLComponent]) &#123;</span><br><span class="line">            <span class="comment">// break if this is a static component and it isn&#x27;t a match</span></span><br><span class="line">            isMatch = <span class="literal">NO</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!isMatch) &#123;</span><br><span class="line">        <span class="comment">// Return nil to indicate that there was not a match</span></span><br><span class="line">        routeVariables = <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> [routeVariables <span class="keyword">copy</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先我们会遍历JLRRouteDefinition中的patternPathComponents，将它的每个元素取出来，如果发现当前的patternPathComponent是以冒号开头，那么表示，当前的path是一个变量，就从request中的pathComponents对应位置取出pathComponent。再将patternPathComponen开始的冒号以及结尾如果是#的去掉作为key，将requst pathComponent 作为value添加到routeVariables。</p>
<p>如果当前的匹配规则patternPathComponent是通配符，并且request的pathComponents长度大于当前的index，那么将request pathComponents中剩余的值都赋给routeVariables，这时候key为通配符符号*。<br>为什么能够这样做，以为我们规定通配符要放在路径的最后面。</p>
<p>除了变量，通配符之外只剩下静态component，这种只要判断是否相等就可以了。不相等就表示直接不匹配。</p>
<p>所以routeVariablesForRequest其实是要完成两部分任务，一部分负责匹配，一部分负责将path中的变量提取出来。</p>
<p>我们再回到routeResponseForRequest，提取完path中的全部变量后会执行下面这部分代码：</p>
<figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">NSDictionary *<span class="built_in">match</span>Params = [<span class="literal">self</span> <span class="built_in">match</span>ParametersForRequest:request <span class="keyword">route</span>Variables:<span class="keyword">route</span>Variables];</span><br></pre></td></tr></table></figure>

<p>它其实是将上面从path提取出来的参数以及request.additionalParameters，request.queryParams合并起来作为最终的参数，并且在这最终的参数中添加request.URL，以及self.scheme。我们知道JLRRoutes的参数可以通过path指定，通过request.queryParams，通过request.additionalParameters 这三个地方指定。这里就是将这写参数合并起来，传递下去。后续的处理block拿到这些参数进行对应的逻辑处理。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">NSDictionary</span> *)matchParametersForRequest:(JLRRouteRequest *)request routeVariables:(<span class="built_in">NSDictionary</span> &lt;<span class="built_in">NSString</span> *, <span class="built_in">NSString</span> *&gt; *)routeVariables &#123;</span><br><span class="line">    <span class="built_in">NSMutableDictionary</span> *matchParams = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Add the parsed query parameters (&#x27;?a=b&amp;c=d&#x27;). Also includes fragment.</span></span><br><span class="line">    <span class="comment">// 添加query参数</span></span><br><span class="line">    <span class="type">BOOL</span> decodePlusSymbols = ((request.options &amp; JLRRouteRequestOptionDecodePlusSymbols) == JLRRouteRequestOptionDecodePlusSymbols);</span><br><span class="line">    [matchParams addEntriesFromDictionary:[JLRParsingUtilities queryParams:request.queryParams decodePlusSymbols:decodePlusSymbols]];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Add the actual parsed route variables (the items in the route prefixed with &#x27;:&#x27;).</span></span><br><span class="line">    <span class="comment">// 添加路径中的参数</span></span><br><span class="line">    [matchParams addEntriesFromDictionary:routeVariables];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Add the additional parameters, if any were specified in the request.</span></span><br><span class="line">    <span class="comment">// 添加request中附带的额外的参数</span></span><br><span class="line">    <span class="keyword">if</span> (request.additionalParameters != <span class="literal">nil</span>) &#123;</span><br><span class="line">        [matchParams addEntriesFromDictionary:request.additionalParameters];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Finally, add the base parameters. This is done last so that these cannot be overriden by using the same key in your route or query.</span></span><br><span class="line">    <span class="comment">// 添加request.URL ，self.scheme这些公共参数</span></span><br><span class="line">    [matchParams addEntriesFromDictionary:[<span class="keyword">self</span> defaultMatchParametersForRequest:request]];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> [matchParams <span class="keyword">copy</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSDictionary</span> *)defaultMatchParametersForRequest:(JLRRouteRequest *)request &#123;</span><br><span class="line">    <span class="keyword">return</span> @&#123;JLRoutePatternKey: <span class="keyword">self</span>.pattern ?: [<span class="built_in">NSNull</span> null], JLRouteURLKey: request.URL ?: [<span class="built_in">NSNull</span> null], JLRouteSchemeKey: <span class="keyword">self</span>.scheme ?: [<span class="built_in">NSNull</span> null]&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有了参数之后就将参数封装到JLRRouteResponse中传递给处理block：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="string">[JLRRouteResponse validMatchResponseWithParameters:matchParams]</span></span><br></pre></td></tr></table></figure>

<p>JLRRouteResponse 十分简单就两个属性，一个用于标记是否匹配，另一个是当前路由的所有请求：</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@interface</span> <span class="attribute">JLRRouteResponse </span>: NSObject &lt;NSCopying&gt;</span><br><span class="line"><span class="comment">/// 是否匹配</span></span><br><span class="line"><span class="variable">@property</span> (nonatomic, assign, readonly, getter=isMatch) BOOL match;</span><br><span class="line"><span class="comment">/// 匹配的参数</span></span><br><span class="line"><span class="variable">@property</span> (nonatomic, copy, readonly, nullable) NSDictionary *parameters;</span><br><span class="line"><span class="variable">@end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们前面在介绍_routeURL的时候看到最终的response是传递到JLRRouteDefinition中的callHandlerBlockWithParameters方法中：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">didRoute</span> = [route callHandlerBlockWithParameters:response.parameters]<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>而callHandlerBlockWithParameters则是调用了handlerBlock将参数传递出去，在业务层进行处理：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">BOOL</span>)callHandlerBlockWithParameters:(<span class="built_in">NSDictionary</span> *)parameters &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.handlerBlock == <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.handlerBlock(parameters);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以整个路由的过程是这样的：</p>
<ol>
<li>在使用路由之前先注册一系列路由规则JLRRouteDefinition，每个路由规则有对应的匹配规则pathPattern,以及如果有对应的路由请求匹配这条规则后的处理。</li>
<li>将匹配规则封装成一个JLRRouteRequest请求，并拿它与所属的schema中的一系列JLRRouteDefinition进行匹配，并尝试按照JLRRouteDefinition中的规则提取对应的参数。</li>
<li>如果匹配了哪条规则，就会触发对应规则的handlerBlock，并将所有参数传递进去。我们在handlerBlock中就可以自定义我们的业务处理。</li>
</ol>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/iOS-%E5%BC%80%E6%BA%90%E5%BA%93%E5%88%86%E6%9E%90/">iOS 开源库分析</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/iOS-开源库分析/">iOS 开源库分析</a>
  </div>

</div>



<div class="comments-count">
	
	  	<span></span>
		<a href="/2019/10/22/JRLRoute-源码解析/#comments" class="ds-thread-count comments-count-link" data-thread-key="2019/10/22/JRLRoute-源码解析/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/10/15/图解iOS之GVUserDefaults/" title="图解iOS之GVUserDefaults" itemprop="url">图解iOS之GVUserDefaults</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Edgar" target="_blank" itemprop="author">Edgar</a>
		
  <p class="article-time">
    <time datetime="2019-10-14T17:19:01.000Z" itemprop="datePublished"> Published 2019-10-15</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p><img src="/2019/10/15/%E5%9B%BE%E8%A7%A3iOS%E4%B9%8BGVUserDefaults/0001.png"></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/iOS-%E5%BC%80%E6%BA%90%E5%BA%93%E5%88%86%E6%9E%90/">iOS 开源库分析</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/iOS-开源库分析/">iOS 开源库分析</a>
  </div>

</div>



<div class="comments-count">
	
	  	<span></span>
		<a href="/2019/10/15/图解iOS之GVUserDefaults/#comments" class="ds-thread-count comments-count-link" data-thread-key="2019/10/15/图解iOS之GVUserDefaults/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/10/12/图解iOS系列之Aspect-一-重要的类及关系介绍/" title="Aspect 源码解析" itemprop="url">Aspect 源码解析</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Edgar" target="_blank" itemprop="author">Edgar</a>
		
  <p class="article-time">
    <time datetime="2019-10-11T16:09:20.000Z" itemprop="datePublished"> Published 2019-10-12</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h5 id="开源代码信息"><a href="#开源代码信息" class="headerlink" title="开源代码信息"></a>开源代码信息</h5><p><a target="_blank" rel="noopener" href="https://github.com/steipete/Aspects">源码地址</a></p>
<p>在编程中有两种比较重要的扩展方式，一种是面向对象编程中的继承方式，一种是面向切面编程，前者是纵向扩展，而后者是横向扩展，目前大多数的流行编程语音都有这两种扩展方式，在iOS开发中使用Aspect来对现有代码进行横向扩展，Aspect用于在当前selector之前或者之后插入代码块或者使用某个代码快替换当前selector，它通过OC的消息转发机制hook消息。所以会有一些性能开销，建议不要把Aspects加到经常被使用的方法里面。</p>
<h5 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h5><p><strong><strong>1. Aspect对外接口</strong></strong></p>
<p>Aspect 代码比较精炼，就两个文件两个接口，我们先来看下它对外的接口：</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">+ (<span class="built_in">id</span>&lt;AspectToken&gt;)aspect_hookSelector:(SEL)selector</span><br><span class="line">                           withOptions:(AspectOptions)options</span><br><span class="line">                            usingBlock:(<span class="built_in">id</span>)block</span><br><span class="line">                                 <span class="keyword">error</span>:(NSError **)<span class="keyword">error</span>;</span><br><span class="line">- (<span class="built_in">id</span>&lt;AspectToken&gt;)aspect_hookSelector:(SEL)selector</span><br><span class="line">                           withOptions:(AspectOptions)options</span><br><span class="line">                            usingBlock:(<span class="built_in">id</span>)block</span><br><span class="line">                                 <span class="keyword">error</span>:(NSError **)<span class="keyword">error</span>;</span><br></pre></td></tr></table></figure>
<p>Aspects是NSObject的一个扩展，所以原则上只要是NSObject的实例都可以通过上面两个方法进行hook。<br>第一个参数selector是当前类需要hook的selector<br>第二个参数options用于指定调用切片方法的时机：</p>
<figure class="highlight elm"><table><tr><td class="code"><pre><span class="line">typedef <span class="type">NS_OPTIONS</span>(<span class="type">NSUInteger</span>, <span class="type">AspectOptions</span>) &#123;</span><br><span class="line">    <span class="type">AspectPositionAfter</span>   = 0,            /// 在原方法实现调用之后调用    <span class="type">Called</span> after the original implementation (default)</span><br><span class="line">    <span class="type">AspectPositionInstead</span> = 1,            /// 将会替换原方法的实现。      <span class="type">Will</span> replace the original implementation.</span><br><span class="line">    <span class="type">AspectPositionBefore</span>  = 2,            /// 在原方法调用之前调用。      <span class="type">Called</span> before the original implementation.</span><br><span class="line">    <span class="type">AspectOptionAutomaticRemoval</span> = 1 &lt;&lt; 3 /// 在第一次执行之后自动移除hook <span class="type">Will</span> remove the hook after the first execution.</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>它可以指定在原方法实现之后插入，这也是默认的方式，还可以使用block替换原来方法的实现，还可以在原方法之前插入指定的block，还可以只进行一次hook，第一次hook之后就会自动被移除。<br>第三个参数block是用于替换被hook selector的代码块<br>第四个参数error用于获取hook过程中的错误。</p>
<p><strong><strong>2. Hook流程分析</strong></strong></p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">static id aspect_add(id self, SEL selector<span class="regexp">/*需要hook的SEL*/</span>, AspectOptions options<span class="regexp">/*切片的时机*/</span>, id block<span class="regexp">/*切片的执行方法*/</span>, NSError **error) &#123;</span><br><span class="line">    <span class="regexp">//</span>.....</span><br><span class="line">    __block AspectIdentifier *identifier = nil;</span><br><span class="line">    <span class="regexp">//</span>aspect_performLocked是一个自旋锁。自旋锁是效率比较高的一种锁，相比@synchronized来说效率高得多。</span><br><span class="line">    aspect_performLocked(^&#123;</span><br><span class="line">        <span class="regexp">//</span>是否允许hook</span><br><span class="line">        <span class="keyword">if</span> (aspect_isSelectorAllowedAndTrack(self, selector, options, error)) &#123;</span><br><span class="line">            <span class="regexp">//</span>添加一个aspect__selectName  ===  AspectsContainer</span><br><span class="line">            AspectsContainer *aspectContainer = aspect_getContainerForObject(self, selector);</span><br><span class="line">            <span class="regexp">//</span>将调用数据封装成AspectIdentifier</span><br><span class="line">            <span class="regexp">//</span>得到了aspectContainer之后，就可以开始准备我们要hook方法的一些信息。这些信息都装在AspectIdentifier中，所以我们需要新建一个AspectIdentifier。</span><br><span class="line">            <span class="regexp">//</span>这个instancetype方法，只有一种情况会创建失败，那就是aspect_isCompatibleBlockSignature方法返回NO。返回NO就意味着我们要替换的方法block和要替换的原方法，两者的方法签名是不相符的</span><br><span class="line">            <span class="regexp">//</span>方法签名匹配成功之后，就会创建好一个AspectIdentifier。</span><br><span class="line">            identifier = [AspectIdentifier identifierWithSelector:selector object:self options:options block:block error:error];</span><br><span class="line">            <span class="keyword">if</span> (identifier) &#123;</span><br><span class="line">                <span class="regexp">//</span>容器中添加identifier</span><br><span class="line">                <span class="regexp">//</span>aspectContainer容器会把它加入到容器中。完成了容器和AspectIdentifier初始化之后，就可以开始准备进行hook了。通过options选项分别添加到容器中的</span><br><span class="line">                [aspectContainer addAspect:identifier withOptions:options];</span><br><span class="line">                <span class="regexp">//</span>添加一个aspects__selectName  ===  AspectsContainer(identifier, options) ====  AspectIdentifier（包含了调用所需要的所有信息）</span><br><span class="line">                <span class="regexp">//</span> Modify the class to allow message interception.</span><br><span class="line">                aspect_prepareClassAndHookSelector(self, selector, error);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    return identifier;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Hook的最开始会调用<strong><strong>aspect_add</strong></strong>，这里会先用一个自旋锁来保证线程的安全，自旋锁是效率比较高的一种锁，相比@synchronized来说效率高得多，紧接着会调用aspect_isSelectorAllowedAndTrack来判断是否允许hook。如果允许hook那么会使用aspect__selectName作为属性名创建一个<strong><strong>AspectsContainer</strong></strong>类型的关联属性，这里需要注意的是每hook一个selector就会在当前对象中多出一个对应的Aspects容器，这里面存放的都是针对一个selector的切片，因为一个selecor可能会有多个不同的切片，每种类型的AspectOptions作为一个AspectIdentifier存放在AspectsContainer容器中。<br>最后通过<strong><strong>aspect_prepareClassAndHookSelector</strong></strong>对方法进行Hook.在介绍aspect_prepareClassAndHookSelector之前我们看下上面遗留的一些问题：</p>
<ol>
<li>如何判断是否允许Hook</li>
<li>aspect_getContainerForObject 的逻辑，AspectsContainer结构</li>
<li>AspectIdentifier 结构</li>
</ol>
<p><strong><strong>判断是否允许Hook</strong></strong></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">BOOL</span> aspect_isSelectorAllowedAndTrack(<span class="built_in">NSObject</span> *<span class="keyword">self</span>, SEL selector, AspectOptions options, <span class="built_in">NSError</span> **error) &#123;</span><br><span class="line">    <span class="comment">//只用初始化一次的结构</span></span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">NSSet</span> *disallowedSelectorList;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> pred;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;pred, ^&#123;</span><br><span class="line">        <span class="comment">//不允许hook的方法selector</span></span><br><span class="line">        disallowedSelectorList = [<span class="built_in">NSSet</span> setWithObjects:<span class="string">@&quot;retain&quot;</span>, <span class="string">@&quot;release&quot;</span>, <span class="string">@&quot;autorelease&quot;</span>, <span class="string">@&quot;forwardInvocation:&quot;</span>, <span class="literal">nil</span>];</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check against the blacklist.</span></span><br><span class="line">    <span class="built_in">NSString</span> *selectorName = <span class="built_in">NSStringFromSelector</span>(selector);</span><br><span class="line">    <span class="comment">//如果当前的selectorName在disallowedSelectorList中不允许hook抛出错误</span></span><br><span class="line">    <span class="keyword">if</span> ([disallowedSelectorList containsObject:selectorName]) &#123;</span><br><span class="line">        <span class="built_in">NSString</span> *errorDescription = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;Selector %@ is blacklisted.&quot;</span>, selectorName];</span><br><span class="line">        AspectError(AspectErrorSelectorBlacklisted, errorDescription);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Additional checks.</span></span><br><span class="line">    AspectOptions position = options &amp; AspectPositionFilter;</span><br><span class="line">    <span class="comment">//不允许在dealloc之后 或者替换dealloc</span></span><br><span class="line">    <span class="keyword">if</span> ([selectorName isEqualToString:<span class="string">@&quot;dealloc&quot;</span>] &amp;&amp; position != AspectPositionBefore) &#123;</span><br><span class="line">        <span class="built_in">NSString</span> *errorDesc = <span class="string">@&quot;AspectPositionBefore is the only valid position when hooking dealloc.&quot;</span>;</span><br><span class="line">        AspectError(AspectErrorSelectorDeallocPosition, errorDesc);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在指定的类中找不到需要hook的方法（如果self和self.class里面都找不到该selector，会报错找不到该方法）</span></span><br><span class="line">    <span class="keyword">if</span> (![<span class="keyword">self</span> respondsToSelector:selector] &amp;&amp; ![<span class="keyword">self</span>.class instancesRespondToSelector:selector]) &#123;</span><br><span class="line">        <span class="built_in">NSString</span> *errorDesc = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;Unable to find selector -[%@ %@].&quot;</span>, <span class="built_in">NSStringFromClass</span>(<span class="keyword">self</span>.class), selectorName];</span><br><span class="line">        AspectError(AspectErrorDoesNotRespondToSelector, errorDesc);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Search for the current class and the class hierarchy IF we are modifying a class object</span></span><br><span class="line">    <span class="keyword">if</span> (class_isMetaClass(object_getClass(<span class="keyword">self</span>))) &#123;</span><br><span class="line">        </span><br><span class="line">        Class klass = [<span class="keyword">self</span> <span class="keyword">class</span>];</span><br><span class="line">        <span class="built_in">NSMutableDictionary</span> *swizzledClassesDict = aspect_getSwizzledClassesDict();</span><br><span class="line">        Class currentClass = [<span class="keyword">self</span> <span class="keyword">class</span>];</span><br><span class="line"></span><br><span class="line">        AspectTracker *tracker = swizzledClassesDict[currentClass];</span><br><span class="line">        <span class="comment">//是否在子类已经hook过了</span></span><br><span class="line">        <span class="keyword">if</span> ([tracker subclassHasHookedSelectorName:selectorName]) &#123;</span><br><span class="line">            <span class="built_in">NSSet</span> *subclassTracker = [tracker subclassTrackersHookingSelectorName:selectorName];</span><br><span class="line">            <span class="built_in">NSSet</span> *subclassNames = [subclassTracker valueForKey:<span class="string">@&quot;trackedClassName&quot;</span>];</span><br><span class="line">            <span class="built_in">NSString</span> *errorDescription = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;Error: %@ already hooked subclasses: %@. A method can only be hooked once per class hierarchy.&quot;</span>, selectorName, subclassNames];</span><br><span class="line">            AspectError(AspectErrorSelectorAlreadyHookedInClassHierarchy, errorDescription);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">//获取当前类的tracker</span></span><br><span class="line">            tracker = swizzledClassesDict[currentClass];</span><br><span class="line">            <span class="comment">//查看是否有hook了当前selector</span></span><br><span class="line">            <span class="keyword">if</span> ([tracker.selectorNames containsObject:selectorName]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (klass == currentClass) &#123;</span><br><span class="line">                    <span class="comment">// Already modified and topmost!</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//在当前类中已经hook过</span></span><br><span class="line">                <span class="built_in">NSString</span> *errorDescription = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;Error: %@ already hooked in %@. A method can only be hooked once per class hierarchy.&quot;</span>, selectorName, <span class="built_in">NSStringFromClass</span>(currentClass)];</span><br><span class="line">                AspectError(AspectErrorSelectorAlreadyHookedInClassHierarchy, errorDescription);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((currentClass = class_getSuperclass(currentClass)));</span><br><span class="line">        <span class="comment">//经过上面合法性hook判断和类方法不允许重复替换的检查后，到此，就可以把要hook的信息记录下来，用AspectTracker标记</span></span><br><span class="line">        <span class="comment">//当前类tracker -- 待hook方法</span></span><br><span class="line">        <span class="comment">//   父tracker -- 待hook方法</span></span><br><span class="line">        <span class="comment">//   父tracker -- 待hook方法</span></span><br><span class="line">        currentClass = klass;</span><br><span class="line">        AspectTracker *subclassTracker = <span class="literal">nil</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">//当前类的tracker</span></span><br><span class="line">            tracker = swizzledClassesDict[currentClass];</span><br><span class="line">            <span class="comment">//如果没有的话则新建tracker</span></span><br><span class="line">            <span class="keyword">if</span> (!tracker) &#123;</span><br><span class="line">                tracker = [[AspectTracker alloc] initWithTrackedClass:currentClass];</span><br><span class="line">                swizzledClassesDict[(<span class="type">id</span>&lt;<span class="built_in">NSCopying</span>&gt;)currentClass] = tracker;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//非第一次则添加到subclassTracker</span></span><br><span class="line">            <span class="keyword">if</span> (subclassTracker) &#123;</span><br><span class="line">                [tracker addSubclassTracker:subclassTracker hookingSelectorName:selectorName];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//第一次添加到tracker</span></span><br><span class="line">                [tracker.selectorNames addObject:selectorName];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// All superclasses get marked as having a subclass that is modified.</span></span><br><span class="line">            subclassTracker = tracker;</span><br><span class="line">        &#125;<span class="keyword">while</span> ((currentClass = class_getSuperclass(currentClass)));</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>aspect_isSelectorAllowedAndTrack方法中主要做两件事情：</p>
<ol>
<li>判断当前selector是否允许Hook</li>
<li>如果还没建立Tracker则建立Tracker的层级关系</li>
</ol>
<p>首先会检查当前需要hook的selector是否在黑名单中，Aspect里面不允许hook “retain”, “release”, “autorelease”, “forwardInvocation:”4种方法，而且hook “dealloc”方法的时机必须是before，并且selector要能被找到，并且在对象继承层级上没有被hook过，如果这些条件都满足才允许Hook。</p>
<p>然后重建Tracker的层级关系，每个AspectTracker包含被跟踪的类以及这个类被hook替换的selector名称，以及它子类的tracker。</p>
<p><strong><strong>aspect_getContainerForObject 的逻辑</strong></strong></p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">static AspectsContainer *aspect<span class="constructor">_getContainerForObject(NSObject <span class="operator">*</span><span class="params">self</span>, SEL <span class="params">selector</span>)</span> &#123;</span><br><span class="line">    <span class="constructor">NSCParameterAssert(<span class="params">self</span>)</span>;</span><br><span class="line">    SEL aliasSelector = aspect<span class="constructor">_aliasForSelector(<span class="params">selector</span>)</span>;</span><br><span class="line">    <span class="comment">//设置关联对象aspect__selectorName  AspectsContainer</span></span><br><span class="line">    <span class="comment">//用这个字符串标记所有的selector，都加上前缀&quot;aspects&quot;。然后获得其对应的AssociatedObject关联对象，如果获取不到，就创建一个关联对象。最终得到selector有&quot;aspects&quot;前缀，对应的aspectContainer。</span></span><br><span class="line">    AspectsContainer *aspectContainer = objc<span class="constructor">_getAssociatedObject(<span class="params">self</span>, <span class="params">aliasSelector</span>)</span>;</span><br><span class="line">    <span class="keyword">if</span> (!aspectContainer) &#123;</span><br><span class="line">        aspectContainer = <span class="literal">[A<span class="identifier">spectsContainer</span> <span class="identifier">new</span>]</span>;</span><br><span class="line">        objc<span class="constructor">_setAssociatedObject(<span class="params">self</span>, <span class="params">aliasSelector</span>, <span class="params">aspectContainer</span>, OBJC_ASSOCIATION_RETAIN)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    return aspectContainer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>aspect_getContainerForObject 方法中会在当前对象中为每个hook的selector添加一个关联属性，属性名称为aspect__selectorName 类型为AspectsContainer，AspectsContainer里面只存储一个selector相关的所有hook信息。</p>
<p><strong><strong>AspectsContainer 和 AspectIdentifier的结构</strong></strong></p>
<p>上面介绍过了<strong><strong>AspectsContainer</strong></strong> 代表的是一个selector 所包含的全部hook方法，包含在原有selector之前，之后，替换原有selector的block。<br>所以AspectsContainer 包含三个数组 <strong><strong>beforeAspects</strong></strong>,<strong><strong>insteadAspects</strong></strong>,<strong><strong>afterAspects</strong></strong>:</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AspectsContainer</span> : <span class="title">NSObject</span></span></span><br><span class="line">- (<span class="type">void</span>)addAspect:(AspectIdentifier *)aspect withOptions:(AspectOptions)injectPosition;</span><br><span class="line">- (<span class="type">BOOL</span>)removeAspect:(<span class="type">id</span>)aspect;</span><br><span class="line">- (<span class="type">BOOL</span>)hasAspects;</span><br><span class="line"><span class="keyword">@property</span> (atomic, <span class="keyword">copy</span>) <span class="built_in">NSArray</span> *beforeAspects;</span><br><span class="line"><span class="keyword">@property</span> (atomic, <span class="keyword">copy</span>) <span class="built_in">NSArray</span> *insteadAspects;</span><br><span class="line"><span class="keyword">@property</span> (atomic, <span class="keyword">copy</span>) <span class="built_in">NSArray</span> *afterAspects;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>在添加的时候会根据插入的位置分别存储到不同的数组:</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)addAspect:(AspectIdentifier *)aspect withOptions:(AspectOptions)options &#123;</span><br><span class="line">    <span class="built_in">NSParameterAssert</span>(aspect);</span><br><span class="line">    <span class="built_in">NSUInteger</span> position = options&amp;AspectPositionFilter;</span><br><span class="line">    <span class="keyword">switch</span> (position) &#123;</span><br><span class="line">        <span class="comment">//会往NSArray后面添加aspect后返回新的数组的地址</span></span><br><span class="line">        <span class="keyword">case</span> AspectPositionBefore:  <span class="keyword">self</span>.beforeAspects  = [(<span class="keyword">self</span>.beforeAspects ?:@[]) arrayByAddingObject:aspect]; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> AspectPositionInstead: <span class="keyword">self</span>.insteadAspects = [(<span class="keyword">self</span>.insteadAspects?:@[]) arrayByAddingObject:aspect]; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> AspectPositionAfter:   <span class="keyword">self</span>.afterAspects   = [(<span class="keyword">self</span>.afterAspects  ?:@[]) arrayByAddingObject:aspect]; <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AspectIdentifier 代表一个Aspect的切片的具体内容。里面包含了单个的 Aspect 的具体信息，包括执行时机，要执行 block 所需要用到的具体信息：包括方法签名、参数等等。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AspectIdentifier</span> : <span class="title">NSObject</span></span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)identifierWithSelector:(SEL)selector object:(<span class="type">id</span>)object options:(AspectOptions)options block:(<span class="type">id</span>)block error:(<span class="built_in">NSError</span> **)error;</span><br><span class="line">- (<span class="type">BOOL</span>)invokeWithInfo:(<span class="type">id</span>&lt;AspectInfo&gt;)info;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) SEL selector;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="type">id</span> block;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMethodSignature</span> *blockSignature;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="type">id</span> object;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) AspectOptions options;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>我们看下它的初始化方法：</p>
<figure class="highlight pony"><table><tr><td class="code"><pre><span class="line">+ (instancetype)identifierWithSelector:(<span class="type">SEL</span>)selector <span class="keyword">object</span>:(id)<span class="keyword">object</span> options:(<span class="type">AspectOptions</span>)options block:(id)block <span class="keyword">error</span>:(<span class="type">NSError</span> **)<span class="keyword">error</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个aspect_blockMethodSignature的目的是把传递进来的AspectBlock转换成NSMethodSignature的方法签名。</span></span><br><span class="line">    <span class="type">NSMethodSignature</span> *blockSignature = aspect_blockMethodSignature(block, <span class="keyword">error</span>);</span><br><span class="line">    <span class="comment">//这个函数的作用是把我们要替换的方法block和要替换的原方法，通过签名进行对比,如果不兼容则返回nil</span></span><br><span class="line">    <span class="keyword">if</span> (!aspect_isCompatibleBlockSignature(blockSignature, <span class="keyword">object</span>, selector, <span class="keyword">error</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> nil;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">AspectIdentifier</span> *identifier = nil;</span><br><span class="line">    <span class="keyword">if</span> (blockSignature) &#123;</span><br><span class="line">        identifier = [<span class="type">AspectIdentifier</span> <span class="keyword">new</span>];</span><br><span class="line">        identifier.selector = selector;<span class="comment">//selector</span></span><br><span class="line">        identifier.block = block;      <span class="comment">//用于替换的block</span></span><br><span class="line">        identifier.blockSignature = blockSignature;<span class="comment">//block签名</span></span><br><span class="line">        identifier.options = options;     <span class="comment">//hook位置</span></span><br><span class="line">        identifier.<span class="keyword">object</span> = <span class="keyword">object</span>;       <span class="comment">// 被hook的对象</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> identifier;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>aspect_blockMethodSignature 用于获取block的签名信息，大家可以看下下面的注释，关于如何从Block中获取签名可以查看<a target="_blank" rel="noopener" href="https://mikefighting.github.io/2018/07/04/advance-block-use-in-aspects/">Aspects框架中Block的使用</a>这篇博客。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSMethodSignature</span> *aspect_blockMethodSignature(<span class="type">id</span> block, <span class="built_in">NSError</span> **error) &#123;</span><br><span class="line">    AspectBlockRef layout = (__bridge <span class="type">void</span> *)block;</span><br><span class="line">    <span class="comment">//把入参block强制转换成AspectBlockRef类型，然后判断是否有AspectBlockFlagsHasSignature的标志位，如果没有，报不包含方法签名的error。</span></span><br><span class="line">	<span class="keyword">if</span> (!(layout-&gt;flags &amp; AspectBlockFlagsHasSignature)) &#123;</span><br><span class="line">        <span class="comment">//block 不包含方法签名</span></span><br><span class="line">        <span class="built_in">NSString</span> *description = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;The block %@ doesn&#x27;t contain a type signature.&quot;</span>, block];</span><br><span class="line">        AspectError(AspectErrorMissingBlockSignature, description);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="type">void</span> *desc = layout-&gt;descriptor;</span><br><span class="line">	desc += <span class="number">2</span> * <span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span>);</span><br><span class="line">	<span class="keyword">if</span> (layout-&gt;flags &amp; AspectBlockFlagsHasCopyDisposeHelpers) &#123;</span><br><span class="line">		desc += <span class="number">2</span> * <span class="keyword">sizeof</span>(<span class="type">void</span> *);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//desc就是原来block里面对应的descriptor指针。descriptor指针往下偏移2个unsigned long int的位置就指向了copy函数的地址，</span></span><br><span class="line">    <span class="comment">//如果包含Copy和Dispose函数，那么继续往下偏移2个(void)的大小。</span></span><br><span class="line">    <span class="comment">//这时指针肯定移动到了const char signature的位置。如果desc不存在，那么也会报错，该block不包含方法签名。</span></span><br><span class="line">	<span class="keyword">if</span> (!desc) &#123;</span><br><span class="line">        <span class="comment">//block 不包含方法签名</span></span><br><span class="line">        <span class="built_in">NSString</span> *description = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;The block %@ doesn&#x27;t has a type signature.&quot;</span>, block];</span><br><span class="line">        AspectError(AspectErrorMissingBlockSignature, description);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">const</span> <span class="type">char</span> *signature = (*(<span class="keyword">const</span> <span class="type">char</span> **)desc);</span><br><span class="line">    <span class="comment">//到了这里，就保证有方法签名且存在。最后调用NSMethodSignature的signatureWithObjCTypes方法，返回方法签名。</span></span><br><span class="line">	<span class="keyword">return</span> [<span class="built_in">NSMethodSignature</span> signatureWithObjCTypes:signature];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>拿到Block签名后就可以通过aspect_isCompatibleBlockSignature来比较block的签名和要hook的selector方法的签名是否兼容：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">BOOL</span> aspect_isCompatibleBlockSignature(<span class="built_in">NSMethodSignature</span> *blockSignature, <span class="type">id</span> object, SEL selector, <span class="built_in">NSError</span> **error) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line"></span><br><span class="line">    <span class="type">BOOL</span> signaturesMatch = <span class="literal">YES</span>;</span><br><span class="line">    <span class="built_in">NSMethodSignature</span> *methodSignature = [[object <span class="keyword">class</span>] instanceMethodSignatureForSelector:selector];</span><br><span class="line">    <span class="comment">//先比较方法签名的参数个数是否相等</span></span><br><span class="line">    <span class="keyword">if</span> (blockSignature.numberOfArguments &gt; methodSignature.numberOfArguments) &#123;</span><br><span class="line">        signaturesMatch = <span class="literal">NO</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//比较我们要替换的方法里面第一个参数是不是_cmd，对应的Type就是@</span></span><br><span class="line">        <span class="keyword">if</span> (blockSignature.numberOfArguments &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="type">char</span> *blockType = [blockSignature getArgumentTypeAtIndex:<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (blockType[<span class="number">0</span>] != <span class="string">&#x27;@&#x27;</span>) &#123;</span><br><span class="line">                signaturesMatch = <span class="literal">NO</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Argument 0 is self/block, argument 1 is SEL or id&lt;AspectInfo&gt;. We start comparing at argument 2.</span></span><br><span class="line">        <span class="comment">// The block can have less arguments than the method, that&#x27;s ok.</span></span><br><span class="line">        <span class="comment">// methodSignature 和 blockSignature 的return value都是void，所以对应的都是v。</span></span><br><span class="line">        <span class="comment">// methodSignature的argument 0 是隐含参数 self，所以对应的是@。blockSignature的argument 0 是block，所以对应的是@？。</span></span><br><span class="line">        <span class="comment">// methodSignature的argument 1 是隐含参数 _cmd，所以对应的是:。blockSignature的argument 1 是，所以对应的是@&quot;&quot;。</span></span><br><span class="line">        <span class="comment">// 从argument 2开始才是方法签名后面的对应可能出现差异，需要比较的参数列表。</span></span><br><span class="line">        <span class="keyword">if</span> (signaturesMatch) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> idx = <span class="number">2</span>; idx &lt; blockSignature.numberOfArguments; idx++) &#123;</span><br><span class="line">                <span class="keyword">const</span> <span class="type">char</span> *methodType = [methodSignature getArgumentTypeAtIndex:idx];</span><br><span class="line">                <span class="keyword">const</span> <span class="type">char</span> *blockType = [blockSignature getArgumentTypeAtIndex:idx];</span><br><span class="line">                <span class="comment">// Only compare parameter, not the optional type data.</span></span><br><span class="line">                <span class="keyword">if</span> (!methodType || !blockType || methodType[<span class="number">0</span>] != blockType[<span class="number">0</span>]) &#123;</span><br><span class="line">                    signaturesMatch = <span class="literal">NO</span>; <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!signaturesMatch) &#123;</span><br><span class="line">        <span class="built_in">NSString</span> *description = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;Block signature %@ doesn&#x27;t match %@.&quot;</span>, blockSignature, methodSignature];</span><br><span class="line">        AspectError(AspectErrorIncompatibleBlockSignature, description);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>aspect_isCompatibleBlockSignature首先会判断block和selector的参数个数是否一致，然后检查block的第一个参数是否是_cmd，如果这两个条件都满足后才会继续从第二个参数开始比较block和selector之间的参数是否匹配。</p>
<p>invokeWithInfo 是调度切片block的方法，这个留在后面介绍。</p>
<p>到目前位置我们做了如下工作：在hook一个selector的时候会先判断当前selector是否可以被hook，如果可以则进行下一步：<br>紧接着我们会使用关联属性来为当前hook方法添加一个AspectsContainer，AspectsContainer当中有三个关键数组，分别用于存放option类型为AspectPositionAfter，AspectPositionInstead，AspectPositionBefore 的 AspectIdentifier。每个AspectIdentifier都包含一个切片的全部信息，这里最关键的是在初始化的时候提取的block签名信息，并且在这里会使用block签名信息和selector签名信息进行兼容性检查。AspectIdentifier内部还包含触发对应block的方法。</p>
<p>接下来我们继续看下关键的Hook部分：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">static void aspect<span class="constructor">_prepareClassAndHookSelector(NSObject <span class="operator">*</span><span class="params">self</span>, SEL <span class="params">selector</span>, NSError <span class="operator">**</span><span class="params">error</span>)</span> &#123;</span><br><span class="line">    <span class="comment">//创建一个以&quot;_Aspects_&quot;为结尾的class作为当前的class的子类</span></span><br><span class="line">    Class klass = aspect<span class="constructor">_hookClass(<span class="params">self</span>, <span class="params">error</span>)</span>;</span><br><span class="line">    <span class="comment">//获取本意要执行的selector</span></span><br><span class="line">    Method targetMethod = <span class="keyword">class</span><span class="constructor">_getInstanceMethod(<span class="params">klass</span>, <span class="params">selector</span>)</span>;</span><br><span class="line">    IMP targetMethodIMP = <span class="keyword">method</span><span class="constructor">_getImplementation(<span class="params">targetMethod</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里是判断当前IMP是不是_objc_msgForward或者_objc_msgForward_stret，即判断当前IMP是不是消息转发。如果是消息转发的话就不做hook处理</span></span><br><span class="line">    <span class="keyword">if</span> (!aspect<span class="constructor">_isMsgForwardIMP(<span class="params">targetMethodIMP</span>)</span>) &#123;</span><br><span class="line">        <span class="comment">//如果不是消息转发，就先获取当前原始的selector对应的IMP的方法编码typeEncoding。</span></span><br><span class="line">        const <span class="built_in">char</span> *typeEncoding = <span class="keyword">method</span><span class="constructor">_getTypeEncoding(<span class="params">targetMethod</span>)</span>;</span><br><span class="line">        <span class="comment">//获取aspect_selector方法</span></span><br><span class="line">        SEL aliasSelector = aspect<span class="constructor">_aliasForSelector(<span class="params">selector</span>)</span>;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="literal">[<span class="identifier">klass</span> <span class="identifier">instancesRespondToSelector</span>:<span class="identifier">aliasSelector</span>]</span>) &#123;</span><br><span class="line">            <span class="comment">//如果子类里面不能响应aspects_xxxx，就为klass添加aspects_xxxx方法，方法的实现为原生方法的实现。也就是将原始的方法添加到创建的以&quot;_Aspects_&quot;为结尾的class</span></span><br><span class="line">            __unused BOOL addedAlias = <span class="keyword">class</span><span class="constructor">_addMethod(<span class="params">klass</span>, <span class="params">aliasSelector</span>, <span class="params">method_getImplementation</span>(<span class="params">targetMethod</span>)</span>, typeEncoding);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将slector指向_objc_msgForward 和_objc_msgForward_stret，可想而知，当selector被执行的时候，也会触发消息转发从而进入forwardInvocation，而我们又对forwardInvacation进行了swizzling，因此，最终转入我们自己的处理逻辑代码中。</span></span><br><span class="line">        <span class="keyword">class</span><span class="constructor">_replaceMethod(<span class="params">klass</span>, <span class="params">selector</span>, <span class="params">aspect_getMsgForwardIMP</span>(<span class="params">self</span>, <span class="params">selector</span>)</span>, typeEncoding);</span><br><span class="line">        <span class="constructor">AspectLog(@<span class="string">&quot;Aspects: Installed hook for -[%@ %@].&quot;</span>, <span class="params">klass</span>, NSStringFromSelector(<span class="params">selector</span>)</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>aspect_prepareClassAndHookSelector方法中会先创建一个以_Aspects_为结尾的class作为当前的class的子类，如果当前方法不是消息分发方法_objc_msgForward或者_objc_msgForward_stret，就进行方法替换。比如我们要调用classA 的testA方法，并且testA已经被hook了，那么这时候我们会创建一个classA_Aspects_类作为classA的子类。在调用classA 的testA方法的时候会先看下classA_Aspects_是否有aspects_testA方法，如果没有则添加一个方法aspects_testA指向原来的testA，并且将classA_Aspects_的selector方法替换为aspect_getMsgForwardIMP(self, selector)走消息分发途径。消息具体怎么分发的我们看下<strong><strong>aspect_hookClass</strong></strong>：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">static Class aspect<span class="constructor">_hookClass(NSObject <span class="operator">*</span><span class="params">self</span>, NSError <span class="operator">**</span><span class="params">error</span>)</span> &#123;</span><br><span class="line">    <span class="constructor">NSCParameterAssert(<span class="params">self</span>)</span>;</span><br><span class="line">	Class statedClass = self.<span class="keyword">class</span>;                     <span class="comment">//是获取类对象</span></span><br><span class="line">	Class baseClass = <span class="keyword">object</span><span class="constructor">_getClass(<span class="params">self</span>)</span>;           <span class="comment">//是获取到类的isa。</span></span><br><span class="line">	NSString *className = <span class="constructor">NSStringFromClass(<span class="params">baseClass</span>)</span>;<span class="comment">//类名</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">[<span class="identifier">className</span> <span class="identifier">hasSuffix</span>:A<span class="identifier">spectsSubclassSuffix</span>]</span>) &#123;</span><br><span class="line">		return baseClass;</span><br><span class="line">        <span class="comment">//如果包含了@&quot;_Aspects_&quot;后缀，代表该类已经被hook过了，直接return。</span></span><br><span class="line">        <span class="comment">//如果不包含@&quot;_Aspects_&quot;后缀，再判断是否是baseClass是否是元类，如果是元类，调用aspect_swizzleClassInPlace。</span></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">class</span><span class="constructor">_isMetaClass(<span class="params">baseClass</span>)</span>) &#123;</span><br><span class="line">        return aspect<span class="constructor">_swizzleClassInPlace((Class)</span>self);</span><br><span class="line">        <span class="comment">// Probably a KVO&#x27;ed class. Swizzle in place. Also swizzle meta classes in place.</span></span><br><span class="line">        <span class="comment">//如果也不是元类，再判断statedClass 和 baseClass是否相等，如果不相等，说明为KVO过的对象，因为KVO的对象isa指针会指向一个中间类。对KVO中间类调用aspect_swizzleClassInPlace。</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (statedClass != baseClass) &#123;</span><br><span class="line">        return aspect<span class="constructor">_swizzleClassInPlace(<span class="params">baseClass</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//当className没有包含@&quot;_Aspects_&quot;后缀，并且也不是元类，也不是KVO的中间类</span></span><br><span class="line">    <span class="comment">//在当前类名中添加AspectsSubclassSuffix</span></span><br><span class="line">    <span class="comment">//hook 是在runtime中动态创建子类的基础上实现的</span></span><br><span class="line">	const <span class="built_in">char</span> *subclassName = <span class="literal">[<span class="identifier">className</span> <span class="identifier">stringByAppendingString</span>:A<span class="identifier">spectsSubclassSuffix</span>]</span>.UTF8String;</span><br><span class="line">	Class subclass = objc<span class="constructor">_getClass(<span class="params">subclassName</span>)</span>;</span><br><span class="line">    <span class="comment">//正常情况下是没有这个添加AspectsSubclassSuffix的类的</span></span><br><span class="line">	<span class="keyword">if</span> (subclass<span class="operator"> == </span>nil) &#123;</span><br><span class="line">        <span class="comment">//创建一个新的class,它的父类为baseClass</span></span><br><span class="line">		subclass = objc<span class="constructor">_allocateClassPair(<span class="params">baseClass</span>, <span class="params">subclassName</span>, 0)</span>;</span><br><span class="line">		<span class="keyword">if</span> (subclass<span class="operator"> == </span>nil) &#123;</span><br><span class="line">            NSString *errrorDesc = <span class="literal">[NSS<span class="identifier">tring</span> <span class="identifier">stringWithFormat</span>:@&quot;<span class="identifier">objc_allocateClassPair</span> <span class="identifier">failed</span> <span class="identifier">to</span> <span class="identifier">allocate</span> <span class="identifier">class</span> %<span class="identifier">s</span>.&quot;, <span class="identifier">subclassName</span>]</span>;</span><br><span class="line">            <span class="constructor">AspectError(AspectErrorFailedToAllocateClassPair, <span class="params">errrorDesc</span>)</span>;</span><br><span class="line">            return nil;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这里是关键</span></span><br><span class="line">		aspect<span class="constructor">_swizzleForwardInvocation(<span class="params">subclass</span>)</span>;</span><br><span class="line">        <span class="comment">//把class的实例方法替换成返回statedClass，也就是说把调用class时候的isa指向了statedClass了。</span></span><br><span class="line">		aspect<span class="constructor">_hookedGetClass(<span class="params">subclass</span>, <span class="params">statedClass</span>)</span>;</span><br><span class="line">		aspect<span class="constructor">_hookedGetClass(<span class="params">object_getClass</span>(<span class="params">subclass</span>)</span>, statedClass);</span><br><span class="line">		objc<span class="constructor">_registerClassPair(<span class="params">subclass</span>)</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//将当前实例对象的class替换为添加AspectsSubclassSuffix的类</span></span><br><span class="line">    <span class="comment">//所有的 swizzling 操作都发生在子类，这样做的好处是你不需要去更改对象本身的类，</span></span><br><span class="line">    <span class="comment">//也就是，当你在 remove aspects 的时候，如果发现当前对象的 aspect 都被移除了，那么，你可以将 isa 指针重新指回对象本身的类，从而消除了该对象的 swizzling ,</span></span><br><span class="line">    <span class="comment">//同时也不会影响到其他该类的不同对象)这样对原来替换的类或者对象没有任何影响而且可以在子类基础上新增或者删除aspect。</span></span><br><span class="line">	<span class="keyword">object</span><span class="constructor">_setClass(<span class="params">self</span>, <span class="params">subclass</span>)</span>;</span><br><span class="line">    <span class="comment">//hookClass阶段就完成了，成功的把self hook成了其子类 xxx_Aspects_</span></span><br><span class="line">	return subclass;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>aspect_hookClass 方法中会通过objc_allocateClassPair来创建一个“类名+_Aspects_”结尾的新类作为baseClass的子类。并且通过aspect_swizzleForwardInvocation将当前类forwardInvocation方法的实现为__ASPECTS_ARE_BEING_CALLED__。然后将当前实例对象的class替换为添加AspectsSubclassSuffix的类，所有的 swizzling 操作都发生在子类，这样做的好处是你不需要去更改对象本身的类，也就是，当你在remove aspects 的时候，如果发现当前对象的 aspect 都被移除了，那么我们可以将 isa 指针重新指回对象本身的类，从而消除了该对象的 swizzling ,同时也不会影响到其他该类的不同对象，这样对原来替换的类或者对象没有任何影响而且可以在子类基础上新增或者删除aspect。</p>
<p>我们看下消息转发方法的替换：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">static NSString *const AspectsForwardInvocationSelectorName = @<span class="string">&quot;__aspects_forwardInvocation:&quot;</span>;</span><br><span class="line">static void aspect<span class="constructor">_swizzleForwardInvocation(Class <span class="params">klass</span>)</span> &#123;</span><br><span class="line">    <span class="constructor">NSCParameterAssert(<span class="params">klass</span>)</span>;</span><br><span class="line">    <span class="comment">//主要作用是替换当前类forwardInvocation方法的实现为__ASPECTS_ARE_BEING_CALLED__</span></span><br><span class="line">    IMP originalImplementation = <span class="keyword">class</span><span class="constructor">_replaceMethod(<span class="params">klass</span>, @<span class="params">selector</span>(<span class="params">forwardInvocation</span>:)</span>, (IMP)__ASPECTS_ARE_BEING_CALLED__, <span class="string">&quot;v@:@&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (originalImplementation) &#123;</span><br><span class="line">        <span class="comment">//当调用forwardInvocation进行消息分发的时候会调用__ASPECTS_ARE_BEING_CALLED__ ，__ASPECTS_ARE_BEING_CALLED__ 的selector为 __aspects_forwardInvocation</span></span><br><span class="line">        <span class="keyword">class</span><span class="constructor">_addMethod(<span class="params">klass</span>, NSSelectorFromString(AspectsForwardInvocationSelectorName)</span>, originalImplementation, <span class="string">&quot;v@:@&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果klass没有实现forwardInvocation就会添加forwardInvocation方法并指向__ASPECTS_ARE_BEING_CALLED__实现，这种情况originalImplementation返回的是nil，所以不会走下面的流程，也就是说如果原来方法没有forwardInvocation，则会添加forwardInvocation方法，如果有的话将会替换forwardInvocation的实现为__ASPECTS_ARE_BEING_CALLED__，并新建一个方法__aspects_forwardInvocation指向原先已经实现的forwardInvocation，也就是说经过aspect_swizzleForwardInvocation处理后，klass中一定有一个forwardInvocation方法指向__ASPECTS_ARE_BEING_CALLED__，如果原来有的情况下还会多出一个__aspects_forwardInvocation指向原来的forwardInvocation。</p>
<p>我们再来看下****<strong>ASPECTS_ARE_BEING_CALLED</strong>****</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">static void <span class="constructor">__ASPECTS_ARE_BEING_CALLED__(<span class="params">__unsafe_unretained</span> NSObject <span class="operator">*</span><span class="params">self</span>, SEL <span class="params">selector</span>, NSInvocation <span class="operator">*</span><span class="params">invocation</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取原始的selector</span></span><br><span class="line">    SEL originalSelector = invocation.selector;</span><br><span class="line">    <span class="comment">//获取带有aspects_xxxx前缀的方法</span></span><br><span class="line">	SEL aliasSelector = aspect<span class="constructor">_aliasForSelector(<span class="params">invocation</span>.<span class="params">selector</span>)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将当前请求selector替换为aspects_xxxx</span></span><br><span class="line">    <span class="comment">//比如调用sel1---&gt;aspects_sel1---&gt;AspectContainer</span></span><br><span class="line">    invocation.selector = aliasSelector;</span><br><span class="line">    <span class="comment">//获取实例对象的容器objectContainer，这里是之前aspect_add关联过的对象。</span></span><br><span class="line">    AspectsContainer *objectContainer = objc<span class="constructor">_getAssociatedObject(<span class="params">self</span>, <span class="params">aliasSelector</span>)</span>;</span><br><span class="line">    <span class="comment">//获取获得类对象容器classContainer</span></span><br><span class="line">    AspectsContainer *classContainer = aspect<span class="constructor">_getContainerForClass(<span class="params">object_getClass</span>(<span class="params">self</span>)</span>, aliasSelector);</span><br><span class="line">    <span class="comment">//初始化AspectInfo，传入self、invocation参数</span></span><br><span class="line">    AspectInfo *info = <span class="literal">[[A<span class="identifier">spectInfo</span> <span class="identifier">alloc</span>]</span> initWithInstance:self invocation:invocation];</span><br><span class="line">    NSArray *aspectsToRemove = nil;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Before hooks.</span></span><br><span class="line">    aspect<span class="constructor">_invoke(<span class="params">classContainer</span>.<span class="params">beforeAspects</span>, <span class="params">info</span>)</span>;</span><br><span class="line">    aspect<span class="constructor">_invoke(<span class="params">objectContainer</span>.<span class="params">beforeAspects</span>, <span class="params">info</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Instead hooks.</span></span><br><span class="line">    BOOL respondsToAlias = YES;</span><br><span class="line">    <span class="keyword">if</span> (objectContainer.insteadAspects.count<span class="operator"> || </span>classContainer.insteadAspects.count) &#123;</span><br><span class="line">        aspect<span class="constructor">_invoke(<span class="params">classContainer</span>.<span class="params">insteadAspects</span>, <span class="params">info</span>)</span>;</span><br><span class="line">        aspect<span class="constructor">_invoke(<span class="params">objectContainer</span>.<span class="params">insteadAspects</span>, <span class="params">info</span>)</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        Class klass = <span class="keyword">object</span><span class="constructor">_getClass(<span class="params">invocation</span>.<span class="params">target</span>)</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> ((respondsToAlias = <span class="literal">[<span class="identifier">klass</span> <span class="identifier">instancesRespondToSelector</span>:<span class="identifier">aliasSelector</span>]</span>)) &#123;</span><br><span class="line">                <span class="literal">[<span class="identifier">invocation</span> <span class="identifier">invoke</span>]</span>;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">while</span> (!respondsToAlias<span class="operator"> &amp;&amp; </span>(klass = <span class="keyword">class</span><span class="constructor">_getSuperclass(<span class="params">klass</span>)</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// After hooks.</span></span><br><span class="line">    aspect<span class="constructor">_invoke(<span class="params">classContainer</span>.<span class="params">afterAspects</span>, <span class="params">info</span>)</span>;</span><br><span class="line">    aspect<span class="constructor">_invoke(<span class="params">objectContainer</span>.<span class="params">afterAspects</span>, <span class="params">info</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果hook没有被正常执行，那么就应该执行原来的方法。</span></span><br><span class="line">    <span class="comment">// If no hooks are installed, call original implementation (usually to throw an exception)</span></span><br><span class="line">    <span class="keyword">if</span> (!respondsToAlias) &#123;</span><br><span class="line">        invocation.selector = originalSelector;</span><br><span class="line">        SEL originalForwardInvocationSEL = <span class="constructor">NSSelectorFromString(AspectsForwardInvocationSelectorName)</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">[<span class="identifier">self</span> <span class="identifier">respondsToSelector</span>:<span class="identifier">originalForwardInvocationSEL</span>]</span>) &#123;</span><br><span class="line">            ((void( *)(id, SEL, NSInvocation *))objc_msgSend)(self, originalForwardInvocationSEL, invocation);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="literal">[<span class="identifier">self</span> <span class="identifier">doesNotRecognizeSelector</span>:<span class="identifier">invocation</span>.<span class="identifier">selector</span>]</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Remove any hooks that are queued for deregistration.</span></span><br><span class="line">    <span class="literal">[<span class="identifier">aspectsToRemove</span> <span class="identifier">makeObjectsPerformSelector</span>:@<span class="identifier">selector</span>(<span class="identifier">remove</span>)]</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先进入这里的时候会通过关联属性来获取aspect_selector对应的属性值，如果有被hook的话则会获取到存放hook切片信息的切片容器AspectsContainer。我们使用invocation信息创建AspectInfo，<br>然后调用aspect_invoke宏来执行AspectsContainer中的beforeAspects，insteadAspects，以及afterAspects，如果insteadAspects为空的话，则直接执行子类的aliasSelector。我们之前已经提到过了，在aspect_prepareClassAndHookSelector方法中会在子类添加一个aspect_selector的方法它指向selector实现，所以这里会执行原来方法中的selector。如果respondsToAlias &#x3D; NO 表示instancesRespondToSelector返回NO,表示调用了一个没有实现的方法，所以走原来类的消息转发机制。</p>
<p>我们最后再来看下aspect_invoke这个宏：</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">#define aspect_invoke(aspects, info) \</span></span><br><span class="line"><span class="keyword">for</span> (AspectIdentifier *aspect <span class="keyword">in</span> aspects) &#123;<span class="string">\</span></span><br><span class="line">    [aspect invokeWithInfo:info];<span class="string">\</span></span><br><span class="line">    <span class="keyword">if</span> (aspect.options &amp; AspectOptionAutomaticRemoval) &#123; <span class="string">\</span></span><br><span class="line">        aspectsToRemove = [aspectsToRemove?:@[] arrayByAddingObject:aspect]; <span class="string">\</span></span><br><span class="line">    &#125; <span class="string">\</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里会遍历aspects中的AspectIdentifier，并调用invokeWithInfo执行对应的block。如果切片类型为AspectOptionAutomaticRemoval，则触发后将它移除。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">BOOL</span>)invokeWithInfo:(<span class="type">id</span>&lt;AspectInfo&gt;)info &#123;</span><br><span class="line">    <span class="comment">//block的调度者封装</span></span><br><span class="line">    <span class="built_in">NSInvocation</span> *blockInvocation = [<span class="built_in">NSInvocation</span> invocationWithMethodSignature:<span class="keyword">self</span>.blockSignature];</span><br><span class="line">    <span class="comment">//原始调度者的封装</span></span><br><span class="line">    <span class="built_in">NSInvocation</span> *originalInvocation = info.originalInvocation;</span><br><span class="line">    <span class="built_in">NSUInteger</span> numberOfArguments = <span class="keyword">self</span>.blockSignature.numberOfArguments;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Be extra paranoid. We already check that on hook registration.</span></span><br><span class="line">    <span class="keyword">if</span> (numberOfArguments &gt; originalInvocation.methodSignature.numberOfArguments) &#123;</span><br><span class="line">        AspectLogError(<span class="string">@&quot;Block has too many arguments. Not calling %@&quot;</span>, info);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The `self` of the block will be the AspectInfo. Optional.</span></span><br><span class="line">    <span class="keyword">if</span> (numberOfArguments &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        [blockInvocation setArgument:&amp;info atIndex:<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="type">void</span> *argBuf = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> idx = <span class="number">2</span>; idx &lt; numberOfArguments; idx++) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="type">char</span> *type = [originalInvocation.methodSignature getArgumentTypeAtIndex:idx];</span><br><span class="line">		<span class="built_in">NSUInteger</span> argSize;</span><br><span class="line">		<span class="built_in">NSGetSizeAndAlignment</span>(type, &amp;argSize, <span class="literal">NULL</span>);</span><br><span class="line">        </span><br><span class="line">		<span class="keyword">if</span> (!(argBuf = reallocf(argBuf, argSize))) &#123;</span><br><span class="line">            AspectLogError(<span class="string">@&quot;Failed to allocate memory for block invocation.&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">//循环把originalInvocation中取出参数，赋值到argBuf中，然后再赋值到blockInvocation里</span></span><br><span class="line">		[originalInvocation getArgument:argBuf atIndex:idx];</span><br><span class="line">		[blockInvocation setArgument:argBuf atIndex:idx];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最后把self.block赋值给blockInvocation的Target</span></span><br><span class="line">    [blockInvocation invokeWithTarget:<span class="keyword">self</span>.block];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (argBuf != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        free(argBuf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>invokeWithInfo 方法中主要将原先selector的方法参数，提取出来，传到block上，再通过invokeWithTarget执行block。</p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h5><p>最后我们来做个总结：<br>在我们hook某个方法的时候会在当前类上添加一个名字为aspect_selector的关联属性，这个关联属性类型为AspectContainer它是用于存放该selector相关的切片的容器，容器里面有三个数组，分别存放着<br>不同AspectOptions的AspectIdentifier,每个AspectIdentifier都包含着一个切片的具体信息。紧接着会创建一个以_Aspects_结尾的类作为当前类的子类，这里类里面会添加一个方法名称为aspect_selector的方法，方法的实现指向原来的selector实现。并且会为该子类添加一个指向__ASPECTS_ARE_BEING_CALLED__的forwardInvocation方法。如果原来的类已经实现了forwardInvocation，就会添加一个__aspects_forwardInvocation方法指向原先已经实现的forwardInvocation。这个方法会在Aspect消息转发机制走不通的情况下走这里的消息转发。</p>
<p>这以后再将子类的selector方法调用替换为Aspect消息转发,这样我们调用这个selector的时候就会通过Aspect 消息转发进入__ASPECTS_ARE_BEING_CALLED__，在__ASPECTS_ARE_BEING_CALLED__中会先尝试取出之前的关联属性的切片容器，执行容器内的切片block，在这会如果instead切片为空的时候会调用aspect_selector，由于上面已经将aspect_selector指向原来的selector实现，所以这里会有机会调用原来类的selector方法。如果原来类不能响应selector方法，那么就走原来类的forwardInvocation，进行消息转发。</p>
<p><strong><strong>重要的类及关系介绍:</strong></strong><br><img src="/2019/10/12/%E5%9B%BE%E8%A7%A3iOS%E7%B3%BB%E5%88%97%E4%B9%8BAspect-%E4%B8%80-%E9%87%8D%E8%A6%81%E7%9A%84%E7%B1%BB%E5%8F%8A%E5%85%B3%E7%B3%BB%E4%BB%8B%E7%BB%8D/001.png"><br>****Hook流程图:****：<br><img src="/2019/10/12/%E5%9B%BE%E8%A7%A3iOS%E7%B3%BB%E5%88%97%E4%B9%8BAspect-%E4%B8%80-%E9%87%8D%E8%A6%81%E7%9A%84%E7%B1%BB%E5%8F%8A%E5%85%B3%E7%B3%BB%E4%BB%8B%E7%BB%8D/001.png"></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/iOS-%E5%BC%80%E6%BA%90%E5%BA%93%E5%88%86%E6%9E%90/">iOS 开源库分析</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/iOS-开源库分析/">iOS 开源库分析</a>
  </div>

</div>



<div class="comments-count">
	
	  	<span></span>
		<a href="/2019/10/12/图解iOS系列之Aspect-一-重要的类及关系介绍/#comments" class="ds-thread-count comments-count-link" data-thread-key="2019/10/12/图解iOS系列之Aspect-一-重要的类及关系介绍/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/10/08/图解iOS系列之JSPatch-一-源码分析/" title="JSPatch 源码分析" itemprop="url">JSPatch 源码分析</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Edgar" target="_blank" itemprop="author">Edgar</a>
		
  <p class="article-time">
    <time datetime="2019-10-08T15:13:05.000Z" itemprop="datePublished"> Published 2019-10-08</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h5 id="源码信息"><a href="#源码信息" class="headerlink" title="源码信息"></a>源码信息</h5><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/bang590/JSPatch">JSPatch</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/bang590/JSPatch/wiki">JSPatch Wiki</a></li>
<li><a target="_blank" rel="noopener" href="https://jspatch.com/">JSPatch SDK</a></li>
<li><a target="_blank" rel="noopener" href="http://bang590.github.io/JSPatchConvertor/">JSPatchConvertor</a></li>
</ul>
<p>JSPatch是iOS平台上的热修复方案，至于什么是热修复以及使用JSPatch是否会被苹果官方拒绝上架，这里不做介绍，这篇博客只关注JSPatch 源码本身。带大家过下JSPatch的源码。</p>
<h5 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h5><p><strong><strong>用例情景</strong></strong></p>
<p>JSPatch核心代码很精简但是这不意味着简单，还是需要仔细啃才能够理解它的思想。</p>
<p>我们先看下JSPatchDemo中的用法例子：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">[JPEngine startEngine];</span><br><span class="line"><span class="built_in">NSString</span> *sourcePath = [[<span class="built_in">NSBundle</span> mainBundle] pathForResource:<span class="string">@&quot;demo&quot;</span> ofType:<span class="string">@&quot;js&quot;</span>];</span><br><span class="line"><span class="built_in">NSString</span> *script = [<span class="built_in">NSString</span> stringWithContentsOfFile:sourcePath encoding:<span class="built_in">NSUTF8StringEncoding</span> error:<span class="literal">nil</span>];[JPEngine evaluateScript:script];</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>在例子中首先启动JPEngine，紧接着会去加载本地的demo.js。然后在JPEngine中执行本地的demo.js脚本。</p>
<p>我们看下原先的RootViewController <strong><strong>JPViewController</strong></strong>:</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&quot;JPViewController.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">JPViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="variable language_">super</span> viewDidLoad];</span><br><span class="line">    <span class="built_in">UIButton</span> *btn = [[<span class="built_in">UIButton</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">100</span>, [<span class="built_in">UIScreen</span> mainScreen].bounds.size.width, <span class="number">50</span>)];</span><br><span class="line">    [btn setTitle:<span class="string">@&quot;Push JPTableViewController&quot;</span> forState:<span class="built_in">UIControlStateNormal</span>];</span><br><span class="line">    [btn addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(handleBtn:) forControlEvents:<span class="built_in">UIControlEventTouchUpInside</span>];</span><br><span class="line">    [btn setBackgroundColor:[<span class="built_in">UIColor</span> grayColor]];</span><br><span class="line">    [<span class="keyword">self</span>.view addSubview:btn];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)handleBtn:(<span class="type">id</span>)sender &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>整个界面上有一个按钮，点击它会执行handleBtn方法，但是handleBtn目前是一个空方法，但是如果你将整个demo项目跑起来后会发现点击的时候会弹出一个TableView。但是如果注释掉之前将的JPEngine相关代码，点击就不会有任何响应，所以可以确定是JPEngine搞的鬼。我们看下demo.js:</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">defineClass(&#x27;JPViewController&#x27;, &#123;</span><br><span class="line">  handleBtn: function(<span class="name">sender</span>) &#123;</span><br><span class="line">    var tableViewCtrl = JPTableViewController.alloc().init()</span><br><span class="line">    self.navigationController().pushViewController_animated(<span class="name">tableViewCtrl</span>, YES)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">defineClass(&#x27;JPTableViewController : UITableViewController &lt;UIAlertViewDelegate&gt;&#x27;, [&#x27;data&#x27;], &#123;</span><br><span class="line">  dataSource: function() &#123;</span><br><span class="line">    var data = self.data()<span class="comment">;</span></span><br><span class="line">    if (<span class="name">data</span>) return data<span class="comment">;</span></span><br><span class="line">    var data = []<span class="comment">;</span></span><br><span class="line">    for (<span class="name">var</span> i = <span class="number">0</span><span class="comment">; i &lt; 20; i ++) &#123;</span></span><br><span class="line">      data.push(<span class="string">&quot;cell from js &quot;</span> + i)<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">    self.setData(<span class="name">data</span>)</span><br><span class="line">    return data<span class="comment">;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  numberOfSectionsInTableView: function(<span class="name">tableView</span>) &#123;</span><br><span class="line">    return <span class="number">1</span><span class="comment">;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  tableView_numberOfRowsInSection: function(<span class="name">tableView</span>, section) &#123;</span><br><span class="line">    return self.dataSource().length<span class="comment">;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  tableView_cellForRowAtIndexPath: function(<span class="name">tableView</span>, indexPath) &#123;</span><br><span class="line">    var cell = tableView.dequeueReusableCellWithIdentifier(<span class="string">&quot;cell&quot;</span>) </span><br><span class="line">    if (!cell) &#123;</span><br><span class="line">      cell = require(&#x27;UITableViewCell&#x27;).alloc().initWithStyle_reuseIdentifier(<span class="number">0</span>, <span class="string">&quot;cell&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    cell.textLabel().setText(<span class="name">self</span>.dataSource()[indexPath.row()])</span><br><span class="line">    return cell</span><br><span class="line">  &#125;,</span><br><span class="line">  tableView_heightForRowAtIndexPath: function(<span class="name">tableView</span>, indexPath) &#123;</span><br><span class="line">    return <span class="number">60</span></span><br><span class="line">  &#125;,</span><br><span class="line">  tableView_didSelectRowAtIndexPath: function(<span class="name">tableView</span>, indexPath) &#123;</span><br><span class="line">     var alertView = require(&#x27;UIAlertView&#x27;).alloc().initWithTitle_message_delegate_cancelButtonTitle_otherButtonTitles(<span class="string">&quot;Alert&quot;</span>,self.dataSource()[indexPath.row()], self, <span class="string">&quot;OK&quot;</span>,  null)<span class="comment">;</span></span><br><span class="line">     alertView.show()</span><br><span class="line">  &#125;,</span><br><span class="line">  alertView_willDismissWithButtonIndex: function(<span class="name">alertView</span>, idx) &#123;</span><br><span class="line">    console.log(&#x27;click btn &#x27; + alertView.buttonTitleAtIndex(<span class="name">idx</span>).toJS())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>即使你不懂JavaScript 看到上面的代码估计也可以猜出个大概，它重写了handleBtn方法，在点击的时候会push一个JPTableViewController页面。并且使用JavaScript语言实现了JPTableViewController。也就是说它可以通过动态加载一个js文件，并且在这个js文件中改变现有代码的行为。既然本地的js文件也是需要转换为string后放到JSPatchEngine引擎中执行，如果将这个文件放到服务端下发下去，那么就可以通过后台动态控制我们应用的行为了，是不是很诱人的功能，当然我们不会将它用于实现大需求，一般如果用于修修线上的一些紧急bug还是比较方便的，特别是苹果平台审核周期有时候会比较长。这种情况如果遇到线上的一些崩溃没有热修复，只能和苹果官方沟通来缩短审核的时间，紧急发布修复版本。</p>
<p><strong><strong>JSPatch 引擎初始化</strong></strong></p>
<figure class="highlight wren"><table><tr><td class="code"><pre><span class="line"><span class="operator">+</span> (<span class="variable">void</span>)<span class="title function_">startEngine</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.判断是否存在 JSContext 类. ---&gt; iOS 7.0 以下不支持 JavaScriptCore</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="operator">!</span>[<span class="title class_">JSContext</span> <span class="keyword">class</span>] <span class="operator">||</span> <span class="variable">_context</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.创建一个 JS 运行环境.</span></span><br><span class="line">    <span class="title class_">JSContext</span> <span class="operator">*</span><span class="variable">context</span> <span class="operator">=</span> [[<span class="title class_">JSContext</span> <span class="variable">alloc</span>] init];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3.为了使 JSPatch.js 可以访问 JPEngine 中定义的 C 函数，需为 context 注册 block.</span></span><br><span class="line">    <span class="comment">//3.1 创建类.</span></span><br><span class="line">    <span class="variable">context</span>[@<span class="string">&quot;_OC_defineClass&quot;</span>] <span class="operator">=</span> <span class="title function_">^</span>(<span class="params">NSString</span> *<span class="params">classDeclaration</span>, <span class="params">JSValue</span> *<span class="params">instanceMethods</span>, <span class="params">JSValue</span> *<span class="params">classMethods</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">defineClass</span>(classDeclaration, instanceMethods, classMethods);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3.2 类实现某协议.</span></span><br><span class="line">    <span class="variable">context</span>[@<span class="string">&quot;_OC_defineProtocol&quot;</span>] <span class="operator">=</span> <span class="title function_">^</span>(<span class="params">NSString</span> *<span class="params">protocolDeclaration</span>, <span class="params">JSValue</span> *<span class="params">instProtocol</span>, <span class="params">JSValue</span> *<span class="params">clsProtocol</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">defineProtocol</span>(<span class="variable">protocolDeclaration</span>, instProtocol,<span class="variable">clsProtocol</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3.3 js调用oc的实例方法.</span></span><br><span class="line">    <span class="variable">context</span>[@<span class="string">&quot;_OC_callI&quot;</span>] <span class="operator">=</span> <span class="operator">^</span><span class="title function_">id</span>(<span class="params">JSValue</span> *<span class="params">obj</span>, <span class="params">NSString</span> *<span class="params">selectorName</span>, <span class="params">JSValue</span> *<span class="params">arguments</span>, <span class="params">BOOL</span> <span class="params">isSuper</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">callSelector</span>(<span class="variable">nil</span>, <span class="variable">selectorName</span>, <span class="variable">arguments</span>, <span class="variable">obj</span>, isSuper);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.4 js调用oc的类方法.</span></span><br><span class="line">    <span class="variable">context</span>[@<span class="string">&quot;_OC_callC&quot;</span>] <span class="operator">=</span> <span class="operator">^</span><span class="title function_">id</span>(<span class="params">NSString</span> *<span class="params">className</span>, <span class="params">NSString</span> *<span class="params">selectorName</span>, <span class="params">JSValue</span> *<span class="params">arguments</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">callSelector</span>(className, <span class="variable">selectorName</span>, <span class="variable">arguments</span>, <span class="variable">nil</span>, <span class="variable">NO</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.5 js 对象转 oc 对象.</span></span><br><span class="line">    <span class="variable">context</span>[@<span class="string">&quot;_OC_formatJSToOC&quot;</span>] <span class="operator">=</span> <span class="operator">^</span><span class="title function_">id</span>(<span class="params">JSValue</span> *<span class="params">obj</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">formatJSToOC</span>(<span class="variable">obj</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3.6 oc 对象 转 js 对象.</span></span><br><span class="line">    <span class="variable">context</span>[@<span class="string">&quot;_OC_formatOCToJS&quot;</span>] <span class="operator">=</span> <span class="operator">^</span><span class="title function_">id</span>(<span class="params">JSValue</span> *<span class="params">obj</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">formatOCToJS</span>([<span class="variable">obj</span> <span class="variable">toObject</span>]);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3.7 获取对象的关联属性</span></span><br><span class="line">    <span class="variable">context</span>[@<span class="string">&quot;_OC_getCustomProps&quot;</span>] <span class="operator">=</span> <span class="operator">^</span><span class="title function_">id</span>(<span class="params">JSValue</span> *<span class="params">obj</span>) &#123;</span><br><span class="line">        <span class="variable">id</span> <span class="variable">realObj</span> <span class="operator">=</span> <span class="title function_">formatJSToOC</span>(<span class="variable">obj</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">objc_getAssociatedObject</span>(<span class="variable">realObj</span>, <span class="variable">kPropAssociatedObjectKey</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3.8 给对象动态添加关联属性</span></span><br><span class="line">    <span class="variable">context</span>[@<span class="string">&quot;_OC_setCustomProps&quot;</span>] <span class="operator">=</span> <span class="title function_">^</span>(<span class="params">JSValue</span> *<span class="params">obj</span>, <span class="params">JSValue</span> *<span class="params">val</span>) &#123;</span><br><span class="line">        <span class="variable">id</span> <span class="variable">realObj</span> <span class="operator">=</span> <span class="title function_">formatJSToOC</span>(<span class="variable">obj</span>);</span><br><span class="line">        <span class="title function_">objc_setAssociatedObject</span>(<span class="variable">realObj</span>, <span class="variable">kPropAssociatedObjectKey</span>, <span class="variable">val</span>, <span class="variable">OBJC_ASSOCIATION_RETAIN_NONATOMIC</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3.9 给 js 对象设置 weak.</span></span><br><span class="line">    <span class="variable">context</span>[@<span class="string">&quot;__weak&quot;</span>] <span class="operator">=</span> <span class="operator">^</span><span class="title function_">id</span>(<span class="params">JSValue</span> *<span class="params">jsval</span>) &#123;</span><br><span class="line">        <span class="variable">id</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="title function_">formatJSToOC</span>(<span class="variable">jsval</span>);</span><br><span class="line">        <span class="keyword">return</span> [[<span class="title class_">JSContext</span> <span class="variable">currentContext</span>][@<span class="string">&quot;_formatOCToJS&quot;</span>] <span class="variable">callWithArguments</span>:@[<span class="title function_">formatOCToJS</span>([<span class="title class_">JPBoxing</span> <span class="variable">boxWeakObj</span>:<span class="variable">obj</span>])]];</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.10 给 js 对象设置 strong.</span></span><br><span class="line">    <span class="variable">context</span>[@<span class="string">&quot;__strong&quot;</span>] <span class="operator">=</span> <span class="operator">^</span><span class="title function_">id</span>(<span class="params">JSValue</span> *<span class="params">jsval</span>) &#123;</span><br><span class="line">        <span class="variable">id</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="title function_">formatJSToOC</span>(<span class="variable">jsval</span>);</span><br><span class="line">        <span class="keyword">return</span> [[<span class="title class_">JSContext</span> <span class="variable">currentContext</span>][@<span class="string">&quot;_formatOCToJS&quot;</span>] <span class="variable">callWithArguments</span>:@[<span class="title function_">formatOCToJS</span>(<span class="variable">obj</span>)]];</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3.11 获取 oc 对象的父类.</span></span><br><span class="line">    <span class="variable">context</span>[@<span class="string">&quot;_OC_superClsName&quot;</span>] <span class="operator">=</span> <span class="title function_">^</span>(<span class="params">NSString</span> *<span class="params">clsName</span>) &#123;</span><br><span class="line">        <span class="title class_">Class</span> <span class="variable">cls</span> <span class="operator">=</span> <span class="title class_">NSClassFromString</span>(<span class="variable">clsName</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">NSStringFromClass</span>([<span class="variable">cls</span> superclass]);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3.12 是否自动转换类型.</span></span><br><span class="line">    <span class="variable">context</span>[@<span class="string">&quot;autoConvertOCType&quot;</span>] <span class="operator">=</span> <span class="title function_">^</span>(<span class="params">BOOL</span> <span class="params">autoConvert</span>) &#123;</span><br><span class="line">        <span class="variable">_autoConvert</span> <span class="operator">=</span> <span class="variable">autoConvert</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.13 oc number 转换为 string.</span></span><br><span class="line">    <span class="variable">context</span>[@<span class="string">&quot;convertOCNumberToString&quot;</span>] <span class="operator">=</span> <span class="title function_">^</span>(<span class="params">BOOL</span> <span class="params">convertOCNumberToString</span>) &#123;</span><br><span class="line">        <span class="variable">_convertOCNumberToString</span> <span class="operator">=</span> <span class="variable">convertOCNumberToString</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3.14 在JS中调用include方法,可以在一个JS文件中加载其他JS文件.</span></span><br><span class="line">    <span class="variable">context</span>[@<span class="string">&quot;include&quot;</span>] <span class="operator">=</span> <span class="title function_">^</span>(<span class="params">NSString</span> *<span class="params">filePath</span>) &#123;</span><br><span class="line">        <span class="title class_">NSString</span> <span class="operator">*</span><span class="variable">absolutePath</span> <span class="operator">=</span> [<span class="variable">_scriptRootDir</span> <span class="variable">stringByAppendingPathComponent</span>:<span class="variable">filePath</span>];</span><br><span class="line">        <span class="keyword">if</span> (<span class="operator">!</span><span class="variable">_runnedScript</span>) &#123;</span><br><span class="line">            <span class="variable">_runnedScript</span> <span class="operator">=</span> [[<span class="title class_">NSMutableSet</span> <span class="variable">alloc</span>] init];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">absolutePath</span> <span class="operator">&amp;&amp;</span> <span class="operator">!</span>[<span class="variable">_runnedScript</span> <span class="variable">containsObject</span>:<span class="variable">absolutePath</span>]) &#123;</span><br><span class="line">            [<span class="title class_">JPEngine</span> <span class="variable">_evaluateScriptWithPath</span>:<span class="variable">absolutePath</span>];</span><br><span class="line">            [<span class="variable">_runnedScript</span> <span class="variable">addObject</span>:<span class="variable">absolutePath</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//3.15 获取资源文件路径.</span></span><br><span class="line">    <span class="variable">context</span>[@<span class="string">&quot;resourcePath&quot;</span>] <span class="operator">=</span> <span class="title function_">^</span>(<span class="params">NSString</span> *<span class="params">filePath</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="variable">_scriptRootDir</span> <span class="variable">stringByAppendingPathComponent</span>:<span class="variable">filePath</span>];</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.16 让 js 方法延迟执行.</span></span><br><span class="line">    <span class="variable">context</span>[@<span class="string">&quot;dispatch_after&quot;</span>] <span class="operator">=</span> <span class="title function_">^</span>(<span class="params">double</span> <span class="params">time</span>, <span class="params">JSValue</span> *<span class="params">func</span>) &#123;</span><br><span class="line">        <span class="title function_">dispatch_after</span>(<span class="title function_">dispatch_time</span>(<span class="variable">DISPATCH_TIME_NOW</span>, (int64_t)(<span class="variable">time</span> <span class="operator">*</span> <span class="variable">NSEC_PER_SEC</span>)), <span class="title function_">dispatch_get_main_queue</span>(), <span class="operator">^</span>&#123;</span><br><span class="line">            [<span class="variable">func</span> <span class="variable">callWithArguments</span>:<span class="variable">nil</span>];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3.17 让js方法在 main queue dispatch async 执行.</span></span><br><span class="line">    <span class="variable">context</span>[@<span class="string">&quot;dispatch_async_main&quot;</span>] <span class="operator">=</span> <span class="title function_">^</span>(<span class="params">JSValue</span> *<span class="params">func</span>) &#123;</span><br><span class="line">        <span class="title function_">dispatch_async</span>(<span class="title function_">dispatch_get_main_queue</span>(), <span class="operator">^</span>&#123;</span><br><span class="line">            [<span class="variable">func</span> <span class="variable">callWithArguments</span>:<span class="variable">nil</span>];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3.18 让js方法在 main queue dispatch sync 执行.</span></span><br><span class="line">    <span class="variable">context</span>[@<span class="string">&quot;dispatch_sync_main&quot;</span>] <span class="operator">=</span> <span class="title function_">^</span>(<span class="params">JSValue</span> *<span class="params">func</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([<span class="title class_">NSThread</span> <span class="variable">currentThread</span>].<span class="property">isMainThread</span>) &#123;</span><br><span class="line">            [<span class="variable">func</span> <span class="variable">callWithArguments</span>:<span class="variable">nil</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="title function_">dispatch_sync</span>(<span class="title function_">dispatch_get_main_queue</span>(), <span class="operator">^</span>&#123;</span><br><span class="line">                [<span class="variable">func</span> <span class="variable">callWithArguments</span>:<span class="variable">nil</span>];</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3.19 让js方法在 global queue dispatch async 执行.</span></span><br><span class="line">    <span class="variable">context</span>[@<span class="string">&quot;dispatch_async_global_queue&quot;</span>] <span class="operator">=</span> <span class="title function_">^</span>(<span class="params">JSValue</span> *<span class="params">func</span>) &#123;</span><br><span class="line">        <span class="title function_">dispatch_async</span>(<span class="title function_">dispatch_get_global_queue</span>(<span class="number">0</span>, <span class="number">0</span>), <span class="operator">^</span>&#123;</span><br><span class="line">            [<span class="variable">func</span> <span class="variable">callWithArguments</span>:<span class="variable">nil</span>];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3.20 释放js创建的oc对象.</span></span><br><span class="line">    <span class="variable">context</span>[@<span class="string">&quot;releaseTmpObj&quot;</span>] <span class="operator">=</span> <span class="operator">^</span><span class="title function_">void</span>(<span class="params">JSValue</span> *<span class="params">jsVal</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([[<span class="variable">jsVal</span> <span class="variable">toObject</span>] isKindOfClass:[<span class="title class_">NSDictionary</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">            <span class="variable">void</span> <span class="operator">*</span><span class="variable">pointer</span> <span class="operator">=</span>  [(<span class="title class_">JPBoxing</span> <span class="operator">*</span>)([<span class="variable">jsVal</span> <span class="variable">toObject</span>][@<span class="string">&quot;__obj&quot;</span>]) <span class="variable">unboxPointer</span>];</span><br><span class="line">            <span class="variable">id</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="operator">*</span>((<span class="variable">__unsafe_unretained</span> <span class="variable">id</span> <span class="operator">*</span>)<span class="variable">pointer</span>);</span><br><span class="line">            @<span class="title function_">synchronized</span>(_<span class="params">TMPMemoryPool</span>) &#123;</span><br><span class="line">                [<span class="variable">_TMPMemoryPool</span> <span class="variable">removeObjectForKey</span>:[<span class="title class_">NSNumber</span> <span class="variable">numberWithInteger</span>:[(<span class="title class_">NSObject</span><span class="operator">*</span>)<span class="variable">obj</span> <span class="variable">hash</span>]]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3.21 js调用oc方法进行打印.</span></span><br><span class="line">    <span class="variable">context</span>[@<span class="string">&quot;_OC_log&quot;</span>] <span class="operator">=</span> <span class="operator">^</span>() &#123;</span><br><span class="line">        <span class="title class_">NSArray</span> <span class="operator">*</span><span class="variable">args</span> <span class="operator">=</span> [<span class="title class_">JSContext</span> <span class="variable">currentArguments</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="title class_">JSValue</span> <span class="operator">*</span><span class="variable">jsVal</span> <span class="keyword">in</span> <span class="variable">args</span>) &#123;</span><br><span class="line">            <span class="variable">id</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="title function_">formatJSToOC</span>(<span class="variable">jsVal</span>);</span><br><span class="line">            <span class="title class_">NSLog</span>(@<span class="string">&quot;JSPatch.log: %@&quot;</span>, <span class="variable">obj</span> <span class="operator">==</span> <span class="variable">_nilObj</span> ? <span class="variable">nil</span> : (<span class="variable">obj</span> <span class="operator">==</span> <span class="variable">_nullObj</span> ? [<span class="title class_">NSNull</span> <span class="literal">null</span>]: <span class="variable">obj</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3.22 将js捕捉到的异常交给oc方法处理.</span></span><br><span class="line">    <span class="variable">context</span>[@<span class="string">&quot;_OC_catch&quot;</span>] <span class="operator">=</span> <span class="title function_">^</span>(<span class="params">JSValue</span> *<span class="params">msg</span>, <span class="params">JSValue</span> *<span class="params">stack</span>) &#123;</span><br><span class="line">        <span class="variable">_exceptionBlock</span>([<span class="title class_">NSString</span> <span class="variable">stringWithFormat</span>:@<span class="string">&quot;js exception, <span class="char escape_">\n</span>msg: %@, <span class="char escape_">\n</span>stack: <span class="char escape_">\n</span> %@&quot;</span>, [<span class="variable">msg</span> <span class="variable">toObject</span>], [<span class="variable">stack</span> <span class="variable">toObject</span>]]);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//4. 注册 JSContext 执行出现异常时的回调.</span></span><br><span class="line">    <span class="variable">context</span>.<span class="property">exceptionHandler</span> <span class="operator">=</span> <span class="title function_">^</span>(<span class="params">JSContext</span> *<span class="params">con</span>, <span class="params">JSValue</span> *<span class="params">exception</span>) &#123;</span><br><span class="line">        <span class="title class_">NSLog</span>(@<span class="string">&quot;%@&quot;</span>, <span class="variable">exception</span>);</span><br><span class="line">        <span class="variable">_exceptionBlock</span>([<span class="title class_">NSString</span> <span class="variable">stringWithFormat</span>:@<span class="string">&quot;js exception: %@&quot;</span>, <span class="variable">exception</span>]);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//5. 创建OC中的null对象，转换成js的null对象，并设置到JSContext实例让js代码可以获取.</span></span><br><span class="line">    <span class="variable">_nullObj</span> <span class="operator">=</span> [[<span class="title class_">NSObject</span> <span class="variable">alloc</span>] init];</span><br><span class="line">    <span class="variable">context</span>[@<span class="string">&quot;_OC_null&quot;</span>] <span class="operator">=</span> <span class="title function_">formatOCToJS</span>(<span class="variable">_nullObj</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//6. 保存 context.</span></span><br><span class="line">    <span class="variable">_context</span> <span class="operator">=</span> <span class="variable">context</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//7. oc 中的 nil 对象.</span></span><br><span class="line">    <span class="variable">_nilObj</span> <span class="operator">=</span> [[<span class="title class_">NSObject</span> <span class="variable">alloc</span>] init];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//8. 同步锁.</span></span><br><span class="line">    <span class="variable">_JSMethodSignatureLock</span> <span class="operator">=</span> [[<span class="title class_">NSLock</span> <span class="variable">alloc</span>] init];</span><br><span class="line">    <span class="variable">_JSMethodForwardCallLock</span> <span class="operator">=</span> [[<span class="title class_">NSRecursiveLock</span> <span class="variable">alloc</span>] init];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//9. 在 JSPatch 中注册过的结构体定义（键：结构体名）.</span></span><br><span class="line">    <span class="variable">_registeredStruct</span> <span class="operator">=</span> [[<span class="title class_">NSMutableDictionary</span> <span class="variable">alloc</span>] init];</span><br><span class="line">    <span class="variable">_currInvokeSuperClsName</span> <span class="operator">=</span> [[<span class="title class_">NSMutableDictionary</span> <span class="variable">alloc</span>] init];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//10. 注册内存警告通知.</span></span><br><span class="line">    [[<span class="title class_">NSNotificationCenter</span> <span class="variable">defaultCenter</span>] <span class="variable">addObserver</span>:<span class="variable">self</span> <span class="variable">selector</span>:@<span class="title function_">selector</span>(<span class="variable">handleMemoryWarning</span>) <span class="variable">name</span>:<span class="title class_">UIApplicationDidReceiveMemoryWarningNotification</span> <span class="variable">object</span>:<span class="variable">nil</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//11. 读取JSPatch.js，方便传入的js代码中使用JSPatch.js提供的函数.</span></span><br><span class="line">    <span class="title class_">NSString</span> <span class="operator">*</span><span class="variable">path</span> <span class="operator">=</span> [[<span class="title class_">NSBundle</span> <span class="variable">bundleForClass</span>:[<span class="variable">self</span> <span class="keyword">class</span>]] <span class="variable">pathForResource</span>:@<span class="string">&quot;JSPatch&quot;</span> <span class="variable">ofType</span>:@<span class="string">&quot;js&quot;</span>];</span><br><span class="line">    <span class="keyword">if</span> (<span class="operator">!</span><span class="variable">path</span>) <span class="variable">_exceptionBlock</span>(@<span class="string">&quot;can&#x27;t find JSPatch.js&quot;</span>);</span><br><span class="line">    <span class="title class_">NSString</span> <span class="operator">*</span><span class="variable">jsCore</span> <span class="operator">=</span> [[<span class="title class_">NSString</span> <span class="variable">alloc</span>] initWithData:[[<span class="title class_">NSFileManager</span> <span class="variable">defaultManager</span>] <span class="variable">contentsAtPath</span>:<span class="variable">path</span>] <span class="variable">encoding</span>:<span class="variable">NSUTF8StringEncoding</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//12. 加载 JSPatch.js 中的所有 js 代码到JSContext.</span></span><br><span class="line">    <span class="keyword">if</span> ([<span class="variable">_context</span> <span class="variable">respondsToSelector</span>:@<span class="title function_">selector</span>(<span class="variable">evaluateScript</span>:<span class="variable">withSourceURL</span>:)]) &#123;</span><br><span class="line">        [<span class="variable">_context</span> <span class="variable">evaluateScript</span>:<span class="variable">jsCore</span> <span class="variable">withSourceURL</span>:[<span class="variable">NSURL</span> <span class="title class_">URLWithString</span>:@<span class="string">&quot;JSPatch.js&quot;</span>]];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        [<span class="variable">_context</span> <span class="variable">evaluateScript</span>:<span class="variable">jsCore</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于JSPatch是基于JavaScriptCore的所以在进行JSPatch 引擎初始化的时候会先检查下当前系统中是否支持JavaScriptCore。iOS 7.0 以下不支持 JavaScriptCore 所以在iOS 7.0 以下调用startEngine不会继续执行，直接返回。否则会创建一个JSContext并开始往JSContext里面注册对应的block，这些block会在JSPatch.js 中被调用。然后会注册JSContext 执行出现异常时的回调.最后会加载 JSPatch.js 中的所有 js 代码到JSContext 运行。</p>
<p>在JSPatch.js中会向gloable环境下添加defineClass，require，defineProtocol，block，defineJSClass 这些方法，这些方法可以供我们在热修复js文件中调用。</p>
<p>我们再回到demo.js:</p>
<figure class="highlight zephir"><table><tr><td class="code"><pre><span class="line">defineClass(<span class="string">&#x27;JPTableViewController : UITableViewController &lt;UIAlertViewDelegate&gt;&#x27;</span>, [<span class="string">&#x27;data&#x27;</span>], &#123;</span><br><span class="line">  dataSource: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> data = <span class="keyword">self</span>.data();</span><br><span class="line">    <span class="keyword">if</span> (data) <span class="keyword">return</span> data;</span><br><span class="line">    <span class="keyword">var</span> data = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i ++) &#123;</span><br><span class="line">      data.push(<span class="string">&quot;cell from js &quot;</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">self</span>.setData(data)</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">  &#125;,</span><br><span class="line">  numberOfSectionsInTableView: <span class="function"><span class="keyword">function</span><span class="params">(tableView)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  tableView_numberOfRowsInSection: <span class="function"><span class="keyword">function</span><span class="params">(tableView, section)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.dataSource().length;</span><br><span class="line">  &#125;,</span><br><span class="line">  tableView_cellForRowAtIndexPath: <span class="function"><span class="keyword">function</span><span class="params">(tableView, indexPath)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> cell = tableView.dequeueReusableCellWithIdentifier(<span class="string">&quot;cell&quot;</span>) </span><br><span class="line">    <span class="keyword">if</span> (!cell) &#123;</span><br><span class="line">      cell = <span class="keyword">require</span>(<span class="string">&#x27;UITableViewCell&#x27;</span>).alloc().initWithStyle_reuseIdentifier(<span class="number">0</span>, <span class="string">&quot;cell&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    cell.textLabel().setText(<span class="keyword">self</span>.dataSource()[indexPath.row()])</span><br><span class="line">    <span class="keyword">return</span> cell</span><br><span class="line">  &#125;,</span><br><span class="line">  tableView_heightForRowAtIndexPath: <span class="function"><span class="keyword">function</span><span class="params">(tableView, indexPath)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">60</span></span><br><span class="line">  &#125;,</span><br><span class="line">  tableView_didSelectRowAtIndexPath: <span class="function"><span class="keyword">function</span><span class="params">(tableView, indexPath)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">var</span> alertView = <span class="keyword">require</span>(<span class="string">&#x27;UIAlertView&#x27;</span>).alloc().initWithTitle_message_delegate_cancelButtonTitle_otherButtonTitles(<span class="string">&quot;Alert&quot;</span>,<span class="keyword">self</span>.dataSource()[indexPath.row()], <span class="keyword">self</span>, <span class="string">&quot;OK&quot;</span>,  <span class="keyword">null</span>);</span><br><span class="line">     alertView.show()</span><br><span class="line">  &#125;,</span><br><span class="line">  alertView_willDismissWithButtonIndex: <span class="function"><span class="keyword">function</span><span class="params">(alertView, idx)</span> </span>&#123;</span><br><span class="line">    console.log(<span class="string">&#x27;click btn &#x27;</span> + alertView.buttonTitleAtIndex(idx).toJS())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>上面的defineClass有三个参数，第一个参数是类定义的字符串，第二个[‘data’]代表的是一个类的属性列表，这里只有一个属性参数data。第三个参数是这个类的实例方法列表。</p>
<figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line">global.defineClass = function(declaration<span class="comment">/*定义字符串*/</span>, properties<span class="comment">/*属性*/</span>, instMethods<span class="comment">/*实例方法*/</span>, clsMethods<span class="comment">/*类方法*/</span>) &#123;</span><br><span class="line">    var newInstMethods = &#123;&#125;<span class="comment">/*用于存放新的实例方法*/</span>, newClsMethods = &#123;&#125;<span class="comment">/*用于存放新的类方法*/</span></span><br><span class="line">    <span class="keyword">if</span> (!(properties instanceof Array)) &#123;</span><br><span class="line">      clsMethods = instMethods</span><br><span class="line">      instMethods = properties</span><br><span class="line">      properties = null</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (properties) &#123;</span><br><span class="line">      <span class="comment">//为属性添加Getter/Setter方法</span></span><br><span class="line">      properties.<span class="keyword">forEach</span>(function(<span class="built_in">name</span>)&#123;</span><br><span class="line">        <span class="comment">//在instMethods中添加属性的get方法</span></span><br><span class="line">        <span class="keyword">if</span> (!instMethods[<span class="built_in">name</span>]) &#123;</span><br><span class="line">          instMethods[<span class="built_in">name</span>] = <span class="variable">_propertiesGetFun</span>(<span class="built_in">name</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//在instMethods中添加属性的set方法</span></span><br><span class="line">        var nameOfSet = <span class="string">&quot;set&quot;</span>+ <span class="built_in">name</span>.substr(<span class="number">0</span>,<span class="number">1</span>).toUpperCase() + <span class="built_in">name</span>.substr(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (!instMethods[nameOfSet]) &#123;</span><br><span class="line">          instMethods[nameOfSet] = <span class="variable">_propertiesSetFun</span>(<span class="built_in">name</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//取出实际类名</span></span><br><span class="line">    var realClsName = declaration.split(<span class="string">&#x27;:&#x27;</span>)[<span class="number">0</span>].<span class="built_in">trim</span>()</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//将实例方法和类方法 都转化为 key:方法名 [参数个数:方法实现]的形式 存放在newInstMethods，newClsMethods</span></span><br><span class="line">    <span class="variable">_formatDefineMethods</span>(instMethods, newInstMethods, realClsName)</span><br><span class="line">    <span class="variable">_formatDefineMethods</span>(clsMethods, newClsMethods, realClsName)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用OC的defineClass 进行定义</span></span><br><span class="line">    var ret = <span class="variable">_OC_defineClass</span>(declaration, newInstMethods, newClsMethods)</span><br><span class="line">    var <span class="built_in">className</span> = ret[<span class="string">&#x27;cls&#x27;</span>]</span><br><span class="line">    var superCls = ret[<span class="string">&#x27;superCls&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="variable">_ocCls</span>[<span class="built_in">className</span>] = &#123;</span><br><span class="line">      instMethods: &#123;&#125;,</span><br><span class="line">      clsMethods: &#123;&#125;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (superCls.length &amp;&amp; <span class="variable">_ocCls</span>[superCls]) &#123;</span><br><span class="line">      <span class="keyword">for</span> (var funcName <span class="built_in">in</span> <span class="variable">_ocCls</span>[superCls][<span class="string">&#x27;instMethods&#x27;</span>]) &#123;</span><br><span class="line">        <span class="variable">_ocCls</span>[<span class="built_in">className</span>][<span class="string">&#x27;instMethods&#x27;</span>][funcName] = <span class="variable">_ocCls</span>[superCls][<span class="string">&#x27;instMethods&#x27;</span>][funcName]</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (var funcName <span class="built_in">in</span> <span class="variable">_ocCls</span>[superCls][<span class="string">&#x27;clsMethods&#x27;</span>]) &#123;</span><br><span class="line">        <span class="variable">_ocCls</span>[<span class="built_in">className</span>][<span class="string">&#x27;clsMethods&#x27;</span>][funcName] = <span class="variable">_ocCls</span>[superCls][<span class="string">&#x27;clsMethods&#x27;</span>][funcName]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将自定义的js热修复代码添加到js环境</span></span><br><span class="line">    <span class="variable">_setupJSMethod</span>(<span class="built_in">className</span>, instMethods, <span class="number">1</span>, realClsName)</span><br><span class="line">    <span class="variable">_setupJSMethod</span>(<span class="built_in">className</span>, clsMethods, <span class="number">0</span>, realClsName)</span><br><span class="line"></span><br><span class="line">    return require(<span class="built_in">className</span>)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>JSPatch.js 的defineClass方法中会调用 JSEngine startEngine方法中向JSContext注入的_OC_defineClass block。传入的是这个类的定义，以及实例方法，类方法。其中实例方法和类方法的结构如下：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">key</span>:方法名<span class="meta"> [参数个数:方法实现]</span></span><br></pre></td></tr></table></figure>

<p>我们先来看下_OC_defineClass再回过来看JSPatch.js</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="built_in">context</span>[@<span class="string">&quot;_OC_defineClass&quot;</span>] = ^(NSString *classDeclaration, <span class="keyword">JSValue </span>*<span class="keyword">instanceMethods, </span><span class="keyword">JSValue </span>*classMethods) &#123;</span><br><span class="line">    return defineClass(classDeclaration, <span class="keyword">instanceMethods, </span>classMethods);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">static NSDictionary *define<span class="constructor">Class(NSString <span class="operator">*</span><span class="params">classDeclaration</span>, JSValue <span class="operator">*</span><span class="params">instanceMethods</span>, JSValue <span class="operator">*</span><span class="params">classMethods</span>)</span> &#123;</span><br><span class="line">    <span class="comment">//================================根据JSj脚本实例化出相对应的类====================================================</span></span><br><span class="line">    <span class="comment">//1.使用 NSScanner 分离 classDeclaration.</span></span><br><span class="line">    NSScanner *scanner = <span class="literal">[NSS<span class="identifier">canner</span> <span class="identifier">scannerWithString</span>:<span class="identifier">classDeclaration</span>]</span>;</span><br><span class="line">    </span><br><span class="line">    NSString *className;      <span class="comment">//类名</span></span><br><span class="line">    NSString *superClassName; <span class="comment">//父类名</span></span><br><span class="line">    NSString *protocolNames;  <span class="comment">//实现的协议名</span></span><br><span class="line">    <span class="literal">[<span class="identifier">scanner</span> <span class="identifier">scanUpToString</span>:@&quot;:&quot; <span class="identifier">intoString</span>:&amp;<span class="identifier">className</span>]</span>;</span><br><span class="line">    <span class="keyword">if</span> (!scanner.isAtEnd) &#123;</span><br><span class="line">        scanner.scanLocation = scanner.scanLocation + <span class="number">1</span>;</span><br><span class="line">        <span class="literal">[<span class="identifier">scanner</span> <span class="identifier">scanUpToString</span>:@&quot;&lt;&quot; <span class="identifier">intoString</span>:&amp;<span class="identifier">superClassName</span>]</span>;</span><br><span class="line">        <span class="keyword">if</span> (!scanner.isAtEnd) &#123;</span><br><span class="line">            scanner.scanLocation = scanner.scanLocation + <span class="number">1</span>;</span><br><span class="line">            <span class="literal">[<span class="identifier">scanner</span> <span class="identifier">scanUpToString</span>:@&quot;&gt;&quot; <span class="identifier">intoString</span>:&amp;<span class="identifier">protocolNames</span>]</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!superClassName) superClassName = @<span class="string">&quot;NSObject&quot;</span>;</span><br><span class="line">    <span class="comment">//类名</span></span><br><span class="line">    className = trim(className);</span><br><span class="line">    <span class="comment">//父类名</span></span><br><span class="line">    superClassName = trim(superClassName);</span><br><span class="line">    <span class="comment">//取出协议</span></span><br><span class="line">    NSArray *protocols = <span class="literal">[<span class="identifier">protocolNames</span> <span class="identifier">length</span>]</span> ? <span class="literal">[<span class="identifier">protocolNames</span> <span class="identifier">componentsSeparatedByString</span>:@&quot;,&quot;]</span> : nil;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//实例化对应的类</span></span><br><span class="line">    Class cls = <span class="constructor">NSClassFromString(<span class="params">className</span>)</span>;</span><br><span class="line">    <span class="keyword">if</span> (!cls) &#123;</span><br><span class="line">        Class superCls = <span class="constructor">NSClassFromString(<span class="params">superClassName</span>)</span>;</span><br><span class="line">        <span class="keyword">if</span> (!superCls) &#123;</span><br><span class="line">            <span class="constructor">_exceptionBlock([NSString <span class="params">stringWithFormat</span>:@<span class="string">&quot;can&#x27;t find the super class %@&quot;</span>, <span class="params">superClassName</span>])</span>;</span><br><span class="line">            return @&#123;@<span class="string">&quot;cls&quot;</span>: className&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        cls = objc<span class="constructor">_allocateClassPair(<span class="params">superCls</span>, <span class="params">className</span>.UTF8String, 0)</span>;</span><br><span class="line">        objc<span class="constructor">_registerClassPair(<span class="params">cls</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//为类添加协议</span></span><br><span class="line">    <span class="keyword">if</span> (protocols.count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (NSString* protocolName <span class="keyword">in</span> protocols) &#123;</span><br><span class="line">            Protocol *protocol = objc<span class="constructor">_getProtocol([<span class="params">trim</span>(<span class="params">protocolName</span>)</span> cStringUsingEncoding:NSUTF8StringEncoding]);</span><br><span class="line">            class_addProtocol (cls, protocol);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//====================================================================================</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i ++) &#123;</span><br><span class="line">        BOOL isInstance = i<span class="operator"> == </span><span class="number">0</span>;</span><br><span class="line">        JSValue *jsMethods = isInstance ? instanceMethods: classMethods;</span><br><span class="line">        <span class="comment">//3.若是添加实例方法，直接使用Class对象；</span></span><br><span class="line">        <span class="comment">//若是添加类方法，需要获取元类.</span></span><br><span class="line">        </span><br><span class="line">        Class currCls = isInstance ? cls: objc<span class="constructor">_getMetaClass(<span class="params">className</span>.UTF8String)</span>;</span><br><span class="line">        <span class="comment">//把js对象转换成OC的字典，从而可以取到方法名、参数个数、具体实现.</span></span><br><span class="line">        NSDictionary *methodDict = <span class="literal">[<span class="identifier">jsMethods</span> <span class="identifier">toDictionary</span>]</span>;</span><br><span class="line">        <span class="keyword">for</span> (NSString *jsMethodName <span class="keyword">in</span> methodDict.allKeys) &#123;</span><br><span class="line">            <span class="comment">//方法名为键，一个数组为值。数组第一个元素为对应实现函数的参数个数，第二个元素是方法的具体实现。</span></span><br><span class="line">            JSValue *jsMethodArr = <span class="literal">[<span class="identifier">jsMethods</span> <span class="identifier">valueForProperty</span>:<span class="identifier">jsMethodName</span>]</span>;</span><br><span class="line">            <span class="comment">//第一个值为  参数个数</span></span><br><span class="line">            <span class="built_in">int</span> numberOfArg = <span class="literal">[<span class="identifier">jsMethodArr</span>[<span class="number">0</span>]</span> toInt32];</span><br><span class="line">            <span class="comment">//将方法名转换为selectorName</span></span><br><span class="line">            NSString *selectorName = convert<span class="constructor">JPSelectorString(<span class="params">jsMethodName</span>)</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (<span class="literal">[<span class="identifier">selectorName</span> <span class="identifier">componentsSeparatedByString</span>:@&quot;:&quot;]</span>.count - <span class="number">1</span> &lt; numberOfArg) &#123;</span><br><span class="line">                selectorName = <span class="literal">[<span class="identifier">selectorName</span> <span class="identifier">stringByAppendingString</span>:@&quot;:&quot;]</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//第二个值为  方法实现</span></span><br><span class="line">            JSValue *jsMethod = jsMethodArr<span class="literal">[<span class="number">1</span>]</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">class</span><span class="constructor">_respondsToSelector(<span class="params">currCls</span>, NSSelectorFromString(<span class="params">selectorName</span>)</span>)) &#123;</span><br><span class="line">                <span class="comment">// 4.如果要替换的类已经定义了该方法，直接对该方法替换和实现消息转发.</span></span><br><span class="line">                override<span class="constructor">Method(<span class="params">currCls</span>, <span class="params">selectorName</span>, <span class="params">jsMethod</span>, !<span class="params">isInstance</span>, NULL)</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                BOOL overrided = NO;</span><br><span class="line">                <span class="keyword">for</span> (NSString *protocolName <span class="keyword">in</span> protocols) &#123;</span><br><span class="line">                    <span class="built_in">char</span> *types = <span class="keyword">method</span><span class="constructor">TypesInProtocol(<span class="params">protocolName</span>, <span class="params">selectorName</span>, <span class="params">isInstance</span>, YES)</span>;</span><br><span class="line">                    <span class="keyword">if</span> (!types) types = <span class="keyword">method</span><span class="constructor">TypesInProtocol(<span class="params">protocolName</span>, <span class="params">selectorName</span>, <span class="params">isInstance</span>, NO)</span>;</span><br><span class="line">                    <span class="keyword">if</span> (types) &#123;</span><br><span class="line">                        override<span class="constructor">Method(<span class="params">currCls</span>, <span class="params">selectorName</span>, <span class="params">jsMethod</span>, !<span class="params">isInstance</span>, <span class="params">types</span>)</span>;</span><br><span class="line">                        free(types);</span><br><span class="line">                        overrided = YES;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!overrided) &#123;</span><br><span class="line">                    <span class="comment">//5.2 上述两种情况都不满足.js端请求添加一个新的方法.</span></span><br><span class="line">                    <span class="keyword">if</span> (!<span class="literal">[[<span class="identifier">jsMethodName</span> <span class="identifier">substringToIndex</span>:<span class="number">1</span>]</span> isEqualToString:@<span class="string">&quot;_&quot;</span>]) &#123;</span><br><span class="line">                        <span class="comment">//方法名的处理：_改为:</span></span><br><span class="line">                        NSMutableString *typeDescStr = <span class="literal">[@&quot;@@:&quot; <span class="identifier">mutableCopy</span>]</span>;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; numberOfArg; i ++) &#123;</span><br><span class="line">                            <span class="literal">[<span class="identifier">typeDescStr</span> <span class="identifier">appendString</span>:@&quot;@&quot;]</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//构造一个typeDescription为&quot;@@:\@*&quot;的IMP.将这个IMP添加到类中.</span></span><br><span class="line">                        override<span class="constructor">Method(<span class="params">currCls</span>, <span class="params">selectorName</span>, <span class="params">jsMethod</span>, !<span class="params">isInstance</span>, [<span class="params">typeDescStr</span> <span class="params">cStringUsingEncoding</span>:NSUTF8StringEncoding])</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 6.为该类添加两个方法，使js脚本拥有设置property的方法.</span></span><br><span class="line">    <span class="keyword">class</span><span class="constructor">_addMethod(<span class="params">cls</span>, @<span class="params">selector</span>(<span class="params">getProp</span>:)</span>, (IMP)getPropIMP, <span class="string">&quot;@@:@&quot;</span>);</span><br><span class="line">    <span class="keyword">class</span><span class="constructor">_addMethod(<span class="params">cls</span>, @<span class="params">selector</span>(<span class="params">setProp</span>:<span class="params">forKey</span>:)</span>, (IMP)setPropIMP, <span class="string">&quot;v@:@@&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//// 7.返回字典给js脚本</span></span><br><span class="line">    return @&#123;@<span class="string">&quot;cls&quot;</span>: className, @<span class="string">&quot;superCls&quot;</span>: superClassName&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们以demo.js为例子，defineClass这里传入的classDeclaration为 <strong><strong>JPTableViewController : UITableViewController <UIAlertViewDelegate></UIAlertViewDelegate></strong></strong> 这个字符串。在defineClass中会从中提取类信息，父类信息，以及协议信息。<br>第二个参数instanceMethods和第三个参数classMethods分别为包含属性Setter&#x2F;Getter在内的实例方法和类方法。上面提到了这两个参数在js方法中已经将它组合成</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">key</span>:方法名<span class="meta"> [参数个数:方法实现]</span></span><br></pre></td></tr></table></figure>
<p>这种形式，我们以</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><span class="line">tableView_numberOfRowsInSection: <span class="keyword">function</span>(<span class="params">tableView, section</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> self.dataSource().<span class="built_in">length</span>;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>为例子: key为 tableView_numberOfRowsInSection value为[2,tableView:numberOfRowsInSection:的实现] 我们知道OC中要构建一个selector需要知道这个方法是实例方法还是类方法，方法名，IMP<br>类名，IMP 都可以直接拿到，我们还缺一个关键的信息，就是selectorName. 我们从js带过来带的key为tableView_numberOfRowsInSection，它其实包含了selectorName所需要的必要信息，只不过它是以”<em>“分隔，所以将将”</em>“替换为”:”<br>然后检查通过”:”分隔的字符串数和传入的参数个数这个进行进行比较，如果少了则需要在最后加个”:”就可以拿到我们需要的selectorName了。</p>
<p>我们接下来看下热修复最关键的方法overrideMethod:</p>
<p><strong><strong>方法替换</strong></strong></p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  使用jsvalue中将要替换的方法实现来替换oc类中的方法实现</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @param cls             被替换的类</span></span><br><span class="line"><span class="comment"> *  @param selectorName    被替换实现的SEL</span></span><br><span class="line"><span class="comment"> *  @param function        在js中定义的将要替换的新的实现</span></span><br><span class="line"><span class="comment"> *  @param isClassMethod   是否类方法（如果是--&gt;寻找MetaClass）</span></span><br><span class="line"><span class="comment"> *  @param typeDescription 被替换的实现方法的编码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">static void override<span class="constructor">Method(Class <span class="params">cls</span>, NSString <span class="operator">*</span><span class="params">selectorName</span>, JSValue <span class="operator">*</span><span class="params">function</span>, BOOL <span class="params">isClassMethod</span>, <span class="params">const</span> <span class="params">char</span> <span class="operator">*</span><span class="params">typeDescription</span>)</span> &#123;</span><br><span class="line">    <span class="comment">//1. 要重写的方法的SEL.</span></span><br><span class="line">    SEL selector = <span class="constructor">NSSelectorFromString(<span class="params">selectorName</span>)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2. 获取重写方法的具体实现函数的格式编码.</span></span><br><span class="line">    <span class="keyword">if</span> (!typeDescription) &#123;</span><br><span class="line">        Method <span class="keyword">method</span> = <span class="keyword">class</span><span class="constructor">_getInstanceMethod(<span class="params">cls</span>, <span class="params">selector</span>)</span>;</span><br><span class="line">        typeDescription = (<span class="built_in">char</span> *)<span class="keyword">method</span><span class="constructor">_getTypeEncoding(<span class="params">method</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3.获取 class 中被重写 SEL 对应的原始IMP.</span></span><br><span class="line">    IMP originalImp = <span class="keyword">class</span><span class="constructor">_respondsToSelector(<span class="params">cls</span>, <span class="params">selector</span>)</span> ? <span class="keyword">class</span><span class="constructor">_getMethodImplementation(<span class="params">cls</span>, <span class="params">selector</span>)</span> : NULL;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//4.准备进入消息转发处理的系统函数实现IMP.</span></span><br><span class="line">    IMP msgForwardIMP = _objc_msgForward;</span><br><span class="line">    <span class="comment">//.......</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//--------------------------------------将要修复类原来的forwardInvocaiton替换成ORIGforwardInvocation--------------------------</span></span><br><span class="line">    <span class="comment">//--------------------------------------将要修复类的SEL替换成ORIGsel添加到类---------------------------------------------------</span></span><br><span class="line">    <span class="comment">//6.将cls中原来 forwardInvocaiton: 的实现替换成 JPForwardInvocation:函数实现.</span></span><br><span class="line">    <span class="comment">//class_replaceMethod()返回的是替换之前的 IMP.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">class</span><span class="constructor">_getMethodImplementation(<span class="params">cls</span>, @<span class="params">selector</span>(<span class="params">forwardInvocation</span>:)</span>) != (IMP)JPForwardInvocation) &#123;</span><br><span class="line">        IMP originalForwardImp = <span class="keyword">class</span><span class="constructor">_replaceMethod(<span class="params">cls</span>, @<span class="params">selector</span>(<span class="params">forwardInvocation</span>:)</span>, (IMP)JPForwardInvocation, <span class="string">&quot;v@:@&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (originalForwardImp) &#123;</span><br><span class="line">            <span class="comment">//7.为cls添加新的SEL(ORIGforwardInvocation:)，指向原始 forwardInvocation: 的实现IMP.</span></span><br><span class="line">            <span class="keyword">class</span><span class="constructor">_addMethod(<span class="params">cls</span>, @<span class="params">selector</span>(ORIGforwardInvocation:)</span>, originalForwardImp, <span class="string">&quot;v@:@&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="literal">[<span class="identifier">cls</span> <span class="identifier">jp_fixMethodSignature</span>]</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">class</span><span class="constructor">_respondsToSelector(<span class="params">cls</span>, <span class="params">selector</span>)</span>) &#123;</span><br><span class="line">        NSString *originalSelectorName = <span class="literal">[NSS<span class="identifier">tring</span> <span class="identifier">stringWithFormat</span>:@&quot;ORIG%@&quot;, <span class="identifier">selectorName</span>]</span>;</span><br><span class="line">        SEL originalSelector = <span class="constructor">NSSelectorFromString(<span class="params">originalSelectorName</span>)</span>;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="keyword">class</span><span class="constructor">_respondsToSelector(<span class="params">cls</span>, <span class="params">originalSelector</span>)</span>) &#123;</span><br><span class="line">            <span class="comment">//8.为cls添加新的SEL(ORIG...:)指向被替换方法的原始实现IMP.</span></span><br><span class="line">            <span class="keyword">class</span><span class="constructor">_addMethod(<span class="params">cls</span>, <span class="params">originalSelector</span>, <span class="params">originalImp</span>, <span class="params">typeDescription</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//9.构造替换实现后的新SEL:(JP...)</span></span><br><span class="line">    NSString *JPSelectorName = <span class="literal">[NSS<span class="identifier">tring</span> <span class="identifier">stringWithFormat</span>:@&quot;<span class="identifier">_JP</span>%@&quot;, <span class="identifier">selectorName</span>]</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//10.记录新SEL对应js传过来的待替换目标方法的实现.</span></span><br><span class="line">    <span class="constructor">_initJPOverideMethods(<span class="params">cls</span>)</span>;</span><br><span class="line">    _JSOverideMethods<span class="literal">[<span class="identifier">cls</span>]</span><span class="literal">[JPS<span class="identifier">electorName</span>]</span> = <span class="keyword">function</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//11.替换原SEL的实现IMP为msgForwardIMP</span></span><br><span class="line">    <span class="comment">//让被替换的方法调用时，直接进入“消息转发”流程（_objc_msgForward 或 _objc_msgForward_stret）</span></span><br><span class="line">    <span class="comment">//这一步放到最后是为了避免在 overrideMethod 过程中调用原sel导致的线程问题.</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Replace the original selector at last, preventing threading issus when</span></span><br><span class="line">    <span class="comment">// the selector get called during the execution of `overrideMethod`</span></span><br><span class="line">    <span class="keyword">class</span><span class="constructor">_replaceMethod(<span class="params">cls</span>, <span class="params">selector</span>, <span class="params">msgForwardIMP</span>, <span class="params">typeDescription</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果大家看过Aspect源码这部分会比较好理解，两者在这部分思路是类似的，首先会将当前类的forwardInvocaiton替换为JSPatch实现的JPForwardInvocation:如果原来的类已经有实现了forwardInvocaiton那么就会将forwardInvocaiton替换成ORIGforwardInvocation<br>当前方法的selectorName 替换为_JPselectorName，如果原来有这个方法了，这里是在覆盖原有的方法，那么会将原来的方法selectorName改为ORIGselectorName。最后将selector方法的实现替换为_objc_msgForward 或 _objc_msgForward_stret 从而在代码中调用这个方法的时候，会触发消息下发。<br>走forwardInvocaiton，也就是会走到JSPatch实现的JPForwardInvocation:来重新控制方法调用的规则。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">static void <span class="constructor">JPForwardInvocation(<span class="params">__unsafe_unretained</span> <span class="params">id</span> <span class="params">assignSlf</span>, SEL <span class="params">selector</span>, NSInvocation <span class="operator">*</span><span class="params">invocation</span>)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//1.表示oc对象是否已经被释放</span></span><br><span class="line">    BOOL deallocFlag = NO;</span><br><span class="line">    id slf = assignSlf;</span><br><span class="line">    BOOL isBlock = <span class="literal">[[<span class="identifier">assignSlf</span> <span class="identifier">class</span>]</span> isSubclassOfClass : <span class="constructor">NSClassFromString(@<span class="string">&quot;NSBlock&quot;</span>)</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.获取invocation中参数的数量</span></span><br><span class="line">    NSMethodSignature *methodSignature = <span class="literal">[<span class="identifier">invocation</span> <span class="identifier">methodSignature</span>]</span>;</span><br><span class="line">    NSInteger numberOfArguments = <span class="literal">[<span class="identifier">methodSignature</span> <span class="identifier">numberOfArguments</span>]</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3.转化调用的SEL为JPSEL（这是JSPatch中缓存JSValue* function的key格式）</span></span><br><span class="line">    NSString *selectorName = isBlock ? @<span class="string">&quot;&quot;</span> : <span class="constructor">NSStringFromSelector(<span class="params">invocation</span>.<span class="params">selector</span>)</span>;</span><br><span class="line">    NSString *JPSelectorName = <span class="literal">[NSS<span class="identifier">tring</span> <span class="identifier">stringWithFormat</span>:@&quot;<span class="identifier">_JP</span>%@&quot;, <span class="identifier">selectorName</span>]</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//4.判断JPSEL是否有对应的js函数的实现，如果没有就走原始方法的消息转发的流程.</span></span><br><span class="line">    JSValue *jsFunc = isBlock ? objc<span class="constructor">_getAssociatedObject(<span class="params">assignSlf</span>, <span class="string">&quot;_JSValue&quot;</span>)</span><span class="literal">[@&quot;<span class="identifier">cb</span>&quot;]</span> : get<span class="constructor">JSFunctionInObjectHierachy(<span class="params">slf</span>, JPSelectorName)</span>;</span><br><span class="line">    <span class="keyword">if</span> (!jsFunc) &#123;</span><br><span class="line">        <span class="constructor">JPExecuteORIGForwardInvocation(<span class="params">slf</span>, <span class="params">selector</span>, <span class="params">invocation</span>)</span>;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//5.1 初始化数组，存储NSInvacation中获取的参数列表，传给对应的js函数</span></span><br><span class="line">    NSMutableArray *argList = <span class="literal">[[NSM<span class="identifier">utableArray</span> <span class="identifier">alloc</span>]</span> init];</span><br><span class="line">    <span class="keyword">if</span> (!isBlock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">[<span class="identifier">slf</span> <span class="identifier">class</span>]</span><span class="operator"> == </span>slf) &#123;</span><br><span class="line">            <span class="comment">//5.2 类方法：设置__clsName标识表明这是一个类对象</span></span><br><span class="line">            <span class="literal">[<span class="identifier">argList</span> <span class="identifier">addObject</span>:[JSV<span class="identifier">alue</span> <span class="identifier">valueWithObject</span>:@&#123;@&quot;<span class="identifier">__clsName</span>&quot;: NSS<span class="identifier">tringFromClass</span>([<span class="identifier">slf</span> <span class="identifier">class</span>]</span>)&#125; inContext:_context]];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="literal">[<span class="identifier">selectorName</span> <span class="identifier">isEqualToString</span>:@&quot;<span class="identifier">dealloc</span>&quot;]</span>) &#123;</span><br><span class="line">            <span class="comment">//5.3 要被释放的对象：使用assign来保存self指针</span></span><br><span class="line">            <span class="literal">[<span class="identifier">argList</span> <span class="identifier">addObject</span>:[JPB<span class="identifier">oxing</span> <span class="identifier">boxAssignObj</span>:<span class="identifier">slf</span>]</span>];</span><br><span class="line">            deallocFlag = YES;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//5.4 使用 weak 保存self 指针</span></span><br><span class="line">            <span class="literal">[<span class="identifier">argList</span> <span class="identifier">addObject</span>:[JPB<span class="identifier">oxing</span> <span class="identifier">boxWeakObj</span>:<span class="identifier">slf</span>]</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//5.5 NSInvocation 对象的前两个参数是self和_cmd,所以直接从第3个参数开始获取</span></span><br><span class="line">    <span class="keyword">for</span> (NSUInteger i = isBlock ? <span class="number">1</span> : <span class="number">2</span>; i &lt; numberOfArguments; i++) &#123;</span><br><span class="line">        const <span class="built_in">char</span> *argumentType = <span class="literal">[<span class="identifier">methodSignature</span> <span class="identifier">getArgumentTypeAtIndex</span>:<span class="identifier">i</span>]</span>;</span><br><span class="line">        <span class="comment">//返回值如果是const，获取encoding来判断类型.</span></span><br><span class="line">        switch(argumentType<span class="literal">[<span class="number">0</span>]</span><span class="operator"> == </span><span class="character">&#x27;r&#x27;</span> ? argumentType<span class="literal">[<span class="number">1</span>]</span> : argumentType<span class="literal">[<span class="number">0</span>]</span>) &#123;</span><br><span class="line">            <span class="comment">//从invocation中获取参数，添加到argList中.</span></span><br><span class="line">            #define <span class="constructor">JP_FWD_ARG_CASE(<span class="params">_typeChar</span>, <span class="params">_type</span>)</span> \</span><br><span class="line">            case _typeChar: &#123;   \</span><br><span class="line">                _type arg;  \</span><br><span class="line">                <span class="literal">[<span class="identifier">invocation</span> <span class="identifier">getArgument</span>:&amp;<span class="identifier">arg</span> <span class="identifier">atIndex</span>:<span class="identifier">i</span>]</span>;    \</span><br><span class="line">                <span class="literal">[<span class="identifier">argList</span> <span class="identifier">addObject</span>:@(<span class="identifier">arg</span>)]</span>; \</span><br><span class="line">                break;  \</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="constructor">JP_FWD_ARG_CASE(&#x27;<span class="params">c</span>&#x27;, <span class="params">char</span>)</span></span><br><span class="line">            <span class="constructor">JP_FWD_ARG_CASE(&#x27;C&#x27;, <span class="params">unsigned</span> <span class="params">char</span>)</span></span><br><span class="line">            <span class="constructor">JP_FWD_ARG_CASE(&#x27;<span class="params">s</span>&#x27;, <span class="params">short</span>)</span></span><br><span class="line">            <span class="constructor">JP_FWD_ARG_CASE(&#x27;S&#x27;, <span class="params">unsigned</span> <span class="params">short</span>)</span></span><br><span class="line">            <span class="constructor">JP_FWD_ARG_CASE(&#x27;<span class="params">i</span>&#x27;, <span class="params">int</span>)</span></span><br><span class="line">            <span class="constructor">JP_FWD_ARG_CASE(&#x27;I&#x27;, <span class="params">unsigned</span> <span class="params">int</span>)</span></span><br><span class="line">            <span class="constructor">JP_FWD_ARG_CASE(&#x27;<span class="params">l</span>&#x27;, <span class="params">long</span>)</span></span><br><span class="line">            <span class="constructor">JP_FWD_ARG_CASE(&#x27;L&#x27;, <span class="params">unsigned</span> <span class="params">long</span>)</span></span><br><span class="line">            <span class="constructor">JP_FWD_ARG_CASE(&#x27;<span class="params">q</span>&#x27;, <span class="params">long</span> <span class="params">long</span>)</span></span><br><span class="line">            <span class="constructor">JP_FWD_ARG_CASE(&#x27;Q&#x27;, <span class="params">unsigned</span> <span class="params">long</span> <span class="params">long</span>)</span></span><br><span class="line">            <span class="constructor">JP_FWD_ARG_CASE(&#x27;<span class="params">f</span>&#x27;, <span class="params">float</span>)</span></span><br><span class="line">            <span class="constructor">JP_FWD_ARG_CASE(&#x27;<span class="params">d</span>&#x27;, <span class="params">double</span>)</span></span><br><span class="line">            <span class="constructor">JP_FWD_ARG_CASE(&#x27;B&#x27;, BOOL)</span></span><br><span class="line">            case <span class="character">&#x27;@&#x27;</span>: &#123;</span><br><span class="line">                <span class="comment">//id类型参数使用__unsafe__unretained</span></span><br><span class="line">                __unsafe_unretained id arg;</span><br><span class="line">                <span class="literal">[<span class="identifier">invocation</span> <span class="identifier">getArgument</span>:&amp;<span class="identifier">arg</span> <span class="identifier">atIndex</span>:<span class="identifier">i</span>]</span>;</span><br><span class="line">                <span class="comment">//block参数使用copy，_nilObj表示nil</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">[<span class="identifier">arg</span> <span class="identifier">isKindOfClass</span>:NSC<span class="identifier">lassFromString</span>(@&quot;NSB<span class="identifier">lock</span>&quot;)]</span>) &#123;</span><br><span class="line">                    <span class="literal">[<span class="identifier">argList</span> <span class="identifier">addObject</span>:(<span class="identifier">arg</span> ? [<span class="identifier">arg</span> <span class="identifier">copy</span>]</span>: _nilObj)];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="literal">[<span class="identifier">argList</span> <span class="identifier">addObject</span>:(<span class="identifier">arg</span> ? <span class="identifier">arg</span>: <span class="identifier">_nilObj</span>)]</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            case <span class="character">&#x27;&#123;&#x27;</span>: &#123;</span><br><span class="line"><span class="comment">//                处理结构体类型参数</span></span><br><span class="line"><span class="comment">//                获取结构体类型名称，把参数包装成JSValue类型</span></span><br><span class="line">                NSString *typeString = extract<span class="constructor">StructName([NSString <span class="params">stringWithUTF8String</span>:<span class="params">argumentType</span>])</span>;</span><br><span class="line">                #define <span class="constructor">JP_FWD_ARG_STRUCT(<span class="params">_type</span>, <span class="params">_transFunc</span>)</span> \</span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">[<span class="identifier">typeString</span> <span class="identifier">rangeOfString</span>:@#<span class="identifier">_type</span>]</span>.location != NSNotFound) &#123;    \</span><br><span class="line">                    _type arg; \</span><br><span class="line">                    <span class="literal">[<span class="identifier">invocation</span> <span class="identifier">getArgument</span>:&amp;<span class="identifier">arg</span> <span class="identifier">atIndex</span>:<span class="identifier">i</span>]</span>;    \</span><br><span class="line">                    <span class="literal">[<span class="identifier">argList</span> <span class="identifier">addObject</span>:[JSV<span class="identifier">alue</span> <span class="identifier">_transFunc</span>:<span class="identifier">arg</span> <span class="identifier">inContext</span>:<span class="identifier">_context</span>]</span>];  \</span><br><span class="line">                    break; \</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="constructor">JP_FWD_ARG_STRUCT(CGRect, <span class="params">valueWithRect</span>)</span></span><br><span class="line">                <span class="constructor">JP_FWD_ARG_STRUCT(CGPoint, <span class="params">valueWithPoint</span>)</span></span><br><span class="line">                <span class="constructor">JP_FWD_ARG_STRUCT(CGSize, <span class="params">valueWithSize</span>)</span></span><br><span class="line">                <span class="constructor">JP_FWD_ARG_STRUCT(NSRange, <span class="params">valueWithRange</span>)</span></span><br><span class="line"><span class="comment">//                自定义类型的结构体处理</span></span><br><span class="line">                @synchronized (_context) &#123;</span><br><span class="line">                    NSDictionary *structDefine = _registeredStruct<span class="literal">[<span class="identifier">typeString</span>]</span>;</span><br><span class="line">                    <span class="keyword">if</span> (structDefine) &#123;</span><br><span class="line">                        size_t size = size<span class="constructor">OfStructTypes(<span class="params">structDefine</span>[@<span class="string">&quot;types&quot;</span>])</span>;</span><br><span class="line">                        <span class="keyword">if</span> (size) &#123;</span><br><span class="line">                            void *ret = malloc(size);</span><br><span class="line">                            <span class="literal">[<span class="identifier">invocation</span> <span class="identifier">getArgument</span>:<span class="identifier">ret</span> <span class="identifier">atIndex</span>:<span class="identifier">i</span>]</span>;</span><br><span class="line">                            NSDictionary *dict = get<span class="constructor">DictOfStruct(<span class="params">ret</span>, <span class="params">structDefine</span>)</span>;</span><br><span class="line">                            <span class="literal">[<span class="identifier">argList</span> <span class="identifier">addObject</span>:[JSV<span class="identifier">alue</span> <span class="identifier">valueWithObject</span>:<span class="identifier">dict</span> <span class="identifier">inContext</span>:<span class="identifier">_context</span>]</span>];</span><br><span class="line">                            free(ret);</span><br><span class="line">                            break;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            case <span class="character">&#x27;:&#x27;</span>: &#123;</span><br><span class="line">                <span class="comment">//selector类型处理</span></span><br><span class="line">                SEL selector;</span><br><span class="line">                <span class="literal">[<span class="identifier">invocation</span> <span class="identifier">getArgument</span>:&amp;<span class="identifier">selector</span> <span class="identifier">atIndex</span>:<span class="identifier">i</span>]</span>;</span><br><span class="line">                NSString *selectorName = <span class="constructor">NSStringFromSelector(<span class="params">selector</span>)</span>;</span><br><span class="line">                <span class="literal">[<span class="identifier">argList</span> <span class="identifier">addObject</span>:(<span class="identifier">selectorName</span> ? <span class="identifier">selectorName</span>: <span class="identifier">_nilObj</span>)]</span>;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            case <span class="character">&#x27;^&#x27;</span>:</span><br><span class="line">            case <span class="character">&#x27;*&#x27;</span>: &#123;</span><br><span class="line">                <span class="comment">//指针类型处理</span></span><br><span class="line">                void *arg;</span><br><span class="line">                <span class="literal">[<span class="identifier">invocation</span> <span class="identifier">getArgument</span>:&amp;<span class="identifier">arg</span> <span class="identifier">atIndex</span>:<span class="identifier">i</span>]</span>;</span><br><span class="line">                <span class="literal">[<span class="identifier">argList</span> <span class="identifier">addObject</span>:[JPB<span class="identifier">oxing</span> <span class="identifier">boxPointer</span>:<span class="identifier">arg</span>]</span>];</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            case <span class="character">&#x27;#&#x27;</span>: &#123;</span><br><span class="line">                <span class="comment">//Class类型</span></span><br><span class="line">                Class arg;</span><br><span class="line">                <span class="literal">[<span class="identifier">invocation</span> <span class="identifier">getArgument</span>:&amp;<span class="identifier">arg</span> <span class="identifier">atIndex</span>:<span class="identifier">i</span>]</span>;</span><br><span class="line">                <span class="literal">[<span class="identifier">argList</span> <span class="identifier">addObject</span>:[JPB<span class="identifier">oxing</span> <span class="identifier">boxClass</span>:<span class="identifier">arg</span>]</span>];</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            default: &#123;</span><br><span class="line">                <span class="constructor">NSLog(@<span class="string">&quot;error type %s&quot;</span>, <span class="params">argumentType</span>)</span>;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (_currInvokeSuperClsName<span class="literal">[<span class="identifier">selectorName</span>]</span>) &#123;</span><br><span class="line">        Class cls = <span class="constructor">NSClassFromString(<span class="params">_currInvokeSuperClsName</span>[<span class="params">selectorName</span>])</span>;</span><br><span class="line">        NSString *tmpSelectorName = <span class="literal">[[<span class="identifier">selectorName</span> <span class="identifier">stringByReplacingOccurrencesOfString</span>:@&quot;<span class="identifier">_JPSUPER_</span>&quot; <span class="identifier">withString</span>:@&quot;<span class="identifier">_JP</span>&quot;]</span> stringByReplacingOccurrencesOfString:@<span class="string">&quot;SUPER_&quot;</span> withString:@<span class="string">&quot;_JP&quot;</span>];</span><br><span class="line">        <span class="keyword">if</span> (!_JSOverideMethods<span class="literal">[<span class="identifier">cls</span>]</span><span class="literal">[<span class="identifier">tmpSelectorName</span>]</span>) &#123;</span><br><span class="line">            NSString *ORIGSelectorName = <span class="literal">[<span class="identifier">selectorName</span> <span class="identifier">stringByReplacingOccurrencesOfString</span>:@&quot;SUPER<span class="identifier">_</span>&quot; <span class="identifier">withString</span>:@&quot;ORIG&quot;]</span>;</span><br><span class="line">            <span class="literal">[<span class="identifier">argList</span> <span class="identifier">removeObjectAtIndex</span>:<span class="number">0</span>]</span>;</span><br><span class="line">            id retObj = call<span class="constructor">Selector(<span class="params">_currInvokeSuperClsName</span>[<span class="params">selectorName</span>], ORIGSelectorName, [JSValue <span class="params">valueWithObject</span>:<span class="params">argList</span> <span class="params">inContext</span>:<span class="params">_context</span>], [JSValue <span class="params">valueWithObject</span>:@&#123;@<span class="string">&quot;__obj&quot;</span>: <span class="params">slf</span>, @<span class="string">&quot;__realClsName&quot;</span>: @<span class="string">&quot;&quot;</span>&#125; <span class="params">inContext</span>:<span class="params">_context</span>], NO)</span>;</span><br><span class="line">            id __autoreleasing ret = format<span class="constructor">JSToOC([JSValue <span class="params">valueWithObject</span>:<span class="params">retObj</span> <span class="params">inContext</span>:<span class="params">_context</span>])</span>;</span><br><span class="line">            <span class="literal">[<span class="identifier">invocation</span> <span class="identifier">setReturnValue</span>:&amp;<span class="identifier">ret</span>]</span>;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//6.将上面获得的参数列表数组转化为对应的js对象数组</span></span><br><span class="line">    NSArray *params = <span class="constructor">_formatOCToJSList(<span class="params">argList</span>)</span>;</span><br><span class="line">    <span class="built_in">char</span> returnType<span class="literal">[<span class="number">255</span>]</span>;</span><br><span class="line">    strcpy(returnType, <span class="literal">[<span class="identifier">methodSignature</span> <span class="identifier">methodReturnType</span>]</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 7.获取返回值类型</span></span><br><span class="line">    <span class="comment">// Restore the return type</span></span><br><span class="line">    <span class="keyword">if</span> (strcmp(returnType, @encode(JPDouble))<span class="operator"> == </span><span class="number">0</span>) &#123;</span><br><span class="line">        strcpy(returnType, @encode(double));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (strcmp(returnType, @encode(JPFloat))<span class="operator"> == </span><span class="number">0</span>) &#123;</span><br><span class="line">        strcpy(returnType, @encode(<span class="built_in">float</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7.1 返回值是否为const，如果是，获取后面的encoding来判断类型</span></span><br><span class="line">    switch (returnType<span class="literal">[<span class="number">0</span>]</span><span class="operator"> == </span><span class="character">&#x27;r&#x27;</span> ? returnType<span class="literal">[<span class="number">1</span>]</span> : returnType<span class="literal">[<span class="number">0</span>]</span>) &#123;</span><br><span class="line">        #define JP_FWD_RET_CALL_JS \</span><br><span class="line">            JSValue *jsval; \</span><br><span class="line">            <span class="literal">[<span class="identifier">_JSMethodForwardCallLock</span> <span class="identifier">lock</span>]</span>;   \</span><br><span class="line">            jsval = <span class="literal">[<span class="identifier">jsFunc</span> <span class="identifier">callWithArguments</span>:<span class="identifier">params</span>]</span>; \</span><br><span class="line">            <span class="literal">[<span class="identifier">_JSMethodForwardCallLock</span> <span class="identifier">unlock</span>]</span>; \</span><br><span class="line">            <span class="keyword">while</span> (!<span class="literal">[<span class="identifier">jsval</span> <span class="identifier">isNull</span>]</span><span class="operator"> &amp;&amp; </span>!<span class="literal">[<span class="identifier">jsval</span> <span class="identifier">isUndefined</span>]</span><span class="operator"> &amp;&amp; </span><span class="literal">[<span class="identifier">jsval</span> <span class="identifier">hasProperty</span>:@&quot;<span class="identifier">__isPerformInOC</span>&quot;]</span>) &#123; \</span><br><span class="line">                NSArray *args = nil;  \</span><br><span class="line">                JSValue *cb = jsval<span class="literal">[@&quot;<span class="identifier">cb</span>&quot;]</span>; \</span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">[<span class="identifier">jsval</span> <span class="identifier">hasProperty</span>:@&quot;<span class="identifier">sel</span>&quot;]</span>) &#123;   \</span><br><span class="line">                    id callRet = call<span class="constructor">Selector(![<span class="params">jsval</span>[@<span class="string">&quot;clsName&quot;</span>] <span class="params">isUndefined</span>] ? [<span class="params">jsval</span>[@<span class="string">&quot;clsName&quot;</span>] <span class="params">toString</span>] : <span class="params">nil</span>, [<span class="params">jsval</span>[@<span class="string">&quot;sel&quot;</span>] <span class="params">toString</span>], <span class="params">jsval</span>[@<span class="string">&quot;args&quot;</span>], ![<span class="params">jsval</span>[@<span class="string">&quot;obj&quot;</span>] <span class="params">isUndefined</span>] ? <span class="params">jsval</span>[@<span class="string">&quot;obj&quot;</span>] : <span class="params">nil</span>, NO)</span>;  \</span><br><span class="line">                    args = @<span class="literal">[[<span class="identifier">_context</span>[@&quot;<span class="identifier">_formatOCToJS</span>&quot;]</span> callWithArguments:callRet ? @<span class="literal">[<span class="identifier">callRet</span>]</span> : <span class="constructor">_formatOCToJSList(@[<span class="params">_nilObj</span>])</span>]];  \</span><br><span class="line">                &#125;   \</span><br><span class="line">                <span class="literal">[<span class="identifier">_JSMethodForwardCallLock</span> <span class="identifier">lock</span>]</span>;    \</span><br><span class="line">                jsval = <span class="literal">[<span class="identifier">cb</span> <span class="identifier">callWithArguments</span>:<span class="identifier">args</span>]</span>;  \</span><br><span class="line">                <span class="literal">[<span class="identifier">_JSMethodForwardCallLock</span> <span class="identifier">unlock</span>]</span>;  \</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        #define <span class="constructor">JP_FWD_RET_CASE_RET(<span class="params">_typeChar</span>, <span class="params">_type</span>, <span class="params">_retCode</span>)</span>   \</span><br><span class="line">            case _typeChar : &#123; \</span><br><span class="line">                JP_FWD_RET_CALL_JS \</span><br><span class="line">                _retCode \</span><br><span class="line">                <span class="literal">[<span class="identifier">invocation</span> <span class="identifier">setReturnValue</span>:&amp;<span class="identifier">ret</span>]</span>;\</span><br><span class="line">                break;  \</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        #define <span class="constructor">JP_FWD_RET_CASE(<span class="params">_typeChar</span>, <span class="params">_type</span>, <span class="params">_typeSelector</span>)</span>   \</span><br><span class="line">            <span class="constructor">JP_FWD_RET_CASE_RET(<span class="params">_typeChar</span>, <span class="params">_type</span>, <span class="params">_type</span> <span class="params">ret</span> = [[<span class="params">jsval</span> <span class="params">toObject</span>] <span class="params">_typeSelector</span>];)</span>   \</span><br><span class="line"></span><br><span class="line">        #define JP_FWD_RET_CODE_ID \</span><br><span class="line">            id __autoreleasing ret = format<span class="constructor">JSToOC(<span class="params">jsval</span>)</span>; \</span><br><span class="line">            <span class="keyword">if</span> (ret<span class="operator"> == </span>_nilObj<span class="operator"> ||   </span>\</span><br><span class="line">                (<span class="literal">[<span class="identifier">ret</span> <span class="identifier">isKindOfClass</span>:[NSN<span class="identifier">umber</span> <span class="identifier">class</span>]</span>]<span class="operator"> &amp;&amp; </span>strcmp(<span class="literal">[<span class="identifier">ret</span> <span class="identifier">objCType</span>]</span>, <span class="string">&quot;c&quot;</span>)<span class="operator"> == </span><span class="number">0</span><span class="operator"> &amp;&amp; </span>!<span class="literal">[<span class="identifier">ret</span> <span class="identifier">boolValue</span>]</span>)) ret = nil;  \</span><br><span class="line"></span><br><span class="line">        #define JP_FWD_RET_CODE_POINTER    \</span><br><span class="line">            void *ret; \</span><br><span class="line">            id obj = format<span class="constructor">JSToOC(<span class="params">jsval</span>)</span>; \</span><br><span class="line">            <span class="keyword">if</span> (<span class="literal">[<span class="identifier">obj</span> <span class="identifier">isKindOfClass</span>:[JPB<span class="identifier">oxing</span> <span class="identifier">class</span>]</span>]) &#123; \</span><br><span class="line">                ret = <span class="literal">[((JPB<span class="identifier">oxing</span> <span class="operator">*</span>)<span class="identifier">obj</span>) <span class="identifier">unboxPointer</span>]</span>; \</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        #define JP_FWD_RET_CODE_CLASS    \</span><br><span class="line">            Class ret;   \</span><br><span class="line">            ret = format<span class="constructor">JSToOC(<span class="params">jsval</span>)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        #define JP_FWD_RET_CODE_SEL    \</span><br><span class="line">            SEL ret;   \</span><br><span class="line">            id obj = format<span class="constructor">JSToOC(<span class="params">jsval</span>)</span>; \</span><br><span class="line">            <span class="keyword">if</span> (<span class="literal">[<span class="identifier">obj</span> <span class="identifier">isKindOfClass</span>:[NSS<span class="identifier">tring</span> <span class="identifier">class</span>]</span>]) &#123; \</span><br><span class="line">                ret = <span class="constructor">NSSelectorFromString(<span class="params">obj</span>)</span>; \</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="constructor">JP_FWD_RET_CASE_RET(&#x27;@&#x27;, <span class="params">id</span>, JP_FWD_RET_CODE_ID)</span></span><br><span class="line">        <span class="constructor">JP_FWD_RET_CASE_RET(&#x27;^&#x27;, <span class="params">void</span><span class="operator">*</span>, JP_FWD_RET_CODE_POINTER)</span></span><br><span class="line">        <span class="constructor">JP_FWD_RET_CASE_RET(&#x27;<span class="operator">*</span>&#x27;, <span class="params">void</span><span class="operator">*</span>, JP_FWD_RET_CODE_POINTER)</span></span><br><span class="line">        <span class="constructor">JP_FWD_RET_CASE_RET(&#x27;#&#x27;, Class, JP_FWD_RET_CODE_CLASS)</span></span><br><span class="line">        <span class="constructor">JP_FWD_RET_CASE_RET(&#x27;:&#x27;, SEL, JP_FWD_RET_CODE_SEL)</span></span><br><span class="line"></span><br><span class="line">        <span class="constructor">JP_FWD_RET_CASE(&#x27;<span class="params">c</span>&#x27;, <span class="params">char</span>, <span class="params">charValue</span>)</span></span><br><span class="line">        <span class="constructor">JP_FWD_RET_CASE(&#x27;C&#x27;, <span class="params">unsigned</span> <span class="params">char</span>, <span class="params">unsignedCharValue</span>)</span></span><br><span class="line">        <span class="constructor">JP_FWD_RET_CASE(&#x27;<span class="params">s</span>&#x27;, <span class="params">short</span>, <span class="params">shortValue</span>)</span></span><br><span class="line">        <span class="constructor">JP_FWD_RET_CASE(&#x27;S&#x27;, <span class="params">unsigned</span> <span class="params">short</span>, <span class="params">unsignedShortValue</span>)</span></span><br><span class="line">        <span class="constructor">JP_FWD_RET_CASE(&#x27;<span class="params">i</span>&#x27;, <span class="params">int</span>, <span class="params">intValue</span>)</span></span><br><span class="line">        <span class="constructor">JP_FWD_RET_CASE(&#x27;I&#x27;, <span class="params">unsigned</span> <span class="params">int</span>, <span class="params">unsignedIntValue</span>)</span></span><br><span class="line">        <span class="constructor">JP_FWD_RET_CASE(&#x27;<span class="params">l</span>&#x27;, <span class="params">long</span>, <span class="params">longValue</span>)</span></span><br><span class="line">        <span class="constructor">JP_FWD_RET_CASE(&#x27;L&#x27;, <span class="params">unsigned</span> <span class="params">long</span>, <span class="params">unsignedLongValue</span>)</span></span><br><span class="line">        <span class="constructor">JP_FWD_RET_CASE(&#x27;<span class="params">q</span>&#x27;, <span class="params">long</span> <span class="params">long</span>, <span class="params">longLongValue</span>)</span></span><br><span class="line">        <span class="constructor">JP_FWD_RET_CASE(&#x27;Q&#x27;, <span class="params">unsigned</span> <span class="params">long</span> <span class="params">long</span>, <span class="params">unsignedLongLongValue</span>)</span></span><br><span class="line">        <span class="constructor">JP_FWD_RET_CASE(&#x27;<span class="params">f</span>&#x27;, <span class="params">float</span>, <span class="params">floatValue</span>)</span></span><br><span class="line">        <span class="constructor">JP_FWD_RET_CASE(&#x27;<span class="params">d</span>&#x27;, <span class="params">double</span>, <span class="params">doubleValue</span>)</span></span><br><span class="line">        <span class="constructor">JP_FWD_RET_CASE(&#x27;B&#x27;, BOOL, <span class="params">boolValue</span>)</span></span><br><span class="line"></span><br><span class="line">        case <span class="character">&#x27;v&#x27;</span>: &#123;</span><br><span class="line">            JP_FWD_RET_CALL_JS</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        case <span class="character">&#x27;&#123;&#x27;</span>: &#123;</span><br><span class="line">            NSString *typeString = extract<span class="constructor">StructName([NSString <span class="params">stringWithUTF8String</span>:<span class="params">returnType</span>])</span>;</span><br><span class="line">            #define <span class="constructor">JP_FWD_RET_STRUCT(<span class="params">_type</span>, <span class="params">_funcSuffix</span>)</span> \</span><br><span class="line">            <span class="keyword">if</span> (<span class="literal">[<span class="identifier">typeString</span> <span class="identifier">rangeOfString</span>:@#<span class="identifier">_type</span>]</span>.location != NSNotFound) &#123;    \</span><br><span class="line">                JP_FWD_RET_CALL_JS \</span><br><span class="line">                _type ret = <span class="literal">[<span class="identifier">jsval</span> <span class="identifier">_funcSuffix</span>]</span>; \</span><br><span class="line">                <span class="literal">[<span class="identifier">invocation</span> <span class="identifier">setReturnValue</span>:&amp;<span class="identifier">ret</span>]</span>;\</span><br><span class="line">                break;  \</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="constructor">JP_FWD_RET_STRUCT(CGRect, <span class="params">toRect</span>)</span></span><br><span class="line">            <span class="constructor">JP_FWD_RET_STRUCT(CGPoint, <span class="params">toPoint</span>)</span></span><br><span class="line">            <span class="constructor">JP_FWD_RET_STRUCT(CGSize, <span class="params">toSize</span>)</span></span><br><span class="line">            <span class="constructor">JP_FWD_RET_STRUCT(NSRange, <span class="params">toRange</span>)</span></span><br><span class="line">            </span><br><span class="line">            @synchronized (_context) &#123;</span><br><span class="line">                NSDictionary *structDefine = _registeredStruct<span class="literal">[<span class="identifier">typeString</span>]</span>;</span><br><span class="line">                <span class="keyword">if</span> (structDefine) &#123;</span><br><span class="line">                    size_t size = size<span class="constructor">OfStructTypes(<span class="params">structDefine</span>[@<span class="string">&quot;types&quot;</span>])</span>;</span><br><span class="line">                    JP_FWD_RET_CALL_JS</span><br><span class="line">                    void *ret = malloc(size);</span><br><span class="line">                    NSDictionary *dict = format<span class="constructor">JSToOC(<span class="params">jsval</span>)</span>;</span><br><span class="line">                    get<span class="constructor">StructDataWithDict(<span class="params">ret</span>, <span class="params">dict</span>, <span class="params">structDefine</span>)</span>;</span><br><span class="line">                    <span class="literal">[<span class="identifier">invocation</span> <span class="identifier">setReturnValue</span>:<span class="identifier">ret</span>]</span>;</span><br><span class="line">                    free(ret);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        default: &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (_pointersToRelease) &#123;</span><br><span class="line">        <span class="keyword">for</span> (NSValue *<span class="keyword">val</span> <span class="keyword">in</span> _pointersToRelease) &#123;</span><br><span class="line">            void *pointer = NULL;</span><br><span class="line">            <span class="literal">[<span class="identifier">val</span> <span class="identifier">getValue</span>:&amp;<span class="identifier">pointer</span>]</span>;</span><br><span class="line">            <span class="constructor">CFRelease(<span class="params">pointer</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        _pointersToRelease = nil;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//8.待替换的方法是 delloc 需要特殊处理：</span></span><br><span class="line">    <span class="keyword">if</span> (deallocFlag) &#123;</span><br><span class="line">        slf = nil;</span><br><span class="line">        Class instClass = <span class="keyword">object</span><span class="constructor">_getClass(<span class="params">assignSlf</span>)</span>;</span><br><span class="line">        Method deallocMethod = <span class="keyword">class</span><span class="constructor">_getInstanceMethod(<span class="params">instClass</span>, NSSelectorFromString(@<span class="string">&quot;ORIGdealloc&quot;</span>)</span>);</span><br><span class="line">        <span class="comment">//获取原delloc imp 指针，调用delloc，防止内存泄漏.</span></span><br><span class="line">        void (*originalDealloc)(__unsafe_unretained id, SEL) = (<span class="constructor">__typeof__(<span class="params">originalDealloc</span>)</span>)<span class="keyword">method</span><span class="constructor">_getImplementation(<span class="params">deallocMethod</span>)</span>;</span><br><span class="line">        original<span class="constructor">Dealloc(<span class="params">assignSlf</span>, NSSelectorFromString(@<span class="string">&quot;dealloc&quot;</span>)</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>JPForwardInvocation 会先从 NSInvocation中取出selector 名称，现在selector名称之前加上_JP,然后看下当前对象是否有对应的方法，我们在overideMethod方法中了解到，如果我们热修复js脚本中有对应的方法，那么就会在该对象中多出一个_JP开头的方法，指向热修复补丁中的实现。<br>所以这里会先看下当前方法中是否有对应的补丁方法，如果没有就调用JPExecuteORIGForwardInvocation走原来的消息分发机制。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">static void <span class="constructor">JPExecuteORIGForwardInvocation(<span class="params">id</span> <span class="params">slf</span>, SEL <span class="params">selector</span>, NSInvocation <span class="operator">*</span><span class="params">invocation</span>)</span> &#123;</span><br><span class="line">    SEL origForwardSelector = @selector(ORIGforwardInvocation:);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">[<span class="identifier">slf</span> <span class="identifier">respondsToSelector</span>:<span class="identifier">origForwardSelector</span>]</span>) &#123;</span><br><span class="line">        NSMethodSignature *methodSignature = <span class="literal">[<span class="identifier">slf</span> <span class="identifier">methodSignatureForSelector</span>:<span class="identifier">origForwardSelector</span>]</span>;</span><br><span class="line">        <span class="keyword">if</span> (!methodSignature) &#123;</span><br><span class="line">            <span class="constructor">_exceptionBlock([NSString <span class="params">stringWithFormat</span>:@<span class="string">&quot;unrecognized selector -ORIGforwardInvocation: for instance %@&quot;</span>, <span class="params">slf</span>])</span>;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        NSInvocation *forwardInv= <span class="literal">[NSI<span class="identifier">nvocation</span> <span class="identifier">invocationWithMethodSignature</span>:<span class="identifier">methodSignature</span>]</span>;</span><br><span class="line">        <span class="literal">[<span class="identifier">forwardInv</span> <span class="identifier">setTarget</span>:<span class="identifier">slf</span>]</span>;</span><br><span class="line">        <span class="literal">[<span class="identifier">forwardInv</span> <span class="identifier">setSelector</span>:<span class="identifier">origForwardSelector</span>]</span>;</span><br><span class="line">        <span class="literal">[<span class="identifier">forwardInv</span> <span class="identifier">setArgument</span>:&amp;<span class="identifier">invocation</span> <span class="identifier">atIndex</span>:<span class="number">2</span>]</span>;</span><br><span class="line">        <span class="literal">[<span class="identifier">forwardInv</span> <span class="identifier">invoke</span>]</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Class superCls = <span class="literal">[[<span class="identifier">slf</span> <span class="identifier">class</span>]</span> superclass];</span><br><span class="line">        Method superForwardMethod = <span class="keyword">class</span><span class="constructor">_getInstanceMethod(<span class="params">superCls</span>, @<span class="params">selector</span>(<span class="params">forwardInvocation</span>:)</span>);</span><br><span class="line">        void (*superForwardIMP)(id, SEL, NSInvocation *);</span><br><span class="line">        superForwardIMP = (void (*)(id, SEL, NSInvocation *))<span class="keyword">method</span><span class="constructor">_getImplementation(<span class="params">superForwardMethod</span>)</span>;</span><br><span class="line">        super<span class="constructor">ForwardIMP(<span class="params">slf</span>, @<span class="params">selector</span>(<span class="params">forwardInvocation</span>:)</span>, invocation);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果有的话，会把NSInvocation中的参数提取出来，传递给对应的补丁方法。然后通过JP_FWD_RET_CALL_JS调用js方法。通过JP_FWD_RET_CALL_JS中的</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">jsval</span> = [cb callWithArguments:args]</span><br></pre></td></tr></table></figure>
<p>获取到返回值后设置到NSInvocation中，完成方法的替换。</p>
<p>比如我们上面介绍的例子中有一个handleBtn. 原来的方法实现是空实现，后面通过JSPatch的demo.js 覆盖了这个方法，我们梳理下这是怎么实现的：</p>
<p>由于我们原有对象已经有了这个方法，只不过这个方法是空的，所以在overideMethod方法中会将原来的方法的selector名称改为_ORIGHandleBtn,指向原来的实现：</p>
<figure class="highlight erlang"><table><tr><td class="code"><pre><span class="line">- <span class="params">(void)</span>handleBtn:<span class="params">(id)</span>sender &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>而会在该类中添加一个_JPhandleBtn,它的实现指向补丁js中的实现。<br>并且由于该对象没有实现forwardInvocaiton 所以会为该对象新增加一个JPForwardInvocation，并且将原来的对handleBtn的调用转换为_objc_msgForward。这一切工作完成后我们来看下整个调用过程：<br>我们点击按钮后会触发handleBtn，这时候由于handleBtn的实现被替换为_objc_msgForward所以会走消息分发途径，进而走到forwardInvocaiton，由于forwardInvocaiton的实现在上面被替换为JPForwardInvocation<br>在JPForwardInvocation中会先尝试将消息转发到_JPhandleBtn看下是否有这个实现，这里由于有这个实现所以就直接将invocation参数提取出来，传递给对应的js方法执行。这就达到了整个方法替换的目的。</p>
<p><strong><strong>如何在JS环境下执行OC方法</strong></strong></p>
<p>我们上面了解到了怎么通过消息转发来达到热修复的目的，接下来我们还有一个问题就是如何在JS中执行OC方法，我们看下_evaluateScript，它的作用是将补丁js方法加载到JSContext中执行。我们还是以demo.js为例子</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="operator">+</span> (<span class="type">JSValue</span> <span class="operator">*</span>)_evaluateScript:(<span class="type">NSString</span> <span class="operator">*</span>)script withSourceURL:(<span class="type">NSURL</span> <span class="operator">*</span>)resourceURL &#123;</span><br><span class="line">    <span class="comment">//1. script 不存在或当前 iOS 版本低于 7.0 退出.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="operator">!</span>script <span class="operator">||</span> <span class="operator">!</span>[<span class="type">JSContext</span> <span class="keyword">class</span>]) &#123;</span><br><span class="line">        _exceptionBlock(@<span class="string">&quot;script is nil&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//在执行脚本之前会自动调用startEngine</span></span><br><span class="line">    [<span class="keyword">self</span> startEngine];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 正则式构建 (?&lt;!\\\\)\\.\\s*(\\w+)\\s*\\(</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="operator">!</span>_regex) &#123;</span><br><span class="line">        _regex <span class="operator">=</span> [<span class="type">NSRegularExpression</span> regularExpressionWithPattern:_regexStr options:<span class="number">0</span> error:<span class="literal">nil</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">NSString</span> <span class="operator">*</span>formatedScript <span class="operator">=</span> [<span class="type">NSString</span> stringWithFormat:@<span class="string">&quot;;(function()&#123;try&#123;<span class="subst">\n</span>%@<span class="subst">\n</span>&#125;catch(e)&#123;_OC_catch(e.message, e.stack)&#125;&#125;)();&quot;</span>, [_regex stringByReplacingMatchesInString:script options:<span class="number">0</span> range:<span class="type">NSMakeRange</span>(<span class="number">0</span>, script.length) withTemplate:_replaceStr]];</span><br><span class="line">    <span class="comment">//4.将正则处理后的js代码加载到 context 执行.(进入 JavaScriptCore)</span></span><br><span class="line">    <span class="meta">@try</span> &#123;</span><br><span class="line">        <span class="comment">//转换 JPTableViewController.alloc().init() 为 JPTableViewController.__c(&quot;alloc&quot;)().__c(&quot;init&quot;)()</span></span><br><span class="line">        <span class="keyword">if</span> ([_context respondsToSelector:<span class="meta">@selector</span>(evaluateScript:withSourceURL:)]) &#123;</span><br><span class="line">            <span class="keyword">return</span> [_context evaluateScript:formatedScript withSourceURL:resourceURL];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> [_context evaluateScript:formatedScript];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@catch</span> (<span class="type">NSException</span> <span class="operator">*</span>exception) &#123;</span><br><span class="line">        _exceptionBlock([<span class="type">NSString</span> stringWithFormat:@<span class="string">&quot;%@&quot;</span>, exception]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>demo.js加载后会先通过正则匹配处理后再送到JSContext中，我们看下匹配替换后的formatedScript是什么样的：</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line"><span class="comment">;(function()&#123;try&#123;</span></span><br><span class="line">defineClass(&#x27;JPViewController&#x27;, &#123;</span><br><span class="line">  handleBtn: function(<span class="name">sender</span>) &#123;</span><br><span class="line">    var tableViewCtrl = JPTableViewController.__c(<span class="string">&quot;alloc&quot;</span>)().__c(<span class="string">&quot;init&quot;</span>)()</span><br><span class="line">    self.__c(<span class="string">&quot;navigationController&quot;</span>)().__c(<span class="string">&quot;pushViewController_animated&quot;</span>)(<span class="name">tableViewCtrl</span>, YES)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">defineClass(&#x27;JPTableViewController : UITableViewController &lt;UIAlertViewDelegate&gt;&#x27;, [&#x27;data&#x27;], &#123;</span><br><span class="line">  dataSource: function() &#123;</span><br><span class="line">    var data = self.__c(<span class="string">&quot;data&quot;</span>)()<span class="comment">;</span></span><br><span class="line">    if (<span class="name">data</span>) return data<span class="comment">;</span></span><br><span class="line">    var data = []<span class="comment">;</span></span><br><span class="line">    for (<span class="name">var</span> i = <span class="number">0</span><span class="comment">; i &lt; 20; i ++) &#123;</span></span><br><span class="line">      data.__c(<span class="string">&quot;push&quot;</span>)(<span class="string">&quot;cell from js &quot;</span> + i)<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">    self.__c(<span class="string">&quot;setData&quot;</span>)(<span class="name">data</span>)</span><br><span class="line">    return data<span class="comment">;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  numberOfSectionsInTableView: function(<span class="name">tableView</span>) &#123;</span><br><span class="line">    return <span class="number">1</span><span class="comment">;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  tableView_numberOfRowsInSection: function(<span class="name">tableView</span>, section) &#123;</span><br><span class="line">    return self.__c(<span class="string">&quot;dataSource&quot;</span>)().length<span class="comment">;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  tableView_cellForRowAtIndexPath: function(<span class="name">tableView</span>, indexPath) &#123;</span><br><span class="line">    var cell = tableView.__c(<span class="string">&quot;dequeueReusableCellWithIdentifier&quot;</span>)(<span class="string">&quot;cell&quot;</span>) </span><br><span class="line">    if (!cell) &#123;</span><br><span class="line">      cell = require(&#x27;UITableViewCell&#x27;).__c(<span class="string">&quot;alloc&quot;</span>)().__c(<span class="string">&quot;initWithStyle_reuseIdentifier&quot;</span>)(<span class="number">0</span>, <span class="string">&quot;cell&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    cell.__c(<span class="string">&quot;textLabel&quot;</span>)().__c(<span class="string">&quot;setText&quot;</span>)(<span class="name">self</span>.__c(<span class="string">&quot;dataSource&quot;</span>)()[indexPath.__c(<span class="string">&quot;row&quot;</span>)()])</span><br><span class="line">    return cell</span><br><span class="line">  &#125;,</span><br><span class="line">  tableView_heightForRowAtIndexPath: function(<span class="name">tableView</span>, indexPath) &#123;</span><br><span class="line">    return <span class="number">60</span></span><br><span class="line">  &#125;,</span><br><span class="line">  tableView_didSelectRowAtIndexPath: function(<span class="name">tableView</span>, indexPath) &#123;</span><br><span class="line">     var alertView = require(&#x27;UIAlertView&#x27;).__c(<span class="string">&quot;alloc&quot;</span>)().__c(<span class="string">&quot;initWithTitle_message_delegate_cancelButtonTitle_otherButtonTitles&quot;</span>)(<span class="string">&quot;Alert&quot;</span>,self.__c(<span class="string">&quot;dataSource&quot;</span>)()[indexPath.__c(<span class="string">&quot;row&quot;</span>)()], self, <span class="string">&quot;OK&quot;</span>,  null)<span class="comment">;</span></span><br><span class="line">     alertView.__c(<span class="string">&quot;show&quot;</span>)()</span><br><span class="line">  &#125;,</span><br><span class="line">  alertView_willDismissWithButtonIndex: function(<span class="name">alertView</span>, idx) &#123;</span><br><span class="line">    console.__c(<span class="string">&quot;log&quot;</span>)(&#x27;click btn &#x27; + alertView.__c(<span class="string">&quot;buttonTitleAtIndex&quot;</span>)(<span class="name">idx</span>).__c(<span class="string">&quot;toJS&quot;</span>)())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;catch(<span class="name">e</span>)&#123;_OC_catch(<span class="name">e</span>.message, e.stack)&#125;&#125;)()<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>大家可以发现所有的xxx.XXXX 都被替换成了xxx.__c(“XXXX),为什么需要这样转换呢？我们到JSPatch.js寻找这个答案：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">__c</span>: <span class="keyword">function</span>(<span class="params">methodName</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> slf = <span class="variable language_">this</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (slf <span class="keyword">instanceof</span> <span class="title class_">Boolean</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (slf[methodName]) &#123;</span><br><span class="line">    <span class="keyword">return</span> slf[methodName].<span class="title function_">bind</span>(slf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!slf.<span class="property">__obj</span> &amp;&amp; !slf.<span class="property">__clsName</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(slf + <span class="string">&#x27;.&#x27;</span> + methodName + <span class="string">&#x27; is undefined&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (slf.<span class="property">__isSuper</span> &amp;&amp; slf.<span class="property">__clsName</span>) &#123;</span><br><span class="line">        slf.<span class="property">__clsName</span> = <span class="title function_">_OC_superClsName</span>(slf.<span class="property">__obj</span>.<span class="property">__realClsName</span> ? slf.<span class="property">__obj</span>.<span class="property">__realClsName</span>: slf.<span class="property">__clsName</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> clsName = slf.<span class="property">__clsName</span></span><br><span class="line">    <span class="keyword">if</span> (clsName &amp;&amp; _ocCls[clsName]) &#123;</span><br><span class="line">    <span class="keyword">var</span> methodType = slf.<span class="property">__obj</span> ? <span class="string">&#x27;instMethods&#x27;</span>: <span class="string">&#x27;clsMethods&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> (_ocCls[clsName][methodType][methodName]) &#123;</span><br><span class="line">        slf.<span class="property">__isSuper</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> _ocCls[clsName][methodType][methodName].<span class="title function_">bind</span>(slf)</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">var</span> args = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>)</span><br><span class="line">        <span class="comment">//_methodFunc() 把相关信息传给OC，OC用 Runtime 接口调用相应方法，返回结果值，这个调用就结束了。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">_methodFunc</span>(slf.<span class="property">__obj</span>, slf.<span class="property">__clsName</span>, methodName, args, slf.<span class="property">__isSuper</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">*  <span class="attr">instance</span>: 对象</span><br><span class="line">*  <span class="attr">clsName</span>: 类名</span><br><span class="line">*  <span class="attr">methodName</span>: 方法名</span><br><span class="line">*  <span class="attr">args</span>: 参数列表</span><br><span class="line">*  <span class="attr">isSuper</span>: 是否调用<span class="variable language_">super</span>父类的方法</span><br><span class="line">*  <span class="attr">isPerformSelector</span>:是否用performSelector方式调用</span><br><span class="line">*/</span><br><span class="line"><span class="keyword">var</span> _methodFunc = <span class="keyword">function</span>(<span class="params">instance, clsName, methodName, args, isSuper, isPerformSelector</span>) &#123;</span><br><span class="line"><span class="keyword">var</span> selectorName = methodName</span><br><span class="line"><span class="keyword">if</span> (!isPerformSelector) &#123;</span><br><span class="line">    <span class="comment">//处理得到OC中的方法SEL,参数</span></span><br><span class="line">    methodName = methodName.<span class="title function_">replace</span>(<span class="regexp">/__/g</span>, <span class="string">&quot;-&quot;</span>)</span><br><span class="line">    selectorName = methodName.<span class="title function_">replace</span>(<span class="regexp">/_/g</span>, <span class="string">&quot;:&quot;</span>).<span class="title function_">replace</span>(<span class="regexp">/-/g</span>, <span class="string">&quot;_&quot;</span>)</span><br><span class="line">    <span class="keyword">var</span> marchArr = selectorName.<span class="title function_">match</span>(<span class="regexp">/:/g</span>)</span><br><span class="line">    <span class="keyword">var</span> numOfArgs = marchArr ? marchArr.<span class="property">length</span> : <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> (args.<span class="property">length</span> &gt; numOfArgs) &#123;</span><br><span class="line">    selectorName += <span class="string">&quot;:&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当前是否是一个实例，如果是实例调用_OC_callI否则调用_OC_callC</span></span><br><span class="line"><span class="keyword">var</span> ret = instance ? <span class="title function_">_OC_callI</span>(instance, selectorName, args, isSuper):</span><br><span class="line">                        <span class="title function_">_OC_callC</span>(clsName, selectorName, args)</span><br><span class="line"><span class="comment">//获取OC方法执行完毕的返回值，并转化成JS对象</span></span><br><span class="line"><span class="keyword">return</span> <span class="title function_">_formatOCToJS</span>(ret)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>__c 里面会调用_methodFunc，_methodFunc方法里面会根据当前方法是实例方法还是类方法决定调用_OC_callI还是_OC_callC。最后将oc中的返回值转换为JS对象返回。<br>_OC_callI还是_OC_callC是在我们初始化JSPatch引擎的时候注入到JS中的。在js中调用_OC_callI或者_OC_callC会触发调用OC层的callSelector方法,通过它将js中的补丁方法中oc相关的方法交给oc层。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  完成oc中的方法调用</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @param className    类名（nil --&gt; 表示实例方法）</span></span><br><span class="line"><span class="comment"> *  @param selectorName 方法SEL值</span></span><br><span class="line"><span class="comment"> *  @param arguments    方法执行参数</span></span><br><span class="line"><span class="comment"> *  @param instance     对象（js对象中的变量，如: var UIAlertView = &#123; __clsName : &#x27;UIAlertView&#x27;&#125;）</span></span><br><span class="line"><span class="comment"> *  @param isSuper      是否调用的是父类方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @return 方法执行后的结果值，返回给js代码中.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">#pragma mark -</span><br><span class="line">static id call<span class="constructor">Selector(NSString <span class="operator">*</span><span class="params">className</span>, NSString <span class="operator">*</span><span class="params">selectorName</span>, JSValue <span class="operator">*</span><span class="params">arguments</span>, JSValue <span class="operator">*</span><span class="params">instance</span>, BOOL <span class="params">isSuper</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    NSString *realClsName = <span class="literal">[[<span class="identifier">instance</span> <span class="identifier">valueForProperty</span>:@&quot;<span class="identifier">__realClsName</span>&quot;]</span> toString];</span><br><span class="line">   </span><br><span class="line">    <span class="comment">///[1] 实例变量处理</span></span><br><span class="line">    <span class="keyword">if</span> (instance) &#123;</span><br><span class="line">        <span class="comment">//1.将js封装的instance对象进行拆装，得到oc对象.</span></span><br><span class="line">        instance = format<span class="constructor">JSToOC(<span class="params">instance</span>)</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">class</span><span class="constructor">_isMetaClass(<span class="params">object_getClass</span>(<span class="params">instance</span>)</span>)) &#123;</span><br><span class="line">            <span class="comment">//如果调用的是类方法则获取到类名</span></span><br><span class="line">            className = <span class="constructor">NSStringFromClass((Class)</span>instance);</span><br><span class="line">            instance = nil;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!instance<span class="operator"> || </span>instance<span class="operator"> == </span>_nilObj<span class="operator"> || </span><span class="literal">[<span class="identifier">instance</span> <span class="identifier">isKindOfClass</span>:[JPB<span class="identifier">oxing</span> <span class="identifier">class</span>]</span>]) &#123;</span><br><span class="line">            <span class="comment">//如果不是类方法，但是传入的instance 是空的则返回 nil</span></span><br><span class="line">            return @&#123;@<span class="string">&quot;__isNil&quot;</span>: @(YES)&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">///[2] 参数处理</span></span><br><span class="line">    <span class="comment">//2.将js封装的参数列表转为oc类型.</span></span><br><span class="line">    id argumentsObj = format<span class="constructor">JSToOC(<span class="params">arguments</span>)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">///[2] 解包处理</span></span><br><span class="line">    <span class="keyword">if</span> (instance<span class="operator"> &amp;&amp; </span><span class="literal">[<span class="identifier">selectorName</span> <span class="identifier">isEqualToString</span>:@&quot;<span class="identifier">toJS</span>&quot;]</span>) &#123;</span><br><span class="line"><span class="comment">//      3.如果要执行的方法是&quot;toJS&quot;，即转化为js类型，对于NSString/NSDictory/NSArray/NSData需进行特殊处理</span></span><br><span class="line"><span class="comment">//        因为JSPatch中需使用JPBoxing包装OC中的上述对象，防止JavaScriptCore.framework转换类型.</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">[<span class="identifier">instance</span> <span class="identifier">isKindOfClass</span>:[NSS<span class="identifier">tring</span> <span class="identifier">class</span>]</span>]<span class="operator"> || </span><span class="literal">[<span class="identifier">instance</span> <span class="identifier">isKindOfClass</span>:[NSD<span class="identifier">ictionary</span> <span class="identifier">class</span>]</span>]<span class="operator"> || </span><span class="literal">[<span class="identifier">instance</span> <span class="identifier">isKindOfClass</span>:[NSA<span class="identifier">rray</span> <span class="identifier">class</span>]</span>]<span class="operator"> || </span><span class="literal">[<span class="identifier">instance</span> <span class="identifier">isKindOfClass</span>:[NSD<span class="identifier">ate</span> <span class="identifier">class</span>]</span>]) &#123;</span><br><span class="line">            return <span class="constructor">_unboxOCObjectToJS(<span class="params">instance</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">///[3] 获取到Class对象</span></span><br><span class="line">    <span class="comment">//4.根据类名与selectorName获得对应的类对象与selector</span></span><br><span class="line">    Class cls = instance ? <span class="literal">[<span class="identifier">instance</span> <span class="identifier">class</span>]</span> : <span class="constructor">NSClassFromString(<span class="params">className</span>)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">///[3] 获取到SEL对象</span></span><br><span class="line">    SEL selector = <span class="constructor">NSSelectorFromString(<span class="params">selectorName</span>)</span>;</span><br><span class="line">    </span><br><span class="line">    NSString *superClassName = nil;</span><br><span class="line">    <span class="comment">//5.判断是否调用的是父类的方法，如果是，走父类的方法实现</span></span><br><span class="line">    <span class="keyword">if</span> (isSuper) &#123;</span><br><span class="line">        <span class="comment">//5.1 定义新的SEL:SUPERSEL</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">///[4] 构建出SUPER_seletcorName</span></span><br><span class="line">        NSString *superSelectorName = <span class="literal">[NSS<span class="identifier">tring</span> <span class="identifier">stringWithFormat</span>:@&quot;SUPER<span class="identifier">_</span>%@&quot;, <span class="identifier">selectorName</span>]</span>;</span><br><span class="line">        SEL superSelector = <span class="constructor">NSSelectorFromString(<span class="params">superSelectorName</span>)</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">///[5] 构建出superCls</span></span><br><span class="line">        Class superCls;</span><br><span class="line">        <span class="keyword">if</span> (realClsName.length) &#123;</span><br><span class="line">            Class defineClass = <span class="constructor">NSClassFromString(<span class="params">realClsName</span>)</span>;</span><br><span class="line">            superCls = defineClass ? <span class="literal">[<span class="identifier">defineClass</span> <span class="identifier">superclass</span>]</span> : <span class="literal">[<span class="identifier">cls</span> <span class="identifier">superclass</span>]</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            superCls = <span class="literal">[<span class="identifier">cls</span> <span class="identifier">superclass</span>]</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Method superMethod = <span class="keyword">class</span><span class="constructor">_getInstanceMethod(<span class="params">superCls</span>, <span class="params">selector</span>)</span>;</span><br><span class="line">        IMP superIMP = <span class="keyword">method</span><span class="constructor">_getImplementation(<span class="params">superMethod</span>)</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 5.2  将SUPERSEL指向superIMP的实现</span></span><br><span class="line">        <span class="comment">///[6] 添加superSelector方法</span></span><br><span class="line">        <span class="keyword">class</span><span class="constructor">_addMethod(<span class="params">cls</span>, <span class="params">superSelector</span>, <span class="params">superIMP</span>, <span class="params">method_getTypeEncoding</span>(<span class="params">superMethod</span>)</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//5.3  查找父类中是否有添加JPSEL的实现</span></span><br><span class="line">        NSString *JPSelectorName = <span class="literal">[NSS<span class="identifier">tring</span> <span class="identifier">stringWithFormat</span>:@&quot;<span class="identifier">_JP</span>%@&quot;, <span class="identifier">selectorName</span>]</span>;</span><br><span class="line">        JSValue *overideFunction = _JSOverideMethods<span class="literal">[<span class="identifier">superCls</span>]</span><span class="literal">[JPS<span class="identifier">electorName</span>]</span>;</span><br><span class="line">        <span class="keyword">if</span> (overideFunction) &#123;</span><br><span class="line">            <span class="comment">// 如果有，进行imp替换</span></span><br><span class="line">            override<span class="constructor">Method(<span class="params">cls</span>, <span class="params">superSelectorName</span>, <span class="params">overideFunction</span>, NO, NULL)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        selector = superSelector;</span><br><span class="line">        superClassName = <span class="constructor">NSStringFromClass(<span class="params">superCls</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    NSMutableArray *_markArray;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//6.通过类对象与selector构造对应的NSMethodSignature签名</span></span><br><span class="line">    NSInvocation *invocation;</span><br><span class="line">    NSMethodSignature *methodSignature;</span><br><span class="line">    <span class="keyword">if</span> (!_JSMethodSignatureCache) &#123;</span><br><span class="line">        _JSMethodSignatureCache = <span class="literal">[[NSM<span class="identifier">utableDictionary</span> <span class="identifier">alloc</span>]</span>init];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (instance) &#123;</span><br><span class="line">        <span class="literal">[<span class="identifier">_JSMethodSignatureLock</span> <span class="identifier">lock</span>]</span>;</span><br><span class="line">        <span class="keyword">if</span> (!_JSMethodSignatureCache<span class="literal">[<span class="identifier">cls</span>]</span>) &#123;</span><br><span class="line">            _JSMethodSignatureCache<span class="literal">[(<span class="identifier">id</span>&lt;NSC<span class="identifier">opying</span>&gt;)<span class="identifier">cls</span>]</span> = <span class="literal">[[NSM<span class="identifier">utableDictionary</span> <span class="identifier">alloc</span>]</span>init];</span><br><span class="line">        &#125;</span><br><span class="line">        methodSignature = _JSMethodSignatureCache<span class="literal">[<span class="identifier">cls</span>]</span><span class="literal">[<span class="identifier">selectorName</span>]</span>;</span><br><span class="line">        <span class="keyword">if</span> (!methodSignature) &#123;</span><br><span class="line">            <span class="comment">//区别在这里</span></span><br><span class="line">            methodSignature = <span class="literal">[<span class="identifier">cls</span> <span class="identifier">instanceMethodSignatureForSelector</span>:<span class="identifier">selector</span>]</span>;</span><br><span class="line">            methodSignature = fix<span class="constructor">Signature(<span class="params">methodSignature</span>)</span>;</span><br><span class="line">            _JSMethodSignatureCache<span class="literal">[<span class="identifier">cls</span>]</span><span class="literal">[<span class="identifier">selectorName</span>]</span> = methodSignature;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="literal">[<span class="identifier">_JSMethodSignatureLock</span> <span class="identifier">unlock</span>]</span>;</span><br><span class="line">        <span class="keyword">if</span> (!methodSignature) &#123;</span><br><span class="line">            <span class="constructor">_exceptionBlock([NSString <span class="params">stringWithFormat</span>:@<span class="string">&quot;unrecognized selector %@ for instance %@&quot;</span>, <span class="params">selectorName</span>, <span class="params">instance</span>])</span>;</span><br><span class="line">            return nil;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//7.根据签名构造NSInvocation对象</span></span><br><span class="line">        invocation = <span class="literal">[NSI<span class="identifier">nvocation</span> <span class="identifier">invocationWithMethodSignature</span>:<span class="identifier">methodSignature</span>]</span>;</span><br><span class="line">        <span class="comment">//8.为invocation对象设置target</span></span><br><span class="line">        <span class="literal">[<span class="identifier">invocation</span> <span class="identifier">setTarget</span>:<span class="identifier">instance</span>]</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//区别在这里</span></span><br><span class="line">        methodSignature = <span class="literal">[<span class="identifier">cls</span> <span class="identifier">methodSignatureForSelector</span>:<span class="identifier">selector</span>]</span>;</span><br><span class="line">        methodSignature = fix<span class="constructor">Signature(<span class="params">methodSignature</span>)</span>;</span><br><span class="line">        <span class="keyword">if</span> (!methodSignature) &#123;</span><br><span class="line">            <span class="constructor">_exceptionBlock([NSString <span class="params">stringWithFormat</span>:@<span class="string">&quot;unrecognized selector %@ for class %@&quot;</span>, <span class="params">selectorName</span>, <span class="params">className</span>])</span>;</span><br><span class="line">            return nil;</span><br><span class="line">        &#125;</span><br><span class="line">        invocation = <span class="literal">[NSI<span class="identifier">nvocation</span> <span class="identifier">invocationWithMethodSignature</span>:<span class="identifier">methodSignature</span>]</span>;</span><br><span class="line">        <span class="literal">[<span class="identifier">invocation</span> <span class="identifier">setTarget</span>:<span class="identifier">cls</span>]</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 9.为invocation对象设置selector</span></span><br><span class="line">    <span class="literal">[<span class="identifier">invocation</span> <span class="identifier">setSelector</span>:<span class="identifier">selector</span>]</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//10.根据签名得知每个参数的实际类型</span></span><br><span class="line">    NSUInteger numberOfArguments = methodSignature.numberOfArguments;</span><br><span class="line">    NSInteger inputArguments = <span class="literal">[(NSA<span class="identifier">rray</span> <span class="operator">*</span>)<span class="identifier">argumentsObj</span> <span class="identifier">count</span>]</span>;</span><br><span class="line">    <span class="keyword">if</span> (inputArguments &gt; numberOfArguments - <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">//10.1 多参数方法仅支持 id 类型参数和 id 类型返回,直接revoke并返回.</span></span><br><span class="line">        <span class="comment">// calling variable argument method, only support parameter type `id` and return type `id`</span></span><br><span class="line">        id sender = instance != nil ? instance : cls;</span><br><span class="line">        <span class="comment">//msg_send方法</span></span><br><span class="line">        id result = invoke<span class="constructor">VariableParameterMethod(<span class="params">argumentsObj</span>, <span class="params">methodSignature</span>, <span class="params">sender</span>, <span class="params">selector</span>)</span>;</span><br><span class="line">        return format<span class="constructor">OCToJS(<span class="params">result</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">///参数处理</span></span><br><span class="line">    <span class="comment">//10.2 将JS传递过来的参数进行对应的转换(如 NSNumber -&gt; int)，转换后为 NSInvoca</span></span><br><span class="line">    <span class="keyword">for</span> (NSUInteger i = <span class="number">2</span>; i &lt; numberOfArguments; i++) &#123;</span><br><span class="line">        const <span class="built_in">char</span> *argumentType = <span class="literal">[<span class="identifier">methodSignature</span> <span class="identifier">getArgumentTypeAtIndex</span>:<span class="identifier">i</span>]</span>;</span><br><span class="line">        id valObj = argumentsObj<span class="literal">[<span class="identifier">i</span>-<span class="number">2</span>]</span>;</span><br><span class="line">        switch (argumentType<span class="literal">[<span class="number">0</span>]</span><span class="operator"> == </span><span class="character">&#x27;r&#x27;</span> ? argumentType<span class="literal">[<span class="number">1</span>]</span> : argumentType<span class="literal">[<span class="number">0</span>]</span>) &#123;</span><br><span class="line">                </span><br><span class="line">                #define <span class="constructor">JP_CALL_ARG_CASE(<span class="params">_typeString</span>, <span class="params">_type</span>, <span class="params">_selector</span>)</span> \</span><br><span class="line">                case _typeString: &#123;                              \</span><br><span class="line">                    _type value = <span class="literal">[<span class="identifier">valObj</span> <span class="identifier">_selector</span>]</span>;                     \</span><br><span class="line">                    <span class="literal">[<span class="identifier">invocation</span> <span class="identifier">setArgument</span>:&amp;<span class="identifier">value</span> <span class="identifier">atIndex</span>:<span class="identifier">i</span>]</span>;\</span><br><span class="line">                    break; \</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="constructor">JP_CALL_ARG_CASE(&#x27;<span class="params">c</span>&#x27;, <span class="params">char</span>, <span class="params">charValue</span>)</span></span><br><span class="line">                <span class="constructor">JP_CALL_ARG_CASE(&#x27;C&#x27;, <span class="params">unsigned</span> <span class="params">char</span>, <span class="params">unsignedCharValue</span>)</span></span><br><span class="line">                <span class="constructor">JP_CALL_ARG_CASE(&#x27;<span class="params">s</span>&#x27;, <span class="params">short</span>, <span class="params">shortValue</span>)</span></span><br><span class="line">                <span class="constructor">JP_CALL_ARG_CASE(&#x27;S&#x27;, <span class="params">unsigned</span> <span class="params">short</span>, <span class="params">unsignedShortValue</span>)</span></span><br><span class="line">                <span class="constructor">JP_CALL_ARG_CASE(&#x27;<span class="params">i</span>&#x27;, <span class="params">int</span>, <span class="params">intValue</span>)</span></span><br><span class="line">                <span class="constructor">JP_CALL_ARG_CASE(&#x27;I&#x27;, <span class="params">unsigned</span> <span class="params">int</span>, <span class="params">unsignedIntValue</span>)</span></span><br><span class="line">                <span class="constructor">JP_CALL_ARG_CASE(&#x27;<span class="params">l</span>&#x27;, <span class="params">long</span>, <span class="params">longValue</span>)</span></span><br><span class="line">                <span class="constructor">JP_CALL_ARG_CASE(&#x27;L&#x27;, <span class="params">unsigned</span> <span class="params">long</span>, <span class="params">unsignedLongValue</span>)</span></span><br><span class="line">                <span class="constructor">JP_CALL_ARG_CASE(&#x27;<span class="params">q</span>&#x27;, <span class="params">long</span> <span class="params">long</span>, <span class="params">longLongValue</span>)</span></span><br><span class="line">                <span class="constructor">JP_CALL_ARG_CASE(&#x27;Q&#x27;, <span class="params">unsigned</span> <span class="params">long</span> <span class="params">long</span>, <span class="params">unsignedLongLongValue</span>)</span></span><br><span class="line">                <span class="constructor">JP_CALL_ARG_CASE(&#x27;<span class="params">f</span>&#x27;, <span class="params">float</span>, <span class="params">floatValue</span>)</span></span><br><span class="line">                <span class="constructor">JP_CALL_ARG_CASE(&#x27;<span class="params">d</span>&#x27;, <span class="params">double</span>, <span class="params">doubleValue</span>)</span></span><br><span class="line">                <span class="constructor">JP_CALL_ARG_CASE(&#x27;B&#x27;, BOOL, <span class="params">boolValue</span>)</span></span><br><span class="line">                </span><br><span class="line">            case <span class="character">&#x27;:&#x27;</span>: &#123;</span><br><span class="line">                SEL value = nil;</span><br><span class="line">                <span class="keyword">if</span> (valObj != _nilObj) &#123;</span><br><span class="line">                    value = <span class="constructor">NSSelectorFromString(<span class="params">valObj</span>)</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="literal">[<span class="identifier">invocation</span> <span class="identifier">setArgument</span>:&amp;<span class="identifier">value</span> <span class="identifier">atIndex</span>:<span class="identifier">i</span>]</span>;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            case <span class="character">&#x27;&#123;&#x27;</span>: &#123;</span><br><span class="line">                NSString *typeString = extract<span class="constructor">StructName([NSString <span class="params">stringWithUTF8String</span>:<span class="params">argumentType</span>])</span>;</span><br><span class="line">                JSValue *<span class="keyword">val</span> = arguments<span class="literal">[<span class="identifier">i</span>-<span class="number">2</span>]</span>;</span><br><span class="line">                #define <span class="constructor">JP_CALL_ARG_STRUCT(<span class="params">_type</span>, <span class="params">_methodName</span>)</span> \</span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">[<span class="identifier">typeString</span> <span class="identifier">rangeOfString</span>:@#<span class="identifier">_type</span>]</span>.location != NSNotFound) &#123;    \</span><br><span class="line">                    _type value = <span class="literal">[<span class="identifier">val</span> <span class="identifier">_methodName</span>]</span>;  \</span><br><span class="line">                    <span class="literal">[<span class="identifier">invocation</span> <span class="identifier">setArgument</span>:&amp;<span class="identifier">value</span> <span class="identifier">atIndex</span>:<span class="identifier">i</span>]</span>;  \</span><br><span class="line">                    break; \</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="constructor">JP_CALL_ARG_STRUCT(CGRect, <span class="params">toRect</span>)</span></span><br><span class="line">                <span class="constructor">JP_CALL_ARG_STRUCT(CGPoint, <span class="params">toPoint</span>)</span></span><br><span class="line">                <span class="constructor">JP_CALL_ARG_STRUCT(CGSize, <span class="params">toSize</span>)</span></span><br><span class="line">                <span class="constructor">JP_CALL_ARG_STRUCT(NSRange, <span class="params">toRange</span>)</span></span><br><span class="line">                @synchronized (_context) &#123;</span><br><span class="line">                    NSDictionary *structDefine = _registeredStruct<span class="literal">[<span class="identifier">typeString</span>]</span>;</span><br><span class="line">                    <span class="keyword">if</span> (structDefine) &#123;</span><br><span class="line">                        size_t size = size<span class="constructor">OfStructTypes(<span class="params">structDefine</span>[@<span class="string">&quot;types&quot;</span>])</span>;</span><br><span class="line">                        void *ret = malloc(size);</span><br><span class="line">                        get<span class="constructor">StructDataWithDict(<span class="params">ret</span>, <span class="params">valObj</span>, <span class="params">structDefine</span>)</span>;</span><br><span class="line">                        <span class="literal">[<span class="identifier">invocation</span> <span class="identifier">setArgument</span>:<span class="identifier">ret</span> <span class="identifier">atIndex</span>:<span class="identifier">i</span>]</span>;</span><br><span class="line">                        free(ret);</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            case <span class="character">&#x27;*&#x27;</span>:</span><br><span class="line">            case <span class="character">&#x27;^&#x27;</span>: &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">[<span class="identifier">valObj</span> <span class="identifier">isKindOfClass</span>:[JPB<span class="identifier">oxing</span> <span class="identifier">class</span>]</span>]) &#123;</span><br><span class="line">                    void *value = <span class="literal">[((JPB<span class="identifier">oxing</span> <span class="operator">*</span>)<span class="identifier">valObj</span>) <span class="identifier">unboxPointer</span>]</span>;</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">if</span> (argumentType<span class="literal">[<span class="number">1</span>]</span><span class="operator"> == </span><span class="character">&#x27;@&#x27;</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!_TMPMemoryPool) &#123;</span><br><span class="line">                            _TMPMemoryPool = <span class="literal">[[NSM<span class="identifier">utableDictionary</span> <span class="identifier">alloc</span>]</span> init];</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (!_markArray) &#123;</span><br><span class="line">                            _markArray = <span class="literal">[[NSM<span class="identifier">utableArray</span> <span class="identifier">alloc</span>]</span> init];</span><br><span class="line">                        &#125;</span><br><span class="line">                        memset(value, <span class="number">0</span>, sizeof(id));</span><br><span class="line">                        <span class="literal">[<span class="identifier">_markArray</span> <span class="identifier">addObject</span>:<span class="identifier">valObj</span>]</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                    <span class="literal">[<span class="identifier">invocation</span> <span class="identifier">setArgument</span>:&amp;<span class="identifier">value</span> <span class="identifier">atIndex</span>:<span class="identifier">i</span>]</span>;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            case <span class="character">&#x27;#&#x27;</span>: &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">[<span class="identifier">valObj</span> <span class="identifier">isKindOfClass</span>:[JPB<span class="identifier">oxing</span> <span class="identifier">class</span>]</span>]) &#123;</span><br><span class="line">                    Class value = <span class="literal">[((JPB<span class="identifier">oxing</span> <span class="operator">*</span>)<span class="identifier">valObj</span>) <span class="identifier">unboxClass</span>]</span>;</span><br><span class="line">                    <span class="literal">[<span class="identifier">invocation</span> <span class="identifier">setArgument</span>:&amp;<span class="identifier">value</span> <span class="identifier">atIndex</span>:<span class="identifier">i</span>]</span>;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            default: &#123;</span><br><span class="line">                <span class="keyword">if</span> (valObj<span class="operator"> == </span>_nullObj) &#123;</span><br><span class="line">                    valObj = <span class="literal">[NSN<span class="identifier">ull</span> <span class="identifier">null</span>]</span>;</span><br><span class="line">                    <span class="literal">[<span class="identifier">invocation</span> <span class="identifier">setArgument</span>:&amp;<span class="identifier">valObj</span> <span class="identifier">atIndex</span>:<span class="identifier">i</span>]</span>;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (valObj<span class="operator"> == </span>_nilObj<span class="operator"> ||</span></span><br><span class="line"><span class="operator">                    </span>(<span class="literal">[<span class="identifier">valObj</span> <span class="identifier">isKindOfClass</span>:[NSN<span class="identifier">umber</span> <span class="identifier">class</span>]</span>]<span class="operator"> &amp;&amp; </span>strcmp(<span class="literal">[<span class="identifier">valObj</span> <span class="identifier">objCType</span>]</span>, <span class="string">&quot;c&quot;</span>)<span class="operator"> == </span><span class="number">0</span><span class="operator"> &amp;&amp; </span>!<span class="literal">[<span class="identifier">valObj</span> <span class="identifier">boolValue</span>]</span>)) &#123;</span><br><span class="line">                    valObj = nil;</span><br><span class="line">                    <span class="literal">[<span class="identifier">invocation</span> <span class="identifier">setArgument</span>:&amp;<span class="identifier">valObj</span> <span class="identifier">atIndex</span>:<span class="identifier">i</span>]</span>;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">[(JSV<span class="identifier">alue</span> <span class="operator">*</span>)<span class="identifier">arguments</span>[<span class="identifier">i</span>-<span class="number">2</span>]</span> hasProperty:@<span class="string">&quot;__isBlock&quot;</span>]) &#123;</span><br><span class="line">                    JSValue *blkJSVal = arguments<span class="literal">[<span class="identifier">i</span>-<span class="number">2</span>]</span>;</span><br><span class="line">                    Class JPBlockClass = <span class="constructor">NSClassFromString(@<span class="string">&quot;JPBlock&quot;</span>)</span>;</span><br><span class="line">                    <span class="keyword">if</span> (JPBlockClass<span class="operator"> &amp;&amp; </span>!<span class="literal">[<span class="identifier">blkJSVal</span>[@&quot;<span class="identifier">blockObj</span>&quot;]</span> isUndefined]) &#123;</span><br><span class="line">                        __autoreleasing id cb = <span class="literal">[JPB<span class="identifier">lockClass</span> <span class="identifier">performSelector</span>:@<span class="identifier">selector</span>(<span class="identifier">blockWithBlockObj</span>:) <span class="identifier">withObject</span>:[<span class="identifier">blkJSVal</span>[@&quot;<span class="identifier">blockObj</span>&quot;]</span> toObject]];</span><br><span class="line">                        <span class="literal">[<span class="identifier">invocation</span> <span class="identifier">setArgument</span>:&amp;<span class="identifier">cb</span> <span class="identifier">atIndex</span>:<span class="identifier">i</span>]</span>;</span><br><span class="line">                        <span class="constructor">Block_release((<span class="params">__bridge</span> <span class="params">void</span> <span class="operator">*</span>)</span>cb);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        __autoreleasing id cb = gen<span class="constructor">CallbackBlock(<span class="params">arguments</span>[<span class="params">i</span>-2])</span>;</span><br><span class="line">                        <span class="literal">[<span class="identifier">invocation</span> <span class="identifier">setArgument</span>:&amp;<span class="identifier">cb</span> <span class="identifier">atIndex</span>:<span class="identifier">i</span>]</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="literal">[<span class="identifier">invocation</span> <span class="identifier">setArgument</span>:&amp;<span class="identifier">valObj</span> <span class="identifier">atIndex</span>:<span class="identifier">i</span>]</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (superClassName) _currInvokeSuperClsName<span class="literal">[<span class="identifier">selectorName</span>]</span> = superClassName;</span><br><span class="line">    <span class="comment">//11.执行 invoke 方法,并且传递指定的参数</span></span><br><span class="line">    <span class="literal">[<span class="identifier">invocation</span> <span class="identifier">invoke</span>]</span>;</span><br><span class="line">    <span class="keyword">if</span> (superClassName) <span class="literal">[<span class="identifier">_currInvokeSuperClsName</span> <span class="identifier">removeObjectForKey</span>:<span class="identifier">selectorName</span>]</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">[<span class="identifier">_markArray</span> <span class="identifier">count</span>]</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (JPBoxing *box <span class="keyword">in</span> _markArray) &#123;</span><br><span class="line">            void *pointer = <span class="literal">[<span class="identifier">box</span> <span class="identifier">unboxPointer</span>]</span>;</span><br><span class="line">            id obj = *((__unsafe_unretained id *)pointer);</span><br><span class="line">            <span class="keyword">if</span> (obj) &#123;</span><br><span class="line">                @synchronized(_TMPMemoryPool) &#123;</span><br><span class="line">                    <span class="literal">[<span class="identifier">_TMPMemoryPool</span> <span class="identifier">setObject</span>:<span class="identifier">obj</span> <span class="identifier">forKey</span>:[NSN<span class="identifier">umber</span> <span class="identifier">numberWithInteger</span>:[(NSO<span class="identifier">bject</span><span class="operator">*</span>)<span class="identifier">obj</span> <span class="identifier">hash</span>]</span>]];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">char</span> returnType<span class="literal">[<span class="number">255</span>]</span>;</span><br><span class="line">    strcpy(returnType, <span class="literal">[<span class="identifier">methodSignature</span> <span class="identifier">methodReturnType</span>]</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Restore the return type</span></span><br><span class="line">    <span class="keyword">if</span> (strcmp(returnType, @encode(JPDouble))<span class="operator"> == </span><span class="number">0</span>) &#123;</span><br><span class="line">        strcpy(returnType, @encode(double));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (strcmp(returnType, @encode(JPFloat))<span class="operator"> == </span><span class="number">0</span>) &#123;</span><br><span class="line">        strcpy(returnType, @encode(<span class="built_in">float</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    id returnValue;</span><br><span class="line">    <span class="comment">//12. 获取 invocation 运行返回值.</span></span><br><span class="line">    <span class="keyword">if</span> (strncmp(returnType, <span class="string">&quot;v&quot;</span>, <span class="number">1</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (strncmp(returnType, <span class="string">&quot;@&quot;</span>, <span class="number">1</span>)<span class="operator"> == </span><span class="number">0</span>) &#123;</span><br><span class="line">            void *result;</span><br><span class="line">            <span class="literal">[<span class="identifier">invocation</span> <span class="identifier">getReturnValue</span>:&amp;<span class="identifier">result</span>]</span>;</span><br><span class="line">            <span class="comment">// 13. 将返回值封装成JS对应的对象并返回.</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//For performance, ignore the other methods prefix with alloc/new/copy/mutableCopy</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="literal">[<span class="identifier">selectorName</span> <span class="identifier">isEqualToString</span>:@&quot;<span class="identifier">alloc</span>&quot;]</span><span class="operator"> || </span><span class="literal">[<span class="identifier">selectorName</span> <span class="identifier">isEqualToString</span>:@&quot;<span class="identifier">new</span>&quot;]</span><span class="operator"> ||</span></span><br><span class="line"><span class="operator">                </span><span class="literal">[<span class="identifier">selectorName</span> <span class="identifier">isEqualToString</span>:@&quot;<span class="identifier">copy</span>&quot;]</span><span class="operator"> || </span><span class="literal">[<span class="identifier">selectorName</span> <span class="identifier">isEqualToString</span>:@&quot;<span class="identifier">mutableCopy</span>&quot;]</span>) &#123;</span><br><span class="line">                returnValue = (__bridge_transfer id)result;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                returnValue = (__bridge id)result;</span><br><span class="line">            &#125;</span><br><span class="line">            return format<span class="constructor">OCToJS(<span class="params">returnValue</span>)</span>;</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            switch (returnType<span class="literal">[<span class="number">0</span>]</span><span class="operator"> == </span><span class="character">&#x27;r&#x27;</span> ? returnType<span class="literal">[<span class="number">1</span>]</span> : returnType<span class="literal">[<span class="number">0</span>]</span>) &#123;</span><br><span class="line">                    </span><br><span class="line">                #define <span class="constructor">JP_CALL_RET_CASE(<span class="params">_typeString</span>, <span class="params">_type</span>)</span> \</span><br><span class="line">                case _typeString: &#123;                              \</span><br><span class="line">                    _type tempResultSet; \</span><br><span class="line">                    <span class="literal">[<span class="identifier">invocation</span> <span class="identifier">getReturnValue</span>:&amp;<span class="identifier">tempResultSet</span>]</span>;\</span><br><span class="line">                    returnValue = @(tempResultSet); \</span><br><span class="line">                    break; \</span><br><span class="line">                &#125;</span><br><span class="line">                    </span><br><span class="line">                <span class="constructor">JP_CALL_RET_CASE(&#x27;<span class="params">c</span>&#x27;, <span class="params">char</span>)</span></span><br><span class="line">                <span class="constructor">JP_CALL_RET_CASE(&#x27;C&#x27;, <span class="params">unsigned</span> <span class="params">char</span>)</span></span><br><span class="line">                <span class="constructor">JP_CALL_RET_CASE(&#x27;<span class="params">s</span>&#x27;, <span class="params">short</span>)</span></span><br><span class="line">                <span class="constructor">JP_CALL_RET_CASE(&#x27;S&#x27;, <span class="params">unsigned</span> <span class="params">short</span>)</span></span><br><span class="line">                <span class="constructor">JP_CALL_RET_CASE(&#x27;<span class="params">i</span>&#x27;, <span class="params">int</span>)</span></span><br><span class="line">                <span class="constructor">JP_CALL_RET_CASE(&#x27;I&#x27;, <span class="params">unsigned</span> <span class="params">int</span>)</span></span><br><span class="line">                <span class="constructor">JP_CALL_RET_CASE(&#x27;<span class="params">l</span>&#x27;, <span class="params">long</span>)</span></span><br><span class="line">                <span class="constructor">JP_CALL_RET_CASE(&#x27;L&#x27;, <span class="params">unsigned</span> <span class="params">long</span>)</span></span><br><span class="line">                <span class="constructor">JP_CALL_RET_CASE(&#x27;<span class="params">q</span>&#x27;, <span class="params">long</span> <span class="params">long</span>)</span></span><br><span class="line">                <span class="constructor">JP_CALL_RET_CASE(&#x27;Q&#x27;, <span class="params">unsigned</span> <span class="params">long</span> <span class="params">long</span>)</span></span><br><span class="line">                <span class="constructor">JP_CALL_RET_CASE(&#x27;<span class="params">f</span>&#x27;, <span class="params">float</span>)</span></span><br><span class="line">                <span class="constructor">JP_CALL_RET_CASE(&#x27;<span class="params">d</span>&#x27;, <span class="params">double</span>)</span></span><br><span class="line">                <span class="constructor">JP_CALL_RET_CASE(&#x27;B&#x27;, BOOL)</span></span><br><span class="line"></span><br><span class="line">                case <span class="character">&#x27;&#123;&#x27;</span>: &#123;</span><br><span class="line">                    NSString *typeString = extract<span class="constructor">StructName([NSString <span class="params">stringWithUTF8String</span>:<span class="params">returnType</span>])</span>;</span><br><span class="line">                    #define <span class="constructor">JP_CALL_RET_STRUCT(<span class="params">_type</span>, <span class="params">_methodName</span>)</span> \</span><br><span class="line">                    <span class="keyword">if</span> (<span class="literal">[<span class="identifier">typeString</span> <span class="identifier">rangeOfString</span>:@#<span class="identifier">_type</span>]</span>.location != NSNotFound) &#123;    \</span><br><span class="line">                        _type result;   \</span><br><span class="line">                        <span class="literal">[<span class="identifier">invocation</span> <span class="identifier">getReturnValue</span>:&amp;<span class="identifier">result</span>]</span>;    \</span><br><span class="line">                        return <span class="literal">[JSV<span class="identifier">alue</span> <span class="identifier">_methodName</span>:<span class="identifier">result</span> <span class="identifier">inContext</span>:<span class="identifier">_context</span>]</span>;    \</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="constructor">JP_CALL_RET_STRUCT(CGRect, <span class="params">valueWithRect</span>)</span></span><br><span class="line">                    <span class="constructor">JP_CALL_RET_STRUCT(CGPoint, <span class="params">valueWithPoint</span>)</span></span><br><span class="line">                    <span class="constructor">JP_CALL_RET_STRUCT(CGSize, <span class="params">valueWithSize</span>)</span></span><br><span class="line">                    <span class="constructor">JP_CALL_RET_STRUCT(NSRange, <span class="params">valueWithRange</span>)</span></span><br><span class="line">                    @synchronized (_context) &#123;</span><br><span class="line">                        NSDictionary *structDefine = _registeredStruct<span class="literal">[<span class="identifier">typeString</span>]</span>;</span><br><span class="line">                        <span class="keyword">if</span> (structDefine) &#123;</span><br><span class="line">                            size_t size = size<span class="constructor">OfStructTypes(<span class="params">structDefine</span>[@<span class="string">&quot;types&quot;</span>])</span>;</span><br><span class="line">                            void *ret = malloc(size);</span><br><span class="line">                            <span class="literal">[<span class="identifier">invocation</span> <span class="identifier">getReturnValue</span>:<span class="identifier">ret</span>]</span>;</span><br><span class="line">                            NSDictionary *dict = get<span class="constructor">DictOfStruct(<span class="params">ret</span>, <span class="params">structDefine</span>)</span>;</span><br><span class="line">                            free(ret);</span><br><span class="line">                            return dict;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                case <span class="character">&#x27;*&#x27;</span>:</span><br><span class="line">                case <span class="character">&#x27;^&#x27;</span>: &#123;</span><br><span class="line">                    void *result;</span><br><span class="line">                    <span class="literal">[<span class="identifier">invocation</span> <span class="identifier">getReturnValue</span>:&amp;<span class="identifier">result</span>]</span>;</span><br><span class="line">                    returnValue = format<span class="constructor">OCToJS([JPBoxing <span class="params">boxPointer</span>:<span class="params">result</span>])</span>;</span><br><span class="line">                    <span class="keyword">if</span> (strncmp(returnType, <span class="string">&quot;^&#123;CG&quot;</span>, <span class="number">4</span>)<span class="operator"> == </span><span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!_pointersToRelease) &#123;</span><br><span class="line">                            _pointersToRelease = <span class="literal">[[NSM<span class="identifier">utableArray</span> <span class="identifier">alloc</span>]</span> init];</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="literal">[<span class="identifier">_pointersToRelease</span> <span class="identifier">addObject</span>:[NSV<span class="identifier">alue</span> <span class="identifier">valueWithPointer</span>:<span class="identifier">result</span>]</span>];</span><br><span class="line">                        <span class="constructor">CFRetain(<span class="params">result</span>)</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                case <span class="character">&#x27;#&#x27;</span>: &#123;</span><br><span class="line">                    Class result;</span><br><span class="line">                    <span class="literal">[<span class="identifier">invocation</span> <span class="identifier">getReturnValue</span>:&amp;<span class="identifier">result</span>]</span>;</span><br><span class="line">                    returnValue = format<span class="constructor">OCToJS([JPBoxing <span class="params">boxClass</span>:<span class="params">result</span>])</span>;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return returnValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>callSelector代码很长但是它所处理的任务比较比较明确，它主要是通过js传过来的参数来构建一个Invocation 通过[invocation invoke]来执行对应的方法。代码细节部分已经给出了较为详细的注解大家可以看下整个流程。</p>
<p>我们这里回顾下整个过程；</p>
<p>在启动JSPatch 引擎之后会向Context注入一系列的OC方法给JS回调。<br>紧接着加载JSPatch.js 它里面主要定义了一些关键方法，最主要的是__c,它会从中提取到OC消息转发所必须的一系列参数，通过_OC_callI或者_OC_callC 传给 OC 层， OC 层中调用callSelector 方法，通过js传过来的参数来构建一个Invocation 通过[invocation invoke]来执行对应的方法。<br>而在OC层中加载补丁js脚本后会将脚本中的xxx.XXXX 正则替换为xxx.__c(“XXXX”)，这样通过上面的解释后调用OC层方法，如果忽略掉这部分的整个细节，整个过程是js 补丁脚本中的 xxx.XXXX 最后会转为 OC中的[invocation invoke]<br>是不是有点巧妙？</p>
<hr>
<p><strong><strong>总结</strong></strong></p>
<p>这篇博客主要从如何通过消息转发机制来使用js补丁方法&#x2F;类来替换现有的方法，从而达到热修复的目的。以及如何将js中OC相关的代码交给OC层来处理。第一部分思路有点和Aspect类似，大家可以细细体会下，很巧妙的一个方案。下面是JSPatch的一个简单的框图。</p>
<p><img src="/2019/10/08/%E5%9B%BE%E8%A7%A3iOS%E7%B3%BB%E5%88%97%E4%B9%8BJSPatch-%E4%B8%80-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/001.png"></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/iOS-%E5%BC%80%E6%BA%90%E5%BA%93%E5%88%86%E6%9E%90/">iOS 开源库分析</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/iOS-开源库分析/">iOS 开源库分析</a>
  </div>

</div>



<div class="comments-count">
	
	  	<span></span>
		<a href="/2019/10/08/图解iOS系列之JSPatch-一-源码分析/#comments" class="ds-thread-count comments-count-link" data-thread-key="2019/10/08/图解iOS系列之JSPatch-一-源码分析/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/10/05/转-RAC-知识点汇总-总结得非常全/" title="[转]RAC 知识点汇总 总结得非常全" itemprop="url">[转]RAC 知识点汇总 总结得非常全</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Edgar" target="_blank" itemprop="author">Edgar</a>
		
  <p class="article-time">
    <time datetime="2019-10-04T16:40:09.000Z" itemprop="datePublished"> Published 2019-10-05</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="一：关于ReactiveCocoa的知识点"><a href="#一：关于ReactiveCocoa的知识点" class="headerlink" title="一：关于ReactiveCocoa的知识点"></a>一：关于ReactiveCocoa的知识点</h2><p>1：RACSigner基础知识点</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">信号类(RACSiganl)，只是表示当数据改变时，信号内部会发出数据，它本身不具备发送信号的能力，而是交给内部一个订阅者去发出。</span><br><span class="line"></span><br><span class="line">默认一个信号都是冷信号，也就是值改变了，也不会触发，只有订阅了这个信号，这个信号才会变为热信号，值改变了才会触发。</span><br><span class="line"></span><br><span class="line">如何订阅信号：调用信号RACSignal的<span class="keyword">subscribeNext就能订阅</span></span><br><span class="line"><span class="keyword"></span></span><br></pre></td></tr></table></figure>

<p>常见的操作方法：</p>
<figure class="highlight vbnet"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">flattenMap map 用于把源信号内容映射成新的内容。</span><br><span class="line"></span><br><span class="line">concat 组合 按一定顺序拼接信号，当多个信号发出的时候，有顺序的接收信号</span><br><span class="line"></span><br><span class="line"><span class="keyword">then</span> 用于连接两个信号，当第一个信号完成，才会连接<span class="keyword">then</span>返回的信号。</span><br><span class="line"></span><br><span class="line">merge 把多个信号合并为一个信号，任何一个信号有新值的时候就会调用</span><br><span class="line"></span><br><span class="line">zipWith 把两个信号压缩成一个信号，只有当两个信号同时发出信号内容时，并且把两个信号的内容合并成一个元组，才会触发压缩流的<span class="keyword">next</span>事件。</span><br><span class="line"></span><br><span class="line"><span class="symbol">combineLatest:</span>将多个信号合并起来，并且拿到各个信号的最新的值,必须每个合并的signal至少都有过一次sendNext，才会触发合并的信号。</span><br><span class="line"></span><br><span class="line">reduce聚合:用于信号发出的内容是元组，把信号发出元组的值聚合成一个值</span><br><span class="line"></span><br><span class="line"><span class="symbol">filter:</span>过滤信号，使用它可以获取满足条件的信号.</span><br><span class="line"></span><br><span class="line"><span class="symbol">ignore:</span>忽略完某些值的信号.</span><br><span class="line"></span><br><span class="line"><span class="symbol">distinctUntilChanged:</span>当上一次的值和当前的值有明显的变化就会发出信号，否则会被忽略掉。</span><br><span class="line"></span><br><span class="line"><span class="symbol">take:</span>从开始一共取N次的信号</span><br><span class="line"></span><br><span class="line"><span class="symbol">takeLast:</span>取最后N次的信号,前提条件，订阅者必须调用完成，因为只有完成，就知道总共有多少信号.</span><br><span class="line"></span><br><span class="line"><span class="symbol">takeUntil:</span>(RACSignal *):获取信号直到某个信号执行完成</span><br><span class="line"></span><br><span class="line"><span class="symbol">skip:</span>(NSUInteger):跳过几个信号,不接受。</span><br><span class="line"></span><br><span class="line"><span class="symbol">switchToLatest:</span>用于signalOfSignals（信号的信号），有时候信号也会发出信号，会在signalOfSignals中，获取signalOfSignals发送的最新信号。</span><br><span class="line"></span><br><span class="line"><span class="symbol">doNext:</span> 执行<span class="keyword">Next</span>之前，会先执行这个Block</span><br><span class="line"></span><br><span class="line"><span class="symbol">doCompleted:</span> 执行sendCompleted之前，会先执行这个Block</span><br><span class="line"></span><br><span class="line">timeout：超时，可以让一个信号在一定的时间后，自动报错。</span><br><span class="line"></span><br><span class="line">interval 定时：每隔一段时间发出信号</span><br><span class="line"></span><br><span class="line">delay 延迟发送<span class="keyword">next</span>。</span><br><span class="line"></span><br><span class="line">retry重试 ：只要失败，就会重新执行创建信号中的block,直到成功.</span><br><span class="line"></span><br><span class="line">replay重放：当一个信号被多次订阅,反复播放内容</span><br><span class="line"></span><br><span class="line">throttle节流:当某个信号发送比较频繁时，可以使用节流，在某一段时间不发送信号内容，过了一段时间获取信号的最新内容发出。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2：RACSubject基础知识点</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">RACSubject:</span>信号提供者，自己可以充当信号，又能发送信号  使用场景:通常用来代替代理，有了它，就不必要定义代理了</span><br><span class="line"></span><br><span class="line">RACSubject使用步骤</span><br><span class="line"><span class="number">1</span>.创建信号 [RACSubject <span class="keyword">subject]，跟RACSiganl不一样，创建信号时没有block。</span></span><br><span class="line"><span class="keyword"></span><span class="number">2</span>.订阅信号 - (RACDisposable *)<span class="keyword">subscribeNext:(void </span>(^)(id x))nextBlock</span><br><span class="line"><span class="number">3</span>.发送信号 sendNext:(id)value</span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">RACSubject:</span>底层实现和RACSignal不一样。</span><br><span class="line"><span class="number">1</span>.调用<span class="keyword">subscribeNext订阅信号，只是把订阅者保存起来，并且订阅者的nextBlock已经赋值了。</span></span><br><span class="line"><span class="keyword"></span><span class="number">2</span>.调用sendNext发送信号，遍历刚刚保存的所有订阅者，一个一个调用订阅者的nextBlock。</span><br><span class="line"></span><br><span class="line">RACSubject实例进行map操作之后, 发送完毕一定要调用-sendCompleted, 否则会出现内存泄漏<span class="comment">; 而RACSignal实例不管是否进行map操作, 不管是否调用-sendCompleted, 都不会出现内存泄漏.</span></span><br><span class="line">原因 : 因为RACSubject是热信号, 为了保证未来有事件发生的时候, 订阅者可以收到信息, 所以需要对持有订阅者!</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>3：RACSequence基础知识点</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="section">RACSequence:RAC中的集合类，用于代替NSArray,NSDictionary,可以使用它来快速遍历数组和字典</span></span><br><span class="line"></span><br><span class="line">通过RACSequence对数组进行操作</span><br><span class="line">这里其实是三步</span><br><span class="line"><span class="section">第一步: 把数组转换成集合RACSequence numbers.rac_sequence</span></span><br><span class="line"><span class="section">第二步: 把集合RACSequence转换RACSignal信号类,numbers.rac_sequence.signal</span></span><br><span class="line"><span class="section">第三步: 订阅信号，激活信号，会自动把集合中的所有值，遍历出来。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>4：RACCommand基础知识点</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">RACCommand:RAC中用于处理事件的类，可以把事件如何处理,事件中的数据如何传递，包装到这个类中，他可以很方便的监控事件的执行过程</span><br><span class="line"></span><br><span class="line">一、RACCommand使用步骤:</span><br><span class="line"><span class="number">1.</span>创建命令 initWithSignalBlock:(RACSignal * (^)(id <span class="built_in">input</span>))signalBlock</span><br><span class="line"><span class="number">2.</span>在signalBlock中，创建RACSignal，并且作为signalBlock的返回值</span><br><span class="line"><span class="number">3.</span>执行命令 - (RACSignal *)<span class="built_in">execute</span>:(id)<span class="built_in">input</span></span><br><span class="line"></span><br><span class="line">二、RACCommand使用注意:</span><br><span class="line"><span class="number">1.</span>signalBlock必须要返回一个信号，不能传<span class="literal">nil</span>.</span><br><span class="line"><span class="number">2.</span>如果不想要传递信号，直接创建空的信号[RACSignal empty];</span><br><span class="line"><span class="number">3.</span>RACCommand中信号如果数据传递完，必须调用[subscriber sendCompleted]，这时命令才会执行完毕，否则永远处于执行中。</span><br><span class="line"><span class="number">4.</span>RACCommand需要被强引用，否则接收不到RACCommand中的信号，因此RACCommand中的信号是延迟发送的。</span><br><span class="line"></span><br><span class="line">三、RACCommand设计思想：内部signalBlock为什么要返回一个信号，这个信号有什么用。</span><br><span class="line"><span class="number">1.</span>在RAC开发中，通常会把网络请求封装到RACCommand，直接执行某个RACCommand就能发送请求。</span><br><span class="line"><span class="number">2.</span>当RACCommand内部请求到数据的时候，需要把请求的数据传递给外界，这时候就需要通过signalBlock返回的信号传递了。</span><br><span class="line"></span><br><span class="line">四、如何拿到RACCommand中返回信号发出的数据。</span><br><span class="line"><span class="number">1.</span>RACCommand有个执行信号源executionSignals，这个是signal of signals(信号的信号),意思是信号发出的数据是信号，不是普通的类型。</span><br><span class="line"><span class="number">2.</span>订阅executionSignals就能拿到RACCommand中返回的信号，然后订阅signalBlock返回的信号，就能获取发出的值。</span><br><span class="line"></span><br><span class="line">五、监听当前命令是否正在执行executing</span><br><span class="line"></span><br><span class="line">六、使用场景,监听按钮点击，网络请求</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>5：RACMulticastConnection基础知识点</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">RACMulticastConnection:用于当一个信号，被多次订阅时，为了保证创建信号时，避免多次调用创建信号中的block，造成副作用，可以使用这个类处理</span><br><span class="line">使用注意:RACMulticastConnection通过RACSignal的-publish或者-muticast:方法创建.</span><br><span class="line"></span><br><span class="line">RACMulticastConnection使用步骤:</span><br><span class="line"><span class="number">1.</span>创建信号 + (RACSignal *)createSignal:(RACDisposable * (^)(id&lt;RACSubscriber&gt; subscriber))didSubscribe</span><br><span class="line"><span class="number">2.</span>创建连接 RACMulticastConnection *connect = [signal publish];</span><br><span class="line"><span class="number">3.</span>订阅信号,注意：订阅的不在是之前的信号，而是连接的信号。 [connect.signal subscribeNext:nextBlock]</span><br><span class="line"><span class="number">4.</span>连接 [connect connect]</span><br><span class="line"></span><br><span class="line">RACMulticastConnection底层原理:</span><br><span class="line"><span class="number">1.</span>创建connect，connect.sourceSignal -&gt; <span class="built_in">RACSignal</span>(原始信号)  connect.signal -&gt; RACSubject</span><br><span class="line"><span class="number">2.</span>订阅connect.signal，会调用RACSubject的subscribeNext，创建订阅者，而且把订阅者保存起来，不会执行block。</span><br><span class="line"><span class="number">3.</span>[connect connect]内部会订阅<span class="built_in">RACSignal</span>(原始信号)，并且订阅者是RACSubject</span><br><span class="line"><span class="number">3.1</span>.订阅原始信号，就会调用原始信号中的didSubscribe</span><br><span class="line"><span class="number">3.2</span> didSubscribe，拿到订阅者调用sendNext，其实是调用RACSubject的sendNext</span><br><span class="line"><span class="number">4.</span>RACSubject的sendNext,会遍历RACSubject所有订阅者发送信号。</span><br><span class="line"><span class="number">4.1</span> 因为刚刚第二步，都是在订阅RACSubject，因此会拿到第二步所有的订阅者，调用他们的nextBlock</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">需求：假设在一个信号中发送请求，每次订阅一次都会发送请求，这样就会导致多次请求。</span><br><span class="line">解决：使用RACMulticastConnection就能解决.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>6：RAC结合UI一般事件</p>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">rac_signalForSelector : 代替代理</span><br><span class="line"></span><br><span class="line"><span class="symbol">rac_valuesAndChangesForKeyPath:</span> KVO</span><br><span class="line"></span><br><span class="line"><span class="symbol">rac_signalForControlEvents:</span>监听事件</span><br><span class="line"></span><br><span class="line">rac_addObserverForName 代替通知</span><br><span class="line"></span><br><span class="line">rac_textSignal：监听文本框文字改变</span><br><span class="line"></span><br><span class="line"><span class="symbol">rac_liftSelector:</span>withSignalsFromArray:Signals:当传入的Signals(信号数组)，每一个signal都至少sendNext过一次，就会去触发第一个selector参数的方法。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>7：高阶操作知识内容</p>
<p>8：RAC并发编程知识点</p>
<figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">1</span>: subscribeOn运用</span><br><span class="line"></span><br><span class="line"><span class="symbol">RACSignal</span> *signal = [<span class="symbol">RACSignal</span> createSignal:^<span class="symbol">RACDisposable</span> *(id&lt;<span class="symbol">RACSubscriber</span>&gt; subscriber) &#123;</span><br><span class="line"><span class="symbol">NSLog</span>(@<span class="string">&quot;%@ 111&quot;</span>,[<span class="symbol">NSThread</span> currentThread]);</span><br><span class="line"></span><br><span class="line">//可以放更新<span class="symbol">UI</span>操作</span><br><span class="line"></span><br><span class="line">[subscriber sendNext:@<span class="number">0.1</span>];</span><br><span class="line"><span class="symbol">RACDisposable</span> *disposable = [[<span class="symbol">RACScheduler</span> scheduler] schedule:^&#123;</span><br><span class="line"><span class="symbol">NSLog</span>(@<span class="string">&quot;%@ 5555&quot;</span>,[<span class="symbol">NSThread</span> currentThread]);</span><br><span class="line">[subscriber sendNext:@<span class="number">1.1</span>];</span><br><span class="line">[subscriber sendCompleted];</span><br><span class="line">&#125;];</span><br><span class="line">return disposable;</span><br><span class="line">&#125;];</span><br><span class="line">[[<span class="symbol">RACScheduler</span> scheduler] schedule:^&#123;</span><br><span class="line"><span class="symbol">NSLog</span>(@<span class="string">&quot;%@ 222&quot;</span>,[<span class="symbol">NSThread</span> currentThread]);</span><br><span class="line">[[signal subscribeOn:[<span class="symbol">RACScheduler</span> mainThreadScheduler]] subscribeNext:^(id x) &#123;</span><br><span class="line"><span class="symbol">NSLog</span>(@<span class="string">&quot;%@ %@&quot;</span>,[<span class="symbol">NSThread</span> currentThread], x);</span><br><span class="line">&#125;]; &#125;];</span><br><span class="line"><span class="symbol">NSLog</span>(@<span class="string">&quot;%@ 4444&quot;</span>,[<span class="symbol">NSThread</span> currentThread]);</span><br><span class="line"></span><br><span class="line">//使用subscribeOn 可以让signal内的代码在主线程中运行，sendNext在哪个线程 则对应的订阅输出就在对应线程上，所以<span class="number">0.1</span>输出是在主线程中； 所以当在signal里面可能要放一些更新<span class="symbol">UI</span>的操作，而这些是要在主线程才能处理，而订阅者却无法确认，所以要使用subscribeOn让它在主线程中；</span><br><span class="line">//能够保证didSubscribe block在指定的scheduler</span><br><span class="line">//不能保证sendNext、 error、 complete在哪个scheduler</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>：deliverOn运用</span><br><span class="line"></span><br><span class="line"><span class="symbol">RACSignal</span> *signal = [<span class="symbol">RACSignal</span> createSignal:^<span class="symbol">RACDisposable</span> *(id&lt;<span class="symbol">RACSubscriber</span>&gt; subscriber) &#123;</span><br><span class="line"><span class="symbol">NSLog</span>(@<span class="string">&quot;%@ 111&quot;</span>,[<span class="symbol">NSThread</span> currentThread]);</span><br><span class="line">[subscriber sendNext:@<span class="number">0.1</span>];</span><br><span class="line"><span class="symbol">RACDisposable</span> *disposable = [[<span class="symbol">RACScheduler</span> scheduler] schedule:^&#123;</span><br><span class="line"><span class="symbol">NSLog</span>(@<span class="string">&quot;%@ 555&quot;</span>,[<span class="symbol">NSThread</span> currentThread]);</span><br><span class="line">[subscriber sendNext:@<span class="number">1.1</span>];</span><br><span class="line">[subscriber sendCompleted];</span><br><span class="line">&#125;];</span><br><span class="line">return disposable;</span><br><span class="line">&#125;];</span><br><span class="line">[[<span class="symbol">RACScheduler</span> scheduler] schedule:^&#123;</span><br><span class="line"><span class="symbol">NSLog</span>(@<span class="string">&quot;%@ 222&quot;</span>,[<span class="symbol">NSThread</span> currentThread]);</span><br><span class="line">[[signal deliverOn:[<span class="symbol">RACScheduler</span> mainThreadScheduler]] subscribeNext:^(id x) &#123;</span><br><span class="line"><span class="symbol">NSLog</span>(@<span class="string">&quot;%@ %@&quot;</span>,[<span class="symbol">NSThread</span> currentThread], x);</span><br><span class="line"></span><br><span class="line">//可以放<span class="symbol">UI</span>更新操作</span><br><span class="line"></span><br><span class="line">&#125;]; &#125;];</span><br><span class="line"></span><br><span class="line">//当我们让订阅的处理代码在指定的线程中执行，而不必去关心发送信号的当前线程，就可以deliverOn</span><br></pre></td></tr></table></figure>


<p>9：冷信号跟热信号知识点</p>
<figure class="highlight golo"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Hot <span class="keyword">Observable</span>是主动的，尽管你并没有订阅事件，但是它会时刻推送，就像鼠标移动；而Cold <span class="keyword">Observable</span>是被动的，只有当你订阅的时候，它才会发布消息。</span><br><span class="line"></span><br><span class="line">Hot <span class="keyword">Observable</span>可以有多个订阅者，是一对多，集合可以与订阅者共享信息；而Cold <span class="keyword">Observable</span>只能一对一，当有不同的订阅者，消息是重新完整发送。</span><br><span class="line"></span><br><span class="line">热信号是主动的，即使你没有订阅事件，它仍然会时刻推送 而冷信号是被动的，只有当你订阅的时候，它才会发送消息</span><br><span class="line">热信号可以有多个订阅者，是一对多，信号可以与订阅者共享信息 而冷信号只能一对一，当有不同的订阅者，消息会从新完整发送</span><br><span class="line"></span><br><span class="line">冷信号与热信号的本质区别在于是否保持状态，冷信号的多次订阅是不保持状态的，而热信号的多次订阅可以保持状态</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>10：RACDisposable知识点</p>
<figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">RACDisposable用于取消订阅信号，默认信号发送完之后就会主动的取消订阅。订阅信号使用的subscribeNext<span class="operator">:</span>方法返回的就是RACDisposable类型的对象</span><br><span class="line"></span><br><span class="line">当订阅者发送信号<span class="operator">-</span> (<span class="keyword">void</span>)sendNext<span class="operator">:</span>(<span class="built_in">id</span>)value之后，会执行：<span class="operator">-</span> (RACDisposable <span class="operator">*</span>)subscribeNext<span class="operator">:</span>(<span class="keyword">void</span> (<span class="operator">^</span>)(<span class="built_in">id</span> x))nextBlock中的nextBlock。当nextBlock执行完毕也就意味着subscribeNext方法返回了RACDisposable对象。</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>如果不强引用订阅者对象，默认情况下会自动取消订阅，我们可以拿到RACDisposable 用<span class="operator">+</span> (instancetype)disposableWithBlock<span class="operator">:</span>(<span class="keyword">void</span> (<span class="operator">^</span>)(<span class="keyword">void</span>))block做清空资源的一些操作了。</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>如果不希望自动取消订阅，我们应该强引用RACSubscriber <span class="operator">*</span> subscriber。在想要取消订阅的时候用<span class="operator">-</span> (RACDisposable <span class="operator">*</span>)subscribeNext<span class="operator">:</span>(<span class="keyword">void</span> (<span class="operator">^</span>)(<span class="built_in">id</span> x))nextBlock返回的RACDisposable对象去调用<span class="operator">-</span> (<span class="keyword">void</span>)dispose方法</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>11：RACChannel知识点</p>
<figure class="highlight obj-c"><table><tr><td class="code"><pre><span class="line">RACChannelTerminal *channelA = RACChannelTo(<span class="keyword">self</span>, valueA);</span><br><span class="line">RACChannelTerminal *channelB = RACChannelTo(<span class="keyword">self</span>, valueB);</span><br><span class="line">[[channelA map:^<span class="type">id</span>(<span class="built_in">NSString</span> *value) &#123;</span><br><span class="line"><span class="keyword">if</span> ([value isEqualToString:<span class="string">@&quot;西&quot;</span>]) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">@&quot;东&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> value;</span><br><span class="line">&#125;] subscribe:channelB];</span><br><span class="line">[[channelB map:^<span class="type">id</span>(<span class="built_in">NSString</span> *value) &#123;</span><br><span class="line"><span class="keyword">if</span> ([value isEqualToString:<span class="string">@&quot;左&quot;</span>]) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">@&quot;右&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> value;</span><br><span class="line">&#125;] subscribe:channelA];</span><br><span class="line">[[RACObserve(<span class="keyword">self</span>, valueA) filter:^<span class="type">BOOL</span>(<span class="type">id</span> value) &#123;</span><br><span class="line"><span class="keyword">return</span> value ? <span class="literal">YES</span> : <span class="literal">NO</span>;</span><br><span class="line">&#125;] subscribeNext:^(<span class="built_in">NSString</span>* x) &#123;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;你向%@&quot;</span>, x);</span><br><span class="line">&#125;];</span><br><span class="line">[[RACObserve(<span class="keyword">self</span>, valueB) filter:^<span class="type">BOOL</span>(<span class="type">id</span> value) &#123;</span><br><span class="line"><span class="keyword">return</span> value ? <span class="literal">YES</span> : <span class="literal">NO</span>;</span><br><span class="line">&#125;] subscribeNext:^(<span class="built_in">NSString</span>* x) &#123;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;他向%@&quot;</span>, x);</span><br><span class="line">&#125;];</span><br><span class="line"><span class="keyword">self</span>.valueA = <span class="string">@&quot;西&quot;</span>;</span><br><span class="line"><span class="keyword">self</span>.valueB = <span class="string">@&quot;左&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">RACChannelTerminal *characterRemainingTerminal = RACChannelTo(_loginButton, titleLabel.text);</span><br><span class="line"></span><br><span class="line">[[<span class="keyword">self</span>.userNameText.rac_textSignal map:^<span class="type">id</span>(<span class="built_in">NSString</span> *text) &#123;</span><br><span class="line"><span class="keyword">return</span> [@(<span class="number">100</span> - (<span class="built_in">NSInteger</span>)text.length) stringValue];</span><br><span class="line">&#125;] subscribe:characterRemainingTerminal];</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>12：RAC倒计时小实例</p>
<figure class="highlight wren"><table><tr><td class="code"><pre><span class="line"><span class="comment">//倒计时的效果</span></span><br><span class="line"><span class="title class_">RACSignal</span> <span class="operator">*</span>(<span class="operator">^</span><span class="variable">counterSigner</span>)(<span class="title class_">NSNumber</span> <span class="operator">*</span><span class="variable">count</span>)<span class="operator">=</span><span class="operator">^</span><span class="title class_">RACSignal</span> <span class="title function_">*</span>(<span class="params">NSNumber</span> *<span class="params">count</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="title class_">RACSignal</span> <span class="operator">*</span><span class="variable">timerSignal</span><span class="operator">=</span>[<span class="title class_">RACSignal</span> interval:<span class="number">1</span> <span class="variable">onScheduler</span>:<span class="title class_">RACScheduler</span>.<span class="property">mainThreadScheduler</span>];</span><br><span class="line"><span class="title class_">RACSignal</span> <span class="operator">*</span><span class="variable">counterSignal</span><span class="operator">=</span>[[<span class="variable">timerSignal</span> <span class="variable">scanWithStart</span>:<span class="variable">count</span> <span class="variable">reduce</span>:<span class="operator">^</span><span class="title function_">id</span>(<span class="params">NSNumber</span> *<span class="params">running</span>, <span class="params">id</span> <span class="params">next</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> @(<span class="variable">running</span>.<span class="property">integerValue</span> <span class="number">-1</span>);</span><br><span class="line">&#125;] <span class="variable">takeUntilBlock</span>:<span class="operator">^</span><span class="title function_">BOOL</span>(<span class="params">NSNumber</span> *<span class="params">x</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="variable">x</span>.<span class="property">integerValue</span><span class="operator">&lt;</span><span class="number">0</span>;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> [<span class="variable">counterSignal</span> <span class="variable">startWith</span>:<span class="variable">count</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="title class_">RACSignal</span> <span class="operator">*</span><span class="variable">enableSignal</span><span class="operator">=</span>[<span class="variable">self</span>.<span class="property">myTextField</span>.<span class="property">rac_textSignal</span> <span class="variable">map</span>:<span class="operator">^</span><span class="title function_">id</span>(<span class="params">NSString</span> *<span class="params">value</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> @(<span class="variable">value</span>.<span class="property">length</span><span class="operator">==</span><span class="number">11</span>);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="title class_">RACCommand</span> <span class="operator">*</span><span class="variable">command</span><span class="operator">=</span>[[<span class="title class_">RACCommand</span> <span class="variable">alloc</span>]initWithEnabled:<span class="variable">enableSignal</span> <span class="variable">signalBlock</span>:<span class="operator">^</span><span class="title class_">RACSignal</span> <span class="title function_">*</span>(<span class="params">id</span> <span class="params">input</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="title function_">counterSigner</span>(@<span class="number">10</span>);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="title class_">RACSignal</span> <span class="operator">*</span><span class="variable">counterStringSignal</span><span class="operator">=</span>[[<span class="variable">command</span>.<span class="property">executionSignals</span> <span class="variable">switchToLatest</span>] <span class="variable">map</span>:<span class="operator">^</span><span class="title function_">id</span>(<span class="params">NSNumber</span> *<span class="params">value</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> [<span class="variable">value</span> <span class="variable">stringValue</span>];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="title class_">RACSignal</span> <span class="operator">*</span><span class="variable">resetStringSignal</span><span class="operator">=</span>[[<span class="variable">command</span>.<span class="property">executing</span> <span class="variable">filter</span>:<span class="operator">^</span><span class="title function_">BOOL</span>(<span class="params">NSNumber</span> *<span class="params">value</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="operator">!</span><span class="variable">value</span>.<span class="property">boolValue</span>;</span><br><span class="line">&#125;] <span class="variable">mapReplace</span>:@<span class="string">&quot;点击获得验证码&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//[self.myButton rac_liftSelector:@selector(setTitle:forState:) withSignals:[RACSignal merge:@[counterStringSignal,resetStringSignal]],[RACSignal return:@(UIControlStateNormal)],nil];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//上面也可以写成下面这样</span></span><br><span class="line">@<span class="title function_">weakify</span>(<span class="variable">self</span>);</span><br><span class="line">[[<span class="title class_">RACSignal</span> <span class="variable">merge</span>:@[<span class="variable">counterStringSignal</span>,<span class="variable">resetStringSignal</span>]] <span class="variable">subscribeNext</span>:<span class="title function_">^</span>(<span class="params">id</span> <span class="params">x</span>) &#123;</span><br><span class="line">@<span class="title function_">strongify</span>(<span class="variable">self</span>);</span><br><span class="line">[<span class="variable">self</span>.<span class="property">myButton</span> <span class="variable">setTitle</span>:<span class="variable">x</span> forState:<span class="title class_">UIControlStateNormal</span>];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="variable">self</span>.<span class="property">myButton</span>.<span class="property">rac_command</span><span class="operator">=</span><span class="variable">command</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//编写关于委托的编写方式 是在self上面进行rac_signalForSelector</span></span><br><span class="line">[[<span class="variable">self</span></span><br><span class="line"><span class="variable">rac_signalForSelector</span>:@<span class="title function_">selector</span>(<span class="variable">textFieldShouldReturn</span>:)</span><br><span class="line"><span class="variable">fromProtocol</span>:@<span class="title function_">protocol</span>(<span class="title class_">UITextFieldDelegate</span>)]</span><br><span class="line"><span class="variable">subscribeNext</span>:<span class="title function_">^</span>(<span class="params">RACTuple</span> *<span class="params">tuple</span>) &#123;</span><br><span class="line">@<span class="title function_">strongify</span>(<span class="variable">self</span>)</span><br><span class="line"><span class="keyword">if</span> (<span class="variable">tuple</span>.<span class="property">first</span> <span class="operator">==</span> <span class="variable">self</span>.<span class="property">myTextField</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="title class_">NSLog</span>(@<span class="string">&quot;触发&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="variable">self</span>.<span class="property">myTextField</span>.<span class="property">delegate</span> <span class="operator">=</span> <span class="variable">self</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>13：常见的宏定义运用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">1</span>：</span><br><span class="line">RAC(TARGET, [KEYPATH, [NIL_VALUE]]):用于给某个对象的某个属性绑定</span><br><span class="line">只要文本框文字改变，就会修改label的文字</span><br><span class="line">RAC(self.labelView,text) = _textField.rac_textSignal;</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>:</span><br><span class="line">RACObserve(self, name):监听某个对象的某个属性,返回的是信号。</span><br><span class="line">[RACObserve(self.view, center) subscribeNext:^(<span class="built_in">id</span> x) &#123;</span><br><span class="line">NSLog(@<span class="string">&quot;%@&quot;</span>,x);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">当RACObserve放在block里面使用时一定要加上weakify，不管里面有没有使用到self；否则会内存泄漏，因为RACObserve宏里面就有一个self</span><br><span class="line"><span class="meta">@weakify(<span class="params">self</span>);</span></span><br><span class="line">RACSignal *signal3 = [anotherSignal flattenMap:^(NSArrayController *arrayController) &#123;</span><br><span class="line">//Avoids a retain cycle because of RACObserve implicitly referencing self</span><br><span class="line"><span class="meta">@strongify(<span class="params">self</span>);</span></span><br><span class="line"><span class="keyword">return</span> RACObserve(arrayController, items);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>:</span><br><span class="line"><span class="meta">@weakify(<span class="params">Obj</span>)和@strongify(<span class="params">Obj</span>),一般两个都是配套使用,在主头文件(<span class="params">ReactiveCocoa.h</span>)中并没有导入，需要自己手动导入，RACEXTScope.h才可以使用。但是每次导入都非常麻烦，只需要在主头文件自己导入就好了</span></span><br><span class="line"></span><br><span class="line"><span class="number">4</span>:</span><br><span class="line">RACTuplePack：把数据包装成RACTuple（元组类）</span><br><span class="line">把参数中的数据包装成元组</span><br><span class="line">RACTuple *<span class="built_in">tuple</span> = RACTuplePack(@<span class="number">10</span>,@<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"><span class="number">5</span>:</span><br><span class="line">RACTupleUnpack：把RACTuple（元组类）解包成对应的数据</span><br><span class="line">把参数中的数据包装成元组</span><br><span class="line">RACTuple *<span class="built_in">tuple</span> = RACTuplePack(@<span class="string">&quot;xmg&quot;</span>,@<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">解包元组，会把元组的值，按顺序给参数里面的变量赋值</span><br><span class="line">name = @<span class="string">&quot;xmg&quot;</span> age = @<span class="number">20</span></span><br><span class="line">RACTupleUnpack(NSString *name,NSNumber *age) = <span class="built_in">tuple</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="二：关于使用ReactiveCocoa结合MVVM模式的实例；"><a href="#二：关于使用ReactiveCocoa结合MVVM模式的实例；" class="headerlink" title="二：关于使用ReactiveCocoa结合MVVM模式的实例；"></a>二：关于使用ReactiveCocoa结合MVVM模式的实例；</h2><p>MVVM模式和MVC模式一样，主要目的是分离视图（View）和模型（Model），有几大优点</p>
<ol>
<li><p>低耦合。视图（View）可以独立于Model变化和修改，一个ViewModel可以绑定到不同的”View”上，当View变化的时候Model可以不变，当Model变化的时候View也可以不变。</p>
</li>
<li><p>可重用性。你可以把一些视图逻辑放在一个ViewModel里面，让很多view重用这段视图逻辑。</p>
</li>
<li><p>独立开发。开发人员可以专注于业务逻辑和数据的开发（ViewModel），设计人员可以专注于页面设计。</p>
</li>
<li><p>可测试。界面素来是比较难于测试的，而现在测试可以针对ViewModel来写。</p>
</li>
</ol>
<h2 id="三：单元测试知识"><a href="#三：单元测试知识" class="headerlink" title="三：单元测试知识"></a>三：单元测试知识</h2><p>单元测试这边主要采用两种方式，一种是XCode自动的XCTestCase进行，如下面这些就是它所对应的断言等，另外一种是采有KIWI的插件进行测试；项目中有针对viewController、viewModel、帮助类等的测试实例；运用快捷键（command+U）可以运行单元测试实例；</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//知识点一：</span></span><br><span class="line"><span class="comment">//方法在XCTestCase的测试方法调用之前调用，可以在测试之前创建在test case方法中需要用到的一些对象等</span></span><br><span class="line"><span class="comment">//- (void)setUp ;</span></span><br><span class="line"><span class="comment">//当测试全部结束之后调用tearDown方法，法则在全部的test case执行结束之后清理测试现场，释放资源删除不用的对象等</span></span><br><span class="line"><span class="comment">//- (void)tearDown ;</span></span><br><span class="line"><span class="comment">//测试代码执行性能</span></span><br><span class="line"><span class="comment">//- (void)testPerformanceExample</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//知识点二：</span></span><br><span class="line"><span class="comment">//通用断言</span></span><br><span class="line"><span class="constructor">XCTFail(<span class="params">format</span>…)</span></span><br><span class="line"><span class="comment">//为空判断，a1为空时通过，反之不通过；</span></span><br><span class="line"><span class="constructor">XCTAssertNil(<span class="params">a1</span>, <span class="params">format</span><span class="operator">...</span>)</span></span><br><span class="line"><span class="comment">//不为空判断，a1不为空时通过，反之不通过；</span></span><br><span class="line"><span class="constructor">XCTAssertNotNil(<span class="params">a1</span>, <span class="params">format</span>…)</span></span><br><span class="line"><span class="comment">//当expression求值为TRUE时通过；</span></span><br><span class="line"><span class="constructor">XCTAssert(<span class="params">expression</span>, <span class="params">format</span><span class="operator">...</span>)</span></span><br><span class="line"><span class="comment">//当expression求值为TRUE时通过；</span></span><br><span class="line"><span class="constructor">XCTAssertTrue(<span class="params">expression</span>, <span class="params">format</span><span class="operator">...</span>)</span></span><br><span class="line"><span class="comment">//当expression求值为False时通过；</span></span><br><span class="line"><span class="constructor">XCTAssertFalse(<span class="params">expression</span>, <span class="params">format</span><span class="operator">...</span>)</span></span><br><span class="line"><span class="comment">//判断相等，[a1 isEqual:a2]值为TRUE时通过，其中一个不为空时，不通过；</span></span><br><span class="line"><span class="constructor">XCTAssertEqualObjects(<span class="params">a1</span>, <span class="params">a2</span>, <span class="params">format</span><span class="operator">...</span>)</span></span><br><span class="line"><span class="comment">//判断不等，[a1 isEqual:a2]值为False时通过；</span></span><br><span class="line"><span class="constructor">XCTAssertNotEqualObjects(<span class="params">a1</span>, <span class="params">a2</span>, <span class="params">format</span><span class="operator">...</span>)</span></span><br><span class="line"><span class="comment">//判断相等（当a1和a2是 C语言标量、结构体或联合体时使用,实际测试发现NSString也可以）；</span></span><br><span class="line"><span class="constructor">XCTAssertEqual(<span class="params">a1</span>, <span class="params">a2</span>, <span class="params">format</span><span class="operator">...</span>)</span></span><br><span class="line"><span class="comment">//判断不等（当a1和a2是 C语言标量、结构体或联合体时使用）；</span></span><br><span class="line"><span class="constructor">XCTAssertNotEqual(<span class="params">a1</span>, <span class="params">a2</span>, <span class="params">format</span><span class="operator">...</span>)</span></span><br><span class="line"><span class="comment">//判断相等，（double或float类型）提供一个误差范围，当在误差范围（+/-accuracy）以内相等时通过测试；</span></span><br><span class="line"><span class="constructor">XCTAssertEqualWithAccuracy(<span class="params">a1</span>, <span class="params">a2</span>, <span class="params">accuracy</span>, <span class="params">format</span><span class="operator">...</span>)</span></span><br><span class="line"><span class="comment">//判断不等，（double或float类型）提供一个误差范围，当在误差范围以内不等时通过测试；</span></span><br><span class="line"><span class="constructor">XCTAssertNotEqualWithAccuracy(<span class="params">a1</span>, <span class="params">a2</span>, <span class="params">accuracy</span>, <span class="params">format</span><span class="operator">...</span>)</span></span><br><span class="line"><span class="comment">//异常测试，当expression发生异常时通过，反之不通过；</span></span><br><span class="line"><span class="constructor">XCTAssertThrows(<span class="params">expression</span>, <span class="params">format</span><span class="operator">...</span>)</span></span><br><span class="line"><span class="comment">//异常测试，当expression发生specificException异常时通过；反之发生其他异常或不发生异常均不通过</span></span><br><span class="line"><span class="constructor">XCTAssertThrowsSpecific(<span class="params">expression</span>, <span class="params">specificException</span>, <span class="params">format</span><span class="operator">...</span>)</span></span><br><span class="line"><span class="comment">//异常测试，当expression发生具体异常、具体异常名称的异常时通过测试，反之不通过；</span></span><br><span class="line"><span class="constructor">XCTAssertThrowsSpecificNamed(<span class="params">expression</span>, <span class="params">specificException</span>, <span class="params">exception_name</span>, <span class="params">format</span><span class="operator">...</span>)</span></span><br><span class="line"><span class="comment">//异常测试，当expression没有发生异常时通过测试；</span></span><br><span class="line"><span class="constructor">XCTAssertNoThrow(<span class="params">expression</span>, <span class="params">format</span>…)</span></span><br><span class="line"><span class="comment">//异常测试，当expression没有发生具体异常、具体异常名称的异常时通过测试，反之不通过；</span></span><br><span class="line"><span class="constructor">XCTAssertNoThrowSpecific(<span class="params">expression</span>, <span class="params">specificException</span>, <span class="params">format</span><span class="operator">...</span>)</span></span><br><span class="line"><span class="comment">//异常测试，当expression没有发生具体异常、具体异常名称的异常时通过测试，反之不通过</span></span><br><span class="line"><span class="constructor">XCTAssertNoThrowSpecificNamed(<span class="params">expression</span>, <span class="params">specificException</span>, <span class="params">exception_name</span>, <span class="params">format</span><span class="operator">...</span>)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>采用KiWi的单元测试效果：</p>
<figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#import <span class="string">&lt;Kiwi/Kiwi.h&gt;</span></span></span><br><span class="line"><span class="comment">//把原本在项目pch中那些第三方插件的头文件也要引入</span></span><br><span class="line"><span class="meta">#import <span class="string">&lt;ReactiveCocoa/ReactiveCocoa.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//测试LogInViewController</span></span><br><span class="line"><span class="meta">#import <span class="string">&quot;RACTestLoginViewController.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SPEC_BEGIN(LoginViewControllerSpec)</span><br><span class="line"></span><br><span class="line">describe(@<span class="string">&quot;RACTestLoginViewController&quot;</span>, ^&#123;</span><br><span class="line"><span class="variable">__block</span> RACTestLoginViewController *controller = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">beforeEach(^&#123;</span><br><span class="line">controller = [RACTestLoginViewController new];</span><br><span class="line">[controller view];</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">afterEach(^&#123;</span><br><span class="line">controller = <span class="literal">nil</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">describe(@<span class="string">&quot;Root View&quot;</span>, ^&#123;</span><br><span class="line"></span><br><span class="line">context(@<span class="string">&quot;when view did load&quot;</span>, ^&#123;</span><br><span class="line">it(@<span class="string">&quot;should bind data&quot;</span>, ^&#123;</span><br><span class="line">controller.userNameText.<span class="built_in">text</span>=@<span class="string">&quot;wujunyang&quot;</span>;</span><br><span class="line">controller.passWordTest.<span class="built_in">text</span>=@<span class="string">&quot;123456&quot;</span>;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//一定要调用sendActionsForControlEvents方法来通知UI已经更新 因为RAC是监听这个输入框的变化</span></span><br><span class="line">[controller.userNameText sendActionsForControlEvents:UIControlEventEditingChanged];</span><br><span class="line">[controller.passWordTest sendActionsForControlEvents:UIControlEventEditingChanged];</span><br><span class="line"></span><br><span class="line">[[controller.myLoginViewModel.username should] equal:controller.userNameText.<span class="built_in">text</span>];</span><br><span class="line">[[controller.myLoginViewModel.password should] equal:controller.passWordTest.<span class="built_in">text</span>];</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">SPEC_END</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>关于kiwi中的操作类型可以直接查看：<a target="_blank" rel="noopener" href="https://github.com/allending/Kiwi/wiki/Expectations">https://github.com/allending/Kiwi/wiki/Expectations</a></p>
<p>注意：发现在进行单元测试时，针对RAC就会报[RACStream(Operations) reduceEach:]_block_invoke，后来发现是Pod引入写法有问题，导致的【it usually means RAC is being linked twice. Make sure it’s only in your app target.】 所以测试的MobileProjectTests特别要注意；</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">platform <span class="symbol">:ios</span>, <span class="string">&#x27;7.0&#x27;</span></span><br><span class="line"></span><br><span class="line">abstract_target <span class="string">&#x27;MobileProjectDefault&#x27;</span> <span class="keyword">do</span></span><br><span class="line">pod <span class="string">&#x27;AFNetworking&#x27;</span>, <span class="string">&#x27;~&gt;2.6.0&#x27;</span></span><br><span class="line">pod <span class="string">&#x27;SDWebImage&#x27;</span>, <span class="string">&#x27;~&gt;3.7&#x27;</span></span><br><span class="line">pod <span class="string">&#x27;JSONModel&#x27;</span>, <span class="string">&#x27;~&gt; 1.0.1&#x27;</span></span><br><span class="line">pod <span class="string">&#x27;Masonry&#x27;</span>,<span class="string">&#x27;~&gt;0.6.1&#x27;</span></span><br><span class="line">pod <span class="string">&#x27;FMDB/common&#x27;</span> , <span class="string">&#x27;~&gt;2.5&#x27;</span></span><br><span class="line">pod <span class="string">&#x27;FMDB/SQLCipher&#x27;</span>, <span class="string">&#x27;~&gt;2.5&#x27;</span></span><br><span class="line">pod <span class="string">&#x27;CocoaLumberjack&#x27;</span>, <span class="string">&#x27;~&gt; 2.0.0-rc&#x27;</span></span><br><span class="line">pod <span class="string">&#x27;ReactiveCocoa&#x27;</span>, <span class="string">&#x27;2.5&#x27;</span></span><br><span class="line">pod <span class="string">&#x27;CYLTabBarController&#x27;</span></span><br><span class="line">pod <span class="string">&#x27;MLeaksFinder&#x27;</span>  <span class="comment">#可以把它放在MobileProject_Local的target中 这样就不会影响到产品环境</span></span><br><span class="line">pod <span class="string">&#x27;RealReachability&#x27;</span></span><br><span class="line"></span><br><span class="line">target <span class="string">&#x27;MobileProject_Local&#x27;</span> <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">target <span class="string">&#x27;MobileProject&#x27;</span> <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line">target <span class="string">&#x27;MobileProjectTests&#x27;</span> <span class="keyword">do</span></span><br><span class="line">inherit! <span class="symbol">:search_paths</span></span><br><span class="line">pod <span class="string">&#x27;Kiwi&#x27;</span>, <span class="string">&#x27;~&gt; 2.3.1&#x27;</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="四：ReactiveCocoa知识分享地址"><a href="#四：ReactiveCocoa知识分享地址" class="headerlink" title="四：ReactiveCocoa知识分享地址"></a>四：ReactiveCocoa知识分享地址</h2><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">ReactiveCocoa 和 MVVM 入门 http:<span class="regexp">//yu</span>lingtianxia.com<span class="regexp">/blog/</span><span class="number">2015</span><span class="regexp">/05/</span><span class="number">21</span><span class="regexp">/ReactiveCocoa-and-MVVM-an-Introduction/</span></span><br><span class="line"></span><br><span class="line">MVVM Tutorial with ReactiveCocoa  http:<span class="regexp">//</span>southpeak.github.io<span class="regexp">/blog/</span><span class="number">2014</span><span class="regexp">/08/</span><span class="number">08</span><span class="regexp">/mvvmzhi-nan-yi-:flickrsou-suo-shi-li/</span></span><br><span class="line"></span><br><span class="line">ReactiveCocoa <span class="number">1</span>-官方readme文档翻译  http:<span class="regexp">//</span>cindyfn.com<span class="regexp">/reactivecocoa/</span><span class="number">2014</span><span class="regexp">/12/</span><span class="number">01</span>/ios-frame-use-ReactiveCocoa.html</span><br><span class="line"></span><br><span class="line">这样好用的ReactiveCocoa，根本停不下来  http:<span class="regexp">//</span>www.cocoachina.com<span class="regexp">/ios/</span><span class="number">20150817</span>/<span class="number">13071</span>.html</span><br><span class="line"></span><br><span class="line">ReactiveCocoa基本组件：深入浅出RACCommand  http:<span class="regexp">//</span>www.tuicool.com<span class="regexp">/articles/</span>nYJRvu</span><br><span class="line"></span><br><span class="line">ReactiveCocoa自述：工作原理和应用  http:<span class="regexp">//</span>www.cocoachina.com<span class="regexp">/ios/</span><span class="number">20150702</span>/<span class="number">12302</span>.html</span><br><span class="line"></span><br><span class="line">RACSignal的巧克力工厂 http:<span class="regexp">//</span>www.cnblogs.com<span class="regexp">/sunnyxx/</span>p/<span class="number">3547763</span>.html</span><br><span class="line"></span><br><span class="line">ReactiveCocoa一些概念讲解  http:<span class="regexp">//</span>www.thinksaas.cn<span class="regexp">/group/</span>topic<span class="regexp">/347067/</span></span><br><span class="line"></span><br><span class="line">细说ReactiveCocoa的冷信号与热信号（二）：为什么要区分冷热信号  http:<span class="regexp">//</span>www.tuicool.com<span class="regexp">/articles/</span>e2uMzyq</span><br><span class="line"></span><br><span class="line">细说ReactiveCocoa的冷信号与热信号（三）：怎么处理冷信号与热信号  http:<span class="regexp">//</span>www.tuicool.com<span class="regexp">/articles/</span>emIVZjY</span><br><span class="line"></span><br><span class="line">最快让你上手ReactiveCocoa之基础篇   http:<span class="regexp">//</span>www.jianshu.com<span class="regexp">/p/</span><span class="number">87</span>ef6720a096</span><br><span class="line"></span><br><span class="line">最快让你上手ReactiveCocoa之进阶篇  http:<span class="regexp">//</span>www.jianshu.com<span class="regexp">/p/</span>e10e5ca413b7</span><br><span class="line"></span><br><span class="line">ReactiveCocoa基础：理解并使用RACCommand http:<span class="regexp">//</span>www.yiqivr.com<span class="regexp">/2015/</span><span class="number">10</span><span class="regexp">/19/</span>%E8%AF%<span class="number">91</span>-ReactiveCocoa%E5%<span class="number">9</span>F%BA%E7%A1%<span class="number">80</span>%EF%BC%<span class="number">9</span>A%E7%<span class="number">90</span>%<span class="number">86</span>%E8%A7%A3%E5%B9%B6%E4%BD%BF%E7%<span class="number">94</span>%A8RACCommand/  </span><br><span class="line"></span><br><span class="line">RAC一些代码总结：https:<span class="regexp">//gi</span>thub.com<span class="regexp">/shuaiwang007/</span>RAC </span><br><span class="line"></span><br><span class="line">ReactiveCocoa小总结   http:<span class="regexp">//</span>www.jianshu.com<span class="regexp">/p/</span><span class="number">8</span>fd6c8349774</span><br><span class="line"></span><br><span class="line">如何在ReactiveCocoa中写单元测试   http:<span class="regexp">//</span>www.jianshu.com<span class="regexp">/p/</span><span class="number">412875512</span>bd1</span><br><span class="line"></span><br><span class="line">TDD的iOS开发初步以及Kiwi使用入门 https:<span class="regexp">//</span>onevcat.com<span class="regexp">/2014/</span><span class="number">02</span><span class="regexp">/ios-test-with-kiwi/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/iOS-%E5%BC%80%E6%BA%90%E5%BA%93%E5%88%86%E6%9E%90/">iOS 开源库分析</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/iOS-开源库分析/">iOS 开源库分析</a>
  </div>

</div>



<div class="comments-count">
	
	  	<span></span>
		<a href="/2019/10/05/转-RAC-知识点汇总-总结得非常全/#comments" class="ds-thread-count comments-count-link" data-thread-key="2019/10/05/转-RAC-知识点汇总-总结得非常全/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/10/04/图解iOS之ReactiveObjc-部分重要概念及操作简图-二/" title="图解iOS之ReactiveObjc 部分重要概念及操作简图 二" itemprop="url">图解iOS之ReactiveObjc 部分重要概念及操作简图 二</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Edgar" target="_blank" itemprop="author">Edgar</a>
		
  <p class="article-time">
    <time datetime="2019-10-03T18:43:56.000Z" itemprop="datePublished"> Published 2019-10-04</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p><img src="/2019/10/04/%E5%9B%BE%E8%A7%A3iOS%E4%B9%8BReactiveObjc-%E9%83%A8%E5%88%86%E9%87%8D%E8%A6%81%E6%A6%82%E5%BF%B5%E5%8F%8A%E6%93%8D%E4%BD%9C%E7%AE%80%E5%9B%BE-%E4%BA%8C/0003.png"><br><img src="/2019/10/04/%E5%9B%BE%E8%A7%A3iOS%E4%B9%8BReactiveObjc-%E9%83%A8%E5%88%86%E9%87%8D%E8%A6%81%E6%A6%82%E5%BF%B5%E5%8F%8A%E6%93%8D%E4%BD%9C%E7%AE%80%E5%9B%BE-%E4%BA%8C/0002.png"><br><img src="/2019/10/04/%E5%9B%BE%E8%A7%A3iOS%E4%B9%8BReactiveObjc-%E9%83%A8%E5%88%86%E9%87%8D%E8%A6%81%E6%A6%82%E5%BF%B5%E5%8F%8A%E6%93%8D%E4%BD%9C%E7%AE%80%E5%9B%BE-%E4%BA%8C/0001.png"></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/iOS-%E5%BC%80%E6%BA%90%E5%BA%93%E5%88%86%E6%9E%90/">iOS 开源库分析</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/iOS-开源库分析/">iOS 开源库分析</a>
  </div>

</div>



<div class="comments-count">
	
	  	<span></span>
		<a href="/2019/10/04/图解iOS之ReactiveObjc-部分重要概念及操作简图-二/#comments" class="ds-thread-count comments-count-link" data-thread-key="2019/10/04/图解iOS之ReactiveObjc-部分重要概念及操作简图-二/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/10/02/图解iOS之ReactiveObjc-部分重要概念及操作简图/" title="图解iOS之ReactiveObjc 部分重要概念及操作简图 一" itemprop="url">图解iOS之ReactiveObjc 部分重要概念及操作简图 一</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Edgar" target="_blank" itemprop="author">Edgar</a>
		
  <p class="article-time">
    <time datetime="2019-10-01T18:37:03.000Z" itemprop="datePublished"> Published 2019-10-02</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p><img src="/2019/10/02/%E5%9B%BE%E8%A7%A3iOS%E4%B9%8BReactiveObjc-%E9%83%A8%E5%88%86%E9%87%8D%E8%A6%81%E6%A6%82%E5%BF%B5%E5%8F%8A%E6%93%8D%E4%BD%9C%E7%AE%80%E5%9B%BE/00.png"><br><img src="/2019/10/02/%E5%9B%BE%E8%A7%A3iOS%E4%B9%8BReactiveObjc-%E9%83%A8%E5%88%86%E9%87%8D%E8%A6%81%E6%A6%82%E5%BF%B5%E5%8F%8A%E6%93%8D%E4%BD%9C%E7%AE%80%E5%9B%BE/1.png"><br><img src="/2019/10/02/%E5%9B%BE%E8%A7%A3iOS%E4%B9%8BReactiveObjc-%E9%83%A8%E5%88%86%E9%87%8D%E8%A6%81%E6%A6%82%E5%BF%B5%E5%8F%8A%E6%93%8D%E4%BD%9C%E7%AE%80%E5%9B%BE/2.png"><br><img src="/2019/10/02/%E5%9B%BE%E8%A7%A3iOS%E4%B9%8BReactiveObjc-%E9%83%A8%E5%88%86%E9%87%8D%E8%A6%81%E6%A6%82%E5%BF%B5%E5%8F%8A%E6%93%8D%E4%BD%9C%E7%AE%80%E5%9B%BE/3.png"><br><img src="/2019/10/02/%E5%9B%BE%E8%A7%A3iOS%E4%B9%8BReactiveObjc-%E9%83%A8%E5%88%86%E9%87%8D%E8%A6%81%E6%A6%82%E5%BF%B5%E5%8F%8A%E6%93%8D%E4%BD%9C%E7%AE%80%E5%9B%BE/4.png"><br><img src="/2019/10/02/%E5%9B%BE%E8%A7%A3iOS%E4%B9%8BReactiveObjc-%E9%83%A8%E5%88%86%E9%87%8D%E8%A6%81%E6%A6%82%E5%BF%B5%E5%8F%8A%E6%93%8D%E4%BD%9C%E7%AE%80%E5%9B%BE/5.png"><br><img src="/2019/10/02/%E5%9B%BE%E8%A7%A3iOS%E4%B9%8BReactiveObjc-%E9%83%A8%E5%88%86%E9%87%8D%E8%A6%81%E6%A6%82%E5%BF%B5%E5%8F%8A%E6%93%8D%E4%BD%9C%E7%AE%80%E5%9B%BE/6.png"><br><img src="/2019/10/02/%E5%9B%BE%E8%A7%A3iOS%E4%B9%8BReactiveObjc-%E9%83%A8%E5%88%86%E9%87%8D%E8%A6%81%E6%A6%82%E5%BF%B5%E5%8F%8A%E6%93%8D%E4%BD%9C%E7%AE%80%E5%9B%BE/7.png"><br><img src="/2019/10/02/%E5%9B%BE%E8%A7%A3iOS%E4%B9%8BReactiveObjc-%E9%83%A8%E5%88%86%E9%87%8D%E8%A6%81%E6%A6%82%E5%BF%B5%E5%8F%8A%E6%93%8D%E4%BD%9C%E7%AE%80%E5%9B%BE/8.png"><br><img src="/2019/10/02/%E5%9B%BE%E8%A7%A3iOS%E4%B9%8BReactiveObjc-%E9%83%A8%E5%88%86%E9%87%8D%E8%A6%81%E6%A6%82%E5%BF%B5%E5%8F%8A%E6%93%8D%E4%BD%9C%E7%AE%80%E5%9B%BE/9.png"><br><img src="/2019/10/02/%E5%9B%BE%E8%A7%A3iOS%E4%B9%8BReactiveObjc-%E9%83%A8%E5%88%86%E9%87%8D%E8%A6%81%E6%A6%82%E5%BF%B5%E5%8F%8A%E6%93%8D%E4%BD%9C%E7%AE%80%E5%9B%BE/10.png"><br><img src="/2019/10/02/%E5%9B%BE%E8%A7%A3iOS%E4%B9%8BReactiveObjc-%E9%83%A8%E5%88%86%E9%87%8D%E8%A6%81%E6%A6%82%E5%BF%B5%E5%8F%8A%E6%93%8D%E4%BD%9C%E7%AE%80%E5%9B%BE/11.png"><br><img src="/2019/10/02/%E5%9B%BE%E8%A7%A3iOS%E4%B9%8BReactiveObjc-%E9%83%A8%E5%88%86%E9%87%8D%E8%A6%81%E6%A6%82%E5%BF%B5%E5%8F%8A%E6%93%8D%E4%BD%9C%E7%AE%80%E5%9B%BE/12.png"><br><img src="/2019/10/02/%E5%9B%BE%E8%A7%A3iOS%E4%B9%8BReactiveObjc-%E9%83%A8%E5%88%86%E9%87%8D%E8%A6%81%E6%A6%82%E5%BF%B5%E5%8F%8A%E6%93%8D%E4%BD%9C%E7%AE%80%E5%9B%BE/13.png"><br><img src="/2019/10/02/%E5%9B%BE%E8%A7%A3iOS%E4%B9%8BReactiveObjc-%E9%83%A8%E5%88%86%E9%87%8D%E8%A6%81%E6%A6%82%E5%BF%B5%E5%8F%8A%E6%93%8D%E4%BD%9C%E7%AE%80%E5%9B%BE/14.png"><br><img src="/2019/10/02/%E5%9B%BE%E8%A7%A3iOS%E4%B9%8BReactiveObjc-%E9%83%A8%E5%88%86%E9%87%8D%E8%A6%81%E6%A6%82%E5%BF%B5%E5%8F%8A%E6%93%8D%E4%BD%9C%E7%AE%80%E5%9B%BE/15.png"></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/iOS-%E5%BC%80%E6%BA%90%E5%BA%93%E5%88%86%E6%9E%90/">iOS 开源库分析</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/iOS-开源库分析/">iOS 开源库分析</a>
  </div>

</div>



<div class="comments-count">
	
	  	<span></span>
		<a href="/2019/10/02/图解iOS之ReactiveObjc-部分重要概念及操作简图/#comments" class="ds-thread-count comments-count-link" data-thread-key="2019/10/02/图解iOS之ReactiveObjc-部分重要概念及操作简图/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/09/14/iOS-组件化总结/" title="iOS 组件化总结" itemprop="url">iOS 组件化总结</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Edgar" target="_blank" itemprop="author">Edgar</a>
		
  <p class="article-time">
    <time datetime="2019-09-13T17:57:51.000Z" itemprop="datePublished"> Published 2019-09-14</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h5 id="0-开篇叨叨"><a href="#0-开篇叨叨" class="headerlink" title="0. 开篇叨叨"></a>0. 开篇叨叨</h5><p>今天给大家讲的主题是iOS组件化，提起组件化让我想起了在读研的时候用的一款图形化编程语言<a target="_blank" rel="noopener" href="https://www.ni.com/zh-cn/shop/labview/labview-details.html">NI LabVIEW</a>,它是由美国国家仪器公司开发的，它编写的程序是由一个个图形模块堆叠起来的，我们可以很轻松地将几个模块通过数据流连接起来构成一个比较复杂的程序，当然它还有和硬件通信控制硬件的功能，但这不是我们的重点。从整体角度来看，它编写的程序主要由下面几部分构成：</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">模块         <span class="comment">-- 提供某个功能服务</span></span><br><span class="line">模块间的连线  <span class="comment">-- 数据事件沿着连线流动</span></span><br><span class="line">逻辑块       <span class="comment">-- 控制数据怎样沿着连线在这些功能模块上流动</span></span><br></pre></td></tr></table></figure>

<p>我们在组件化某个项目的时候也就是也就是在搭建类似NI LabVIEW平台的过程，在这个过程中我们需要考虑如何划分和封装模块，模块间数据怎么交互，如何注册&#x2F;查找对应服务的模块。</p>
<p>开发人员在组件化的项目上编写代码的时候只需要提供输入数据，然后调用合适的组件，将数据送入组件处理，组件处理完后将处理后的数据按照约定的交付形式输出，然后再流入下个组件，在项目中能够通过便捷的方式路由到任何一个组件，并且组件间没有任何耦合，拆开组件在不修改任何代码的情况下在另一个项目中复用组件。</p>
<p><strong><strong>那么大家思考过没：什么是组件化？ 为啥要在项目上使用组件化技术？</strong></strong></p>
<p>在我看来组件化指的是将项目代码进行分层，解耦，并制定模块间通信的方式，从而实现解耦，复用。不可否认有些项目的组件化是KPI产物，但是很大程度来说组件化都是十分必要的，为啥？它有啥好处？</p>
<ul>
<li><p>首先组件化带来的最大好处就是项目成果积累，一般一个公司都会不只一个项目，如果采用组件化将可共享的模块从各个项目中抽离出来，形成一个组件，那么其他项目需要这个功能的时候就可以直接复用，而不用重复开发，并且这些组件在多个项目的维护下会越来越健壮，这种积累从长远角度看对于一个公司来说是一个十分可观的成果。</p>
</li>
<li><p>其次从宏观角度上看，每个组件都相当于一个黑盒，我们只关心我们注入哪些数据，组件吐出哪些数据，里面的细节对于组件使用者来说不用太多关照，这样就会使得整个项目的结构更加清晰。同时这种黑盒结构很容易通过测试用例对组件进行测试。</p>
</li>
<li><p>在多人协作的团队可以将整个项目分割成多个模块分配给开发成员。</p>
</li>
<li><p>由于组件是可以单独编译的，开发测试过程中，可以只编译自己那部分代码，不需要编译整个项目代码，从这个角度出发，组件化可以很大程度上加快整个项目的编译速度。从测试角度可以在开发过程中先提交组件测试，测试通过后再进行组件集成测试，从开发流程角度可以更好得进行独立并行开发，各个组件的负责人在功能尚未开发完之前可以按照约定的组件接口结构，Mock假数据给调用者，这样我们在开发组件的同时，依赖方可以同时开发他们的组件，等到我们的组件开发完毕后使用真实数据替换Mock假数据就可以很轻松得将两个组件对接起来。</p>
</li>
<li><p>不同组件的开发人员可以选择自己喜欢的架构模式 (当然这里不推荐这样做，一个项目尽量保持架构一致)</p>
</li>
<li><p>可以针对单个组件或者模块进行编译测试，更好定位问题，我们可以通过对组件间接口进行测试，如果发现异常就可以针对组件进行排查。</p>
</li>
<li><p>组件化架构在各个模块之间天然形成了一道屏障，避免某个开发人员偷懒直接引用头文件，产生组件间的耦合，破坏整体架构，同时，因为每个人都负责自己的组件，代码提交也只提交自己负责模块的仓库，所以代码冲突的问题会变得很少，还有好处就是假设以后某个业务发生大的改变，需要对相关代码进行重构，可以在单个组件内进行重构，只要保证对外接口准确无误就可以了，组件化架构降低了重构的风险，保证了代码的健壮性。</p>
</li>
</ul>
<p>但是<strong><strong>组件化又有那些缺点呢？</strong></strong></p>
<p>其实倒不是组件化有啥缺点，组件化的唯一缺点就是会给项目带来复杂性，比如我们在非组件化项目中从一个对象拿到另一个对象是十分容易的，但是组件化项目中有可能这两个对象是跨组件的，这种情况下可能就需要绕个大弯去获取，这对于项目初期进度很赶的时候是十分恼火的一个问题，并且某个项目刚刚成立之前，往往对于项目的整体形态都没形成一个很系统的认知，这种情况下对项目进行组件化规划是比较困难的，因为如果组件划分不合理调整起来是很困难的一件事情，这对需求的把握能力以及前瞻能力都有很高的要求，这就导致一般项目初期很少考虑组件化，到了项目第一个demo出来，并且人员到齐的情况下才会将组件化纳入到项目日程。</p>
<h5 id="1-组件化要思考的关键问题"><a href="#1-组件化要思考的关键问题" class="headerlink" title="1. 组件化要思考的关键问题"></a>1. 组件化要思考的关键问题</h5><p>组件简单说就是如何组织组件，如何添加组件，如何发现组件，如何交付数据，如何传递动作，把这些理清楚了组件框架就可以理出个头绪了，往详细得说组件化需要考虑如下几点：</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="bullet">* </span>如何划分组件/组件解耦</span><br><span class="line"><span class="bullet">* </span>组件间数据通信的时候数据怎么交付</span><br><span class="line"><span class="bullet">* </span>如何设计组件路由</span><br><span class="line"><span class="bullet">* </span>如何设计消息总线</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="2-用组件化视角审视项目结构"><a href="#2-用组件化视角审视项目结构" class="headerlink" title="2. 用组件化视角审视项目结构"></a>2. 用组件化视角审视项目结构</h5><p>在用组件化视角审视项目结构之前我们看下一般一个应用的通用部分有哪些，下面是我自己设计的一个框架的结构图，该框架是我的练手项目，目前完成大部分的基础工作，还有一部分正在开发中，后续整个完善后开源给大家，大家一起完善，一起学习，目前暂定名字为IDLFundation,之前有打算叫GKFundation(Geek Fundation) 但是后面觉得俗气，所以想了个更俗气的名字IDLFundation（idealist Fundation 理想主义者）</p>
<p><img src="/2019/09/14/iOS-%E7%BB%84%E4%BB%B6%E5%8C%96%E6%80%BB%E7%BB%93/0000001.png"></p>
<h5 id="2-1-数据层"><a href="#2-1-数据层" class="headerlink" title="2.1 数据层"></a>2.1 数据层</h5><p>数据层主要包括两大部分:DataSource以及Data Processor。DataSource 又可以分成Local DataSource 以及Remote DataSource</p>
<ul>
<li>Local DataSource 包括</li>
</ul>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="bullet">* </span>数据库：一般用于存储结构性数据</span><br><span class="line"><span class="bullet">* </span>缓存：  一般用于存储有时效性的数据，超过某个过期时间或者超过一定容量限制就会被清除</span><br><span class="line"><span class="bullet">* </span>文件管理：一般用于管理文件</span><br><span class="line"><span class="bullet">* </span>KeyChain: 它的特点是除非恢复出厂设置否则即使卸载应用数据也都会保留着，很适合存储密码等关键信息。</span><br><span class="line"><span class="bullet">* </span>UserDefault: 一般用于存储极为小型的数据，比如某个标志位等，它会随着应用的卸载而丢失</span><br><span class="line"><span class="bullet">* </span>ImageLoader: 实质上也是一种缓存，只不过存储的是图片数据。</span><br></pre></td></tr></table></figure>

<ul>
<li>Remote DataSource 包括</li>
</ul>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="bullet">* </span>Http/Https: 这个是大多数的远程数据来源</span><br><span class="line"><span class="bullet">* </span>WebSocket:  WebSocket一般用于后端主动下发消息</span><br><span class="line"><span class="bullet">* </span>Downloader/Uploader: 一般用于上传和下载大型的数据，比如图像或者文件等</span><br></pre></td></tr></table></figure>

<p>在拿到数据后或者在存储数据之前一般会对数据做相应处理后交付给使用方：</p>
<p>常用的数据处理包括：</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="bullet">* </span>数据加解密： 一般在存储或者传输敏感数据的时候需要对数据进行一次加密，但是加密有时候会比较耗时，所以对于非关键数据一般不用加密传输。</span><br><span class="line"><span class="bullet">* </span>数据压缩/解压缩：对于传输比较大的数据一般都会在传输前做压缩解压处理</span><br><span class="line"><span class="bullet">* </span>序列化/反序列化：这个是最常见的数据处理方式，在拿到后台的数据后我们通常会对数据进行反序列化成一个对象后传递给上层进行处理，而在向服务端发送数据对象之前需要将数据进行序列化后进行传输。目前比较常用的序列化和反序列化方式有JSON以及Probuf,JSON的特点是比较直观，而Probuf是基于二进制的数据，所以数据量会比JSON小，但是调试的时候比较不直观。</span><br></pre></td></tr></table></figure>

<p>在MVVM架构中和数据层关系最密切的就是Model层了，Model中一般都是一些获取数据的方法，在获取完数据后经过处理后放在Model层待使用方取用，Model层状态发生变化View层一般也会同步变化，比如开始获取数据的时候一般会呈现一个加载动画，数据拿到后会呈现一个用于显示数据的界面，获取数据失败会有错误信息界面，这里我们用一个ViewAction来向View层同步状态</p>
<h5 id="2-2-视图层"><a href="#2-2-视图层" class="headerlink" title="2.2 视图层"></a>2.2 视图层</h5><p>视图层在各个项目中往往差异比较大，但是还是有可以提炼出的共同点：</p>
<figure class="highlight nestedtext"><table><tr><td class="code"><pre><span class="line"><span class="attribute">* UI Components</span><span class="punctuation">:</span> <span class="string">大多数项目中会用到列表，闪屏，Banner,按钮，圆角图片，弹窗，面板，Toast的界面相关的控件，可以将这些控件的公共部分给抽象出来，使用的时候通过配置就可以应用在不同项目中。</span></span><br><span class="line"><span class="attribute">* Theme Manager</span><span class="punctuation">:</span> <span class="string">主题管理包括图片，颜色，字体等多种资源管理，一般在主题发生切换的时候还需要往外部传递信号，供外界监听。</span></span><br><span class="line"><span class="attribute">* LayoutKit</span><span class="punctuation"> :</span> <span class="string">布局库，目前比较流行的就是Masory了，除了它还有一系列基于Flex模式的布局库，比如Yoga,ComponentKit等，一般比较高效的布局库会带有异步计算布局参数，缓存布局参数的功能。</span></span><br><span class="line"><span class="attribute">* Device UI Adapter</span><span class="punctuation">:</span> <span class="string">随着越来越多的屏幕分辨率出现，适配也成为了视图层中一个很重要的工作，所以一个项目中一般会有视图适配工具类。</span></span><br></pre></td></tr></table></figure>

<p>视图层的工作比较简单，IDLFundation 中会管理三种状态的视图分别是Loading View,Content View, Empty&#x2F;Exception View,这三者的作用从名称上都可以看出来是干什么用的，它受ViewAction信号控制<br>如果说数据层是生产数据的，那么视图层的作用就是生产交互事件，在IDLFunation中会将事件通过RACCommand暴露出去，可以在ViewController中对其进行相关工作的绑定。<br>视图还有一个功能就是布局它的子控件。嗯，视图层大致就这么简单。</p>
<h5 id="2-3-ViewController层"><a href="#2-3-ViewController层" class="headerlink" title="2.3 ViewController层"></a>2.3 ViewController层</h5><p>在IDLFundation中 ViewController层相当于MVVM的ViewModel层，它负责绑定View 和 Model层，同时处理View层生成的动作，它会监听一系列事件，比如主题更换，语言更换，网络状态切换，ViewController生命周期变化，通过感知这些事件触发对应的逻辑处理。</p>
<h5 id="2-4-APM-amp-amp-Quality-Center"><a href="#2-4-APM-amp-amp-Quality-Center" class="headerlink" title="2.4 APM &amp;&amp; Quality Center"></a>2.4 APM &amp;&amp; Quality Center</h5><p>介绍完IDLFundation最核心的MVVM框架后，仅次于它的一个部分就是APM &amp;&amp; Quality Center 模块，在这里包含了一系列性能检测，以及异常收集，Logger上报，埋点数据上报等工具，这个模块用于对整个应用进行检测。所以个人将这个模块也归入核心框架层。</p>
<h5 id="2-5-应用配置层"><a href="#2-5-应用配置层" class="headerlink" title="2.5 应用配置层"></a>2.5 应用配置层</h5><p>应用配置层会以两种形式对应用进行配置，一种是本地项目配置，一种是云指令控制，后者可以根据服务端下发的配置文件对应用的功能进行配置。</p>
<h5 id="2-6-AppContext"><a href="#2-6-AppContext" class="headerlink" title="2.6 AppContext"></a>2.6 AppContext</h5><p>这个一般同于存储一些全局的应用变量，比如登录后的登录态等，多个地方都需要使用，并且方便取用。</p>
<h5 id="2-7-应用路由"><a href="#2-7-应用路由" class="headerlink" title="2.7 应用路由"></a>2.7 应用路由</h5><p>这里指的是路由的框架层，一般一个路由可以分成两部分一部分是强应用相关的部分，包括应用定义的路由协议，以及对某个协议的处理。<br>另一部分是通用的部分，包括路由的分发匹配，路由策略等，这部分是可以抽出来对多个项目共用的。</p>
<h5 id="2-8-Hot-Fix"><a href="#2-8-Hot-Fix" class="headerlink" title="2.8 Hot Fix"></a>2.8 Hot Fix</h5><p>说到Hot Fix 大家一定会联想到JSPatch,但是其实Hot Fix 除了JSPath外还可以结合动态下发路由表来修复线上问题，这个后续有时间会向大家介绍下。</p>
<h5 id="2-9-ABTest"><a href="#2-9-ABTest" class="headerlink" title="2.9 ABTest"></a>2.9 ABTest</h5><p>目前一般项目都会使用到ABTest据说这种开发方式在字节跳动会比较常用，也就是说同一个功能客户端会同时开发几套效果，通过对用户进行不同的分组，对不同的用户使用不同的展示方式，ABTest比较强调公平性，不然很难说服产品们他们的策略谁优谁劣，<br>但是一般小型项目一个功能往往只有一个产品负责，这种ABTest往往比较不那么严格，只要随机分组就好。对于字节跳动那种模式，分组的公平性就很重要，不然产品们吵着吵着就会将矛头指向ABTest开发工程师。哈哈，毕竟KPI相关。</p>
<h5 id="2-10-Web-Componente"><a href="#2-10-Web-Componente" class="headerlink" title="2.10 Web Componente"></a>2.10 Web Componente</h5><p>我把这个成为应用的动态化模块，主要包括基于JavaScripCore的 JS桥，以及React Native.这些是可以动态变化的，动态指的是同一个地址里面的内容可以随时变化而不用通过发布版本的方式。</p>
<h5 id="2-11-AutoMation-Tools"><a href="#2-11-AutoMation-Tools" class="headerlink" title="2.11 AutoMation Tools"></a>2.11 AutoMation Tools</h5><p>我们很经常在玩笑啥时候能给自动化需求，哈哈，估计等不到那一天吧，不过我们确实可以将开发中很大一部分工作通过自动化来完成，比如埋点key，参数，颜色表，字符表，资源索引等。这些脚本很容易提高我们的开发效率，并且不容易出错，个人感觉很值得。</p>
<h5 id="2-12-Common-Module"><a href="#2-12-Common-Module" class="headerlink" title="2.12 Common Module"></a>2.12 Common Module</h5><p>这部分就相对比较大的模块，一般我们会将这些常用模块公共部分抽象出来，通过在业务层配置，达到复用的目的。</p>
<h5 id="3-组件化设计细节"><a href="#3-组件化设计细节" class="headerlink" title="3 组件化设计细节"></a>3 组件化设计细节</h5><p>在我们介绍完一个项目的大致结构后我们重新回到组件化这个问题，在组件化这个问题上没有固定的模式，需要依照项目的实际情况来确定，但是在设计组件化框架的时候有一些问题是必须要思考的：</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="bullet">* </span>如何划分组件/组件如何解耦</span><br><span class="line"><span class="bullet">* </span>如何设计组件路由</span><br><span class="line"><span class="bullet">* </span>组件化消息总线设计</span><br><span class="line"><span class="bullet">* </span>组件集成</span><br></pre></td></tr></table></figure>

<h5 id="3-1-组件划分"><a href="#3-1-组件划分" class="headerlink" title="3.1 组件划分"></a>3.1 组件划分</h5><p>关于组件划分我们需要思考如下几个问题：</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="bullet">* </span>划分组件需要遵循那些规则</span><br><span class="line"><span class="bullet">* </span>如何能够做到某个组件单独拎出来在不修改的情况下在另一个项目中使用。</span><br><span class="line"><span class="bullet">* </span>如何能够在只修改极少数代码的情况下将某个组件移除，并且主工程能够正常运行。</span><br></pre></td></tr></table></figure>

<h5 id="3-1-1-组件划分规则"><a href="#3-1-1-组件划分规则" class="headerlink" title="3.1.1 组件划分规则"></a>3.1.1 组件划分规则</h5><p>一般我们在项目中会把项目划分成：业务模块，功能组件以及基础组件。</p>
<ul>
<li><strong><strong>业务模块</strong></strong>：</li>
</ul>
<p>业务模块一般是一个具体的业务比如酒店业务模块，机票订阅业务模块，每个模块都是较大的一个需求，每一个模块都是由多个功能组件组合而成。通过调用不同的功能组件来获得相应的支持，数据从一个功能组件流向另一个功能组件，每个功能组件提供对应的服务，最终展现给用户。一般业务模块粒度比较粗，但是数量不宜太多。这一层往往变动比较频繁。一般会有单独的人来维护。</p>
<ul>
<li><strong><strong>功能组件</strong></strong>：</li>
</ul>
<p>功能组件指的是从业务角度来看是一个相对独立的不可再分的部件，每个功能组件都能够提供某项独立的服务，比如搜索组件，比如用户信息管理组件。一般我们在开发过程中会不断从业务模块中去提取，一旦有较为稳定的可以归并为一个功能的逻辑出现的时候，我们就会将这部分逻辑封装后下沉到功能组件。</p>
<ul>
<li><strong><strong>基础组件</strong></strong>：</li>
</ul>
<p>基础组件一般指的是和业务无关的，可以在多个项目中复用的，比如应用主题管理组件。网络组件等等。这个层的组件强调的是多项目的可复用性，所以对稳定性要求一般是最高的。一般考虑到它的可复用性在划分粒度上都会分得比较细。功能也会比较单一，基础层组件相互之间不应该产生任何依赖。</p>
<ul>
<li><strong><strong>资源组件</strong></strong>：</li>
</ul>
<p>对于图片资源，可以单独剥出一个组件，这个组件中只存放图片文件不包含任何代码，这些图片可以通过Bundle,image Assets进行管理，并按不同业务模块建立不同的Bundle或者image Assets。</p>
<p>组件拆分原则：</p>
<p>对于组件的拆分，一般需要依据各个组件的特点，首先总体上应该去中心化，形成层级从上而下单向依赖，也就是说业务模块依赖功能组件，功能组件依赖基础组件。在发现有多个组件可以共用的逻辑或者数据模型的情况下，要考虑将这些公用的部分下沉，这种层级结构还有一种特点就是：越是上层的组件，越贴近业务，也就越不稳定，因此我们在划分的时候一般业务模块粒度会相对粗一些，功能组件划分粒度一般会细一点，而基础组件一般会考虑它的稳定性，只有十分必要的情况下才会考虑把它纳入到基础组件。对于项目中存在的公共资源和代码，应该将其下沉到下层。</p>
<p>总结:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">在划分的过程中遵循：</span><br><span class="line"><span class="bullet">1.</span> 去中心化，组件结构层级化，依赖从上而下，平级组件无依赖。</span><br><span class="line"><span class="bullet">2.</span> 业务模块粗粒度，功能组件细粒度，基础组件强调高稳定性，高复用性。</span><br><span class="line"><span class="bullet">3.</span> 目标：独立模块组件可以编译运行，每个模块可随意插拔。</span><br></pre></td></tr></table></figure>

<h5 id="3-1-2-组件解耦"><a href="#3-1-2-组件解耦" class="headerlink" title="3.1.2 组件解耦"></a>3.1.2 组件解耦</h5><p>在组件化过程中，主要有两部分会产生耦合：一个是组件间调用，一个是组件间数据交付形式,这部分需要思考如下几个问题：</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="bullet">* </span>组件间通信选用何种形式才能降低耦合</span><br><span class="line"><span class="bullet">* </span>组件间数据通信的时候数据怎么交付，以什么形式交付才不会带来耦合</span><br><span class="line"><span class="bullet">* </span>如何交付非常规数据</span><br></pre></td></tr></table></figure>

<p>关于组件解耦推荐大家阅读下bang的<a target="_blank" rel="noopener" href="https://wereadteam.github.io/2016/03/19/iOS-Component/">iOS 组件化方案探索</a>，这篇博客很清晰地介绍了组件化组件间依赖的解耦过程。</p>
<p>组件间通信以及组件间数据交付形式是产生组件耦合的最根源原因。组件间通信一般有URL形式，class-protocals 形式，target-action形式。我们来看下理想的依赖模式是怎样的：</p>
<p><img src="/2019/09/14/iOS-%E7%BB%84%E4%BB%B6%E5%8C%96%E6%80%BB%E7%BB%93/0000002.png"></p>
<p>理想的依赖关系应该如上图所示，调用方依赖Mediator及对应模块的Mediator分类，但是被调用组件中不知道Mediator以及调用方的存在（只让其他模块对中间层产生耦合关系，中间层不对其他模块发生耦合），假定我们要移除被调用方直接移除就好，Mediator在没有找到被调用者的时候只是不响应而已不会对其他部分有任何影响，而被调用者由于不感知Mediator所以从项目中提取出来也不会对它有任何影响。对于调用者要从项目中移出只需要调整与Mediator相关的代码即可，甚至可以带着Mediator移出。到新环境中的时候只要对接Mediator接口即可。具体的实现方式可以看casatwy的<a target="_blank" rel="noopener" href="https://casatwy.com/iOS-Modulization.html">iOS应用架构谈 组件化方案</a>.在这种模式下，可以通过Mediator解决组件间头文件直接引用、依赖混乱的问题。需要注意的是Mediator应该只负责挂接节点的通信任务，不应该包含涉及具体业务的逻辑。也就是说Mediator中只应该负责找到响应方，将参数打包抛给响应方即可，至于具体的逻辑由调用方和响应方做具体的处理。</p>
<p>下面是CTMediator的大致结构：<br><img src="/2019/09/14/iOS-%E7%BB%84%E4%BB%B6%E5%8C%96%E6%80%BB%E7%BB%93/0000004.png"></p>
<p>还有一处可能会带来耦合的地方是组件间的数据交付形式，如果不用组件化的话我们一般在两个对象数据产生交付的时候一般会以一个具体的Model形式交付，但是应用组件化后这些Model存放在哪里就是个问题，模型类放在调用方和被调方的哪个组件都不太合适，因为以具体Model形式交付的化双方就都会依赖这个Model，这就导致必须将这个Model下沉。但是同一个Model可能是多个模块之间交付的数据形式，这就导致需要将所有的Model放置到一个单独的下层组件中去。也就是说每个层都会有一个Model层供上层使用，在这种情况下抽出某个组件都会有藕断丝连痛不欲生的感觉。可能大家会退而求其次在用到这个模型对象的所有组件中，都分别维护一份相同的模型类，或者各自维护不同结构的模型类，但是这样业务发生改变模型类就会很麻烦，这是不可取的。所以比较合理的方式是去Model化，以Dictionary形式进行交互，参数Dictionary在Mediator中封装。这样所有的变化都集中在Mediator中。这里需要注意的是组件内部还是可以使用Model的。</p>
<p>总结:</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line">在解耦方面，主要有两部分会产生耦合：</span><br><span class="line"><span class="bullet">* </span>一个是组件间调用，一个是组件间数据交付形式</span><br><span class="line"><span class="bullet">* </span>前者可以借助runtime + target-action形式解决，后者采用去Model化Dictionary进行交付。</span><br></pre></td></tr></table></figure>

<h5 id="3-2-组件路由"><a href="#3-2-组件路由" class="headerlink" title="3.2 组件路由"></a>3.2 组件路由</h5><h5 id="3-2-1-组件路由的作用"><a href="#3-2-1-组件路由的作用" class="headerlink" title="3.2.1 组件路由的作用"></a>3.2.1 组件路由的作用</h5><p>路由是组件化中很重要的一部分，我们有时候会自嘲我们日常做的工作就是从一个界面点击后跳转到另一界面拉取数据后，再次点击后再重复上面的工作，这个侧面反应了路由跳转再整个应用中的重要程度，但是我们再从比较宽泛的角度来看，其实通过路由不一定只是解决在页面之间的跳转问题，它其实是一个资源的索引，通过它不但可以跳转页面，还可以获得某些资源数据。</p>
<h5 id="3-2-2-评判组件路由的标准"><a href="#3-2-2-评判组件路由的标准" class="headerlink" title="3.2.2 评判组件路由的标准"></a>3.2.2 评判组件路由的标准</h5><p>一个组件路由设计得好还是不好往往会有一定地标准去评判，下面列出个人认为的一些标准：</p>
<ul>
<li><p><strong><strong>准确高效</strong></strong><br>路由最基本的要求就是准确高效，如果这一点都不能保证那么这个路由一般不会在项目中采用。</p>
</li>
<li><p><strong><strong>灵活跳转</strong></strong></p>
</li>
</ul>
<p>在设计路由接口的时候一般需要思考如下几个点：</p>
<ul>
<li><p>如何对外提供远程访问的功能：<br>这些接口包括：Web端访问的接口，其他App调用接口。</p>
</li>
<li><p>如何在应用内部提供应用内模块(组件)间的页面之间访问的功能。</p>
</li>
<li><p>如何统一同一个产品下不同端，不同页面形式（RN,Weex，H5，Native页面）之间的路由方式。</p>
</li>
<li><p>如何通过路由访问资源</p>
</li>
<li><p>如何通过路由进行模块调度，组件加载</p>
</li>
<li><p><strong><strong>动态性</strong></strong></p>
</li>
</ul>
<p>一般我们在设计路由的时候都会有个路由映射表，可能你会说target-action方式没有这种路由映射表，但实际上它的target以及action selector就是它的路由映射表，有了路由映射表的概念，我们就可以通过动态下发对应的路由映射表来实现路由的动态化，在跳转之前查询下如果有在路由映射表里面那么就按照表里面的进行跳转，如果不在那么就按照原样跳转，通过这种机制在跳转前进行拦截，替换，这有什么好处呢？比如我们线上某个页面有奔溃异常那么可以将这个界面的路由指定到一个统一的异常页面页面，或者用某个特定的H5页面作为降级页面，这样就可以达到简单的热修复的目的。</p>
<p>在这里需要补充一点：有了路由后我们可以在路由上做很多工作，除了上面提到了热修复策略，页面黑白名单策略，还可以在路由上进行统一跳转埋点，鉴权，配合灰度进行风控逻辑。</p>
<ul>
<li><strong><strong>安全性</strong></strong></li>
</ul>
<p>跨应用时，需要注意注入攻击，做到敏感参数加密防篡改，同时需要注意路由层应提供能够实现风控的机制。<br>跨业务系统的时候，访问敏感页面或资源的时候需要通过Token等认证信息来实现路由层的身份认证。</p>
<p>下面是目前开源的一些比较好的路由开源代码，大家在设计过程中可以参照这些项目进行设计符合自己项目的路由器：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/joeldev/JLRoutes">JLRoutes 5029 star</a><br><a target="_blank" rel="noopener" href="https://github.com/casatwy/CTMediator">CTMediator 2638 star</a><br><a target="_blank" rel="noopener" href="https://github.com/meili/MGJRouter">MGJRouter 1946 star</a><br><a target="_blank" rel="noopener" href="https://github.com/clayallsopp/routable-ios">routable-ios 1773 star</a><br><a target="_blank" rel="noopener" href="https://github.com/button/DeepLinkKit">DeepLinkKit 3236 star</a><br><a target="_blank" rel="noopener" href="https://github.com/aaronbrethorst/ABRouter">ABRouter 136 star</a><br><a target="_blank" rel="noopener" href="https://github.com/lightory/HHRouter">HHRouter 1574 star</a><br><a target="_blank" rel="noopener" href="https://github.com/imlifengfeng/FFRouter">FFRouter 157 star</a><br><a target="_blank" rel="noopener" href="https://github.com/chenxiancai/STCRouter">STCRouter 19 star</a></p>
<p>上面的路由大体可以归为三类：URL形式，class-protocals 形式，target-action形式。个人比较偏向于target-action形式，关于target-action形式的组件化介绍可以看下<a target="_blank" rel="noopener" href="https://casatwy.com/iOS-Modulization.html">iOS应用架构谈 组件化方案</a>以及<a target="_blank" rel="noopener" href="https://wereadteam.github.io/2016/03/19/iOS-Component/">iOS 组件化方案探索</a>。URL形式，class-protocals 形式大家可以看下<a target="_blank" rel="noopener" href="https://limboy.me/tech/2016/03/10/mgj-components.html">蘑菇街 App 的组件化之路</a> <a target="_blank" rel="noopener" href="https://limboy.me/tech/2016/03/14/mgj-components-continued.html">蘑菇街 App 的组件化之路·续</a></p>
<p>下面我们分别简单对比下三种路由方式：</p>
<ul>
<li><strong><strong>URL形式</strong></strong></li>
</ul>
<p>这种方式是借鉴前端的路由思想，它将应用内任何资源与一个URL对应在一起。它最大的优点就是可以统一三端路由形式。具有天然的动态性，适合经常开展运营活动的应用，它的缺点也是比较致命的：这种方式不能在模块间传递非常规数据。所以一般会在多端路由的情况下或者暴露给外部应用调用的情况下使用这种形式。</p>
<ul>
<li><strong><strong>Class-Protocals 形式</strong></strong></li>
</ul>
<p>这种方式的优点是没有硬编码，但是它的缺点也比较明显处理不好会产生模块间耦合。</p>
<ul>
<li><strong><strong>Target-Action形式</strong></strong></li>
</ul>
<p>Target-Action方式的优点是无需注册，能够做到被调用模块不被依赖。但是它有个比较不足的地方就是在参数打包的时候会有硬编码，但是可以通过在Mediator中包装一层将这部分归并到Mediator统一处理。</p>
<h5 id="4-组件化消息总线设计"><a href="#4-组件化消息总线设计" class="headerlink" title="4 组件化消息总线设计"></a>4 组件化消息总线设计</h5><p>下图是个人设计的一个组件化消息总线：</p>
<p><img src="/2019/09/14/iOS-%E7%BB%84%E4%BB%B6%E5%8C%96%E6%80%BB%E7%BB%93/0000003.png"></p>
<p>整个总线是集中式下发，消息中心包含了各个消息的注册信息，最主要包括某个事件的监听组件列表，每个eventType为key，value为当前事件的监听组件列表，另一个注册信息是某个事件的响应selector字符串，key为eventType，value为seletorString, 当某个模块需要发送消息的时候调用triggEvent方法，将要触发的事件以及要携带的参数传递到消息中心，消息中心通过查表找出哪些模块需要通知，然后再查着该事件的响应selector,通过performSeletor来调用监听模块的响应方法，从而达到通知消息的目的。</p>
<h5 id="5-组件集成"><a href="#5-组件集成" class="headerlink" title="5 组件集成"></a>5 组件集成</h5><p>在实际项目中一般会将每个组件都分割成一个单独工程，通过git统一管理，主工程通过Cocoapods集成各个组件，关于Cocoapods的时候大家可以看之前的博客，之前有专门拎出一篇博客进行介绍，但是除了Cocoapods之外还可以有其他的方式。一种是在项目中直接集成源码这种的优点是在主工程调试比较方便，可以看到组件的内部实现，另一种是framework，它的好处是可以加快编译速度，并且每个组件的代码是不可见的，对于比较机密敏感的模块可以选用这种方式。</p>
<p><img src="/2019/09/14/iOS-%E7%BB%84%E4%BB%B6%E5%8C%96%E6%80%BB%E7%BB%93/0000005.png"></p>
<h5 id="6-组件化步骤"><a href="#6-组件化步骤" class="headerlink" title="6 组件化步骤"></a>6 组件化步骤</h5><p>在项目相对稳定成型的时候我们就可以向项目引入组件化了，有了上面的介绍相信大家对整个组件化有了一定的了解了，作为文章的最后给出一个组件化的一个步骤供大家在项目实际开发过程中参考：</p>
<ul>
<li>6.1 <strong><strong>项目模块划分</strong></strong></li>
</ul>
<p>组件化过程不同人有不同的方式，有的人喜欢从下往上，先从细粒度的基本组件开始，然后再封装功能组件，而后才是业务模块，但是个人比较不推荐这种方式，这种方式比较容易陷入到细节中没有宏观的概念，建议找个纸和笔画出整个项目可以划分成哪些模块，这些模块就是我们的业务模块部分，然后在划分这部分模块的时候，再考虑这个模块有那些功能，一一穷举出来，这时候就大概知道有那些功能模块了，到了这一步就可以开始动手从代码层面上进行组件划分了，在划分过程中再把通用的部分下沉，形成一个一个基础组件。不断封装不断下沉公共部分。通过定义一些组件间接口，这些接口后续会在路由中实现，步骤完成后确认组件和其他部分代码没有耦合后就可以将这部分组件提交到组件库中进行管理。</p>
<p>基础层组件则在集成后直接依赖，例如资源文件和配置文件，这些都是直接在主工程或组件中使用的。第三方库则是通过功能组件层的业务封装，封装后由路由进行通信，业务组件层是直接依赖第三方库源码的。</p>
<ul>
<li>6.2 <strong><strong>设计组件路由，进行组件解耦</strong></strong></li>
</ul>
<p>个人建议在内部模块之间使用Target-Action方式，而对外接口或者有些需要H5跳转到客户端的采用URL形式（这主要考虑到H5跳客户端需要保持两端共同的跳转方式，而URL是这些之中唯一能够做到多端统一的路由方式）。<br>在开始解耦之前先列出上一步划分的组件之间的交互接口，然后通过组件路由来桥接这些接口，传递数据，这里数据的交付应该是去Model化的形式进行交付。</p>
<ul>
<li>6.3 <strong><strong>组件消息梳理</strong></strong></li>
</ul>
<p>梳理出各个组件哪个组件发出那些消息，哪些组件监听这些消息，都将这些信息注册到组件化消息总线中。</p>
<ul>
<li>6.4 <strong><strong>组件测试</strong></strong></li>
</ul>
<p>经过上述的组件化，需要我们对整个项目进行自测，首先从各个组件内部先进行测试，然后再扩展到组件间的接口部分进行测试，最后再对项目整体进行测试。</p>
<ul>
<li>6.5 <strong><strong>新起项目如何做组件化</strong></strong></li>
</ul>
<p>上面介绍的主要针对项目成型的情况下，通过组件化来重构项目，如果是新起的项目，我们会先将项目配置文件等集成到主工程中，做一些基础的项目配置，随后集成需要的组件。之后各个业务根据业务需求实现各个业务组件，一旦遇到需要依赖基础组件库中的服务的时候，就往主项目中引入基础组件库，遇到要从某个组件开发者那里获得某项服务的时候可以到接口需求后台提单，支持组件开发人员根据需求单来提供服务。在这个过程中可以通过Mock数据来并行开发，组件开发结束后，测试先介入对组件进行功能测试，在所有组件完成后再进行组件集成测试。</p>
<p>总结：<br>这篇文章是写得算是比较久的一篇博客，主要涵盖了：什么是组件化，组件化的优缺点，从项目结构角度分析了一个项目该有的部分，而后正式从如何划分组件，如何从路由角度，数据交付角度来对组件解耦，再接着介绍了路由的功能，三种常见的路由实现方式以及如何设计路由。如何设计消息总线，组件的集成。最后给出了组件化的大致步骤。相信通过上面的介绍结合给出的开源方案，大家都应该会对组件化有个进一步的理解。组件化是一个很强义务相关的话题，需要对自己的项目业务有比较深刻的理解才能设计出比较优雅的组件化框架，本文只是针对比较通用的一些方面进行总结，文章的最后结合<a target="_blank" rel="noopener" href="https://blog.csdn.net/licaomengRICE/article/details/49253255">手机淘宝的客户端架构探索之路</a>来做个结尾，我自己的组件化也从无锋的这篇文章中借鉴了很多思想，所以想分享给大家，首先建议大家先通读原文，然后再看接下来的内容。</p>
<p>首先我们看下整个方案的大题结构图：</p>
<p><img src="/2019/09/14/iOS-%E7%BB%84%E4%BB%B6%E5%8C%96%E6%80%BB%E7%BB%93/0000006.png"></p>
<p>这里涉及到了一切皆Bundle（组件）的概念，整个方案是围绕Bundle展开的，分成三层，最顶层是一系列Bundle，第二层是总线层，用于数据的交付，事件的通知，资源的路由。最后一层则是容器层.<br>如果将容器看成一个OS，那么一个个Bundle就相当于一个个App一样，它是可被部署的单元，里面可以涉及UI的部分，服务的部分。Bundle对容器是没有依赖的，它只会依赖中间的总线层。容器有完全独立的三大职能：启动加载、生命周期管理、组件管理。其中生命周期管理，负责将容器的生命周期通知到各个Bundle，让Bundle能够感知这些生命周期事件，并作出响应。组件管理器负责添加、删除、替换。在启动的时候，会首先由容器完成整个应用的引导流程，容器的初始化，核心中间件的初始化，启动入口的Bundle(入口Bundle是可配置的，一旦被配置就表示用户点击图标后首先会看到的界面).</p>
<p>总线方面主要分成三大部分，UI总线，服务总线，消息总线：</p>
<p><strong><strong>UI总线</strong></strong>和上述的组件路由类似，负责资源的选址，为了三端统一，使用了以跨平台统一的URL作为路由方式，这里比较有意思的是自动降级机制:</p>
<blockquote>
<p>没有Bundle承载的URL，将自动以Web 容器加载。这样就可以实现，当一个新的业务到达手机当中的时候，当手机客户端还没有实现这个功能，就会自动以Web的形式把它运作出来。当想要保证轻量化的时候，可能会裁剪掉一些Bundle，这时没有了这些Bundle，这些功能将会自动以Web的方式替换掉，使得在整个流程里面它是完整的。体验可能会有一些差别，但是功能是不受影响的。</p>
</blockquote>
<p><strong><strong>服务总线</strong></strong>主要用于提供某项服务的总线，通过往总线传入数据后，经过某项服务处理后将数据传出。<br><strong><strong>消息总线</strong></strong>这里的消息总线Android里面使用Broadcast，iOS使用NSNotification。个人比较偏向于使用该博客上面介绍的那种消息总线的方式来通知事件。这里对手淘的具体项目需求不是很清楚所以不做评判。但是这三种总线的划分十分值得借鉴的。</p>
<p>最后手淘在组件化架构的基础上，淘宝提出Bundle App的概念，可以通过已有组件，进行简单配置后就可以组成一个新的app出来。解决了多个应用业务复用的问题，防止重复开发同一业务或功能。</p>
<p><img src="/2019/09/14/iOS-%E7%BB%84%E4%BB%B6%E5%8C%96%E6%80%BB%E7%BB%93/0000007.png"></p>
<h5 id="组件化相关的较好文章"><a href="#组件化相关的较好文章" class="headerlink" title="组件化相关的较好文章"></a>组件化相关的较好文章</h5><ul>
<li><a target="_blank" rel="noopener" href="https://casatwy.com/iOS-Modulization.html">iOS应用架构谈 组件化方案</a></li>
<li><a target="_blank" rel="noopener" href="https://casatwy.com/modulization_in_action.html">在现有工程中实施基于CTMediator的组件化方案</a></li>
<li><a target="_blank" rel="noopener" href="https://limboy.me/tech/2016/03/10/mgj-components.html">蘑菇街 App 的组件化之路</a></li>
<li><a target="_blank" rel="noopener" href="https://limboy.me/tech/2016/03/14/mgj-components-continued.html">蘑菇街 App 的组件化之路·续</a></li>
<li><a target="_blank" rel="noopener" href="https://wereadteam.github.io/2016/03/19/iOS-Component/">iOS 组件化方案探索</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/fengmin/p/5507790.html">iOS组件化思路－大神博客研读和思考</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/alibaba/BeeHive">BeeHive</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/5ucpVa6ku4b9_pfMP9CqlQ">Category 特性在 iOS 组件化中的应用与管控</a></li>
<li><a target="_blank" rel="noopener" href="https://halfrost.com/ios_router/">iOS 组件化 —— 路由设计思路分析</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/22565656">iOS组件化方案</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5d0e1eaf5188251a36222cd9">组件化架构漫谈</a></li>
<li><a target="_blank" rel="noopener" href="https://www.infoq.cn/article/BwVSA-aI2jVv4IRNOwps">有赞移动 iOS 组件化（模块化）架构设计实践</a></li>
<li><a target="_blank" rel="noopener" href="https://zuikyo.github.io/2019/07/15/iOS_inrerface_orientation_modularization/">打造完备的iOS组件化方案：如何面向接口进行模块解耦</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/licaomengRICE/article/details/49253255">手机淘宝客户端架构探索实践</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/cf314e4df9ad">iOS组件化–壳工程</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/568e875abd48">iOS组件化实践(一)：简介</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5ba3cc0df265da0aac6fdaa0">iOS 从零到一搭建组件化项目框架</a></li>
</ul>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/iOS-%E8%BF%9B%E9%98%B6/">iOS 进阶</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/iOS-进阶/">iOS 进阶</a>
  </div>

</div>



<div class="comments-count">
	
	  	<span></span>
		<a href="/2019/09/14/iOS-组件化总结/#comments" class="ds-thread-count comments-count-link" data-thread-key="2019/09/14/iOS-组件化总结/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/09/10/在部门内分享的Flutter材料/" title="iOS 跨平台方案总结" itemprop="url">iOS 跨平台方案总结</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Edgar" target="_blank" itemprop="author">Edgar</a>
		
  <p class="article-time">
    <time datetime="2019-09-10T15:01:42.000Z" itemprop="datePublished"> Published 2019-09-10</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>这是源于个人在公司内部Flutter分享时候的PPT,同时也对跨平台方案做了个简单的总结比较，分享给大家希望对大家有帮助:</p>
<p><img src="/2019/09/10/%E5%9C%A8%E9%83%A8%E9%97%A8%E5%86%85%E5%88%86%E4%BA%AB%E7%9A%84Flutter%E6%9D%90%E6%96%99/0001.png"><br><img src="/2019/09/10/%E5%9C%A8%E9%83%A8%E9%97%A8%E5%86%85%E5%88%86%E4%BA%AB%E7%9A%84Flutter%E6%9D%90%E6%96%99/0002.png"><br><img src="/2019/09/10/%E5%9C%A8%E9%83%A8%E9%97%A8%E5%86%85%E5%88%86%E4%BA%AB%E7%9A%84Flutter%E6%9D%90%E6%96%99/0003.png"><br><img src="/2019/09/10/%E5%9C%A8%E9%83%A8%E9%97%A8%E5%86%85%E5%88%86%E4%BA%AB%E7%9A%84Flutter%E6%9D%90%E6%96%99/0004.png"><br><img src="/2019/09/10/%E5%9C%A8%E9%83%A8%E9%97%A8%E5%86%85%E5%88%86%E4%BA%AB%E7%9A%84Flutter%E6%9D%90%E6%96%99/0005.png"><br><img src="/2019/09/10/%E5%9C%A8%E9%83%A8%E9%97%A8%E5%86%85%E5%88%86%E4%BA%AB%E7%9A%84Flutter%E6%9D%90%E6%96%99/0006.png"><br><img src="/2019/09/10/%E5%9C%A8%E9%83%A8%E9%97%A8%E5%86%85%E5%88%86%E4%BA%AB%E7%9A%84Flutter%E6%9D%90%E6%96%99/0007.png"><br><img src="/2019/09/10/%E5%9C%A8%E9%83%A8%E9%97%A8%E5%86%85%E5%88%86%E4%BA%AB%E7%9A%84Flutter%E6%9D%90%E6%96%99/0008.png"><br><img src="/2019/09/10/%E5%9C%A8%E9%83%A8%E9%97%A8%E5%86%85%E5%88%86%E4%BA%AB%E7%9A%84Flutter%E6%9D%90%E6%96%99/0009.png"><br><img src="/2019/09/10/%E5%9C%A8%E9%83%A8%E9%97%A8%E5%86%85%E5%88%86%E4%BA%AB%E7%9A%84Flutter%E6%9D%90%E6%96%99/0010.png"><br><img src="/2019/09/10/%E5%9C%A8%E9%83%A8%E9%97%A8%E5%86%85%E5%88%86%E4%BA%AB%E7%9A%84Flutter%E6%9D%90%E6%96%99/0011.png"><br><img src="/2019/09/10/%E5%9C%A8%E9%83%A8%E9%97%A8%E5%86%85%E5%88%86%E4%BA%AB%E7%9A%84Flutter%E6%9D%90%E6%96%99/0012.png"><br><img src="/2019/09/10/%E5%9C%A8%E9%83%A8%E9%97%A8%E5%86%85%E5%88%86%E4%BA%AB%E7%9A%84Flutter%E6%9D%90%E6%96%99/0013.png"><br><img src="/2019/09/10/%E5%9C%A8%E9%83%A8%E9%97%A8%E5%86%85%E5%88%86%E4%BA%AB%E7%9A%84Flutter%E6%9D%90%E6%96%99/0014.png"><br><img src="/2019/09/10/%E5%9C%A8%E9%83%A8%E9%97%A8%E5%86%85%E5%88%86%E4%BA%AB%E7%9A%84Flutter%E6%9D%90%E6%96%99/0015.png"><br><img src="/2019/09/10/%E5%9C%A8%E9%83%A8%E9%97%A8%E5%86%85%E5%88%86%E4%BA%AB%E7%9A%84Flutter%E6%9D%90%E6%96%99/0016.png"><br><img src="/2019/09/10/%E5%9C%A8%E9%83%A8%E9%97%A8%E5%86%85%E5%88%86%E4%BA%AB%E7%9A%84Flutter%E6%9D%90%E6%96%99/0017.png"><br><img src="/2019/09/10/%E5%9C%A8%E9%83%A8%E9%97%A8%E5%86%85%E5%88%86%E4%BA%AB%E7%9A%84Flutter%E6%9D%90%E6%96%99/0018.png"><br><img src="/2019/09/10/%E5%9C%A8%E9%83%A8%E9%97%A8%E5%86%85%E5%88%86%E4%BA%AB%E7%9A%84Flutter%E6%9D%90%E6%96%99/0019.png"><br><img src="/2019/09/10/%E5%9C%A8%E9%83%A8%E9%97%A8%E5%86%85%E5%88%86%E4%BA%AB%E7%9A%84Flutter%E6%9D%90%E6%96%99/0020.png"><br><img src="/2019/09/10/%E5%9C%A8%E9%83%A8%E9%97%A8%E5%86%85%E5%88%86%E4%BA%AB%E7%9A%84Flutter%E6%9D%90%E6%96%99/0021.png"><br><img src="/2019/09/10/%E5%9C%A8%E9%83%A8%E9%97%A8%E5%86%85%E5%88%86%E4%BA%AB%E7%9A%84Flutter%E6%9D%90%E6%96%99/0022.png"><br><img src="/2019/09/10/%E5%9C%A8%E9%83%A8%E9%97%A8%E5%86%85%E5%88%86%E4%BA%AB%E7%9A%84Flutter%E6%9D%90%E6%96%99/0023.png"><br><img src="/2019/09/10/%E5%9C%A8%E9%83%A8%E9%97%A8%E5%86%85%E5%88%86%E4%BA%AB%E7%9A%84Flutter%E6%9D%90%E6%96%99/0024.png"><br><img src="/2019/09/10/%E5%9C%A8%E9%83%A8%E9%97%A8%E5%86%85%E5%88%86%E4%BA%AB%E7%9A%84Flutter%E6%9D%90%E6%96%99/0025.png"><br><img src="/2019/09/10/%E5%9C%A8%E9%83%A8%E9%97%A8%E5%86%85%E5%88%86%E4%BA%AB%E7%9A%84Flutter%E6%9D%90%E6%96%99/0026.png"><br><img src="/2019/09/10/%E5%9C%A8%E9%83%A8%E9%97%A8%E5%86%85%E5%88%86%E4%BA%AB%E7%9A%84Flutter%E6%9D%90%E6%96%99/0027.png"><br><img src="/2019/09/10/%E5%9C%A8%E9%83%A8%E9%97%A8%E5%86%85%E5%88%86%E4%BA%AB%E7%9A%84Flutter%E6%9D%90%E6%96%99/0028.png"><br><img src="/2019/09/10/%E5%9C%A8%E9%83%A8%E9%97%A8%E5%86%85%E5%88%86%E4%BA%AB%E7%9A%84Flutter%E6%9D%90%E6%96%99/0029.png"><br><img src="/2019/09/10/%E5%9C%A8%E9%83%A8%E9%97%A8%E5%86%85%E5%88%86%E4%BA%AB%E7%9A%84Flutter%E6%9D%90%E6%96%99/0030.png"><br><img src="/2019/09/10/%E5%9C%A8%E9%83%A8%E9%97%A8%E5%86%85%E5%88%86%E4%BA%AB%E7%9A%84Flutter%E6%9D%90%E6%96%99/0031.png"><br><img src="/2019/09/10/%E5%9C%A8%E9%83%A8%E9%97%A8%E5%86%85%E5%88%86%E4%BA%AB%E7%9A%84Flutter%E6%9D%90%E6%96%99/0032.png"></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/iOS-%E8%BF%9B%E9%98%B6/">iOS 进阶</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/iOS-进阶/">iOS 进阶</a>
  </div>

</div>



<div class="comments-count">
	
	  	<span></span>
		<a href="/2019/09/10/在部门内分享的Flutter材料/#comments" class="ds-thread-count comments-count-link" data-thread-key="2019/09/10/在部门内分享的Flutter材料/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>







  <nav id="page-nav" class="clearfix">
    <a class="extend prev" rel="prev" href="/page/5/">&lt;span&gt;&lt;&#x2F;span&gt;Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><a class="page-number" href="/page/8/">8</a><span class="space">&hellip;</span><a class="page-number" href="/page/30/">30</a><a class="extend next" rel="next" href="/page/7/">Next&lt;span&gt;&lt;&#x2F;span&gt;</a>
  </nav>

</div>
      <div class="openaside"><a class="navbutton" href="#" title="Show Sidebar"></a></div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="Hide Sidebar"></a></div>
<aside class="clearfix">
<div id="authorInfo">
	
		<div class="author-img"></div>		
	
	<div class="social-info" class="clearfix">
		
		
		<a href="https://github.com/tbfungeek" target="_blank" class="icon-github" title="github"></a>
		
		
		
		
		
		
		
		
		
		
		<a href="mailto:tbfungeek@163.com" target="_blank" class="icon-email" title="Email Me"></a>
		

	</div>
</div>

  
<div class="categorieslist">
	<p class="asidetitle">Categories</p>
		<ul>
		
		  
			<li><a href="/categories/Android-小经验/" title="Android 小经验">Android 小经验<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Android-源码分析/" title="Android 源码分析">Android 源码分析<sup>21</sup></a></li>
		  
		
		  
			<li><a href="/categories/Android其他/" title="Android其他">Android其他<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Android初步/" title="Android初步">Android初步<sup>21</sup></a></li>
		  
		
		  
			<li><a href="/categories/Android进阶/" title="Android进阶">Android进阶<sup>100</sup></a></li>
		  
		
		  
			<li><a href="/categories/Hexo-使用/" title="Hexo 使用">Hexo 使用<sup>10</sup></a></li>
		  
		
		  
			<li><a href="/categories/JavaScript理论/" title="JavaScript理论">JavaScript理论<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Objective-C-相关/" title="Objective C 相关">Objective C 相关<sup>24</sup></a></li>
		  
		
		  
			<li><a href="/categories/OpenCV/" title="OpenCV">OpenCV<sup>6</sup></a></li>
		  
		
		  
			<li><a href="/categories/ROS/" title="ROS">ROS<sup>9</sup></a></li>
		  
		
		  
			<li><a href="/categories/iOS-工具使用/" title="iOS 工具使用">iOS 工具使用<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/iOS-开源库分析/" title="iOS 开源库分析">iOS 开源库分析<sup>36</sup></a></li>
		  
		
		  
			<li><a href="/categories/iOS-理论基础/" title="iOS 理论基础">iOS 理论基础<sup>14</sup></a></li>
		  
		
		  
			<li><a href="/categories/iOS-进阶/" title="iOS 进阶">iOS 进阶<sup>4</sup></a></li>
		  
		
		  
			<li><a href="/categories/个人收藏/" title="个人收藏">个人收藏<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/代码规范/" title="代码规范">代码规范<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/其他/" title="其他">其他<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/博客分类目录/" title="博客分类目录">博客分类目录<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/叨叨系列/" title="叨叨系列">叨叨系列<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/开源代码分析/" title="开源代码分析">开源代码分析<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/开源库分析/" title="开源库分析">开源库分析<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/树莓派/" title="树莓派">树莓派<sup>4</sup></a></li>
		  
		
		  
			<li><a href="/categories/版本控制/" title="版本控制">版本控制<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/直播/" title="直播">直播<sup>6</sup></a></li>
		  
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">Tags</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/iOS-开源库分析/" title="iOS 开源库分析">iOS 开源库分析<sup>36</sup></a></li>
			
		
			
				<li><a href="/tags/Android-设计模式/" title="Android 设计模式">Android 设计模式<sup>29</sup></a></li>
			
		
			
				<li><a href="/tags/Objective-C-相关/" title="Objective C 相关">Objective C 相关<sup>24</sup></a></li>
			
		
			
				<li><a href="/tags/Android基础/" title="Android基础">Android基础<sup>21</sup></a></li>
			
		
			
				<li><a href="/tags/AOSP-源码/" title="AOSP 源码">AOSP 源码<sup>17</sup></a></li>
			
		
			
				<li><a href="/tags/Android-常用第三方库/" title="Android 常用第三方库">Android 常用第三方库<sup>15</sup></a></li>
			
		
			
				<li><a href="/tags/iOS-理论基础/" title="iOS 理论基础">iOS 理论基础<sup>14</sup></a></li>
			
		
			
				<li><a href="/tags/Hexo-使用/" title="Hexo 使用">Hexo 使用<sup>10</sup></a></li>
			
		
			
				<li><a href="/tags/ROS/" title="ROS">ROS<sup>9</sup></a></li>
			
		
			
				<li><a href="/tags/Android-动画进阶/" title="Android 动画进阶">Android 动画进阶<sup>8</sup></a></li>
			
		
			
				<li><a href="/tags/Android-JNI/" title="Android JNI">Android JNI<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/Android-绘图进阶/" title="Android 绘图进阶">Android 绘图进阶<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/Android性能优化/" title="Android性能优化">Android性能优化<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/Android-自动化测试/" title="Android 自动化测试">Android 自动化测试<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/OpenCV/" title="OpenCV">OpenCV<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/直播/" title="直播">直播<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/Android-开源源码/" title="Android 开源源码">Android 开源源码<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/Android-自定义View进阶/" title="Android 自定义View进阶">Android 自定义View进阶<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/树莓派/" title="树莓派">树莓派<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/iOS-进阶/" title="iOS 进阶">iOS 进阶<sup>4</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">Links</p>
    <ul>
        
          <li>
            
            	<a href="https://hexo.io" target="_blank" title="Hexo">Hexo</a>
            
          </li>
        
          <li>
            
            	<a href="https://pages.github.com/" target="_blank" title="GitHub">GitHub</a>
            
          </li>
        
          <li>
            
            	<a href="http://pf18.github.io/" target="_blank" title="PF18">PF18</a>
            
          </li>
        
          <li>
            
            	<a href="http://toutiao.io/" target="_blank" title="开发者头条">开发者头条</a>
            
          </li>
        
          <li>
            
            	<a href="http://www.jcodecraeer.com/" target="_blank" title="泡在网上的日子">泡在网上的日子</a>
            
          </li>
        
    </ul>
</div>

  


  <div class="rsspart">
	<a href="atom.xml" target="_blank" title="rss">RSS</a>
</div>

  
  <div class="tagcloudlist">
    <p class="asidetitle">Tag Cloud</p>
    <div class="tagcloudlist clearfix">
       <a href="/tags/AOSP-%E6%BA%90%E7%A0%81/" style="font-size: 17.14px;">AOSP 源码</a> <a href="/tags/Android-APK-%E7%AD%BE%E5%90%8D/" style="font-size: 10px;">Android APK 签名</a> <a href="/tags/Android-JNI/" style="font-size: 12.86px;">Android JNI</a> <a href="/tags/Android-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E8%BF%9B%E9%98%B6/" style="font-size: 10.71px;">Android 事件处理进阶</a> <a href="/tags/Android-%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6/" style="font-size: 13.57px;">Android 动画进阶</a> <a href="/tags/Android-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%80%E5%8F%91/" style="font-size: 10px;">Android 多线程开发</a> <a href="/tags/Android-%E5%B0%8F%E7%BB%8F%E9%AA%8C/" style="font-size: 10px;">Android 小经验</a> <a href="/tags/Android-%E5%B8%B8%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/" style="font-size: 16.43px;">Android 常用第三方库</a> <a href="/tags/Android-%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/" style="font-size: 10px;">Android 开发流程</a> <a href="/tags/Android-%E5%BC%80%E6%BA%90%E6%BA%90%E7%A0%81/" style="font-size: 12.14px;">Android 开源源码</a> <a href="/tags/Android-%E7%BB%98%E5%9B%BE%E8%BF%9B%E9%98%B6/" style="font-size: 12.86px;">Android 绘图进阶</a> <a href="/tags/Android-%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/" style="font-size: 12.86px;">Android 自动化测试</a> <a href="/tags/Android-%E8%87%AA%E5%AE%9A%E4%B9%89View%E8%BF%9B%E9%98%B6/" style="font-size: 12.14px;">Android 自定义View进阶</a> <a href="/tags/Android-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 19.29px;">Android 设计模式</a> <a href="/tags/Android%E5%85%B6%E4%BB%96/" style="font-size: 10px;">Android其他</a> <a href="/tags/Android%E5%9F%BA%E7%A1%80/" style="font-size: 17.86px;">Android基础</a> <a href="/tags/Android%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/" style="font-size: 10px;">Android开发流程</a> <a href="/tags/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" style="font-size: 12.86px;">Android性能优化</a> <a href="/tags/Android%E6%B7%B7%E6%B7%86%E6%8A%80%E6%9C%AF/" style="font-size: 10px;">Android混淆技术</a> <a href="/tags/Android%E8%B4%A8%E9%87%8F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/" style="font-size: 11.43px;">Android质量管理工具</a> <a href="/tags/Android%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/" style="font-size: 10px;">Android逆向工程</a> <a href="/tags/Git-github/" style="font-size: 10px;">Git && github</a> <a href="/tags/Hexo-%E4%BD%BF%E7%94%A8/" style="font-size: 15px;">Hexo 使用</a> <a href="/tags/JavaScript/" style="font-size: 10px;">JavaScript</a> <a href="/tags/Linux-%E4%BD%BF%E7%94%A8/" style="font-size: 10px;">Linux 使用</a> <a href="/tags/Objective-C-%E7%9B%B8%E5%85%B3/" style="font-size: 18.57px;">Objective C 相关</a> <a href="/tags/OpenCV/" style="font-size: 12.86px;">OpenCV</a> <a href="/tags/ROS/" style="font-size: 14.29px;">ROS</a> <a href="/tags/iOS-%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/" style="font-size: 10.71px;">iOS 工具使用</a> <a href="/tags/iOS-%E5%BC%80%E6%BA%90%E5%BA%93%E5%88%86%E6%9E%90/" style="font-size: 20px;">iOS 开源库分析</a> <a href="/tags/iOS-%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/" style="font-size: 15.71px;">iOS 理论基础</a> <a href="/tags/iOS-%E8%BF%9B%E9%98%B6/" style="font-size: 12.14px;">iOS 进阶</a> <a href="/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/" style="font-size: 10px;">代码规范</a> <a href="/tags/%E5%8D%9A%E5%AE%A2%E5%88%86%E7%B1%BB%E7%9B%AE%E5%BD%95/" style="font-size: 10.71px;">博客分类目录</a> <a href="/tags/%E5%8F%A8%E5%8F%A8%E7%B3%BB%E5%88%97/" style="font-size: 10px;">叨叨系列</a> <a href="/tags/%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/" style="font-size: 11.43px;">工具的使用</a> <a href="/tags/%E5%BC%80%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/" style="font-size: 10.71px;">开源代码分析</a> <a href="/tags/%E5%BC%80%E6%BA%90%E5%BA%93%E5%88%86%E6%9E%90/" style="font-size: 10px;">开源库分析</a> <a href="/tags/%E6%9D%82%E7%B1%BB/" style="font-size: 10px;">杂类</a> <a href="/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/" style="font-size: 12.14px;">树莓派</a> <a href="/tags/%E7%9B%B4%E6%92%AD/" style="font-size: 12.86px;">直播</a> <a href="/tags/%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/" style="font-size: 10.71px;">编程技巧</a> <a href="/tags/%E7%BD%91%E7%AB%99%E6%94%B6%E8%97%8F/" style="font-size: 10px;">网站收藏</a> <a href="/tags/%E9%87%8D%E8%A6%81%E6%8E%A7%E4%BB%B6/" style="font-size: 11.43px;">重要控件</a>
    </div>
  </div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
		
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/hsihohuang/kiddochan" target="_blank" title="Kiddochan">Kiddochan</a> © 2022 
		
		<a href="/about" target="_blank" title="Edgar">Edgar</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
        
    }
  });
});
</script>










<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?7c9443b0374f1cf6b1dbb5ab84d939cb";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="Back to Top"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
 </html>
