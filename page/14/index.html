
 <!DOCTYPE HTML>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
  
    <title>Edgar&#39;s Blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="Edgar">
    

    
    <meta name="description" content="Android | 全栈工程师">
<meta property="og:type" content="website">
<meta property="og:title" content="Edgar&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/page/14/index.html">
<meta property="og:site_name" content="Edgar&#39;s Blog">
<meta property="og:description" content="Android | 全栈工程师">
<meta property="og:locale">
<meta property="article:author" content="Edgar">
<meta name="twitter:card" content="summary">

    
    <link rel="alternative" href="atom.xml" title="Edgar&#39;s Blog" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/unnamed4_n_mSY_icon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/profile.png">
    <link rel="apple-touch-icon-precomposed" href="/img/profile.png">
    
    
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 6.2.0"></head>

  <body>
    <header>
      
<div>
		
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="Edgar&#39;s Blog">Edgar&#39;s Blog</a></h1>
				<h2 class="blog-motto"></h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="Menu">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
					<li>
 					
					<form class="search" action="/search/index.html" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" autocomplete="off" name="q" maxlength="20" placeholder="Search" />
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main">

   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/07/30/Android-源码分析之基于Stagefright的MediaPlayer框架/" title="Android-源码分析之基于Stagefright的MediaPlayer播放框架[0]" itemprop="url">Android-源码分析之基于Stagefright的MediaPlayer播放框架[0]</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Edgar" target="_blank" itemprop="author">Edgar</a>
		
  <p class="article-time">
    <time datetime="2016-07-30T11:15:30.000Z" itemprop="datePublished"> Published 2016-07-30</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>Android上的MediaPlayer播放底层框架已经经历了多次变动，从最早先的OpenCore到后来的StageFright再到现在的NuPlayerDriver，在工作开始接触Android的时候已经移除了OpenCore所以对OpenCore的了解仅仅停留在听说过，这些框架在演进过程中一般都是先两种框架并存，然后再在某个版本中将其移除，早先Android中使用的是Stagefright + NuPlayer并存的方式，其中前者负责播放本地的媒体文件，后者用于播放网络流媒体文件，但是在后来的Android L开始NuPlayeri渐渐开始替代了Stagefright，目前本地播放已经切换到NuPlayer上了，在Android N AOPS 源代码中甚至移除了Stagefright。在接下来的两篇博客中将会给大家介绍Stragefright播放框架以及Nuplayer播放框架。<br>今天这篇先带大家看下Stagefright播放框架。在介绍Stagefright和Nuplayer之前我们先来看下Android MediaPlayer播放框架的大体结构图：</p>
<p>整个结构可以分成如下几个部分：</p>
<ul>
<li>MediaPlayer  Java层，这是我们开发上层应用所接触的API层。代码位于 frameworks&#x2F;base&#x2F;media&#x2F;java&#x2F;android&#x2F;media&#x2F;MediaPlayer.java</li>
<li>MediaPlayer  JNI 层，它用于将Java层和MediaPlayer的 native层连接起来。代码位于frameworks&#x2F;base&#x2F;media&#x2F;jni&#x2F;android_media_MediaPlayer.cpp</li>
<li>MediaPLayer  Native层，它是MediaPlayer的本地代码这里包括了Stagefright + AwesomePlayer 以及Nuplayer + Nuplayer 两大播放框架，代码位于frameworks&#x2F;av&#x2F;</li>
<li>MediaPlayer  HardWare层，这个涉及到一些硬编码部分<br><img src="/2016/07/30/Android-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E5%9F%BA%E4%BA%8EStagefright%E7%9A%84MediaPlayer%E6%A1%86%E6%9E%B6/1.png"></li>
</ul>
<p>上面只是一个通用的结构，下面来个基于Stagefight的MediaPLayer框架的结构：</p>
<p><img src="/2016/07/30/Android-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E5%9F%BA%E4%BA%8EStagefright%E7%9A%84MediaPlayer%E6%A1%86%E6%9E%B6/2.png"></p>
<p>在最上层是应用层，这里包括Music，Video还可以是一些其他相关的应用，这些应用使用framwork层提供的上层API接口来访问和操作底层的播放框架，上面已经介绍过在Java层和native层之间通过jni层来进行映射，这些native层部件则通过IPC进程间通信方式来从Media Player Service获得请求的响应。Media Player Service 是在mediaserver创建的时候被创建出来的，它负责根据当前文件的mimetype创建合适的media player，并由对应的mediaplayer实例化一个合适的编解码器，获取和操作多媒体文件的内容，以及管理其间的缓存。下面是各个层的更为详细的介绍。<br>为了在后续的介绍中不被整个代码绕晕建议在这里先通过这些图对整个框架有大体的了解。后续的代码介绍的时候我会更偏向于细节介绍。</p>
<ul>
<li><p>应用层和framework层<br>使用到MediaPlayer的应用很多，最常见的就是Music和Video，如果要了解这些应用的实现可以看下AOSP代码中的packages&#x2F;apps，这些代码中用到了frameworks&#x2F;base&#x2F;media&#x2F;所提供的MediaPlayer接口，这些接口都十分简单，我们只需要知道这些接口的具体功能就可以开发出一款功能较为齐全的Music，但是如果遇到一些难以解决的问题的时候就需要深入到native层的实现，从底层的实现来找到问题的根源，所以通过framework层代码可以更加深入得了解整个播放框架的机制。</p>
</li>
<li><p>Native Media Player 层：<br>对于刚接触MediaPlayer框架的时候最怕的就是阅读这部分代码了，一旦播放流程走到JNI接口，再从JNI接口进入native层，整个请求的数据流和控制流都会变得复杂起来。并且这部分不像应用层那样调式起来方便，有大量的文档可以参阅，所以基本的学习方式只能通过打Log和阅读代码的注释。这部分将会再后续部分进行比较详细的讲解分析。</p>
</li>
<li><p>Media Player Service 部分：</p>
</li>
</ul>
<p>从Native层发出的IPC请求将会由Media Player Service 部分进行处理.MediaPlayerService是在frameworks&#x2F;av&#x2F;media&#x2F;mediaserver&#x2F;main_mediaserver.cpp的main方法中初始化的，在main方法中还启动了多个Android系统服务比如AudioFlinger, CameraService等，实例化Media Player Service 子系统的工作包括MediaPlayerService对象的创建,以及内置底层Media PLayer播放框架工厂的注册，一旦 MediaPlayerService 服务启动，MediaPlayerService将会接受Native MediaPlayer 层的IPC请求，并且为每个操作media内容的请求实例化一个MediaPlayerService::Client对象, Client有一个createPlayer 的方法可以使用特定的工厂类为某个特定的类型创建一个本地media player，后续的发向native层的请求都会交给刚刚提到的native 层的 media palyer来处理，这里的media player指的是StagefrightPlayer或者Nuplayerdriver.但是我们这里先不讨论Nuplayerdriver。</p>
<p><img src="/2016/07/30/Android-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E5%9F%BA%E4%BA%8EStagefright%E7%9A%84MediaPlayer%E6%A1%86%E6%9E%B6/3.png"></p>
<p>AwesomePlayer是实现播放的底层操作者，它在StagefrightPlayer初始化的时候被创建，它负责将对应的音频视频和对应的解码器对应起来。这里涉及到了MediaExtractor，它会从媒体文件中抽取到有效的头信息。并返回对应的引用。在准备播放的时候AwesomePlayer通过OMXCodec来根据媒体文件类型创建解码器，解码器是驻留在OMX子系统上（OMX是OpenMAX在Android上面的实现)，这些解码器主要用于处理内存缓冲，转化成原始数据格式，这部分的实现代码主要在frameworks&#x2F;av&#x2F;media&#x2F;libstagefright&#x2F;omx 以及frameworks&#x2F;av&#x2F;media&#x2F;libstagefright&#x2F;codecs 目录下, Stagefright Media Player和 OMX部件是通过IPC方式交互的.<br>AwesomePlayer最终会处理应用层发出的播放，暂停，停止等请求，这些请求往往和媒体类型有关联对于音频文件.AwesomePlayer 将会创建一个AudioPlayer来对文件进行处理，比如当前文件只有音频部分需要播放，这时候AwesomePlayer将会调用AudioPlayer::start()进行播放，一旦用户提交了其他新的请求AudioPlayer会使用MediaSource对象来和底层的OMX子系统进行交互。<br>对于视频文件，AwesomePlayer将会触发AwesomeRenderer的视频渲染能力，这也是通过MediaSource&#x2F;OMXCodec 对象和 OMX子系统进行交互。并且AwesomePlayer负责音频和视频的同步工作，所以AwesomePlayer引入了一个时间队列机制TimedEventQueue.当一个入队的事件到期了，TimedEventQueue将会触发AwesomePlayer对应的回调方法从而保证音频和视频的同步. 这些是在 AwesomePlayer::onVideoEvent()方法中实现的, 在处理完当前帧后将会触发AwesomePlayer::postVideoEvent_l()来安排下一次的处理。整个框架的大体功能就是这样，但是到了细节的时候就复杂了。但是不怕，一点点分析就会看到整个框架的全貌了。一定要有耐心和细心，并且需要看多总结。好了这里就先介绍到这里，我们接下来细节部分放在下一篇博客中介绍。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Android-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">Android 源码分析</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/AOSP-源码/">AOSP 源码</a>
  </div>

</div>



<div class="comments-count">
	
	  	<span></span>
		<a href="/2016/07/30/Android-源码分析之基于Stagefright的MediaPlayer框架/#comments" class="ds-thread-count comments-count-link" data-thread-key="2016/07/30/Android-源码分析之基于Stagefright的MediaPlayer框架/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/07/30/Android-源码分析之MediaPlayer-一-状态机介绍/" title="Android 源码分析之MediaPlayer 一 状态机介绍" itemprop="url">Android 源码分析之MediaPlayer 一 状态机介绍</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Edgar" target="_blank" itemprop="author">Edgar</a>
		
  <p class="article-time">
    <time datetime="2016-07-30T08:45:31.000Z" itemprop="datePublished"> Published 2016-07-30</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h4 id="应用层使用MediaPlayer的方式"><a href="#应用层使用MediaPlayer的方式" class="headerlink" title="应用层使用MediaPlayer的方式"></a>应用层使用MediaPlayer的方式</h4><p>在创建MediaPlayer的时候有如下的方式可以选择：</p>
<ul>
<li>将资源存放在raw目录下</li>
<li>使用在线资源的Uri</li>
<li>使用本地资源的Uri</li>
<li>使用Content Provider</li>
</ul>
<p>用法总结如下图所示：</p>
<p><img src="/2016/07/30/Android-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BMediaPlayer-%E4%B8%80-%E7%8A%B6%E6%80%81%E6%9C%BA%E4%BB%8B%E7%BB%8D/2.png"></p>
<h4 id="MediaPlayer状态机机制"><a href="#MediaPlayer状态机机制" class="headerlink" title="MediaPlayer状态机机制"></a>MediaPlayer状态机机制</h4><p>MediaPlayer的状态不是可以任意切换的，它的状态切换受到状态机器的约束：下面是MediaPlayer的状态机的切换图，如果违背了状态机切换规则则会抛出异常这些将会在后续源代码分析的时候进行介绍：</p>
<p><img src="/2016/07/30/Android-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BMediaPlayer-%E4%B8%80-%E7%8A%B6%E6%80%81%E6%9C%BA%E4%BB%8B%E7%BB%8D/1.png"></p>
<p>上图中每个椭圆代表一个状态点，共有Idle状态，End状态，Error状态，Initialized 状态，Prepared 状态，Started状态，Paused 状态，Stop 状态，PlaybackCompleted 状态九个状态：</p>
<ul>
<li><p>Idle状态：MediaPlayer可以通过两种方式进入Idle状态:一种是使用new创建一个，另一种是调用 reset()方法，但是上述两种有细微的差别：在上述两种方式到达Idle状态的时候如果立即调用getCurrentPosition(), getDuration(),setLooping(boolean), setVolume(float, float), pause(), start(), stop(), seekTo(int), prepare() or prepareAsync()这些方法则会产生错误，但是前者不会触发OnErrorListener.onError()，后者则会触发OnErrorListener.onError()。还有个很重要的地方是：当使用new方式创建MediaPlayer实例的时候将处于Idle状态，但是如果使用create方法创建的实例的时候是处于Prepared状态。因此使用使用create方法创建实例后不需要调用prepare()方法。</p>
</li>
<li><p>End状态：当MediaPlayer实例调用release()方法后就处于End状态。一旦处于End状态MediaPlayer实例将不能再被使用并且不能再回到其他的状态。</p>
</li>
<li><p>Error状态:当出现不支持播放的格式，播放流超时，或者在MediaPlayer实例处于错误状态的时候调用prepare(), prepareAsync()或者setDataSource方法时会触发错误，并进入Error状态。这时候如果通过setOnErrorListener(android.media.MediaPlayer.OnErrorListener).设置了错误监听器则在发生上述错误的时候将会调用OnErrorListener.onError()方法。和End状态不同，处于Error状态的实例可以通过调用reset()回到空闲状态。</p>
</li>
<li><p>Initialized 状态：在Idle状态调用setDataSource将会到达Initialized状态。</p>
</li>
<li><p>Prepared 状态：在调用start()方法开始播放之前，需要进入Prepared 状态，可以通过两种方式到达这种状态，一种是调用prepare()方法，这种是同步的方法，只有在方法返回的时候才进入Prepared 状态，另一种是调用prepareAsync()使用异步的方式，这种方式是先让MediaPlayer实例进入Prepared状态并返回，然后内部的播放机制继续完成准备工作直到完成。不论哪种方式只要调用setOnPreparedListener方法.在完成后都会调用onPrepared()方法。</p>
</li>
<li><p>Started状态:在成功调用start()方法后MediaPlayer对象将会进入这个状态，这时候再调用start()方法将不会有任何影响。可以通过调用isPlaying()方法来查看是否处于Started状态。可以通过setOnBufferingUpdateListener(OnBufferingUpdateListener)注册对缓存区情况的监听。</p>
</li>
<li><p>Paused 状态：在Started状态可以调用pause()方法让其进入Paused 状态，在停止状态也可以调用start()方法回到Started状态，也可以调用stop()方法进入Stop状态。需要注意的是从Started状态状态到Paused 状态使用的是异步的方法，当pause()方法返回的时候需要等待一小段时间才能将状态更新到isPlaying()的返回值</p>
</li>
<li><p>Stop 状态：当MediaPlayer实例处于Started, Paused, Prepared 或者PlaybackCompleted状态的时候调用stop方法将会进入Stop 状态。在进入stop状态的时候就不能直接start，而必须通过调用prepare() 或者prepareAsync()方法进入Prepared 状态的时候才可以再次进入start状态。</p>
</li>
<li><p>PlaybackCompleted 状态：当播放完成的时候如果循环模式设为false，那么在播放结束的时候将会进入PlaybackCompleted 状态，如果这之前已经调用setOnCompletionListener(OnCompletionListener)注册监听器的话，将会调用OnCompletion.onCompletion()回调方法。在PlaybackCompleted 状态的时候可以调用start()方法重新开始播放歌曲。如果循环模式设为true则播放完成将不会进入PlaybackCompleted 状态而是继续留在Started状态。</p>
</li>
<li><p>调整歌曲的播放进度,可以调用seekTo(int)方法来调整歌曲的播放进度，seekTo(int)方法会立刻返回。但是实际的seek操作会等待一会儿才会结束，如果调用了setOnSeekCompleteListener(OnSeekCompleteListener).在seek操作结束后将会调用OnSeekComplete.onSeekComplete()方法。可以在Start，Prepared, Paused 和 PlaybackCompleted 状态调用seekTo(int)方法调整歌曲的播放进度。</p>
</li>
</ul>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Android-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">Android 源码分析</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/AOSP-源码/">AOSP 源码</a>
  </div>

</div>



<div class="comments-count">
	
	  	<span></span>
		<a href="/2016/07/30/Android-源码分析之MediaPlayer-一-状态机介绍/#comments" class="ds-thread-count comments-count-link" data-thread-key="2016/07/30/Android-源码分析之MediaPlayer-一-状态机介绍/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/07/29/Android-源码分析之MediaScanner-2/" title="Android 源码分析之MediaScanner[2]" itemprop="url">Android 源码分析之MediaScanner[2]</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Edgar" target="_blank" itemprop="author">Edgar</a>
		
  <p class="article-time">
    <time datetime="2016-07-29T02:40:48.000Z" itemprop="datePublished"> Published 2016-07-29</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h4 id="音频视频文件帧信息的获取"><a href="#音频视频文件帧信息的获取" class="headerlink" title="音频视频文件帧信息的获取"></a>音频视频文件帧信息的获取</h4><p>上面分析的是非音频视频图像文件的扫描流程，在接下来的章节将介绍多媒体文件信息的获取，接下来的部分以MP3格式的音频文件作为分析对象进行介绍：<br>对于MP3格式大家可以在网上找下，这里就不展开介绍了。</p>
<h5 id="音频视频文件的TAG解析流程分析"><a href="#音频视频文件的TAG解析流程分析" class="headerlink" title="音频视频文件的TAG解析流程分析"></a>音频视频文件的TAG解析流程分析</h5><p>在doScanFile中会执行对应的判断，如果当前扫描文件为音频或者视频文件则调用processFile方法进行处理。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Uri <span class="title">doScanFile</span><span class="params">(<span class="type">String</span> path, <span class="type">String</span> mimeType, <span class="type">long</span> lastModified,<span class="type">long</span> fileSize, <span class="type">boolean</span> isDirectory, <span class="type">boolean</span> scanAlways, <span class="type">boolean</span> noMedia)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        FileEntry entry = <span class="built_in">beginFile</span>(path, mimeType, lastModified,</span><br><span class="line">                fileSize, isDirectory, noMedia);</span><br><span class="line">        <span class="comment">//......</span></span><br><span class="line">        <span class="keyword">if</span> (entry != null &amp;&amp; (entry.mLastModifiedChanged || scanAlways)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (noMedia) &#123;</span><br><span class="line">                <span class="comment">//.........</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//........</span></span><br><span class="line">                <span class="comment">// 如果是音频文件或者视频文件调用processFile抽取元数据</span></span><br><span class="line">                <span class="comment">// we only extract metadata for audio and video files</span></span><br><span class="line">                <span class="keyword">if</span> (isaudio || isvideo) &#123;</span><br><span class="line">                    <span class="built_in">processFile</span>(path, mimeType, <span class="keyword">this</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//.........</span></span><br><span class="line">                result = <span class="built_in">endFile</span>(entry, ringtones, notifications, alarms, music, podcasts);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (RemoteException e) &#123;</span><br><span class="line">        <span class="comment">//...................</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在doScanFile调用的processFile是native方法，<br>因此首先调用android_media_Mediascanner.cpp.中的android_media_MediaScanner_processFile方法，在该方法中就直接调用StageFrightMediaScanner的processFile方法。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">android_media_MediaScanner_processFile</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        JNIEnv *env, jobject thiz, jstring path,</span></span></span><br><span class="line"><span class="params"><span class="function">        jstring mimeType, jobject client)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MediaScanner *mp = <span class="built_in">getNativeScanner_l</span>(env, thiz);</span><br><span class="line">    <span class="comment">//........</span></span><br><span class="line">    <span class="comment">//获取MimeType</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *mimeTypeStr = (mimeType ? env-&gt;<span class="built_in">GetStringUTFChars</span>(mimeType, <span class="literal">NULL</span>) : <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//...........</span></span><br><span class="line">    <span class="function">MyMediaScannerClient <span class="title">myClient</span><span class="params">(env, client)</span></span>;</span><br><span class="line">    <span class="comment">//调用StageFrightMediaScanner的processFile方法</span></span><br><span class="line">    MediaScanResult result = mp-&gt;<span class="built_in">processFile</span>(pathStr, mimeTypeStr, myClient);</span><br><span class="line">    <span class="comment">//..........</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们先来看下getNativeScanner_l：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">static MediaScanner *get<span class="constructor">NativeScanner_l(JNIEnv<span class="operator">*</span> <span class="params">env</span>, <span class="params">jobject</span> <span class="params">thiz</span>)</span> &#123;</span><br><span class="line">    return (MediaScanner *) env-&gt;<span class="constructor">GetLongField(<span class="params">thiz</span>, <span class="params">fields</span>.<span class="params">context</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它是将fields.context转换为MediaScanner，fields.context这个是怎么来的还记得吧：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">static void</span><br><span class="line">android<span class="constructor">_media_MediaScanner_native_setup(JNIEnv <span class="operator">*</span><span class="params">env</span>, <span class="params">jobject</span> <span class="params">thiz</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="constructor">ALOGV(<span class="string">&quot;native_setup&quot;</span>)</span>;</span><br><span class="line">    MediaScanner *mp = <span class="keyword">new</span> StagefrightMediaScanner;</span><br><span class="line">    <span class="comment">//..............</span></span><br><span class="line">    env-&gt;<span class="constructor">SetLongField(<span class="params">thiz</span>, <span class="params">fields</span>.<span class="params">context</span>, (<span class="params">jlong</span>)</span>mp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以这里的getNativeScanner_l返回的是StagefrightMediaScanner<br>而在StagefrightMediaScanner的processFile方法中则直接调用MediaScannerClient类中的beginFile以及endFile方法还有StagefrightMediaScanner 的processFileInternal方法。</p>
<figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line">MediaScanResult StagefrightMediaScanner::processFile(</span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">char</span> *path, <span class="keyword">const</span> <span class="built_in">char</span> *mimeType,</span><br><span class="line">        MediaScannerClient &amp;<span class="keyword">client</span>) &#123;</span><br><span class="line">    ALOGV(<span class="string">&quot;processFile &#x27;%s&#x27;.&quot;</span>, path);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">client</span>.setLocale(locale());</span><br><span class="line">    <span class="comment">//client = MyMediaScannerClient</span></span><br><span class="line">    <span class="keyword">client</span>.beginFile();</span><br><span class="line">    MediaScanResult result = processFileInternal(path, mimeType, <span class="keyword">client</span>);</span><br><span class="line">    <span class="keyword">client</span>.endFile();</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们先来看下MyMediaScannerClient::beginFile</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> FileEntry <span class="title function_">beginFile</span><span class="params">(String path, String mimeType, <span class="type">long</span> lastModified,</span></span><br><span class="line"><span class="params">        <span class="type">long</span> fileSize, <span class="type">boolean</span> isDirectory, <span class="type">boolean</span> noMedia)</span> &#123;</span><br><span class="line">    mMimeType = mimeType;</span><br><span class="line">    mFileType = <span class="number">0</span>;</span><br><span class="line">    mFileSize = fileSize;</span><br><span class="line">    mIsDrm = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isDirectory) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!noMedia &amp;&amp; isNoMediaFile(path)) &#123;</span><br><span class="line">            noMedia = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mNoMedia = noMedia;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// try mimeType first, if it is specified</span></span><br><span class="line">        <span class="keyword">if</span> (mimeType != <span class="literal">null</span>) &#123;</span><br><span class="line">            mFileType = MediaFile.getFileTypeForMimeType(mimeType);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// if mimeType was not specified, compute file type based on file extension.</span></span><br><span class="line">        <span class="keyword">if</span> (mFileType == <span class="number">0</span>) &#123;</span><br><span class="line">            MediaFile.<span class="type">MediaFileType</span> <span class="variable">mediaFileType</span> <span class="operator">=</span> MediaFile.getFileType(path);</span><br><span class="line">            <span class="keyword">if</span> (mediaFileType != <span class="literal">null</span>) &#123;</span><br><span class="line">                mFileType = mediaFileType.fileType;</span><br><span class="line">                <span class="keyword">if</span> (mMimeType == <span class="literal">null</span>) &#123;</span><br><span class="line">                    mMimeType = mediaFileType.mimeType;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isDrmEnabled() &amp;&amp; MediaFile.isDrmFileType(mFileType)) &#123;</span><br><span class="line">            mFileType = getFileTypeFromDrm(path);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">FileEntry</span> <span class="variable">entry</span> <span class="operator">=</span> makeEntryFor(path);</span><br><span class="line">    <span class="comment">// add some slack to avoid a rounding error</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">delta</span> <span class="operator">=</span> (entry != <span class="literal">null</span>) ? (lastModified - entry.mLastModified) : <span class="number">0</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">wasModified</span> <span class="operator">=</span> delta &gt; <span class="number">1</span> || delta &lt; -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (entry == <span class="literal">null</span> || wasModified) &#123;</span><br><span class="line">        <span class="keyword">if</span> (wasModified) &#123;</span><br><span class="line">            entry.mLastModified = lastModified;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            entry = <span class="keyword">new</span> <span class="title class_">FileEntry</span>(<span class="number">0</span>, path, lastModified,</span><br><span class="line">                    (isDirectory ? MtpConstants.FORMAT_ASSOCIATION : <span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        entry.mLastModifiedChanged = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mProcessPlaylists &amp;&amp; MediaFile.isPlayListFileType(mFileType)) &#123;</span><br><span class="line">        mPlayLists.add(entry);</span><br><span class="line">        <span class="comment">// we don&#x27;t process playlists in the main scan, so return null</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// clear all the metadata</span></span><br><span class="line">    mArtist = <span class="literal">null</span>;</span><br><span class="line">    mAlbumArtist = <span class="literal">null</span>;</span><br><span class="line">    mAlbum = <span class="literal">null</span>;</span><br><span class="line">    mTitle = <span class="literal">null</span>;</span><br><span class="line">    mComposer = <span class="literal">null</span>;</span><br><span class="line">    mGenre = <span class="literal">null</span>;</span><br><span class="line">    mTrack = <span class="number">0</span>;</span><br><span class="line">    mYear = <span class="number">0</span>;</span><br><span class="line">    mDuration = <span class="number">0</span>;</span><br><span class="line">    mPath = path;</span><br><span class="line">    mLastModified = lastModified;</span><br><span class="line">    mWriter = <span class="literal">null</span>;</span><br><span class="line">    mCompilation = <span class="number">0</span>;</span><br><span class="line">    mWidth = <span class="number">0</span>;</span><br><span class="line">    mHeight = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> entry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从processFileInternal方法开始就开始获取音频视频内部的数据了，在processFileInternal中对文件的处理分如下几个部分：</p>
<ul>
<li>获取当前音频视频文件的扩展名，看是否是平台所支持的文件类型，如果为空或者不支持就返回MEDIA_SCAN_RESULT_SKIPPED。</li>
<li>根据文件扩展名判断当前扫描的文件是否是DRM文件，如果是的话则开始获取DRM的信息。DRM信息是通过调用drmManagerClient-&gt;getMetadata(&amp;tmp)方法来获取的，获取到的信息封装在DrmMetadata对象中。这部分将放在今后的DRM部分介绍。</li>
<li>获取音频视频的TAG信息：<br>这部分最重要的是如下两个方法：<br>StagefrightMetadataRetriever ::setDataSource<br>StagefrightMetadataRetriever ::extractMetadata</li>
</ul>
<p>这部分代码是比较重要的所以我们将对下面的方法进行详细介绍：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">MediaScanResult <span class="title">StagefrightMediaScanner::processFileInternal</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> * <span class="comment">/* mimeType */</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        MediaScannerClient &amp;client)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断当前文件是否有扩展名</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *extension = <span class="built_in">strrchr</span>(path, <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!extension) &#123;</span><br><span class="line">        <span class="keyword">return</span> MEDIA_SCAN_RESULT_SKIPPED;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断当前扩展名十分支持</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">FileHasAcceptableExtension</span>(extension)) &#123;</span><br><span class="line">        <span class="keyword">return</span> MEDIA_SCAN_RESULT_SKIPPED;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建媒体抽取器</span></span><br><span class="line">    <span class="function">sp&lt;MediaMetadataRetriever&gt; <span class="title">mRetriever</span><span class="params">(<span class="keyword">new</span> MediaMetadataRetriever)</span></span>;</span><br><span class="line">    <span class="comment">//打开文件</span></span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">open</span>(path, O_RDONLY | O_LARGEFILE);</span><br><span class="line">    <span class="type">status_t</span> status;</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// couldn&#x27;t open it locally, maybe the media server can?</span></span><br><span class="line">        <span class="comment">//打不开尝试从网络上获取</span></span><br><span class="line">        status = mRetriever-&gt;<span class="built_in">setDataSource</span>(<span class="literal">NULL</span> <span class="comment">/* httpService */</span>, path);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//设置数据源</span></span><br><span class="line">        status = mRetriever-&gt;<span class="built_in">setDataSource</span>(fd, <span class="number">0</span>, <span class="number">0x7ffffffffffffff</span>L);</span><br><span class="line">        <span class="built_in">close</span>(fd);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//抽取媒体头数据</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *value;</span><br><span class="line">    <span class="keyword">if</span> ((value = mRetriever-&gt;<span class="built_in">extractMetadata</span>(METADATA_KEY_MIMETYPE)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        status = client.<span class="built_in">setMimeType</span>(value);</span><br><span class="line">        <span class="keyword">if</span> (status) &#123;</span><br><span class="line">            <span class="keyword">return</span> MEDIA_SCAN_RESULT_ERROR;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">KeyMap</span> &#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *tag;</span><br><span class="line">        <span class="type">int</span> key;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> KeyMap kKeyMap[] = &#123;</span><br><span class="line">        &#123; <span class="string">&quot;tracknumber&quot;</span>, METADATA_KEY_CD_TRACK_NUMBER &#125;,</span><br><span class="line">        &#123; <span class="string">&quot;discnumber&quot;</span>, METADATA_KEY_DISC_NUMBER &#125;,</span><br><span class="line">        &#123; <span class="string">&quot;album&quot;</span>, METADATA_KEY_ALBUM &#125;,</span><br><span class="line">        &#123; <span class="string">&quot;artist&quot;</span>, METADATA_KEY_ARTIST &#125;,</span><br><span class="line">        &#123; <span class="string">&quot;albumartist&quot;</span>, METADATA_KEY_ALBUMARTIST &#125;,</span><br><span class="line">        &#123; <span class="string">&quot;composer&quot;</span>, METADATA_KEY_COMPOSER &#125;,</span><br><span class="line">        &#123; <span class="string">&quot;genre&quot;</span>, METADATA_KEY_GENRE &#125;,</span><br><span class="line">        &#123; <span class="string">&quot;title&quot;</span>, METADATA_KEY_TITLE &#125;,</span><br><span class="line">        &#123; <span class="string">&quot;year&quot;</span>, METADATA_KEY_YEAR &#125;,</span><br><span class="line">        &#123; <span class="string">&quot;duration&quot;</span>, METADATA_KEY_DURATION &#125;,</span><br><span class="line">        &#123; <span class="string">&quot;writer&quot;</span>, METADATA_KEY_WRITER &#125;,</span><br><span class="line">        &#123; <span class="string">&quot;compilation&quot;</span>, METADATA_KEY_COMPILATION &#125;,</span><br><span class="line">        &#123; <span class="string">&quot;isdrm&quot;</span>, METADATA_KEY_IS_DRM &#125;,</span><br><span class="line">        &#123; <span class="string">&quot;width&quot;</span>, METADATA_KEY_VIDEO_WIDTH &#125;,</span><br><span class="line">        &#123; <span class="string">&quot;height&quot;</span>, METADATA_KEY_VIDEO_HEIGHT &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">size_t</span> kNumEntries = <span class="built_in">sizeof</span>(kKeyMap) / <span class="built_in">sizeof</span>(kKeyMap[<span class="number">0</span>]);</span><br><span class="line">    <span class="comment">//按照kKeyMap表格的顺序从媒体文件中获取TAG并添加到client中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; kNumEntries; ++i) &#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *value;</span><br><span class="line">        <span class="keyword">if</span> ((value = mRetriever-&gt;<span class="built_in">extractMetadata</span>(kKeyMap[i].key)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            status = client.<span class="built_in">addStringTag</span>(kKeyMap[i].tag, value);</span><br><span class="line">            <span class="keyword">if</span> (status != OK) &#123;</span><br><span class="line">                <span class="keyword">return</span> MEDIA_SCAN_RESULT_ERROR;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> MEDIA_SCAN_RESULT_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们先来看下能够支持的媒体格式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">FileHasAcceptableExtension</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *extension)</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">char</span> *kValidExtensions[] = &#123;</span><br><span class="line">        <span class="string">&quot;.mp3&quot;</span>, <span class="string">&quot;.mp4&quot;</span>, <span class="string">&quot;.m4a&quot;</span>, <span class="string">&quot;.3gp&quot;</span>, <span class="string">&quot;.3gpp&quot;</span>, <span class="string">&quot;.3g2&quot;</span>, <span class="string">&quot;.3gpp2&quot;</span>,</span><br><span class="line">        <span class="string">&quot;.mpeg&quot;</span>, <span class="string">&quot;.ogg&quot;</span>, <span class="string">&quot;.mid&quot;</span>, <span class="string">&quot;.smf&quot;</span>, <span class="string">&quot;.imy&quot;</span>, <span class="string">&quot;.wma&quot;</span>, <span class="string">&quot;.aac&quot;</span>,</span><br><span class="line">        <span class="string">&quot;.wav&quot;</span>, <span class="string">&quot;.amr&quot;</span>, <span class="string">&quot;.midi&quot;</span>, <span class="string">&quot;.xmf&quot;</span>, <span class="string">&quot;.rtttl&quot;</span>, <span class="string">&quot;.rtx&quot;</span>, <span class="string">&quot;.ota&quot;</span>,</span><br><span class="line">        <span class="string">&quot;.mkv&quot;</span>, <span class="string">&quot;.mka&quot;</span>, <span class="string">&quot;.webm&quot;</span>, <span class="string">&quot;.ts&quot;</span>, <span class="string">&quot;.fl&quot;</span>, <span class="string">&quot;.flac&quot;</span>, <span class="string">&quot;.mxmf&quot;</span>,</span><br><span class="line">        <span class="string">&quot;.avi&quot;</span>, <span class="string">&quot;.mpeg&quot;</span>, <span class="string">&quot;.mpg&quot;</span>, <span class="string">&quot;.awb&quot;</span>, <span class="string">&quot;.mpga&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">size_t</span> kNumValidExtensions =</span><br><span class="line">        <span class="built_in">sizeof</span>(kValidExtensions) / <span class="built_in">sizeof</span>(kValidExtensions[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; kNumValidExtensions; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcasecmp</span>(extension, kValidExtensions[i])) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看下setDataSource，它首先会创建一个FileSource。</p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="function"><span class="keyword">void</span> <span class="title">setDataSource</span><span class="params">(FileDescriptor fd, <span class="keyword">long</span> offset, <span class="keyword">long</span> length)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IllegalArgumentException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在setDataSource中我们创建一个FileSource并将其传递到MediaExtractor::Create中根据FileSource来创建出合适的MediaExtractor</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">status_t StagefrightMetadataRetriever::set<span class="constructor">DataSource(<span class="params">int</span> <span class="params">fd</span>, <span class="params">int64_t</span> <span class="params">offset</span>, <span class="params">int64_t</span> <span class="params">length</span>)</span> &#123;</span><br><span class="line">    fd = dup(fd);</span><br><span class="line">    <span class="constructor">ALOGV(<span class="string">&quot;setDataSource(%d, %&quot;</span> PRId64 <span class="string">&quot;, %&quot;</span> PRId64 <span class="string">&quot;)&quot;</span>, <span class="params">fd</span>, <span class="params">offset</span>, <span class="params">length</span>)</span>;</span><br><span class="line">    clear<span class="constructor">Metadata()</span>;</span><br><span class="line">    mSource = <span class="keyword">new</span> <span class="constructor">FileSource(<span class="params">fd</span>, <span class="params">offset</span>, <span class="params">length</span>)</span>;</span><br><span class="line">    status_t err;</span><br><span class="line">    <span class="comment">//检查是否打开文件成功</span></span><br><span class="line">    <span class="keyword">if</span> ((err = mSource-&gt;init<span class="constructor">Check()</span>) != OK) &#123;</span><br><span class="line">        mSource.clear<span class="literal">()</span>;</span><br><span class="line">        return err;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将FileSource传入后根据FileSource的信息创建出合适的MediaExtractor</span></span><br><span class="line">    mExtractor = MediaExtractor::<span class="constructor">Create(<span class="params">mSource</span>)</span>;</span><br><span class="line">    <span class="keyword">if</span> (mExtractor<span class="operator"> == </span>NULL) &#123;</span><br><span class="line">        mSource.clear<span class="literal">()</span>;</span><br><span class="line">        return UNKNOWN_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们接下来看下是如何创建对应的MediaExtractor的，首先会先调用DataSource的sniff，在DataSource的sniff中会调用每个注册的Sniffers对其进行探测，来选出最匹配的。以mimetype形式返回。根据返回的mimetype创建MediaExtractor</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// static</span></span><br><span class="line">sp&lt;MediaExtractor&gt; <span class="title class_">MediaExtractor</span>::<span class="title function_ invoke__">Create</span>(<span class="keyword">const</span> sp&lt;DataSource&gt; &amp;source, <span class="keyword">const</span> char *mime) &#123;</span><br><span class="line">    sp&lt;AMessage&gt; meta;</span><br><span class="line">    String8 tmp;</span><br><span class="line">    <span class="keyword">if</span> (mime == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> confidence;</span><br><span class="line">        <span class="comment">//首先我们会调用DataSource的sniff</span></span><br><span class="line">        <span class="keyword">if</span> (!source-&gt;<span class="title function_ invoke__">sniff</span>(&amp;tmp, &amp;confidence, &amp;meta)) &#123;</span><br><span class="line">            <span class="title function_ invoke__">ALOGV</span>(<span class="string">&quot;FAILED to autodetect media content.&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mime = tmp.<span class="keyword">string</span>();</span><br><span class="line">        <span class="title function_ invoke__">ALOGV</span>(<span class="string">&quot;Autodetected media content as &#x27;%s&#x27; with confidence %.2f&quot;</span>,</span><br><span class="line">             mime, confidence);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> isDrm = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// DRM MIME type syntax is &quot;drm+type+original&quot; where</span></span><br><span class="line">    <span class="comment">// type is &quot;es_based&quot; or &quot;container_based&quot; and</span></span><br><span class="line">    <span class="comment">// original is the content&#x27;s cleartext MIME type</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="title function_ invoke__">strncmp</span>(mime, <span class="string">&quot;drm+&quot;</span>, <span class="number">4</span>)) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="variable constant_">char</span> *originalMime = <span class="title function_ invoke__">strchr</span>(mime+<span class="number">4</span>, <span class="string">&#x27;+&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (originalMime == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// second + not found</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ++originalMime;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="title function_ invoke__">strncmp</span>(mime, <span class="string">&quot;drm+es_based+&quot;</span>, <span class="number">13</span>)) &#123;</span><br><span class="line">            <span class="comment">// DRMExtractor sets container metadata kKeyIsDRM to 1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DRMExtractor</span>(source, originalMime);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="title function_ invoke__">strncmp</span>(mime, <span class="string">&quot;drm+container_based+&quot;</span>, <span class="number">20</span>)) &#123;</span><br><span class="line">            mime = originalMime;</span><br><span class="line">            isDrm = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MediaExtractor *ret = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="title function_ invoke__">strcasecmp</span>(mime, MEDIA_MIMETYPE_CONTAINER_MPEG4)</span><br><span class="line">            || !<span class="title function_ invoke__">strcasecmp</span>(mime, <span class="string">&quot;audio/mp4&quot;</span>)) &#123;</span><br><span class="line">        ret = <span class="keyword">new</span> <span class="title class_">MPEG4Extractor</span>(source);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="title function_ invoke__">strcasecmp</span>(mime, MEDIA_MIMETYPE_AUDIO_MPEG)) &#123;</span><br><span class="line">        ret = <span class="keyword">new</span> <span class="title class_">MP3Extractor</span>(source, meta);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="title function_ invoke__">strcasecmp</span>(mime, MEDIA_MIMETYPE_AUDIO_AMR_NB)</span><br><span class="line">            || !<span class="title function_ invoke__">strcasecmp</span>(mime, MEDIA_MIMETYPE_AUDIO_AMR_WB)) &#123;</span><br><span class="line">        ret = <span class="keyword">new</span> <span class="title class_">AMRExtractor</span>(source);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="title function_ invoke__">strcasecmp</span>(mime, MEDIA_MIMETYPE_AUDIO_FLAC)) &#123;</span><br><span class="line">        ret = <span class="keyword">new</span> <span class="title class_">FLACExtractor</span>(source);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="title function_ invoke__">strcasecmp</span>(mime, MEDIA_MIMETYPE_CONTAINER_WAV)) &#123;</span><br><span class="line">        ret = <span class="keyword">new</span> <span class="title class_">WAVExtractor</span>(source);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="title function_ invoke__">strcasecmp</span>(mime, MEDIA_MIMETYPE_CONTAINER_OGG)) &#123;</span><br><span class="line">        ret = <span class="keyword">new</span> <span class="title class_">OggExtractor</span>(source);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="title function_ invoke__">strcasecmp</span>(mime, MEDIA_MIMETYPE_CONTAINER_MATROSKA)) &#123;</span><br><span class="line">        ret = <span class="keyword">new</span> <span class="title class_">MatroskaExtractor</span>(source);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="title function_ invoke__">strcasecmp</span>(mime, MEDIA_MIMETYPE_CONTAINER_MPEG2TS)) &#123;</span><br><span class="line">        ret = <span class="keyword">new</span> <span class="title class_">MPEG2TSExtractor</span>(source);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="title function_ invoke__">strcasecmp</span>(mime, MEDIA_MIMETYPE_CONTAINER_WVM)) &#123;</span><br><span class="line">        <span class="comment">// Return now.  WVExtractor should not have the DrmFlag set in the block below.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WVMExtractor</span>(source);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="title function_ invoke__">strcasecmp</span>(mime, MEDIA_MIMETYPE_AUDIO_AAC_ADTS)) &#123;</span><br><span class="line">        ret = <span class="keyword">new</span> <span class="title class_">AACExtractor</span>(source, meta);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="title function_ invoke__">strcasecmp</span>(mime, MEDIA_MIMETYPE_CONTAINER_MPEG2PS)) &#123;</span><br><span class="line">        ret = <span class="keyword">new</span> <span class="title class_">MPEG2PSExtractor</span>(source);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="title function_ invoke__">strcasecmp</span>(mime, MEDIA_MIMETYPE_AUDIO_MIDI)) &#123;</span><br><span class="line">        ret = <span class="keyword">new</span> <span class="title class_">MidiExtractor</span>(source);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="literal">NULL</span>) &#123;</span><br><span class="line">       <span class="keyword">if</span> (isDrm) &#123;</span><br><span class="line">           ret-&gt;<span class="title function_ invoke__">setDrmFlag</span>(<span class="literal">true</span>);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           ret-&gt;<span class="title function_ invoke__">setDrmFlag</span>(<span class="literal">false</span>);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是sniff方法。</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">bool DataSource:<span class="type"></span>:sniff(String8 *mimeType, float *confidence, sp&lt;AMessage&gt; *meta) &#123;</span><br><span class="line">    *mimeType = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    *confidence = <span class="number">0.0</span>f;</span><br><span class="line">    meta-&gt;clear();</span><br><span class="line">    &#123;</span><br><span class="line">        Mutex:<span class="type"></span>:Autolock autoLock(gSnifferMutex);</span><br><span class="line">        <span class="keyword">if</span> (!gSniffersRegistered) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (List&lt;SnifferFunc&gt;:<span class="type"></span>:iterator it = gSniffers.begin();</span><br><span class="line">         it != gSniffers.end(); ++it) &#123;</span><br><span class="line">        String8 <span class="keyword">new</span><span class="type">MimeType</span>;</span><br><span class="line">        float <span class="keyword">new</span><span class="type">Confidence</span>;</span><br><span class="line">        sp&lt;AMessage&gt; <span class="keyword">new</span><span class="type">Meta</span>;</span><br><span class="line">        <span class="comment">//调用各种嗅探器的方法获取类型和可信度</span></span><br><span class="line">        <span class="keyword">if</span> ((*it)(<span class="built_in">this</span>, &amp;<span class="keyword">new</span><span class="type">MimeType</span>, &amp;<span class="keyword">new</span><span class="type">Confidence</span>, &amp;<span class="keyword">new</span><span class="type">Meta</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">new</span><span class="type">Confidence</span> &gt; *confidence) &#123;</span><br><span class="line">                *mimeType = <span class="keyword">new</span><span class="type">MimeType</span>;</span><br><span class="line">                *confidence = <span class="keyword">new</span><span class="type">Confidence</span>;</span><br><span class="line">                *meta = <span class="keyword">new</span><span class="type">Meta</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *confidence &gt; <span class="number">0.0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这些sniff是在StagefrightMetadataRetriever创建的时候注册的：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">StagefrightMetadataRetriever::<span class="constructor">StagefrightMetadataRetriever()</span></span><br><span class="line">    : m<span class="constructor">ParsedMetaData(<span class="params">false</span>)</span>,</span><br><span class="line">      m<span class="constructor">AlbumArt(NULL)</span> &#123;</span><br><span class="line">    <span class="comment">//注册默认的音频格式嗅探器</span></span><br><span class="line">    DataSource::<span class="constructor">RegisterDefaultSniffers()</span>;</span><br><span class="line">    <span class="constructor">CHECK_EQ(<span class="params">mClient</span>.<span class="params">connect</span>()</span>, (status_t)OK);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>下面是注册的sniff</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">//static</span></span><br><span class="line">void DataSource::<span class="constructor">RegisterDefaultSniffers()</span> &#123;</span><br><span class="line">    Mutex::Autolock auto<span class="constructor">Lock(<span class="params">gSnifferMutex</span>)</span>;</span><br><span class="line">    <span class="keyword">if</span> (gSniffersRegistered) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="constructor">RegisterSniffer_l(SniffMPEG4)</span>;</span><br><span class="line">    <span class="constructor">RegisterSniffer_l(SniffMatroska)</span>;</span><br><span class="line">    <span class="constructor">RegisterSniffer_l(SniffOgg)</span>;</span><br><span class="line">    <span class="constructor">RegisterSniffer_l(SniffWAV)</span>;</span><br><span class="line">    <span class="constructor">RegisterSniffer_l(SniffFLAC)</span>;</span><br><span class="line">    <span class="constructor">RegisterSniffer_l(SniffAMR)</span>;</span><br><span class="line">    <span class="constructor">RegisterSniffer_l(SniffMPEG2TS)</span>;</span><br><span class="line">    <span class="constructor">RegisterSniffer_l(SniffMP3)</span>;</span><br><span class="line">    <span class="constructor">RegisterSniffer_l(SniffAAC)</span>;</span><br><span class="line">    <span class="constructor">RegisterSniffer_l(SniffMPEG2PS)</span>;</span><br><span class="line">    <span class="constructor">RegisterSniffer_l(SniffWVM)</span>;</span><br><span class="line">    <span class="constructor">RegisterSniffer_l(SniffMidi)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">char</span> value<span class="literal">[PROPERTY<span class="identifier">_VALUE_MAX</span>]</span>;</span><br><span class="line">    <span class="keyword">if</span> (property<span class="constructor">_get(<span class="string">&quot;drm.service.enabled&quot;</span>, <span class="params">value</span>, NULL)</span><span class="operator"></span></span><br><span class="line"><span class="operator">            &amp;&amp; </span>(!strcmp(value, <span class="string">&quot;1&quot;</span>)<span class="operator"> || </span>!strcasecmp(value, <span class="string">&quot;true&quot;</span>))) &#123;</span><br><span class="line">        <span class="constructor">RegisterSniffer_l(SniffDRM)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    gSniffersRegistered = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么sniff又是怎样完成文件类型判断的任务的呢？我们看到上面的RegisterDefaultSniffers我们以MP3为例子，那么使用的sniff为SniffMP3<br>这里我们只关注MP3的sniff–SniffMP3。SniffMP3首先会调用Resync方法对音乐内容帧的帧头进行重新重定位，它会在音乐内容帧内对帧头进行搜索：每次读入1024字节的内容到待检测缓冲区，再从缓冲区中每次读取4个字节32位进行匹配，如果找到匹配的话还会读入后续的连续3个帧的帧头数据进行检测。如果4次检测均成功的话将当前位置作为音乐内容帧的起始位置返回，检测过程是通过GetMPEGAudioFrameSize方法来完成的，如果当前待检测缓冲区内数据没有匹配的则再次读入数据到缓冲区直到检测的位置达到最大检测字节数128*1024字节为止。</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">bool SniffMP3(<span class="keyword">const</span> sp&lt;DataSource&gt; &amp;source, String8 *mimeType,</span><br><span class="line">        float *confidence, sp&lt;AMessage&gt; *meta) &#123;</span><br><span class="line">    off64_t pos = <span class="number">0</span>;</span><br><span class="line">    off64_t post_id3_pos;</span><br><span class="line">    uint32_t header;</span><br><span class="line">    <span class="keyword">if</span> (!Resync(source, <span class="number">0</span>, &amp;pos, &amp;post_id3_pos, &amp;header)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *meta = <span class="keyword">new</span> AMessage;</span><br><span class="line">    <span class="function"><span class="params">(*meta)</span>-&gt;</span>setInt64(<span class="string">&quot;offset&quot;</span>, pos);</span><br><span class="line">    <span class="function"><span class="params">(*meta)</span>-&gt;</span>setInt32(<span class="string">&quot;header&quot;</span>, header);</span><br><span class="line">    <span class="function"><span class="params">(*meta)</span>-&gt;</span>setInt64(<span class="string">&quot;post-id3-offset&quot;</span>, post_id3_pos);</span><br><span class="line"></span><br><span class="line">    *mimeType = MEDIA_MIMETYPE_AUDIO_MPEG;</span><br><span class="line">    *confidence = <span class="number">0.2f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">Resync</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> sp&lt;DataSource&gt; &amp;source, <span class="type">uint32_t</span> match_header,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">off64_t</span> *inout_pos, <span class="type">off64_t</span> *post_id3_pos, <span class="type">uint32_t</span> *out_header)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (post_id3_pos != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        *post_id3_pos = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//跳过标题帧的位置开始同步。</span></span><br><span class="line">    <span class="keyword">if</span> (*inout_pos == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Skip an optional ID3 header if syncing at the very beginning</span></span><br><span class="line">        <span class="comment">// of the datasource.</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="type">uint8_t</span> id3header[<span class="number">10</span>];</span><br><span class="line">            <span class="comment">//读取头10个字节，如果不够10个字节表示存在错误返回false</span></span><br><span class="line">            <span class="keyword">if</span> (source-&gt;<span class="built_in">readAt</span>(*inout_pos, id3header, <span class="built_in">sizeof</span>(id3header))</span><br><span class="line">                    &lt; (<span class="type">ssize_t</span>)<span class="built_in">sizeof</span>(id3header)) &#123;</span><br><span class="line">                <span class="comment">// If we can&#x27;t even read these 10 bytes, we might as well bail</span></span><br><span class="line">                <span class="comment">// out, even if there _were_ 10 bytes of valid mp3 audio data...</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果头3个字节不是ID3退出该循环</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">memcmp</span>(<span class="string">&quot;ID3&quot;</span>, id3header, <span class="number">3</span>)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Skip the ID3v2 header.</span></span><br><span class="line">            <span class="comment">// 获取标签帧的长度</span></span><br><span class="line">            <span class="type">size_t</span> len =</span><br><span class="line">                ((id3header[<span class="number">6</span>] &amp; <span class="number">0x7f</span>) &lt;&lt; <span class="number">21</span>)</span><br><span class="line">                | ((id3header[<span class="number">7</span>] &amp; <span class="number">0x7f</span>) &lt;&lt; <span class="number">14</span>)</span><br><span class="line">                | ((id3header[<span class="number">8</span>] &amp; <span class="number">0x7f</span>) &lt;&lt; <span class="number">7</span>)</span><br><span class="line">                | (id3header[<span class="number">9</span>] &amp; <span class="number">0x7f</span>);</span><br><span class="line"></span><br><span class="line">            len += <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">            *inout_pos += len; <span class="comment">// inout_pos 指向音乐内容区的首地址</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">ALOGV</span>(<span class="string">&quot;skipped ID3 tag, new starting offset is %lld (0x%016llx)&quot;</span>,</span><br><span class="line">                    (<span class="type">long</span> <span class="type">long</span>)*inout_pos, (<span class="type">long</span> <span class="type">long</span>)*inout_pos);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (post_id3_pos != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            *post_id3_pos = *inout_pos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">off64_t</span> pos = *inout_pos;</span><br><span class="line">    <span class="type">bool</span> valid = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> kMaxReadBytes = <span class="number">1024</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> kMaxBytesChecked = <span class="number">128</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="type">uint8_t</span> buf[kMaxReadBytes];</span><br><span class="line">    <span class="type">ssize_t</span> bytesToRead = kMaxReadBytes;</span><br><span class="line">    <span class="type">ssize_t</span> totalBytesRead = <span class="number">0</span>;</span><br><span class="line">    <span class="type">ssize_t</span> remainingBytes = <span class="number">0</span>;</span><br><span class="line">    <span class="type">bool</span> reachEOS = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">uint8_t</span> *tmp = buf;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">//如果当前的扫描位置超过音乐内容区的kMaxBytesChecked（128K）就停止扫描</span></span><br><span class="line">        <span class="keyword">if</span> (pos &gt;= (<span class="type">off64_t</span>)(*inout_pos + kMaxBytesChecked)) &#123;</span><br><span class="line">            <span class="comment">// Don&#x27;t scan forever.</span></span><br><span class="line">            <span class="built_in">ALOGV</span>(<span class="string">&quot;giving up at offset %lld&quot;</span>, (<span class="type">long</span> <span class="type">long</span>)pos);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//加载一个缓冲区的内容。</span></span><br><span class="line">        <span class="keyword">if</span> (remainingBytes &lt; <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (reachEOS) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">memcpy</span>(buf, tmp, remainingBytes);</span><br><span class="line">                bytesToRead = kMaxReadBytes - remainingBytes;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * The next read position should start from the end of</span></span><br><span class="line"><span class="comment">                 * the last buffer, and thus should include the remaining</span></span><br><span class="line"><span class="comment">                 * bytes in the buffer.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                totalBytesRead = source-&gt;<span class="built_in">readAt</span>(pos + remainingBytes,</span><br><span class="line">                                                buf + remainingBytes,</span><br><span class="line">                                                bytesToRead);</span><br><span class="line">                <span class="keyword">if</span> (totalBytesRead &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                reachEOS = (totalBytesRead != bytesToRead);</span><br><span class="line">                totalBytesRead += remainingBytes;</span><br><span class="line">                remainingBytes = totalBytesRead;</span><br><span class="line">                tmp = buf;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从tmp缓冲区中取出头</span></span><br><span class="line">        <span class="type">uint32_t</span> header = <span class="built_in">U32_AT</span>(tmp);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (match_header != <span class="number">0</span> &amp;&amp; (header &amp; kMask) != (match_header &amp; kMask)) &#123;</span><br><span class="line">            <span class="comment">//如果帧的格式校验失败则从当前其实位置下一个位置开始获取32字节</span></span><br><span class="line">            ++pos;</span><br><span class="line">            ++tmp;</span><br><span class="line">            --remainingBytes;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">size_t</span> frame_size;</span><br><span class="line">        <span class="type">int</span> sample_rate, num_channels, bitrate;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">GetMPEGAudioFrameSize</span>(</span><br><span class="line">                    header, &amp;frame_size,</span><br><span class="line">                    &amp;sample_rate, &amp;num_channels, &amp;bitrate)) &#123;</span><br><span class="line">            ++pos;</span><br><span class="line">            ++tmp;</span><br><span class="line">            --remainingBytes;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">ALOGV</span>(<span class="string">&quot;found possible 1st frame at %lld (header = 0x%08x)&quot;</span>, (<span class="type">long</span> <span class="type">long</span>)pos, header);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We found what looks like a valid frame,</span></span><br><span class="line">        <span class="comment">// now find its successors.</span></span><br><span class="line"></span><br><span class="line">        <span class="type">off64_t</span> test_pos = pos + frame_size;</span><br><span class="line"></span><br><span class="line">        valid = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//再连续读取3三个音乐内容区的帧头进行检查，如果都正确就退出检测，将找到的音乐内容区域的位置以及音乐内容帧的帧头返回。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; ++j) &#123;</span><br><span class="line">            <span class="type">uint8_t</span> tmp[<span class="number">4</span>];</span><br><span class="line">            <span class="keyword">if</span> (source-&gt;<span class="built_in">readAt</span>(test_pos, tmp, <span class="number">4</span>) &lt; <span class="number">4</span>) &#123;</span><br><span class="line">                valid = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">uint32_t</span> test_header = <span class="built_in">U32_AT</span>(tmp);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">ALOGV</span>(<span class="string">&quot;subsequent header is %08x&quot;</span>, test_header);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((test_header &amp; kMask) != (header &amp; kMask)) &#123;</span><br><span class="line">                valid = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">size_t</span> test_frame_size;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">GetMPEGAudioFrameSize</span>(</span><br><span class="line">                        test_header, &amp;test_frame_size)) &#123;</span><br><span class="line">                valid = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">ALOGV</span>(<span class="string">&quot;found subsequent frame #%d at %lld&quot;</span>, j + <span class="number">2</span>, (<span class="type">long</span> <span class="type">long</span>)test_pos);</span><br><span class="line"></span><br><span class="line">            test_pos += test_frame_size;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (valid) &#123;</span><br><span class="line">            *inout_pos = pos;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (out_header != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                *out_header = header;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">ALOGV</span>(<span class="string">&quot;no dice, no valid sequence of frames found.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ++pos;</span><br><span class="line">        ++tmp;</span><br><span class="line">        --remainingBytes;</span><br><span class="line">    &#125; <span class="keyword">while</span> (!valid);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> valid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在MediaExtractor::Create 方法中我们通过sniff来识别当前音频的文件类型，并根据返回的mimeType以及可行度来创建具体的Extractor ，我们这里以MP3文件为例，根据sniff判断后在MediaExtractor::Create中将会创建MP3Extractor对象，在MP3Extractor构造方法中，主要是从传入的header中获取采样频率，通道数，帧大小等数据，并将其存入MetaData对象中。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">MP3Extractor::<span class="built_in">MP3Extractor</span>(</span><br><span class="line">        <span class="type">const</span> sp&lt;DataSource&gt; &amp;source, <span class="type">const</span> sp&lt;AMessage&gt; &amp;meta)</span><br><span class="line">    : <span class="built_in">mInitCheck</span>(NO_INIT),</span><br><span class="line">      <span class="built_in">mDataSource</span>(source),</span><br><span class="line">      <span class="built_in">mFirstFramePos</span>(<span class="number">-1</span>),</span><br><span class="line">      <span class="built_in">mFixedHeader</span>(<span class="number">0</span>) &#123;</span><br><span class="line">    <span class="type">off64_t</span> pos = <span class="number">0</span>;</span><br><span class="line">    <span class="type">off64_t</span> post_id3_pos;</span><br><span class="line">    <span class="type">uint32_t</span> header;</span><br><span class="line">    <span class="type">bool</span> success;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//下面这些值在SniffMP3中已经获取了</span></span><br><span class="line">    <span class="type">int64_t</span> meta_offset;<span class="comment">/*表示帧数据的偏移*/</span></span><br><span class="line">    <span class="type">uint32_t</span> meta_header;<span class="comment">/*表示帧头*/</span></span><br><span class="line">    <span class="type">int64_t</span> meta_post_id3_offset;<span class="comment">/*表示TAB帧的偏移*/</span></span><br><span class="line">    <span class="keyword">if</span> (meta != <span class="literal">NULL</span>&amp;&amp; meta-&gt;<span class="built_in">findInt64</span>(<span class="string">&quot;offset&quot;</span>, &amp;meta_offset)</span><br><span class="line">            &amp;&amp; meta-&gt;<span class="built_in">findInt32</span>(<span class="string">&quot;header&quot;</span>, (<span class="type">int32_t</span> *)&amp;meta_header)</span><br><span class="line">            &amp;&amp; meta-&gt;<span class="built_in">findInt64</span>(<span class="string">&quot;post-id3-offset&quot;</span>, &amp;meta_post_id3_offset)) &#123;</span><br><span class="line">        <span class="comment">// The sniffer has already done all the hard work for us, simply</span></span><br><span class="line">        <span class="comment">// accept its judgement.</span></span><br><span class="line">        pos = (<span class="type">off64_t</span>)meta_offset;</span><br><span class="line">        header = meta_header;</span><br><span class="line">        post_id3_pos = (<span class="type">off64_t</span>)meta_post_id3_offset;</span><br><span class="line">        success = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mFirstFramePos = pos;</span><br><span class="line">    mFixedHeader = header;</span><br><span class="line">    mMeta = <span class="keyword">new</span> MetaData;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> frame_size;</span><br><span class="line">    <span class="type">int</span> sample_rate;</span><br><span class="line">    <span class="type">int</span> num_channels;</span><br><span class="line">    <span class="type">int</span> bitrate;</span><br><span class="line">    <span class="built_in">GetMPEGAudioFrameSize</span>(header, &amp;frame_size, &amp;sample_rate, &amp;num_channels, &amp;bitrate);</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> layer = <span class="number">4</span> - ((header &gt;&gt; <span class="number">17</span>) &amp; <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (layer) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            mMeta-&gt;<span class="built_in">setCString</span>(kKeyMIMEType, MEDIA_MIMETYPE_AUDIO_MPEG_LAYER_I);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            mMeta-&gt;<span class="built_in">setCString</span>(kKeyMIMEType, MEDIA_MIMETYPE_AUDIO_MPEG_LAYER_II);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            mMeta-&gt;<span class="built_in">setCString</span>(kKeyMIMEType, MEDIA_MIMETYPE_AUDIO_MPEG);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">TRESPASS</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mMeta-&gt;<span class="built_in">setInt32</span>(kKeySampleRate, sample_rate);</span><br><span class="line">    mMeta-&gt;<span class="built_in">setInt32</span>(kKeyBitRate, bitrate * <span class="number">1000</span>);</span><br><span class="line">    mMeta-&gt;<span class="built_in">setInt32</span>(kKeyChannelCount, num_channels);</span><br><span class="line"></span><br><span class="line">    <span class="type">int64_t</span> durationUs;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (durationUs &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        mMeta-&gt;<span class="built_in">setInt64</span>(kKeyDuration, durationUs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mInitCheck = OK;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get iTunes-style gapless info if present.</span></span><br><span class="line">    <span class="comment">// When getting the id3 tag, skip the V1 tags to prevent the source cache</span></span><br><span class="line">    <span class="comment">// from being iterated to the end of the file.</span></span><br><span class="line">    <span class="function">ID3 <span class="title">id3</span><span class="params">(mDataSource, <span class="literal">true</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (id3.<span class="built_in">isValid</span>()) &#123;</span><br><span class="line">        ID3::Iterator *com = <span class="keyword">new</span> ID3::<span class="built_in">Iterator</span>(id3, <span class="string">&quot;COM&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (com-&gt;<span class="built_in">done</span>()) &#123;</span><br><span class="line">            <span class="keyword">delete</span> com;</span><br><span class="line">            com = <span class="keyword">new</span> ID3::<span class="built_in">Iterator</span>(id3, <span class="string">&quot;COMM&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!com-&gt;<span class="built_in">done</span>()) &#123;</span><br><span class="line">            String8 commentdesc;</span><br><span class="line">            String8 commentvalue;</span><br><span class="line">            com-&gt;<span class="built_in">getString</span>(&amp;commentdesc, &amp;commentvalue);</span><br><span class="line">            <span class="type">const</span> <span class="type">char</span> * desc = commentdesc.<span class="built_in">string</span>();</span><br><span class="line">            <span class="type">const</span> <span class="type">char</span> * value = commentvalue.<span class="built_in">string</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// first 3 characters are the language, which we don&#x27;t care about</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">strlen</span>(desc) &gt; <span class="number">3</span> &amp;&amp; <span class="built_in">strcmp</span>(desc + <span class="number">3</span>, <span class="string">&quot;iTunSMPB&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">int32_t</span> delay, padding;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">sscanf</span>(value, <span class="string">&quot; %*x %x %x %*x&quot;</span>, &amp;delay, &amp;padding) == <span class="number">2</span>) &#123;</span><br><span class="line">                    mMeta-&gt;<span class="built_in">setInt32</span>(kKeyEncoderDelay, delay);</span><br><span class="line">                    mMeta-&gt;<span class="built_in">setInt32</span>(kKeyEncoderPadding, padding);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            com-&gt;<span class="built_in">next</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span> com;</span><br><span class="line">        com = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到目前为止我们已经识别出了当前扫描音频文件的格式类型，并从对应的音乐内容数据帧头部（HEAD）获取到了采样率，比特率等信息，但是我们还有一部分非常重要的信息需要获取，那就是标签帧的信息，在那里记录者歌曲作者，专辑名，歌曲名，甚至专辑封面图片和内嵌歌词等信息，下面部分我们就重点介绍这些信息的获取过程。<br>我们再次回到processFileInternal方法，Tags文件的获取是在mRetriever-&gt;extractMetadata(kKeyMap[i].key)中完成的，<br>在extractMetadata方法传入的参数为要寻找的那个Tag的key，如果当前尚未对帧标签帧进行解析则先调用parseMetaData方法对Tag标签进行解析，如果已经解析过了则这时候就使用传人到keyCode 到mMetaData中进行查找，并返回的需要查找到那个Tag的值.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span> *<span class="title">StagefrightMetadataRetriever::extractMetadata</span><span class="params">(<span class="type">int</span> keyCode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mExtractor == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//调用parseMetaData()解析标签帧</span></span><br><span class="line">    <span class="keyword">if</span> (!mParsedMetaData) &#123;</span><br><span class="line">        <span class="built_in">parseMetaData</span>();</span><br><span class="line">        mParsedMetaData = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ssize_t</span> index = mMetaData.<span class="built_in">indexOfKey</span>(keyCode);</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    /将数据添加到mMetaData</span><br><span class="line">    <span class="keyword">return</span> mMetaData.<span class="built_in">valueAt</span>(index).<span class="built_in">string</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> StagefrightMetadataRetriever<span class="operator">::</span>parseMetaData() &#123;</span><br><span class="line">    <span class="comment">//获取MetaData</span></span><br><span class="line">    sp<span class="operator">&lt;</span>MetaData<span class="operator">&gt;</span> meta <span class="operator">=</span> mExtractor<span class="operator">-&gt;</span>getMetaData();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//TAG对应的map</span></span><br><span class="line">    <span class="keyword">struct</span> Map &#123;</span><br><span class="line">        int from;</span><br><span class="line">        int <span class="keyword">to</span>;</span><br><span class="line">        const char <span class="operator">*</span>name;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">static</span> const Map kMap[] <span class="operator">=</span> &#123;</span><br><span class="line">        &#123; kKeyMIMEType, METADATA_KEY_MIMETYPE, NULL &#125;,</span><br><span class="line">        &#123; kKeyCDTrackNumber, METADATA_KEY_CD_TRACK_NUMBER, <span class="string">&quot;tracknumber&quot;</span> &#125;,</span><br><span class="line">        &#123; kKeyDiscNumber, METADATA_KEY_DISC_NUMBER, <span class="string">&quot;discnumber&quot;</span> &#125;,</span><br><span class="line">        &#123; kKeyAlbum, METADATA_KEY_ALBUM, <span class="string">&quot;album&quot;</span> &#125;,</span><br><span class="line">        &#123; kKeyArtist, METADATA_KEY_ARTIST, <span class="string">&quot;artist&quot;</span> &#125;,</span><br><span class="line">        &#123; kKeyAlbumArtist, METADATA_KEY_ALBUMARTIST, <span class="string">&quot;albumartist&quot;</span> &#125;,</span><br><span class="line">        &#123; kKeyAuthor, METADATA_KEY_AUTHOR, NULL &#125;,</span><br><span class="line">        &#123; kKeyComposer, METADATA_KEY_COMPOSER, <span class="string">&quot;composer&quot;</span> &#125;,</span><br><span class="line">        &#123; kKeyDate, METADATA_KEY_DATE, NULL &#125;,</span><br><span class="line">        &#123; kKeyGenre, METADATA_KEY_GENRE, <span class="string">&quot;genre&quot;</span> &#125;,</span><br><span class="line">        &#123; kKeyTitle, METADATA_KEY_TITLE, <span class="string">&quot;title&quot;</span> &#125;,</span><br><span class="line">        &#123; kKeyYear, METADATA_KEY_YEAR, <span class="string">&quot;year&quot;</span> &#125;,</span><br><span class="line">        &#123; kKeyWriter, METADATA_KEY_WRITER, <span class="string">&quot;writer&quot;</span> &#125;,</span><br><span class="line">        &#123; kKeyCompilation, METADATA_KEY_COMPILATION, <span class="string">&quot;compilation&quot;</span> &#125;,</span><br><span class="line">        &#123; kKeyLocation, METADATA_KEY_LOCATION, NULL &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">static</span> const size_t kNumMapEntries <span class="operator">=</span> <span class="built_in">sizeof</span>(kMap) <span class="operator">/</span> <span class="built_in">sizeof</span>(kMap[<span class="number">0</span>]);</span><br><span class="line">    <span class="comment">//创建判断字符编码检测器</span></span><br><span class="line">    CharacterEncodingDetector <span class="operator">*</span>detector <span class="operator">=</span> <span class="keyword">new</span> CharacterEncodingDetector();</span><br><span class="line">    <span class="comment">//将对应的TAG添加到detector中</span></span><br><span class="line">    <span class="keyword">for</span> (size_t i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> kNumMapEntries; <span class="operator">++</span>i) &#123;</span><br><span class="line">        const char <span class="operator">*</span>value;</span><br><span class="line">        <span class="keyword">if</span> (meta<span class="operator">-&gt;</span>findCString(kMap[i].from, <span class="operator">&amp;</span>value)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (kMap[i].name) &#123;</span><br><span class="line">                <span class="comment">// add to charset detector</span></span><br><span class="line">                <span class="comment">//这里没有直接添加到mMetaData而是先添加到CharacterEncodingDetector的mNames，mValues中等待转换编码</span></span><br><span class="line">                detector<span class="operator">-&gt;</span>addTag(kMap[i].name, value);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// directly add to output list</span></span><br><span class="line">                mMetaData.add(kMap[i].<span class="keyword">to</span>, String8(value));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="operator">/*</span></span><br><span class="line">    <span class="keyword">void</span> CharacterEncodingDetector<span class="operator">::</span>addTag(const char <span class="operator">*</span>name, const char <span class="operator">*</span>value) &#123;</span><br><span class="line">        mNames.push_back(name);</span><br><span class="line">        mValues.push_back(value);</span><br><span class="line">    &#125;</span><br><span class="line">    ×<span class="operator">/</span></span><br><span class="line">    <span class="comment">//开始转化编码，这部分放在后面进行介绍</span></span><br><span class="line">    detector<span class="operator">-&gt;</span>detectAndConvert();</span><br><span class="line">    int size <span class="operator">=</span> detector<span class="operator">-&gt;</span>size();</span><br><span class="line">    <span class="keyword">if</span> (size) &#123;</span><br><span class="line">        <span class="comment">//将转换后的TAG放到mMetaData，这时候整个mMetaData存放的都是正确编码后的内容</span></span><br><span class="line">        <span class="keyword">for</span> (int i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> size; i<span class="operator">++</span>) &#123;</span><br><span class="line">            const char <span class="operator">*</span>name;</span><br><span class="line">            const char <span class="operator">*</span>value;</span><br><span class="line">            detector<span class="operator">-&gt;</span>getTag(i, <span class="operator">&amp;</span>name, <span class="operator">&amp;</span>value);</span><br><span class="line">            <span class="keyword">for</span> (size_t j <span class="operator">=</span> <span class="number">0</span>; j <span class="operator">&lt;</span> kNumMapEntries; <span class="operator">++</span>j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (kMap[j].name <span class="operator">&amp;&amp;</span> <span class="operator">!</span>strcmp(kMap[j].name, name)) &#123;</span><br><span class="line">                    mMetaData.add(kMap[j].<span class="keyword">to</span>, String8(value));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    delete detector;</span><br><span class="line"></span><br><span class="line">    const <span class="keyword">void</span> <span class="operator">*</span>data;</span><br><span class="line">    uint32_t <span class="keyword">type</span>;</span><br><span class="line">    size_t dataSize;</span><br><span class="line">    <span class="keyword">if</span> (meta<span class="operator">-&gt;</span>findData(kKeyAlbumArt, <span class="operator">&amp;</span><span class="keyword">type</span>, <span class="operator">&amp;</span>data, <span class="operator">&amp;</span>dataSize)<span class="operator">&amp;&amp;</span> mAlbumArt <span class="operator">==</span> NULL) &#123;</span><br><span class="line">        mAlbumArt <span class="operator">=</span> MediaAlbumArt<span class="operator">::</span>fromData(dataSize, data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    size_t numTracks <span class="operator">=</span> mExtractor<span class="operator">-&gt;</span>countTracks();</span><br><span class="line"></span><br><span class="line">    char tmp[<span class="number">32</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(tmp, <span class="string">&quot;%zu&quot;</span>, numTracks);</span><br><span class="line"></span><br><span class="line">    mMetaData.add(METADATA_KEY_NUM_TRACKS, String8(tmp));</span><br><span class="line"></span><br><span class="line">    float captureFps;</span><br><span class="line">    <span class="keyword">if</span> (meta<span class="operator">-&gt;</span>findFloat(kKeyCaptureFramerate, <span class="operator">&amp;</span>captureFps)) &#123;</span><br><span class="line">        <span class="built_in">sprintf</span>(tmp, <span class="string">&quot;%f&quot;</span>, captureFps);</span><br><span class="line">        mMetaData.add(METADATA_KEY_CAPTURE_FRAMERATE, String8(tmp));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool hasAudio <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    bool hasVideo <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    int32_t videoWidth <span class="operator">=</span> <span class="number">-1</span>;</span><br><span class="line">    int32_t videoHeight <span class="operator">=</span> <span class="number">-1</span>;</span><br><span class="line">    int32_t audioBitrate <span class="operator">=</span> <span class="number">-1</span>;</span><br><span class="line">    int32_t rotationAngle <span class="operator">=</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The overall duration is the duration of the longest track.</span></span><br><span class="line">    int64_t maxDurationUs <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    String8 timedTextLang;</span><br><span class="line">    <span class="keyword">for</span> (size_t i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> numTracks; <span class="operator">++</span>i) &#123;</span><br><span class="line">        sp<span class="operator">&lt;</span>MetaData<span class="operator">&gt;</span> trackMeta <span class="operator">=</span> mExtractor<span class="operator">-&gt;</span>getTrackMetaData(i);</span><br><span class="line">        int64_t durationUs;</span><br><span class="line">        <span class="keyword">if</span> (trackMeta<span class="operator">-&gt;</span>findInt64(kKeyDuration, <span class="operator">&amp;</span>durationUs)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (durationUs <span class="operator">&gt;</span> maxDurationUs) &#123;</span><br><span class="line">                maxDurationUs <span class="operator">=</span> durationUs;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        const char <span class="operator">*</span>mime;</span><br><span class="line">        <span class="keyword">if</span> (trackMeta<span class="operator">-&gt;</span>findCString(kKeyMIMEType, <span class="operator">&amp;</span>mime)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="operator">!</span>hasAudio <span class="operator">&amp;&amp;</span> <span class="operator">!</span>strncasecmp(<span class="string">&quot;audio/&quot;</span>, mime, <span class="number">6</span>)) &#123;</span><br><span class="line">                hasAudio <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (<span class="operator">!</span>trackMeta<span class="operator">-&gt;</span>findInt32(kKeyBitRate, <span class="operator">&amp;</span>audioBitrate)) &#123;</span><br><span class="line">                    audioBitrate <span class="operator">=</span> <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="operator">!</span>hasVideo <span class="operator">&amp;&amp;</span> <span class="operator">!</span>strncasecmp(<span class="string">&quot;video/&quot;</span>, mime, <span class="number">6</span>)) &#123;</span><br><span class="line">                hasVideo <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">                CHECK(trackMeta<span class="operator">-&gt;</span>findInt32(kKeyWidth, <span class="operator">&amp;</span>videoWidth));</span><br><span class="line">                CHECK(trackMeta<span class="operator">-&gt;</span>findInt32(kKeyHeight, <span class="operator">&amp;</span>videoHeight));</span><br><span class="line">                <span class="keyword">if</span> (<span class="operator">!</span>trackMeta<span class="operator">-&gt;</span>findInt32(kKeyRotation, <span class="operator">&amp;</span>rotationAngle)) &#123;</span><br><span class="line">                    rotationAngle <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="operator">!</span>strcasecmp(mime, MEDIA_MIMETYPE_TEXT_3GPP)) &#123;</span><br><span class="line">                const char <span class="operator">*</span>lang;</span><br><span class="line">                trackMeta<span class="operator">-&gt;</span>findCString(kKeyMediaLanguage, <span class="operator">&amp;</span>lang);</span><br><span class="line">                timedTextLang.append(String8(lang));</span><br><span class="line">                timedTextLang.append(String8(<span class="string">&quot;:&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// To save the language codes for all timed text tracks</span></span><br><span class="line">    <span class="comment">// If multiple text tracks present, the format will look</span></span><br><span class="line">    <span class="comment">// like &quot;eng:chi&quot;</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="operator">!</span>timedTextLang.isEmpty()) &#123;</span><br><span class="line">        mMetaData.add(METADATA_KEY_TIMED_TEXT_LANGUAGES, timedTextLang);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The duration value is a string representing the duration in ms.</span></span><br><span class="line">    <span class="built_in">sprintf</span>(tmp, <span class="string">&quot;%&quot;</span> PRId64, (maxDurationUs <span class="operator">+</span> <span class="number">500</span>) <span class="operator">/</span> <span class="number">1000</span>);</span><br><span class="line">    mMetaData.add(METADATA_KEY_DURATION, String8(tmp));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hasAudio) &#123;</span><br><span class="line">        mMetaData.add(METADATA_KEY_HAS_AUDIO, String8(<span class="string">&quot;yes&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hasVideo) &#123;</span><br><span class="line">        mMetaData.add(METADATA_KEY_HAS_VIDEO, String8(<span class="string">&quot;yes&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="built_in">sprintf</span>(tmp, <span class="string">&quot;%d&quot;</span>, videoWidth);</span><br><span class="line">        mMetaData.add(METADATA_KEY_VIDEO_WIDTH, String8(tmp));</span><br><span class="line"></span><br><span class="line">        <span class="built_in">sprintf</span>(tmp, <span class="string">&quot;%d&quot;</span>, videoHeight);</span><br><span class="line">        mMetaData.add(METADATA_KEY_VIDEO_HEIGHT, String8(tmp));</span><br><span class="line"></span><br><span class="line">        <span class="built_in">sprintf</span>(tmp, <span class="string">&quot;%d&quot;</span>, rotationAngle);</span><br><span class="line">        mMetaData.add(METADATA_KEY_VIDEO_ROTATION, String8(tmp));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (numTracks <span class="operator">==</span> <span class="number">1</span> <span class="operator">&amp;&amp;</span> hasAudio <span class="operator">&amp;&amp;</span> audioBitrate <span class="operator">&gt;=</span> <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">sprintf</span>(tmp, <span class="string">&quot;%d&quot;</span>, audioBitrate);</span><br><span class="line">        mMetaData.add(METADATA_KEY_BITRATE, String8(tmp));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        off64_t sourceSize;</span><br><span class="line">        <span class="keyword">if</span> (mSource<span class="operator">-&gt;</span>getSize(<span class="operator">&amp;</span>sourceSize) <span class="operator">==</span> OK) &#123;</span><br><span class="line">            int64_t avgBitRate <span class="operator">=</span> (int64_t)(sourceSize <span class="operator">*</span> <span class="number">8E6</span> <span class="operator">/</span> maxDurationUs);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">sprintf</span>(tmp, <span class="string">&quot;%&quot;</span> PRId64, avgBitRate);</span><br><span class="line">            mMetaData.add(METADATA_KEY_BITRATE, String8(tmp));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (numTracks <span class="operator">==</span> <span class="number">1</span>) &#123;</span><br><span class="line">        const char <span class="operator">*</span>fileMIME;</span><br><span class="line">        CHECK(meta<span class="operator">-&gt;</span>findCString(kKeyMIMEType, <span class="operator">&amp;</span>fileMIME));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="operator">!</span>strcasecmp(fileMIME, <span class="string">&quot;video/x-matroska&quot;</span>)) &#123;</span><br><span class="line">            sp<span class="operator">&lt;</span>MetaData<span class="operator">&gt;</span> trackMeta <span class="operator">=</span> mExtractor<span class="operator">-&gt;</span>getTrackMetaData(<span class="number">0</span>);</span><br><span class="line">            const char <span class="operator">*</span>trackMIME;</span><br><span class="line">            CHECK(trackMeta<span class="operator">-&gt;</span>findCString(kKeyMIMEType, <span class="operator">&amp;</span>trackMIME));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="operator">!</span>strncasecmp(<span class="string">&quot;audio/&quot;</span>, trackMIME, <span class="number">6</span>)) &#123;</span><br><span class="line">                <span class="comment">// The matroska file only contains a single audio track,</span></span><br><span class="line">                <span class="comment">// rewrite its mime type.</span></span><br><span class="line">                mMetaData.add(</span><br><span class="line">                        METADATA_KEY_MIMETYPE, String8(<span class="string">&quot;audio/x-matroska&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// To check whether the media file is drm-protected</span></span><br><span class="line">    <span class="keyword">if</span> (mExtractor<span class="operator">-&gt;</span>getDrmFlag()) &#123;</span><br><span class="line">        mMetaData.add(METADATA_KEY_IS_DRM, String8(<span class="string">&quot;1&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面代码中可以看出完成关键工作就是从Meta中取出各个TAG，经过字符编码转换后添加到mMetaData中。</p>
<p>我们看到这里不要忽略了getMetaData，getMetaData方法中通过创建用于对存储在文件头的ID3V2标签帧和存储在文件尾部的ID3V1帧进行解析的ID3对象来完成标签帧到解析，这里解析的内容包括基本的歌曲信息标签以及歌词，专辑封面等信息。想要真正了解整个解析过程我们还得继续看下ID3类的构造方法和ID3::Iterator方法。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">sp&lt;MetaData&gt; MP3Extractor::get<span class="constructor">MetaData()</span> &#123;</span><br><span class="line">    sp&lt;MetaData&gt; meta = <span class="keyword">new</span> MetaData;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mInitCheck != OK) &#123;</span><br><span class="line">        return meta;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置mimetype</span></span><br><span class="line">    meta-&gt;set<span class="constructor">CString(<span class="params">kKeyMIMEType</span>, <span class="string">&quot;audio/mpeg&quot;</span>)</span>;</span><br><span class="line">    <span class="comment">//创建id3</span></span><br><span class="line">    ID3 id3(mDataSource);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!id3.is<span class="constructor">Valid()</span>) &#123;</span><br><span class="line">        return meta;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> Map &#123;</span><br><span class="line">        <span class="built_in">int</span> key;</span><br><span class="line">        const <span class="built_in">char</span> *tag1;</span><br><span class="line">        const <span class="built_in">char</span> *tag2;</span><br><span class="line">    &#125;;</span><br><span class="line">    static const Map kMap<span class="literal">[]</span> = &#123;</span><br><span class="line">        &#123; kKeyAlbum, <span class="string">&quot;TALB&quot;</span>, <span class="string">&quot;TAL&quot;</span> &#125;,</span><br><span class="line">        &#123; kKeyArtist, <span class="string">&quot;TPE1&quot;</span>, <span class="string">&quot;TP1&quot;</span> &#125;,</span><br><span class="line">        &#123; kKeyAlbumArtist, <span class="string">&quot;TPE2&quot;</span>, <span class="string">&quot;TP2&quot;</span> &#125;,</span><br><span class="line">        &#123; kKeyComposer, <span class="string">&quot;TCOM&quot;</span>, <span class="string">&quot;TCM&quot;</span> &#125;,</span><br><span class="line">        &#123; kKeyGenre, <span class="string">&quot;TCON&quot;</span>, <span class="string">&quot;TCO&quot;</span> &#125;,</span><br><span class="line">        &#123; kKeyTitle, <span class="string">&quot;TIT2&quot;</span>, <span class="string">&quot;TT2&quot;</span> &#125;,</span><br><span class="line">        &#123; kKeyYear, <span class="string">&quot;TYE&quot;</span>, <span class="string">&quot;TYER&quot;</span> &#125;,</span><br><span class="line">        &#123; kKeyAuthor, <span class="string">&quot;TXT&quot;</span>, <span class="string">&quot;TEXT&quot;</span> &#125;,</span><br><span class="line">        &#123; kKeyCDTrackNumber, <span class="string">&quot;TRK&quot;</span>, <span class="string">&quot;TRCK&quot;</span> &#125;,</span><br><span class="line">        &#123; kKeyDiscNumber, <span class="string">&quot;TPA&quot;</span>, <span class="string">&quot;TPOS&quot;</span> &#125;,</span><br><span class="line">        &#123; kKeyCompilation, <span class="string">&quot;TCP&quot;</span>, <span class="string">&quot;TCMP&quot;</span> &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">    static const size_t kNumMapEntries = sizeof(kMap)<span class="operator"> / </span>sizeof(kMap<span class="literal">[<span class="number">0</span>]</span>);</span><br><span class="line">    <span class="comment">//获取上面提到的TAG</span></span><br><span class="line">    <span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; kNumMapEntries; ++i) &#123;</span><br><span class="line">        ID3::Iterator *it = <span class="keyword">new</span> ID3::<span class="constructor">Iterator(<span class="params">id3</span>, <span class="params">kMap</span>[<span class="params">i</span>].<span class="params">tag1</span>)</span>;</span><br><span class="line">        <span class="keyword">if</span> (it-&gt;<span class="keyword">done</span><span class="literal">()</span>) &#123;</span><br><span class="line">            delete it;</span><br><span class="line">            it = <span class="keyword">new</span> ID3::<span class="constructor">Iterator(<span class="params">id3</span>, <span class="params">kMap</span>[<span class="params">i</span>].<span class="params">tag2</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (it-&gt;<span class="keyword">done</span><span class="literal">()</span>) &#123;</span><br><span class="line">            delete it;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        String8 s;</span><br><span class="line">        it-&gt;get<span class="constructor">String(&amp;<span class="params">s</span>)</span>;</span><br><span class="line">        delete it;</span><br><span class="line">        meta-&gt;set<span class="constructor">CString(<span class="params">kMap</span>[<span class="params">i</span>].<span class="params">key</span>, <span class="params">s</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    size_t dataSize;</span><br><span class="line">    String8 mime;</span><br><span class="line">    <span class="comment">//获取专辑封面</span></span><br><span class="line">    const void *data = id3.get<span class="constructor">AlbumArt(&amp;<span class="params">dataSize</span>, &amp;<span class="params">mime</span>)</span>;</span><br><span class="line">    <span class="keyword">if</span> (data) &#123;</span><br><span class="line">        meta-&gt;set<span class="constructor">Data(<span class="params">kKeyAlbumArt</span>, MetaData::TYPE_NONE, <span class="params">data</span>, <span class="params">dataSize</span>)</span>;</span><br><span class="line">        meta-&gt;set<span class="constructor">CString(<span class="params">kKeyAlbumArtMIME</span>, <span class="params">mime</span>.<span class="params">string</span>()</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    return meta;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们先看下ID3的构造方法，在ID3方法中，会先调用parseV2，如果parseV2返回false的话会调用parseV1，也就是说ID3会首先解析位于文件头到ID3V2标签帧，如果解析失败则会尝试解析ID3V1帧。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">ID3::<span class="constructor">ID3(<span class="params">const</span> <span class="params">sp</span>&lt;DataSource&gt; &amp;<span class="params">source</span>, <span class="params">bool</span> <span class="params">ignoreV1</span>, <span class="params">off64_t</span> <span class="params">offset</span>)</span></span><br><span class="line">    : m<span class="constructor">IsValid(<span class="params">false</span>)</span>,</span><br><span class="line">      m<span class="constructor">Data(NULL)</span>,</span><br><span class="line">      m<span class="constructor">Size(0)</span>,</span><br><span class="line">      m<span class="constructor">FirstFrameOffset(0)</span>,</span><br><span class="line">      m<span class="constructor">Version(ID3_UNKNOWN)</span>,</span><br><span class="line">      m<span class="constructor">RawSize(0)</span> &#123;</span><br><span class="line">    <span class="comment">//解析ID3V2Tab内容</span></span><br><span class="line">    mIsValid = parse<span class="constructor">V2(<span class="params">source</span>, <span class="params">offset</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mIsValid<span class="operator"> &amp;&amp; </span>!ignoreV1) &#123;</span><br><span class="line">        <span class="comment">//解析ID3V1 TAB 内容</span></span><br><span class="line">        mIsValid = parse<span class="constructor">V1(<span class="params">source</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而在parseV2以及parseV1方法中实际上也还没开始解析，它们只是开辟个mData 空间将对应的TAG标签加载到mData中，后续的解析工作将会针对mData中的这些数据进行解析。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ID3::parseV2</span><span class="params">(<span class="type">const</span> sp&lt;DataSource&gt; &amp;source)</span> </span>&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">id3_header</span> &#123;</span><br><span class="line">    <span class="comment">//标签头10个字节</span></span><br><span class="line">    <span class="type">char</span> id[<span class="number">3</span>]; <span class="comment">/*必须为&quot;ID3&quot;否则认为标签不存在*/</span></span><br><span class="line">    <span class="type">uint8_t</span> version_major;  <span class="comment">/*版本号ID3V2.3就记录3*/</span></span><br><span class="line">    <span class="type">uint8_t</span> version_minor;  <span class="comment">/*副版本号此版本记录为0*/</span></span><br><span class="line">    <span class="type">uint8_t</span> flags; <span class="comment">/*存放标志的字节，这个版本只定义了三位*/</span></span><br><span class="line">    <span class="type">uint8_t</span> enc_size[<span class="number">4</span>];  <span class="comment">/*标签大小，不包括标签头的10个字节*/</span></span><br><span class="line">    &#125;;</span><br><span class="line">    id3_header header;</span><br><span class="line">    <span class="keyword">if</span> (source-&gt;<span class="built_in">readAt</span>(<span class="number">0</span>, &amp;header, <span class="built_in">sizeof</span>(header)) != (<span class="type">ssize_t</span>)<span class="built_in">sizeof</span>(header)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*必须为&quot;ID3&quot;否则认为标签不存在*/</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">memcmp</span>(header.id, <span class="string">&quot;ID3&quot;</span>, <span class="number">3</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果主版本号和副版本号都是0xff则表示错误</span></span><br><span class="line">    <span class="keyword">if</span> (header.version_major == <span class="number">0xff</span> || header.version_minor == <span class="number">0xff</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">if</span> (header.version_major == <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="comment">//如果主版本号为2</span></span><br><span class="line">     <span class="comment">//............................................</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (header.version_major == <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="comment">//如果主版本号为3</span></span><br><span class="line">        <span class="keyword">if</span> (header.flags &amp; <span class="number">0x1f</span>) &#123;</span><br><span class="line">            <span class="comment">// We only support the 3 high bits, if any of the lower bits are</span></span><br><span class="line">            <span class="comment">// set, we cannot guarantee to understand the tag format.</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (header.version_major == <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="comment">//如果主版本号为4</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//如果主版本号不是上述的则直接返回false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取标签大小</span></span><br><span class="line">    <span class="type">size_t</span> size;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">ParseSyncsafeInteger</span>(header.enc_size, &amp;size)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//static const size_t kMaxMetadataSize = 3 * 1024 * 1024;</span></span><br><span class="line">    <span class="comment">//如果大小超过3M则退出</span></span><br><span class="line">    <span class="keyword">if</span> (size &gt; kMaxMetadataSize) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//分配用于存放标签内容的空间</span></span><br><span class="line">    mData = (<span class="type">uint8_t</span> *)<span class="built_in">malloc</span>(size);</span><br><span class="line">    mSize = size;</span><br><span class="line">    mRawSize = mSize + <span class="built_in">sizeof</span>(header);</span><br><span class="line">    <span class="comment">//mRawSize 表示 标签帧大小加上 标签头大小10个字节 </span></span><br><span class="line">    <span class="comment">//读取标签帧数据</span></span><br><span class="line">    <span class="keyword">if</span> (source-&gt;<span class="built_in">readAt</span>(<span class="built_in">sizeof</span>(header), mData, mSize) != (<span class="type">ssize_t</span>)mSize) &#123;</span><br><span class="line">        <span class="built_in">free</span>(mData);</span><br><span class="line">        mData = <span class="literal">NULL</span> ;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//..........................................................</span></span><br><span class="line">    mFirstFrameOffset = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//..........................................................</span></span><br><span class="line">    <span class="keyword">if</span> (header.version_major == <span class="number">2</span>) &#123;</span><br><span class="line">        mVersion = ID3_V2_2;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (header.version_major == <span class="number">3</span>) &#123;</span><br><span class="line">        mVersion = ID3_V2_3;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">CHECK_EQ</span>(header.version_major, <span class="number">4</span>);</span><br><span class="line">        mVersion = ID3_V2_4;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ID3::parseV1</span><span class="params">(<span class="type">const</span> sp&lt;DataSource&gt; &amp;source)</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> V1_TAG_SIZE = <span class="number">128</span>;</span><br><span class="line">    <span class="type">off64_t</span> size;</span><br><span class="line">    <span class="keyword">if</span> (source-&gt;<span class="built_in">getSize</span>(&amp;size) != OK || size &lt; (<span class="type">off64_t</span>)V1_TAG_SIZE) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//分配空间</span></span><br><span class="line">    mData = (<span class="type">uint8_t</span> *)<span class="built_in">malloc</span>(V1_TAG_SIZE);</span><br><span class="line">    <span class="comment">//读取位于文件尾部128字节的V1标签帧</span></span><br><span class="line">    <span class="keyword">if</span> (source-&gt;<span class="built_in">readAt</span>(size - V1_TAG_SIZE, mData, V1_TAG_SIZE)</span><br><span class="line">            != (<span class="type">ssize_t</span>)V1_TAG_SIZE) &#123;</span><br><span class="line">        <span class="built_in">free</span>(mData);</span><br><span class="line">        mData = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">memcmp</span>(<span class="string">&quot;TAG&quot;</span>, mData, <span class="number">3</span>)) &#123;</span><br><span class="line">        <span class="built_in">free</span>(mData);</span><br><span class="line">        mData = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mSize = V1_TAG_SIZE;</span><br><span class="line">    mFirstFrameOffset = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span> (mData[V1_TAG_SIZE - <span class="number">3</span>] != <span class="number">0</span>) &#123;</span><br><span class="line">        mVersion = ID3_V1;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mVersion = ID3_V1_1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>真正的解析流程是从Iterator开始的，在Iterator中先是调用strdup(id)获取当前要获取的Tag到ID值放到mID中，接着调用findFrame找到对应到帧。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">ID3::Iterator::<span class="constructor">Iterator(<span class="params">const</span> ID3 &amp;<span class="params">parent</span>, <span class="params">const</span> <span class="params">char</span> <span class="operator">*</span><span class="params">id</span>)</span></span><br><span class="line">    : m<span class="constructor">Parent(<span class="params">parent</span>)</span>,</span><br><span class="line">      m<span class="constructor">ID(NULL)</span>,</span><br><span class="line">      m<span class="constructor">Offset(<span class="params">mParent</span>.<span class="params">mFirstFrameOffset</span>)</span>,</span><br><span class="line">      m<span class="constructor">FrameData(NULL)</span>,</span><br><span class="line">      m<span class="constructor">FrameSize(0)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (id) &#123;</span><br><span class="line">        mID = strdup(id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//找到帧对应的位置</span></span><br><span class="line">    find<span class="constructor">Frame()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在findFrame中将当前ID与存储着全部标签帧数据的mData空间中的每个帧进行对比，如果找到帧标志等于当前ID的数据的时候就退出遍历循环，这时候mID就指向要寻找标签数据的位置。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> ID3::Iterator::<span class="built_in">findFrame</span>() &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        mFrameData = <span class="literal">NULL</span>;</span><br><span class="line">        mFrameSize = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (mParent.mVersion == ID3_V2_2) &#123;</span><br><span class="line">           <span class="comment">//..................................................</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mParent.mVersion == ID3_V2_3</span><br><span class="line">                || mParent.mVersion == ID3_V2_4) &#123;</span><br><span class="line">            <span class="comment">//这是正常的MP3格式</span></span><br><span class="line">            <span class="keyword">if</span> (mOffset + <span class="number">10</span> &gt; mParent.mSize) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果头四个字节为0000则返回</span></span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">memcmp</span>(&amp;mParent.mData[mOffset], <span class="string">&quot;\0\0\0\0&quot;</span>, <span class="number">4</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">size_t</span> baseSize;</span><br><span class="line">            <span class="keyword">if</span> (mParent.mVersion == ID3_V2_4) &#123;</span><br><span class="line">                <span class="comment">//.......................................................................</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//获取标签帧的内容大小</span></span><br><span class="line">                baseSize = <span class="built_in">U32_AT</span>(&amp;mParent.mData[mOffset + <span class="number">4</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//表示包含帧头的总共大小</span></span><br><span class="line">            mFrameSize = <span class="number">10</span> + baseSize;</span><br><span class="line">            <span class="keyword">if</span> (mOffset + mFrameSize &gt; mParent.mSize) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当前标签帧的内容数据</span></span><br><span class="line">            mFrameData = &amp;mParent.mData[mOffset + <span class="number">10</span>];</span><br><span class="line">            <span class="keyword">if</span> (!mID) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将Tab 复制到id上，判断id是否等于mID如果不等则继续查找</span></span><br><span class="line">            <span class="type">char</span> id[<span class="number">5</span>];</span><br><span class="line">            <span class="built_in">memcpy</span>(id, &amp;mParent.mData[mOffset], <span class="number">4</span>);</span><br><span class="line">            id[<span class="number">4</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">            <span class="comment">//如果等于要找的ID 则退出循环，这时候mOffset 指向的是要查找帧的位置</span></span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(id, mID)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">//.................................................</span></span><br><span class="line">        &#125;</span><br><span class="line">        mOffset += mFrameSize;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获取专辑图片：<br>专辑图片的获取过程实际和获取其他TAG的方式是一样的，也是通过遍历存放ID3标签原始数据的mData空间，找到标签为”APIC”的数据，然后再将指向专辑图片的数据的首地址返回。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">void</span> *</span></span><br><span class="line"><span class="function"><span class="title">ID3::getAlbumArt</span><span class="params">(<span class="type">size_t</span> *length, String8 *mime)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    *length = <span class="number">0</span>;</span><br><span class="line">    mime-&gt;<span class="built_in">setTo</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="comment">//APIC Attached picture 定位专辑图片的位置</span></span><br><span class="line">    <span class="function">Iterator <span class="title">it</span><span class="params">(*<span class="keyword">this</span>,(mVersion == ID3_V2_3 || mVersion == ID3_V2_4) ? <span class="string">&quot;APIC&quot;</span> : <span class="string">&quot;PIC&quot;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (!it.<span class="built_in">done</span>()) &#123;</span><br><span class="line">        <span class="type">size_t</span> size;</span><br><span class="line">        <span class="comment">//指向专辑图片数据</span></span><br><span class="line">        <span class="type">const</span> <span class="type">uint8_t</span> *data = it.<span class="built_in">getData</span>(&amp;size);</span><br><span class="line">        <span class="keyword">if</span> (mVersion == ID3_V2_3 || mVersion == ID3_V2_4) &#123;</span><br><span class="line">            <span class="type">uint8_t</span> encoding = data[<span class="number">0</span>];</span><br><span class="line">            mime-&gt;<span class="built_in">setTo</span>((<span class="type">const</span> <span class="type">char</span> *)&amp;data[<span class="number">1</span>]);</span><br><span class="line">            <span class="type">size_t</span> mimeLen = <span class="built_in">strlen</span>((<span class="type">const</span> <span class="type">char</span> *)&amp;data[<span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//返回图片的类型</span></span><br><span class="line">            <span class="type">uint8_t</span> picType = data[<span class="number">1</span> + mimeLen];</span><br><span class="line">            <span class="comment">//图片描述的内容长度</span></span><br><span class="line">            <span class="type">size_t</span> descLen = <span class="built_in">StringSize</span>(&amp;data[<span class="number">2</span> + mimeLen], encoding);</span><br><span class="line">            <span class="comment">//图片的实际长度</span></span><br><span class="line">            *length = size - <span class="number">2</span> - mimeLen - descLen;</span><br><span class="line">            <span class="comment">//返回图片的地址</span></span><br><span class="line">            <span class="keyword">return</span> &amp;data[<span class="number">2</span> + mimeLen + descLen];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">//...........................................................</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述就是获取各个标签帧数据的流程，找出标签帧的值后就将可以将其取出存储到mMetaData中了。<br>我们再回到processFileInternal方法，看下接下来需要做哪些操作：它将会调用status &#x3D; client.addStringTag(kKeyMap[i].tag, value);将该Tag传递到MediaScannerClient中进行处理，那么在MediaScannerClient中会做哪些处理呢？</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">status_t MediaScannerClient::add<span class="constructor">StringTag(<span class="params">const</span> <span class="params">char</span><span class="operator">*</span> <span class="params">name</span>, <span class="params">const</span> <span class="params">char</span><span class="operator">*</span> <span class="params">value</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    handle<span class="constructor">StringTag(<span class="params">name</span>, <span class="params">value</span>)</span>;</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在MediaScanner.java中将从底层传来的对应值赋给对应的成员变量。至此就完成了音频视频文件的Tag标签的获取过程。接下来和其他普通文件的处理方式一样，就是通过MediaProvider将其存储到数据库中。从而完成媒体扫描的整个过程。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public void handle<span class="constructor">StringTag(String <span class="params">name</span>, String <span class="params">value</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (name.equals<span class="constructor">IgnoreCase(<span class="string">&quot;title&quot;</span>)</span><span class="operator"> || </span>name.starts<span class="constructor">With(<span class="string">&quot;title;&quot;</span>)</span>) &#123;</span><br><span class="line">        <span class="comment">// Don&#x27;t trim() here, to preserve the special \001 character</span></span><br><span class="line">        <span class="comment">// used to force sorting. The media provider will trim() before</span></span><br><span class="line">        <span class="comment">// inserting the title in to the database.</span></span><br><span class="line">        mTitle = value;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name.equals<span class="constructor">IgnoreCase(<span class="string">&quot;artist&quot;</span>)</span><span class="operator"> || </span>name.starts<span class="constructor">With(<span class="string">&quot;artist;&quot;</span>)</span>) &#123;</span><br><span class="line">        mArtist = value.trim<span class="literal">()</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name.equals<span class="constructor">IgnoreCase(<span class="string">&quot;albumartist&quot;</span>)</span><span class="operator"> || </span>name.starts<span class="constructor">With(<span class="string">&quot;albumartist;&quot;</span>)</span><span class="operator"></span></span><br><span class="line"><span class="operator">            || </span>name.equals<span class="constructor">IgnoreCase(<span class="string">&quot;band&quot;</span>)</span><span class="operator"> || </span>name.starts<span class="constructor">With(<span class="string">&quot;band;&quot;</span>)</span>) &#123;</span><br><span class="line">        mAlbumArtist = value.trim<span class="literal">()</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name.equals<span class="constructor">IgnoreCase(<span class="string">&quot;album&quot;</span>)</span><span class="operator"> || </span>name.starts<span class="constructor">With(<span class="string">&quot;album;&quot;</span>)</span>) &#123;</span><br><span class="line">        mAlbum = value.trim<span class="literal">()</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name.equals<span class="constructor">IgnoreCase(<span class="string">&quot;composer&quot;</span>)</span><span class="operator"> || </span>name.starts<span class="constructor">With(<span class="string">&quot;composer;&quot;</span>)</span>) &#123;</span><br><span class="line">        mComposer = value.trim<span class="literal">()</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mProcessGenres<span class="operator"> &amp;&amp;</span></span><br><span class="line"><span class="operator">            </span>(name.equals<span class="constructor">IgnoreCase(<span class="string">&quot;genre&quot;</span>)</span><span class="operator"> || </span>name.starts<span class="constructor">With(<span class="string">&quot;genre;&quot;</span>)</span>)) &#123;</span><br><span class="line">        mGenre = get<span class="constructor">GenreName(<span class="params">value</span>)</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name.equals<span class="constructor">IgnoreCase(<span class="string">&quot;year&quot;</span>)</span><span class="operator"> || </span>name.starts<span class="constructor">With(<span class="string">&quot;year;&quot;</span>)</span>) &#123;</span><br><span class="line">        mYear = parse<span class="constructor">Substring(<span class="params">value</span>, 0, 0)</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name.equals<span class="constructor">IgnoreCase(<span class="string">&quot;tracknumber&quot;</span>)</span><span class="operator"> || </span>name.starts<span class="constructor">With(<span class="string">&quot;tracknumber;&quot;</span>)</span>) &#123;</span><br><span class="line">        <span class="comment">// track number might be of the form &quot;2/12&quot;</span></span><br><span class="line">        <span class="comment">// we just read the number before the slash</span></span><br><span class="line">        <span class="built_in">int</span> num = parse<span class="constructor">Substring(<span class="params">value</span>, 0, 0)</span>;</span><br><span class="line">        mTrack = (mTrack<span class="operator"> / </span><span class="number">1000</span>)<span class="operator"> * </span><span class="number">1000</span> + num;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name.equals<span class="constructor">IgnoreCase(<span class="string">&quot;discnumber&quot;</span>)</span><span class="operator"> ||</span></span><br><span class="line"><span class="operator">            </span>name.equals(<span class="string">&quot;set&quot;</span>)<span class="operator"> || </span>name.starts<span class="constructor">With(<span class="string">&quot;set;&quot;</span>)</span>) &#123;</span><br><span class="line">        <span class="comment">// set number might be of the form &quot;1/3&quot;</span></span><br><span class="line">        <span class="comment">// we just read the number before the slash</span></span><br><span class="line">        <span class="built_in">int</span> num = parse<span class="constructor">Substring(<span class="params">value</span>, 0, 0)</span>;</span><br><span class="line">        mTrack = (num<span class="operator"> * </span><span class="number">1000</span>) + (mTrack % <span class="number">1000</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name.equals<span class="constructor">IgnoreCase(<span class="string">&quot;duration&quot;</span>)</span>) &#123;</span><br><span class="line">        mDuration = parse<span class="constructor">Substring(<span class="params">value</span>, 0, 0)</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name.equals<span class="constructor">IgnoreCase(<span class="string">&quot;writer&quot;</span>)</span><span class="operator"> || </span>name.starts<span class="constructor">With(<span class="string">&quot;writer;&quot;</span>)</span>) &#123;</span><br><span class="line">        mWriter = value.trim<span class="literal">()</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name.equals<span class="constructor">IgnoreCase(<span class="string">&quot;compilation&quot;</span>)</span>) &#123;</span><br><span class="line">        mCompilation = parse<span class="constructor">Substring(<span class="params">value</span>, 0, 0)</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name.equals<span class="constructor">IgnoreCase(<span class="string">&quot;isdrm&quot;</span>)</span>) &#123;</span><br><span class="line">        mIsDrm = (parse<span class="constructor">Substring(<span class="params">value</span>, 0, 0)</span><span class="operator"> == </span><span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name.equals<span class="constructor">IgnoreCase(<span class="string">&quot;width&quot;</span>)</span>) &#123;</span><br><span class="line">        mWidth = parse<span class="constructor">Substring(<span class="params">value</span>, 0, 0)</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name.equals<span class="constructor">IgnoreCase(<span class="string">&quot;height&quot;</span>)</span>) &#123;</span><br><span class="line">        mHeight = parse<span class="constructor">Substring(<span class="params">value</span>, 0, 0)</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//Log.v(TAG, &quot;unknown tag: &quot; + name + &quot; (&quot; + mProcessGenres + &quot;)&quot;);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此TAG的解析以及解码过程已经结束，我们最后还需要看下handleStringTag这个方法，这个方法中会将解码后的TAG如何做处理呢？<br>我们首先需要看下这个方法是如何从native层上升到Java层的，说到这个就必须考虑android_media_MediaScanner.cpp这个过渡类，在这个文件中我们可以找到handleStringTag这个方法，和其他一样在这里调用了CallVoidMethod方法进入到java层。这样java层中的handleStringTag就会被调用。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">virtual</span> status_t handle<span class="constructor">StringTag(<span class="params">const</span> <span class="params">char</span><span class="operator">*</span> <span class="params">name</span>, <span class="params">const</span> <span class="params">char</span><span class="operator">*</span> <span class="params">value</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="constructor">ALOGV(<span class="string">&quot;MediaScanner handleStringTag: name(%s) and value(%s)&quot;</span>, <span class="params">name</span>, <span class="params">value</span>)</span>;</span><br><span class="line">    jstring nameStr, valueStr;</span><br><span class="line">    <span class="keyword">if</span> ((nameStr = mEnv-&gt;<span class="constructor">NewStringUTF(<span class="params">name</span>)</span>)<span class="operator"> == </span>NULL) &#123;</span><br><span class="line">        mEnv-&gt;<span class="constructor">ExceptionClear()</span>;</span><br><span class="line">        return NO_MEMORY;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">char</span> *cleaned = NULL;</span><br><span class="line">    <span class="comment">//如果不是正常的UTF-8则将其置为？</span></span><br><span class="line">    <span class="keyword">if</span> (!is<span class="constructor">ValidUtf8(<span class="params">value</span>)</span>) &#123;</span><br><span class="line">        cleaned = strdup(value);</span><br><span class="line">        <span class="built_in">char</span> *chp = cleaned;</span><br><span class="line">        <span class="built_in">char</span> ch;</span><br><span class="line">        <span class="keyword">while</span> ((ch = *chp)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ch &amp; <span class="number">0x80</span>) &#123;</span><br><span class="line">                *chp = <span class="character">&#x27;?&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            chp++;</span><br><span class="line">        &#125;</span><br><span class="line">        value = cleaned;</span><br><span class="line">    &#125;</span><br><span class="line">    valueStr = mEnv-&gt;<span class="constructor">NewStringUTF(<span class="params">value</span>)</span>;</span><br><span class="line">    free(cleaned);</span><br><span class="line">    <span class="keyword">if</span> (valueStr<span class="operator"> == </span>NULL) &#123;</span><br><span class="line">        mEnv-&gt;<span class="constructor">DeleteLocalRef(<span class="params">nameStr</span>)</span>;</span><br><span class="line">        mEnv-&gt;<span class="constructor">ExceptionClear()</span>;</span><br><span class="line">        return NO_MEMORY;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//调用JAVA层的handleStringTag方法。</span></span><br><span class="line">    mEnv-&gt;<span class="constructor">CallVoidMethod(<span class="params">mClient</span>, <span class="params">mHandleStringTagMethodID</span>, <span class="params">nameStr</span>, <span class="params">valueStr</span>)</span>;</span><br><span class="line">    mEnv-&gt;<span class="constructor">DeleteLocalRef(<span class="params">nameStr</span>)</span>;</span><br><span class="line">    mEnv-&gt;<span class="constructor">DeleteLocalRef(<span class="params">valueStr</span>)</span>;</span><br><span class="line">    return check<span class="constructor">AndClearExceptionFromCallback(<span class="params">mEnv</span>, <span class="string">&quot;handleStringTag&quot;</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">最后还是上个图吧，虽然流程简单但是还是很杂的，容易乱：</span><br><span class="line">!<span class="literal">[]</span>(/Android-源码分析之MediaScanner-<span class="number">2.</span>md/<span class="number">1.</span>png)</span><br></pre></td></tr></table></figure>
<p>附录：帧标识的含义</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">AENC    	Audio encryption</span><br><span class="line">APIC   		Attached picture</span><br><span class="line">COMM		Comments</span><br><span class="line">COMR		Commercial</span><br><span class="line">ENCR		Encryption <span class="keyword">method</span> registration</span><br><span class="line">EQUA		Equalization</span><br><span class="line">ETCO		Event <span class="keyword">timing</span> codes</span><br><span class="line">GEOB		General encapsulated <span class="keyword">object</span></span><br><span class="line">GRID		<span class="keyword">Group</span> identification registration</span><br><span class="line">IPLS		Involved people list</span><br><span class="line">LINK		Linked information</span><br><span class="line">MCDI		Music CD identifier</span><br><span class="line">MLLT 		MPEGlocation lookup <span class="keyword">table</span></span><br><span class="line">OWNE		Ownership</span><br><span class="line">PRIV		Private</span><br><span class="line">PCNT 		Playcounter</span><br><span class="line">POPM		Popularimeter</span><br><span class="line">POSS		Position synchronisation</span><br><span class="line">RBUF		Recommended buffer size</span><br><span class="line">RVAD		Relative volume adjustment</span><br><span class="line">RVRB		Reverb</span><br><span class="line">SYLT		Synchronized lyric/<span class="type">text</span></span><br><span class="line">SYTC		Synchronized tempo codes</span><br><span class="line">TALB		Album/Movie/<span class="keyword">Show</span> title</span><br><span class="line">TBPM 		BPM(beats per minute)</span><br><span class="line">TCOM		Composer</span><br><span class="line">TCON		Content <span class="keyword">type</span></span><br><span class="line">TCOP		Copyright message</span><br><span class="line">TDAT 		<span class="type">Date</span></span><br><span class="line">TDLY		Playlist delay</span><br><span class="line">TENC		Encoded <span class="keyword">by</span></span><br><span class="line"><span class="type">TEXT</span>		Lyricist/<span class="type">Text</span> writer</span><br><span class="line">TFLT 		Filetype</span><br><span class="line"><span class="type">TIME</span> 		<span class="type">Time</span></span><br><span class="line">TIT1		Content <span class="keyword">group</span> deion</span><br><span class="line">TIT2		Title/songname/content deion</span><br><span class="line">TIT3		Subtitle/Deion refinement</span><br><span class="line">TKEY		Initial key</span><br><span class="line">TLAN		<span class="keyword">Language</span>(s)</span><br><span class="line">TLEN		Length</span><br><span class="line">TMED		Media <span class="keyword">type</span></span><br><span class="line">TOAL		Original album/movie/<span class="keyword">show</span> title</span><br><span class="line">TOFN		Original filename</span><br><span class="line">TOLY		Original lyricist(s)/<span class="type">text</span> writer(s)</span><br><span class="line">TOPE		Original artist(s)/performer(s)</span><br><span class="line">TORY		Original <span class="keyword">release</span> year</span><br><span class="line">TOWN 		Fileowner/licensee</span><br><span class="line">TPE1 		Leadperformer(s)/Soloist(s)</span><br><span class="line">TPE2		Band/orchestra/accompaniment</span><br><span class="line">TPE3		Conductor/performer refinement</span><br><span class="line">TPE4		Interpreted, remixed, <span class="keyword">or</span> otherwise modified <span class="keyword">by</span></span><br><span class="line">TPOS 		Partof a <span class="keyword">set</span></span><br><span class="line">TPUB		Publisher</span><br><span class="line">TRCK		Track number/Position <span class="keyword">in</span> <span class="keyword">set</span></span><br><span class="line">TRDA		Recording dates</span><br><span class="line">TRSN		Internet radio station <span class="type">name</span></span><br><span class="line">TRSO		Internet radio station <span class="keyword">owner</span></span><br><span class="line">TSIZ 		Size</span><br><span class="line">TSRC 		ISRC(international standard recording code)</span><br><span class="line">TSSE		Software/Hardware <span class="keyword">and</span> settings used <span class="keyword">for</span> <span class="keyword">encoding</span></span><br><span class="line">TYER		Year</span><br><span class="line">TXXX 		Userdefined <span class="type">text</span> information</span><br><span class="line">UFID		<span class="keyword">Unique</span> file identifier</span><br><span class="line"><span class="keyword">USER</span>		Terms <span class="keyword">of</span> use</span><br><span class="line">USLT		Unsychronized lyric/<span class="type">text</span> tranion</span><br><span class="line">WCOM		Commercial information</span><br><span class="line">WCOP		Copyright/Legal information</span><br><span class="line">WOAF		Official audio file webpage</span><br><span class="line">WOAR		Official artist/performer webpage</span><br><span class="line">WOAS		Official audio source webpage</span><br><span class="line">WORS		Official internet radio station homepage</span><br><span class="line">WPAY		Payment</span><br><span class="line">WPUB		Publishers official webpage</span><br><span class="line">WXXX 		Userdefined URL link</span><br></pre></td></tr></table></figure>


        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Android-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">Android 源码分析</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/AOSP-源码/">AOSP 源码</a>
  </div>

</div>



<div class="comments-count">
	
	  	<span></span>
		<a href="/2016/07/29/Android-源码分析之MediaScanner-2/#comments" class="ds-thread-count comments-count-link" data-thread-key="2016/07/29/Android-源码分析之MediaScanner-2/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/07/28/Android-源码分析之MediaScanner/" title="Android-源码分析之MediaScanner[1]" itemprop="url">Android-源码分析之MediaScanner[1]</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Edgar" target="_blank" itemprop="author">Edgar</a>
		
  <p class="article-time">
    <time datetime="2016-07-28T04:37:45.000Z" itemprop="datePublished"> Published 2016-07-28</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>MediaScanner媒体扫描器顾名思义就是用于扫描手机内部多媒体文件的信息，并将这些信息存储到数据库中的模块。我们今天就针对MediaScanner这个模块进行分析学习一下：</p>
<h4 id="普通文件的扫描流程"><a href="#普通文件的扫描流程" class="headerlink" title="普通文件的扫描流程"></a>普通文件的扫描流程</h4><h5 id="扫描请求的接收者-MediaScannerReceiver"><a href="#扫描请求的接收者-MediaScannerReceiver" class="headerlink" title="扫描请求的接收者  MediaScannerReceiver"></a>扫描请求的接收者  MediaScannerReceiver</h5><p>MediaScannerReceiver 继承自BroadcastReceiver它是通过静态注册的方式进行注册的：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">receiver</span> <span class="attr">android:name</span>=<span class="string">&quot;MediaScannerReceiver&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.action.BOOT_COMPLETED&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.action.MEDIA_MOUNTED&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:scheme</span>=<span class="string">&quot;file&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.action.MEDIA_UNMOUNTED&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:scheme</span>=<span class="string">&quot;file&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.action.MEDIA_SCANNER_SCAN_FILE&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:scheme</span>=<span class="string">&quot;file&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">receiver</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>从上面的代码可以看出MediaScannerReceiver接受三种扫描请求广播：</p>
<ul>
<li>Intent.ACTION_BOOT_COMPLETED:开机广播，在收到开机广播后会扫描内部和外部存储路径下的多媒体文件。</li>
<li>Intent.ACTION_MEDIA_MOUNTED:在某个外部存储器加载的时候。</li>
<li>Intent.ACTION_MEDIA_UNMOUNTED: 在某个外部存储器卸载的时候</li>
<li>Intent.ACTION_MEDIA_SCANNER_SCAN_FILE：在接受到对某个文件进行扫描的请求的时候调用scanFile方法进行扫描。</li>
</ul>
<p>那每种广播到来的时候又会进行怎样的响应呢？</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public void on<span class="constructor">Receive(Context <span class="params">context</span>, Intent <span class="params">intent</span>)</span> &#123;</span><br><span class="line">    final String action = intent.get<span class="constructor">Action()</span>;</span><br><span class="line">    final Uri uri = intent.get<span class="constructor">Data()</span>;</span><br><span class="line">    <span class="comment">//收到开机广播后扫描</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="module-access"><span class="module"><span class="identifier">Intent</span>.</span><span class="module"><span class="identifier">ACTION_BOOT_COMPLETED</span>.</span></span>equals(action)) &#123;</span><br><span class="line">        <span class="comment">// Scan both internal and external storage</span></span><br><span class="line">         <span class="comment">//扫描内部存储器中/system/media里面的内容，存放的是铃声等多媒体文件</span></span><br><span class="line">        scan(context, MediaProvider.INTERNAL_VOLUME);</span><br><span class="line">        <span class="comment">//扫描手机的外部存储实际扫描的是/mnt/sdcard/</span></span><br><span class="line">        scan(context, MediaProvider.EXTERNAL_VOLUME);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (uri.get<span class="constructor">Scheme()</span>.equals(<span class="string">&quot;file&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">// handle intents related to external storage</span></span><br><span class="line">            String path = uri.get<span class="constructor">Path()</span>;</span><br><span class="line">            String externalStoragePath = <span class="module-access"><span class="module"><span class="identifier">Environment</span>.</span></span>get<span class="constructor">ExternalStorageDirectory()</span>.get<span class="constructor">Path()</span>;</span><br><span class="line">            String legacyPath = <span class="module-access"><span class="module"><span class="identifier">Environment</span>.</span></span>get<span class="constructor">LegacyExternalStorageDirectory()</span>.get<span class="constructor">Path()</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                path = <span class="keyword">new</span> <span class="constructor">File(<span class="params">path</span>)</span>.get<span class="constructor">CanonicalPath()</span>;</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                <span class="module-access"><span class="module"><span class="identifier">Log</span>.</span></span>e(TAG, <span class="string">&quot;couldn&#x27;t canonicalize &quot;</span> + path);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (path.starts<span class="constructor">With(<span class="params">legacyPath</span>)</span>) &#123;</span><br><span class="line">                path = externalStoragePath + path.substring(legacyPath.length<span class="literal">()</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="module-access"><span class="module"><span class="identifier">Log</span>.</span></span>d(TAG, <span class="string">&quot;action: &quot;</span> + action + <span class="string">&quot; path: &quot;</span> + path);</span><br><span class="line">            <span class="comment">//收到外部存储器加载完成广播的扫描</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="module-access"><span class="module"><span class="identifier">Intent</span>.</span><span class="module"><span class="identifier">ACTION_MEDIA_MOUNTED</span>.</span></span>equals(action)) &#123;</span><br><span class="line">                <span class="comment">// scan whenever any volume is mounted</span></span><br><span class="line">                scan(context, MediaProvider.EXTERNAL_VOLUME);</span><br><span class="line">                <span class="comment">//如果请求的是扫描路径，并且要扫描的属于外部存储路径则开始扫描</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="module-access"><span class="module"><span class="identifier">Intent</span>.</span><span class="module"><span class="identifier">ACTION_MEDIA_SCANNER_SCAN_FILE</span>.</span></span>equals(action)<span class="operator"> &amp;&amp;</span></span><br><span class="line"><span class="operator">                    </span>path != null<span class="operator"> &amp;&amp; </span>path.starts<span class="constructor">With(<span class="params">externalStoragePath</span> + <span class="string">&quot;/&quot;</span>)</span>) &#123;</span><br><span class="line">                scan<span class="constructor">File(<span class="params">context</span>, <span class="params">path</span>)</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看到整个扫描归结于scan和scanFile两个方法的调用。特别是scan方法既能够扫描外部存储又能扫描手机内存，唯一的区别是传入的参数不一样而已。我们接下来就来看下这部分的实现：</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">private void scan(Context <span class="built_in">context</span>, String volume) &#123;</span><br><span class="line">    Bundle <span class="built_in">args</span> = <span class="built_in">new</span> Bundle();</span><br><span class="line">    <span class="built_in">args</span>.putString(<span class="string">&quot;volume&quot;</span>, volume);</span><br><span class="line">    <span class="built_in">context</span>.startService(</span><br><span class="line">            <span class="built_in">new</span> Intent(<span class="built_in">context</span>, MediaScannerService.class).putExtras(<span class="built_in">args</span>));</span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line">private void scanFile(Context <span class="built_in">context</span>, String path) &#123;</span><br><span class="line">    Bundle <span class="built_in">args</span> = <span class="built_in">new</span> Bundle();</span><br><span class="line">    <span class="built_in">args</span>.putString(<span class="string">&quot;filepath&quot;</span>, path);</span><br><span class="line">    <span class="built_in">context</span>.startService(</span><br><span class="line">            <span class="built_in">new</span> Intent(<span class="built_in">context</span>, MediaScannerService.class).putExtras(<span class="built_in">args</span>));</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<p>很简单吧，就直接将路径传递给MediaScannerService就OK了，唯一的不同是携带数据的时候key不一样。</p>
<p>当调用startService后就会启动MediaScannerService，接下来就来看下MediaSannerService</p>
<h5 id="扫描处理的后台处理者-MediaScannerService"><a href="#扫描处理的后台处理者-MediaScannerService" class="headerlink" title="扫描处理的后台处理者 MediaScannerService"></a>扫描处理的后台处理者 MediaScannerService</h5><p>在Scan和ScanFile启动首次MediaScannerService的时候MediaScannerService会调用onCreate方法创建这个服务，在onCreate中最重要的工作是启动一个线程用于扫描任务，因为Service运行在主线程中，如果直接在Service中执行扫描任务的话会阻塞主线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">PowerManager</span> <span class="variable">pm</span> <span class="operator">=</span> (PowerManager)getSystemService(Context.POWER_SERVICE);</span><br><span class="line">    mWakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, TAG);</span><br><span class="line">    <span class="type">StorageManager</span> <span class="variable">storageManager</span> <span class="operator">=</span> (StorageManager)getSystemService(Context.STORAGE_SERVICE);</span><br><span class="line">    mExternalStoragePaths = storageManager.getVolumePaths();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start up the thread running the service.  Note that we create a</span></span><br><span class="line">    <span class="comment">// separate thread because the service normally runs in the process&#x27;s</span></span><br><span class="line">    <span class="comment">// main thread, which we don&#x27;t want to block.</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="literal">null</span>, <span class="built_in">this</span>, <span class="string">&quot;MediaScannerService&quot;</span>);</span><br><span class="line">    thr.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>那么在扫描线程thr中又是做了哪些工作呢？从run方法中可以看出在thr线程中主要是创建了一个ServiceHandler。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public void run<span class="literal">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// reduce priority below other background threads to avoid interfering</span></span><br><span class="line">    <span class="comment">// with other services at boot time.</span></span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">Process</span>.</span></span>set<span class="constructor">ThreadPriority(Process.THREAD_PRIORITY_BACKGROUND +Process.THREAD_PRIORITY_LESS_FAVORABLE)</span>;</span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">Looper</span>.</span></span>prepare<span class="literal">()</span>;</span><br><span class="line"></span><br><span class="line">    mServiceLooper = <span class="module-access"><span class="module"><span class="identifier">Looper</span>.</span></span>my<span class="constructor">Looper()</span>;</span><br><span class="line">    mServiceHandler = <span class="keyword">new</span> <span class="constructor">ServiceHandler()</span>;</span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">Looper</span>.</span></span>loop<span class="literal">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在之后调用startService的时候，MediaScannerService类中的onStartCommand方法将会被调用。在onStartCommand方法中向mServiceHandler发送扫描请求。在传递给mServiceHandler的消息中包含了从Intent中获取的extra信息，凭借着这个信息可以区分当前的扫描请求是扫描整个valum还是单个文件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">onStartCommand</span><span class="params">(Intent intent, <span class="type">int</span> flags, <span class="type">int</span> startId)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (mServiceHandler == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (intent == <span class="literal">null</span>) &#123;</span><br><span class="line">        Log.e(TAG, <span class="string">&quot;Intent is null in onStartCommand: &quot;</span>,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">NullPointerException</span>());</span><br><span class="line">        <span class="keyword">return</span> Service.START_NOT_STICKY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> mServiceHandler.obtainMessage();</span><br><span class="line">    msg.arg1 = startId;</span><br><span class="line">    msg.obj = intent.getExtras();</span><br><span class="line">    mServiceHandler.sendMessage(msg);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Try again later if we are killed before we can finish scanning.</span></span><br><span class="line">    <span class="keyword">return</span> Service.START_REDELIVER_INTENT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> final <span class="keyword">class</span> ServiceHandler extends Handler</span><br><span class="line">&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void handle<span class="constructor">Message(Message <span class="params">msg</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Bundle arguments = (Bundle) msg.obj;</span><br><span class="line">        String filePath = arguments.get<span class="constructor">String(<span class="string">&quot;filepath&quot;</span>)</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//这是扫描单个文件的情况</span></span><br><span class="line">            <span class="keyword">if</span> (filePath != null) &#123;</span><br><span class="line">                IBinder binder = arguments.get<span class="constructor">IBinder(<span class="string">&quot;listener&quot;</span>)</span>;</span><br><span class="line">                IMediaScannerListener listener = </span><br><span class="line">                        (binder<span class="operator"> == </span>null ? null : <span class="module-access"><span class="module"><span class="identifier">IMediaScannerListener</span>.</span><span class="module"><span class="identifier">Stub</span>.</span></span><span class="keyword">as</span><span class="constructor">Interface(<span class="params">binder</span>)</span>);</span><br><span class="line">                Uri uri = null;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//调用scanFile方法</span></span><br><span class="line">                    uri = scan<span class="constructor">File(<span class="params">filePath</span>, <span class="params">arguments</span>.<span class="params">getString</span>(<span class="string">&quot;mimetype&quot;</span>)</span>);</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                    <span class="module-access"><span class="module"><span class="identifier">Log</span>.</span></span>e(TAG, <span class="string">&quot;Exception scanning file&quot;</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (listener != null) &#123;</span><br><span class="line">                    listener.scan<span class="constructor">Completed(<span class="params">filePath</span>, <span class="params">uri</span>)</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="comment">//这是扫描一个目录的情况</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                String volume = arguments.get<span class="constructor">String(<span class="string">&quot;volume&quot;</span>)</span>;</span><br><span class="line">                String<span class="literal">[]</span> directories = null;</span><br><span class="line">                <span class="keyword">if</span> (<span class="module-access"><span class="module"><span class="identifier">MediaProvider</span>.</span><span class="module"><span class="identifier">INTERNAL_VOLUME</span>.</span></span>equals(volume)) &#123;</span><br><span class="line">                    <span class="comment">//这是扫描内部存储的情况</span></span><br><span class="line">                    <span class="comment">// scan internal media storage</span></span><br><span class="line">                    directories = <span class="keyword">new</span> String<span class="literal">[]</span> &#123;</span><br><span class="line">                            <span class="module-access"><span class="module"><span class="identifier">Environment</span>.</span></span>get<span class="constructor">RootDirectory()</span> + <span class="string">&quot;/media&quot;</span>,</span><br><span class="line">                            <span class="module-access"><span class="module"><span class="identifier">Environment</span>.</span></span>get<span class="constructor">OemDirectory()</span> + <span class="string">&quot;/media&quot;</span>,</span><br><span class="line">                    &#125;;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (<span class="module-access"><span class="module"><span class="identifier">MediaProvider</span>.</span><span class="module"><span class="identifier">EXTERNAL_VOLUME</span>.</span></span>equals(volume)) &#123;</span><br><span class="line">                    <span class="comment">// scan external storage volumes</span></span><br><span class="line">                    <span class="comment">//这是扫描外部存储的情况</span></span><br><span class="line">                    directories = mExternalStoragePaths;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (directories != null) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="literal">false</span>) <span class="module-access"><span class="module"><span class="identifier">Log</span>.</span></span>d(TAG, <span class="string">&quot;start scanning volume &quot;</span> + volume + <span class="string">&quot;: &quot;</span></span><br><span class="line">                            + <span class="module-access"><span class="module"><span class="identifier">Arrays</span>.</span></span><span class="keyword">to</span><span class="constructor">String(<span class="params">directories</span>)</span>);</span><br><span class="line">                    <span class="comment">//调用scan方法</span></span><br><span class="line">                    scan(directories, volume);</span><br><span class="line">                    <span class="keyword">if</span> (<span class="literal">false</span>) <span class="module-access"><span class="module"><span class="identifier">Log</span>.</span></span>d(TAG, <span class="string">&quot;done scanning volume &quot;</span> + volume);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            <span class="module-access"><span class="module"><span class="identifier">Log</span>.</span></span>e(TAG, <span class="string">&quot;Exception in handleMessage&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//扫描结束后退出服务</span></span><br><span class="line">        stop<span class="constructor">Self(<span class="params">msg</span>.<span class="params">arg1</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>从上面代码中可以看出在mServiceHandler方法中，首先提取Intent中携带的信息，如果有携带关键字为filepath的数据则说明的是需要扫描的为文件，则调用scanFile方法对指定文件路径的文件进行扫描，如果携带的是关键字为volume的数据则说明当前扫描请求为扫描加载卷，调用的方法为scan方法。</p>
<p>接下来我们重点关注对存储器加载卷的扫描过程。对单个文件的扫描原理大致相同。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> void scan(String<span class="literal">[]</span> directories, String volumeName) &#123;</span><br><span class="line">    Uri uri = <span class="module-access"><span class="module"><span class="identifier">Uri</span>.</span></span>parse(<span class="string">&quot;file://&quot;</span> + directories<span class="literal">[<span class="number">0</span>]</span>);</span><br><span class="line">    <span class="comment">// don&#x27;t sleep while scanning</span></span><br><span class="line">    <span class="comment">//获取唤醒锁，避免在扫描的时候手机发生睡眠</span></span><br><span class="line">    mWakeLock.acquire<span class="literal">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ContentValues values = <span class="keyword">new</span> <span class="constructor">ContentValues()</span>;</span><br><span class="line">        values.put(MediaStore.MEDIA_SCANNER_VOLUME, volumeName);</span><br><span class="line">        Uri scanUri = get<span class="constructor">ContentResolver()</span>.insert(<span class="module-access"><span class="module"><span class="identifier">MediaStore</span>.</span></span>get<span class="constructor">MediaScannerUri()</span>, values);</span><br><span class="line">            </span><br><span class="line">        <span class="comment">//发送ACTION_MEDIA_SCANNER_STARTED广播通知系统其他部件扫描即将开始</span></span><br><span class="line">        send<span class="constructor">Broadcast(<span class="params">new</span> Intent(Intent.ACTION_MEDIA_SCANNER_STARTED, <span class="params">uri</span>)</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (volumeName.equals(MediaProvider.EXTERNAL_VOLUME)) &#123;</span><br><span class="line">                <span class="keyword">open</span><span class="constructor">Database(<span class="params">volumeName</span>)</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//创建MediaScanner开始扫描</span></span><br><span class="line">            MediaScanner scanner = create<span class="constructor">MediaScanner()</span>;</span><br><span class="line">            scanner.scan<span class="constructor">Directories(<span class="params">directories</span>, <span class="params">volumeName</span>)</span>;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            <span class="module-access"><span class="module"><span class="identifier">Log</span>.</span></span>e(TAG, <span class="string">&quot;exception in MediaScanner.scan()&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        get<span class="constructor">ContentResolver()</span>.delete(scanUri, null, null);</span><br><span class="line"></span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        <span class="comment">//通知其他部件扫描结束</span></span><br><span class="line">        send<span class="constructor">Broadcast(<span class="params">new</span> Intent(Intent.ACTION_MEDIA_SCANNER_FINISHED, <span class="params">uri</span>)</span>);</span><br><span class="line">        <span class="comment">//释放唤醒锁</span></span><br><span class="line">        mWakeLock.release<span class="literal">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>于扫描过程是一个耗时的过程，因此在开始扫描之前必须获得电源锁，避免在扫描过程中手机休眠，在扫描结束后释放电源锁。在扫描开始之前会向系统发送一个Intent.ACTION_MEDIA_SCANNER_STARTED的广播，通知系统的其他部件扫描过程的开始，其他部件可以通过监听这个广播。来采取对应的处理，同样在扫描结束后会向系统发送一个Intent.ACTION_MEDIA_SCANNER_FINISHED广播。而扫描任务是通过创建一个MediaScanner对象，并调用scanDirectories方法来实现的。</p>
<p>在应用层转了一圈后终于进入frameworks层了，我们看下frameworks层的MediaScanner类<br>在MediaScanner类中首先加载media_jni库，并调用native_init这个native方法。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">static &#123;</span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>load<span class="constructor">Library(<span class="string">&quot;media_jni&quot;</span>)</span>;</span><br><span class="line">    native<span class="constructor">_init()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">public MediaScanner(Context c) &#123;</span><br><span class="line">    native_setup()<span class="comment">;</span></span><br><span class="line">    mContext <span class="operator">=</span> c<span class="comment">;</span></span><br><span class="line">    mPackageName <span class="operator">=</span> c.getPackageName()<span class="comment">;</span></span><br><span class="line">    mBitmapOptions.inSampleSize <span class="operator">=</span> <span class="number">1</span><span class="comment">;</span></span><br><span class="line">    mBitmapOptions.inJustDecodeBounds <span class="operator">=</span> true<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    setDefaultRingtoneFileNames()<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    mExternalStoragePath <span class="operator">=</span> Environment.getExternalStorageDirectory().getAbsolutePath()<span class="comment">;</span></span><br><span class="line">    mExternalIsEmulated <span class="operator">=</span> Environment.isExternalStorageEmulated()<span class="comment">;</span></span><br><span class="line">    //mClient.testGenreNameConverter()<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在MediaScanner的构造方法中最重要的是调用了native_setup()方法，native_setup也是一个native方法。<br>接下来我们看下native_init和native_setup这两个native方法。</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="literal">void</span></span><br><span class="line">android_media_MediaScanner_native_init(JNIEnv *env)</span><br><span class="line">&#123;</span><br><span class="line">    j<span class="keyword">class</span> <span class="title class_">clazz</span> = env-&gt;FindClass(kClassMediaScanner);</span><br><span class="line">    <span class="keyword">if</span> (clazz == NULL) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fields.context = env-&gt;GetFieldID(clazz, <span class="string">&quot;mNativeContext&quot;</span>, <span class="string">&quot;J&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fields.context == NULL) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>native_init负责获取MediaScanner中的mNativeContext变量并保存到fields.context<br>native_setup负责创建一个MediaScanner的子类StagefrightMediaScanner并将native_init获取到的上下文传给StagefrightMediaScanner对象。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">static void</span><br><span class="line">android<span class="constructor">_media_MediaScanner_native_setup(JNIEnv <span class="operator">*</span><span class="params">env</span>, <span class="params">jobject</span> <span class="params">thiz</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    MediaScanner *mp = <span class="keyword">new</span> StagefrightMediaScanner;</span><br><span class="line">    <span class="keyword">if</span> (mp<span class="operator"> == </span>NULL) &#123;</span><br><span class="line">        jni<span class="constructor">ThrowException(<span class="params">env</span>, <span class="params">kRunTimeException</span>, <span class="string">&quot;Out of memory&quot;</span>)</span>;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    env-&gt;<span class="constructor">SetLongField(<span class="params">thiz</span>, <span class="params">fields</span>.<span class="params">context</span>, (<span class="params">jlong</span>)</span>mp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着我们看下scanDirectories方法：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public void scan<span class="constructor">Directories(String[] <span class="params">directories</span>, String <span class="params">volumeName</span>)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//.......</span></span><br><span class="line">    <span class="comment">//1.扫描前预处理</span></span><br><span class="line">    initialize(volumeName);</span><br><span class="line">    <span class="comment">//2. 预扫描</span></span><br><span class="line">    prescan(null, <span class="literal">true</span>);</span><br><span class="line">    <span class="comment">//.......</span></span><br><span class="line">    <span class="keyword">if</span> (ENABLE_BULK_INSERTS) &#123;</span><br><span class="line">        <span class="comment">// create MediaInserter for bulk inserts</span></span><br><span class="line">        mMediaInserter = <span class="keyword">new</span> <span class="constructor">MediaInserter(<span class="params">mMediaProvider</span>, <span class="params">mPackageName</span>, 500)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; directories.length; i++) &#123;</span><br><span class="line">        <span class="comment">//3.扫描某个目录</span></span><br><span class="line">        process<span class="constructor">Directory(<span class="params">directories</span>[<span class="params">i</span>], <span class="params">mClient</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ENABLE_BULK_INSERTS) &#123;</span><br><span class="line">        <span class="comment">// flush remaining inserts</span></span><br><span class="line">        mMediaInserter.flush<span class="constructor">All()</span>;</span><br><span class="line">        mMediaInserter = null;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4. 扫描后处理</span></span><br><span class="line">    postscan(directories);</span><br><span class="line">    <span class="comment">//.......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面我们过滤掉所有的无关代码，我们看到整个扫描过程分成如下四个部分：</p>
<ul>
<li>initialize 扫描前预处理</li>
<li>prescan  预扫描</li>
<li>processDirectory扫描某个目录</li>
<li>postscan扫描后处理</li>
</ul>
<ol>
<li>扫描前预处理:<br>在initialize中主要初始化各种Uri地址：包括音频，视频，图像，图像缩略图，视频缩略图，文件等Uri地址。如果当前扫描的是外部存储器则需要处理播放列表以及风格。<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> void initialize(String volumeName) &#123;</span><br><span class="line">    </span><br><span class="line">    mMediaProvider = mContext.get<span class="constructor">ContentResolver()</span>.acquire<span class="constructor">Provider(<span class="string">&quot;media&quot;</span>)</span>;</span><br><span class="line">    mAudioUri = <span class="module-access"><span class="module"><span class="identifier">Audio</span>.</span><span class="module"><span class="identifier">Media</span>.</span></span>get<span class="constructor">ContentUri(<span class="params">volumeName</span>)</span>;</span><br><span class="line">    mVideoUri = <span class="module-access"><span class="module"><span class="identifier">Video</span>.</span><span class="module"><span class="identifier">Media</span>.</span></span>get<span class="constructor">ContentUri(<span class="params">volumeName</span>)</span>;</span><br><span class="line">    mImagesUri = <span class="module-access"><span class="module"><span class="identifier">Images</span>.</span><span class="module"><span class="identifier">Media</span>.</span></span>get<span class="constructor">ContentUri(<span class="params">volumeName</span>)</span>;</span><br><span class="line">    mThumbsUri = <span class="module-access"><span class="module"><span class="identifier">Images</span>.</span><span class="module"><span class="identifier">Thumbnails</span>.</span></span>get<span class="constructor">ContentUri(<span class="params">volumeName</span>)</span>;</span><br><span class="line">    mFilesUri = <span class="module-access"><span class="module"><span class="identifier">Files</span>.</span></span>get<span class="constructor">ContentUri(<span class="params">volumeName</span>)</span>;</span><br><span class="line">    mFilesUriNoNotify = mFilesUri.build<span class="constructor">Upon()</span>.append<span class="constructor">QueryParameter(<span class="string">&quot;nonotify&quot;</span>, <span class="string">&quot;1&quot;</span>)</span>.build<span class="literal">()</span>;</span><br><span class="line">    <span class="keyword">if</span> (!volumeName.equals(<span class="string">&quot;internal&quot;</span>)) &#123;</span><br><span class="line">        <span class="comment">// we only support playlists on external media</span></span><br><span class="line">        mProcessPlaylists = <span class="literal">true</span>;</span><br><span class="line">        mProcessGenres = <span class="literal">true</span>;</span><br><span class="line">        mPlaylistsUri = <span class="module-access"><span class="module"><span class="identifier">Playlists</span>.</span></span>get<span class="constructor">ContentUri(<span class="params">volumeName</span>)</span>;</span><br><span class="line">        mCaseInsensitivePaths = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>预扫描处理:<br>预扫描处理主要完成如下工作：</li>
</ol>
<ul>
<li>建立mPlayLists，因为在主扫描过程中对于播放列表是放到后面处理的，所以要新建一个mPlayLists用于存储播放列表文件记录，在beginFile扫到播放列表的时候需要先将其存储到mPlayLists中，等到postscan阶段对其进行统一处理。</li>
<li>扫描数据库并查找数据库中的每一项的本地文件是否存在，这里每次只扫描1000条数据，避免因为加载太多数据而出现卡顿现象，需要注意的是这里并不需要删除真实的文件这是因为如果文件确实消失了则不需要删除，如果是因为在扫描期间文件系统被卸载而后又挂载，这时候删除操作也是不需要的。如果当前项所对应的本地文件不存在，则看下是否是播放列表文件，如果不是播放列表文件则从数据库中删除。如果是播放列表类型则不删除，因为这有可能是由于播放列表信息被用户修改导致的。用户可以在播放器中删除它们。</li>
<li>在清空缺乏实际文件的数据项后重新查询图片数目，音频，视频的数目</li>
</ul>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> void prescan(String filePath, boolean prescanFiles) throws RemoteException &#123;</span><br><span class="line">    Cursor c = null;</span><br><span class="line">    String where = null;</span><br><span class="line">    String<span class="literal">[]</span> selectionArgs = null;</span><br><span class="line">    <span class="comment">//建立mPlayLists</span></span><br><span class="line">    <span class="keyword">if</span> (mPlayLists<span class="operator"> == </span>null) &#123;</span><br><span class="line">        mPlayLists = <span class="keyword">new</span> ArrayList&lt;FileEntry&gt;<span class="literal">()</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mPlayLists.clear<span class="literal">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//通过上述处理mPlayLists将会被清空，</span></span><br><span class="line">    <span class="keyword">if</span> (filePath != null) &#123;</span><br><span class="line">        <span class="comment">// query for only one file</span></span><br><span class="line">        where = <span class="module-access"><span class="module"><span class="identifier">MediaStore</span>.</span><span class="module"><span class="identifier">Files</span>.</span><span class="module"><span class="identifier">FileColumns</span>.</span><span class="module"><span class="identifier">_ID</span> </span></span>+ <span class="string">&quot;&gt;?&quot;</span> +<span class="string">&quot; AND &quot;</span> + Files.FileColumns.DATA + <span class="string">&quot;=?&quot;</span>;</span><br><span class="line">        selectionArgs = <span class="keyword">new</span> String<span class="literal">[]</span> &#123; <span class="string">&quot;&quot;</span>, filePath &#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        where = <span class="module-access"><span class="module"><span class="identifier">MediaStore</span>.</span><span class="module"><span class="identifier">Files</span>.</span><span class="module"><span class="identifier">FileColumns</span>.</span><span class="module"><span class="identifier">_ID</span> </span></span>+ <span class="string">&quot;&gt;?&quot;</span>;</span><br><span class="line">        selectionArgs = <span class="keyword">new</span> String<span class="literal">[]</span> &#123; <span class="string">&quot;&quot;</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Tell the provider to not delete the file.</span></span><br><span class="line">    <span class="comment">// If the file is truly gone the delete is unnecessary, and we want to avoid</span></span><br><span class="line">    <span class="comment">// accidentally deleting files that are really there (this may happen if the</span></span><br><span class="line">    <span class="comment">// filesystem is mounted and unmounted while the scanner is running).</span></span><br><span class="line">    <span class="comment">//在这里告诉provider不要删除那些通过扫描发现不存在的文件，</span></span><br><span class="line">    为的是避免在扫描的时候文件系统卸载了，但是在以后的时候又挂载上了。</span><br><span class="line">    Uri.Builder builder = mFilesUri.build<span class="constructor">Upon()</span>;</span><br><span class="line">    builder.append<span class="constructor">QueryParameter(MediaStore.PARAM_DELETE_DATA, <span class="string">&quot;false&quot;</span>)</span>;</span><br><span class="line">    MediaBulkDeleter deleter = <span class="keyword">new</span> <span class="constructor">MediaBulkDeleter(<span class="params">mMediaProvider</span>, <span class="params">mPackageName</span>,<span class="params">builder</span>.<span class="params">build</span>()</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Build the list of files from the content provider</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (prescanFiles) &#123;</span><br><span class="line">            <span class="comment">// First read existing files from the files table.</span></span><br><span class="line">            <span class="comment">// Because we&#x27;ll be deleting entries for missing files as we go,</span></span><br><span class="line">            <span class="comment">// we need to query the database in small batches, to avoid problems</span></span><br><span class="line">            <span class="comment">// with CursorWindow positioning.</span></span><br><span class="line">            long lastId = Long.MIN_VALUE;</span><br><span class="line">            Uri limitUri = mFilesUri.build<span class="constructor">Upon()</span>.append<span class="constructor">QueryParameter(<span class="string">&quot;limit&quot;</span>, <span class="string">&quot;1000&quot;</span>)</span>.build<span class="literal">()</span>;</span><br><span class="line">            mWasEmptyPriorToScan = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                selectionArgs<span class="literal">[<span class="number">0</span>]</span> = <span class="string">&quot;&quot;</span> + lastId;</span><br><span class="line">                <span class="keyword">if</span> (c != null) &#123;</span><br><span class="line">                    c.close<span class="literal">()</span>;</span><br><span class="line">                    c = null;</span><br><span class="line">                &#125;</span><br><span class="line">                c = mMediaProvider.query(mPackageName, limitUri, FILES_PRESCAN_PROJECTION,where, selectionArgs, <span class="module-access"><span class="module"><span class="identifier">MediaStore</span>.</span><span class="module"><span class="identifier">Files</span>.</span><span class="module"><span class="identifier">FileColumns</span>.</span><span class="module"><span class="identifier">_ID</span>,</span></span> null);</span><br><span class="line">                <span class="keyword">if</span> (c<span class="operator"> == </span>null) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">int</span> num = c.get<span class="constructor">Count()</span>;</span><br><span class="line">                <span class="keyword">if</span> (num<span class="operator"> == </span><span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//如果为0表示已经查询完全部文件信息,退出循环</span></span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                mWasEmptyPriorToScan = <span class="literal">false</span>;</span><br><span class="line">                <span class="comment">//开始获取这一批查询到的要扫描的路径等信息</span></span><br><span class="line">                <span class="keyword">while</span> (c.move<span class="constructor">ToNext()</span>) &#123;</span><br><span class="line">                    long rowId = c.get<span class="constructor">Long(FILES_PRESCAN_ID_COLUMN_INDEX)</span>;</span><br><span class="line">                    String path = c.get<span class="constructor">String(FILES_PRESCAN_PATH_COLUMN_INDEX)</span>;</span><br><span class="line">                    <span class="built_in">int</span> format = c.get<span class="constructor">Int(FILES_PRESCAN_FORMAT_COLUMN_INDEX)</span>;</span><br><span class="line">                    long lastModified = c.get<span class="constructor">Long(FILES_PRESCAN_DATE_MODIFIED_COLUMN_INDEX)</span>;</span><br><span class="line">                    lastId = rowId;</span><br><span class="line">                    <span class="comment">// Only consider entries with absolute path names.</span></span><br><span class="line">                    <span class="comment">// This allows storing URIs in the database without the</span></span><br><span class="line">                    <span class="comment">// media scanner removing them.</span></span><br><span class="line">                    <span class="keyword">if</span> (path != null<span class="operator"> &amp;&amp; </span>path.starts<span class="constructor">With(<span class="string">&quot;/&quot;</span>)</span>) &#123;</span><br><span class="line">                        boolean exists = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="comment">//查看数据库中对应项的本地文件是否存在</span></span><br><span class="line">                            exists = <span class="module-access"><span class="module"><span class="identifier">Os</span>.</span></span>access(path, android.system.OsConstants.F_OK);</span><br><span class="line">                        &#125; catch (ErrnoException e1) &#123;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (!exists<span class="operator"> &amp;&amp; </span>!<span class="module-access"><span class="module"><span class="identifier">MtpConstants</span>.</span></span>is<span class="constructor">AbstractObject(<span class="params">format</span>)</span>) &#123;</span><br><span class="line">                            <span class="comment">// do not delete missing playlists, since they may have been</span></span><br><span class="line">                            <span class="comment">// modified by the user.</span></span><br><span class="line">                            <span class="comment">// The user can delete them in the media player instead.</span></span><br><span class="line">                            <span class="comment">// instead, clear the path and lastModified fields in the row</span></span><br><span class="line">                            MediaFile.MediaFileType mediaFileType = <span class="module-access"><span class="module"><span class="identifier">MediaFile</span>.</span></span>get<span class="constructor">FileType(<span class="params">path</span>)</span>;</span><br><span class="line">                            <span class="built_in">int</span> fileType = (mediaFileType<span class="operator"> == </span>null ? <span class="number">0</span> : mediaFileType.fileType);</span><br><span class="line">                            </span><br><span class="line">                            <span class="comment">//如果当前记录在数据库中存在，在本地中文件并不存在，</span></span><br><span class="line">                            <span class="comment">//并且丢失的文件类型不是播放列表则将记录从数据库中删除</span></span><br><span class="line">                            <span class="comment">//如果是播放列表类型则不删除</span></span><br><span class="line">                            <span class="keyword">if</span> (!<span class="module-access"><span class="module"><span class="identifier">MediaFile</span>.</span></span>is<span class="constructor">PlayListFileType(<span class="params">fileType</span>)</span>) &#123;</span><br><span class="line">                                deleter.delete(rowId);</span><br><span class="line">                                <span class="keyword">if</span> (path.<span class="keyword">to</span><span class="constructor">LowerCase(Locale.US)</span>.ends<span class="constructor">With(<span class="string">&quot;/.nomedia&quot;</span>)</span>) &#123;</span><br><span class="line">                                    deleter.flush<span class="literal">()</span>;</span><br><span class="line">                                    String parent = <span class="keyword">new</span> <span class="constructor">File(<span class="params">path</span>)</span>.get<span class="constructor">Parent()</span>;</span><br><span class="line">                                    mMediaProvider.call(mPackageName, MediaStore.UNHIDE_CALL,parent, null);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    finally &#123;</span><br><span class="line">        <span class="keyword">if</span> (c != null) &#123;</span><br><span class="line">            c.close<span class="literal">()</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        deleter.flush<span class="literal">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// compute original size of images</span></span><br><span class="line">    mOriginalCount = <span class="number">0</span>;</span><br><span class="line">    c = mMediaProvider.query(mPackageName, mImagesUri, ID_PROJECTION, null, null, null, null);</span><br><span class="line">    <span class="keyword">if</span> (c != null) &#123;</span><br><span class="line">        mOriginalCount = c.get<span class="constructor">Count()</span>;</span><br><span class="line">        c.close<span class="literal">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过预处理保证数据库的文件记录与本地的实际文件将一一对应。紧接着就进入了扫描阶段在scanDirectories方法中将会对每个需要扫描的目录调用processDirectory(directories[i], mClient);方法。processDirectory是一个nativie方法。<br>在JNI层的android_media_MediaScanner_processDirectory将会被调用，在该方法中将会调用native层的MediaScanner.cpp的processDirectory方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line"><span class="title function_">android_media_MediaScanner_processDirectory</span><span class="params">(</span></span><br><span class="line"><span class="params">        JNIEnv *env, jobject thiz, jstring path, jobject client)</span></span><br><span class="line">&#123;</span><br><span class="line">    ALOGV(<span class="string">&quot;processDirectory&quot;</span>);</span><br><span class="line">    <span class="comment">//获得Native层的媒体扫描器</span></span><br><span class="line">    MediaScanner *mp = getNativeScanner_l(env, thiz);</span><br><span class="line">    <span class="comment">//.......</span></span><br><span class="line">    <span class="comment">//这里新建一个MyMediaScannerClient对象然后将其作为参数传递到processDirectory中</span></span><br><span class="line">    MyMediaScannerClient <span class="title function_">myClient</span><span class="params">(env, client)</span>;</span><br><span class="line">    <span class="type">MediaScanResult</span> <span class="variable">result</span> <span class="operator">=</span> mp-&gt;processDirectory(pathStr, myClient);</span><br><span class="line">    <span class="comment">//............</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line">MediaScanResult MediaScanner::processDirectory(</span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">char</span> *path, MediaScannerClient &amp;<span class="keyword">client</span>) &#123;</span><br><span class="line">    <span class="comment">//..........</span></span><br><span class="line">    <span class="keyword">client</span>.setLocale(locale());</span><br><span class="line">    <span class="comment">////调用doProcessDirectory处理</span></span><br><span class="line">    MediaScanResult result = doProcessDirectory(pathBuffer, pathRemaining, <span class="keyword">client</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们继续看下native层MediaScannner是如何完成扫描工作的：在MediaScannner中的processDirectory 方法中会对每个扫描路径调用一次processDirectory方法，这里的path为外部存储的或者内部存储的路径</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">MediaScanResult MediaScanner::doProcessDirectory(</span><br><span class="line">        <span class="keyword">char</span> *path, int pathRemaining, MediaScannerClient &amp;client, bool noMedia) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//.......</span></span><br><span class="line">    <span class="keyword">DIR</span>* <span class="keyword">dir</span> = opendir(path);</span><br><span class="line">    <span class="comment">//...........</span></span><br><span class="line">    MediaScanResult result = MEDIA_SCAN_RESULT_OK;</span><br><span class="line">    <span class="keyword">while</span> ((entry = readdir(<span class="keyword">dir</span>))) &#123;</span><br><span class="line">        <span class="keyword">if</span> (doProcessDirectoryEntry(path, pathRemaining, client, noMedia, entry, fileSpot) == MEDIA_SCAN_RESULT_ERROR) &#123;</span><br><span class="line">            result = MEDIA_SCAN_RESULT_ERROR;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    closedir(<span class="keyword">dir</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>doProcessDirectory这个方法会对每个主路径下的子文件调用doProcessDirectoryEntry进行扫描。<br>在开始扫描之前需事先判断当前的文件类型，并根据不同的文件类型进行不同的处理：</p>
<ul>
<li>如果当前文件类型为目录则直接调用client.scanFile方法，将扫描的工作交给MyMediaScannerClient，紧接着调用doProcessDirectory对该目录下的子文件再进行递归扫描。</li>
<li>如果当前文件类型为普通文件类型则直接调用client.scanFile方法，但是与文件类型为目录不同的是当文件类型为普通文件类型的时候调用client.scanFile的时候传入isDirectory参数为false。</li>
</ul>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">MediaScanResult MediaScanner::<span class="keyword">do</span><span class="constructor">ProcessDirectoryEntry(<span class="params">char</span> <span class="operator">*</span><span class="params">path</span>, <span class="params">int</span> <span class="params">pathRemaining</span>, MediaScannerClient &amp;<span class="params">client</span>, <span class="params">bool</span> <span class="params">noMedia</span>,<span class="params">struct</span> <span class="params">dirent</span><span class="operator">*</span> <span class="params">entry</span>, <span class="params">char</span><span class="operator">*</span> <span class="params">fileSpot</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> stat statbuf;</span><br><span class="line">    const <span class="built_in">char</span>* name = entry-&gt;d_name;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">type</span><span class="operator"> == </span>DT_DIR) &#123;</span><br><span class="line">        <span class="comment">// report the directory to the client</span></span><br><span class="line">        <span class="comment">//如果是目录类型</span></span><br><span class="line">        <span class="keyword">if</span> (stat(path, &amp;statbuf)<span class="operator"> == </span><span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//调用client.scanFile扫描目录：这里的isDirectory = true</span></span><br><span class="line">            status_t status = client.scan<span class="constructor">File(<span class="params">path</span>, <span class="params">statbuf</span>.<span class="params">st_mtime</span>, 0,<span class="params">true</span> <span class="operator">/</span><span class="operator">*</span><span class="params">isDirectory</span><span class="operator">*</span><span class="operator">/</span>, <span class="params">childNoMedia</span>)</span>;</span><br><span class="line">            <span class="keyword">if</span> (status) &#123;</span><br><span class="line">                return MEDIA_SCAN_RESULT_ERROR;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// and now process its contents</span></span><br><span class="line">        <span class="comment">//在这个地方开始扫描该目录的子文件</span></span><br><span class="line">        strcat(fileSpot, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">        MediaScanResult result = <span class="keyword">do</span><span class="constructor">ProcessDirectory(<span class="params">path</span>, <span class="params">pathRemaining</span> - <span class="params">nameLength</span> - 1, <span class="params">client</span>, <span class="params">childNoMedia</span>)</span>;</span><br><span class="line">        <span class="keyword">if</span> (result<span class="operator"> == </span>MEDIA_SCAN_RESULT_ERROR) &#123;</span><br><span class="line">            return MEDIA_SCAN_RESULT_ERROR;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">type</span><span class="operator"> == </span>DT_REG) &#123;</span><br><span class="line">        <span class="comment">//如果是普通文件  这里的isDirectory = false</span></span><br><span class="line">        stat(path, &amp;statbuf);</span><br><span class="line">        status_t status = client.scan<span class="constructor">File(<span class="params">path</span>, <span class="params">statbuf</span>.<span class="params">st_mtime</span>, <span class="params">statbuf</span>.<span class="params">st_size</span>,<span class="params">false</span> <span class="operator">/</span><span class="operator">*</span><span class="params">isDirectory</span><span class="operator">*</span><span class="operator">/</span>, <span class="params">noMedia</span>)</span>;</span><br><span class="line">        <span class="keyword">if</span> (status) &#123;</span><br><span class="line">            return MEDIA_SCAN_RESULT_ERROR;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return MEDIA_SCAN_RESULT_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不论怎样这里都是调用的client.scanFile只不过，传入的isDirectory不一样罢了。大家还记得client为MyMediaScannerClient吧，我们就来看下这个方法：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">status_t</span> <span class="title">scanFile</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* path, <span class="type">long</span> <span class="type">long</span> lastModified,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="type">long</span> <span class="type">long</span> fileSize, <span class="type">bool</span> isDirectory, <span class="type">bool</span> noMedia)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    mEnv-&gt;<span class="built_in">CallVoidMethod</span>(mClient, mScanFileMethodID, pathStr, lastModified,</span><br><span class="line">            fileSize, isDirectory, noMedia);</span><br><span class="line">     <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述方法中主要调用的是mEnv-&gt;CallVoidMethod(mClient, mScanFileMethodID, pathStr, lastModified,fileSize, isDirectory, noMedia);这是调用哪个方法呢？要解决这个问题必须找到mScanFileMethodID</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">MyMediaScannerClient(JNIEnv *env, jobject client)</span><br><span class="line">        :   mEnv(env),</span><br><span class="line">            <span class="function"><span class="title">mClient</span>(env-&gt;</span>NewGlobalRef(client)),</span><br><span class="line">            mScanFileMethodID(<span class="number">0</span>),</span><br><span class="line">            mHandleStringTagMethodID(<span class="number">0</span>),</span><br><span class="line">            mSetMimeTypeMethodID(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    jclass mediaScannerClientInterface =</span><br><span class="line">            <span class="function"><span class="title">env</span>-&gt;</span>FindClass(kClassMediaScannerClient);</span><br><span class="line">    <span class="comment">// static const char* const kClassMediaScannerClient =</span></span><br><span class="line">    <span class="string">&quot;android/media/MediaScannerClient&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (mediaScannerClientInterface == NULL) &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;Class %s not found&quot;</span>, kClassMediaScannerClient);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="function"><span class="title">mScanFileMethodID</span> = env-&gt;</span>GetMethodID(</span><br><span class="line">                                mediaScannerClientInterface,</span><br><span class="line">                                <span class="string">&quot;scanFile&quot;</span>,</span><br><span class="line">                                <span class="string">&quot;(Ljava/lang/String;JJZZ)V&quot;</span>);</span><br><span class="line">        <span class="function"><span class="title">mHandleStringTagMethodID</span> = env-&gt;</span>GetMethodID(</span><br><span class="line">                                mediaScannerClientInterface,</span><br><span class="line">                                <span class="string">&quot;handleStringTag&quot;</span>,</span><br><span class="line">                                <span class="string">&quot;(Ljava/lang/String;Ljava/lang/String;)V&quot;</span>);</span><br><span class="line">        <span class="function"><span class="title">mSetMimeTypeMethodID</span> = env-&gt;</span>GetMethodID(</span><br><span class="line">                                mediaScannerClientInterface,</span><br><span class="line">                                <span class="string">&quot;setMimeType&quot;</span>,</span><br><span class="line">                                <span class="string">&quot;(Ljava/lang/String;)V&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面可以看出MyMediaScannerClient实例中的scanFile方法实际上是调用位于MediaScanner.java文件中的MyMediaScannerClient的ScanFile方法：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">@<span class="function">Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">scanFile</span><span class="params">(<span class="type">String</span> path, <span class="type">long</span> lastModified, <span class="type">long</span> fileSize,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">boolean</span> isDirectory, <span class="type">boolean</span> noMedia)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// This is the callback funtion from native codes.</span></span><br><span class="line">    <span class="comment">// Log.v(TAG, &quot;scanFile: &quot;+path);</span></span><br><span class="line">    <span class="built_in">doScanFile</span>(path, null, lastModified, fileSize, isDirectory, <span class="literal">false</span>, noMedia);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ScanFile方法很简单就直接调用doScanFile方法。在doScanFile方法中将会进入下一个重要的阶段—获取音频视频文件的TAG数据。但是在介绍这个重要阶段之前还是先介绍下beginFile。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Uri <span class="title function_">doScanFile</span><span class="params">(String path, String mimeType, <span class="type">long</span> lastModified,</span></span><br><span class="line"><span class="params">        <span class="type">long</span> fileSize, <span class="type">boolean</span> isDirectory, <span class="type">boolean</span> scanAlways, <span class="type">boolean</span> noMedia)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用beginFile</span></span><br><span class="line">    <span class="type">FileEntry</span> <span class="variable">entry</span> <span class="operator">=</span> beginFile(path, mimeType, lastModified,</span><br><span class="line">            fileSize, isDirectory, noMedia);</span><br><span class="line">           </span><br><span class="line">    <span class="keyword">if</span> (entry != <span class="literal">null</span> &amp;&amp; (entry.mLastModifiedChanged || scanAlways)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (noMedia) &#123;</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">lowpath</span> <span class="operator">=</span> path.toLowerCase(Locale.ROOT);</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">ringtones</span> <span class="operator">=</span> (lowpath.indexOf(RINGTONES_DIR) &gt; <span class="number">0</span>);</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">notifications</span> <span class="operator">=</span> (lowpath.indexOf(NOTIFICATIONS_DIR) &gt; <span class="number">0</span>);</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">alarms</span> <span class="operator">=</span> (lowpath.indexOf(ALARMS_DIR) &gt; <span class="number">0</span>);</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">podcasts</span> <span class="operator">=</span> (lowpath.indexOf(PODCAST_DIR) &gt; <span class="number">0</span>);</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">music</span> <span class="operator">=</span> (lowpath.indexOf(MUSIC_DIR) &gt; <span class="number">0</span>) ||</span><br><span class="line">                (!ringtones &amp;&amp; !notifications &amp;&amp; !alarms &amp;&amp; !podcasts);</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isaudio</span> <span class="operator">=</span> MediaFile.isAudioFileType(mFileType);</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isvideo</span> <span class="operator">=</span> MediaFile.isVideoFileType(mFileType);</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isimage</span> <span class="operator">=</span> MediaFile.isImageFileType(mFileType);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (isaudio || isvideo || isimage) &#123;</span><br><span class="line">                path = Environment.maybeTranslateEmulatedPathToInternal(<span class="keyword">new</span> <span class="title class_">File</span>(path))</span><br><span class="line">                        .getAbsolutePath();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果为音频或者视频文件抽取元数据</span></span><br><span class="line">            <span class="comment">// we only extract metadata for audio and video files</span></span><br><span class="line">            <span class="keyword">if</span> (isaudio || isvideo) &#123;</span><br><span class="line">                processFile(path, mimeType, <span class="built_in">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果是图像则调用processImageFile</span></span><br><span class="line">            <span class="keyword">if</span> (isimage) &#123;</span><br><span class="line">                processImageFile(path);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//调用endFile</span></span><br><span class="line">            result = endFile(entry, ringtones, notifications, alarms, music, podcasts);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>beginFile故名思议就是在扫描前进行的一些处理:</p>
<ul>
<li>如果当前扫描的文件是普通文件则确定当前普通文件的文件类型。</li>
<li>使用当前path参数到数据库中进行查询，这时候有两种情况，该文件的记录已经存在数据库中了，这时候使用path在数据库中找到对应的文件信息，并使用这些信息来创建一个FileEntry，如果当前的文件是新添加的文件，则在数据中并没有关于这个文件的信息，则new出一个新的FileEntry：<br>entry &#x3D; new FileEntry(0, path, lastModified,(isDirectory ? MtpConstants.FORMAT_ASSOCIATION : 0));</li>
<li>如果当前文件是播放列表类型则将其先存储到mPlayLists中，在主扫描进程中先不做处理。</li>
<li>清空元数据，为接下来的扫描做准备。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> FileEntry <span class="title function_">beginFile</span><span class="params">(String path, String mimeType, <span class="type">long</span> lastModified,<span class="type">long</span> fileSize, <span class="type">boolean</span> isDirectory, <span class="type">boolean</span> noMedia)</span> &#123;</span><br><span class="line">    mMimeType = mimeType;</span><br><span class="line">    mFileType = <span class="number">0</span>;</span><br><span class="line">    mFileSize = fileSize;</span><br><span class="line">    mIsDrm = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isDirectory) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!noMedia &amp;&amp; isNoMediaFile(path)) &#123;</span><br><span class="line">            noMedia = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mNoMedia = noMedia;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// try mimeType first, if it is specified</span></span><br><span class="line">        <span class="keyword">if</span> (mimeType != <span class="literal">null</span>) &#123;</span><br><span class="line">            mFileType = MediaFile.getFileTypeForMimeType(mimeType);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// if mimeType was not specified, compute file type based on file extension.</span></span><br><span class="line">        <span class="keyword">if</span> (mFileType == <span class="number">0</span>) &#123;</span><br><span class="line">            MediaFile.<span class="type">MediaFileType</span> <span class="variable">mediaFileType</span> <span class="operator">=</span> MediaFile.getFileType(path);</span><br><span class="line">            <span class="keyword">if</span> (mediaFileType != <span class="literal">null</span>) &#123;</span><br><span class="line">                mFileType = mediaFileType.fileType;</span><br><span class="line">                <span class="keyword">if</span> (mMimeType == <span class="literal">null</span>) &#123;</span><br><span class="line">                    mMimeType = mediaFileType.mimeType;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isDrmEnabled() &amp;&amp; MediaFile.isDrmFileType(mFileType)) &#123;</span><br><span class="line">            mFileType = getFileTypeFromDrm(path);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//使用path查询数据库，在数据库中找到对应的文件信息，</span></span><br><span class="line">    并使用这些信息来创建一个FileEntry</span><br><span class="line">    <span class="type">FileEntry</span> <span class="variable">entry</span> <span class="operator">=</span> makeEntryFor(path);</span><br><span class="line">    <span class="comment">// add some slack to avoid a rounding error</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">delta</span> <span class="operator">=</span> (entry != <span class="literal">null</span>) ? (lastModified - entry.mLastModified) : <span class="number">0</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">wasModified</span> <span class="operator">=</span> delta &gt; <span class="number">1</span> || delta &lt; -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (entry == <span class="literal">null</span> || wasModified) &#123;</span><br><span class="line">        <span class="keyword">if</span> (wasModified) &#123;</span><br><span class="line">            entry.mLastModified = lastModified;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            entry = <span class="keyword">new</span> <span class="title class_">FileEntry</span>(<span class="number">0</span>, path, lastModified,</span><br><span class="line">                    (isDirectory ? MtpConstants.FORMAT_ASSOCIATION : <span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        entry.mLastModifiedChanged = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">//如果当前类型为播放列表类型</span></span><br><span class="line">    <span class="keyword">if</span> (mProcessPlaylists &amp;&amp; MediaFile.isPlayListFileType(mFileType)) &#123;</span><br><span class="line">        <span class="comment">//将数据存储到队列中在后续的部分处理，不在主扫描过程中处理</span></span><br><span class="line">        mPlayLists.add(entry);</span><br><span class="line">        <span class="comment">// we don&#x27;t process playlists in the main scan, so return null</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// clear all the metadata</span></span><br><span class="line">    mArtist = <span class="literal">null</span>;</span><br><span class="line">    mAlbumArtist = <span class="literal">null</span>;</span><br><span class="line">    mAlbum = <span class="literal">null</span>;</span><br><span class="line">    mTitle = <span class="literal">null</span>;</span><br><span class="line">    mComposer = <span class="literal">null</span>;</span><br><span class="line">    mGenre = <span class="literal">null</span>;</span><br><span class="line">    mTrack = <span class="number">0</span>;</span><br><span class="line">    mYear = <span class="number">0</span>;</span><br><span class="line">    mDuration = <span class="number">0</span>;</span><br><span class="line">    mPath = path;</span><br><span class="line">    mLastModified = lastModified;</span><br><span class="line">    mWriter = <span class="literal">null</span>;</span><br><span class="line">    mCompilation = <span class="number">0</span>;</span><br><span class="line">    mWidth = <span class="number">0</span>;</span><br><span class="line">    mHeight = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> entry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>如果当前文件不是音频视频或者图像文件则直接在doScanFile中调用endFile将信息存储到数据库中。我们看下endFile这个方法。<br>在endFile方法中做了如下工作：</p>
<ul>
<li>如果歌手信息不存在则使用专辑作者作为歌手信息.</li>
<li>接着调用toValues方法将文件的基本信息添加到ContentValues中</li>
<li>对toValues方法添加的基本信息进行修正。</li>
<li>如果是新添加的音频文件则将传入的ringtones，notifications，alarms，music，podcasts添加到ContentValues中，如果是图片则从ExifInterface中获取图片的长度宽度，经纬度，时区信息。</li>
<li>如果当前扫描的文件是新增的则将当前的ContentValues插入到数据库中,如果当前的文件的记录在数据库中本来就有的则调用update对数据库原先存在的项进行更新。</li>
<li>更新Setting上的相关设置.</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Uri <span class="title function_">endFile</span><span class="params">(FileEntry entry, <span class="type">boolean</span> ringtones, <span class="type">boolean</span> notifications,</span></span><br><span class="line"><span class="params">        <span class="type">boolean</span> alarms, <span class="type">boolean</span> music, <span class="type">boolean</span> podcasts)</span></span><br><span class="line">        <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">    <span class="comment">// update database</span></span><br><span class="line">    <span class="comment">// use album artist if artist is missing</span></span><br><span class="line">    <span class="keyword">if</span> (mArtist == <span class="literal">null</span> || mArtist.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        mArtist = mAlbumArtist;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ContentValues</span> <span class="variable">values</span> <span class="operator">=</span> toValues();</span><br><span class="line">    <span class="type">String</span> <span class="variable">title</span> <span class="operator">=</span> values.getAsString(MediaStore.MediaColumns.TITLE);</span><br><span class="line">    <span class="keyword">if</span> (title == <span class="literal">null</span> || TextUtils.isEmpty(title.trim())) &#123;</span><br><span class="line">        title = MediaFile.getFileTitle(values.getAsString(MediaStore.MediaColumns.DATA));</span><br><span class="line">        values.put(MediaStore.MediaColumns.TITLE, title);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">album</span> <span class="operator">=</span> values.getAsString(Audio.Media.ALBUM);</span><br><span class="line">    <span class="keyword">if</span> (MediaStore.UNKNOWN_STRING.equals(album)) &#123;</span><br><span class="line">        album = values.getAsString(MediaStore.MediaColumns.DATA);</span><br><span class="line">        <span class="comment">// extract last path segment before file name</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">lastSlash</span> <span class="operator">=</span> album.lastIndexOf(<span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (lastSlash &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">previousSlash</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> album.indexOf(<span class="string">&#x27;/&#x27;</span>, previousSlash + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (idx &lt; <span class="number">0</span> || idx &gt;= lastSlash) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                previousSlash = idx;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (previousSlash != <span class="number">0</span>) &#123;</span><br><span class="line">                album = album.substring(previousSlash + <span class="number">1</span>, lastSlash);</span><br><span class="line">                values.put(Audio.Media.ALBUM, album);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="variable">rowId</span> <span class="operator">=</span> entry.mRowId;</span><br><span class="line">    <span class="keyword">if</span> (MediaFile.isAudioFileType(mFileType) &amp;&amp; (rowId == <span class="number">0</span> || mMtpObjectHandle != <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="comment">// Only set these for new entries. For existing entries, they</span></span><br><span class="line">        <span class="comment">// may have been modified later, and we want to keep the current</span></span><br><span class="line">        <span class="comment">// values so that custom ringtones still show up in the ringtone</span></span><br><span class="line">        <span class="comment">// picker.</span></span><br><span class="line">        values.put(Audio.Media.IS_RINGTONE, ringtones);</span><br><span class="line">        values.put(Audio.Media.IS_NOTIFICATION, notifications);</span><br><span class="line">        values.put(Audio.Media.IS_ALARM, alarms);</span><br><span class="line">        values.put(Audio.Media.IS_MUSIC, music);</span><br><span class="line">        values.put(Audio.Media.IS_PODCAST, podcasts);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mFileType == MediaFile.FILE_TYPE_JPEG &amp;&amp; !mNoMedia) &#123;</span><br><span class="line">        <span class="type">ExifInterface</span> <span class="variable">exif</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            exif = <span class="keyword">new</span> <span class="title class_">ExifInterface</span>(entry.mPath);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            <span class="comment">// exif is null</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (exif != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">float</span>[] latlng = <span class="keyword">new</span> <span class="title class_">float</span>[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">if</span> (exif.getLatLong(latlng)) &#123;</span><br><span class="line">                values.put(Images.Media.LATITUDE, latlng[<span class="number">0</span>]);</span><br><span class="line">                values.put(Images.Media.LONGITUDE, latlng[<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> exif.getGpsDateTime();</span><br><span class="line">            <span class="keyword">if</span> (time != -<span class="number">1</span>) &#123;</span><br><span class="line">                values.put(Images.Media.DATE_TAKEN, time);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// If no time zone information is available, we should consider using</span></span><br><span class="line">                <span class="comment">// EXIF local time as taken time if the difference between file time</span></span><br><span class="line">                <span class="comment">// and EXIF local time is not less than 1 Day, otherwise MediaProvider</span></span><br><span class="line">                <span class="comment">// will use file time as taken time.</span></span><br><span class="line">                time = exif.getDateTime();</span><br><span class="line">                <span class="keyword">if</span> (time != -<span class="number">1</span> &amp;&amp; Math.abs(mLastModified * <span class="number">1000</span> - time) &gt;= <span class="number">86400000</span>) &#123;</span><br><span class="line">                    values.put(Images.Media.DATE_TAKEN, time);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">orientation</span> <span class="operator">=</span> exif.getAttributeInt(</span><br><span class="line">                ExifInterface.TAG_ORIENTATION, -<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (orientation != -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// We only recognize a subset of orientation tag values.</span></span><br><span class="line">                <span class="type">int</span> degree;</span><br><span class="line">                <span class="keyword">switch</span>(orientation) &#123;</span><br><span class="line">                    <span class="keyword">case</span> ExifInterface.ORIENTATION_ROTATE_90:</span><br><span class="line">                        degree = <span class="number">90</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> ExifInterface.ORIENTATION_ROTATE_180:</span><br><span class="line">                        degree = <span class="number">180</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> ExifInterface.ORIENTATION_ROTATE_270:</span><br><span class="line">                        degree = <span class="number">270</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        degree = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                values.put(Images.Media.ORIENTATION, degree);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">Uri</span> <span class="variable">tableUri</span> <span class="operator">=</span> mFilesUri;</span><br><span class="line">    <span class="type">MediaInserter</span> <span class="variable">inserter</span> <span class="operator">=</span> mMediaInserter;</span><br><span class="line">    <span class="keyword">if</span> (!mNoMedia) &#123;</span><br><span class="line">        <span class="keyword">if</span> (MediaFile.isVideoFileType(mFileType)) &#123;</span><br><span class="line">            tableUri = mVideoUri;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (MediaFile.isImageFileType(mFileType)) &#123;</span><br><span class="line">            tableUri = mImagesUri;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (MediaFile.isAudioFileType(mFileType)) &#123;</span><br><span class="line">            tableUri = mAudioUri;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Uri</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">needToSetSettings</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (rowId == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mMtpObjectHandle != <span class="number">0</span>) &#123;</span><br><span class="line">            values.put(MediaStore.MediaColumns.MEDIA_SCANNER_NEW_OBJECT_ID, mMtpObjectHandle);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (tableUri == mFilesUri) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">format</span> <span class="operator">=</span> entry.mFormat;</span><br><span class="line">            <span class="keyword">if</span> (format == <span class="number">0</span>) &#123;</span><br><span class="line">                format = MediaFile.getFormatCode(entry.mPath, mMimeType);</span><br><span class="line">            &#125;</span><br><span class="line">            values.put(Files.FileColumns.FORMAT, format);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Setting a flag in order not to use bulk insert for the file related with</span></span><br><span class="line">        <span class="comment">// notifications, ringtones, and alarms, because the rowId of the inserted file is</span></span><br><span class="line">        <span class="comment">// needed.</span></span><br><span class="line">        <span class="keyword">if</span> (mWasEmptyPriorToScan) &#123;</span><br><span class="line">            <span class="keyword">if</span> (notifications &amp;&amp; !mDefaultNotificationSet) &#123;</span><br><span class="line">                <span class="keyword">if</span> (TextUtils.isEmpty(mDefaultNotificationFilename) ||</span><br><span class="line">                        doesPathHaveFilename(entry.mPath, mDefaultNotificationFilename)) &#123;</span><br><span class="line">                    needToSetSettings = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ringtones &amp;&amp; !mDefaultRingtoneSet) &#123;</span><br><span class="line">                <span class="keyword">if</span> (TextUtils.isEmpty(mDefaultRingtoneFilename) ||</span><br><span class="line">                        doesPathHaveFilename(entry.mPath, mDefaultRingtoneFilename)) &#123;</span><br><span class="line">                    needToSetSettings = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (alarms &amp;&amp; !mDefaultAlarmSet) &#123;</span><br><span class="line">                <span class="keyword">if</span> (TextUtils.isEmpty(mDefaultAlarmAlertFilename) ||</span><br><span class="line">                        doesPathHaveFilename(entry.mPath, mDefaultAlarmAlertFilename)) &#123;</span><br><span class="line">                    needToSetSettings = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// New file, insert it.</span></span><br><span class="line">        <span class="comment">// Directories need to be inserted before the files they contain, so they</span></span><br><span class="line">        <span class="comment">// get priority when bulk inserting.</span></span><br><span class="line">        <span class="comment">// If the rowId of the inserted file is needed, it gets inserted immediately,</span></span><br><span class="line">        <span class="comment">// bypassing the bulk inserter.</span></span><br><span class="line">        <span class="keyword">if</span> (inserter == <span class="literal">null</span> || needToSetSettings) &#123;</span><br><span class="line">            <span class="keyword">if</span> (inserter != <span class="literal">null</span>) &#123;</span><br><span class="line">                inserter.flushAll();</span><br><span class="line">            &#125;</span><br><span class="line">            result = mMediaProvider.insert(mPackageName, tableUri, values);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (entry.mFormat == MtpConstants.FORMAT_ASSOCIATION) &#123;</span><br><span class="line">            inserter.insertwithPriority(tableUri, values);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            inserter.insert(tableUri, values);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (result != <span class="literal">null</span>) &#123;</span><br><span class="line">            rowId = ContentUris.parseId(result);</span><br><span class="line">            entry.mRowId = rowId;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// updated file</span></span><br><span class="line">        result = ContentUris.withAppendedId(tableUri, rowId);</span><br><span class="line">        <span class="comment">// path should never change, and we want to avoid replacing mixed cased paths</span></span><br><span class="line">        <span class="comment">// with squashed lower case paths</span></span><br><span class="line">        values.remove(MediaStore.MediaColumns.DATA);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">mediaType</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (!MediaScanner.isNoMediaPath(entry.mPath)) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">fileType</span> <span class="operator">=</span> MediaFile.getFileTypeForMimeType(mMimeType);</span><br><span class="line">            <span class="keyword">if</span> (MediaFile.isAudioFileType(fileType)) &#123;</span><br><span class="line">                mediaType = FileColumns.MEDIA_TYPE_AUDIO;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (MediaFile.isVideoFileType(fileType)) &#123;</span><br><span class="line">                mediaType = FileColumns.MEDIA_TYPE_VIDEO;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (MediaFile.isImageFileType(fileType)) &#123;</span><br><span class="line">                mediaType = FileColumns.MEDIA_TYPE_IMAGE;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (MediaFile.isPlayListFileType(fileType)) &#123;</span><br><span class="line">                mediaType = FileColumns.MEDIA_TYPE_PLAYLIST;</span><br><span class="line">            &#125;</span><br><span class="line">            values.put(FileColumns.MEDIA_TYPE, mediaType);</span><br><span class="line">        &#125;</span><br><span class="line">        mMediaProvider.update(mPackageName, result, values, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(needToSetSettings) &#123;</span><br><span class="line">        <span class="keyword">if</span> (notifications) &#123;</span><br><span class="line">            setSettingIfNotSet(Settings.System.NOTIFICATION_SOUND, tableUri, rowId);</span><br><span class="line">            mDefaultNotificationSet = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ringtones) &#123;</span><br><span class="line">            setSettingIfNotSet(Settings.System.RINGTONE, tableUri, rowId);</span><br><span class="line">            mDefaultRingtoneSet = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (alarms) &#123;</span><br><span class="line">            setSettingIfNotSet(Settings.System.ALARM_ALERT, tableUri, rowId);</span><br><span class="line">            mDefaultAlarmSet = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到目前为止processDirectory方法的整个流程已经介绍完毕，如果是非视频音频图像文件则已经结束了整个扫描的过程，但是我们上面介绍的时候还忽略了播放列表文件。所以在下面的部分介绍播放列表文件，音频，视频，图像文件的处理。</p>
<h4 id="播放列表的处理"><a href="#播放列表的处理" class="headerlink" title="播放列表的处理:"></a>播放列表的处理:</h4><p>我们在介绍beginFile方法的时候说到在主扫描进程中并不对扫描到的播放列表进行处理，只是将其放到mPlayLists中。那么这些播放列表是什么时候处理呢？又将如何处理这些播放列表？在MediaScanner中播放列表文件的处理位于postscan方法中，这时候我们已经知道了存储器中有哪些多媒体文件。在processPlayLists方法中只处理最新的和上次扫描以后修改后的播放列表文件，通过获取播放列表的类型，再根据播放列表的类型调用不同的方法处理播放列表文件。</p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">void</span> <span class="title">postscan</span><span class="params">(String[] directories)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// handle playlists last, after we know what media files are on the storage.</span></span><br><span class="line">    <span class="comment">//如果当前扫描路径为外部存储路径则，则处理播放列表</span></span><br><span class="line">    <span class="keyword">if</span> (mProcessPlaylists) &#123;</span><br><span class="line">        <span class="comment">//只处理最新的和上次扫描以后修改后的播放列表文件,</span></span><br><span class="line">        <span class="comment">//获得最后的名字以及最后的修改时间,</span></span><br><span class="line">        <span class="comment">//并根据播放列表的类型调用不同的方法处理播放列表文件</span></span><br><span class="line">        processPlayLists();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mOriginalCount == <span class="number">0</span> &amp;&amp; mImagesUri.equals(Images.Media.getContentUri(<span class="string">&quot;external&quot;</span>)))</span><br><span class="line">        pruneDeadThumbnailFiles();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// allow GC to clean up</span></span><br><span class="line">    mPlayLists = <span class="keyword">null</span>;</span><br><span class="line">    mMediaProvider = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>processPlayLists方法中首先获取全部的音频文件，并使用全部的音频文件作为参数，传入processPlayList，这个参数在后续将会介绍，其实之所以传入全部音频文件是用于获取每个播放列表的Playlist Member（播放列表成员歌曲）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processPlayLists</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">        Iterator&lt;FileEntry&gt; iterator = mPlayLists.iterator();</span><br><span class="line">        <span class="type">Cursor</span> <span class="variable">fileList</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// use the files uri and projection because we need the format column,</span></span><br><span class="line">            <span class="comment">// but restrict the query to just audio files</span></span><br><span class="line">            /获取全部的音频文件</span><br><span class="line">            fileList = mMediaProvider.query(mPackageName, mFilesUri, FILES_PRESCAN_PROJECTION,</span><br><span class="line">                    <span class="string">&quot;media_type=2&quot;</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                <span class="type">FileEntry</span> <span class="variable">entry</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">                <span class="comment">// only process playlist files if they are new or have been modified since the last scan</span></span><br><span class="line">                <span class="comment">// 只处理最新的和上次扫描以后修改后的播放列表文件</span></span><br><span class="line">                <span class="keyword">if</span> (entry.mLastModifiedChanged) &#123;</span><br><span class="line">                    processPlayList(entry, fileList);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e1) &#123;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (fileList != <span class="literal">null</span>) &#123;</span><br><span class="line">                fileList.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>我们看下对每个播放列表是怎么处理的，在处理前必须确保有一个播放列表的名字，首先通过查找MediaStore.Audio.Playlists.NAME对应的值，看下是否存在，如果不存在则从MediaStore.MediaColumns.TITLE中获取，如果还是没有值，就再尝试从文件名中获取。如果当前的播放列表是新增的则往数据库中插入新的播放列表信息，并获取播放列表成员的Uri，如果当前播放列表存在的话就更新其内容并且删除原来的member Uri。最后获取播放列表文件的类型，根据不同的文件类型调用不同的方法调用不同的方法处理。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> void process<span class="constructor">PlayList(FileEntry <span class="params">entry</span>, Cursor <span class="params">fileList</span>)</span> throws RemoteException &#123;</span><br><span class="line">    </span><br><span class="line">    String path = entry.mPath;</span><br><span class="line">    ContentValues values = <span class="keyword">new</span> <span class="constructor">ContentValues()</span>;</span><br><span class="line">    <span class="built_in">int</span> lastSlash = path.last<span class="constructor">IndexOf(&#x27;<span class="operator">/</span>&#x27;)</span>;</span><br><span class="line">    <span class="keyword">if</span> (lastSlash &lt; <span class="number">0</span>) throw <span class="keyword">new</span> <span class="constructor">IllegalArgumentException(<span class="string">&quot;bad path &quot;</span> + <span class="params">path</span>)</span>;</span><br><span class="line">    Uri uri, membersUri;</span><br><span class="line">    <span class="comment">//从FileEnty中获取rowId</span></span><br><span class="line">    long rowId = entry.mRowId;</span><br><span class="line">    <span class="comment">// 确保有一个播放列表名字，首先查看MediaStore.Audio.Playlists.NAME</span></span><br><span class="line">    <span class="comment">// 再查看MediaStore.MediaColumns.TITLE 如果还是为空则获取最后的.后面的字符</span></span><br><span class="line">    String name = values.get<span class="constructor">AsString(MediaStore.Audio.Playlists.NAME)</span>;</span><br><span class="line">    <span class="keyword">if</span> (name<span class="operator"> == </span>null) &#123;</span><br><span class="line">        name = values.get<span class="constructor">AsString(MediaStore.MediaColumns.TITLE)</span>;</span><br><span class="line">        <span class="keyword">if</span> (name<span class="operator"> == </span>null) &#123;</span><br><span class="line">            <span class="comment">// 从文件中获取播放列表名字</span></span><br><span class="line">            <span class="built_in">int</span> lastDot = path.last<span class="constructor">IndexOf(&#x27;.&#x27;)</span>;</span><br><span class="line">            name = (lastDot &lt; <span class="number">0</span> ? path.substring(lastSlash + <span class="number">1</span>): </span><br><span class="line">                   path.substring(lastSlash + <span class="number">1</span>, lastDot));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将播放列表的名字和修改时间添加到数据库中</span></span><br><span class="line">    values.put(MediaStore.Audio.Playlists.NAME, name);</span><br><span class="line">    values.put(MediaStore.Audio.Playlists.DATE_MODIFIED, entry.mLastModified);</span><br><span class="line">    <span class="keyword">if</span> (rowId<span class="operator"> == </span><span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//如果不存在的话插入新的播放列表信息</span></span><br><span class="line">        values.put(MediaStore.Audio.Playlists.DATA, path);</span><br><span class="line">        <span class="comment">//这时候value包含NAME  DATA  DATE_MODIFIED</span></span><br><span class="line">        uri = mMediaProvider.insert(mPackageName, mPlaylistsUri, values);</span><br><span class="line">        rowId = <span class="module-access"><span class="module"><span class="identifier">ContentUris</span>.</span></span>parse<span class="constructor">Id(<span class="params">uri</span>)</span>;</span><br><span class="line">        <span class="comment">//获得插入的行id </span></span><br><span class="line">        <span class="comment">//获得播放列表成员的Uri</span></span><br><span class="line">        membersUri = <span class="module-access"><span class="module"><span class="identifier">Uri</span>.</span></span><span class="keyword">with</span><span class="constructor">AppendedPath(<span class="params">uri</span>, Playlists.Members.CONTENT_DIRECTORY)</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果存在的话就更新并且删除原来的member Uri</span></span><br><span class="line">        uri = <span class="module-access"><span class="module"><span class="identifier">ContentUris</span>.</span></span><span class="keyword">with</span><span class="constructor">AppendedId(<span class="params">mPlaylistsUri</span>, <span class="params">rowId</span>)</span>;</span><br><span class="line">        mMediaProvider.update(mPackageName, uri, values, null, null);</span><br><span class="line">        membersUri = <span class="module-access"><span class="module"><span class="identifier">Uri</span>.</span></span><span class="keyword">with</span><span class="constructor">AppendedPath(<span class="params">uri</span>, Playlists.Members.CONTENT_DIRECTORY)</span>;</span><br><span class="line">        mMediaProvider.delete(mPackageName, membersUri, null, null);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取播放列表的目录</span></span><br><span class="line">    String playListDirectory = path.substring(<span class="number">0</span>, lastSlash + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//获取播放列表的文件类型</span></span><br><span class="line">    MediaFile.MediaFileType mediaFileType = <span class="module-access"><span class="module"><span class="identifier">MediaFile</span>.</span></span>get<span class="constructor">FileType(<span class="params">path</span>)</span>;</span><br><span class="line">    <span class="built_in">int</span> fileType = (mediaFileType<span class="operator"> == </span>null ? <span class="number">0</span> : mediaFileType.fileType);</span><br><span class="line">    <span class="comment">//根据不同的文件类型调用不同的方法调用不同的方法处理</span></span><br><span class="line">    <span class="keyword">if</span> (fileType<span class="operator"> == </span>MediaFile.FILE_TYPE_M3U) &#123;</span><br><span class="line">        process<span class="constructor">M3uPlayList(<span class="params">path</span>, <span class="params">playListDirectory</span>, <span class="params">membersUri</span>, <span class="params">values</span>, <span class="params">fileList</span>)</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fileType<span class="operator"> == </span>MediaFile.FILE_TYPE_PLS) &#123;</span><br><span class="line">        process<span class="constructor">PlsPlayList(<span class="params">path</span>, <span class="params">playListDirectory</span>, <span class="params">membersUri</span>, <span class="params">values</span>, <span class="params">fileList</span>)</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fileType<span class="operator"> == </span>MediaFile.FILE_TYPE_WPL) &#123;</span><br><span class="line">        process<span class="constructor">WplPlayList(<span class="params">path</span>, <span class="params">playListDirectory</span>, <span class="params">membersUri</span>, <span class="params">values</span>, <span class="params">fileList</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果是M3U播放列表：则调用processM3uPlayList方法处理：<br>在processM3uPlayList方法打开播放列表文件，并读取播放列表内容，将读取到的播放列表成员记录添加到mPlsylist队列中调用processCachedPlaylist处理。</p>
<figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processM3uPlayList</span>(<span class="built_in">String</span> path, <span class="built_in">String</span> playListDirectory, Uri uri,</span><br><span class="line">        ContentValues values, Cursor fileList) &#123;</span><br><span class="line">    <span class="built_in">BufferedReader</span> reader = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        File f = <span class="keyword">new </span><span class="class title_">File</span>(path);</span><br><span class="line">        <span class="comment">//判断播放列表文件是否存在，如果存在则调用cachePlaylistEntry</span></span><br><span class="line">        <span class="comment">//读取后添加到mPlsylist队列中调用processCachedPlaylist处理</span></span><br><span class="line">        <span class="keyword">if</span> (f.<span class="property">exists</span>()) &#123;</span><br><span class="line">            reader = <span class="keyword">new </span><span class="class title_">BufferedReader</span>(<span class="keyword">new </span><span class="class title_">InputStreamReader</span>(<span class="keyword">new </span><span class="class title_">FileInputStream</span>(f)), </span><br><span class="line">            <span class="number">8192</span>);</span><br><span class="line">            <span class="built_in">String</span> <span class="built_in">line</span> = reader.<span class="property">readLine</span>();</span><br><span class="line">            <span class="comment">//清除播放列表缓冲列表</span></span><br><span class="line">            mPlaylistEntries.<span class="property">clear</span>();</span><br><span class="line">            <span class="keyword">while</span> (<span class="built_in">line</span> != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 忽略注释行</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">line</span>.<span class="property">length</span>() &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">line</span>.<span class="property">charAt</span>(<span class="number">0</span>) != <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">                    <span class="comment">//如果不是注释行，则表示为播放列表信息，则将其处理后添加到mPlsylist队列中</span></span><br><span class="line">                    <span class="title function_">cachePlaylistEntry</span>(<span class="built_in">line</span>, playListDirectory);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">line</span> = reader.<span class="property">readLine</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="title function_">processCachedPlaylist</span>(fileList, values, uri);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="title function_">catch</span> (IOException e) &#123;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (reader != <span class="literal">null</span>)</span><br><span class="line">                reader.<span class="property">close</span>();</span><br><span class="line">        &#125; <span class="title function_">catch</span> (IOException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果是PLS格式的播放列表则将包含“File &#x3D; ”开头的行，则将等号后面的内容读取出来（这些就是播放列表成员的记录）并存储到mPlsylist中，并调用processCachedPlaylist进行处理。</p>
<figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processPlsPlayList</span>(<span class="built_in">String</span> path, <span class="built_in">String</span> playListDirectory, Uri uri,</span><br><span class="line">    ContentValues values, Cursor fileList) &#123;</span><br><span class="line">    <span class="built_in">BufferedReader</span> reader = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        File f = <span class="keyword">new </span><span class="class title_">File</span>(path);</span><br><span class="line">        <span class="keyword">if</span> (f.<span class="property">exists</span>()) &#123;</span><br><span class="line">            reader = <span class="keyword">new </span><span class="class title_">BufferedReader</span>(</span><br><span class="line">            <span class="keyword">new </span><span class="class title_">InputStreamReader</span>(<span class="keyword">new </span><span class="class title_">FileInputStream</span>(f)), <span class="number">8192</span>);</span><br><span class="line">            <span class="built_in">String</span> <span class="built_in">line</span> = reader.<span class="property">readLine</span>();</span><br><span class="line">            mPlaylistEntries.<span class="property">clear</span>();</span><br><span class="line">            <span class="keyword">while</span> (<span class="built_in">line</span> != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//如果是File开头的行则表示是PLS格式的播放列表信息</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">line</span>.<span class="property">startsWith</span>(<span class="string">&quot;File&quot;</span>)) &#123;</span><br><span class="line">                    <span class="type">int</span> equals = <span class="built_in">line</span>.<span class="property">indexOf</span>(<span class="string">&#x27;=&#x27;</span>);</span><br><span class="line">                    <span class="keyword">if</span> (equals &gt; <span class="number">0</span>) &#123;</span><br><span class="line">             <span class="comment">//将=后面的内容添加到mPlsylist中，调用processCachedPlaylist进行处理</span></span><br><span class="line">                        <span class="title function_">cachePlaylistEntry</span>(<span class="built_in">line</span>.<span class="property">substring</span>(equals + <span class="number">1</span>), playListDirectory);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">line</span> = reader.<span class="property">readLine</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="title function_">processCachedPlaylist</span>(fileList, values, uri);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="title function_">catch</span> (IOException e) &#123;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (reader != <span class="literal">null</span>)</span><br><span class="line">                reader.<span class="property">close</span>();</span><br><span class="line">        &#125; <span class="title function_">catch</span> (IOException e) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果是WPL格式的播放列表文件则使用Xml解析器对其进行解析。同样最后也是调用processCachedPlaylist对其中的播放列表进行处理。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="built_in">void</span> <span class="title function_">processWplPlayList</span>(<span class="params"><span class="built_in">String</span> path, <span class="built_in">String</span> playListDirectory, Uri uri,</span></span><br><span class="line"><span class="params">        ContentValues values, Cursor fileList</span>) &#123;</span><br><span class="line">    <span class="title class_">Xlog</span>.<span class="title function_">i</span>(<span class="variable constant_">TAG</span>,<span class="string">&quot;MediaScanner#processWplPlayList()&quot;</span>);</span><br><span class="line">    <span class="title class_">FileInputStream</span> fis = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="title class_">File</span> f = <span class="keyword">new</span> <span class="title class_">File</span>(path);</span><br><span class="line">        <span class="keyword">if</span> (f.<span class="title function_">exists</span>()) &#123;</span><br><span class="line">            fis = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(f);</span><br><span class="line">            mPlaylistEntries.<span class="title function_">clear</span>();</span><br><span class="line">            <span class="title class_">Xml</span>.<span class="title function_">parse</span>(fis, <span class="title class_">Xml</span>.<span class="title function_">findEncodingByName</span>(<span class="string">&quot;UTF-8&quot;</span>),</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">WplHandler</span>(playListDirectory, uri, fileList).<span class="title function_">getContentHandler</span>());</span><br><span class="line">            <span class="title function_">processCachedPlaylist</span>(fileList, values, uri);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (<span class="title class_">SAXException</span> e) &#123;</span><br><span class="line">        e.<span class="title function_">printStackTrace</span>();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (<span class="title class_">IOException</span> e) &#123;</span><br><span class="line">        e.<span class="title function_">printStackTrace</span>();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (fis != <span class="literal">null</span>)</span><br><span class="line">                fis.<span class="title function_">close</span>();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (<span class="title class_">IOException</span> e) &#123;</span><br><span class="line">            <span class="title class_">Xlog</span>.<span class="title function_">e</span>(<span class="variable constant_">TAG</span>, <span class="string">&quot;IOException in MediaScanner.processWplPlayList()&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>cachePlaylistEntry负责讲从播放列表文件中读取到的播放列表行进行处理后添加到mPlaylistEntries中。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">private <span class="type">void</span> cachePlaylistEntry(String <span class="type">line</span>, String playListDirectory) &#123;</span><br><span class="line">    PlaylistEntry entry = <span class="built_in">new</span> PlaylistEntry();</span><br><span class="line">    // 去除尾部的空白符</span><br><span class="line">    <span class="type">int</span> entryLength = <span class="type">line</span>.length();</span><br><span class="line">    <span class="keyword">while</span> (entryLength &gt; <span class="number">0</span> &amp;&amp; <span class="type">Character</span>.isWhitespace(<span class="type">line</span>.charAt(entryLength - <span class="number">1</span>))) entryLength<span class="comment">--;</span></span><br><span class="line">    <span class="keyword">if</span> (entryLength &lt; <span class="number">3</span>) <span class="keyword">return</span>;//如果小于三个字符则不合法</span><br><span class="line">    <span class="keyword">if</span> (entryLength &lt; <span class="type">line</span>.length()) <span class="type">line</span> = <span class="type">line</span>.substring(<span class="number">0</span>, entryLength);</span><br><span class="line">    //如果entryLength小于<span class="type">line</span>.length()表示尾部有空格则删除尾部的空白符</span><br><span class="line">    </span><br><span class="line">    //当前路径是否是绝对路径？</span><br><span class="line">    <span class="type">char</span> ch1 = <span class="type">line</span>.charAt(<span class="number">0</span>);</span><br><span class="line">    <span class="type">boolean</span> fullPath = (ch1 == <span class="string">&#x27;/&#x27;</span> ||</span><br><span class="line">            (<span class="type">Character</span>.isLetter(ch1) &amp;&amp; <span class="type">line</span>.charAt(<span class="number">1</span>) == <span class="string">&#x27;:&#x27;</span> &amp;&amp; <span class="type">line</span>.charAt(<span class="number">2</span>) == <span class="string">&#x27;\\&#x27;</span>));</span><br><span class="line">    // 如果是一个相对路径，则通过和playListDirectory进行合并构成全路径</span><br><span class="line">    <span class="keyword">if</span> (!fullPath)</span><br><span class="line">        <span class="type">line</span> = playListDirectory + <span class="type">line</span>;</span><br><span class="line">    entry.path = <span class="type">line</span>;</span><br><span class="line">    // 将全路径保存到mPlaylistEntries</span><br><span class="line">    mPlaylistEntries.<span class="keyword">add</span>(entry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>processCachedPlaylist方法中将数据库中全部音频文件数据与存储在mPlaylistEntries的当前播放列表的成员歌曲记录进行匹配，匹配过程是调用matchEntries方法来完成的，它会使用全部音频文件与mPlaylistEntries中未匹配的项进行对比，如果路径相同则认为找到匹配的，如果不完全一致就通过对比路径的各个部分，寻找最匹配的那个。 如果mPlaylistEntries中全部项都匹配了，则返回true。最后将mPlaylistEntries中的成员作为当前播放列表的playlist member添加到数据库中。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> void process<span class="constructor">CachedPlaylist(Cursor <span class="params">fileList</span>, ContentValues <span class="params">values</span>, Uri <span class="params">playlistUri</span>)</span> &#123;</span><br><span class="line">    fileList.move<span class="constructor">ToPosition(-1)</span>;</span><br><span class="line">    <span class="keyword">while</span> (fileList.move<span class="constructor">ToNext()</span>) &#123;</span><br><span class="line">        long rowId = fileList.get<span class="constructor">Long(FILES_PRESCAN_ID_COLUMN_INDEX)</span>;</span><br><span class="line">        String data = fileList.get<span class="constructor">String(FILES_PRESCAN_PATH_COLUMN_INDEX)</span>;</span><br><span class="line">        <span class="comment">// mPlaylistEntries中全部项都匹配了</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">match</span><span class="constructor">Entries(<span class="params">rowId</span>, <span class="params">data</span>)</span>) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">int</span> len = mPlaylistEntries.size<span class="literal">()</span>;</span><br><span class="line">    <span class="built_in">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        PlaylistEntry entry = mPlaylistEntries.get(i);</span><br><span class="line">        <span class="keyword">if</span> (entry.bestmatchlevel &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//将mPlaylistEntries中的成员作为当前播放列表的playlist member</span></span><br><span class="line">                <span class="comment">//添加到数据库中。</span></span><br><span class="line">                values.clear<span class="literal">()</span>;</span><br><span class="line">                values.put(MediaStore.Audio.Playlists.Members.PLAY_ORDER, </span><br><span class="line">                <span class="module-access"><span class="module"><span class="identifier">Integer</span>.</span></span>value<span class="constructor">Of(<span class="params">index</span>)</span>);</span><br><span class="line">                values.put(MediaStore.Audio.Playlists.Members.AUDIO_ID, </span><br><span class="line">                <span class="module-access"><span class="module"><span class="identifier">Long</span>.</span></span>value<span class="constructor">Of(<span class="params">entry</span>.<span class="params">bestmatchid</span>)</span>);</span><br><span class="line">                mMediaProvider.insert(mPackageName, playlistUri, values);</span><br><span class="line">                index++;</span><br><span class="line">            &#125; catch (RemoteException e) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">    mPlaylistEntries.clear<span class="literal">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> boolean <span class="keyword">match</span><span class="constructor">Entries(<span class="params">long</span> <span class="params">rowId</span>, String <span class="params">data</span>)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">int</span> len = mPlaylistEntries.size<span class="literal">()</span>;</span><br><span class="line">    boolean <span class="keyword">done</span> = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        PlaylistEntry entry = mPlaylistEntries.get(i);</span><br><span class="line">        <span class="comment">//如果entry.bestmatchlevel == Integer.MAX_VALUE 则表示已经被匹配了</span></span><br><span class="line">        <span class="comment">//这种情况下将当前的与mPlaylistEntries的进行比较</span></span><br><span class="line">        <span class="keyword">if</span> (entry.bestmatchlevel<span class="operator"> == </span>Integer.MAX_VALUE) &#123;</span><br><span class="line">            continue; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//开始比较的时候先将done置为false</span></span><br><span class="line">        <span class="keyword">done</span> = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//data字段已经匹配不需要进行路径匹配了</span></span><br><span class="line">        <span class="keyword">if</span> (data.equals<span class="constructor">IgnoreCase(<span class="params">entry</span>.<span class="params">path</span>)</span>) &#123;</span><br><span class="line">            entry.bestmatchid = rowId;</span><br><span class="line">            entry.bestmatchlevel = Integer.MAX_VALUE;</span><br><span class="line">            continue; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//通过比对路径的每个字段寻找最比配的那个播放列表</span></span><br><span class="line">        <span class="built_in">int</span> matchLength = <span class="keyword">match</span><span class="constructor">Paths(<span class="params">data</span>, <span class="params">entry</span>.<span class="params">path</span>)</span>;</span><br><span class="line">        <span class="keyword">if</span> (matchLength &gt; entry.bestmatchlevel) &#123;</span><br><span class="line">            entry.bestmatchid = rowId;</span><br><span class="line">            entry.bestmatchlevel = matchLength;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return <span class="keyword">done</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结以下，播放列表的处理是将播放列表文件进行解析，然后将播放列表文件中的成员添加到一个容器中，然后对容器进行遍历，并在数据库中对其进行匹配，如果匹配则添加到Playlist Member中</p>
<h4 id="缩略图处理："><a href="#缩略图处理：" class="headerlink" title="缩略图处理："></a>缩略图处理：</h4><p>在MediaScanner中对缩略图处理也是位于Postscan方法中。在pruneDeadThumbnailFiles方法中先获取DCIM&#x2F;thumbnails目录下的所有文件列表，在这个文件夹下存放的是所有的缩略图，而后再查看数据库中的视频和图像的缩略图信息，如果在数据库中存在该记录则表示该缩略图有用，从existingFiles中移除，到最后existingFiles中剩余的就是那些数据库中不需要的缩略图了，这些不需要的缩略图可以从DCIM&#x2F;.thumbnails中删除，最后删除Mini 缩略图文件。</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> void pruneDeadThumbnailFiles() &#123;</span><br><span class="line">    HashSet&lt;<span class="keyword">String</span>&gt; existingFiles = <span class="keyword">new</span> <span class="type">HashSet</span>&lt;<span class="keyword">String</span>&gt;();</span><br><span class="line">    <span class="keyword">String</span> directory = <span class="string">&quot;/sdcard/DCIM/.thumbnails&quot;</span>;</span><br><span class="line">    <span class="keyword">String</span> [] files = (<span class="keyword">new</span> <span class="type">File</span>(directory)).list();</span><br><span class="line">    Cursor c = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (files == <span class="literal">null</span>)</span><br><span class="line">        files = <span class="keyword">new</span> <span class="type">String</span>[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; files.length; i++) &#123;</span><br><span class="line">        <span class="keyword">String</span> fullPathString = directory + <span class="string">&quot;/&quot;</span> + files[i];</span><br><span class="line">        existingFiles.add(fullPathString);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        c = mMediaProvider.query(</span><br><span class="line">                mPackageName,</span><br><span class="line">                mThumbsUri,</span><br><span class="line">                <span class="keyword">new</span> <span class="type">String</span> [] &#123; <span class="string">&quot;_data&quot;</span> &#125;,</span><br><span class="line">                <span class="literal">null</span>,</span><br><span class="line">                <span class="literal">null</span>,</span><br><span class="line">                <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">        Log.v(TAG, <span class="string">&quot;pruneDeadThumbnailFiles... &quot;</span> + c);</span><br><span class="line">        <span class="keyword">if</span> (c != <span class="literal">null</span> &amp;&amp; c.moveToFirst()) &#123;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">String</span> fullPathString = c.getString(<span class="number">0</span>);</span><br><span class="line">                existingFiles.remove(fullPathString);</span><br><span class="line">            &#125; <span class="keyword">while</span> (c.moveToNext());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">String</span> fileToDelete : <span class="type">existingFiles</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="literal">false</span>)</span><br><span class="line">                Log.v(TAG, <span class="string">&quot;fileToDelete is &quot;</span> + fileToDelete);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                (<span class="keyword">new</span> <span class="type">File</span>(fileToDelete)).delete();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SecurityException ex) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Log.v(TAG, <span class="string">&quot;/pruneDeadThumbnailFiles... &quot;</span> + c);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        <span class="comment">// We will soon be killed...</span></span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        <span class="keyword">if</span> (c != <span class="literal">null</span>) &#123;</span><br><span class="line">            c.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="音频视频文件帧信息的获取"><a href="#音频视频文件帧信息的获取" class="headerlink" title="音频视频文件帧信息的获取"></a>音频视频文件帧信息的获取</h5><p>这部分比较复杂我们将放在下一篇博客中介绍</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Android-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">Android 源码分析</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/AOSP-源码/">AOSP 源码</a>
  </div>

</div>



<div class="comments-count">
	
	  	<span></span>
		<a href="/2016/07/28/Android-源码分析之MediaScanner/#comments" class="ds-thread-count comments-count-link" data-thread-key="2016/07/28/Android-源码分析之MediaScanner/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/07/28/Android-源码分析之Binder/" title="Android-源码分析之Binder" itemprop="url">Android-源码分析之Binder</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Edgar" target="_blank" itemprop="author">Edgar</a>
		
  <p class="article-time">
    <time datetime="2016-07-28T04:30:33.000Z" itemprop="datePublished"> Published 2016-07-28</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>下面这俩张是根据Android框架揭秘改编，这本书很适合初学者快速了解整个系统的大体结构，很形象生动，看代码的时候可以对着上面的图进行阅读会加深理解。下面这两张图就当作这篇博客的后续写作纲要吧。这段时间有点忙。只能有空的时候构思。</p>
<p><img src="/2016/07/28/Android-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BBinder/1.png"></p>
<p><img src="/2016/07/28/Android-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BBinder/2.png"></p>
<p><img src="/2016/07/28/Android-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BBinder/3.png"></p>
<p><img src="/2016/07/28/Android-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BBinder/4.png"></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Android-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">Android 源码分析</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/AOSP-源码/">AOSP 源码</a>
  </div>

</div>



<div class="comments-count">
	
	  	<span></span>
		<a href="/2016/07/28/Android-源码分析之Binder/#comments" class="ds-thread-count comments-count-link" data-thread-key="2016/07/28/Android-源码分析之Binder/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/07/28/Android-源码分析之AsyncTask/" title="Android-源码分析之AsyncTask" itemprop="url">Android-源码分析之AsyncTask</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Edgar" target="_blank" itemprop="author">Edgar</a>
		
  <p class="article-time">
    <time datetime="2016-07-28T04:28:09.000Z" itemprop="datePublished"> Published 2016-07-28</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>在之前的博客中已经介绍过了Handler，我们知道主线其实就是UI界面的守护进程一样，只有它才能修改UI界面上的元素，工作线程如果要更新界面需要通过主线程的Handler来更新，后来为了更加方便我们在子线程中更新UI元素，Android引入了一个AsyncTask类，通过它可以很方便地在后台线程和UI线程之间进行切换。极大得简便了我们的日常开发。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="symbol">AsyncTask</span>&lt;<span class="symbol">Params, <span class="symbol">Progress</span>, <span class="symbol">Result</span></span>&gt; </span><br></pre></td></tr></table></figure>
<p>AsyncTask是一个抽象类，如果要使用需要继承这个类，这里需要再提下这三个参数的含义：</p>
<ul>
<li>Params 表示在启动AsyncTask时传入的参数在后台任务中可以使用作为输入数据。如果不需要任何参数则可以传入Void</li>
<li>Progress 用于在后台任务在执行时调用onProgressUpdate方法在界面上显示当前的进度。</li>
<li>Result 表示当前后台任务完成后的返回结果</li>
</ul>
<p>具体的用法见Android进阶之多线程技术这篇博客，这里就不再作展开介绍了，我们接下来就以一个场景来展开介绍</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DownloadAsyncTask</span> <span class="keyword">extends</span> <span class="title class_ inherited__">AsyncTask</span>&lt;<span class="title class_">Void</span>, <span class="title class_">Integer</span>, <span class="title class_">Boolean</span>&gt; &#123;  </span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">protected</span> <span class="built_in">void</span> <span class="title function_">onPreExecute</span>(<span class="params"></span>) &#123;  </span><br><span class="line">        downloadProgressDialog.<span class="title function_">show</span>();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">protected</span> <span class="title class_">Boolean</span> <span class="title function_">doInBackground</span>(<span class="params">Void... params</span>) &#123;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;  </span><br><span class="line">                int process = <span class="title function_">downloadTask</span>();  </span><br><span class="line">                <span class="title function_">publishProgress</span>(process);  </span><br><span class="line">                <span class="keyword">if</span> (process &gt;= <span class="number">100</span>) &#123;  </span><br><span class="line">                    <span class="keyword">break</span>;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (<span class="title class_">Exception</span> e) &#123;  </span><br><span class="line">            <span class="title class_">Log</span>.<span class="title function_">e</span>(<span class="variable constant_">TAG</span>,<span class="string">&quot;There is something error !&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">protected</span> <span class="built_in">void</span> <span class="title function_">onProgressUpdate</span>(<span class="params">Integer... values</span>) &#123;  </span><br><span class="line">        downloadProgressDialog.<span class="title function_">setMessage</span>(<span class="string">&quot;下载进度：&quot;</span> + values[<span class="number">0</span>] + <span class="string">&quot;%&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">protected</span> <span class="built_in">void</span> <span class="title function_">onPostExecute</span>(<span class="params"><span class="built_in">Boolean</span> result</span>) &#123;  </span><br><span class="line">        downloadProgressDialog.<span class="title function_">dismiss</span>();  </span><br><span class="line">        <span class="keyword">if</span> (result) &#123;  </span><br><span class="line">            <span class="title class_">Toast</span>.<span class="title function_">makeText</span>(context, <span class="string">&quot;下载成功&quot;</span>, <span class="title class_">Toast</span>.<span class="property">LENGTH_SHORT</span>).<span class="title function_">show</span>();  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            <span class="title class_">Toast</span>.<span class="title function_">makeText</span>(context, <span class="string">&quot;下载失败&quot;</span>, <span class="title class_">Toast</span>.<span class="property">LENGTH_SHORT</span>).<span class="title function_">show</span>();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>这是一个比较简单的模拟下载的示例，在downloadTask我们使用一个简单的sleep后更新返回值，我們先來看下AsycTask的构造方法：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AsyncTask</span>()</span> &#123;</span><br><span class="line">    mWorker = <span class="keyword">new</span> WorkerRunnable&lt;Params, Result&gt;() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Result <span class="title">call</span>() throws Exception</span> &#123;</span><br><span class="line">            mTaskInvoked.<span class="keyword">set</span>(<span class="literal">true</span>);</span><br><span class="line">            Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</span><br><span class="line">            <span class="comment">//noinspection unchecked</span></span><br><span class="line">            Result result = doInBackground(mParams);</span><br><span class="line">            Binder.flushPendingCommands();</span><br><span class="line">            <span class="keyword">return</span> postResult(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    mFuture = <span class="keyword">new</span> FutureTask&lt;Result&gt;(mWorker) &#123;</span><br><span class="line">        @Override</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">done</span>()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                postResultIfNotInvoked(<span class="keyword">get</span>());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                android.util.Log.w(LOG_TAG, e);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;An error occurred while executing doInBackground()&quot;</span>,</span><br><span class="line">                        e.getCause());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (CancellationException e) &#123;</span><br><span class="line">                postResultIfNotInvoked(<span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里创建了一个WorkerRunnable对象以及FutureTask对象，我们在继续深入代码之前先对这两个类有大概的了解下：<br>WorkerRunnable实现了Callable接口,是一个有返回值的线程任务。它的返回结果就是Result，FutureTask可以获取到执行结果并且可以取消执行任务，通过传入Runnable或者Callable的任务给FutureTask，直接调用其run方法或者放入线程池执行，之后可以在外部通过FutureTask的get方法异步获取执行结果，FutureTask非常适合用于耗时的计算，主线程可以在完成自己的任务后，再去获取结果。另外，FutureTask还可以确保即使调用了多次run方法，它都只会执行一次Runnable或者Callable任务，或者通过cancel取消FutureTask的执行等。从上面描述是否看到了AyncTask的雏形。如果对这两个类想要有更多的了解可以通过如下两篇博客来了解，也相当于该自己留个坑后续再深入了解。</p>
<p><a target="_blank" rel="noopener" href="http://blog.csdn.net/linchunquan/article/details/22382487">http://blog.csdn.net/linchunquan/article/details/22382487</a><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/jackchen95/article/details/13631761">http://blog.csdn.net/jackchen95/article/details/13631761</a></p>
<p>好了我们继续：<br>上面讲到我们创建了一个WorkerRunnable对象后放到FutureTask中运行。那么整个初始化就结束了，接着就调用execute方法启动任务。</p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line">@MainThread</span><br><span class="line"><span class="keyword">public</span> final AsyncTask&lt;<span class="keyword">Params</span>, Progress, Result&gt; execute(<span class="keyword">Params</span><span class="params">...</span> <span class="keyword">params</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> executeOnExecutor(sDefaultExecutor, <span class="keyword">params</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>紧接着调用我们的executeOnExecutor方法。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"> @MainThread</span><br><span class="line"><span class="function"><span class="keyword">public</span> final AsyncTask&lt;Params, Progress, Result&gt; <span class="title">executeOnExecutor</span>(<span class="params">Executor exec,</span></span></span><br><span class="line"><span class="params"><span class="function">        Params... <span class="keyword">params</span></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mStatus != Status.PENDING) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (mStatus) &#123;</span><br><span class="line">            <span class="keyword">case</span> RUNNING:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Cannot execute task:&quot;</span></span><br><span class="line">                        + <span class="string">&quot; the task is already running.&quot;</span>);</span><br><span class="line">            <span class="keyword">case</span> FINISHED:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Cannot execute task:&quot;</span></span><br><span class="line">                        + <span class="string">&quot; the task has already been executed &quot;</span></span><br><span class="line">                        + <span class="string">&quot;(a task can be executed only once)&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mStatus = Status.RUNNING;</span><br><span class="line"></span><br><span class="line">    onPreExecute();</span><br><span class="line"></span><br><span class="line">    mWorker.mParams = <span class="keyword">params</span>;</span><br><span class="line">    exec.execute(mFuture);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里传入的exec参数为sDefaultExecutor，它的定义如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">Executor</span> <span class="variable">sDefaultExecutor</span> <span class="operator">=</span> SERIAL_EXECUTOR;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Executor</span> <span class="variable">SERIAL_EXECUTOR</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SerialExecutor</span>();</span><br></pre></td></tr></table></figure>
<p>也就是说它是一个SerialExecutor，看下代码中有如下注释：<br>说明这是一个串行的任务，每次只能执行一个，当当前的任务结束的时候才允许执行下一个。这也是很多时候提到的AyncTask的弊端。我门这里先不讲这些。继续我们的源码分析。</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">* An &#123;@link Executor&#125; <span class="keyword">that</span> executes tasks one <span class="keyword">at</span> a <span class="built_in">time</span> <span class="keyword">in</span> serial</span><br><span class="line">* order.  This serialization <span class="keyword">is</span> <span class="keyword">global</span> <span class="keyword">to</span> a particular process.</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<p>executeOnExecutor中会先判断当前的状态这里需要注意的是AysnTask是一个单次执行的任务，一旦执行结束后再调用excute就会抛出错误，必须重新new一个。在状态为PENDING的情况下说明当前的AsyncTask尚未执行，这时候会将当前状态置为Status.RUNNING<br>并在调用onPreExecute后调用SerialExecutor的execute方法。</p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SerialExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ArrayDeque&lt;Runnable&gt; mTasks = <span class="keyword">new</span> ArrayDeque&lt;Runnable&gt;();</span><br><span class="line">    Runnable mActive;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(<span class="keyword">final</span> Runnable r)</span> </span>&#123;</span><br><span class="line">        mTasks.offer(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    r.run();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    scheduleNext();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">if</span> (mActive == <span class="keyword">null</span>) &#123;</span><br><span class="line">            scheduleNext();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="function"><span class="keyword">void</span> <span class="title">scheduleNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((mActive = mTasks.poll()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            THREAD_POOL_EXECUTOR.execute(mActive);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在SerialExecutor的execute方法中我们调用了FutureTask 的 run()方法（FutureTask 代码不在framework层中而是在libcore下）</p>
<figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">public void run() &#123;</span><br><span class="line">    if (<span class="keyword">state</span> != NEW ||</span><br><span class="line">        !U.compareAndSwapObject(this, RUNNER, null, Thread.currentThread()))</span><br><span class="line">        return;</span><br><span class="line">    try &#123;</span><br><span class="line">        Callable<span class="variable">&lt;V&gt;</span> c = callable;</span><br><span class="line">        if (c != null &amp;&amp; <span class="keyword">state</span> == NEW) &#123;</span><br><span class="line">            V result;</span><br><span class="line">            boolean ran;</span><br><span class="line">            try &#123;</span><br><span class="line">                result = c.call();</span><br><span class="line">                ran = true;</span><br><span class="line">            &#125; catch (Throwable ex) &#123;</span><br><span class="line">                result = null;</span><br><span class="line">                ran = false;</span><br><span class="line">                <span class="built_in">set</span>Exception(ex);</span><br><span class="line">            &#125;</span><br><span class="line">            if (ran)</span><br><span class="line">                <span class="built_in">set</span>(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        // runner must be non-null until <span class="keyword">state</span> is settled <span class="keyword">to</span></span><br><span class="line">        // prevent concurrent calls <span class="keyword">to</span> run()</span><br><span class="line">        runner = null;</span><br><span class="line">        // <span class="keyword">state</span> must be re-read after nulling runner <span class="keyword">to</span> prevent</span><br><span class="line">        // leaked interrupts</span><br><span class="line">        int s = <span class="keyword">state</span>;</span><br><span class="line">        if (s &gt;= INTERRUPTING)</span><br><span class="line">            handlePossibleCancellationInterrupt(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里调用了</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">result</span> <span class="operator">=</span> c.call()</span><br></pre></td></tr></table></figure>

<p>也就是介绍构造函数时提到的WorkRunable，为了避免大家在这关键关头翻代码我直接再次贴在下面了。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">mWorker = <span class="keyword">new</span> WorkerRunnable&lt;Params, Result&gt;<span class="literal">()</span> &#123;</span><br><span class="line">    public Result call<span class="literal">()</span> throws Exception &#123;</span><br><span class="line">        mTaskInvoked.set(<span class="literal">true</span>);</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">Process</span>.</span></span>set<span class="constructor">ThreadPriority(Process.THREAD_PRIORITY_BACKGROUND)</span>;</span><br><span class="line">        <span class="comment">//noinspection unchecked</span></span><br><span class="line">        Result result = <span class="keyword">do</span><span class="constructor">InBackground(<span class="params">mParams</span>)</span>;</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">Binder</span>.</span></span>flush<span class="constructor">PendingCommands()</span>;</span><br><span class="line">        return post<span class="constructor">Result(<span class="params">result</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里大家是不是看到了doInBackground方法？那么执行完结果怎么返回到主线程呢？我们注意到最后通过postResult来将结果返回。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Result <span class="title function_">postResult</span><span class="params">(Result result)</span> &#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> getHandler().obtainMessage(MESSAGE_POST_RESULT,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">AsyncTaskResult</span>&lt;Result&gt;(<span class="built_in">this</span>, result));</span><br><span class="line">    message.sendToTarget();</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们继续看下这个方法：这里我们看到了Handler的影子。它会通过getHandler获取到一个Handler，这个Handler实际上就是MainHandler，我们拭目以待：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Handler <span class="title">getHandler</span>()</span> &#123;</span><br><span class="line">    synchronized (AsyncTask.<span class="keyword">class</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sHandler == <span class="literal">null</span>) &#123;</span><br><span class="line">            sHandler = <span class="keyword">new</span> InternalHandler();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sHandler;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> static <span class="class"><span class="keyword">class</span> <span class="title">InternalHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    public <span class="type">InternalHandler</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="type">Looper</span>.getMainLooper());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">&quot;unchecked&quot;</span>, <span class="string">&quot;RawUseOfParameterizedType&quot;</span>&#125;)</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    public void handleMessage(<span class="type">Message</span> msg) &#123;</span><br><span class="line">        <span class="type">AsyncTaskResult</span>&lt;?&gt; result = (<span class="type">AsyncTaskResult</span>&lt;?&gt;) msg.obj;</span><br><span class="line">        switch (msg.what) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="type">MESSAGE_POST_RESULT</span>:</span><br><span class="line">                <span class="comment">// There is only one result</span></span><br><span class="line">                result.mTask.finish(result.mData[<span class="number">0</span>]);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="type">MESSAGE_POST_PROGRESS</span>:</span><br><span class="line">                result.mTask.onProgressUpdate(result.mData);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看到了吧在创建InternalHandler的时候会将getMainLooper传入。通过这个Handler将MESSAGE_POST_RESULT消息发送给MainLooper，在消息循环中执行到这个消息的时候就调用InternalHandler的handleMessage，进而调用：</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line"><span class="literal">result</span>.mTask.finish(<span class="literal">result</span>.mData[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure>

<p>在紧接着就是调用finish方法，并将result作为参数传入：</p>
<figure class="highlight isbl"><table><tr><td class="code"><pre><span class="line"><span class="variable">private</span> <span class="variable">void</span> <span class="function"><span class="title">finish</span>(<span class="variable"><span class="class">Result</span></span> <span class="variable"><span class="class">result</span></span>) &#123;</span></span><br><span class="line"><span class="function">    <span class="variable"><span class="keyword">if</span></span> (<span class="title">isCancelled</span>()) &#123;</span></span><br><span class="line"><span class="function">        <span class="title">onCancelled</span>(<span class="variable"><span class="class">result</span></span>);</span></span><br><span class="line"><span class="function">    &#125; <span class="variable"><span class="keyword">else</span></span> &#123;</span></span><br><span class="line"><span class="function">        <span class="title">onPostExecute</span>(<span class="variable"><span class="class">result</span></span>);</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function">    <span class="variable">mStatus</span> = <span class="variable">Status.FINISHED</span>;</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>

<p>在这里就调用了onPostExecute方法。</p>
<p>最后再看下publishProgress这个方法：</p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WorkerThread</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="function"><span class="keyword">void</span> <span class="title">publishProgress</span><span class="params">(Progress... values)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isCancelled()) &#123;</span><br><span class="line">        getHandler().obtainMessage(MESSAGE_POST_PROGRESS,</span><br><span class="line">                <span class="keyword">new</span> AsyncTaskResult&lt;Progress&gt;(<span class="keyword">this</span>, values)).sendToTarget();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实如果上面的流程大家看得懂的话这里只要贴出代码就知道整个过程了：就是往MainLooper上发送MESSAGE_POST_PROGRESS消息InternalHandler收到消息后调用onProgressUpdate执行。</p>
<p>其实这里还涉及到SerialExecutor的串行执行的问题，这个将放在后面的博客中介绍。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Android-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">Android 源码分析</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/AOSP-源码/">AOSP 源码</a>
  </div>

</div>



<div class="comments-count">
	
	  	<span></span>
		<a href="/2016/07/28/Android-源码分析之AsyncTask/#comments" class="ds-thread-count comments-count-link" data-thread-key="2016/07/28/Android-源码分析之AsyncTask/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/07/28/Android-源码分析之HandlerThread/" title="Android-源码分析之HandlerThread" itemprop="url">Android-源码分析之HandlerThread</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Edgar" target="_blank" itemprop="author">Edgar</a>
		
  <p class="article-time">
    <time datetime="2016-07-28T03:55:15.000Z" itemprop="datePublished"> Published 2016-07-28</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>上一篇我们介绍了Handler 我们知道了一般的工作线程在默认情况下是没有消息处理能力的，如果要处理消息需要通过如下的代码来给普通的线程创建一个Looper。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NonMainThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">      public <span class="type">Handler</span> mHandler;</span><br><span class="line">      public void run() &#123;</span><br><span class="line">          <span class="type">Looper</span>.prepare();</span><br><span class="line">          mHandler = <span class="keyword">new</span> <span class="type">Handler</span>() &#123;</span><br><span class="line">              public void handleMessage(<span class="type">Message</span> msg) &#123;</span><br><span class="line">                  <span class="comment">// process incoming messages here</span></span><br><span class="line">              &#125;</span><br><span class="line">          &#125;;</span><br><span class="line">          <span class="type">Looper</span>.loop();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这个看上去不是很复杂，但是Android为我们提供了更为简单的实现方式–HandlerThread<br>首先我们还是先来看下它的使用方式：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">mHandlerThread = <span class="keyword">new</span> <span class="constructor">HandlerThread(<span class="string">&quot;WorkThread&quot;</span>)</span>;</span><br><span class="line">mHandlerThread.start<span class="literal">()</span>;</span><br><span class="line">mThreadHandler = <span class="keyword">new</span> <span class="constructor">Handler(<span class="params">mHandlerThread</span>.<span class="params">getLooper</span>()</span>) &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void handle<span class="constructor">Message(Message <span class="params">msg</span>)</span> &#123;</span><br><span class="line">        super.handle<span class="constructor">Message(<span class="params">msg</span>)</span>;</span><br><span class="line">         <span class="comment">//。。。。。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们接下来就来分析下这个过程：</p>
<p>首先在构造方法中接受一个参数为这个HandlerThread的名字，接着为我们的线程设置一个默认的优先级。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HandlerThread</span><span class="params">(<span class="type">String</span> name)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">super</span>(name);</span><br><span class="line">    mPriority = <span class="built_in">Process</span>.THREAD_PRIORITY_DEFAULT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果不想使用默认的优先级可以使用下面的构造方法：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HandlerThread</span><span class="params">(<span class="type">String</span> name, <span class="type">int</span> priority)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">super</span>(name);</span><br><span class="line">    mPriority = priority;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>紧接着在调用start方法后，run方法将会运行：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void run<span class="literal">()</span> &#123;</span><br><span class="line">    mTid = <span class="module-access"><span class="module"><span class="identifier">Process</span>.</span></span>my<span class="constructor">Tid()</span>;</span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">Looper</span>.</span></span>prepare<span class="literal">()</span>;</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        mLooper = <span class="module-access"><span class="module"><span class="identifier">Looper</span>.</span></span>my<span class="constructor">Looper()</span>;</span><br><span class="line">        notify<span class="constructor">All()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">Process</span>.</span></span>set<span class="constructor">ThreadPriority(<span class="params">mPriority</span>)</span>;</span><br><span class="line">    on<span class="constructor">LooperPrepared()</span>;</span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">Looper</span>.</span></span>loop<span class="literal">()</span>;</span><br><span class="line">    mTid = -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码很熟悉吧，其实该博客开头提到的那个代码，这里需要注意的是onLooperPrepared()这个方法是空的，我们如果需要在Looper循环开始前做些其他处理可以覆写这个方法。</p>
<p>接下来我们就可以调用getLooper方法返回已经处于loop状态的Looper了，也有了MessageQueue，就可以创建Handler处理其他线程发过来的消息了，注意的是这里是为了让非UI线程拥有处理其他线程发送过来消息能力才使用HandlerThread的，如果只需要具有消息发送的能力就不需要了，这个一定要清楚。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Looper getLooper() &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isAlive()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// If the thread has been started, wait until the looper has been created.</span></span><br><span class="line">    synchronized (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (isAlive() &amp;&amp; mLooper == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mLooper;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Android-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">Android 源码分析</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/AOSP-源码/">AOSP 源码</a>
  </div>

</div>



<div class="comments-count">
	
	  	<span></span>
		<a href="/2016/07/28/Android-源码分析之HandlerThread/#comments" class="ds-thread-count comments-count-link" data-thread-key="2016/07/28/Android-源码分析之HandlerThread/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/07/28/Android-源码分析之Handler-MessageQueue-Looper/" title="Android 源码分析之Handler MessageQueue Looper" itemprop="url">Android 源码分析之Handler MessageQueue Looper</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Edgar" target="_blank" itemprop="author">Edgar</a>
		
  <p class="article-time">
    <time datetime="2016-07-28T03:19:57.000Z" itemprop="datePublished"> Published 2016-07-28</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>我们首先看下我们的日常使用场景：<br>下面的例子中我们启动了一个线程在后台上作一些耗时间的操作，在操作结束后通过Handler向主线程发送一个消息更新文本，我们接下来就着这个情景对Handler源代码进行学习。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Handler handler = <span class="keyword">new</span> <span class="constructor">Handler()</span> &#123;</span><br><span class="line"></span><br><span class="line">     @Override</span><br><span class="line">     public void handle<span class="constructor">Message(Message <span class="params">msg</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (msg.what<span class="operator"> == </span>CHANGE_TEXT) &#123;</span><br><span class="line">            textView.set<span class="constructor">Text(String.<span class="params">valueOf</span>(<span class="params">msg</span>.<span class="params">obj</span>)</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        super.handle<span class="constructor">Message(<span class="params">msg</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//一些耗时的操作</span></span><br><span class="line">            Message msg = Message.obtain();</span><br><span class="line">            msg.what = CHANGE_TEXT;</span><br><span class="line">            msg.obj = <span class="string">&quot;Hello Handle&quot;</span> ;</span><br><span class="line">            <span class="keyword">handler</span>.sendMessage(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.start();</span><br></pre></td></tr></table></figure>
<p>首先是调用构造方法创建一个Handler对象，在构造方法的注释中我们看到一个比较有价值的提示：就是如果一个线程没有Looper那么它将不具备接受Message的能力，如果完这种线程中post消息那么将会有异常抛出。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Default constructor associates this handler with the &#123;@link Looper&#125; for the</span></span><br><span class="line"><span class="comment"> * current thread.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If this thread does not have a looper, this handler won&#x27;t be able to receive messages</span></span><br><span class="line"><span class="comment"> * so an exception is thrown.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span>()</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面的构造方法实际上是调用了Handler的另一个构造方法：</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Handler(Callback callback, <span class="keyword">boolean</span> async) &#123;</span><br><span class="line">    <span class="keyword">if</span> (FIND_POTENTIAL_LEAKS) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">Class</span>&lt;? <span class="keyword">extends</span> Handler&gt; klass = getClass();</span><br><span class="line">        <span class="keyword">if</span> ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;</span><br><span class="line">                (klass.getModifiers() &amp; Modifier.<span class="keyword">STATIC</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            Log.w(TAG, <span class="string">&quot;The following Handler class should be static or leaks might occur: &quot;</span> +</span><br><span class="line">                klass.getCanonicalName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mLooper = Looper.myLooper();</span><br><span class="line">    <span class="keyword">if</span> (mLooper == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">            <span class="string">&quot;Can&#x27;t create handler inside thread that has not called Looper.prepare()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mQueue = mLooper.mQueue;</span><br><span class="line">    mCallback = callback;</span><br><span class="line">    mAsynchronous = async;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个方法的开始部分会先判断当前的Handler类是否是匿名内部类，或者静态内部类，成员内部类，如果是这些的话需要将Handler声明成static，这个在之前的内存优化的博客中已经提到，如果是非静态的那么将会持有外部类的引用，很有可能造成内存泄露。<br>紧接着调用</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">Looper</span>.</span></span>my<span class="constructor">Looper()</span></span><br></pre></td></tr></table></figure>
<p>判断当前线程是否有Looper，这一点我们上面已经提到了如果没有Looper就没有处理消息的能力。那么什么时候才有Looper呢？<br>我们看下myLooper方法：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the Looper object associated with the current thread.  Returns</span></span><br><span class="line"><span class="comment"> * null if the calling thread is not associated with a Looper.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> @Nullable <span class="function">Looper <span class="title">myLooper</span>()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> sThreadLocal.<span class="keyword">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从注释上看我们可以很明显看出它是用于获取当前线程的Looper，那么这个Looper是什么时候设置的呢？ 我们接下来看：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span>(<span class="params">boolean quitAllowed</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (sThreadLocal.<span class="keyword">get</span>() != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Only one Looper may be created per thread&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sThreadLocal.<span class="keyword">set</span>(<span class="keyword">new</span> Looper(quitAllowed));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码中会先判断当前线程是否已经有Looper了，如果没有那么就添加一个，这就意味着一个线程至多只能有一个Looper。<br>那么我们上面的代码并没有调用这个prepare方法，为什么没有报错，原因在于主线程在创建的时候就已经随即创建了一个MainLooper，我们看源代码中prepare方法下面的prepareMainLooper方法：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepareMainLooper</span>()</span> &#123;</span><br><span class="line">    prepare(<span class="literal">false</span>);</span><br><span class="line">    synchronized (Looper.<span class="keyword">class</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sMainLooper != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;The main Looper has already been prepared.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sMainLooper = myLooper();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它会新建一个Looper后将其赋给sMainLooper。</p>
<p>我们可以搜索下这个方法在哪里被调用，我们可以看到AcitivityThread.java中的main方法中有调用该方法：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> <span class="title">main</span><span class="params">(<span class="type">String</span>[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//.......</span></span><br><span class="line">    Looper.<span class="built_in">prepareMainLooper</span>();</span><br><span class="line">    ActivityThread thread = <span class="keyword">new</span> <span class="built_in">ActivityThread</span>();</span><br><span class="line">    thread.<span class="built_in">attach</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (sMainThreadHandler == null) &#123;</span><br><span class="line">        sMainThreadHandler = thread.<span class="built_in">getHandler</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">        Looper.<span class="built_in">myLooper</span>().<span class="built_in">setMessageLogging</span>(<span class="keyword">new</span></span><br><span class="line">                <span class="built_in">LogPrinter</span>(Log.DEBUG, <span class="string">&quot;ActivityThread&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// End of event ActivityThreadMain.</span></span><br><span class="line">    Trace.<span class="built_in">traceEnd</span>(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">    Looper.<span class="built_in">loop</span>();</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">RuntimeException</span>(<span class="string">&quot;Main thread loop unexpectedly exited&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里主线程创建了一个Looper并添加到sThreadLocal中。</p>
<p>发送Message：<br>Handler发送消息的方式有很多种我们以最简单的sendMessage(Message msg)来作为分析对象：</p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">sendMessage</span><span class="params">(Message msg)</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">return</span> <span class="title">sendMessageDelayed</span><span class="params">(msg, <span class="number">0</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里会调用sendMessageDelayed(Message msg, long delayMillis)这个方法的第二个参数为延迟时间：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public final boolean send<span class="constructor">MessageDelayed(Message <span class="params">msg</span>, <span class="params">long</span> <span class="params">delayMillis</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (delayMillis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        delayMillis = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    return send<span class="constructor">MessageAtTime(<span class="params">msg</span>, SystemClock.<span class="params">uptimeMillis</span>()</span> + delayMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>sendMessageAtTime 会调用enqueueMessage方法将消息入队</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title">sendMessageAtTime</span><span class="params">(Message msg, <span class="type">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">    MessageQueue queue = mQueue;</span><br><span class="line">    <span class="keyword">if</span> (queue == null) &#123;</span><br><span class="line">        RuntimeException e = <span class="keyword">new</span> <span class="built_in">RuntimeException</span>(</span><br><span class="line">                <span class="keyword">this</span> + <span class="string">&quot; sendMessageAtTime() called with no mQueue&quot;</span>);</span><br><span class="line">        Log.<span class="built_in">w</span>(<span class="string">&quot;Looper&quot;</span>, e.<span class="built_in">getMessage</span>(), e);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">enqueueMessage</span>(queue, msg, uptimeMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> boolean enqueue<span class="constructor">Message(MessageQueue <span class="params">queue</span>, Message <span class="params">msg</span>, <span class="params">long</span> <span class="params">uptimeMillis</span>)</span> &#123;</span><br><span class="line">    msg.target = this;</span><br><span class="line">    <span class="keyword">if</span> (mAsynchronous) &#123;</span><br><span class="line">        msg.set<span class="constructor">Asynchronous(<span class="params">true</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    return queue.enqueue<span class="constructor">Message(<span class="params">msg</span>, <span class="params">uptimeMillis</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">boolean</span> enqueueMessage(Message msg, <span class="keyword">long</span> when) &#123;</span><br><span class="line">    <span class="keyword">if</span> (msg.target == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Message must have a target.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (msg.isInUse()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(msg + <span class="string">&quot; This message is already in use.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">            IllegalStateException e = <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                    msg.target + <span class="string">&quot; sending message to a Handler on a dead thread&quot;</span>);</span><br><span class="line">            Log.w(TAG, e.getMessage(), e);</span><br><span class="line">            msg.recycle();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        msg.markInUse();</span><br><span class="line">        msg.when = when;</span><br><span class="line">        Message p = mMessages;</span><br><span class="line">        <span class="keyword">boolean</span> needWake;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123;</span><br><span class="line">            <span class="comment">// New head, wake up the event queue if blocked.</span></span><br><span class="line">            msg.<span class="keyword">next</span> = p;</span><br><span class="line">            mMessages = msg;</span><br><span class="line">            needWake = mBlocked;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Inserted within the middle of the queue.  Usually we don&#x27;t have to wake</span></span><br><span class="line">            <span class="comment">// up the event queue unless there is a barrier at the head of the queue</span></span><br><span class="line">            <span class="comment">// and the message is the earliest asynchronous message in the queue.</span></span><br><span class="line">            needWake = mBlocked &amp;&amp; p.target == <span class="keyword">null</span> &amp;&amp; msg.isAsynchronous();</span><br><span class="line">            Message prev;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                prev = p;</span><br><span class="line">                p = p.<span class="keyword">next</span>;</span><br><span class="line">                <span class="keyword">if</span> (p == <span class="keyword">null</span> || when &lt; p.when) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class="line">                    needWake = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            msg.<span class="keyword">next</span> = p; <span class="comment">// invariant: p == prev.next</span></span><br><span class="line">            prev.<span class="keyword">next</span> = msg;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// We can assume mPtr != 0 because mQuitting is false.</span></span><br><span class="line">        <span class="keyword">if</span> (needWake) &#123;</span><br><span class="line">            nativeWake(mPtr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面代码中可以看出当收到一个Message后将会遍历整个消息队列，并将当前消息插入按照时间排序好的队列中。</p>
<p>那么消息已经进入队列了，那么什么时候被调用的呢？我们在看AcitivityThread.java中的main方法的时候除了prepareMainLooer外在最后调用了loop方法。这个其实就是一个消息循环，</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public static void loop<span class="literal">()</span> &#123;</span><br><span class="line">    final Looper me = my<span class="constructor">Looper()</span>;</span><br><span class="line">    <span class="keyword">if</span> (me<span class="operator"> == </span>null) &#123;</span><br><span class="line">        throw <span class="keyword">new</span> <span class="constructor">RuntimeException(<span class="string">&quot;No Looper; Looper.prepare() wasn&#x27;t called on this thread.&quot;</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    final MessageQueue queue = me.mQueue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make sure the identity of this thread is that of the local process,</span></span><br><span class="line">    <span class="comment">// and keep track of what that identity token actually is.</span></span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">Binder</span>.</span></span>clear<span class="constructor">CallingIdentity()</span>;</span><br><span class="line">    final long ident = <span class="module-access"><span class="module"><span class="identifier">Binder</span>.</span></span>clear<span class="constructor">CallingIdentity()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Message msg = queue.next<span class="literal">()</span>; <span class="comment">// might block</span></span><br><span class="line">        <span class="keyword">if</span> (msg<span class="operator"> == </span>null) &#123;</span><br><span class="line">            <span class="comment">// No message indicates that the message queue is quitting.</span></span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// This must be in a local variable, in case a UI event sets the logger</span></span><br><span class="line">        Printer logging = me.mLogging;</span><br><span class="line">        <span class="keyword">if</span> (logging != null) &#123;</span><br><span class="line">            logging.println(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot;</span> + msg.target + <span class="string">&quot; &quot;</span> +</span><br><span class="line">                    msg.callback + <span class="string">&quot;: &quot;</span> + msg.what);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        msg.target.dispatch<span class="constructor">Message(<span class="params">msg</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (logging != null) &#123;</span><br><span class="line">            logging.println(<span class="string">&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot;</span> + msg.target + <span class="string">&quot; &quot;</span> + msg.callback);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Make sure that during the course of dispatching the</span></span><br><span class="line">        <span class="comment">// identity of the thread wasn&#x27;t corrupted.</span></span><br><span class="line">        final long newIdent = <span class="module-access"><span class="module"><span class="identifier">Binder</span>.</span></span>clear<span class="constructor">CallingIdentity()</span>;</span><br><span class="line">        <span class="keyword">if</span> (ident != newIdent) &#123;</span><br><span class="line">            <span class="module-access"><span class="module"><span class="identifier">Log</span>.</span></span>wtf(TAG, <span class="string">&quot;Thread identity changed from 0x&quot;</span></span><br><span class="line">                    + <span class="module-access"><span class="module"><span class="identifier">Long</span>.</span></span><span class="keyword">to</span><span class="constructor">HexString(<span class="params">ident</span>)</span> + <span class="string">&quot; to 0x&quot;</span></span><br><span class="line">                    + <span class="module-access"><span class="module"><span class="identifier">Long</span>.</span></span><span class="keyword">to</span><span class="constructor">HexString(<span class="params">newIdent</span>)</span> + <span class="string">&quot; while dispatching to &quot;</span></span><br><span class="line">                    + msg.target.get<span class="constructor">Class()</span>.get<span class="constructor">Name()</span> + <span class="string">&quot; &quot;</span></span><br><span class="line">                    + msg.callback + <span class="string">&quot; what=&quot;</span> + msg.what);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        msg.recycle<span class="constructor">Unchecked()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码其实不难，很容易找到关键代码：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">msg.target.dispatch<span class="constructor">Message(<span class="params">msg</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>msg.target 是什么？其实它就是往MessageQueue中post消息的那个Handler，也就是说Looper会遍历整个消息队列，找到消息的Target然后调用它的dispatchMessage，下面我们来看下dispatchMessage方法，在dispatchMessage方法中调用的是handleMessage这个回调方法，这就是我们写的那个业务逻辑。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public void dispatch<span class="constructor">Message(Message <span class="params">msg</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (msg.callback != null) &#123;</span><br><span class="line">        handle<span class="constructor">Callback(<span class="params">msg</span>)</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mCallback != null) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mCallback.handle<span class="constructor">Message(<span class="params">msg</span>)</span>) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        handle<span class="constructor">Message(<span class="params">msg</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>读到这里可能细心的同学会留意到都没介绍队列中怎么决定某个消息何时处理，是的，这个其实是通过在loop中调用queue.next进行决定的。</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">Message <span class="keyword">next</span>() &#123;</span><br><span class="line">    <span class="comment">// Return here if the message loop has already quit and been disposed.</span></span><br><span class="line">    <span class="comment">// This can happen if the application tries to restart a looper after quit</span></span><br><span class="line">    <span class="comment">// which is not supported.</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> ptr = mPtr;</span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> pendingIdleHandlerCount = -<span class="number">1</span>; <span class="comment">// -1 only during first iteration</span></span><br><span class="line">    <span class="keyword">int</span> nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nextPollTimeoutMillis != <span class="number">0</span>) &#123;</span><br><span class="line">            Binder.flushPendingCommands();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">// Try to retrieve the next message.  Return if found.</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">            Message prevMsg = <span class="keyword">null</span>;</span><br><span class="line">            Message msg = mMessages;</span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="keyword">null</span> &amp;&amp; msg.target == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// Stalled by a barrier.  Find the next asynchronous message in the queue.</span></span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    prevMsg = msg;</span><br><span class="line">                    msg = msg.<span class="keyword">next</span>;</span><br><span class="line">                &#125; <span class="keyword">while</span> (msg != <span class="keyword">null</span> &amp;&amp; !msg.isAsynchronous());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (now &lt; msg.when) &#123;</span><br><span class="line">                    <span class="comment">// Next message is not ready.  Set a timeout to wake up when it is ready.</span></span><br><span class="line">                    nextPollTimeoutMillis = (<span class="keyword">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// Got a message.</span></span><br><span class="line">                    mBlocked = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (prevMsg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        prevMsg.<span class="keyword">next</span> = msg.<span class="keyword">next</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        mMessages = msg.<span class="keyword">next</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    msg.<span class="keyword">next</span> = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">&quot;Returning message: &quot;</span> + msg);</span><br><span class="line">                    msg.markInUse();</span><br><span class="line">                    <span class="keyword">return</span> msg;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// No more messages.</span></span><br><span class="line">                nextPollTimeoutMillis = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Process the quit message now that all pending messages have been handled.</span></span><br><span class="line">            <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">                dispose();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If first time idle, then get the number of idlers to run.</span></span><br><span class="line">            <span class="comment">// Idle handles only run if the queue is empty or if the first message</span></span><br><span class="line">            <span class="comment">// in the queue (possibly a barrier) is due to be handled in the future.</span></span><br><span class="line">            <span class="keyword">if</span> (pendingIdleHandlerCount &lt; <span class="number">0</span></span><br><span class="line">                    &amp;&amp; (mMessages == <span class="keyword">null</span> || now &lt; mMessages.when)) &#123;</span><br><span class="line">                pendingIdleHandlerCount = mIdleHandlers.<span class="keyword">size</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pendingIdleHandlerCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// No idle handlers to run.  Loop and wait some more.</span></span><br><span class="line">                mBlocked = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mPendingIdleHandlers == <span class="keyword">null</span>) &#123;</span><br><span class="line">                mPendingIdleHandlers = <span class="keyword">new</span> IdleHandler[Math.max(pendingIdleHandlerCount, <span class="number">4</span>)];</span><br><span class="line">            &#125;</span><br><span class="line">            mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Run the idle handlers.</span></span><br><span class="line">        <span class="comment">// We only ever reach this code block during the first iteration.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> IdleHandler idler = mPendingIdleHandlers[i];</span><br><span class="line">            mPendingIdleHandlers[i] = <span class="keyword">null</span>; <span class="comment">// release the reference to the handler</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">boolean</span> keep = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                keep = idler.queueIdle();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                Log.wtf(TAG, <span class="string">&quot;IdleHandler threw exception&quot;</span>, t);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!keep) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                    mIdleHandlers.remove(idler);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Reset the idle handler count to 0 so we do not run them again.</span></span><br><span class="line">        pendingIdleHandlerCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// While calling an idle handler, a new message could have been delivered</span></span><br><span class="line">        <span class="comment">// so go back and look again for a pending message without waiting.</span></span><br><span class="line">        nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的代码很长，但是其实关键的逻辑不难，它就是在一段时间内会去编历整个消息队列，查看Message中的when字段，并和当前的时间进行比对，如果达到要发送的时刻那么就返回这个Message给Looper。到此整个Handler源代码学习告一个小段落。我们来回顾下整个过程：</p>
<p>首先在AcitivityThread.java的main方法中会调用Looper.prepareMainLooper();创建一个MainLooper，然后调用Looper.loop();开启消息循环，这时候就可以允许Hanlder往主消息队列投递消息了，我们在主线程中创建Hanlder，在子线程中处理完耗时操作后就可以通过这个Handler完MainLooper中sentMessage，这些消息会通过调用enqueueMessage加入到消息队列中，注意这里的Message持有Handler的引用，这也是为什么需要将匿名内部类，静态内部类的Handler设置为static的原因了，否则Handler会持有外部类的引用，那么只要消息没及时处理，Handler所在的Activity或者Service一旦退出了就会造成内存泄露。<br>接下来在Looper.looper中会定期查看每个消息，如果时间到了就会调用消息所绑定Handler的dispatchMessage方法。在该方法中调用我们实现的handleMessage。</p>
<p>整个过程如下图所示：</p>
<p><img src="/2016/07/28/Android-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BHandler-MessageQueue-Looper/2.png"></p>
<p>再来站在全局的角度来一张图：</p>
<p><img src="/2016/07/28/Android-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BHandler-MessageQueue-Looper/1.png"></p>
<p>那么子线程可以有处理消息的能力吗，这个问题我们其实在上面已经说过了，默认情况是没有的，因为没有Looper，但是我们可以为一个子线程创建一个Looper这样就有了消息处理的能力了。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NonMainThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">      public <span class="type">Handler</span> mHandler;</span><br><span class="line">      public void run() &#123;</span><br><span class="line">          <span class="type">Looper</span>.prepare();</span><br><span class="line">          mHandler = <span class="keyword">new</span> <span class="type">Handler</span>() &#123;</span><br><span class="line">              public void handleMessage(<span class="type">Message</span> msg) &#123;</span><br><span class="line">                  <span class="comment">// process incoming messages here</span></span><br><span class="line">              &#125;</span><br><span class="line">          &#125;;</span><br><span class="line">          <span class="type">Looper</span>.loop();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Android-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">Android 源码分析</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/AOSP-源码/">AOSP 源码</a>
  </div>

</div>



<div class="comments-count">
	
	  	<span></span>
		<a href="/2016/07/28/Android-源码分析之Handler-MessageQueue-Looper/#comments" class="ds-thread-count comments-count-link" data-thread-key="2016/07/28/Android-源码分析之Handler-MessageQueue-Looper/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/07/27/Android-源码分析之ListView/" title="Android-源码分析之ListView" itemprop="url">Android-源码分析之ListView</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Edgar" target="_blank" itemprop="author">Edgar</a>
		
  <p class="article-time">
    <time datetime="2016-07-27T02:52:44.000Z" itemprop="datePublished"> Published 2016-07-27</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>在之前的博客已经介绍了ListView和Adapter了，但是之前篇文章只是着眼于基本的使用并没有讲到具体的背后的原理，这篇博客将会代大家过下ListView的源代码，让大家了解下整个原理：重点是ListView 缓存机制</p>
<h5 id="ListView-缓存机制的实现"><a href="#ListView-缓存机制的实现" class="headerlink" title="ListView 缓存机制的实现"></a>ListView 缓存机制的实现</h5><h6 id="RecycleBin原理概述"><a href="#RecycleBin原理概述" class="headerlink" title="RecycleBin原理概述"></a>RecycleBin原理概述</h6><p>在介绍RecycleBin原理之前我们先来介绍两个对象，ActiveView和ScrapView。我们知道ListView中包含两类子View，一类是可见的，显示在屏幕上的，这个就是ActiveView，另一类是不可见的这些被称为ScrapView（Scrap表示废弃的意思）ListView会把ScrapView删除的同时放入到RecycleBin中缓存起来。当我们滑动ListView的时候，就会导致有一部分元素进入屏幕，一些item从屏幕中移出，在移入的时候会从RecycleBin中取出一个ScrapView，将其作为convertView参数传递给Adapter的getView方法，从而达到View复用的目的，这样就不必在Adapter的getView方法中执行 LayoutInflater.inflate()方法了，从而大大提高整个性能，在编程的世界中有两个东西一直是矛盾的那就是时间和空间，而ListView中在这两者之间做了很好的平衡，个人觉得之所以可以做到这点还依赖于ListView item的一个特性，那就是每个item的布局是一致的只不过换了内容。</p>
<p><img src="/2016/07/27/Android-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BListView/1.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RecycleBin</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Views that were on screen at the start of layout. This array is populated at the start of</span></span><br><span class="line"><span class="comment">     * layout, and at the end of layout all view in mActiveViews are moved to mScrapViews.</span></span><br><span class="line"><span class="comment">     * Views in mActiveViews represent a contiguous range of Views, with position of the first</span></span><br><span class="line"><span class="comment">     * view store in mFirstActivePosition.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> View[] mActiveViews = <span class="keyword">new</span> <span class="title class_">View</span>[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Unsorted views that can be used by the adapter as a convert view.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;View&gt;[] mScrapViews;</span><br><span class="line">	<span class="comment">//.....</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Fill ActiveViews with all of the children of the AbsListView.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> childCount The minimum number of views mActiveViews should hold</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> firstActivePosition The position of the first view that will be stored in</span></span><br><span class="line"><span class="comment">     *        mActiveViews</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">fillActiveViews</span><span class="params">(<span class="type">int</span> childCount, <span class="type">int</span> firstActivePosition)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mActiveViews.length &lt; childCount) &#123;</span><br><span class="line">            mActiveViews = <span class="keyword">new</span> <span class="title class_">View</span>[childCount];</span><br><span class="line">        &#125;</span><br><span class="line">        mFirstActivePosition = firstActivePosition;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//noinspection MismatchedReadAndWriteOfArray</span></span><br><span class="line">        <span class="keyword">final</span> View[] activeViews = mActiveViews;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; childCount; i++) &#123;</span><br><span class="line">            <span class="type">View</span> <span class="variable">child</span> <span class="operator">=</span> getChildAt(i);</span><br><span class="line">            AbsListView.<span class="type">LayoutParams</span> <span class="variable">lp</span> <span class="operator">=</span> (AbsListView.LayoutParams) child.getLayoutParams();</span><br><span class="line">            <span class="comment">// Don&#x27;t put header or footer views into the scrap heap</span></span><br><span class="line">            <span class="keyword">if</span> (lp != <span class="literal">null</span> &amp;&amp; lp.viewType != ITEM_VIEW_TYPE_HEADER_OR_FOOTER) &#123;</span><br><span class="line">                <span class="comment">// Note:  We do place AdapterView.ITEM_VIEW_TYPE_IGNORE in active views.</span></span><br><span class="line">                <span class="comment">//        However, we will NOT place them into scrap views.</span></span><br><span class="line">                activeViews[i] = child;</span><br><span class="line">                <span class="comment">// Remember the position so that setupChild() doesn&#x27;t reset state.</span></span><br><span class="line">                lp.scrappedFromPosition = firstActivePosition + i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Get the view corresponding to the specified position. The view will be removed from</span></span><br><span class="line"><span class="comment">     * mActiveViews if it is found.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> position The position to look up in mActiveViews</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> The view if it is found, null otherwise</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    View <span class="title function_">getActiveView</span><span class="params">(<span class="type">int</span> position)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> position - mFirstActivePosition;</span><br><span class="line">        <span class="keyword">final</span> View[] activeViews = mActiveViews;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;=<span class="number">0</span> &amp;&amp; index &lt; activeViews.length) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">View</span> <span class="variable">match</span> <span class="operator">=</span> activeViews[index];</span><br><span class="line">            activeViews[index] = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">return</span> match;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> A view from the ScrapViews collection. These are unordered.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    View <span class="title function_">getScrapView</span><span class="params">(<span class="type">int</span> position)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">whichScrap</span> <span class="operator">=</span> mAdapter.getItemViewType(position);</span><br><span class="line">        <span class="keyword">if</span> (whichScrap &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mViewTypeCount == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> retrieveFromScrap(mCurrentScrap, position);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (whichScrap &lt; mScrapViews.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> retrieveFromScrap(mScrapViews[whichScrap], position);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Puts a view into the list of scrap views.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * If the list data hasn&#x27;t changed or the adapter has stable IDs, views</span></span><br><span class="line"><span class="comment">     * with transient state will be preserved for later retrieval.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> scrap The view to add</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> position The view&#x27;s position within its parent</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addScrapView</span><span class="params">(View scrap, <span class="type">int</span> position)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> AbsListView.<span class="type">LayoutParams</span> <span class="variable">lp</span> <span class="operator">=</span> (AbsListView.LayoutParams) scrap.getLayoutParams();</span><br><span class="line">        <span class="keyword">if</span> (lp == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// Can&#x27;t recycle, but we don&#x27;t know anything about the view.</span></span><br><span class="line">            <span class="comment">// Ignore it completely.</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        lp.scrappedFromPosition = position;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Remove but don&#x27;t scrap header or footer views, or views that</span></span><br><span class="line">        <span class="comment">// should otherwise not be recycled.</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">viewType</span> <span class="operator">=</span> lp.viewType;</span><br><span class="line">        <span class="keyword">if</span> (!shouldRecycleViewType(viewType)) &#123;</span><br><span class="line">            <span class="comment">// Can&#x27;t recycle. If it&#x27;s not a header or footer, which have</span></span><br><span class="line">            <span class="comment">// special handling and should be ignored, then skip the scrap</span></span><br><span class="line">            <span class="comment">// heap and we&#x27;ll fully detach the view later.</span></span><br><span class="line">            <span class="keyword">if</span> (viewType != ITEM_VIEW_TYPE_HEADER_OR_FOOTER) &#123;</span><br><span class="line">                getSkippedScrap().add(scrap);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        scrap.dispatchStartTemporaryDetach();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// The the accessibility state of the view may change while temporary</span></span><br><span class="line">        <span class="comment">// detached and we do not allow detached views to fire accessibility</span></span><br><span class="line">        <span class="comment">// events. So we are announcing that the subtree changed giving a chance</span></span><br><span class="line">        <span class="comment">// to clients holding on to a view in this subtree to refresh it.</span></span><br><span class="line">        notifyViewAccessibilityStateChangedIfNeeded(</span><br><span class="line">                AccessibilityEvent.CONTENT_CHANGE_TYPE_SUBTREE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Don&#x27;t scrap views that have transient state.</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">scrapHasTransientState</span> <span class="operator">=</span> scrap.hasTransientState();</span><br><span class="line">        <span class="keyword">if</span> (scrapHasTransientState) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mAdapter != <span class="literal">null</span> &amp;&amp; mAdapterHasStableIds) &#123;</span><br><span class="line">                <span class="comment">// If the adapter has stable IDs, we can reuse the view for</span></span><br><span class="line">                <span class="comment">// the same data.</span></span><br><span class="line">                <span class="keyword">if</span> (mTransientStateViewsById == <span class="literal">null</span>) &#123;</span><br><span class="line">                    mTransientStateViewsById = <span class="keyword">new</span> <span class="title class_">LongSparseArray</span>&lt;&gt;();</span><br><span class="line">                &#125;</span><br><span class="line">                mTransientStateViewsById.put(lp.itemId, scrap);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!mDataChanged) &#123;</span><br><span class="line">                <span class="comment">// If the data hasn&#x27;t changed, we can reuse the views at</span></span><br><span class="line">                <span class="comment">// their old positions.</span></span><br><span class="line">                <span class="keyword">if</span> (mTransientStateViews == <span class="literal">null</span>) &#123;</span><br><span class="line">                    mTransientStateViews = <span class="keyword">new</span> <span class="title class_">SparseArray</span>&lt;&gt;();</span><br><span class="line">                &#125;</span><br><span class="line">                mTransientStateViews.put(position, scrap);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Otherwise, we&#x27;ll have to remove the view and start over.</span></span><br><span class="line">                getSkippedScrap().add(scrap);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (mViewTypeCount == <span class="number">1</span>) &#123;</span><br><span class="line">                mCurrentScrap.add(scrap);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mScrapViews[viewType].add(scrap);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mRecyclerListener != <span class="literal">null</span>) &#123;</span><br><span class="line">                mRecyclerListener.onMovedToScrapHeap(scrap);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>RecycleBin的代码不是很大但是全部在博客讲解每个细节一来自己也不是完全懂每个细节，而且太关注细节我们常常会陷入细节而看不到整个原理，所以在分析源代码的时候，第一次不要太纠结细节，等到后面有疑问或者遇到问题需要解决的时候在认真分析对应的细节。<br>好了言归正传，我们上面贴出了RecycleBin的关键代码，正如上面介绍的RecycleBin包含mActiveViews，以及mScrapViews这两个主要成员变量，这里再插入一个分析源代码的方法就是：在学习源代码的时候先看英文注释，一般Android代码中大部分都有比较详细的注释的，通过这些注释往往会快速了解这东西到底是干吗的，到底要不要继续深入看下去。</p>
<p>我们看下mActiveViews 的注释：</p>
<blockquote>
<p>Views that were on screen at the start of layout. This array is populated at the start of layout, and at the end of layout all view in mActiveViews are moved to mScrapViews.Views in mActiveViews represent a contiguous range of Views, with position of the first view store in mFirstActivePosition.</p>
</blockquote>
<p>大体的意思就是它用于存放的是在每次开始布局之前位于屏幕上的那些item View，在布局结束后所有存在于mActiveViews的item View都会移到mScrapViews，mActiveViews存放的内容是连续的从mFirstActivePosition位置开始到屏幕所能显示下的最大item数目。</p>
<p>那么mScrapViews 又是什么呢？</p>
<blockquote>
<p>Unsorted views that can be used by the adapter as a convert view.</p>
</blockquote>
<p>从注释中可以了解到它是一个无序排列的列表，这些视图可以被传入Adapter中作为一个convert view.</p>
<ul>
<li>fillActiveViews 这个方法用于将AbsListView所有的子item 添加到ActiveViews中，它接收两个参数childCount表示屏幕显示的子item的数目，firstActivePosition表示屏幕上第一个item的位置。这个很简单。</li>
<li>getActiveView 这个方法将会传入位置参数，然后将会从mActiveViews中寻找并取出item View，如果找到在mActiveViews中对应的这个位置View将会被置为null</li>
<li>addScrapView 这个代码比较多，但是所处理的任务很简单就是将废弃的View添加到mScrapViews中，getScrapView相反就是从ScrapView中取出view。</li>
</ul>
<p>大家看完上面的代码是不是和我有一样的感觉，这代码有啥营养？确实如果不结合ListView代码来分析，是完全看不出RecycleBin的原理的。我们在了解到RecycleBin中有什么之后皆来来就需要看它怎么在Listview中起到一个缓存的作用。</p>
<p>我们接下来就来讲解下ListView和RecycleBin如何交互实现缓存的：</p>
<p>主要关注如下两个情况：</p>
<ul>
<li>ListView的item View 回收到 RecycleBin</li>
<li>从RecycleBin中取出View作为ListView的item View</li>
</ul>
<p>我们从绘制的角度出发，观察它是如何在绘制的过程中实现子View的缓存：</p>
<p>首先在分析代码之前我们先来了解下ListView的继承关系，这样有利于我们对代码的了解（说白了就是知道在子类找不到的时候，知道如何顺着继承关系找）</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">L<span class="function"><span class="title">istView</span>-&gt;</span> A<span class="function"><span class="title">bsListView</span> -&gt;</span>A<span class="function"><span class="title">dapterView</span> -&gt;</span> ViewGroup</span><br></pre></td></tr></table></figure>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void on<span class="constructor">Layout(<span class="params">boolean</span> <span class="params">changed</span>, <span class="params">int</span> <span class="params">l</span>, <span class="params">int</span> <span class="params">t</span>, <span class="params">int</span> <span class="params">r</span>, <span class="params">int</span> <span class="params">b</span>)</span> &#123;</span><br><span class="line">    super.on<span class="constructor">Layout(<span class="params">changed</span>, <span class="params">l</span>, <span class="params">t</span>, <span class="params">r</span>, <span class="params">b</span>)</span>;</span><br><span class="line">    mInLayout = <span class="literal">true</span>;</span><br><span class="line">    final <span class="built_in">int</span> childCount = get<span class="constructor">ChildCount()</span>;</span><br><span class="line">    <span class="keyword">if</span> (changed) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; childCount; i++) &#123;</span><br><span class="line">            get<span class="constructor">ChildAt(<span class="params">i</span>)</span>.force<span class="constructor">Layout()</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mRecycler.mark<span class="constructor">ChildrenDirty()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    layout<span class="constructor">Children()</span>;</span><br><span class="line">    mInLayout = <span class="literal">false</span>;</span><br><span class="line">    mOverscrollMax = (b - t)<span class="operator"> / </span>OVERSCROLL_LIMIT_DIVISOR;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Move somewhere sane. This doesn&#x27;t belong in onLayout().</span></span><br><span class="line">    <span class="keyword">if</span> (mFastScroll != null) &#123;</span><br><span class="line">        mFastScroll.on<span class="constructor">ItemCountChanged(<span class="params">getChildCount</span>()</span>, mItemCount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>onlayout方法是在AbsListView中实现的，ListView中并没有实现这个方法，这是因为这部分代码属于GridView以及ListView通用的，所以将其放在父类上，我们知道在布局大小或者位置等发生变化的时候将会调用onLayout()方法，它会强制要求所有子item进行重绘。但是如果仔细看会发现layoutChildren()这个方法，我们接下来看下这个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">layoutChildren</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="comment">//......</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">//......</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">childrenTop</span> <span class="operator">=</span> mListPadding.top;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">childrenBottom</span> <span class="operator">=</span> mBottom - mTop - mListPadding.bottom;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">childCount</span> <span class="operator">=</span> getChildCount();</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">delta</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        View sel;</span><br><span class="line">        <span class="type">View</span> <span class="variable">oldSel</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">View</span> <span class="variable">oldFirst</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">View</span> <span class="variable">newSel</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// Remember stuff we will need down below</span></span><br><span class="line">        <span class="keyword">switch</span> (mLayoutMode) &#123;</span><br><span class="line">  		<span class="comment">//......</span></span><br><span class="line">        <span class="keyword">case</span> LAYOUT_MOVE_SELECTION:</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="comment">// Remember the previously selected view</span></span><br><span class="line">            index = mSelectedPosition - mFirstPosition;</span><br><span class="line">            <span class="keyword">if</span> (index &gt;= <span class="number">0</span> &amp;&amp; index &lt; childCount) &#123;</span><br><span class="line">                oldSel = getChildAt(index);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Remember the previous first child</span></span><br><span class="line">            oldFirst = getChildAt(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (mNextSelectedPosition &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                delta = mNextSelectedPosition - mSelectedPosition;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Caution: newSel might be null</span></span><br><span class="line">            newSel = getChildAt(index + delta);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">dataChanged</span> <span class="operator">=</span> mDataChanged;</span><br><span class="line">        <span class="keyword">if</span> (dataChanged) &#123;</span><br><span class="line">            handleDataChanged();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//......</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">firstPosition</span> <span class="operator">=</span> mFirstPosition;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">RecycleBin</span> <span class="variable">recycleBin</span> <span class="operator">=</span> mRecycler;</span><br><span class="line">        <span class="keyword">if</span> (dataChanged) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; childCount; i++) &#123;</span><br><span class="line">                recycleBin.addScrapView(getChildAt(i), firstPosition+i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            recycleBin.fillActiveViews(childCount, firstPosition);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Clear out old views</span></span><br><span class="line">        detachAllViewsFromParent();</span><br><span class="line">        recycleBin.removeSkippedScrap();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (mLayoutMode) &#123;</span><br><span class="line">        <span class="comment">//......</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">if</span> (childCount == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!mStackFromBottom) &#123;</span><br><span class="line">                    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">position</span> <span class="operator">=</span> lookForSelectablePosition(<span class="number">0</span>, <span class="literal">true</span>);</span><br><span class="line">                    setSelectedPositionInt(position);</span><br><span class="line">                    sel = fillFromTop(childrenTop);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">position</span> <span class="operator">=</span> lookForSelectablePosition(mItemCount - <span class="number">1</span>, <span class="literal">false</span>);</span><br><span class="line">                    setSelectedPositionInt(position);</span><br><span class="line">                    sel = fillUp(mItemCount - <span class="number">1</span>, childrenBottom);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (mSelectedPosition &gt;= <span class="number">0</span> &amp;&amp; mSelectedPosition &lt; mItemCount) &#123;</span><br><span class="line">                    sel = fillSpecific(mSelectedPosition,</span><br><span class="line">                            oldSel == <span class="literal">null</span> ? childrenTop : oldSel.getTop());</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mFirstPosition &lt; mItemCount) &#123;</span><br><span class="line">                    sel = fillSpecific(mFirstPosition,</span><br><span class="line">                            oldFirst == <span class="literal">null</span> ? childrenTop : oldFirst.getTop());</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    sel = fillSpecific(<span class="number">0</span>, childrenTop);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Flush any cached views that did not get reused above</span></span><br><span class="line">        recycleBin.scrapActiveViews();</span><br><span class="line">	<span class="comment">//......</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">       <span class="comment">//......</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在介绍之前我们先看下如下代码片：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">final <span class="built_in">int</span> firstPosition = mFirstPosition;</span><br><span class="line">final RecycleBin recycleBin = mRecycler;</span><br><span class="line"><span class="keyword">if</span> (dataChanged) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; childCount; i++) &#123;</span><br><span class="line">        recycleBin.add<span class="constructor">ScrapView(<span class="params">getChildAt</span>(<span class="params">i</span>)</span>, firstPosition+i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    recycleBin.fill<span class="constructor">ActiveViews(<span class="params">childCount</span>, <span class="params">firstPosition</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们需要了解下dataChanged这个变量是怎么控制的，其实这个变量是在Adapter调用了notifyDataSetChanged方法，通知Adapter的数据源发生了变化，此时dataChanged变量就为true，这时候会将当前的所有可视item 通过RecycleBin的addScrapView方法将其放入RecycleBin的废弃List中，供后续复用。</p>
<p>为了让大家地更清楚我把那些无用的代码删除掉了，我们先从第一次layout的情形进行分析，第一次layout的时候布局上是没有子元素的，这时候dataChanged &#x3D; false，childCount &#x3D; 0所以fillActiveViews这个方法也是没有任何作用的。所以上面的整个关键代码如下：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (childCount<span class="operator"> == </span><span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!mStackFromBottom) &#123;</span><br><span class="line">        final <span class="built_in">int</span> position = look<span class="constructor">ForSelectablePosition(0, <span class="params">true</span>)</span>;</span><br><span class="line">        set<span class="constructor">SelectedPositionInt(<span class="params">position</span>)</span>;</span><br><span class="line">        sel = fill<span class="constructor">FromTop(<span class="params">childrenTop</span>)</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        final <span class="built_in">int</span> position = look<span class="constructor">ForSelectablePosition(<span class="params">mItemCount</span> - 1, <span class="params">false</span>)</span>;</span><br><span class="line">        set<span class="constructor">SelectedPositionInt(<span class="params">position</span>)</span>;</span><br><span class="line">        sel = fill<span class="constructor">Up(<span class="params">mItemCount</span> - 1, <span class="params">childrenBottom</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码就是根据实际的方向来调用fillFromTop还是fillUp这两个其实功能都差不多，区别只是在于方向而已，我们以fillFromTop来分析：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Fills the list from top to bottom, starting with mFirstPosition</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param nextTop The location where the top of the first item should be</span></span><br><span class="line"><span class="comment"> *        drawn</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return The view that is currently selected</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> View fill<span class="constructor">FromTop(<span class="params">int</span> <span class="params">nextTop</span>)</span> &#123;</span><br><span class="line">    mFirstPosition = <span class="module-access"><span class="module"><span class="identifier">Math</span>.</span></span>min(mFirstPosition, mSelectedPosition);</span><br><span class="line">    mFirstPosition = <span class="module-access"><span class="module"><span class="identifier">Math</span>.</span></span>min(mFirstPosition, mItemCount - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (mFirstPosition &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        mFirstPosition = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    return fill<span class="constructor">Down(<span class="params">mFirstPosition</span>, <span class="params">nextTop</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>片段没实在的作用，实际的功能位于fillDown中。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> View fill<span class="constructor">Down(<span class="params">int</span> <span class="params">pos</span>, <span class="params">int</span> <span class="params">nextTop</span>)</span> &#123;</span><br><span class="line">    View selectedView = null;</span><br><span class="line">    <span class="built_in">int</span> <span class="keyword">end</span> = (mBottom - mTop);</span><br><span class="line">    <span class="keyword">if</span> ((mGroupFlags &amp; CLIP_TO_PADDING_MASK)<span class="operator"> == </span>CLIP_TO_PADDING_MASK) &#123;</span><br><span class="line">        <span class="keyword">end</span> -= mListPadding.bottom;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (nextTop &lt; <span class="keyword">end</span><span class="operator"> &amp;&amp; </span>pos &lt; mItemCount) &#123;</span><br><span class="line">        <span class="comment">// is this the selected item?</span></span><br><span class="line">        boolean selected = pos<span class="operator"> == </span>mSelectedPosition;</span><br><span class="line">        View child = make<span class="constructor">AndAddView(<span class="params">pos</span>, <span class="params">nextTop</span>, <span class="params">true</span>, <span class="params">mListPadding</span>.<span class="params">left</span>, <span class="params">selected</span>)</span>;</span><br><span class="line">        nextTop = child.get<span class="constructor">Bottom()</span> + mDividerHeight;</span><br><span class="line">        <span class="keyword">if</span> (selected) &#123;</span><br><span class="line">            selectedView = child;</span><br><span class="line">        &#125;</span><br><span class="line">        pos++;</span><br><span class="line">    &#125;</span><br><span class="line">    set<span class="constructor">VisibleRangeHint(<span class="params">mFirstPosition</span>, <span class="params">mFirstPosition</span> + <span class="params">getChildCount</span>()</span> - <span class="number">1</span>);</span><br><span class="line">    return selectedView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在fillDown中会从屏幕的第一个元素开始，遍历填充每个元素，这里最关键的代码是makeAndAddView</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> View <span class="title">makeAndAddView</span><span class="params">(<span class="type">int</span> position, <span class="type">int</span> y, <span class="type">boolean</span> flow, <span class="type">int</span> childrenLeft,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">boolean</span> selected)</span> </span>&#123;</span><br><span class="line">    View child;</span><br><span class="line">    <span class="keyword">if</span> (!mDataChanged) &#123;</span><br><span class="line">        <span class="comment">// Try to use an existing view for this position</span></span><br><span class="line">        child = mRecycler.<span class="built_in">getActiveView</span>(position);</span><br><span class="line">        <span class="keyword">if</span> (child != null) &#123;</span><br><span class="line">            <span class="comment">// Found it -- we&#x27;re using an existing child</span></span><br><span class="line">            <span class="comment">// This just needs to be positioned</span></span><br><span class="line">            <span class="built_in">setupChild</span>(child, position, y, flow, childrenLeft, selected, <span class="literal">true</span>);</span><br><span class="line">            <span class="keyword">return</span> child;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Make a new view for this position, or convert an unused view if possible</span></span><br><span class="line">    child = <span class="built_in">obtainView</span>(position, mIsScrap);</span><br><span class="line">    <span class="comment">// This needs to be positioned and measured</span></span><br><span class="line">    <span class="built_in">setupChild</span>(child, position, y, flow, childrenLeft, selected, mIsScrap[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在makeAndAddView方法中尝试从从RecycleBin当中获取一个ActiveView，但是在第一次布局时候RecycleBin是空的，所以返回的是null，那么就直接调用obtainView方法创建或者尝试从ScropView中或其一个子View来复用，但是这时候ScropView数组也是空的，所以只能新建一个，这个就是在obtainView方法中实现的逻辑了，我们现在这里提下，紧接着就将获取到的子View通过setupChild添加到ListView中。</p>
<p>因此我们重点关注下obtainView：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">View obtain<span class="constructor">View(<span class="params">int</span> <span class="params">position</span>, <span class="params">boolean</span>[] <span class="params">isScrap</span>)</span> &#123;</span><br><span class="line">	<span class="comment">//.......</span></span><br><span class="line">    final View scrapView = mRecycler.get<span class="constructor">ScrapView(<span class="params">position</span>)</span>;</span><br><span class="line">    final View child = mAdapter.get<span class="constructor">View(<span class="params">position</span>, <span class="params">scrapView</span>, <span class="params">this</span>)</span>;</span><br><span class="line">    <span class="keyword">if</span> (scrapView != null) &#123;</span><br><span class="line">        <span class="keyword">if</span> (child != scrapView) &#123;</span><br><span class="line">            <span class="comment">// Failed to re-bind the data, return scrap to the heap.</span></span><br><span class="line">            mRecycler.add<span class="constructor">ScrapView(<span class="params">scrapView</span>, <span class="params">position</span>)</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            isScrap<span class="literal">[<span class="number">0</span>]</span> = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// Finish the temporary detach started in addScrapView().</span></span><br><span class="line">            child.dispatch<span class="constructor">FinishTemporaryDetach()</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//.......</span></span><br><span class="line">    return child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>obtainView方法也是又臭又长但是我们只看关键的。它会调用getScrapView从mRecycler的ScrapView中获取可以复用的scrapView但是我们现在第一次什么都没有，所以scrapView为null。下面这个大家熟悉了把，</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">final View child = mAdapter.get<span class="constructor">View(<span class="params">position</span>, <span class="params">scrapView</span>, <span class="params">this</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>什么不熟悉？这个就是调用Adapter的getView方法啊，第二个参数就是我们经常提到的convertView。想必看了下面的代码大家都会有印象吧：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public View get<span class="constructor">View(<span class="params">int</span> <span class="params">position</span>, View <span class="params">convertView</span>, ViewGroup <span class="params">parent</span>)</span> &#123;</span><br><span class="line">    ViewHolder holder = null;</span><br><span class="line">    <span class="keyword">if</span> (convertView<span class="operator"> == </span>null) &#123;</span><br><span class="line">        holder=<span class="keyword">new</span> <span class="constructor">ViewHolder()</span>;</span><br><span class="line">        convertView = mInflater.inflate(<span class="module-access"><span class="module"><span class="identifier">R</span>.</span></span>layout.vlist2, null);</span><br><span class="line">        holder.img = (ImageView)convertView.find<span class="constructor">ViewById(R.<span class="params">id</span>.<span class="params">img</span>)</span>;</span><br><span class="line">        holder.title = (TextView)convertView.find<span class="constructor">ViewById(R.<span class="params">id</span>.<span class="params">title</span>)</span>;</span><br><span class="line">        holder.info = (TextView)convertView.find<span class="constructor">ViewById(R.<span class="params">id</span>.<span class="params">info</span>)</span>;</span><br><span class="line">        holder.viewBtn =(Button)convertView.find<span class="constructor">ViewById(R.<span class="params">id</span>.<span class="params">view_btn</span>)</span>;</span><br><span class="line">        convertView.set<span class="constructor">Tag(<span class="params">holder</span>)</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        holder = (ViewHolder)convertView.get<span class="constructor">Tag()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    holder.img.set<span class="constructor">BackgroundResource((Integer)</span>mData.get(position).get(<span class="string">&quot;img&quot;</span>));</span><br><span class="line">    holder.title.set<span class="constructor">Text((String)</span>mData.get(position).get(<span class="string">&quot;title&quot;</span>));</span><br><span class="line">    holder.info.set<span class="constructor">Text((String)</span>mData.get(position).get(<span class="string">&quot;info&quot;</span>));</span><br><span class="line">    return convertView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一次layout的时候我们convertView为空那么就会inflate一个作为convertView并返回。makeAndAddView#setupChild就将这个convertView添加到布局中。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="type">void</span> <span class="title">setupChild</span><span class="params">(View child, <span class="type">int</span> position, <span class="type">int</span> y, <span class="type">boolean</span> flowDown, <span class="type">int</span> childrenLeft,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">boolean</span> selected, <span class="type">boolean</span> recycled)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="keyword">if</span> ((recycled &amp;&amp; !p.forceAdd) || (p.recycledHeaderFooter</span><br><span class="line">            &amp;&amp; p.viewType == AdapterView.ITEM_VIEW_TYPE_HEADER_OR_FOOTER)) &#123;</span><br><span class="line">        <span class="built_in">attachViewToParent</span>(child, flowDown ? <span class="number">-1</span> : <span class="number">0</span>, p);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        p.forceAdd = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (p.viewType == AdapterView.ITEM_VIEW_TYPE_HEADER_OR_FOOTER) &#123;</span><br><span class="line">            p.recycledHeaderFooter = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">addViewInLayout</span>(child, flowDown ? <span class="number">-1</span> : <span class="number">0</span>, p, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> 	<span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>setupChild方法很简单就是调用了addViewInLayout将convertView添加到ListView中。</p>
<p><img src="/2016/07/27/Android-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BListView/2.png"></p>
<p>接下来我们看下在经过第一次layout后，往后的布局和之前的布局有什么不一样的地方。<br>我们还是从layoutChildren开始，这里和上面的区别是由于childCount不为0所以fillActiveViews会将Child Item添加到ActiviteView数组中，<br>紧接着调用fillSpecific，这个会从指定的位置开始加载Child item。紧接着调用makeAndAddView，这时候makeAndAddView跑的逻辑就和之前不一样了，由于mDataChanged为false（假设当前数据集每变，也就是没有对数据集进行增删的操作）这次调用mRecycler.getActiveView的时候返回的就不是空了，因为前面我们调用了RecycleBin的fillActiveViews()方法来缓存ChildView。所以就不会再进入obtainView()方法，而是会直接调用setupChild()方法，这样就避免了重新inflate。<br>接下来看下setupChild()，由于我们在这之前调用了detachAllViewsFromParent所以子View应该调用attachViewToParent()方法。而不是前面提到的addViewInLayout方法。<br><img src="/2016/07/27/Android-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BListView/3.png"></p>
<p>好了我们看完上面代码可能觉得还是没有接触到最核心的缓存机制，最关键的部分是在滑动的时候如何缓存的，接下来我们看下这部分逻辑：<br>我们知道我们的交互事件都会被传递到onTouchEvent中，在ListView也不例外，onTouchEvent有很多事件，我们关注ACTION_MOVE,在这部分代码中我们重点关注trackMotionScroll方法：这个方法顾名思义就是跟踪滑动事件：这个代码也很长，我们还是从中关注重点。</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line">boolean trackMotionScroll(int deltaY,<span class="built_in"> int </span>incrementalDeltaY) &#123;</span><br><span class="line">   <span class="keyword"> final</span><span class="built_in"> int </span>childCount = getChildCount();</span><br><span class="line">   <span class="built_in"> if </span>(childCount == 0) &#123;</span><br><span class="line">       <span class="built_in"> return </span>true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword"> final</span><span class="built_in"> int </span>firstTop = getChildAt(0).getTop();</span><br><span class="line">   <span class="keyword"> final</span><span class="built_in"> int </span>lastBottom = getChildAt(childCount - 1).getBottom();</span><br><span class="line"></span><br><span class="line">   <span class="keyword"> final</span> Rect listPadding = m<span class="class">ListPadding;</span></span><br><span class="line"></span><br><span class="line">    // <span class="string">&quot;effective padding&quot;</span> In this case is the amount of padding that affects</span><br><span class="line">    // how much space should<span class="built_in"> not </span>be<span class="built_in"> filled </span>by items. If we don&#x27;t clip to padding</span><br><span class="line">    // there is no effective padding.</span><br><span class="line">   <span class="built_in"> int </span>effectivePaddingTop = 0;</span><br><span class="line">   <span class="built_in"> int </span>effectivePaddingBottom = 0;</span><br><span class="line">   <span class="built_in"> if </span>((mGroupFlags &amp; CLIP_TO_PADDING_MASK) == CLIP_TO_PADDING_MASK) &#123;</span><br><span class="line">        effectivePaddingTop = listPadding.top;</span><br><span class="line">        effectivePaddingBottom = listPadding.bottom;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     // FIXME account for grid vertical spacing too?</span><br><span class="line">   <span class="keyword"> final</span><span class="built_in"> int </span>spaceAbove = effectivePaddingTop - firstTop;</span><br><span class="line">   <span class="keyword"> final</span><span class="built_in"> int </span>end = getHeight() - effectivePaddingBottom;</span><br><span class="line">   <span class="keyword"> final</span><span class="built_in"> int </span>spaceBelow = lastBottom - end;</span><br><span class="line"></span><br><span class="line">   <span class="keyword"> final</span><span class="built_in"> int </span>height = getHeight() - mPaddingBottom - mPaddingTop;</span><br><span class="line">   <span class="built_in"> if </span>(deltaY &lt; 0) &#123;</span><br><span class="line">        deltaY = Math.max(-(height - 1), deltaY);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        deltaY = Math.min(height - 1, deltaY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="built_in"> if </span>(incrementalDeltaY &lt; 0) &#123;</span><br><span class="line">        incrementalDeltaY = Math.max(-(height - 1), incrementalDeltaY);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        incrementalDeltaY = Math.min(height - 1, incrementalDeltaY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword"> final</span><span class="built_in"> int </span>firstPosition = mFirstPosition;</span><br><span class="line"></span><br><span class="line">    // Update our guesses for where the first<span class="built_in"> and </span>last views are</span><br><span class="line">   <span class="built_in"> if </span>(firstPosition == 0) &#123;</span><br><span class="line">        mFirstPositionDistanceGuess = firstTop - listPadding.top;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        mFirstPositionDistanceGuess += incrementalDeltaY;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="built_in"> if </span>(firstPosition + childCount == mItemCount) &#123;</span><br><span class="line">        m<span class="class">LastPositionDistanceGuess = lastBottom + listPadding.bottom;</span></span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        m<span class="class">LastPositionDistanceGuess += incrementalDeltaY;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword"> final</span> boolean cannotScrollDown = (firstPosition == 0 &amp;&amp;</span><br><span class="line">            firstTop &gt;= listPadding.top &amp;&amp; incrementalDeltaY &gt;= 0);</span><br><span class="line">   <span class="keyword"> final</span> boolean cannotScrollUp = (firstPosition + childCount == mItemCount &amp;&amp;</span><br><span class="line">            lastBottom &lt;= getHeight() - listPadding.bottom &amp;&amp; incrementalDeltaY &lt;= 0);</span><br><span class="line"></span><br><span class="line">   <span class="built_in"> if </span>(cannotScrollDown || cannotScrollUp) &#123;</span><br><span class="line">       <span class="built_in"> return </span>incrementalDeltaY != 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword"> final</span> boolean down = incrementalDeltaY &lt; 0;</span><br><span class="line"></span><br><span class="line">   <span class="keyword"> final</span> boolean inTouchMode = isInTouchMode();</span><br><span class="line">   <span class="built_in"> if </span>(inTouchMode) &#123;</span><br><span class="line">        hideSelector();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword"> final</span><span class="built_in"> int </span>headerViewsCount = getHeaderViewsCount();</span><br><span class="line">   <span class="keyword"> final</span><span class="built_in"> int </span>footerViewsStart = mItemCount - getFooterViewsCount();</span><br><span class="line"></span><br><span class="line">   <span class="built_in"> int </span>start = 0;</span><br><span class="line">   <span class="built_in"> int </span>count = 0;</span><br><span class="line"></span><br><span class="line">   <span class="built_in"> if </span>(down) &#123;</span><br><span class="line">       <span class="built_in"> int </span>top = -incrementalDeltaY;</span><br><span class="line">       <span class="built_in"> if </span>((mGroupFlags &amp; CLIP_TO_PADDING_MASK) == CLIP_TO_PADDING_MASK) &#123;</span><br><span class="line">            top += listPadding.top;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; childCount; i++) &#123;</span><br><span class="line">           <span class="keyword"> final</span> View child = getChildAt(i);</span><br><span class="line">           <span class="built_in"> if </span>(child.getBottom() &gt;= top) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                count++;</span><br><span class="line">               <span class="built_in"> int </span>position = firstPosition + i;</span><br><span class="line">               <span class="built_in"> if </span>(position &gt;= headerViewsCount &amp;&amp; position &lt; footerViewsStart) &#123;</span><br><span class="line">                    // The view will be rebound to<span class="built_in"> new </span>data, clear any</span><br><span class="line">                    //<span class="keyword"> system</span>-managed<span class="keyword"> transient</span> state.</span><br><span class="line">                    child.clearAccessibilityFocus();</span><br><span class="line">                    mRecycler.addScrapView(child, position);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">       <span class="built_in"> int </span>bottom = getHeight() - incrementalDeltaY;</span><br><span class="line">       <span class="built_in"> if </span>((mGroupFlags &amp; CLIP_TO_PADDING_MASK) == CLIP_TO_PADDING_MASK) &#123;</span><br><span class="line">            bottom -= listPadding.bottom;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = childCount - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">           <span class="keyword"> final</span> View child = getChildAt(i);</span><br><span class="line">           <span class="built_in"> if </span>(child.getTop() &lt;= bottom) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                start = i;</span><br><span class="line">                count++;</span><br><span class="line">               <span class="built_in"> int </span>position = firstPosition + i;</span><br><span class="line">               <span class="built_in"> if </span>(position &gt;= headerViewsCount &amp;&amp; position &lt; footerViewsStart) &#123;</span><br><span class="line">                    // The view will be rebound to<span class="built_in"> new </span>data, clear any</span><br><span class="line">                    //<span class="keyword"> system</span>-managed<span class="keyword"> transient</span> state.</span><br><span class="line">                    child.clearAccessibilityFocus();</span><br><span class="line">                    mRecycler.addScrapView(child, position);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mMotionViewNewTop = mMotionViewOriginalTop + deltaY;</span><br><span class="line">    mBlock<span class="class">LayoutRequests = true;</span></span><br><span class="line"></span><br><span class="line">   <span class="built_in"> if </span>(count &gt; 0) &#123;</span><br><span class="line">        detachViewsFromParent(start, count);</span><br><span class="line">        mRecycler.removeSkippedScrap();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // invalidate before moving the children to avoid unnecessary invalidate</span><br><span class="line">    // calls to bubble up from the children all the way to the top</span><br><span class="line">   <span class="built_in"> if </span>(!awakenScrollBars()) &#123;</span><br><span class="line">       invalidate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    offsetChildrenTopAndBottom(incrementalDeltaY);</span><br><span class="line"></span><br><span class="line">   <span class="built_in"> if </span>(down) &#123;</span><br><span class="line">        mFirstPosition += count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword"> final</span><span class="built_in"> int </span>absIncrementalDeltaY = Math.abs(incrementalDeltaY);</span><br><span class="line">   <span class="built_in"> if </span>(spaceAbove &lt; absIncrementalDeltaY || spaceBelow &lt; absIncrementalDeltaY) &#123;</span><br><span class="line">        fillGap(down);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="built_in"> if </span>(!inTouchMode &amp;&amp; mSelectedPosition != INVALID_POSITION) &#123;</span><br><span class="line">       <span class="keyword"> final</span><span class="built_in"> int </span>childIndex = mSelectedPosition - mFirstPosition;</span><br><span class="line">       <span class="built_in"> if </span>(childIndex &gt;= 0 &amp;&amp; childIndex &lt; getChildCount()) &#123;</span><br><span class="line">            positionSelector(mSelectedPosition, getChildAt(childIndex));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else<span class="built_in"> if </span>(mSelectorPosition != INVALID_POSITION) &#123;</span><br><span class="line">       <span class="keyword"> final</span><span class="built_in"> int </span>childIndex = mSelectorPosition - mFirstPosition;</span><br><span class="line">       <span class="built_in"> if </span>(childIndex &gt;= 0 &amp;&amp; childIndex &lt; getChildCount()) &#123;</span><br><span class="line">            positionSelector(INVALID_POSITION, getChildAt(childIndex));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        mSelectorRect.setEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">    mBlock<span class="class">LayoutRequests = false;</span></span><br><span class="line">    invokeOnItemScrollListener();</span><br><span class="line">   <span class="built_in"> return </span>false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法传入两个参数deltaY表示从手指最初按下时的位置到当前手指所处的位置，incrementalDeltaY则表示相邻两次在Y方向上位置的改变量，incrementalDeltaY的正负值就可以判断我们当前的滑动方向了。（incrementalDeltaY小于0，表示向下滑动，大于0就是向上滑动）在这个部分逻辑中将会根据边缘作为判断依据如果子View的bottom值小于top值的时候，说明这个子View移出屏幕了，这时候就会调用RecycleBin的addScrapView()方法将这个View加入到废弃缓存当中，上面介绍了移出屏幕的情况，由于界面显示的子View是固定的所以有移出就有移入，我们接下来看下这部分逻辑：<br>如果ListView中最后一个View的底部已经移入了屏幕，或者ListView中第一个View的顶部移入了屏幕，就会调 用fillGap()方法，我们看下这个方法：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void fill<span class="constructor">Gap(<span class="params">boolean</span> <span class="params">down</span>)</span> &#123;</span><br><span class="line">    final <span class="built_in">int</span> count = get<span class="constructor">ChildCount()</span>;</span><br><span class="line">    <span class="keyword">if</span> (down) &#123;</span><br><span class="line">        <span class="built_in">int</span> paddingTop = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> ((mGroupFlags &amp; CLIP_TO_PADDING_MASK)<span class="operator"> == </span>CLIP_TO_PADDING_MASK) &#123;</span><br><span class="line">            paddingTop = get<span class="constructor">ListPaddingTop()</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        final <span class="built_in">int</span> startOffset = count &gt; <span class="number">0</span> ? get<span class="constructor">ChildAt(<span class="params">count</span> - 1)</span>.get<span class="constructor">Bottom()</span> + mDividerHeight :</span><br><span class="line">                paddingTop;</span><br><span class="line">        fill<span class="constructor">Down(<span class="params">mFirstPosition</span> + <span class="params">count</span>, <span class="params">startOffset</span>)</span>;</span><br><span class="line">        correct<span class="constructor">TooHigh(<span class="params">getChildCount</span>()</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">int</span> paddingBottom = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> ((mGroupFlags &amp; CLIP_TO_PADDING_MASK)<span class="operator"> == </span>CLIP_TO_PADDING_MASK) &#123;</span><br><span class="line">            paddingBottom = get<span class="constructor">ListPaddingBottom()</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        final <span class="built_in">int</span> startOffset = count &gt; <span class="number">0</span> ? get<span class="constructor">ChildAt(0)</span>.get<span class="constructor">Top()</span> - mDividerHeight :</span><br><span class="line">                get<span class="constructor">Height()</span> - paddingBottom;</span><br><span class="line">        fill<span class="constructor">Up(<span class="params">mFirstPosition</span> - 1, <span class="params">startOffset</span>)</span>;</span><br><span class="line">        correct<span class="constructor">TooLow(<span class="params">getChildCount</span>()</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>额，又回到之前的流程，在fillGap又调用了fillDown&#x2F;fillUp，我们知道这两个方法会调用makeAndAddView，但是这时候的makeAndAddView流程又和上面不大一样了。这时候mRecycler.getActiveView返回的是null</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> View <span class="title">makeAndAddView</span><span class="params">(<span class="type">int</span> position, <span class="type">int</span> y, <span class="type">boolean</span> flow, <span class="type">int</span> childrenLeft,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">boolean</span> selected)</span> </span>&#123;</span><br><span class="line">    View child;</span><br><span class="line">    <span class="keyword">if</span> (!mDataChanged) &#123;</span><br><span class="line">        <span class="comment">// Try to use an existing view for this position</span></span><br><span class="line">        child = mRecycler.<span class="built_in">getActiveView</span>(position);</span><br><span class="line">        <span class="keyword">if</span> (child != null) &#123;</span><br><span class="line">            <span class="comment">// Found it -- we&#x27;re using an existing child</span></span><br><span class="line">            <span class="comment">// This just needs to be positioned</span></span><br><span class="line">            <span class="built_in">setupChild</span>(child, position, y, flow, childrenLeft, selected, <span class="literal">true</span>);</span><br><span class="line">            <span class="keyword">return</span> child;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Make a new view for this position, or convert an unused view if possible</span></span><br><span class="line">    child = <span class="built_in">obtainView</span>(position, mIsScrap);</span><br><span class="line">    <span class="comment">// This needs to be positioned and measured</span></span><br><span class="line">    <span class="built_in">setupChild</span>(child, position, y, flow, childrenLeft, selected, mIsScrap[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么是null我们再来看下getActiveView：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">View</span> getActiveView(<span class="type">int</span> position) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="keyword">index</span> = position - mFirstActivePosition;</span><br><span class="line">    final <span class="keyword">View</span>[] activeViews = mActiveViews;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">index</span> &gt;=<span class="number">0</span> &amp;&amp; <span class="keyword">index</span> &lt; activeViews.length) &#123;</span><br><span class="line">        final <span class="keyword">View</span> match = activeViews[<span class="keyword">index</span>];</span><br><span class="line">        activeViews[<span class="keyword">index</span>] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> match;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于之前这个方法已经被调用过了它会将activeViews[index]置为null所以还会调用obtainView，上面已经对该方法做了分析，它会调用getScrapView()方法来尝试从废弃缓存中获取一个View，如果没有的话则会inflate一个返回。</p>
<h5 id="ListView的优化"><a href="#ListView的优化" class="headerlink" title="ListView的优化"></a>ListView的优化</h5><p>上面介绍的只是ListView的缓存机制，了解了整个缓存机制后我们就可以充分利用convertView来判断是否inflate了，所以整个ListView只加载一屏的布局，之后滑动出来的item使用的是之前已经加载的布局的缓存，但是我们看下下面的getView我们使用了ViewHolder，还有set&#x2F;getTag这是干啥用的？</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public View get<span class="constructor">View(<span class="params">int</span> <span class="params">position</span>, View <span class="params">convertView</span>, ViewGroup <span class="params">parent</span>)</span> &#123;</span><br><span class="line">    ViewHolder holder = null;</span><br><span class="line">    <span class="keyword">if</span> (convertView<span class="operator"> == </span>null) &#123;</span><br><span class="line">        holder=<span class="keyword">new</span> <span class="constructor">ViewHolder()</span>;</span><br><span class="line">        convertView = mInflater.inflate(<span class="module-access"><span class="module"><span class="identifier">R</span>.</span></span>layout.vlist2, null);</span><br><span class="line">        holder.img = (ImageView)convertView.find<span class="constructor">ViewById(R.<span class="params">id</span>.<span class="params">img</span>)</span>;</span><br><span class="line">        holder.title = (TextView)convertView.find<span class="constructor">ViewById(R.<span class="params">id</span>.<span class="params">title</span>)</span>;</span><br><span class="line">        holder.info = (TextView)convertView.find<span class="constructor">ViewById(R.<span class="params">id</span>.<span class="params">info</span>)</span>;</span><br><span class="line">        holder.viewBtn =(Button)convertView.find<span class="constructor">ViewById(R.<span class="params">id</span>.<span class="params">view_btn</span>)</span>;</span><br><span class="line">        convertView.set<span class="constructor">Tag(<span class="params">holder</span>)</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        holder = (ViewHolder)convertView.get<span class="constructor">Tag()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    holder.img.set<span class="constructor">BackgroundResource((Integer)</span>mData.get(position).get(<span class="string">&quot;img&quot;</span>));</span><br><span class="line">    holder.title.set<span class="constructor">Text((String)</span>mData.get(position).get(<span class="string">&quot;title&quot;</span>));</span><br><span class="line">    holder.info.set<span class="constructor">Text((String)</span>mData.get(position).get(<span class="string">&quot;info&quot;</span>));</span><br><span class="line">    return convertView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实使用ViewHolder，还有set&#x2F;getTag是为了节省findViewById的时间。如果不使用ViewHolder，每次getView的时候都需要得到一次子布局，而这也是很耗时并且耗资源的，如果使用了ViewHolder作为子布局的缓存，使用View的setTag方法将缓存与每个item绑定，则也可以省去了findViewById的时间（这里我个人的理解是将id与ViewHolder中的View绑定起来，如果有理解错误欢迎更正）<br>这里还需要注意一点我们一般需要将ViewHolder设置为静态的因为因为静态内部类，不持有外部类的引用，从而避免内存泄露。</p>
<p>总结如下：基本的优化方式</p>
<ul>
<li>使用ConvertView复用机制</li>
<li>使用ViewHolder</li>
<li>使用set&#x2F;getTag</li>
</ul>
<p>ListView Item带有图片的情况：</p>
<p>我们在开发的时候会遇到ListView中每个item都有一个Image的情况，这个在Music应用中十分常见，<br>所以我们一般对这些图像的加载使用图片缓存，并且在加载这些图片的时候使用异步加载，但是这也面临这空间和时间的平衡问题。<br>这种情况还有一种方法就是针对图片资源进行优化比如在图片解码的时候，降低像素颜色信息，去掉透明度等，或者在设计资源的时候尽量减小图片资源的尺寸。</p>
<p>为了避免不需要加载在我们还可以设置在滑动不加载图片滑动停止的时候加载图片<br>下面是对应的实现例子：<br>转载自 <a target="_blank" rel="noopener" href="http://blog.csdn.net/yy1300326388/article/details/45153813">http://blog.csdn.net/yy1300326388/article/details/45153813</a></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义当前listview是否在滑动状态</span></span><br><span class="line"><span class="keyword">private</span>  <span class="built_in">boolean</span> scrollState=<span class="literal">false</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">setScrollState</span>(<span class="params"><span class="built_in">boolean</span> scrollState</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">scrollState</span> = scrollState;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实体类</span></span><br><span class="line">UserEnity userEnity=lists.get(position);</span><br><span class="line"><span class="keyword">if</span> (!scrollState)&#123;<span class="comment">//如果当前不是滑动的状态，我们填充真数据</span></span><br><span class="line">    <span class="comment">//填充数据</span></span><br><span class="line">    viewHolder.tv_name.set<span class="constructor">Text(<span class="params">userEnity</span>.<span class="params">getName</span>()</span>);</span><br><span class="line">    <span class="comment">//设置Tag中数据为空表示数据已填充</span></span><br><span class="line">    viewHolder.tv_name.set<span class="constructor">Tag(<span class="params">null</span>)</span>;</span><br><span class="line">    <span class="comment">//加载图片</span></span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">ImageLoader</span>.</span></span>get<span class="constructor">Instance()</span>.display<span class="constructor">Image(<span class="params">img_url</span>,<span class="params">viewHolder</span>.<span class="params">iv_icon</span>)</span>;</span><br><span class="line">    <span class="comment">//设置tag为1表示已加载过数据</span></span><br><span class="line">    viewHolder.iv_icon.set<span class="constructor">Tag(<span class="string">&quot;1&quot;</span>)</span>;</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;<span class="comment">//如果当前是滑动的状态，我们填充假数据</span></span><br><span class="line">    viewHolder.tv_name.set<span class="constructor">Text(<span class="string">&quot;加载中&quot;</span>)</span>;</span><br><span class="line">    <span class="comment">//将数据name保存在Tag当中</span></span><br><span class="line">    viewHolder.tv_name.set<span class="constructor">Tag(<span class="params">userEnity</span>.<span class="params">getName</span>()</span>);</span><br><span class="line">    <span class="comment">//将数据image_url保存在Tag当中</span></span><br><span class="line">    viewHolder.iv_icon.set<span class="constructor">Tag(<span class="params">img_url</span>)</span>;</span><br><span class="line">    <span class="comment">//设置默认显示图片（最好是本地资源的图片）</span></span><br><span class="line">    viewHolder.iv_icon.set<span class="constructor">ImageResource(R.<span class="params">mipmap</span>.<span class="params">ic_launcher</span>)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">设置监听</span><br><span class="line">@Override</span><br><span class="line">public void on<span class="constructor">ScrollStateChanged(AbsListView <span class="params">view</span>, <span class="params">int</span> <span class="params">scrollState</span>)</span> &#123;</span><br><span class="line">    switch (scrollState)&#123;</span><br><span class="line">        case AbsListView.OnScrollListener.SCROLL_STATE_IDLE:<span class="comment">//停止滚动</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//设置为停止滚动</span></span><br><span class="line">            myAdapter.set<span class="constructor">ScrollState(<span class="params">false</span>)</span>;</span><br><span class="line">            <span class="comment">//当前屏幕中listview的子项的个数</span></span><br><span class="line">            <span class="built_in">int</span> count = view.get<span class="constructor">ChildCount()</span>;</span><br><span class="line">            <span class="module-access"><span class="module"><span class="identifier">Log</span>.</span></span>e(<span class="string">&quot;MainActivity&quot;</span>,count+<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">                <span class="comment">//获取到item的name</span></span><br><span class="line">                TextView tv_name = (TextView) view.get<span class="constructor">ChildAt(<span class="params">i</span>)</span>.find<span class="constructor">ViewById(R.<span class="params">id</span>.<span class="params">main_item_tv_name</span>)</span>;</span><br><span class="line">                <span class="comment">//获取到item的头像</span></span><br><span class="line">                ImageView iv_show= (ImageView) view.get<span class="constructor">ChildAt(<span class="params">i</span>)</span>.find<span class="constructor">ViewById(R.<span class="params">id</span>.<span class="params">main_item_iv_icon</span>)</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (tv_name.get<span class="constructor">Tag()</span> != null) &#123; <span class="comment">//非null说明需要加载数据</span></span><br><span class="line">                    tv_name.set<span class="constructor">Text(<span class="params">tv_name</span>.<span class="params">getTag</span>()</span>.<span class="keyword">to</span><span class="constructor">String()</span>);<span class="comment">//直接从Tag中取出我们存储的数据name并且赋值</span></span><br><span class="line">                    tv_name.set<span class="constructor">Tag(<span class="params">null</span>)</span>;<span class="comment">//设置为已加载过数据</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!iv_show.get<span class="constructor">Tag()</span>.equals(<span class="string">&quot;1&quot;</span>))&#123;<span class="comment">//!=&quot;1&quot;说明需要加载数据</span></span><br><span class="line">                    String image_url=iv_show.get<span class="constructor">Tag()</span>.<span class="keyword">to</span><span class="constructor">String()</span>;<span class="comment">//直接从Tag中取出我们存储的数据image——url</span></span><br><span class="line">                    <span class="module-access"><span class="module"><span class="identifier">ImageLoader</span>.</span></span>get<span class="constructor">Instance()</span>.display<span class="constructor">Image(<span class="params">image_url</span>, <span class="params">iv_show</span>)</span>;<span class="comment">//显示图片</span></span><br><span class="line">                    iv_show.set<span class="constructor">Tag(<span class="string">&quot;1&quot;</span>)</span>;<span class="comment">//设置为已加载过数据</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        case AbsListView.OnScrollListener.SCROLL_STATE_FLING:<span class="comment">//滚动做出了抛的动作</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//设置为正在滚动</span></span><br><span class="line">            myAdapter.set<span class="constructor">ScrollState(<span class="params">true</span>)</span>;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        case AbsListView.OnScrollListener.SCROLL_STATE_TOUCH_SCROLL:<span class="comment">//正在滚动</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//设置为正在滚动</span></span><br><span class="line">            myAdapter.set<span class="constructor">ScrollState(<span class="params">true</span>)</span>;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>局部更新：<br><a target="_blank" rel="noopener" href="http://blog.csdn.net/nupt123456789/article/details/39432781">http://blog.csdn.net/nupt123456789/article/details/39432781</a><br><a target="_blank" rel="noopener" href="http://www.cnblogs.com/liuling/p/2015-10-20-01.html">http://www.cnblogs.com/liuling/p/2015-10-20-01.html</a></p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> void update<span class="constructor">ProgressPartly(<span class="params">int</span> <span class="params">progress</span>,<span class="params">int</span> <span class="params">position</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">int</span> firstVisiblePosition = listview.get<span class="constructor">FirstVisiblePosition()</span>;</span><br><span class="line">    <span class="built_in">int</span> lastVisiblePosition = listview.get<span class="constructor">LastVisiblePosition()</span>;</span><br><span class="line">    <span class="keyword">if</span>(position&gt;=firstVisiblePosition<span class="operator"> &amp;&amp; </span>position&lt;=lastVisiblePosition)&#123;</span><br><span class="line">        View view = listview.get<span class="constructor">ChildAt(<span class="params">position</span> - <span class="params">firstVisiblePosition</span>)</span>;</span><br><span class="line">        <span class="keyword">if</span>(view.get<span class="constructor">Tag()</span> instanceof ViewHolder)&#123;</span><br><span class="line">            ViewHolder vh = (ViewHolder)view.get<span class="constructor">Tag()</span>;</span><br><span class="line">            vh.pb.set<span class="constructor">Progress(<span class="params">progress</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结一下：</p>
<p>其实ListView优化的最根本途径在于getView方法的优化，所以我们优化就需要将一切耗时的操作从getView中抽离，比如图片加载，网络数据加载，文件加载。<br>因此可以通过如下几种途径来优化：</p>
<ol>
<li>启动线程来异步加载图片，在图片尚未加载完成之前先用空白图片占位</li>
<li>滑动时不加载图片，停止滑动时加载</li>
<li>使用缓存机制将其缓存到内存中（注意使用弱引用）</li>
<li>局部刷新</li>
<li>Item中的控件宽高尽量写成固定的值或者math_parent，避免影响其他控件的位置导致重新绘制</li>
<li>减少布局层次，缩短绘制时间。慎用 layout_weight 类似属性，以便缩短布局的 Measure 时间。</li>
<li>使用RecyclerView，RecyclerView提供了原生的局部刷新功能</li>
<li>在加载的时候，为ImageView设置一个Tag，比如imageView.setTag(image_url),下一次再加载之前，首先获取Tag，比如imageUrl &#x3D; imageView.getTag(),如果此时的地址和之前的地址一样，我们就不需要加载了，如果不一样，再加载。</li>
</ol>
<p>最后是之前开发中遇到的两种ListView错位的问题：<br>下面是当时的参考解决方案，后续有空的时候再对这部分进行专门总结：<br><a target="_blank" rel="noopener" href="http://www.cnblogs.com/lesliefang/p/3619223.html">http://www.cnblogs.com/lesliefang/p/3619223.html</a><br><a target="_blank" rel="noopener" href="http://www.runoob.com/w3cnote/android-tutorial-listview-checkbox.html">http://www.runoob.com/w3cnote/android-tutorial-listview-checkbox.html</a><br><a target="_blank" rel="noopener" href="http://www.trinea.cn/android/android-listview-display-error-image-when-scroll/">http://www.trinea.cn/android/android-listview-display-error-image-when-scroll/</a></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Android-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">Android 源码分析</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/AOSP-源码/">AOSP 源码</a>
  </div>

</div>



<div class="comments-count">
	
	  	<span></span>
		<a href="/2016/07/27/Android-源码分析之ListView/#comments" class="ds-thread-count comments-count-link" data-thread-key="2016/07/27/Android-源码分析之ListView/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/07/26/Android-进阶之软引用和弱引用/" title="Android 进阶之软引用和弱引用" itemprop="url">Android 进阶之软引用和弱引用</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Edgar" target="_blank" itemprop="author">Edgar</a>
		
  <p class="article-time">
    <time datetime="2016-07-26T02:56:36.000Z" itemprop="datePublished"> Published 2016-07-26</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h4 id="三种引用对比"><a href="#三种引用对比" class="headerlink" title="三种引用对比"></a>三种引用对比</h4><table>
<thead>
<tr>
<th>引用类型</th>
<th>回收时期</th>
</tr>
</thead>
<tbody><tr>
<td>强引用</td>
<td>当代码中显示标示这个对象不使用的时候</td>
</tr>
<tr>
<td>软引用</td>
<td>内存不足的时候</td>
</tr>
<tr>
<td>弱引用</td>
<td>不管内存是否充足，只要执行gc的时候就有可能被回收</td>
</tr>
</tbody></table>
<p>通过上面我们可以看出除了强引用外其他两种引用在使用的时候都需要判断是否被回收。</p>
<h4 id="软引用和弱引用的使用场景上的区别："><a href="#软引用和弱引用的使用场景上的区别：" class="headerlink" title="软引用和弱引用的使用场景上的区别："></a>软引用和弱引用的使用场景上的区别：</h4><p>如果只是想避免OutOfMemory异常的发生，则可以使用软引用。如果对于应用的性能更在意，想尽快回收一些占用内存比较大的对象，则可以使用弱引用。<br>另外可以根据对象是否经常使用来判断选择软引用还是弱引用。如果该对象可能会经常使用的，就尽量用软引用。如果该对象不被使用的可能性更大些，就可以用弱引用。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Android%E8%BF%9B%E9%98%B6/">Android进阶</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/编程技巧/">编程技巧</a>
  </div>

</div>



<div class="comments-count">
	
	  	<span></span>
		<a href="/2016/07/26/Android-进阶之软引用和弱引用/#comments" class="ds-thread-count comments-count-link" data-thread-key="2016/07/26/Android-进阶之软引用和弱引用/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>







  <nav id="page-nav" class="clearfix">
    <a class="extend prev" rel="prev" href="/page/13/">&lt;span&gt;&lt;&#x2F;span&gt;Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="page-number" href="/page/13/">13</a><span class="page-number current">14</span><a class="page-number" href="/page/15/">15</a><a class="page-number" href="/page/16/">16</a><span class="space">&hellip;</span><a class="page-number" href="/page/30/">30</a><a class="extend next" rel="next" href="/page/15/">Next&lt;span&gt;&lt;&#x2F;span&gt;</a>
  </nav>

</div>
      <div class="openaside"><a class="navbutton" href="#" title="Show Sidebar"></a></div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="Hide Sidebar"></a></div>
<aside class="clearfix">
<div id="authorInfo">
	
		<div class="author-img"></div>		
	
	<div class="social-info" class="clearfix">
		
		
		<a href="https://github.com/tbfungeek" target="_blank" class="icon-github" title="github"></a>
		
		
		
		
		
		
		
		
		
		
		<a href="mailto:tbfungeek@163.com" target="_blank" class="icon-email" title="Email Me"></a>
		

	</div>
</div>

  
<div class="categorieslist">
	<p class="asidetitle">Categories</p>
		<ul>
		
		  
			<li><a href="/categories/Android-小经验/" title="Android 小经验">Android 小经验<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Android-源码分析/" title="Android 源码分析">Android 源码分析<sup>21</sup></a></li>
		  
		
		  
			<li><a href="/categories/Android其他/" title="Android其他">Android其他<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Android初步/" title="Android初步">Android初步<sup>21</sup></a></li>
		  
		
		  
			<li><a href="/categories/Android进阶/" title="Android进阶">Android进阶<sup>100</sup></a></li>
		  
		
		  
			<li><a href="/categories/Hexo-使用/" title="Hexo 使用">Hexo 使用<sup>10</sup></a></li>
		  
		
		  
			<li><a href="/categories/JavaScript理论/" title="JavaScript理论">JavaScript理论<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Objective-C-相关/" title="Objective C 相关">Objective C 相关<sup>24</sup></a></li>
		  
		
		  
			<li><a href="/categories/OpenCV/" title="OpenCV">OpenCV<sup>6</sup></a></li>
		  
		
		  
			<li><a href="/categories/ROS/" title="ROS">ROS<sup>9</sup></a></li>
		  
		
		  
			<li><a href="/categories/iOS-工具使用/" title="iOS 工具使用">iOS 工具使用<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/iOS-开源库分析/" title="iOS 开源库分析">iOS 开源库分析<sup>36</sup></a></li>
		  
		
		  
			<li><a href="/categories/iOS-理论基础/" title="iOS 理论基础">iOS 理论基础<sup>14</sup></a></li>
		  
		
		  
			<li><a href="/categories/iOS-进阶/" title="iOS 进阶">iOS 进阶<sup>4</sup></a></li>
		  
		
		  
			<li><a href="/categories/个人收藏/" title="个人收藏">个人收藏<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/代码规范/" title="代码规范">代码规范<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/其他/" title="其他">其他<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/博客分类目录/" title="博客分类目录">博客分类目录<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/叨叨系列/" title="叨叨系列">叨叨系列<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/开源代码分析/" title="开源代码分析">开源代码分析<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/开源库分析/" title="开源库分析">开源库分析<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/树莓派/" title="树莓派">树莓派<sup>4</sup></a></li>
		  
		
		  
			<li><a href="/categories/版本控制/" title="版本控制">版本控制<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/直播/" title="直播">直播<sup>6</sup></a></li>
		  
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">Tags</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/iOS-开源库分析/" title="iOS 开源库分析">iOS 开源库分析<sup>36</sup></a></li>
			
		
			
				<li><a href="/tags/Android-设计模式/" title="Android 设计模式">Android 设计模式<sup>29</sup></a></li>
			
		
			
				<li><a href="/tags/Objective-C-相关/" title="Objective C 相关">Objective C 相关<sup>24</sup></a></li>
			
		
			
				<li><a href="/tags/Android基础/" title="Android基础">Android基础<sup>21</sup></a></li>
			
		
			
				<li><a href="/tags/AOSP-源码/" title="AOSP 源码">AOSP 源码<sup>17</sup></a></li>
			
		
			
				<li><a href="/tags/Android-常用第三方库/" title="Android 常用第三方库">Android 常用第三方库<sup>15</sup></a></li>
			
		
			
				<li><a href="/tags/iOS-理论基础/" title="iOS 理论基础">iOS 理论基础<sup>14</sup></a></li>
			
		
			
				<li><a href="/tags/Hexo-使用/" title="Hexo 使用">Hexo 使用<sup>10</sup></a></li>
			
		
			
				<li><a href="/tags/ROS/" title="ROS">ROS<sup>9</sup></a></li>
			
		
			
				<li><a href="/tags/Android-动画进阶/" title="Android 动画进阶">Android 动画进阶<sup>8</sup></a></li>
			
		
			
				<li><a href="/tags/Android-JNI/" title="Android JNI">Android JNI<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/Android-绘图进阶/" title="Android 绘图进阶">Android 绘图进阶<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/Android性能优化/" title="Android性能优化">Android性能优化<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/Android-自动化测试/" title="Android 自动化测试">Android 自动化测试<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/OpenCV/" title="OpenCV">OpenCV<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/直播/" title="直播">直播<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/Android-开源源码/" title="Android 开源源码">Android 开源源码<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/Android-自定义View进阶/" title="Android 自定义View进阶">Android 自定义View进阶<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/树莓派/" title="树莓派">树莓派<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/iOS-进阶/" title="iOS 进阶">iOS 进阶<sup>4</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">Links</p>
    <ul>
        
          <li>
            
            	<a href="https://hexo.io" target="_blank" title="Hexo">Hexo</a>
            
          </li>
        
          <li>
            
            	<a href="https://pages.github.com/" target="_blank" title="GitHub">GitHub</a>
            
          </li>
        
          <li>
            
            	<a href="http://pf18.github.io/" target="_blank" title="PF18">PF18</a>
            
          </li>
        
          <li>
            
            	<a href="http://toutiao.io/" target="_blank" title="开发者头条">开发者头条</a>
            
          </li>
        
          <li>
            
            	<a href="http://www.jcodecraeer.com/" target="_blank" title="泡在网上的日子">泡在网上的日子</a>
            
          </li>
        
    </ul>
</div>

  


  <div class="rsspart">
	<a href="atom.xml" target="_blank" title="rss">RSS</a>
</div>

  
  <div class="tagcloudlist">
    <p class="asidetitle">Tag Cloud</p>
    <div class="tagcloudlist clearfix">
       <a href="/tags/AOSP-%E6%BA%90%E7%A0%81/" style="font-size: 17.14px;">AOSP 源码</a> <a href="/tags/Android-APK-%E7%AD%BE%E5%90%8D/" style="font-size: 10px;">Android APK 签名</a> <a href="/tags/Android-JNI/" style="font-size: 12.86px;">Android JNI</a> <a href="/tags/Android-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E8%BF%9B%E9%98%B6/" style="font-size: 10.71px;">Android 事件处理进阶</a> <a href="/tags/Android-%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6/" style="font-size: 13.57px;">Android 动画进阶</a> <a href="/tags/Android-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%80%E5%8F%91/" style="font-size: 10px;">Android 多线程开发</a> <a href="/tags/Android-%E5%B0%8F%E7%BB%8F%E9%AA%8C/" style="font-size: 10px;">Android 小经验</a> <a href="/tags/Android-%E5%B8%B8%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/" style="font-size: 16.43px;">Android 常用第三方库</a> <a href="/tags/Android-%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/" style="font-size: 10px;">Android 开发流程</a> <a href="/tags/Android-%E5%BC%80%E6%BA%90%E6%BA%90%E7%A0%81/" style="font-size: 12.14px;">Android 开源源码</a> <a href="/tags/Android-%E7%BB%98%E5%9B%BE%E8%BF%9B%E9%98%B6/" style="font-size: 12.86px;">Android 绘图进阶</a> <a href="/tags/Android-%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/" style="font-size: 12.86px;">Android 自动化测试</a> <a href="/tags/Android-%E8%87%AA%E5%AE%9A%E4%B9%89View%E8%BF%9B%E9%98%B6/" style="font-size: 12.14px;">Android 自定义View进阶</a> <a href="/tags/Android-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 19.29px;">Android 设计模式</a> <a href="/tags/Android%E5%85%B6%E4%BB%96/" style="font-size: 10px;">Android其他</a> <a href="/tags/Android%E5%9F%BA%E7%A1%80/" style="font-size: 17.86px;">Android基础</a> <a href="/tags/Android%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/" style="font-size: 10px;">Android开发流程</a> <a href="/tags/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" style="font-size: 12.86px;">Android性能优化</a> <a href="/tags/Android%E6%B7%B7%E6%B7%86%E6%8A%80%E6%9C%AF/" style="font-size: 10px;">Android混淆技术</a> <a href="/tags/Android%E8%B4%A8%E9%87%8F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/" style="font-size: 11.43px;">Android质量管理工具</a> <a href="/tags/Android%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/" style="font-size: 10px;">Android逆向工程</a> <a href="/tags/Git-github/" style="font-size: 10px;">Git && github</a> <a href="/tags/Hexo-%E4%BD%BF%E7%94%A8/" style="font-size: 15px;">Hexo 使用</a> <a href="/tags/JavaScript/" style="font-size: 10px;">JavaScript</a> <a href="/tags/Linux-%E4%BD%BF%E7%94%A8/" style="font-size: 10px;">Linux 使用</a> <a href="/tags/Objective-C-%E7%9B%B8%E5%85%B3/" style="font-size: 18.57px;">Objective C 相关</a> <a href="/tags/OpenCV/" style="font-size: 12.86px;">OpenCV</a> <a href="/tags/ROS/" style="font-size: 14.29px;">ROS</a> <a href="/tags/iOS-%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/" style="font-size: 10.71px;">iOS 工具使用</a> <a href="/tags/iOS-%E5%BC%80%E6%BA%90%E5%BA%93%E5%88%86%E6%9E%90/" style="font-size: 20px;">iOS 开源库分析</a> <a href="/tags/iOS-%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/" style="font-size: 15.71px;">iOS 理论基础</a> <a href="/tags/iOS-%E8%BF%9B%E9%98%B6/" style="font-size: 12.14px;">iOS 进阶</a> <a href="/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/" style="font-size: 10px;">代码规范</a> <a href="/tags/%E5%8D%9A%E5%AE%A2%E5%88%86%E7%B1%BB%E7%9B%AE%E5%BD%95/" style="font-size: 10.71px;">博客分类目录</a> <a href="/tags/%E5%8F%A8%E5%8F%A8%E7%B3%BB%E5%88%97/" style="font-size: 10px;">叨叨系列</a> <a href="/tags/%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/" style="font-size: 11.43px;">工具的使用</a> <a href="/tags/%E5%BC%80%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/" style="font-size: 10.71px;">开源代码分析</a> <a href="/tags/%E5%BC%80%E6%BA%90%E5%BA%93%E5%88%86%E6%9E%90/" style="font-size: 10px;">开源库分析</a> <a href="/tags/%E6%9D%82%E7%B1%BB/" style="font-size: 10px;">杂类</a> <a href="/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/" style="font-size: 12.14px;">树莓派</a> <a href="/tags/%E7%9B%B4%E6%92%AD/" style="font-size: 12.86px;">直播</a> <a href="/tags/%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/" style="font-size: 10.71px;">编程技巧</a> <a href="/tags/%E7%BD%91%E7%AB%99%E6%94%B6%E8%97%8F/" style="font-size: 10px;">网站收藏</a> <a href="/tags/%E9%87%8D%E8%A6%81%E6%8E%A7%E4%BB%B6/" style="font-size: 11.43px;">重要控件</a>
    </div>
  </div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
		
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/hsihohuang/kiddochan" target="_blank" title="Kiddochan">Kiddochan</a> © 2022 
		
		<a href="/about" target="_blank" title="Edgar">Edgar</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
        
    }
  });
});
</script>










<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?7c9443b0374f1cf6b1dbb5ab84d939cb";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="Back to Top"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
 </html>
