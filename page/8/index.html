
 <!DOCTYPE HTML>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
  
    <title>Edgar&#39;s Blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="Edgar">
    

    
    <meta name="description" content="Android | 全栈工程师">
<meta property="og:type" content="website">
<meta property="og:title" content="Edgar&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/page/8/index.html">
<meta property="og:site_name" content="Edgar&#39;s Blog">
<meta property="og:description" content="Android | 全栈工程师">
<meta property="og:locale">
<meta property="article:author" content="Edgar">
<meta name="twitter:card" content="summary">

    
    <link rel="alternative" href="atom.xml" title="Edgar&#39;s Blog" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/unnamed4_n_mSY_icon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/profile.png">
    <link rel="apple-touch-icon-precomposed" href="/img/profile.png">
    
    
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 6.2.0"></head>

  <body>
    <header>
      
<div>
		
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="Edgar&#39;s Blog">Edgar&#39;s Blog</a></h1>
				<h2 class="blog-motto"></h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="Menu">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
					<li>
 					
					<form class="search" action="/search/index.html" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" autocomplete="off" name="q" maxlength="20" placeholder="Search" />
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main">

   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/08/10/iOS开发中的定时器实现总结/" title="iOS开发中的定时器实现总结" itemprop="url">iOS开发中的定时器实现总结</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Edgar" target="_blank" itemprop="author">Edgar</a>
		
  <p class="article-time">
    <time datetime="2019-08-10T02:43:25.000Z" itemprop="datePublished"> Published 2019-08-10</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h6 id="NSTimmer"><a href="#NSTimmer" class="headerlink" title="NSTimmer"></a><strong><strong>NSTimmer</strong></strong></h6><h6 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h6><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NS_ASSUME_NONNULL_BEGIN</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">IDLTimerProxy</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">NSTimer</span> *)scheduledTimerWithTimeInterval:(<span class="built_in">NSTimeInterval</span>)ti target:(<span class="type">id</span>)aTarget selector:(SEL)aSelector userInfo:(<span class="keyword">nullable</span> <span class="type">id</span>)userInfo repeats:(<span class="type">BOOL</span>)yesOrNo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NS_ASSUME_NONNULL_END</span></span><br></pre></td></tr></table></figure>

<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&quot;IDLTimerProxy.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">IDLTimerProxy</span>()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>, <span class="keyword">readwrite</span>) SEL       selector;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>,   <span class="keyword">readwrite</span>) <span class="type">id</span>        target;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>,   <span class="keyword">readwrite</span>) <span class="built_in">NSTimer</span>   *timer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">IDLTimerProxy</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">NSTimer</span> *)scheduledTimerWithTimeInterval:(<span class="built_in">NSTimeInterval</span>)ti target:(<span class="type">id</span>)aTarget selector:(SEL)aSelector userInfo:(<span class="keyword">nullable</span> <span class="type">id</span>)userInfo repeats:(<span class="type">BOOL</span>)yesOrNo &#123;</span><br><span class="line">    IDLTimerProxy *proxy = [IDLTimerProxy new];</span><br><span class="line">    proxy.target = aTarget;</span><br><span class="line">    proxy.selector = aSelector;</span><br><span class="line">    proxy.timer = [<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:ti target:proxy selector:<span class="keyword">@selector</span>(performSelectorWithTimmer:) userInfo:userInfo repeats:yesOrNo];</span><br><span class="line">    <span class="keyword">return</span> proxy.timer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)performSelectorWithTimmer:(<span class="built_in">NSTimer</span> *)timmer &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">self</span>.target &amp;&amp; [<span class="keyword">self</span>.target respondsToSelector:<span class="keyword">self</span>.selector]) &#123;</span><br><span class="line">        [<span class="keyword">self</span>.target performSelector:<span class="keyword">self</span>.selector withObject:timmer.userInfo];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        [<span class="keyword">self</span>.timer invalidate];</span><br><span class="line">        <span class="keyword">self</span>.timer = <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>调用方式：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">self</span>.timmer = [IDLTimerProxy scheduledTimerWithTimeInterval:<span class="number">5</span> target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(run:) userInfo:<span class="literal">nil</span> repeats:<span class="literal">YES</span>];</span><br></pre></td></tr></table></figure>

<h6 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h6><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NS_ASSUME_NONNULL_BEGIN</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">IDLWeakTimerProxy</span> : <span class="title">NSProxy</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">instancetype</span>)proxyWithTarget:(<span class="type">id</span>)targe;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NS_ASSUME_NONNULL_END</span></span><br></pre></td></tr></table></figure>


<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&quot;IDLWeakTimerProxy.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">IDLWeakTimerProxy</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readwrite</span>) <span class="type">id</span> target;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">IDLWeakTimerProxy</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">instancetype</span>)proxyWithTarget:(<span class="type">id</span>)target &#123;</span><br><span class="line">    <span class="keyword">return</span> [[IDLWeakTimerProxy alloc] initWithTarget:target];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithTarget:(<span class="type">id</span>)target &#123;</span><br><span class="line">    _target = target;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)sel &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span>.target methodSignatureForSelector:sel];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)invocation &#123;</span><br><span class="line">    <span class="keyword">if</span>(!invocation) <span class="keyword">return</span>;</span><br><span class="line">    SEL selector = invocation.selector;</span><br><span class="line">    <span class="keyword">if</span>([<span class="keyword">self</span>.target respondsToSelector:selector]) &#123;</span><br><span class="line">        [invocation invokeWithTarget:<span class="keyword">self</span>.target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">BOOL</span>)respondsToSelector:(SEL)aSelector &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span>.target respondsToSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>调用方式：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">self</span>.weakTimmerProxy = [IDLWeakTimerProxy proxyWithTarget:<span class="keyword">self</span>];</span><br><span class="line"><span class="keyword">self</span>.timmer = [<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="number">3</span> target:<span class="keyword">self</span>.weakTimmerProxy selector:<span class="keyword">@selector</span>(run:) userInfo:<span class="literal">nil</span> repeats:<span class="literal">YES</span>];</span><br></pre></td></tr></table></figure>

<h6 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h6><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSTimer</span> (<span class="title">IDLBlockTimer</span>)</span></span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">NSTimer</span> *)idl_scheduledTimerWithTimeInterval:(<span class="built_in">NSTimeInterval</span>)interval block:(<span class="type">void</span> (^)(<span class="type">void</span>))block repeats:(<span class="type">BOOL</span>)repeats &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> scheduledTimerWithTimeInterval:interval target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(idl_blockSelector:) userInfo:[block <span class="keyword">copy</span>] repeats:repeats];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="type">void</span>)idl_blockSelector:(<span class="built_in">NSTimer</span> *)timer &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span>(^block)(<span class="type">void</span>) = timer.userInfo;</span><br><span class="line">    <span class="keyword">if</span> (block) &#123;</span><br><span class="line">        block();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<h6 id="dispatch-source-t"><a href="#dispatch-source-t" class="headerlink" title="dispatch_source_t"></a><strong><strong>dispatch_source_t</strong></strong></h6><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">self.gcdTimmer = <span class="keyword">dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, </span><span class="number">0</span>, <span class="number">0</span>, <span class="keyword">dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, </span><span class="number">0</span>));</span><br><span class="line"><span class="keyword">dispatch_source_set_timer(self.gcdTimmer, </span><span class="keyword">dispatch_time(DISPATCH_TIME_NOW, </span><span class="number">0</span>), <span class="number">3</span> * NSEC_PER_SEC, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">dispatch_source_set_event_handler(self.gcdTimmer, </span>^&#123;</span><br><span class="line">    </span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">dispatch_resume(self.gcdTimmer);</span></span><br></pre></td></tr></table></figure>

<h6 id="CADisplayLink"><a href="#CADisplayLink" class="headerlink" title="CADisplayLink"></a><strong><strong>CADisplayLink</strong></strong></h6><ul>
<li><strong><strong>CADisplayLink 与 NSTimer 的区别：</strong></strong></li>
</ul>
<ul>
<li><p>CADisplayLink是一个能让我们以和屏幕刷新率同步的频率将特定的内容绘制到屏幕上的定时器类。CADisplayLink以特定模式注册到runloop后，每当屏幕显示内容刷新结束的时候，runloop就会向CADisplayLink指定的target发送一次指定的selector消息，CADisplayLink类对应的selector就会被调用一次。</p>
</li>
<li><p>NSTimer以指定的模式注册到runloop后，每当设定的周期时间到达后，runloop会向指定的target发送一次指定的selector消息。</p>
</li>
<li><p><strong><strong>对于精度而言</strong></strong>：</p>
</li>
</ul>
<p>由于iOS设备的屏幕刷新频率是固定的，CADisplayLink在正常情况下精确度相当高。NSTimer的精确度就显得低了点，比如NSTimer的触发时间到的时候，runloop如果在忙于别的调用，触发时间就会推迟到下一个runloop周期。NSTimer新增了tolerance属性，让用户可以设置可以容忍的触发的时间范围。</p>
<ul>
<li><strong><strong>对于使用场景而言</strong></strong>：</li>
</ul>
<p>CADisplayLink使用场合相对专一，适合做界面的不停重绘。而NSTimer的使用范围要广泛的多，各种需要单次或者循环定时处理的任务都可以使用。</p>
<ul>
<li><p><strong><strong>例子：</strong></strong></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">self</span>.weakTimmerProxy = [IDLWeakTimerProxy proxyWithTarget:<span class="keyword">self</span>];</span><br><span class="line"><span class="keyword">self</span>.cadisplaylink = [<span class="built_in">CADisplayLink</span> displayLinkWithTarget:<span class="keyword">self</span>.weakTimmerProxy selector:<span class="keyword">@selector</span>(run:)];</span><br><span class="line">[<span class="keyword">self</span>.cadisplaylink addToRunLoop:[<span class="built_in">NSRunLoop</span> currentRunLoop] forMode:<span class="built_in">NSRunLoopCommonModes</span>];</span><br><span class="line"><span class="keyword">self</span>.cadisplaylink.paused = <span class="literal">YES</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><strong>CADisplayLink 接口：</strong></strong></p>
</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">CADisplayLink</span> : <span class="title">NSObject</span></span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">@private</span></span><br><span class="line">  <span class="type">void</span> *_impl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//每秒多少帧</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">NSInteger</span> preferredFramesPerSecond</span><br><span class="line">    API_AVAILABLE(ios(<span class="number">10.0</span>), watchos(<span class="number">3.0</span>), tvos(<span class="number">10.0</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 display link</span></span><br><span class="line">+ (<span class="built_in">CADisplayLink</span> *)displayLinkWithTarget:(<span class="type">id</span>)target selector:(SEL)sel;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将display link 添加到 runloop 除非停止，否则在每个vsync信号到来的时候定时调用selector</span></span><br><span class="line">- (<span class="type">void</span>)addToRunLoop:(<span class="built_in">NSRunLoop</span> *)runloop forMode:(<span class="built_in">NSRunLoopMode</span>)mode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将display link 从runloop中移除</span></span><br><span class="line">- (<span class="type">void</span>)removeFromRunLoop:(<span class="built_in">NSRunLoop</span> *)runloop forMode:(<span class="built_in">NSRunLoopMode</span>)mode;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将display link 从所有的runloop modes中移除，并且释放target 对象。</span></span><br><span class="line">- (<span class="type">void</span>)invalidate;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 暂停display link</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">getter</span>=isPaused, <span class="keyword">nonatomic</span>) <span class="type">BOOL</span> paused;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">readonly</span>, <span class="keyword">nonatomic</span>) <span class="built_in">CFTimeInterval</span> timestamp; <span class="comment">//表示屏幕显示的上一帧的时间戳</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">readonly</span>, <span class="keyword">nonatomic</span>) <span class="built_in">CFTimeInterval</span> duration;  <span class="comment">//两帧间隔时间 默认为16.6ms</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">readonly</span>, <span class="keyword">nonatomic</span>) <span class="built_in">CFTimeInterval</span> targetTimestamp</span><br><span class="line">    API_AVAILABLE(ios(<span class="number">10.0</span>), watchos(<span class="number">3.0</span>), tvos(<span class="number">10.0</span>));</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>




        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/iOS-%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/">iOS 理论基础</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/iOS-理论基础/">iOS 理论基础</a>
  </div>

</div>



<div class="comments-count">
	
	  	<span></span>
		<a href="/2019/08/10/iOS开发中的定时器实现总结/#comments" class="ds-thread-count comments-count-link" data-thread-key="2019/08/10/iOS开发中的定时器实现总结/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/08/10/iOS-KeyChain-总结/" title="iOS KeyChain 总结" itemprop="url">iOS KeyChain 总结</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Edgar" target="_blank" itemprop="author">Edgar</a>
		
  <p class="article-time">
    <time datetime="2019-08-10T02:33:25.000Z" itemprop="datePublished"> Published 2019-08-10</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h5 id="1-KeyChain-简要概述"><a href="#1-KeyChain-简要概述" class="headerlink" title="1. KeyChain 简要概述"></a>1. KeyChain 简要概述</h5><p><img src="/2019/08/10/iOS-KeyChain-%E6%80%BB%E7%BB%93/000001.png"></p>
<p>KeyChain的实质是一个安全的数据库（数据库位于&#x2F;private&#x2F;var&#x2F;Keychains&#x2F;keychain-2.db),里面大部分数据都是加密的, 我们可以用KeyChain保存一些私密信息，比如密码、证书、设备唯一码（UDID）等等，总的来说KeyChain有如下特点：</p>
<ol>
<li>安全</li>
<li>Keychain的信息是存在于每个应用沙盒之外由系统负责管理，因此不会因App删除而丢失，在重装App后，Keychain里的数据还能使用,除非将系统恢复出厂设置。</li>
<li>一般而言不同App之间Keychain不能相互访问，但是从iOS 3 开始可以通过设置共有钥匙串部分信息。可以利用这一特性在自家的应用上共享KeyChain信息。</li>
</ol>
<h5 id="2-KeyChain的结构"><a href="#2-KeyChain的结构" class="headerlink" title="2. KeyChain的结构"></a>2. KeyChain的结构</h5><p>每一个KeyChain由多个KeyChain item组成，KeyChain item的结构类似字典，同时每条KeyChain Item还包含一条data和多个attributes组成。<br>其中苹果提供了下面几种类型的keychain item，并且对不同类型的item做了不同的处理，比如password和key类的item就会做加密，而certificates类的就不会。</p>
<ul>
<li>kSecClass</li>
</ul>
<p>KeyChain Item 的类别，可以是下面几项：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="built_in">CFTypeRef</span> kSecClassGenericPassword   <span class="comment">//通用密码项</span></span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">CFTypeRef</span> kSecClassInternetPassword  <span class="comment">//互联网密码项</span></span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">CFTypeRef</span> kSecClassCertificate       <span class="comment">//证书项</span></span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">CFTypeRef</span> kSecClassKey               <span class="comment">//key项</span></span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">CFTypeRef</span> kSecClassIdentity          <span class="comment">//认证项</span></span><br></pre></td></tr></table></figure>

<p>系统指定的这些item都有特定需要配置的属性，这些属性是可选的不一定都需要给定，详细的可以查看SecItem.h文件，下面仅仅列出kSecClassGenericPassword的Attribute.</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line">kSecClassGenericPassword item <span class="keyword">attributes</span>:</span><br><span class="line">kSecAttrAccess (OS X only)</span><br><span class="line">kSecAttrAccessControl</span><br><span class="line">kSecAttrAccessGroup (iOS<span class="comment">; also OS X if kSecAttrSynchronizable specified)</span></span><br><span class="line">kSecAttrAccessible (iOS<span class="comment">; also OS X if kSecAttrSynchronizable specified)</span></span><br><span class="line">kSecAttrCreationDate</span><br><span class="line">kSecAttrModificationDate</span><br><span class="line">kSecAttrDescription</span><br><span class="line">kSecAttrComment</span><br><span class="line">kSecAttrCreator</span><br><span class="line">kSecAttrType</span><br><span class="line">kSecAttrLabel</span><br><span class="line">kSecAttrIsInvisible</span><br><span class="line">kSecAttrIsNegative</span><br><span class="line">kSecAttrAccount</span><br><span class="line">kSecAttrService</span><br><span class="line">kSecAttrGeneric</span><br><span class="line">kSecAttrSynchronizable</span><br></pre></td></tr></table></figure>
<p>需要注意的kSecClassIdentity item 由于是私有key和证书的结合，因此它的Attribute是二者的合集。</p>
<p>其中还有个比较重要的Attribute是kSecAttrAccessible，在我们调用SecItemCopyMatching方法返回item数据的时候，如果权限不够就会抛出errSecInteractionNotAllowed的错误。</p>
<figure class="highlight mathematica"><table><tr><td class="code"><pre><span class="line"><span class="variable">kSecAttrAccessibleWhenUnlocked</span>     当前的<span class="built_in">Item</span>只有设备处于解锁状态才能被访问<span class="operator">,</span>这个适用于在前台访问的<span class="built_in">Item</span><span class="operator">.</span></span><br><span class="line"><span class="variable">kSecAttrAccessibleAfterFirstUnlock</span> 当前的<span class="built_in">Item</span>只有设备重启并解锁后才能被访问，这个适用于需要在后台访问的<span class="built_in">Item</span><span class="operator">.</span></span><br><span class="line"><span class="variable">kSecAttrAccessibleAlways</span>           不论是否解锁库，都能访问改<span class="variable">item</span>，这种类型极为不安全，不推荐使用。</span><br></pre></td></tr></table></figure>

<p>上面这些类型在加密备份的时候都会同步到新的机器上。</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">kSecAttrAccessibleWhenUnlockedThisDeviceOnly</span></span><br><span class="line"><span class="attribute">kSecAttrAccessibleAfterFirstUnlockThisDeviceOnly</span></span><br><span class="line"><span class="attribute">kSecAttrAccessibleAlwaysThisDeviceOnly</span></span><br></pre></td></tr></table></figure>

<p>上面这些多出了ThisDeviceOnly，这个表明这些Item在加密备份后，会被以硬件相关的密钥(key)加密。并且不会随着备份移动至其他设备。</p>
<p>一般而言最好不要将Item设置为kSecAttrAccessibleAlways，并且钥匙串可以通过iTunes或iCloud同步的方式同步到其他设备，如果你保存的数据高度敏感，则需要使用后缀为ThisDeviceOnly的选项。</p>
<p>Keychain 从 iOS 7.0 开始也支持iCloud备份。把kSecAttrSynchronizable属性设置为@YES，这样后Keychain就能被iCloud备份并且跨设备分享。</p>
<p><img src="/2019/08/10/iOS-KeyChain-%E6%80%BB%E7%BB%93/000003.png"></p>
<h5 id="3-在项目中引入KeyChain的方案："><a href="#3-在项目中引入KeyChain的方案：" class="headerlink" title="3. 在项目中引入KeyChain的方案："></a>3. 在项目中引入KeyChain的方案：</h5><p>不论使用下面哪种方式在使用之前都必须往项目中导入Security.framework框架</p>
<p>对于KeyChain 的封装较少目前网上用得较多的有如下三种方式：</p>
<ol>
<li>使用官方推出的 <a target="_blank" rel="noopener" href="https://github.com/baptistefetet/KeychainItemWrapper">KeychainItemWrapper</a></li>
</ol>
<p>使用KeychainItemWrapper保存数据：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">KeychainItemWrapper *<span class="keyword">wrapper</span> = [[KeychainItemWrapper alloc] initWithIdentifier:@&quot;idealists&quot; accessGroup:nil];</span><br><span class="line">NSString *username = @&quot;linxiaohai&quot;;</span><br><span class="line">NSString *<span class="keyword">password</span> = @&quot;123&quot;;</span><br><span class="line">[<span class="keyword">wrapper</span> setObject:username forKey:(id)kSecAttrAccount];</span><br><span class="line">[<span class="keyword">wrapper</span> setObject:<span class="keyword">password</span> forKey:(id)kSecValueData];</span><br></pre></td></tr></table></figure>

<p>在初始化KeychainItemWrapper会用到两个参数：</p>
<ul>
<li>Identifier: 我们从keychain中取数据的时候会用到</li>
<li>accessGroup: 如果想要在应用之间共享信息，那么需要指定访问组KeyChain Access Group.如果不需要共享则传nil</li>
</ul>
<ul>
<li>(void)setObject:(id)inObject forKey:(id)key;<br>这里的key必须是Security.framework 里头文件“SecItem.h”里定义好的key，用其他字符串做key程序会崩溃</li>
</ul>
<p>使用KeychainItemWrapper获取数据：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">KeychainItemWrapper *<span class="keyword">wrapper</span> = [[KeychainItemWrapper alloc] initWithIdentifier:@&quot;idealists&quot; accessGroup:nil];</span><br><span class="line">username = [<span class="keyword">wrapper</span> objectForKey:(id)kSecAttrAccount];</span><br><span class="line"><span class="keyword">password</span> = [<span class="keyword">wrapper</span> objectForKey:(id)kSecValueData];</span><br></pre></td></tr></table></figure>
<p>这里需要注意的是identifier和accessGroup必须要对应上。</p>
<ol start="2">
<li><p>第三方封装<a target="_blank" rel="noopener" href="https://github.com/soffes/SAMKeychain">SAMKeychain</a>,<a target="_blank" rel="noopener" href="https://github.com/samsoffes/sskeychain">SSKeychain</a><br>这两个三方库其实是同一个实现，只不过在iOS 10中有个私有系统类也叫SSKeychain，所以如果在iOS 10中使用会有不兼容的问题，可以查看对应的<a target="_blank" rel="noopener" href="https://github.com/soffes/SAMKeychain/issues/179">issue</a></p>
<p>这个是star 比较多的一个开源项目，接口也十分简单。</p>
</li>
<li><p>通过Security.framework框架使用<br>不论是KeychainItemWrapper还是SAMKeychain都是对Security的封装，Security.framework提供了如下的API供我们使用：</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">SecItemAdd 添加一个keychain <span class="built_in">item</span></span><br><span class="line">SecItemUpdate 修改一个keychain <span class="built_in">item</span></span><br><span class="line">SecItemCopyMatching 搜索一个keychain <span class="built_in">item</span></span><br><span class="line">SecItemDelete 删除一个keychain <span class="built_in">item</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h5 id="4-使用KeyChain-Access-Group-实现不同APP共享Keychain中的数据"><a href="#4-使用KeyChain-Access-Group-实现不同APP共享Keychain中的数据" class="headerlink" title="4. 使用KeyChain Access Group 实现不同APP共享Keychain中的数据"></a>4. 使用KeyChain Access Group 实现不同APP共享Keychain中的数据</h5><p>从iOS 3.0 之后，不同应用之间可以共享KeyChain 数据了。如果我们的产品线有一系列的应用并且这些应用之间需要共享一些公共的账号信息，就可以通过共享KeyChain来实现。但是这是有严格限制的，只有拥有相同 App ID 前缀的应用才有可能共享 keychain。并且各应用存储的 keychain item 都需要标记了相同的 kSecAccessGroup 字段值。</p>
<p>App ID 是由两个部分组成:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Bundle</span> <span class="attr">Seed</span> <span class="attr">ID</span>&gt;</span> . <span class="tag">&lt;<span class="name">Bundle</span>  <span class="attr">Identifier</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Bundle Seed ID(Team ID) 是由苹果公司在第一次创建一个App ID生成的，是一个唯一的10个字符组成的字符串。Bundle  Identifier这个就是我们应用的bundle id。<br>比如：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="number">659823</span>F3DC53<span class="selector-class">.com</span><span class="selector-class">.example</span>.amazingApp</span><br></pre></td></tr></table></figure>
<p>659823F3DC53 是我们的Team ID。一个开发者账号可以有几个不同的Team ID。也就是说要共享数据必须要求使用同一个Team ID。</p>
<p>比如我们的两个应用App ID如下：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">ABC1234DEF<span class="selector-class">.com</span><span class="selector-class">.useyourloaf</span><span class="selector-class">.amazingApp1</span></span><br><span class="line">ABC1234DEF<span class="selector-class">.com</span><span class="selector-class">.useyourloaf</span>.amazingApp2</span><br></pre></td></tr></table></figure>
<p>我们可以定义一个共享的KeyChain Access Group</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">ABC1234DEF</span>.</span></span>amazingAppFamily</span><br></pre></td></tr></table></figure>

<ol>
<li>Project-&gt; Capebilities-&gt; Keychain Sharing ，将Keychain Sharing打开，在新版的Xcode中，将Keychain Sharing打开后，会在项目对应的目录下自动生成对应的Entitlements文件，在Entitlements文件的KeyChain Access Group节点中添加KeyChain Access Group名字。ABC1234DEF.amazingAppFamily</li>
</ol>
<p><img src="/2019/08/10/iOS-KeyChain-%E6%80%BB%E7%BB%93/0000111.png"></p>
<ol start="2">
<li><p>在 Project-&gt; Build Setting -&gt; Code Signing Entitlements 中添加上一个步骤生成的Entitlements文件。</p>
</li>
<li><p>在存储数据的时候指定kSecAttrAccessGroup 为 ABC1234DEF.amazingAppFamily</p>
</li>
</ol>
<h5 id="5-使用keychain需要注意的问题"><a href="#5-使用keychain需要注意的问题" class="headerlink" title="5. 使用keychain需要注意的问题"></a>5. 使用keychain需要注意的问题</h5><ul>
<li>当我们没有打开Keychain Access Group，并且没有entitlement文件时，KeyChain默认以bundle id为Group。如果我们在版本更新的时候改变了bundle id，那么新版本就访问不了旧版本的KeyChain信息了。解决办法是从一开始我们就打开KeychainSharing，添加Keychain Access Group，并且指定每条keychain Item的group，私有的信息就指定app的bundle id为它的Group。</li>
<li>代码内Access group名称一定要有AppIdentifierPrefix前缀。</li>
<li>Keychain是基于数据库存储，不允许添加重复的条目。所以每条item都必须指定对应的唯一标识符也就是那些主要的key，如果Key指定不正确，可能会出现添加后查找不到的问题。</li>
<li>kSecAttrSynchronizable也会作为主要的key之一。它的value值默认为No，如果之前添加的item此条属性为YES，在搜索，更新，删除的时候必须添加此条属性才能查找到之前添加的item。</li>
<li>KeyChain item字典内添加自定义key时会出现参数不合法的错误,所以要注意对传入的参数进行校验。</li>
</ul>
<h5 id="6-Keychain的安全性"><a href="#6-Keychain的安全性" class="headerlink" title="6. Keychain的安全性"></a>6. Keychain的安全性</h5><p>Keychain内部的数据会自动加密。如果设备没有越狱并且不暴力破解，Keychain确实很安全。但是越狱后的设备，Keychain就很危险了，结合Keychain Dumper等工具,很容易拿到Keychain数据，网上也有较多现成攻略，</p>
<h5 id="6-KeyChain的进一步封装"><a href="#6-KeyChain的进一步封装" class="headerlink" title="6. KeyChain的进一步封装"></a>6. KeyChain的进一步封装</h5><p>SAMKeychain 是一个很不错的项目，但是它只提供密码形式的存储，这里向借鉴SAMKeychain对KeyChain的核心功能的封装以及Masory配置属性的方式（主要是克服使用字典方式传递参数的时候，如果key不是指定的会崩溃的问题）</p>
<p><img src="/2019/08/10/iOS-KeyChain-%E6%80%BB%E7%BB%93/0000222.png"></p>
<p>主要分成四层：</p>
<ol>
<li><p>KeyChainAttibuteMaker：将kSecClass传递进去KeyChainAttibuteMaker根据kSecClass，新建出对应的KeyChainItemAttribute的子项，比如传入kSecClassGenericPassword会新建一个GenericPasswordAttribute，并通过Block传出，供外面对属性进行配置。</p>
</li>
<li><p>KeyChainAttibuteMaker会对配置完的KeyChainItemAttribute对象进行校验，对于非nil类型的属性，根据属性名，获取Keychain Attribute 的key字符串，构建出NSDirectionary对象传递出来。</p>
</li>
<li><p>NMKeyChainTool 提供顶层的封装供外部开发者调用，它主要完成两项任务： KeyChainItemAttribute 的构建，KeyChainItemAttribute转NSDirectionary 调用NMKeyChainItemQuery操作KeyChain</p>
</li>
<li><p>NMKeyChainItemQuery 是比较纯粹的增删改查的操作。调用的是Security.framework的SecItemAdd，SecItemUpdate，SecItemCopyMatching，SecItemDelete对KeyChain进行操作。</p>
</li>
</ol>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/iOS-%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/">iOS 理论基础</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/iOS-理论基础/">iOS 理论基础</a>
  </div>

</div>



<div class="comments-count">
	
	  	<span></span>
		<a href="/2019/08/10/iOS-KeyChain-总结/#comments" class="ds-thread-count comments-count-link" data-thread-key="2019/08/10/iOS-KeyChain-总结/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/08/08/iOS-动画总结/" title="iOS 动画总结" itemprop="url">iOS 动画总结</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Edgar" target="_blank" itemprop="author">Edgar</a>
		
  <p class="article-time">
    <time datetime="2019-08-07T17:30:44.000Z" itemprop="datePublished"> Published 2019-08-08</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h5 id="开篇叨叨"><a href="#开篇叨叨" class="headerlink" title="开篇叨叨"></a><strong><strong>开篇叨叨</strong></strong></h5><p>iOS动画简单说就是在一段时间内CALayer的Animatable Property发生了变化，一个完整动画包括时间成份（时长，时间变化曲线，动画速度），动画内容（哪些属性发生变化），属性变化范围：（fromValue,toValue），iOS的动画是基于Core Animation的，Core Animation将大部分实际的绘图任务交给了图形硬件GPU来处理，GPU会加速图形渲染的速度。这种加速技术让动画拥有更高的帧率并且显示效果更加平滑，不会加重CPU的负担而影响程序的运行速度。一般我们在项目中除了十分复杂或者比较简单的动画使用CAAnimation外，一般都是使用三方的动画库，比如<a target="_blank" rel="noopener" href="https://github.com/jhurray/JHChainableAnimations">JHChainableAnimations</a>，<a target="_blank" rel="noopener" href="https://github.com/Lision/LSAnimator">LSAnimator</a>,这两种都是支持Objective C 和 Swift, 并且是通过链式调用，用起来还是十分方便的，对了还有Facebook 的 <a target="_blank" rel="noopener" href="https://github.com/facebook/pop">POP</a>,但是对于复杂的动画还是部分需要自己来封装。还有一类帧动画我们一般用lottie-ios，只要设计提供个json文件和资源文件就可以完成十分酷炫的动画。</p>
<p>这篇博客将从如下几个方面对iOS的动画做个总结：</p>
<ul>
<li>CAAnimation的继承结构</li>
<li>动画相关的CALayer</li>
<li>时间系统</li>
<li>动画事务管理</li>
</ul>
<h5 id="CAAnimation的继承结构"><a href="#CAAnimation的继承结构" class="headerlink" title="CAAnimation的继承结构"></a><strong><strong>CAAnimation的继承结构</strong></strong></h5><p>要了解iOS动画最重要的是对整个动画的继承结构，下图是CAAnimation的继承结构图：</p>
<p><img src="/2019/08/08/iOS-%E5%8A%A8%E7%94%BB%E6%80%BB%E7%BB%93/00001.png"></p>
<h6 id="CAAnimation"><a href="#CAAnimation" class="headerlink" title="CAAnimation"></a><strong><strong>CAAnimation</strong></strong></h6><p>CAAnimation 这个是基类，它不是为了创建对象而存在的，它主要用于存放一些通用性的属性和方法，它有两个很重要的属性：timingFunction，delegate。</p>
<ul>
<li>timingFunction 表示的是时间曲线，我们知道并不是所有的动画都是线性变化的，它们可能先快后慢，或者先慢后快，这就是由timingFunction决定的。timingFunction 是 CAMediaTimingFunction类型，它的可能值如下：</li>
</ul>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">kCAMediaTimingFunctionLinear</span></span><br><span class="line"><span class="attribute">kCAMediaTimingFunctionEaseIn</span></span><br><span class="line"><span class="attribute">kCAMediaTimingFunctionEaseOut</span></span><br><span class="line"><span class="attribute">kCAMediaTimingFunctionEaseInEaseOut</span></span><br><span class="line"><span class="attribute">kCAMediaTimingFunctionDefault</span></span><br></pre></td></tr></table></figure>

<ul>
<li>delegate 这个是CAAnimationDelegate类型的代理。CAAnimationDelegate很简单，它只有两个方法：</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)animationDidStart:(<span class="built_in">CAAnimation</span> *)anim;  </span><br><span class="line"><span class="comment">//动画开始</span></span><br><span class="line">- (<span class="type">void</span>)animationDidStop:(<span class="built_in">CAAnimation</span> *)anim finished:(<span class="type">BOOL</span>)flag; </span><br><span class="line"><span class="comment">//动画停止，这种停止可以是因为动画结束，也有可能是因为动画从它的载体上移除，这里可以通过flag来区分。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>同时CAAnimation遵循CAMediaTiming协议，这里包含了动画的很多基本属性：</p>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line"><span class="built_in">duration</span>：动画播放一次所用的时间</span><br></pre></td></tr></table></figure>
<figure class="highlight erlang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">begin</span>Time：动画起始时间</span><br><span class="line">可以使用它来达到延迟执行动画的效果 <span class="keyword">begin</span>Time = CACurrentMediaTime()+<span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight gml"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">speed</span>:</span><br><span class="line">如果把动画的duration设置为<span class="number">3</span>秒，而<span class="variable language_">speed</span>设置为<span class="number">2</span>，动画将会在<span class="number">1.5</span>秒结束,并且动画速度是有层级关系的：一个动画的<span class="variable language_">speed</span>为<span class="number">1.5</span>，它同时是一个<span class="variable language_">speed</span>为<span class="number">2</span>的动画组的一个动画成员，则它将以<span class="number">3</span>倍速度被执行。</span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">timeOffset：</span><br><span class="line">这个属性往往会结合其他属性类来控制动画的“当前时间”，下面是暂停动画的代码，在开发中十分实用，因为动画要么开始要么移除，但是如果只是暂停，后续还要继续就可以通过下面方法来实现。</span><br><span class="line"></span><br><span class="line">-(<span class="type">void</span>)pauseLayer:(<span class="built_in">CALayer</span>*)layer &#123;</span><br><span class="line">   <span class="built_in">CFTimeInterval</span> pausedTime = [layer convertTime:<span class="built_in">CACurrentMediaTime</span>() fromLayer:<span class="literal">nil</span>];</span><br><span class="line">   layer.speed = <span class="number">0.0</span>;</span><br><span class="line">   layer.timeOffset = pausedTime;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">-(<span class="type">void</span>)resumeLayer:(<span class="built_in">CALayer</span>*)layer &#123;</span><br><span class="line">   <span class="built_in">CFTimeInterval</span> pausedTime = [layer timeOffset];</span><br><span class="line">   layer.speed = <span class="number">1.0</span>;</span><br><span class="line">   layer.timeOffset = <span class="number">0.0</span>;</span><br><span class="line">   layer.beginTime = <span class="number">0.0</span>;</span><br><span class="line">   <span class="built_in">CFTimeInterval</span> timeSincePause = [layer convertTime:<span class="built_in">CACurrentMediaTime</span>() fromLayer:<span class="literal">nil</span>] - pausedTime;</span><br><span class="line">   layer.beginTime = timeSincePause;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里简单得对上面的动画暂停恢复方法进行解释下：</p>
<p>在CAMediaTiming协议的timeOffset的注释上，官方给出以下公式： </p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">t</span> = (tp - begin) * speed + <span class="literal">off</span>set</span><br></pre></td></tr></table></figure>

<p>tp是父layer的时间点，为了方便理解，可以认为是绝对时间。<br>暂停的时候speed等于0，t &#x3D; offset.要让t停在此刻，也就是让t &#x3D; [layer convertTime:CACurrentMediaTime() fromLayer:nil]。这时候offset就必须等于[layer convertTime:CACurrentMediaTime() fromLayer:nil]</p>
<p>我们再来看下恢复，恢复的时候speed &#x3D; 1，offset &#x3D; 0, t &#x3D; 上一次停留时间也就是t &#x3D; (tp - begin) &#x3D; pausedTime；<br>所以begin &#x3D; [layer convertTime:CACurrentMediaTime() fromLayer:nil] - pauseTime;</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">repeatCount/repeatDuration：动画的重复执行，二者不可同时使用</span><br><span class="line">repeatCount指定重复的次数</span><br><span class="line">repeatDuration指定重复执行持续的时间，一到时间就停止重复执行。</span><br></pre></td></tr></table></figure>

<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">auto</span>reverses：是否自动翻转动画</span><br><span class="line">将使动画先正常走，完了以后反着从结束值回到起始值，如果指定了<span class="built_in">auto</span>reverse = YES 那么完成一次<span class="built_in">auto</span>reverse就需要 <span class="number">2</span>*duration</span><br></pre></td></tr></table></figure>

<figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">fillMode : 动画填充模式</span><br><span class="line"></span><br><span class="line">fillMode的作用就是决定当前对象过了非Active时间段的行为. 比如动画开始之前,动画结束之后，如果要让动画在开始之前显示<span class="keyword">from</span>Value的状态，设置fillMode为kCAFillModeBackwards。如果想让动画结束后停留在<span class="keyword">to</span>Value的状态，就应该设置为kCAFillModeForwards。如果两种都要有，就设置kCAFillModeBoth。注意必须配合animation.removeOnCompletion = NO才能达到以上效果</span><br></pre></td></tr></table></figure>

<p>CALayer遵循CAMediaTiming协议，每个CALayer都有个时间系统，可以通过CACurrentMediaTime() 来获得当前时间，可以通过CALayer的</p>
<figure class="highlight erlang"><table><tr><td class="code"><pre><span class="line">- <span class="params">(CFTimeInterval)</span>convertTime:<span class="params">(CFTimeInterval)</span>t fromLayer:<span class="params">(CALayer *)</span>l;</span><br><span class="line">- <span class="params">(CFTimeInterval)</span>convertTime:<span class="params">(CFTimeInterval)</span>t toLayer:<span class="params">(CALayer *)</span>l;</span><br></pre></td></tr></table></figure>
<p>在两个不同CALayer中进行转换。</p>
<p>下面是介绍这些属性的一个效果图，可以看这些参数来熟悉这些概念。</p>
<p><img src="/2019/08/08/iOS-%E5%8A%A8%E7%94%BB%E6%80%BB%E7%BB%93/00002.jpeg"></p>
<h6 id="CAPropertyAnimation"><a href="#CAPropertyAnimation" class="headerlink" title="CAPropertyAnimation"></a><strong><strong>CAPropertyAnimation</strong></strong></h6><p>CAPropertyAnimation 是属性动画，它其实也还是一个基类，不能用于创建对象，它有一个很重要的属性keyPath,用于指定哪些属性可以用于动画控制，那么我们怎么知道有哪些属性有属性动画呢？可以打开CALayer.h 搜索 “Animatable” 关键字，这些属性都是具有属性动画：将其罗列如下所示：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="attribute">transform</span><span class="selector-class">.scale</span>     </span><br><span class="line"><span class="attribute">transform</span><span class="selector-class">.scale</span><span class="selector-class">.x</span></span><br><span class="line"><span class="attribute">transform</span><span class="selector-class">.scale</span><span class="selector-class">.y</span></span><br><span class="line"><span class="attribute">transform</span><span class="selector-class">.rotation</span> </span><br><span class="line"><span class="attribute">transform</span><span class="selector-class">.rotation</span><span class="selector-class">.x</span></span><br><span class="line"><span class="attribute">transform</span><span class="selector-class">.rotation</span><span class="selector-class">.y</span></span><br><span class="line"><span class="attribute">transform</span><span class="selector-class">.rotation</span><span class="selector-class">.z</span></span><br><span class="line"><span class="attribute">transform</span><span class="selector-class">.translation</span></span><br><span class="line"><span class="attribute">transform</span><span class="selector-class">.translation</span><span class="selector-class">.x</span></span><br><span class="line"><span class="attribute">transform</span><span class="selector-class">.translation</span><span class="selector-class">.y</span></span><br><span class="line"><span class="attribute">transform</span><span class="selector-class">.translation</span><span class="selector-class">.z</span></span><br><span class="line"><span class="attribute">opacity</span> </span><br><span class="line"><span class="attribute">margin</span></span><br><span class="line">zPosition</span><br><span class="line">backgroundColor </span><br><span class="line">cornerRadius </span><br><span class="line">borderWidth</span><br><span class="line">bounds</span><br><span class="line">contents</span><br><span class="line">contentsRect</span><br><span class="line">cornerRadius</span><br><span class="line">frame</span><br><span class="line">hidden</span><br><span class="line"><span class="attribute">mask</span></span><br><span class="line">masksToBounds</span><br><span class="line"><span class="attribute">opacity</span></span><br><span class="line"><span class="attribute">position</span></span><br><span class="line">shadowColor</span><br><span class="line">shadowOffset</span><br><span class="line">shadowOpacity</span><br><span class="line">shadowRadius</span><br></pre></td></tr></table></figure>
<p>它还有两个很关键的属性：additive&#x2F;cumulative</p>
<ul>
<li>additive为YES时，变化值整体加上layer的当前值,也即是它其实是加性属性。</li>
<li>cumulative 为YES时，每次的值要加上上一次循环的的结束值。需要repeatCount&gt;1的时候才能看出效果。</li>
</ul>
<h6 id="CAAnimationGroup"><a href="#CAAnimationGroup" class="headerlink" title="CAAnimationGroup"></a><strong><strong>CAAnimationGroup</strong></strong></h6><p>CAAnimationGroup 可以保存一组动画对象，将CAAnimationGroup对象加入层后，组中所有动画对象可以同时并发运行，可以通过设置动画对象的beginTime属性来更改动画的开始时间</p>
<h6 id="CATransition"><a href="#CATransition" class="headerlink" title="CATransition"></a><strong><strong>CATransition</strong></strong></h6><p>CATransition用于做转场动画，也就是layer的两种状态之间的过渡。能够为层提供移出屏幕和移入屏幕的动画效果：<br>CATransition有如下关键属性：</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span>：动画过渡类型</span><br><span class="line"><span class="keyword">subtype</span>：动画过渡方向</span><br><span class="line">startProgress：动画起点(在整体动画的百分比)</span><br><span class="line">endProgress：动画终点(在整体动画的百分比)</span><br></pre></td></tr></table></figure>

<p>type的值可以是如下枚举值：</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">kCATransitionFade</span></span><br><span class="line"><span class="attribute">kCATransitionMoveIn</span></span><br><span class="line"><span class="attribute">kCATransitionPush</span></span><br><span class="line"><span class="attribute">kCATransitionReveal</span></span><br></pre></td></tr></table></figure>

<p>subtypes的值可以是如下枚举值：</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">kCATransitionFromRight</span></span><br><span class="line"><span class="attribute">kCATransitionFromLeft</span></span><br><span class="line"><span class="attribute">kCATransitionFromTop</span></span><br><span class="line"><span class="attribute">kCATransitionFromBottom</span></span><br></pre></td></tr></table></figure>

<p>各个属性的说明如下图所示：</p>
<p><img src="/2019/08/08/iOS-%E5%8A%A8%E7%94%BB%E6%80%BB%E7%BB%93/00003.jpeg"></p>
<p>下面是一个简单的例子：</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">CATransition *animation = [CATransition animation];</span><br><span class="line">animation.<span class="keyword">type</span> <span class="type">= </span>kCATransitionPush;//设置动画的类型</span><br><span class="line">animation.<span class="keyword">subtype</span> <span class="type">= </span>kCATransitionFromRight; //设置动画的方向</span><br><span class="line">animation.duration = <span class="number">1.0</span>f;</span><br><span class="line">[testView.layer addAnimation:animation forKey:@<span class="string">&quot;pushAnimation&quot;</span>];</span><br></pre></td></tr></table></figure>

<h6 id="CABasicAnimation"><a href="#CABasicAnimation" class="headerlink" title="CABasicAnimation"></a><strong><strong>CABasicAnimation</strong></strong></h6><p>CABasicAnimation：基础动画，通过属性修改进行动画参数控制，它有三个关键属性fromValue和toValue,还有byValue，当然不要忘记了它也是CAPropertyAnimation，在CAPropertyAnimation中可以指定要变化的keyPath.到这里为止动画内容(keyPath)有了，动画时间(duration和timingFunction)有了,开始和结束状态（fromValue和toValue）有了。通过插值就可以得到任意一个时间点的状态，然后渲染绘制形成一系列关联的图像，形成动画，也就是说到CABasicAnimation为止已经可以创建出一个动画了。</p>
<h6 id="CAKeyframeAnimation"><a href="#CAKeyframeAnimation" class="headerlink" title="CAKeyframeAnimation"></a><strong><strong>CAKeyframeAnimation</strong></strong></h6><p>如果说CABasicAnimation是一帧动画的话，CAKeyframeAnimation就是多个CABasicAnimation组成的帧动画，我们知道动画其实就是一帧帧画面连续变化得到的，我们不可能提供无限的连续的动画帧，我们只需要提供必要的关键帧就可以通过插值来完成了，再加上人眼的视觉暂留效应就可以在大脑中留下连续运动的动画。CAKeyframeAnimation有两个最为关键的属性values和keyTimes，values就是各个关键帧的数据，keyTimes是各个关键帧的时间点。keyTimes这个可选参数,当keyTimes没有设置的时候,各个关键帧的时间是均分的。</p>
<p>除了values和keyTimes属性 CAKeyframeAnimation 还有个path属性也很关键，为什么需要这个属性，大家试想下，如果我们要实现一个沿着心型❤️轨迹运动的动画，那么我们要怎么获得keyTimes和values？为了高度拟合轨迹我们要做很多计算才能得到，这显然不是正确的做法，API应该是以简洁易用为目的，所以这时候就可以通过path来描述运动轨迹。这个值默认是nil当其被设定的时候values属性就会被覆盖.</p>
<p>还有比较重要的属性就是calculationMode和rotationMode</p>
<p>calculationMode 影响着关键帧之间的数据如何进行推算：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">kCAAnimationLinear</span>          通过线性插值</span><br><span class="line">kCAAnimationDiscrete        不进行插值，只显示关键帧的画面，看到的动画会是跳跃的</span><br><span class="line">kCAAnimationPaced           这个也是线性插值，但跟第一个的区别是它是整体考虑的。它会忽略掉keyTimes属性，重新计算keyTimes以达到全局匀速的效果。注意这时候keyTimes和timingFunctions是不起作用的; </span><br><span class="line"><span class="attribute">kCAAnimationCubic</span>           效果就是把转折点变得圆滑</span><br><span class="line">kCAAnimationCubicPaced      kCAAnimationPaced和kCAAnimationCubic两种效果叠加</span><br></pre></td></tr></table></figure>

<p>rotationMode只有帧动画使用path路径的时候才有效果的，当值为kCAAnimationRotateAuto是，会把layer旋转，使得layer自身的x轴是跟路径相切的,并且x轴方向跟运动方向一致，使用kCAAnimationRotateAutoReverse也是相切，但x轴方向跟运动方向相反。</p>
<h6 id="CASpringAnimation"><a href="#CASpringAnimation" class="headerlink" title="CASpringAnimation"></a><strong><strong>CASpringAnimation</strong></strong></h6><p>CASpringAnimation是iOS7.0后新增的,它提供了像弹簧一样的变化规律，它有如下关键的属性：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">mass</span>            弹簧质量，影响弹簧的惯性，质量越大，弹簧惯性越大，运动的幅度越大</span><br><span class="line">stiffness       弹簧弹性系数，弹性系数越大，弹簧的运动越快</span><br><span class="line">damping         弹簧阻尼系数，阻尼系数越大，弹簧的停止越快</span><br><span class="line">initialVelocity 初始速率，弹簧动画的初始速度大小，弹簧运动的初始方向与初始速率的正负一致</span><br></pre></td></tr></table></figure>

<h5 id="CoreAnimation的使用步骤"><a href="#CoreAnimation的使用步骤" class="headerlink" title="CoreAnimation的使用步骤"></a><strong><strong>CoreAnimation的使用步骤</strong></strong></h5><ul>
<li>创建CAAnmation子对象</li>
<li>设置CAAnmation的属性</li>
<li>调用CALayer的addAnimation:forKey：将CAAnimation对象添加到CALayer上，就能执行动画</li>
<li>调用CALayer的removeAnimationForKey方法可以停止CALayer中的动画。</li>
</ul>
<h5 id="CGAffineTransform-仿射变换"><a href="#CGAffineTransform-仿射变换" class="headerlink" title="CGAffineTransform 仿射变换"></a><strong><strong>CGAffineTransform 仿射变换</strong></strong></h5><p>在最初开发Android 的时候接触到仿射变换，一直不理解什么是仿射，其实的仿射变换就是将视图的每个点乘以一个仿射矩阵，得到一个变换后的视图，具体变换过程这里不做展开，这里会涉及到数学的矩阵运算，但是要记住一点：图层中平行的两条线在变换之后任然会保持平行。</p>
<p>可以通过如下方法创建CGAffineTransform：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">CGAffineTransformMakeRotation</span><span class="params">(CGFloat angle)</span></span>             <span class="comment">//旋转变换</span></span><br><span class="line"><span class="function"><span class="title">CGAffineTransformMakeScale</span><span class="params">(CGFloat sx, CGFloat sy)</span></span>       <span class="comment">//缩放变换</span></span><br><span class="line"><span class="function"><span class="title">CGAffineTransformMakeTranslation</span><span class="params">(CGFloat tx, CGFloat ty)</span></span> <span class="comment">//平移变换</span></span><br></pre></td></tr></table></figure>
<p>下面是在一个仿射变换基础上叠加另一个仿射变换的方法。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">CGAffineTransformRotate</span>(<span class="built_in">CGAffineTransform</span> t, <span class="built_in">CGFloat</span> angle)</span><br><span class="line"><span class="built_in">CGAffineTransformScale</span>(<span class="built_in">CGAffineTransform</span> t, <span class="built_in">CGFloat</span> sx, <span class="built_in">CGFloat</span> sy)</span><br><span class="line"><span class="built_in">CGAffineTransformTranslate</span>(<span class="built_in">CGAffineTransform</span> t, <span class="built_in">CGFloat</span> tx, <span class="built_in">CGFloat</span> ty)</span><br></pre></td></tr></table></figure>
<p>如果已经存在了两个仿射变换，现在要将它们合在一起的时候可以调用：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">CGAffineTransformConcat</span>(<span class="built_in">CGAffineTransform</span> t1, <span class="built_in">CGAffineTransform</span> t2);</span><br></pre></td></tr></table></figure>
<p>如果需要一个什么都不变的变换，就可以实用</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">CGAffineTransformIdentity</span></span><br></pre></td></tr></table></figure>

<p>下面是一个简单的例子：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">CGAffineTransform</span> transform = CGAffineTransformIdentity; </span><br><span class="line"><span class="attribute">transform</span> = CGAffineTransformScale(transform, <span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line"><span class="attribute">transform</span> = CGAffineTransformRotate(transform, M_PI / <span class="number">180</span>.<span class="number">0</span> * <span class="number">45</span>.<span class="number">0</span>); </span><br><span class="line"><span class="attribute">transform</span> = CGAffineTransformTranslate(transform, <span class="number">250</span>, <span class="number">0</span>);</span><br><span class="line"><span class="attribute">self</span>.layerView.layer.affineTransform = transform;</span><br></pre></td></tr></table></figure>

<p>UIView可以通过设置transform属性做变换。需要注意的是CALayer同样也有一个transform属性，但它的类型是CATransform3D，不要被误导了，真正用于仿射变换的是affineTransform属性。</p>
<h5 id="CATransform3D-3D变换"><a href="#CATransform3D-3D变换" class="headerlink" title="CATransform3D 3D变换"></a><strong><strong>CATransform3D 3D变换</strong></strong></h5><p>和2D仿射变换类似CATransform3D也提供了对应的旋转，缩放，平移的方法，如下所示：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="constructor">CATransform3DMakeRotation(CGFloat <span class="params">angle</span>, CGFloat <span class="params">x</span>, CGFloat <span class="params">y</span>, CGFloat <span class="params">z</span>)</span></span><br><span class="line"><span class="constructor">CATransform3DMakeScale(CGFloat <span class="params">sx</span>, CGFloat <span class="params">sy</span>, CGFloat <span class="params">sz</span>)</span> </span><br><span class="line"><span class="constructor">CATransform3DMakeTranslation(Gloat <span class="params">tx</span>, CGFloat <span class="params">ty</span>, CGFloat <span class="params">tz</span>)</span></span><br></pre></td></tr></table></figure>

<p>透视投影</p>
<p>上面的变换是没有透视效果的，原先平行的还是保持平行，因此我们需要做透视投影处理，要达到透视效果可以通过设置CATransform3D的m34值来实现，那么m34要怎么设置呢？</p>
<p><img src="/2019/08/08/iOS-%E5%8A%A8%E7%94%BB%E6%80%BB%E7%BB%93/00004.png"><br>一般而言 m34 &#x3D; -1.0 &#x2F; distance  （distance视角相机和屏幕之间的距离，以像素为单位，一般不需要仔细计算，根据实际效果500-1000中选择一个就好）</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">CATransform3D</span> transform = CATransform3DIdentity;</span><br><span class="line"><span class="attribute">transform</span>.m34 = - <span class="number">1</span>.<span class="number">0</span> / <span class="number">500</span>.<span class="number">0</span>;</span><br><span class="line"><span class="attribute">transform</span> = CATransform3DRotate(transform, M_PI_4, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="attribute">self</span>.layerView.layer.transform = transform;</span><br></pre></td></tr></table></figure>
<p>对于一个View,Core Animation定义消失点位于View的anchorPoint，但是这里会有个问题：一个界面可能有多个View要做3D变换，但是一个界面通常只能有一个消失点，所以不能通过设置position来移动，因为当改变一个图层的position，你也改变了它的消失点，因此在做3D变换的时候需要记住：当视图通过调整m34来让它更加有3D效果，应该首先把它放置于屏幕中央，然后通过平移来把它移动到指定位置，而不是直接改变它的position，这样所有的3D图层都共享一个消失点。还有一种方式就是通过sublayerTransform，sublayerTransform和对一个图层的变换不同，它影响到所有的子图层。这意味着你可以一次性对包含这些图层的容器做变换，因此我们可以把消失点设置在容器图层的中点，这样就不需要再对子图层分别设置了。这意味着你可以随意使用position和frame来放置子图层，而不需要把它们放置在屏幕中点，然后为了保证统一的消失点用变换来做平移。</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">CATransform3D</span> perspective = CATransform3DIdentity;</span><br><span class="line"><span class="attribute">perspective</span>.m34 = - <span class="number">1</span>.<span class="number">0</span> / <span class="number">500</span>.<span class="number">0</span>;</span><br><span class="line"><span class="attribute">self</span>.containerView.layer.sublayerTransform = perspective;</span><br><span class="line"><span class="attribute">CATransform3D</span> transform1 = CATransform3DMakeRotation(M_PI_4, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="attribute">self</span>.layerView1.layer.transform = transform1;</span><br><span class="line"><span class="attribute">CATransform3D</span> transform2 = CATransform3DMakeRotation(-M_PI_4, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="attribute">self</span>.layerView2.layer.transform = transform2;</span><br></pre></td></tr></table></figure>

<h5 id="动画的事务管理"><a href="#动画的事务管理" class="headerlink" title="动画的事务管理"></a><strong><strong>动画的事务管理</strong></strong></h5><p>事务这个概念在很多地方都会遇到，比如数据库操作等，在iOS动画中事务实际上是Core Animation用来包含一系列属性动画集合的机制，任何CALayer的Animatable Properties设置都应该属于某个CATransaction（在修改CALayer的Animatable Properties时如果发现当前没有事务，则会自动创建一个事务），在一个CATransaction中可以同时对多个layer的属性进行修改，CATransaction负责对layer的修改的捕获和提交，在事务中的变化并不会立刻生效，而是在事务提交的时候将这些图层树的变化成批包装起来，一次性发送到渲染服务进程，在我们看来就是图层的各个属性会在同一时刻由一个动画过渡到新值。Core Animation在每个Runloop周期中自动开始一次新的事务,事务的提交发生在RunLoop进入休眠或者退出期间,即使不显式的用[CATransaction begin]开始一次事务，任何在一次Runloop循环中属性的改变都会被集中起来，然后做一次0.25秒的动画。事务可以嵌套,当事务嵌套时候,只有当最外层的事务commit了之后,整个动画才开始.在没有RunLoop的地方设置CALayer的Animatable Properties,则必须使用显式的事务，有RunLoop的情况下会自动创建CATransation，CATransaction没有属性或者实例方法，并且也不能用+alloc和-init方法创建它。但是可以用+begin和+commit分别来入栈或者出栈,如下所示：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="string">[CATransaction begin]</span>;</span><br><span class="line"> <span class="comment">//动画内容</span></span><br><span class="line"><span class="string">[CATransaction commit]</span>;</span><br></pre></td></tr></table></figure>
<p>UIView动画中：+beginAnimations:context:和+commitAnimations ，以及UIView基于Block的动画方法：+animateWithDuration:animations:也都是基于CATransaction的封装。</p>
<h5 id="动画相关的CALayer"><a href="#动画相关的CALayer" class="headerlink" title="动画相关的CALayer"></a><strong><strong>动画相关的CALayer</strong></strong></h5><p>在介绍iOS渲染的时候已经对iOS UIView以及CALayer做了较为详细的介绍，UIView 和 CALayer职责十分明确，一个是负责事件响应，一个是负责界面呈现，在介绍iOS渲染的时候主要关注的是CALayer内容显示的部分，而这里将会重点介绍CALayer的动画特性，其实给View加上动画，本质上是对其CALayer进行操作，CALayer有很多Animatable Property，我们可以基于这些属性做动画效果。</p>
<p>在介绍完CALayer后我们还需要了解一些特殊的CALayer,和CALayer基于Core Graphic的CPU渲染方式不同，它们大多数是基于GPU渲染的，下面是这些Layer的特点和作用：</p>
<ul>
<li><p><strong><strong>CAShapeLayer</strong></strong><br>CAShapeLayer是一个通过矢量图形而不是Bitmap来绘制的CALayer子类.<br>CAShapeLayer相对于一般的CALayer有如下特点：</p>
<ol>
<li>CAShapeLayer使用了硬件加速,而CALayer是基于Core Graphics使用的是CPU绘图，因此渲染速度会快很多。</li>
<li>CAShapeLayer不需要像普通CALayer一样创建一个寄宿图形，所以无论有多大，都不会占用太多的内存.</li>
</ol>
</li>
<li><p><strong><strong>CATextLayer</strong></strong><br>UILabel最早其实是通过WebKit来实现绘制的，这样就造成了当有很多文字的时候就会有极大的性能压力。而CATextLayer使用了Core Text，所以渲染性能十分快速。</p>
</li>
<li><p><strong><strong>CAGradientLayer</strong></strong><br>CAGradientLayer是用来生成两种或更多颜色平滑渐变的图层，CAGradientLayer也是基于硬件加速对因此渲染效率也比基于Core Graphic 快很多。</p>
</li>
<li><p><strong><strong>CAGradientLayer</strong></strong><br>CAGradientLayer 用于高效生成许多相似的图层。它会绘制一个或多个图层的子图层，并在每个复制体上应用不同的变换。</p>
</li>
<li><p><strong><strong>CAScrollLayer</strong></strong><br>CAScrollLayer用于显示的是可滚动的图层的一部分，可以指定滑动方向和可视区域面积，限制不滑出区域外。</p>
</li>
<li><p><strong><strong>CATiledLayer</strong></strong><br>有时候我们需要呈现一个很大的，质量很高的图片，这种情况下如果将整个图片加载到内存是不大现实的，一来会占用很大的空间，二来图片加载会很耗时，导致动画卡顿。还有个比较棘手的问题就是，OpenGL对纹理对大小是有限制的，如果超过最大纹理大小，Core Animation将会强制用CPU处理图片而不是GPU。为了解决这些问题，CATiledLayer将大图分解成小片然后将他们单独按需载入。从而减小内存占用和加载耗时。</p>
</li>
<li><p><strong><strong>CAEmitterLayer</strong></strong><br>CAEmitterLayer是一个高性能的粒子引擎，被用来创建实时粒子动画如：烟雾，火，雨等等效果。</p>
</li>
<li><p><strong><strong>CAEAGLLayer</strong></strong><br>CAEAGLLayer是CALayer的一个子类，用来显示任意的OpenGL图形。</p>
</li>
<li><p><strong><strong>AVPlayerLayer</strong></strong><br>AVPlayerLayer是用来在iOS上播放视频的。它是高级接口例如MPMoivePlayer的底层实现，提供了显示视频的底层控制。</p>
</li>
</ul>
<h5 id="隐式动画"><a href="#隐式动画" class="headerlink" title="隐式动画"></a><strong><strong>隐式动画</strong></strong></h5><p>iOS中的动画有显式动画和隐式动画两种类型，上面介绍的动画都属于显式动画，接下来要介绍的是隐式动画，我们上面介绍过每一个View都有其对应的layer，这个layer是Root Layer，而其他通过CALayer或其子类直接创建的CALayer是非Root Layer。所有非Root Layer在我们设置Animatable Properties的时候都会存在duration为0.25s的隐式动画，而对Root Layer则没有这个过渡，这是为什么呢？实际上无论什么时候修改Animatable Properties。CALayer都会去查找并运行合适的action，什么是action呢？action实际上是一些遵循了CAAction协议的对象,用于定义一个动画需要做的事情，不论是否在block里面修改view的属性，都会触发CALayer查找合适的CAAction.</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">CAAction</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)runActionForKey:(<span class="built_in">NSString</span> *)event object:(<span class="type">id</span>)anObject</span><br><span class="line">    arguments:(<span class="keyword">nullable</span> <span class="built_in">NSDictionary</span> *)dict;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>CAAction协议中有个runActionForKey方法，我们可以在这个方法中对layer自定义某些动画效果。下面是一个简单的例子：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="meta">@interface</span> <span class="type">CustomAction</span> : <span class="type">NSObject</span>&lt;<span class="type">CAAction</span>&gt;</span><br><span class="line"><span class="meta">@property</span> (nonatomic) <span class="type">CGColorRef</span> currentColor;</span><br><span class="line"><span class="meta">@end</span></span><br><span class="line"><span class="meta">@implementation</span> <span class="type">CustomAction</span></span><br><span class="line"><span class="operator">-</span> (void)runActionForKey:(<span class="type">NSString</span> <span class="operator">*</span>)key object:(id)anObject arguments:(<span class="type">NSDictionary</span> <span class="operator">*</span>)dict &#123;</span><br><span class="line">    <span class="type">CustomLayer</span> <span class="operator">*</span>layer <span class="operator">=</span> anObject;</span><br><span class="line">    <span class="type">CABasicAnimation</span> <span class="operator">*</span>animation <span class="operator">=</span> [<span class="type">CABasicAnimation</span> animationWithKeyPath:@<span class="string">&quot;backgroundColor&quot;</span>];</span><br><span class="line">    animation.fromValue <span class="operator">=</span> (id)[<span class="type">UIColor</span> greenColor].<span class="type">CGColor</span>;</span><br><span class="line">    animation.toValue <span class="operator">=</span> (id)[<span class="type">UIColor</span> redColor].<span class="type">CGColor</span>;</span><br><span class="line">    animation.duration <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">    [layer addAnimation:animation forKey:@<span class="string">&quot;backgroundColor&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@end</span></span><br></pre></td></tr></table></figure>

<p>除了修改layer属性外，触发搜索action事件的触发点包括如下几个：</p>
<figure class="highlight gml"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">layer</span>的属性被修改。包括<span class="variable language_">layer</span>的任何属性，不仅仅只是会产生动画的部分。</span><br><span class="line"><span class="variable language_">layer</span>被添加到<span class="variable language_">layer</span>阶层。标识符key是kCAOnOrder。</span><br><span class="line"><span class="variable language_">layer</span>被移除<span class="variable language_">layer</span>阶层。标示符key是kCAOnOrderOut。</span><br></pre></td></tr></table></figure>

<p>action的搜索的过程：</p>
<p>layer调用actionForKey:方法搜索需要执行的action对象</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">如果layer设置了代理，layer会向它的delegate发送actionForLayer:forKey:消息来要求返回对应当前属性变化的CAAction。</span><br><span class="line">actionForLayer:forKey:有三种返回情况：</span><br><span class="line"><span class="bullet">1.</span> 返回CAAction的对象，这时候将会使用这个CAAction来实现这个动画</span><br><span class="line"><span class="bullet">2.</span> 返回NSNull,这时候就会停止搜索，并且告诉layer不需要执行任何动画</span><br><span class="line"><span class="bullet">3.</span> 返回nil，这时候layer就会继续往下找</span><br><span class="line"><span class="bullet">4.</span> 查找layer的action属性，看可以是否有对应的值</span><br><span class="line"><span class="bullet">5.</span> 查找layer的style属性。</span><br><span class="line"><span class="bullet">6.</span> 调用defaultActionForKey返回对应key的默认action，一般是CABasicAnimation。</span><br></pre></td></tr></table></figure>

<p>找到action对象后，调用action对象的runActionForLayer:object:arguments:方法执行相关操作。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">id</span>&lt;<span class="built_in">CAAction</span>&gt;)actionForLayer:(<span class="built_in">CALayer</span> *)layer forKey:(<span class="built_in">NSString</span> *)event&#123;</span><br><span class="line">    <span class="keyword">if</span> ([event isEqualToString:<span class="string">@&quot;backgroundColor&quot;</span>]) &#123;</span><br><span class="line">        MyAction *action = [MyAction new];</span><br><span class="line">        <span class="keyword">return</span> action;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyAction</span> : <span class="title">NSObject</span>&lt;<span class="title">CAAction</span>&gt;</span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyAction</span></span></span><br><span class="line">- (<span class="type">void</span>)runActionForKey:(<span class="built_in">NSString</span> *)event object:(<span class="type">id</span>)anObject arguments:(<span class="built_in">NSDictionary</span> *)dict&#123;</span><br><span class="line">    CustomLayer *layer = anObject;</span><br><span class="line">    <span class="built_in">CABasicAnimation</span> *animation = [<span class="built_in">CABasicAnimation</span> animation];</span><br><span class="line">    animation.duration = <span class="number">3.0</span>f;</span><br><span class="line">    [layer addAnimation:animation forKey:<span class="string">@&quot;backgroundColor&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>有了上面的介绍大家应该会对从修改属性到动画执行的整个流程有了比较详细的了解了吧，这里就很好理解为什么Root Layer没有隐式动画而非Root Layer会有隐式动画了，其实最大的玄机在于CALayer的delegate对象，我们知道Root Layer的delegte是对应的UIView，因此可以推测之所以Root Layer没有隐式动画就是因为UIView在一般情况下actionForLayer:forKey返回一个 NSNull，只有当属性改变发生在动画block 中时，view 才会返回实际的动作。而非Root Layer,delegate在不设置的情况下为空，所以返回的是通过defaultActionForKey返回的对应key的默认Action.</p>
<p>但是有时候我们又需要关闭这些隐式动画，这种情况就可以通过如下方式来关闭：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">[<span class="built_in">CATransaction</span> begin];</span><br><span class="line"><span class="comment">// 关闭隐式动画</span></span><br><span class="line">[<span class="built_in">CATransaction</span> setDisableActions:<span class="literal">YES</span>];</span><br><span class="line"><span class="comment">//原本会产生隐式动画的部分</span></span><br><span class="line">[<span class="built_in">CATransaction</span> commit];</span><br></pre></td></tr></table></figure>
<p>设置setDisableActions:为YES后，layer的actionForKey:方法将不会被调用，隐式动画也不会生成。</p>
<h5 id="UIView-过渡动画"><a href="#UIView-过渡动画" class="headerlink" title="UIView 过渡动画"></a><strong><strong>UIView 过渡动画</strong></strong></h5><p>视图过渡动画一般用在比如删除或增加子视图的时候。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">+ (<span class="type">void</span>)transitionWithView:(<span class="built_in">UIView</span> *)view </span><br><span class="line">                  duration:(<span class="built_in">NSTimeInterval</span>)duration </span><br><span class="line">                   options:(<span class="built_in">UIViewAnimationOptions</span>)options </span><br><span class="line">                animations:(<span class="type">void</span> (^)(<span class="type">void</span>))animations </span><br><span class="line">                completion:(<span class="type">void</span> (^)(<span class="type">BOOL</span> finished))completion;</span><br></pre></td></tr></table></figure>

<p>view 就是指定的需要做动画过渡的视图,或者要做动画视图的容器视图。<br>animations 中可以执行比如添加、删除、显示或隐藏指定view 的子视图<br>其他的和UIView的block动画类似。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">+ (<span class="type">void</span>)transitionFromView:(<span class="built_in">UIView</span> *)fromView </span><br><span class="line">                    toView:(<span class="built_in">UIView</span> *)toView </span><br><span class="line">                    duration:(<span class="built_in">NSTimeInterval</span>)duration </span><br><span class="line">                    options:(<span class="built_in">UIViewAnimationOptions</span>)options </span><br><span class="line">                    completion:(<span class="type">void</span> (^ __<span class="keyword">nullable</span>)(<span class="type">BOOL</span> finished))completion</span><br></pre></td></tr></table></figure>
<p>这个动画用于从一个view转变到另一个view过程的动画，在动画过程中，首先将 fromView 从父视图中删除，然后将 toView 添加，就是做了一个替换操作 </p>
<h5 id="UIImageView-帧动画"><a href="#UIImageView-帧动画" class="headerlink" title="UIImageView 帧动画"></a><strong><strong>UIImageView 帧动画</strong></strong></h5><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event&#123;</span><br><span class="line">    <span class="built_in">NSArray</span> *imageArray = [<span class="keyword">self</span> getImageArrayWithGIFNameWit:<span class="string">@&quot;aisi&quot;</span>];</span><br><span class="line">    <span class="keyword">self</span>.imageView.animationImages = imageArray;</span><br><span class="line">    <span class="keyword">self</span>.imageView.animationDuration = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">self</span>.imageView.animationRepeatCount = MAXFLOAT;</span><br><span class="line">    [<span class="keyword">self</span>.imageView startAnimating];</span><br><span class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">5.0</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        [_imageView stopAnimating];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSArray</span>&lt;<span class="built_in">UIImage</span> *&gt; *)getImageArrayWithGIFNameWit:(<span class="built_in">NSString</span> *)imageName &#123;</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *imageArray = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">    <span class="built_in">NSString</span> *path = [[<span class="built_in">NSBundle</span> mainBundle] pathForResource:imageName ofType:<span class="string">@&quot;gif&quot;</span>];</span><br><span class="line">    <span class="built_in">NSData</span> *data = [<span class="built_in">NSData</span> dataWithContentsOfFile:path];</span><br><span class="line">    <span class="keyword">if</span> (!data) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">CGImageSourceRef</span> source = <span class="built_in">CGImageSourceCreateWithData</span>((__bridge <span class="built_in">CFDataRef</span>)data, <span class="literal">NULL</span>);</span><br><span class="line">    size_t count = <span class="built_in">CGImageSourceGetCount</span>(source);</span><br><span class="line">    <span class="keyword">if</span> (count &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        [imageArray addObject:[[<span class="built_in">UIImage</span> alloc] initWithData:data]];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            <span class="built_in">CGImageRef</span> image = <span class="built_in">CGImageSourceCreateImageAtIndex</span>(source, i, <span class="literal">NULL</span>);</span><br><span class="line">            </span><br><span class="line">            [imageArray addObject:[<span class="built_in">UIImage</span> imageWithCGImage:image scale:[<span class="built_in">UIScreen</span> mainScreen].scale orientation:<span class="built_in">UIImageOrientationUp</span>]];</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">CGImageRelease</span>(image);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">CFRelease</span>(source);</span><br><span class="line">    <span class="keyword">return</span> imageArray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="转场动画"><a href="#转场动画" class="headerlink" title="转场动画"></a><strong><strong>转场动画</strong></strong></h5><h6 id="1-UIViewController-容器转场动画"><a href="#1-UIViewController-容器转场动画" class="headerlink" title="1. UIViewController 容器转场动画"></a><strong><strong>1. UIViewController 容器转场动画</strong></strong></h6><p>这个适用于多个子UIViewController在一个容器UIViewController中进行切换的动画,它的好处在没有转换到<strong><strong>toViewController</strong></strong>的时候toViewController没有显示也不会load，这样减少内存的使用。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"> <span class="built_in">UIViewController</span> *firstViewController = [<span class="built_in">UIViewController</span> new];</span><br><span class="line">firstViewController.view.backgroundColor = [<span class="built_in">UIColor</span> redColor];</span><br><span class="line">[<span class="keyword">self</span> addChildrenController:firstViewController</span><br><span class="line">            locateSubViewBlock:^(<span class="built_in">UIView</span> * _Nonnull parentControllerRootView, <span class="built_in">UIView</span> * _Nonnull childControllerRootView) &#123;</span><br><span class="line">    childControllerRootView.frame = parentControllerRootView.frame;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="built_in">UIViewController</span> *secondViewController = [<span class="built_in">UIViewController</span> new];</span><br><span class="line">secondViewController.view.backgroundColor = [<span class="built_in">UIColor</span> yellowColor];</span><br><span class="line">secondViewController.view.frame = <span class="keyword">self</span>.view.frame;</span><br><span class="line"><span class="keyword">self</span>.currentViewController = firstViewController;</span><br></pre></td></tr></table></figure>

<p>要切换的时候调用：</p>
<figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">[<span class="literal">self</span> changeControllerFromOldController:<span class="literal">self</span>.currentViewController <span class="keyword">to</span>NewController:secondViewController];</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)changeControllerFromOldController:(<span class="built_in">UIViewController</span> *)oldController toNewController:(<span class="built_in">UIViewController</span> *)newController &#123;</span><br><span class="line">    [<span class="keyword">self</span> addChildViewController:newController];</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span> transitionFromViewController:oldController toViewController:newController duration:<span class="number">8</span> options:<span class="built_in">UIViewAnimationOptionTransitionCurlUp</span> animations:^&#123;</span><br><span class="line">        </span><br><span class="line">    &#125; completion:^(<span class="type">BOOL</span> finished) &#123;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">if</span> (finished) &#123;</span><br><span class="line">            <span class="comment">//移除oldController，但在removeFromParentViewController：方法前不会调用willMoveToParentViewController:nil 方法，所以需要显示调用</span></span><br><span class="line">            [newController didMoveToParentViewController:<span class="keyword">self</span>];</span><br><span class="line">            [oldController willMoveToParentViewController:<span class="literal">nil</span>];</span><br><span class="line">            [oldController removeFromParentViewController];</span><br><span class="line">            <span class="keyword">self</span>.currentViewController = newController;</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.currentViewController = oldController;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果不是非常理解，大家还可以查看这篇博客:<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1156152">iOS addChildViewController方法</a></p>
<h6 id="2-UIViewController之间跳转的转场动画"><a href="#2-UIViewController之间跳转的转场动画" class="headerlink" title="2. UIViewController之间跳转的转场动画"></a><strong><strong>2. UIViewController之间跳转的转场动画</strong></strong></h6><p>在iOS中一个ViewController又被称为一个场景，转场动画就是两个场景之间切换时候的动画，iOS已经默认为我们提供了四种转场动画，可以通过UIViewController的modalTransitionStyle属性来指定：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, <span class="built_in">UIModalTransitionStyle</span>) &#123;</span><br><span class="line">    <span class="built_in">UIModalTransitionStyleCoverVertical</span> = <span class="number">0</span>,    <span class="comment">//从下向上弹起</span></span><br><span class="line">    <span class="built_in">UIModalTransitionStyleFlipHorizontal</span>,       <span class="comment">//水平翻转</span></span><br><span class="line">    <span class="built_in">UIModalTransitionStyleCrossDissolve</span>,        <span class="comment">//渐隐渐现</span></span><br><span class="line">    <span class="built_in">UIModalTransitionStylePartialCurl</span>,          <span class="comment">//翻页</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>有些情况下这些转场动画并不能满足我们产品的需求这时候就需要我们自定义转场动画来满足了。iOS中的场景切换是一个蛮强大的一个模块，下面是整个模块的关系图，后面会针对这个图进行梳理：</p>
<p><img src="/2019/08/08/iOS-%E5%8A%A8%E7%94%BB%E6%80%BB%E7%BB%93/00005.png"></p>
<h6 id="2-1-Present-x2F-Dismiss-动画"><a href="#2-1-Present-x2F-Dismiss-动画" class="headerlink" title="2.1 Present &#x2F; Dismiss 动画"></a><strong><strong>2.1 Present &#x2F; Dismiss 动画</strong></strong></h6><p>首先我们以最常见的一个ViewController present 另外一个ViewController 为例子：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 代码触发一个presentViewController。</span><br><span class="line"><span class="number">2.</span> UIKit询问要过渡到的target ViewController 是否有自定义的过渡动画代理。如果没有，则UIKit将使用iOS自带的过渡动画</span><br><span class="line"><span class="number">3.</span> 如果有过渡动画代理，UIKit则会通过过渡动画代理transitioningDelegate，获取到动画控制器。比如通过 animation<span class="constructor">ControllerForPresentedController(<span class="params">_</span>:<span class="params">presentingController</span>:<span class="params">sourceController</span>:)</span>方法获取到动画控制器，如果返回空，则使用默认的动画控制器。</span><br><span class="line"><span class="number">4.</span> 一旦找到了动画控制器，UIKit构建上下文对象UIViewControllerContextTransitioning。</span><br><span class="line"><span class="number">5.</span> 接着，UIKit通过动画控制器UIViewControllerContextTransitioning 的 transition<span class="constructor">Duration(<span class="params">_</span>:)</span>方法获取动画执行时长。</span><br><span class="line"><span class="number">6.</span> 再接着调用动画控制器的animate<span class="constructor">Transition(<span class="params">_</span>:)</span>完成过渡动画。</span><br><span class="line"><span class="number">7.</span> 最后动画控制器调用上下文对象的complete<span class="constructor">Transition(<span class="params">_</span>:)</span>方法指示动画完成。</span><br></pre></td></tr></table></figure>

<p>这里也介绍下一个最初困惑我比较久的概念presentingViewController&#x2F;presentedViewController</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">假如我们有两个 VC <span class="selector-tag">A</span>/<span class="selector-tag">B</span>，我们要从<span class="selector-tag">A</span>转换到<span class="selector-tag">B</span>，我们称<span class="selector-tag">A</span>为presentingViewController，称<span class="selector-tag">B</span> presentedViewController，当从 <span class="selector-tag">B</span> 结束转换回到 <span class="selector-tag">A</span> 时，我们仍然称呼 <span class="selector-tag">A</span> 为 presentingViewController，<span class="selector-tag">B</span> 为 presentedViewController。这是让我每次比较懵逼的地方。</span><br></pre></td></tr></table></figure>

<p>再说得详细点：</p>
<ul>
<li><strong><strong>presentingViewController[负责呈现的ViewController]</strong></strong></li>
</ul>
<p>关于presentingViewController 官方的说明如下：</p>
<blockquote>
<p>The view controller that presented this view controller.<br>When you present a view controller modally (either explicitly or implicitly) using the presentViewController:animated:completion: method, the view controller that was presented has this property set to the view controller that presented it. If the view controller was not presented modally, but one of its ancestors was, this property contains the view controller that presented the ancestor. If neither the current view controller or any of its ancestors were presented modally, the value in this property is nil.</p>
</blockquote>
<p>也就是说如果我们沿着viewController堆栈，但凡有一个是通过 <strong><strong>presentViewController:animated:completion:</strong></strong> 方法推出的，那么presentingViewController 的值就是推出的堆栈的起点viewController.也就是说只有在调用<strong><strong>presentViewController:animated:completion:</strong></strong> 的时候才会更改这个值，如果通过push的话，就会继承操作的发起者的presentingViewController值。</p>
<p>举个简单的例子：</p>
<p>有五个控制器 ABCDEF，应用启动首先显示RootViewController A，之后A通过present方式推出带导航栏的B，B再通过push的方式推出C，C再通过push的方式推出D，D再通过push的方式推出E，那么E的 presentingViewController 就是 B。上面例子中只有B是通过present方式推出的，且B是CDE的父级，那么 D 的presentingViewController也将是B。</p>
<ul>
<li><strong><strong>presentedViewController[被呈现的ViewController]</strong></strong></li>
</ul>
<p>关于presentedViewController 官方的说明如下：</p>
<blockquote>
<p>The view controller that is presented by this view controller, or one of its ancestors in the view controller hierarchy.<br>When you present a view controller modally (either explicitly or implicitly) using the presentViewController:animated:completion: method, the view controller that called the method has this property set to the view controller that it presented. If the current view controller did not present another view controller modally, the value in this property is nil.</p>
</blockquote>
<p>也就是你通过present模态推出了谁，你的presentedViewController就是谁.</p>
<p>OK 回到转场动画的解释上来：</p>
<p>下面以一个例子来说明如何自定义一个转场动画：</p>
<p>正常情况下我们跳转页面代码如下：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">IDLTargetViewController * targetViewController = [IDLTargetViewController new];</span><br><span class="line">[<span class="keyword">self</span> presentViewController:targetViewController animated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure>

<p>但是上面由于没有自定transitioningDelegate所以用的是系统的默认转场动画也就是从下往上弹出，我们现在要自定义转场动画，就需要指定一个transitioningDelegate，这样系统在跳转的时候就会从transitioningDelegate获取对应的遵循UIViewControllerAnimatedTransitioning协议的对象。</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">targetViewController.transitioningDelegate</span> = [[IDLTransitionDelegate alloc] init]<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>我们先来看UIViewControllerTransitioningDelegate协议中的几个函数：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这个函数用来设置当执行present方法时 进行的转场动画</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="type">id</span> &lt;<span class="built_in">UIViewControllerAnimatedTransitioning</span>&gt;)animationControllerForPresentedController:(<span class="built_in">UIViewController</span> *)presented presentingController:(<span class="built_in">UIViewController</span> *)presenting sourceController:(<span class="built_in">UIViewController</span> *)source;</span><br><span class="line"><span class="comment">//这个函数用来设置当执行dismiss方法时 进行的转场动画</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="type">id</span> &lt;<span class="built_in">UIViewControllerAnimatedTransitioning</span>&gt;)animationControllerForDismissedController:(<span class="built_in">UIViewController</span> *)dismissed;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个函数用来设置当执行present方法时 进行可交互的转场动画</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="type">id</span> &lt;<span class="built_in">UIViewControllerInteractiveTransitioning</span>&gt;)interactionControllerForPresentation:(<span class="type">id</span> &lt;<span class="built_in">UIViewControllerAnimatedTransitioning</span>&gt;)animator;</span><br><span class="line"><span class="comment">//这个函数用来设置当执行dismiss方法时 进行可交互的转场动画</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="type">id</span> &lt;<span class="built_in">UIViewControllerInteractiveTransitioning</span>&gt;)interactionControllerForDismissal:(<span class="type">id</span> &lt;<span class="built_in">UIViewControllerAnimatedTransitioning</span>&gt;)animator;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回UIPresentationController处理转场</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">UIPresentationController</span> *)presentationControllerForPresentedViewController:(<span class="built_in">UIViewController</span> *)presented presentingViewController:(<span class="keyword">nullable</span> <span class="built_in">UIViewController</span> *)presenting sourceViewController:(<span class="built_in">UIViewController</span> *)source <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">8</span>_0);</span><br></pre></td></tr></table></figure>

<p>这里我们只实现present动画那么只需要在IDLTransitionDelegate中实现animationControllerForPresentedController方法。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">nullable</span> <span class="type">id</span> &lt;<span class="built_in">UIViewControllerAnimatedTransitioning</span>&gt;)animationControllerForPresentedController:(<span class="built_in">UIViewController</span> *)presented presentingController:(<span class="built_in">UIViewController</span> *)presenting sourceController:(<span class="built_in">UIViewController</span> *)source&#123;</span><br><span class="line">    <span class="keyword">return</span> [IDLPresenteContentController new];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>IDLPresenteContentController是一个实现了UIViewControllerAnimatedTransitioning协议的对象。它用于提供动画事件，动画上下文的对象。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这个函数用来设置动画执行的时长</span></span><br><span class="line">- (<span class="built_in">NSTimeInterval</span>)transitionDuration:(<span class="keyword">nullable</span> <span class="type">id</span> &lt;<span class="built_in">UIViewControllerContextTransitioning</span>&gt;)transitionContext&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这个函数用来处理具体的动画</span></span><br><span class="line">- (<span class="type">void</span>)animateTransition:(<span class="type">id</span> &lt;<span class="built_in">UIViewControllerContextTransitioning</span>&gt;)transitionContext &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.获取动画的源控制器和目标控制器</span></span><br><span class="line">    ViewController *fromVC = [transitionContext viewControllerForKey:<span class="built_in">UITransitionContextFromViewControllerKey</span>];</span><br><span class="line">    DetailViewController *toVC = [transitionContext viewControllerForKey:<span class="built_in">UITransitionContextToViewControllerKey</span>];</span><br><span class="line">    <span class="built_in">UIView</span> *container = [transitionContext containerView];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.创建一个imageView 的截图，并把 imageView 隐藏，造成使用户以为移动的就是 imageView 的假象</span></span><br><span class="line">    <span class="built_in">UIView</span> *snapshotView = [fromVC.ImageView snapshotViewAfterScreenUpdates:<span class="literal">NO</span>];</span><br><span class="line">    <span class="comment">//计算fromVC.view上的fromVC.ImageView.frame相对于container的坐标</span></span><br><span class="line">    snapshotView.frame = [container convertRect:fromVC.ImageView.frame fromView:fromVC.view];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3.设置目标控制器的位置，并把透明度设为0，在后面的动画中慢慢显示出来变为1</span></span><br><span class="line">    toVC.view.frame = [transitionContext finalFrameForViewController:toVC];</span><br><span class="line">    toVC.view.alpha = <span class="number">0</span>;</span><br><span class="line">    toVC.bgImageView.hidden = <span class="literal">YES</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//4.都添加到 container 中。注意顺序不能错了</span></span><br><span class="line">    [container addSubview:toVC.view];</span><br><span class="line">    [container addSubview:snapshotView];</span><br><span class="line">    </span><br><span class="line">    [<span class="built_in">UIView</span> animateWithDuration:[<span class="keyword">self</span> transitionDuration:transitionContext] delay:<span class="number">0</span> options:<span class="built_in">UIViewAnimationOptionCurveEaseInOut</span> animations:^&#123;</span><br><span class="line">        snapshotView.frame = [container convertRect:toVC.bgImageView.frame fromView:toVC.view];</span><br><span class="line">        fromVC.view.alpha = <span class="number">0</span>;</span><br><span class="line">        toVC.view.alpha = <span class="number">1</span>;</span><br><span class="line">    &#125; completion:^(<span class="type">BOOL</span> finished) &#123;</span><br><span class="line">        fromVC.ImageView.hidden = <span class="literal">NO</span>;</span><br><span class="line">        toVC.bgImageView.hidden = <span class="literal">NO</span>;</span><br><span class="line">        [snapshotView removeFromSuperview];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//一定要记得动画完成后执行此方法，让系统管理 navigation 如果设置为no。可以自己试试</span></span><br><span class="line">        [transitionContext completeTransition:<span class="literal">YES</span>];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里最重要的就是animateTransition方法，这个方法的参数中transitionContext也是关键中的关键，可以通过viewControllerForKey在transitionContext中取出跳转的ViewController，可以通过viewForKey获取到对应的view，还可以通过它来获得动画事件等。在animateTransition方法中一般是如下步骤实现整个动画的：</p>
<ol>
<li>通过viewControllerForKey&#x2F;viewForKey获取所有需要的 view 以及 VC</li>
<li>设定fromView, toView的初始状态</li>
<li>将toView通过addSubview 添加到 containerView </li>
<li>获取动画时间</li>
<li>设定动画</li>
<li>在动画结束的时候调用[transitionContext completeTransition:YES]来结束动画。</li>
</ol>
<p>从上面可以看出transitionContext是一个十分关键的地方，它用于提供动画过程中所需要的各种数据，我们来看下它的声明：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">//容器视图 用来表现动画</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">UIView</span> *containerView;</span><br><span class="line"><span class="comment">//下面是几个只读属性</span></span><br><span class="line"><span class="comment">//是否应该执行动画</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">getter</span>=isAnimated) <span class="type">BOOL</span> animated;</span><br><span class="line"><span class="comment">//是否是可交互的</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">getter</span>=isInteractive) <span class="type">BOOL</span> interactive; <span class="comment">// This indicates whether the transition is currently interactive.</span></span><br><span class="line"><span class="comment">//是否被取消了</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="type">BOOL</span> transitionWasCancelled;</span><br><span class="line"><span class="comment">//转场风格</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">UIModalPresentationStyle</span> presentationStyle;</span><br><span class="line"><span class="comment">//调用这个函数来更新转场过程的百分比 用于可交互动画的阈值</span></span><br><span class="line">- (<span class="type">void</span>)updateInteractiveTransition:(<span class="built_in">CGFloat</span>)percentComplete;</span><br><span class="line"><span class="comment">//完成可交互的转场交互动作时调用</span></span><br><span class="line">- (<span class="type">void</span>)finishInteractiveTransition;</span><br><span class="line"><span class="comment">//取消可交互的转场交互动作时调用</span></span><br><span class="line">- (<span class="type">void</span>)cancelInteractiveTransition;</span><br><span class="line"><span class="comment">//转场动画被中断  暂停时调用</span></span><br><span class="line">- (<span class="type">void</span>)pauseInteractiveTransition;</span><br><span class="line"><span class="comment">//转场动画完成时调用</span></span><br><span class="line">- (<span class="type">void</span>)completeTransition:(<span class="type">BOOL</span>)didComplete;</span><br><span class="line"><span class="comment">//获取转场中的两个视图控制器</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">UITransitionContextViewControllerKey的定义</span></span><br><span class="line"><span class="comment">UITransitionContextFromViewControllerKey  //原视图控制器</span></span><br><span class="line"><span class="comment">UITransitionContextToViewControllerKey    //跳转的视图控制器</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">- (<span class="keyword">nullable</span> __kindof <span class="built_in">UIViewController</span> *)viewControllerForKey:(<span class="built_in">UITransitionContextViewControllerKey</span>)key;</span><br><span class="line"><span class="comment">//直接获取转场中的视图</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">UITransitionContextFromViewKey  //原视图</span></span><br><span class="line"><span class="comment">UITransitionContextToViewKey    //转场的视图</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">- (<span class="keyword">nullable</span> __kindof <span class="built_in">UIView</span> *)viewForKey:(<span class="built_in">UITransitionContextViewKey</span>)key;</span><br><span class="line"><span class="comment">//获取视图控制器的初识位置</span></span><br><span class="line">- (<span class="built_in">CGRect</span>)initialFrameForViewController:(<span class="built_in">UIViewController</span> *)vc;</span><br><span class="line"><span class="comment">//获取视图控制器转场后的位置</span></span><br><span class="line">- (<span class="built_in">CGRect</span>)finalFrameForViewController:(<span class="built_in">UIViewController</span> *)vc;</span><br></pre></td></tr></table></figure>

<h6 id="2-2-Interactive-交互动画"><a href="#2-2-Interactive-交互动画" class="headerlink" title="2.2 Interactive 交互动画"></a><strong><strong>2.2 Interactive 交互动画</strong></strong></h6><p>上面仅仅介绍的是present动画，但是iOS还支持交互动画，也就是通过手势等界面交互来触发动画。</p>
<p>有了上面的介绍接下来的介绍会稍稍简单点：</p>
<p>首先我们还是先设置transitioningDelegate，并在上面IDLTransitionDelegate中添加如下方法实现：</p>
<figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line"><span class="operator">-</span> (nullable <span class="built_in">id</span> <span class="operator">&lt;</span>UIViewControllerInteractiveTransitioning<span class="operator">&gt;</span>)interactionControllerForDismissal<span class="operator">:</span>(<span class="built_in">id</span> <span class="operator">&lt;</span>UIViewControllerAnimatedTransitioning<span class="operator">&gt;</span>)animator&#123;</span><br><span class="line">    <span class="keyword">return</span> [IDLInteractiveTransition <span class="keyword">new</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来实现 IDLInteractiveTransition</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)startInteractiveTransition:(<span class="type">id</span>&lt;<span class="built_in">UIViewControllerContextTransitioning</span>&gt;)transitionContext &#123;</span><br><span class="line">    <span class="comment">// 把 context 对象保存起来</span></span><br><span class="line">    <span class="keyword">self</span>.transitionContext = transitionContext;</span><br><span class="line">    [<span class="variable language_">super</span> startInteractiveTransition:transitionContext];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据手势的偏移来计算当前动画应该有的完成度</span></span><br><span class="line">- (<span class="built_in">CGFloat</span>)percentForGesture:(<span class="built_in">UIScreenEdgePanGestureRecognizer</span> *)gesture &#123;</span><br><span class="line">    <span class="comment">// 根据 container view 以及 gesture recognizer 计算偏移量</span></span><br><span class="line">    <span class="built_in">UIView</span> *transitionContainerView = <span class="keyword">self</span>.transitionContext.containerView;</span><br><span class="line">    <span class="built_in">CGPoint</span> locationInSourceView = [gesture locationInView:transitionContainerView];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据偏移量得出百分比</span></span><br><span class="line">    <span class="built_in">CGFloat</span> width = <span class="built_in">CGRectGetWidth</span>(transitionContainerView.bounds);</span><br><span class="line">    <span class="keyword">return</span> (width - locationInSourceView.x) / width;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// gesture recognizer 的回调</span></span><br><span class="line">- (<span class="keyword">IBAction</span>)gestureRecognizeDidUpdate:(<span class="built_in">UIScreenEdgePanGestureRecognizer</span> *)gestureRecognizer &#123;</span><br><span class="line">    <span class="keyword">switch</span> (gestureRecognizer.state)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIGestureRecognizerStateBegan</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIGestureRecognizerStateChanged</span>:</span><br><span class="line">            <span class="comment">// 计算百分比，并返回</span></span><br><span class="line">            [<span class="keyword">self</span>.transitionContext updateInteractiveTransition:[<span class="keyword">self</span> percentForGesture:gestureRecognizer]];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIGestureRecognizerStateEnded</span>:</span><br><span class="line">            <span class="comment">// 根据预先设定的阈值决定是结束还是取消，这里我们设定 view 中间是分界线</span></span><br><span class="line">            <span class="keyword">if</span> ([<span class="keyword">self</span> percentForGesture:gestureRecognizer] &gt;= <span class="number">0.5</span>f)</span><br><span class="line">                [<span class="keyword">self</span>.transitionContext finishInteractiveTransition];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                [<span class="keyword">self</span>.transitionContext cancelInteractiveTransition];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="comment">// 其他情况，取消转场</span></span><br><span class="line">            [<span class="keyword">self</span>.transitionContext cancelInteractiveTransition];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面是通过自己实现一个遵循UIViewControllerInteractiveTransitioning协议的对象，当然也可以通过系统为我们提供的UIPercentDrivenInteractiveTransition来简化代码</p>
<h6 id="2-3-UIPresentationController-实现弹窗效果"><a href="#2-3-UIPresentationController-实现弹窗效果" class="headerlink" title="2.3 UIPresentationController 实现弹窗效果"></a><strong><strong>2.3 UIPresentationController 实现弹窗效果</strong></strong></h6><p>UIPresentationController 有很多属性下面将比较重要的给抠出来给大家介绍：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">UIPresentationController</span> : <span class="title">NSObject</span> &lt;<span class="title">UIAppearanceContainer</span>, <span class="title">UITraitEnvironment</span>, <span class="title">UIContentContainer</span>, <span class="title">UIFocusEnvironment</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//这个概念见文章上面介绍</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="built_in">UIViewController</span> *presentingViewController; </span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="built_in">UIViewController</span> *presentedViewController;</span><br><span class="line"><span class="comment">//弹窗的模态形式</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">UIModalPresentationStyle</span> presentationStyle;</span><br><span class="line"><span class="comment">// 转场发生的容器视图</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">strong</span>) <span class="built_in">UIView</span> *containerView;</span><br><span class="line"><span class="comment">// 初始化方法</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithPresentedViewController:(<span class="built_in">UIViewController</span> *)presentedViewController presentingViewController:(<span class="keyword">nullable</span> <span class="built_in">UIViewController</span> *)presentingViewController <span class="built_in">NS_DESIGNATED_INITIALIZER</span>;</span><br><span class="line"><span class="comment">// 动画容器布局，可以在这里布局子元素</span></span><br><span class="line">- (<span class="type">void</span>)containerViewWillLayoutSubviews;</span><br><span class="line">- (<span class="type">void</span>)containerViewDidLayoutSubviews;</span><br><span class="line"><span class="comment">//presentView的位置参数</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">CGRect</span> frameOfPresentedViewInContainerView;</span><br><span class="line"><span class="comment">//呈现动画时机回调</span></span><br><span class="line">- (<span class="type">void</span>)presentationTransitionWillBegin;</span><br><span class="line">- (<span class="type">void</span>)presentationTransitionDidEnd:(<span class="type">BOOL</span>)completed;</span><br><span class="line">- (<span class="type">void</span>)dismissalTransitionWillBegin;</span><br><span class="line">- (<span class="type">void</span>)dismissalTransitionDidEnd:(<span class="type">BOOL</span>)completed;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>下面是一个使用例子：</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@interface</span> <span class="attribute">IDLPopPresentationController </span>: UIPresentationController&lt;UIViewControllerTransitioningDelegate,UIViewControllerAnimatedTransitioning&gt;</span><br><span class="line"></span><br><span class="line"><span class="variable">@property</span> (nonatomic, strong, readonly) RACSubject *dissmissSignal;</span><br><span class="line"></span><br><span class="line"><span class="variable">@end</span></span><br></pre></td></tr></table></figure>

<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="meta">@implementation</span> <span class="type">IDLPopPresentationController</span></span><br><span class="line"></span><br><span class="line">#pragma mark overide <span class="type">UIPresentationController</span></span><br><span class="line"><span class="operator">-</span> (instancetype)initWithPresentedViewController:(<span class="type">UIViewController</span> <span class="operator">*</span>)presentedViewController presentingViewController:(<span class="type">UIViewController</span> <span class="operator">*</span>)presentingViewController &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> <span class="operator">=</span> [<span class="keyword">super</span> initWithPresentedViewController:presentedViewController presentingViewController:presentingViewController]) &#123;</span><br><span class="line">        presentedViewController.modalPresentationStyle <span class="operator">=</span> <span class="type">UIModalPresentationCustom</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="operator">-</span> (void)dealloc &#123;</span><br><span class="line">    [<span class="keyword">self</span>.dissmissSignal sendCompleted];</span><br><span class="line">    <span class="keyword">self</span>.dissmissSignal <span class="operator">=</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="operator">-</span> (void)presentationTransitionWillBegin &#123;</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span>.containerView addSubview:<span class="keyword">self</span>.dimmingView];</span><br><span class="line">    [<span class="keyword">self</span>.dimmingView addSubview:<span class="keyword">self</span>.closeBtn];</span><br><span class="line">    [<span class="keyword">self</span>.closeBtn nm_makeFrame:<span class="operator">^</span>(<span class="type">NMFrameMaker</span> <span class="operator">*</span>make) &#123;</span><br><span class="line">        make.right.equalTo(<span class="keyword">self</span>.dimmingView).margin(<span class="number">25</span>);</span><br><span class="line">        make.top.equalTo(<span class="keyword">self</span>.dimmingView).margin(<span class="number">40</span>);</span><br><span class="line">        make.size.nm_equalTo(<span class="type">CGSizeMake</span>(<span class="number">20</span>, <span class="number">20</span>));</span><br><span class="line">    &#125;];</span><br><span class="line">    <span class="meta">@weakify</span>(<span class="keyword">self</span>);</span><br><span class="line">    [<span class="keyword">self</span>.closeBtn addTapBlock:<span class="operator">^</span>(id obj) &#123;</span><br><span class="line">        <span class="meta">@strongify</span>(<span class="keyword">self</span>);</span><br><span class="line">        [<span class="keyword">self</span>.presentingViewController dismissViewControllerAnimated:<span class="type">YES</span> completion:<span class="literal">nil</span>];</span><br><span class="line">        [<span class="keyword">self</span>.dissmissSignal sendNext:<span class="literal">nil</span>];</span><br><span class="line">        [<span class="keyword">self</span>.dissmissSignal sendCompleted];</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//背景 self.dimmingView 的淡入效果与过渡效果一起执</span></span><br><span class="line">    id<span class="operator">&lt;</span><span class="type">UIViewControllerTransitionCoordinator</span><span class="operator">&gt;</span> transitionCoordinator <span class="operator">=</span> <span class="keyword">self</span>.presentingViewController.transitionCoordinator;</span><br><span class="line">    [transitionCoordinator animateAlongsideTransition:<span class="operator">^</span>(id<span class="operator">&lt;</span><span class="type">UIViewControllerTransitionCoordinatorContext</span><span class="operator">&gt;</span> context) &#123;</span><br><span class="line">        <span class="meta">@strongify</span>(<span class="keyword">self</span>);</span><br><span class="line">        <span class="keyword">self</span>.dimmingView.alpha <span class="operator">=</span> <span class="number">0</span>.65f;</span><br><span class="line">    &#125; completion:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="operator">-</span> (void)presentationTransitionDidEnd:(<span class="type">BOOL</span>)completed &#123;</span><br><span class="line">    <span class="comment">//如果呈现没有完成，那就移除背景 View</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="operator">!</span>completed)&#123;</span><br><span class="line">        [<span class="keyword">self</span>.dimmingView removeFromSuperview];</span><br><span class="line">        <span class="keyword">self</span>.dimmingView <span class="operator">=</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="operator">-</span> (void)dismissalTransitionWillBegin &#123;</span><br><span class="line">    id<span class="operator">&lt;</span><span class="type">UIViewControllerTransitionCoordinator</span><span class="operator">&gt;</span> coordinator <span class="operator">=</span> <span class="keyword">self</span>.presentingViewController.transitionCoordinator;</span><br><span class="line">    <span class="meta">@weakify</span>(<span class="keyword">self</span>);</span><br><span class="line">    [coordinator animateAlongsideTransition:<span class="operator">^</span>(id<span class="operator">&lt;</span><span class="type">UIViewControllerTransitionCoordinatorContext</span><span class="operator">&gt;</span> context) &#123;</span><br><span class="line">        <span class="meta">@strongify</span>(<span class="keyword">self</span>);</span><br><span class="line">        <span class="keyword">self</span>.dimmingView.alpha <span class="operator">=</span> <span class="number">0.0</span>;</span><br><span class="line">    &#125; completion:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="operator">-</span> (void)dismissalTransitionDidEnd:(<span class="type">BOOL</span>)completed &#123;</span><br><span class="line">    <span class="keyword">if</span>(completed) &#123;</span><br><span class="line">        [<span class="keyword">self</span>.dimmingView removeFromSuperview];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Notifies an interested controller that the preferred content size of one of its children changed.</span></span><br><span class="line"><span class="operator">-</span> (void)preferredContentSizeDidChangeForChildContentContainer:(id<span class="operator">&lt;</span><span class="type">UIContentContainer</span><span class="operator">&gt;</span>)container &#123;</span><br><span class="line">    [<span class="keyword">super</span> preferredContentSizeDidChangeForChildContentContainer:container];</span><br><span class="line">    <span class="keyword">if</span> (container <span class="operator">==</span> <span class="keyword">self</span>.presentedViewController) &#123;</span><br><span class="line">        [<span class="keyword">self</span>.containerView setNeedsLayout];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="operator">-</span> (void)containerViewWillLayoutSubviews &#123;</span><br><span class="line">    [<span class="keyword">super</span> containerViewWillLayoutSubviews];</span><br><span class="line">    <span class="keyword">self</span>.dimmingView.frame <span class="operator">=</span> <span class="keyword">self</span>.containerView.bounds;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="operator">-</span> (<span class="type">CGRect</span>)frameOfPresentedViewInContainerView &#123;</span><br><span class="line">    <span class="comment">//要呈现的ViewController区域</span></span><br><span class="line">    <span class="keyword">return</span> <span class="type">CGRectMake</span>(<span class="number">15</span>.f, <span class="number">73</span>.f, <span class="type">SCREEN_MIN_LENGTH</span> <span class="operator">-</span> <span class="number">30</span>.f , <span class="type">SCREEN_MAX_LENGTH</span> <span class="operator">-</span> <span class="number">103</span>.f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark <span class="type">UIViewControllerTransitioningDelegate</span></span><br><span class="line"></span><br><span class="line"><span class="operator">-</span> (<span class="type">UIPresentationController</span><span class="operator">*</span> )presentationControllerForPresentedViewController:(<span class="type">UIViewController</span> <span class="operator">*</span>)presented</span><br><span class="line">                                                      presentingViewController:(<span class="type">UIViewController</span> <span class="operator">*</span>)presenting</span><br><span class="line">                                                          sourceViewController:(<span class="type">UIViewController</span> <span class="operator">*</span>)source &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="operator">-</span> (id<span class="operator">&lt;</span><span class="type">UIViewControllerAnimatedTransitioning</span><span class="operator">&gt;</span>)animationControllerForPresentedController:(<span class="type">UIViewController</span> <span class="operator">*</span>)presented</span><br><span class="line">                                                                  presentingController:(<span class="type">UIViewController</span> <span class="operator">*</span>)presenting</span><br><span class="line">                                                                      sourceController:(<span class="type">UIViewController</span> <span class="operator">*</span>)source &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="operator">-</span> (id<span class="operator">&lt;</span><span class="type">UIViewControllerAnimatedTransitioning</span><span class="operator">&gt;</span>)animationControllerForDismissedController:(<span class="type">UIViewController</span> <span class="operator">*</span>)dismissed &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark <span class="operator">-</span> <span class="type">UIViewControllerAnimatedTransitioning</span></span><br><span class="line"><span class="operator">-</span> (<span class="type">NSTimeInterval</span>)transitionDuration:(id<span class="operator">&lt;</span><span class="type">UIViewControllerContextTransitioning</span><span class="operator">&gt;</span>)transitionContext &#123;</span><br><span class="line">    <span class="keyword">return</span> [transitionContext isAnimated] <span class="operator">?</span> <span class="number">0.3</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="operator">-</span> (void)animateTransition:(id<span class="operator">&lt;</span><span class="type">UIViewControllerContextTransitioning</span><span class="operator">&gt;</span>)transitionContext &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">UIViewController</span> <span class="operator">*</span>fromViewController <span class="operator">=</span> [transitionContext viewControllerForKey:<span class="type">UITransitionContextFromViewControllerKey</span>];</span><br><span class="line">    </span><br><span class="line">    __block <span class="type">UIView</span> <span class="operator">*</span>toView <span class="operator">=</span> [transitionContext viewForKey:<span class="type">UITransitionContextToViewKey</span>];</span><br><span class="line">    __block <span class="type">UIView</span> <span class="operator">*</span>fromView <span class="operator">=</span> [transitionContext viewForKey:<span class="type">UITransitionContextFromViewKey</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="type">UIView</span> <span class="operator">*</span>containerView <span class="operator">=</span> transitionContext.containerView;</span><br><span class="line">    [containerView addSubview:toView];</span><br><span class="line">    </span><br><span class="line">    <span class="type">BOOL</span> isPresenting <span class="operator">=</span> (fromViewController <span class="operator">==</span> <span class="keyword">self</span>.presentingViewController);</span><br><span class="line">    <span class="keyword">if</span> (isPresenting) &#123;</span><br><span class="line">        toView.frame <span class="operator">=</span> [<span class="keyword">self</span> frameOfPresentedViewInContainerView];</span><br><span class="line">        toView.alpha <span class="operator">=</span> <span class="keyword">self</span>.closeBtn.alpha <span class="operator">=</span> <span class="number">0</span>.0f;</span><br><span class="line">        toView.layer.masksToBounds <span class="operator">=</span> <span class="type">YES</span>;</span><br><span class="line">        toView.layer.cornerRadius <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">NSTimeInterval</span> duration <span class="operator">=</span> [<span class="keyword">self</span> transitionDuration:transitionContext];</span><br><span class="line">    [<span class="type">UIView</span> animateWithDuration:duration animations:<span class="operator">^</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isPresenting) &#123;</span><br><span class="line">            toView.alpha <span class="operator">=</span> <span class="keyword">self</span>.closeBtn.alpha <span class="operator">=</span> <span class="number">1</span>.0f;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fromView.alpha <span class="operator">=</span> <span class="keyword">self</span>.closeBtn.alpha <span class="operator">=</span> <span class="number">0</span>.0f;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; completion:<span class="operator">^</span>(<span class="type">BOOL</span> finished) &#123;</span><br><span class="line">        <span class="type">BOOL</span> wasCancelled <span class="operator">=</span> [transitionContext transitionWasCancelled];</span><br><span class="line">        [transitionContext completeTransition:<span class="operator">!</span>wasCancelled];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="operator">-</span> (void)animationEnded:(<span class="type">BOOL</span>) transitionCompleted &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#pragma mark <span class="type">Getter</span><span class="operator">/</span><span class="type">Setters</span></span><br><span class="line"></span><br><span class="line"><span class="operator">-</span> (<span class="type">UIView</span> <span class="operator">*</span>)dimmingView &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="operator">!</span>_dimmingView) &#123;</span><br><span class="line">        _dimmingView <span class="operator">=</span> [[<span class="type">UIView</span> alloc] initWithFrame:<span class="keyword">self</span>.containerView.bounds];</span><br><span class="line">        _dimmingView.alpha <span class="operator">=</span> <span class="number">0</span>.0f;</span><br><span class="line">        _dimmingView.backgroundColor <span class="operator">=</span> [<span class="type">UIColor</span> colorWithWhite:<span class="number">0</span>.0f alpha:<span class="number">0</span>.65f];</span><br><span class="line">        _dimmingView.autoresizingMask <span class="operator">=</span> <span class="type">UIViewAutoresizingFlexibleWidth</span><span class="operator">|</span><span class="type">UIViewAutoresizingFlexibleHeight</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _dimmingView;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="operator">-</span> (<span class="type">NMFocusExpandView</span> <span class="operator">*</span>)closeBtn &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="operator">!</span>_closeBtn) &#123;</span><br><span class="line">        _closeBtn <span class="operator">=</span> [[<span class="type">NMFocusExpandView</span> alloc] initWithFrame:<span class="type">CGRectZero</span>];</span><br><span class="line">        [_closeBtn setImage:<span class="type">NMImage</span>.login_instagram_close_icon];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _closeBtn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="operator">-</span> (<span class="type">RACSubject</span> <span class="operator">*</span>)dissmissSignal &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="operator">!</span>_dissmissSignal) &#123;</span><br><span class="line">        _dissmissSignal <span class="operator">=</span> [<span class="type">RACSubject</span> subject];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _dissmissSignal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用方法</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">IDLPopPresentationController *presentationController = [[IDLPopPresentationController alloc] initWithPresentedViewController:instagramLoginViewController</span><br><span class="line">                                                                                                    presentingViewController:<span class="keyword">self</span>];</span><br><span class="line">instagramLoginViewController.transitioningDelegate = presentationController;</span><br><span class="line">[<span class="keyword">self</span> presentViewController:instagramLoginViewController animated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure>

<h6 id="3-转场动画深入文章推荐"><a href="#3-转场动画深入文章推荐" class="headerlink" title="3 转场动画深入文章推荐"></a><strong><strong>3 转场动画深入文章推荐</strong></strong></h6><p>关于转场动画是一个十分大的一个话题，该博客只是帮大家理清楚转场动画的整个过程，对于细节大家还需要深入去挖掘，这里推荐几个比较好的文章大家可以在后续学习中供大家深入学习：</p>
<ol>
<li><p><a target="_blank" rel="noopener" href="https://github.com/seedante/iOS-Note/wiki/ViewController-Transition">iOS 视图控制器转场详解 Github地址</a> <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/9333c5f983de">iOS 视图控制器转场详解 简书地址</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://my.oschina.net/u/2340880/blog/1839722">玩转iOS转场动画</a></p>
</li>
</ol>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/iOS-%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/">iOS 理论基础</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/iOS-理论基础/">iOS 理论基础</a>
  </div>

</div>



<div class="comments-count">
	
	  	<span></span>
		<a href="/2019/08/08/iOS-动画总结/#comments" class="ds-thread-count comments-count-link" data-thread-key="2019/08/08/iOS-动画总结/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/08/08/iOS-事件及手势处理流程/" title="iOS 事件及手势处理流程" itemprop="url">iOS 事件及手势处理流程</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Edgar" target="_blank" itemprop="author">Edgar</a>
		
  <p class="article-time">
    <time datetime="2019-08-07T17:30:01.000Z" itemprop="datePublished"> Published 2019-08-08</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h5 id="开篇叨叨"><a href="#开篇叨叨" class="headerlink" title="开篇叨叨"></a><strong><strong>开篇叨叨</strong></strong></h5><p>在iOS 事件模型中，由iOS事件源产生事件，而后顺着布局树进行Hit-Testing测试，判断哪些View可以响应这个事件，这些View组成一个事件响应链，产生的事件将沿着响应链一级一级传递，最终传递到最终的事件响应者中，由最终事件响应者提供的响应方法处理当前的事件。</p>
<p>这篇博客将主要针对如下问题进行展开：</p>
<ul>
<li>iOS中有哪些事件源类型</li>
<li>哪些对象会消费这些事件（哪些对象可以组成事件响应链上的节点）</li>
<li>事件是怎么传递的</li>
<li>如何判断谁是事件的最佳响应者</li>
<li>事件的处理</li>
</ul>
<h5 id="事件源"><a href="#事件源" class="headerlink" title="事件源"></a><strong><strong>事件源</strong></strong></h5><p>为满足用户需求，iOS 提供了例如点击、长按、摇晃、3D Touch 等多种事件,这些事件大体可以分成触摸事件，运动事件，远程控制事件，按压事件四类。</p>
<ul>
<li><p><strong><strong>触摸事件：</strong></strong></p>
<figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">长按手势 <span class="comment">(UILongPressGestureRecognizer)</span></span><br><span class="line">拖动手势 <span class="comment">(UIPanGestureRecognizer)</span></span><br><span class="line">捏合手势 <span class="comment">(UIPinchGestureRecognizer)</span></span><br><span class="line">响应屏幕边缘手势 <span class="comment">(UIScreenEdgePanGestureRecognizer)</span></span><br><span class="line">轻扫手势 <span class="comment">(UISwipeGestureRecognizer)</span></span><br><span class="line">旋转手势 <span class="comment">(UIRotationGestureRecognizer)</span></span><br><span class="line">点击手势 <span class="comment">(UITapGestureRecognizer)</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong><strong>运动事件</strong></strong><br>iPhone 内置陀螺仪、加速器和磁力仪，可以感知手机的运动情况。iOS 提供了 Core Motion 框架来处理这些运动事件。<br>其中陀螺仪主要用于测量设备绕 X-Y-Z 轴的自转速率，倾斜角度等，加速器主要用于测量设备在 X-Y-Z 轴速度的改变，磁力仪可以测量当前设备的磁极、方向、经纬度等数据。</p>
</li>
<li><p><strong><strong>远程控制事件</strong></strong><br>远程控制事件指通过耳机去控制手机上的一些操作，比如上一曲&#x2F;下一曲&#x2F;播放&#x2F;停止等。</p>
</li>
<li><p><strong><strong>按压事件</strong></strong><br>iOS 9 提供了 3D Touch 事件，可以通过压力的不同来区分不同的操作。</p>
</li>
</ul>
<h5 id="事件响应者"><a href="#事件响应者" class="headerlink" title="事件响应者"></a><strong><strong>事件响应者</strong></strong></h5><p>在iOS中不是任何对象都能处理事件，只有继承了UIResponder的对象才能接受并处理事件，下面是iOS中UIResponder的子类，也就是说只有这些类以及这些类的子类才能响应并处理事件,UIResponder对象之间的联系靠nextResponder指针,组成一个响应链：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UIApplication</span></span><br><span class="line"><span class="built_in">UIViewController</span></span><br><span class="line"><span class="built_in">UIView</span></span><br></pre></td></tr></table></figure>

<p>UIResponder 中定义了一系列的触摸事件响应函数，我们可以通过覆写这些方法来提供自定义的响应：</p>
<figure class="highlight erlang"><table><tr><td class="code"><pre><span class="line">- <span class="params">(void)</span>touchesBegan:<span class="params">(NSSet *)</span>touches withEvent:<span class="params">(UIEvent *)</span>event;</span><br><span class="line">- <span class="params">(void)</span>touchesMoved:<span class="params">(NSSet *)</span>touches withEvent:<span class="params">(UIEvent *)</span>event;</span><br><span class="line">- <span class="params">(void)</span>touchesEnded:<span class="params">(NSSet *)</span>touches withEvent:<span class="params">(UIEvent *)</span>event;</span><br><span class="line">- <span class="params">(void)</span>touchesCancelled:<span class="params">(NSSet *)</span>touches withEvent:<span class="params">(UIEvent *)</span>event;</span><br><span class="line"></span><br><span class="line">- <span class="params">(void)</span>motionBegan:<span class="params">(UIEventSubtype)</span>motion withEvent:<span class="params">(UIEvent *)</span>event;</span><br><span class="line">- <span class="params">(void)</span>motionEnded:<span class="params">(UIEventSubtype)</span>motion withEvent:<span class="params">(UIEvent *)</span>event;</span><br><span class="line">- <span class="params">(void)</span>motionCancelled:<span class="params">(UIEventSubtype)</span>motion withEvent:<span class="params">(UIEvent *)</span>event;</span><br><span class="line"></span><br><span class="line">- <span class="params">(void)</span>remoteControlReceivedWithEvent:<span class="params">(UIEvent *)</span>event;</span><br></pre></td></tr></table></figure>

<p>我们以最常见的触摸事件进行介绍：</p>
<p><img src="/2019/08/08/iOS-%E4%BA%8B%E4%BB%B6%E5%8F%8A%E6%89%8B%E5%8A%BF%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B/000003.png"></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)touchesBegan:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event;<span class="comment">//一根或者多根手指开始触摸view</span></span><br><span class="line">- (<span class="type">void</span>)touchesMoved:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event;<span class="comment">//一根或者多根手指在view上移动</span></span><br><span class="line">- (<span class="type">void</span>)touchesEnded:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event;<span class="comment">//一根或者多根手指离开view</span></span><br><span class="line">- (<span class="type">void</span>)touchesCancelled:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event;<span class="comment">//触摸结束前，某个系统事件(例如电话呼入)打断触摸过程时候调用</span></span><br></pre></td></tr></table></figure>
<p>这里还需注意的是：</p>
<ul>
<li>不论多少根手指同时触摸View,都只会调用一次touchesBegan，但是touches里面会包裹着多个UITouch，每个手指对应一个UITouch对象。</li>
<li>如果多个手指一前一后触摸同一个View,那么会调用多次touchesBegan，每次只包含一个UITouch对象。</li>
<li>如果是处理UIView触摸事件，需要在其子View的中覆写对应的touch方法。如果是处理UIViewController的触摸事件，可以直接在UIViewController的文件中覆写对应的touch方法。</li>
<li>当我们手指按下后在屏幕上移动的时候会不断触发touchesMoved，一旦抬起来就会触发touchesEnded。</li>
</ul>
<h5 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a><strong><strong>事件对象</strong></strong></h5><p>了解了事件源，事件响应对象，我们还需要了解下事件对象，事件对象会携带者一系列的事件信息到事件响应对象，一个触摸事件可能是由多个手指同时触摸产生的。触摸对象集合通过 allTouches 属性获取。</p>
<ul>
<li><strong><strong>UIEvent</strong></strong></li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">UIEvent</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">readonly</span>) <span class="built_in">UIEventType</span>     type;                     <span class="comment">//事件类型</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">readonly</span>) <span class="built_in">UIEventSubtype</span>  subtype;                  <span class="comment">//事件子类型</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">readonly</span>) <span class="built_in">NSTimeInterval</span>  timestamp;                <span class="comment">//事件产生的时间戳</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">nullable</span>) <span class="built_in">NSSet</span> &lt;<span class="built_in">UITouch</span> *&gt; *allTouches; <span class="comment">//一个事件包含的所有触摸事件</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSSet</span> &lt;<span class="built_in">UITouch</span> *&gt; *)touchesForWindow:(<span class="built_in">UIWindow</span> *)window;     </span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSSet</span> &lt;<span class="built_in">UITouch</span> *&gt; *)touchesForView:(<span class="built_in">UIView</span> *)view;</span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSSet</span> &lt;<span class="built_in">UITouch</span> *&gt; *)touchesForGestureRecognizer:(<span class="built_in">UIGestureRecognizer</span> *)gesture;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里的<strong><strong>UIEventType</strong></strong>是事件大的类别：</p>
<figure class="highlight elm"><table><tr><td class="code"><pre><span class="line">typedef <span class="type">NS_ENUM</span>(<span class="type">NSInteger</span>, <span class="type">UIEventType</span>) &#123;</span><br><span class="line">    <span class="type">UIEventTypeTouches</span>,</span><br><span class="line">    <span class="type">UIEventTypeMotion</span>,</span><br><span class="line">    <span class="type">UIEventTypeRemoteControl</span>,</span><br><span class="line">    <span class="type">UIEventTypePresses</span> <span class="type">API_AVAILABLE</span>(ios(9.0)),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>UIEventSubtype 为事件小的类别，比如远程控制事件会使用这个字段来区分具体是哪个子事件：</p>
<figure class="highlight elm"><table><tr><td class="code"><pre><span class="line">typedef <span class="type">NS_ENUM</span>(<span class="type">NSInteger</span>, <span class="type">UIEventSubtype</span>) &#123;</span><br><span class="line">    // available in iPhone <span class="type">OS</span> 3.0</span><br><span class="line">    <span class="type">UIEventSubtypeNone</span>                              = 0,</span><br><span class="line">    </span><br><span class="line">    // for <span class="type">UIEventTypeMotion</span>, available in iPhone <span class="type">OS</span> 3.0</span><br><span class="line">    <span class="type">UIEventSubtypeMotionShake</span>                       = 1,</span><br><span class="line">    </span><br><span class="line">    // for <span class="type">UIEventTypeRemoteControl</span>, available in iOS 4.0</span><br><span class="line">    <span class="type">UIEventSubtypeRemoteControlPlay</span>                 = 100,</span><br><span class="line">    <span class="type">UIEventSubtypeRemoteControlPause</span>                = 101,</span><br><span class="line">    <span class="type">UIEventSubtypeRemoteControlStop</span>                 = 102,</span><br><span class="line">    <span class="type">UIEventSubtypeRemoteControlTogglePlayPause</span>      = 103,</span><br><span class="line">    <span class="type">UIEventSubtypeRemoteControlNextTrack</span>            = 104,</span><br><span class="line">    <span class="type">UIEventSubtypeRemoteControlPreviousTrack</span>        = 105,</span><br><span class="line">    <span class="type">UIEventSubtypeRemoteControlBeginSeekingBackward</span> = 106,</span><br><span class="line">    <span class="type">UIEventSubtypeRemoteControlEndSeekingBackward</span>   = 107,</span><br><span class="line">    <span class="type">UIEventSubtypeRemoteControlBeginSeekingForward</span>  = 108,</span><br><span class="line">    <span class="type">UIEventSubtypeRemoteControlEndSeekingForward</span>    = 109,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>里面包含了一系列的UITouch,可以通过<strong><strong>touchesForWindow</strong></strong>，<strong><strong>touchesForView</strong></strong>，<strong><strong>touchesForGestureRecognizer</strong></strong>来判断属于某个window，view，以及手势下的UITouch.</p>
<ul>
<li><strong><strong>UITouch</strong></strong></li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">UITouch</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//时间戳: 记录了触摸事件产生或变化时的时间。单位是秒。</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">readonly</span>) <span class="built_in">NSTimeInterval</span>      timestamp;</span><br><span class="line"></span><br><span class="line"><span class="comment">//触摸事件在屏幕上有一个周期，即触摸开始、触摸点移动、触摸结束，还有中途取消。通过phase可以查看当前触摸事件在一个周期中所处的状态。</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">readonly</span>) <span class="built_in">UITouchPhase</span>        phase;</span><br><span class="line"></span><br><span class="line"><span class="comment">//轻击（Tap）操作和鼠标的单击操作类似，tapCount表示短时间内轻击屏幕的次数。因此可以根据tapCount判断单击、双击或更多的轻击。</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">readonly</span>) <span class="built_in">NSUInteger</span>          tapCount;</span><br><span class="line"></span><br><span class="line"><span class="comment">//触摸的类型</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">readonly</span>) <span class="built_in">UITouchType</span>         type;</span><br><span class="line"></span><br><span class="line"><span class="comment">//触摸的半径</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">readonly</span>) <span class="built_in">CGFloat</span> majorRadius;</span><br><span class="line"></span><br><span class="line"><span class="comment">//触摸的力度</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">readonly</span>) <span class="built_in">CGFloat</span> force;</span><br><span class="line"></span><br><span class="line"><span class="comment">//触摸产生时所处的窗口。由于窗口可能发生变化，当前所在的窗口不一定是最开始的窗口。</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nullable</span>,<span class="keyword">nonatomic</span>,<span class="keyword">readonly</span>,<span class="keyword">strong</span>) <span class="built_in">UIWindow</span> *window;</span><br><span class="line"></span><br><span class="line"><span class="comment">//触摸产生时所处的视图。由于视图可能发生变化，当前视图也不一定是最初的视图。</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nullable</span>,<span class="keyword">nonatomic</span>,<span class="keyword">readonly</span>,<span class="keyword">strong</span>) <span class="built_in">UIView</span> *view;</span><br><span class="line"></span><br><span class="line"><span class="comment">//现在触摸的坐标</span></span><br><span class="line">/函数返回一个<span class="built_in">CGPoint</span>类型的值，表示触摸在view这个视图上的位置，这里返回的位置是针对view的坐标系的。调用时传入的view参数为空的话，返回的时触摸点在整个窗口的位置。</span><br><span class="line">-(<span class="built_in">CGPoint</span>)locationInView:(<span class="keyword">nullable</span> <span class="built_in">UIView</span> *)view;</span><br><span class="line"></span><br><span class="line"><span class="comment">//上一次触摸的坐标</span></span><br><span class="line"><span class="comment">//该方法记录了前一个坐标值，函数返回也是一个CGPoint类型的值，表示触摸在view这个视图上的位置，这里返回的位置是针对view的坐标系的。调用时传入的view参数为空的话，返回的时触摸点在整个窗口的位置。</span></span><br><span class="line">-(<span class="built_in">CGPoint</span>)previousLocationInView:(<span class="keyword">nullable</span> <span class="built_in">UIView</span> *)view;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>UITouchPhase 用于表示某个触摸是处于哪个阶段</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, <span class="built_in">UITouchPhase</span>) &#123;</span><br><span class="line">    <span class="built_in">UITouchPhaseBegan</span>,             <span class="comment">// whenever a finger touches the surface.</span></span><br><span class="line">    <span class="built_in">UITouchPhaseMoved</span>,             <span class="comment">// whenever a finger moves on the surface.</span></span><br><span class="line">    <span class="built_in">UITouchPhaseStationary</span>,        <span class="comment">// whenever a finger is touching the surface but hasn&#x27;t moved since the previous event.</span></span><br><span class="line">    <span class="built_in">UITouchPhaseEnded</span>,             <span class="comment">// whenever a finger leaves the surface.</span></span><br><span class="line">    <span class="built_in">UITouchPhaseCancelled</span>,         <span class="comment">// whenever a touch doesn&#x27;t end but we need to stop tracking (e.g. putting device to face)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h5 id="事件的传递流程"><a href="#事件的传递流程" class="headerlink" title="事件的传递流程"></a><strong><strong>事件的传递流程</strong></strong></h5><h6 id="阶段1-将事件传递到UIWindow"><a href="#阶段1-将事件传递到UIWindow" class="headerlink" title="阶段1 将事件传递到UIWindow"></a><strong><strong>阶段1 将事件传递到UIWindow</strong></strong></h6><p>当一个事件产生的时候，事件会在底层由IOKit.framework 封装成IOHIDEvent对象。然后系统通过mach port将IOHIDEvent对象转发给SpringBoard.app。 SpringBoard.app 它有点像Android中的lancher，只接收按钮，触摸，加速等事件，SpringBoard会根据当前桌面的状态，判断应该由谁处理此次触摸事件.可能在事件产生的时候你在桌面翻页并没有应用在前台运行，这时候触发SpringBoard本身主线程runloop的source0事件源的回调，将事件交由桌面系统去消耗，如果有应用在前台运行那么会通过mach port 将IOHIDEvent 转发给对应的App.App主线程的RunLoop收到SpringBoard转发的消息后，触发Source1回调__IOHIDEventSystemClientQueueCallback。在这个方法中会触发Source0回调__UIApplicationHandleEventQueue，将IOHIDEvent转换为UIEvent.并通过UIApplication的sendEvent:方法将UIEvent传递给UIWindow.</p>
<h6 id="阶段2-Hit-Testing"><a href="#阶段2-Hit-Testing" class="headerlink" title="阶段2 Hit-Testing"></a><strong><strong>阶段2 Hit-Testing</strong></strong></h6><p>上一阶段UIWindow已经拿到了事件，但是面对着整个复杂的视图层级树，要先判断最先将事件最先传给谁（也就是判断first responder，当然first responder也可以我们直接指定），这就需要靠Hit-Testing来完成了，注意这里并未涉及到事件的处理，只是确定由哪个视图来首先处理 UITouch 事件。</p>
<p><img src="/2019/08/08/iOS-%E4%BA%8B%E4%BB%B6%E5%8F%8A%E6%89%8B%E5%8A%BF%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B/000001.png"></p>
<p>上图中左边是界面结构，右边是对应的视图层级树，其中View B的子View,View B.1遮住了View A的子View,View A2.我们假设点击了View B.1区域。<br>下面是整个Hit-Testing 的流程。</p>
<p><img src="/2019/08/08/iOS-%E4%BA%8B%E4%BB%B6%E5%8F%8A%E6%89%8B%E5%8A%BF%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B/000002.png"></p>
<p>首先UIWindow 会顺着层级树，到RootView,然后RootView有三个子View .由于三个子View的添加顺序为: A –&gt; B –&gt; C, 所以先从C开始，也就是从subViews的最后一个开始，从后往前进行遍历，为什么从后往前而不是从前往后是因为，在数组中所处的位置越后，在界面上所处的位置越上层，这是为了考虑视图遮挡的情况下先判断最上层的。View C调用hit test 判断不在它上面，所以转向B,hit-test测试在它上面，就继续遍历它的子view，子view的遍历过程也是从子view数组的最后一项，往前测试。在测试到View B.1的时候发现触点在它上面，并且它没有子View所以，到此位置终止测试。View B.1 作为Hit-testing最终的结果。 </p>
<p>上面只是展示了正常的Hit-Testing 的流程，实际上，View的一些属性还会影响到Hit-Testing的结果，比如如下的情况：</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line">视图的hidden等于 <span class="keyword">YES</span>。</span><br><span class="line">视图的alpha小于等于 <span class="number">0.01</span>。</span><br><span class="line">视图的userInteractionEnabled为 <span class="keyword">NO</span>。</span><br></pre></td></tr></table></figure>
<p>也就是当前待测试的视图不可见或者不处理交互，这些视图将会被忽略。因此整个hitTest的代码如下所示。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">UIView</span> *)hitTest:(<span class="built_in">CGPoint</span>)point withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">    <span class="comment">//如果当前视图不可见或者不接受事件，将传递给上层</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.alpha &lt;= <span class="number">0.01</span> || <span class="keyword">self</span>.userInteractionEnabled == <span class="literal">NO</span> || <span class="keyword">self</span>.hidden) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断触点是否在当前视图内部</span></span><br><span class="line">    <span class="type">BOOL</span> inside = [<span class="keyword">self</span> pointInside:point withEvent:event];</span><br><span class="line">    <span class="keyword">if</span> (inside) &#123;</span><br><span class="line">        <span class="comment">//如果在的话判断子view</span></span><br><span class="line">        <span class="built_in">NSArray</span> *subViews = <span class="keyword">self</span>.subviews;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = subViews.count - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="built_in">UIView</span> *subView = subViews[i];</span><br><span class="line">            <span class="comment">//将point转换到subView视图上的坐标递归调用子view的hitTest</span></span><br><span class="line">            <span class="built_in">CGPoint</span> insidePoint = [<span class="keyword">self</span> convertPoint:point toView:subView];</span><br><span class="line">            <span class="built_in">UIView</span> *hitView = [subView hitTest:insidePoint withEvent:event];</span><br><span class="line">            <span class="keyword">if</span> (hitView) &#123;</span><br><span class="line">                <span class="keyword">return</span> hitView;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面需要重点看下这个阶段的两个重要方法：</p>
<figure class="highlight erlang"><table><tr><td class="code"><pre><span class="line">- <span class="params">(UIView *)</span>hitTest:<span class="params">(CGPoint)</span>point withEvent:<span class="params">(UIEvent *)</span>event;</span><br><span class="line">- <span class="params">(BOOL)</span>pointInside:<span class="params">(CGPoint)</span>point withEvent:<span class="params">(UIEvent *)</span>event;</span><br></pre></td></tr></table></figure>

<p>hitTest 返回的是包含触点的最适合的子view，如果hitTest:withEvent:方法中返回nil，那么调用该方法的控件本身和其子控件都不是最合适的view，也就是在自己身上没有找到更合适的view。如果同级的兄弟控件也没有合适的view，那么最合适的view就是该控件的父控件。</p>
<p>想让谁成为最合适的view就重写谁自己的父控件的hitTest:withEvent:方法返回指定的子控件，或者重写自己的hitTest:withEvent:方法 return self。但是，建议在父控件的hitTest:withEvent:中返回子控件作为最合适的view！因为有可能在还没遍历到返回self的那个view的时候就已经拿到触点的的view。</p>
<p>pointInside很好理解就是判断点是否在当前view上面，如果是返回YES,否则返回NO.这里需要注意的是，point 必须先转换为相对当前view的坐标系坐标。</p>
<ul>
<li><strong><strong>Hit-Testing 的应用</strong></strong></li>
</ul>
<ol>
<li><strong><strong>增加视图的touch区域</strong></strong></li>
</ol>
<p>这里可以通过两种方式都可以实现：</p>
<p>一种是通过重写hitTest,一种是通过重写pointInside</p>
<p>重写hitTest</p>
 <figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"> - (<span class="built_in">UIView</span> *)hitTest:(<span class="built_in">CGPoint</span>)point withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>.isUserInteractionEnabled || <span class="keyword">self</span>.isHidden || <span class="keyword">self</span>.alpha &lt;= <span class="number">0.01</span>) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGFloat</span> inset = <span class="number">45.0</span>f - <span class="number">78.0</span>f;</span><br><span class="line">    <span class="built_in">CGRect</span> touchRect = <span class="built_in">CGRectInset</span>(<span class="keyword">self</span>.bounds, inset, inset);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">CGRectContainsPoint</span>(touchRect, point)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">UIView</span> *subview <span class="keyword">in</span> [<span class="keyword">self</span>.subviews reverseObjectEnumerator]) &#123;</span><br><span class="line">            <span class="built_in">CGPoint</span> convertedPoint = [subview convertPoint:point fromView:<span class="keyword">self</span>];</span><br><span class="line">            <span class="built_in">UIView</span> *hitTestView = [subview hitTest:convertedPoint withEvent:event];</span><br><span class="line">            <span class="keyword">if</span> (hitTestView) &#123;</span><br><span class="line">                <span class="keyword">return</span> hitTestView;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 重写pointInside</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent*)event &#123;</span><br><span class="line">    CGRect bounds = self.bounds;</span><br><span class="line">    CGFloat widthDelta = <span class="constructor">MAX(<span class="params">self</span>.<span class="params">focusSize</span> - <span class="params">bounds</span>.<span class="params">size</span>.<span class="params">width</span>, 0)</span>;</span><br><span class="line">    CGFloat heightDelta = <span class="constructor">MAX(<span class="params">self</span>.<span class="params">focusSize</span> - <span class="params">bounds</span>.<span class="params">size</span>.<span class="params">height</span>, 0)</span>;</span><br><span class="line">    bounds = <span class="constructor">CGRectInset(<span class="params">bounds</span>, -0.5 <span class="operator">*</span> <span class="params">widthDelta</span>, -0.5 <span class="operator">*</span> <span class="params">heightDelta</span>)</span>;</span><br><span class="line">    return <span class="constructor">CGRectContainsPoint(<span class="params">bounds</span>, <span class="params">point</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong><strong>透传事件</strong></strong></li>
</ol>
<p>当时想在当前 view 处理事件，不想在对 subview 进行遍历，可以直接重写 [hitTest:withEvent:] 方法并 return self 即可。</p>
<ol start="3">
<li><strong><strong>指定某个视图处理事件</strong></strong></li>
</ol>
<p>重写父视图的[hitTest:withEvent:]，指定响应 View。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">UIView</span> *)hitTest:(<span class="built_in">CGPoint</span>)point withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">    <span class="built_in">UIView</span> *hitTestView = [<span class="variable language_">super</span> hitTest:point withEvent:event];</span><br><span class="line">    <span class="keyword">if</span> (hitTestView) &#123;</span><br><span class="line">        hitTestView = <span class="keyword">self</span>.scrollView;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hitTestView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="阶段3-事件的响应"><a href="#阶段3-事件的响应" class="headerlink" title="阶段3 事件的响应"></a><strong><strong>阶段3 事件的响应</strong></strong></h6><p>Touch 事件处理的传递过程与 Hit-Testing 过程正好相反。Hit-Tesing 过程是从父视图到子视图遍历；Touch 事件处理传递是从子视图到父视图传递。<br>首先Touch事件会被发送到first responder，first responder便拥有了对事件的绝对控制权：它可以选择独吞这个事件，也可以将这个事件往下传递给其他响应者.</p>
<p>整个过程如下所示：</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="bullet">* </span>如果当前view是控制器的RootView，那么控制器就是nextResponder，事件就传递给控制器.</span><br><span class="line"><span class="bullet">* </span>如果当前view不是控制器的RootView，那么父视图就是当前view的nextResponder，事件就传递给它的父视图.</span><br><span class="line"><span class="bullet">* </span>在视图层次结构的最顶级视图，如果也不能处理收到的事件或消息，则其将事件或消息传递给window对象进行处理.</span><br><span class="line"><span class="bullet">* </span>如果window对象也不处理，则其将事件或消息传递给UIApplication对象.</span><br><span class="line"><span class="bullet">* </span>如果UIApplication也不能处理该事件或消息，则将其丢弃</span><br></pre></td></tr></table></figure>

<p>响应者对于接收到的事件有3种操作：</p>
<ul>
<li>不拦截  :事件会自动沿着默认的响应链往下传递</li>
<li>拦截，不再往下分发事件 :重写 touchesBegan:withEvent: 进行事件处理，不调用父类的 touchesBegan:withEvent:</li>
<li>拦截，继续往下分发事件 :重写 touchesBegan:withEvent: 进行事件处理，同时调用父类的 touchesBegan:withEvent: 将事件往下传递</li>
</ul>
<p><img src="/2019/08/08/iOS-%E4%BA%8B%E4%BB%B6%E5%8F%8A%E6%89%8B%E5%8A%BF%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B/000005.png"></p>
<p>这里还需要注意的一点是如果我们的View有关联的手势识别器，那么在将touches发送给发生触摸的视图本身前，会先将touches发送给发生触摸的视图所关联的手势识别器，这部分内容将在下面讲手势的时候介绍。<br><img src="/2019/08/08/iOS-%E4%BA%8B%E4%BB%B6%E5%8F%8A%E6%89%8B%E5%8A%BF%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B/000004.png"></p>
<p>触摸事件经历上面各个环节后要么被某个响应对象捕获后释放，要么没能找到能够响应的对象被丢弃。整个触摸事件就结束了。Runloop若没有其他事件需要处理，也将重新进入休眠，等待新的事件到来后唤醒。</p>
<h5 id="手势"><a href="#手势" class="headerlink" title="手势"></a><strong><strong>手势</strong></strong></h5><p>上面介绍了iOS的事件体系，紧接着讲下和事件相关的手势交互，iOS中的手势都是继承自UIGestureRecognizer，系统为了方便大家使用也内置了一系列的手势，下面是目前支持的几种手势，如果不够使用还可以通过继承UIGestureRecognizer来自定义手势。</p>
<table>
<thead>
<tr>
<th>手势</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>UITapGestureRecognizer</td>
<td>轻拍手势</td>
</tr>
<tr>
<td>UISwipeGestureRecognizer</td>
<td>轻扫手势</td>
</tr>
<tr>
<td>UILongPressGestureRecognizer</td>
<td>长按手势</td>
</tr>
<tr>
<td>UIPanGestureRecognizer</td>
<td>平移手势</td>
</tr>
<tr>
<td>UIPinchGestureRecognizer</td>
<td>捏合（缩放）手势</td>
</tr>
<tr>
<td>UIRotationGestureRecognizer</td>
<td>旋转手势</td>
</tr>
<tr>
<td>UIScreenEdgePanGestureRecognizer</td>
<td>屏幕边缘平移</td>
</tr>
</tbody></table>
<h6 id="常用属性和方法"><a href="#常用属性和方法" class="headerlink" title="常用属性和方法"></a><strong><strong>常用属性和方法</strong></strong></h6><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置代理，具体的协议后面会说</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nullable</span>,<span class="keyword">nonatomic</span>,<span class="keyword">weak</span>) <span class="type">id</span> &lt;<span class="built_in">UIGestureRecognizerDelegate</span>&gt; delegate; </span><br><span class="line"><span class="comment">//设置手势是否有效</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">getter</span>=isEnabled) <span class="type">BOOL</span> enabled;</span><br><span class="line"><span class="comment">//获取手势所在的view</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>,<span class="keyword">readonly</span>) <span class="built_in">UIView</span> *view; </span><br><span class="line"><span class="comment">//获取触发触摸的点</span></span><br><span class="line">- (<span class="built_in">CGPoint</span>)locationInView:(<span class="keyword">nullable</span> <span class="built_in">UIView</span>*)view; </span><br><span class="line"><span class="comment">//设置触摸点数</span></span><br><span class="line">- (<span class="built_in">NSUInteger</span>)numberOfTouches; </span><br><span class="line"><span class="comment">//获取某一个触摸点的触摸位置</span></span><br><span class="line">- (<span class="built_in">CGPoint</span>)locationOfTouch:(<span class="built_in">NSUInteger</span>)touchIndex inView:(<span class="keyword">nullable</span> <span class="built_in">UIView</span>*)view;</span><br></pre></td></tr></table></figure>

<h6 id="手势的初始化"><a href="#手势的初始化" class="headerlink" title="手势的初始化"></a><strong><strong>手势的初始化</strong></strong></h6><p>各种手势都是通过initWithTarget：action进行初始化的</p>
<figure class="highlight elm"><table><tr><td class="code"><pre><span class="line">- (instance<span class="keyword">type</span>)initWithTarget:(nullable id)target action:(nullable <span class="type">SEL</span>)action;</span><br></pre></td></tr></table></figure>

<p>还可以通过removeTarget：action将一个selector从手势对象上移除</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">void</span>)removeTarget:(<span class="literal">null</span>able id)target action:(<span class="literal">null</span>able SEL)action;</span><br></pre></td></tr></table></figure>

<p>iOS系统允许一个手势对象可以添加多个selector触发方法，并且触发的时候，所有添加的selector都会被执行</p>
<figure class="highlight erlang"><table><tr><td class="code"><pre><span class="line">- <span class="params">(void)</span>addTarget:<span class="params">(id)</span>target action:<span class="params">(SEL)</span>action;</span><br></pre></td></tr></table></figure>

<p>这里需要注意的是UIGestureRecognizerSubclass.h头文件中定义了一个UIGestureRecognizer分类UIGestureRecognizerProtected，它里面也定义了一系列和UIResponder一样的方法，<br>可以供我们覆写以实现自定义效果。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="operator">-</span> (void)touchesBegan:(<span class="type">NSSet</span>&lt;<span class="type">UITouch</span> *&gt; <span class="operator">*</span>)touches withEvent:(<span class="type">UIEvent</span> <span class="operator">*</span>)event;</span><br><span class="line"><span class="operator">-</span> (void)touchesMoved:(<span class="type">NSSet</span>&lt;<span class="type">UITouch</span> *&gt; <span class="operator">*</span>)touches withEvent:(<span class="type">UIEvent</span> <span class="operator">*</span>)event;</span><br><span class="line"><span class="operator">-</span> (void)touchesEnded:(<span class="type">NSSet</span>&lt;<span class="type">UITouch</span> *&gt; <span class="operator">*</span>)touches withEvent:(<span class="type">UIEvent</span> <span class="operator">*</span>)event;</span><br><span class="line"><span class="operator">-</span> (void)touchesCancelled:(<span class="type">NSSet</span>&lt;<span class="type">UITouch</span> *&gt; <span class="operator">*</span>)touches withEvent:(<span class="type">UIEvent</span> <span class="operator">*</span>)event;</span><br><span class="line"><span class="operator">-</span> (void)touchesEstimatedPropertiesUpdated:(<span class="type">NSSet</span>&lt;<span class="type">UITouch</span> *&gt; <span class="operator">*</span>)touches <span class="type">NS_AVAILABLE_IOS</span>(<span class="number">9_1</span>);</span><br><span class="line"></span><br><span class="line"><span class="operator">-</span> (void)pressesBegan:(<span class="type">NSSet</span>&lt;<span class="type">UIPress</span> *&gt; <span class="operator">*</span>)presses withEvent:(<span class="type">UIPressesEvent</span> <span class="operator">*</span>)event <span class="type">NS_AVAILABLE_IOS</span>(<span class="number">9_0</span>);</span><br><span class="line"><span class="operator">-</span> (void)pressesChanged:(<span class="type">NSSet</span>&lt;<span class="type">UIPress</span> *&gt; <span class="operator">*</span>)presses withEvent:(<span class="type">UIPressesEvent</span> <span class="operator">*</span>)event <span class="type">NS_AVAILABLE_IOS</span>(<span class="number">9_0</span>);</span><br><span class="line"><span class="operator">-</span> (void)pressesEnded:(<span class="type">NSSet</span>&lt;<span class="type">UIPress</span> *&gt; <span class="operator">*</span>)presses withEvent:(<span class="type">UIPressesEvent</span> <span class="operator">*</span>)event <span class="type">NS_AVAILABLE_IOS</span>(<span class="number">9_0</span>);</span><br><span class="line"><span class="operator">-</span> (void)pressesCancelled:(<span class="type">NSSet</span>&lt;<span class="type">UIPress</span> *&gt; <span class="operator">*</span>)presses withEvent:(<span class="type">UIPressesEvent</span> <span class="operator">*</span>)event <span class="type">NS_AVAILABLE_IOS</span>(<span class="number">9_0</span>);</span><br></pre></td></tr></table></figure>

<h6 id="手势代理"><a href="#手势代理" class="headerlink" title="手势代理"></a><strong><strong>手势代理</strong></strong></h6><p>手势有其对应的代理UIGestureRecognizerDelegate 通过它可以指定很多特性，下面将对这些特性进行一一介绍：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">UIGestureRecognizerDelegate</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"><span class="keyword">@optional</span></span><br><span class="line">- (<span class="type">BOOL</span>)gestureRecognizerShouldBegin:(<span class="built_in">UIGestureRecognizer</span> *)gestureRecognizer;</span><br><span class="line">- (<span class="type">BOOL</span>)gestureRecognizer:(<span class="built_in">UIGestureRecognizer</span> *)gestureRecognizer shouldRecognizeSimultaneouslyWithGestureRecognizer:(<span class="built_in">UIGestureRecognizer</span> *)otherGestureRecognizer;</span><br><span class="line">- (<span class="type">BOOL</span>)gestureRecognizer:(<span class="built_in">UIGestureRecognizer</span> *)gestureRecognizer shouldRequireFailureOfGestureRecognizer:(<span class="built_in">UIGestureRecognizer</span> *)otherGestureRecognizer;</span><br><span class="line">- (<span class="type">BOOL</span>)gestureRecognizer:(<span class="built_in">UIGestureRecognizer</span> *)gestureRecognizer shouldBeRequiredToFailByGestureRecognizer:(<span class="built_in">UIGestureRecognizer</span> *)otherGestureRecognizer;</span><br><span class="line">- (<span class="type">BOOL</span>)gestureRecognizer:(<span class="built_in">UIGestureRecognizer</span> *)gestureRecognizer shouldReceiveTouch:(<span class="built_in">UITouch</span> *)touch;</span><br><span class="line">- (<span class="type">BOOL</span>)gestureRecognizer:(<span class="built_in">UIGestureRecognizer</span> *)gestureRecognizer shouldReceivePress:(<span class="built_in">UIPress</span> *)press;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<figure class="highlight erlang"><table><tr><td class="code"><pre><span class="line">- <span class="params">(BOOL)</span>gestureRecognizerShouldBegin:<span class="params">(UIGestureRecognizer *)</span>gestureRecognizer;</span><br></pre></td></tr></table></figure>
<p>开始进行手势识别时调用的方法,当手势识别器识别到手势,准备从UIGestureRecognizerStatePossible状态开始转换时.调用此代理,如果返回YES,那么就继续识别,如果返回NO,那么手势识别器将会将状态置为UIGestureRecognizerStateFailed.</p>
<figure class="highlight erlang"><table><tr><td class="code"><pre><span class="line">- <span class="params">(BOOL)</span>gestureRecognizer:<span class="params">(UIGestureRecognizer *)</span>gestureRecognizer shouldReceiveTouch:<span class="params">(UITouch *)</span>touch</span><br></pre></td></tr></table></figure>
<p>手指触摸屏幕后回调的方法，返回NO则不再进行手势识别，方法触发此方法在window对象在有触摸事件发生时，调用gesture recognizer的touchesBegan:withEvent:方法之前调用，如果返回NO,则gesture recognizer不会看到此触摸事件。(默认情况下为YES)</p>
<figure class="highlight erlang"><table><tr><td class="code"><pre><span class="line">- <span class="params">(BOOL)</span>gestureRecognizer:<span class="params">(UIGestureRecognizer *)</span>gestureRecognizer shouldReceivePress:<span class="params">(UIPress *)</span>press;</span><br></pre></td></tr></table></figure>
<p>手指按压屏幕后回调的方法，返回NO则不再进行手势识别，方法触发等</p>
<figure class="highlight erlang"><table><tr><td class="code"><pre><span class="line">- <span class="params">(BOOL)</span>gestureRecognizer:<span class="params">(UIGestureRecognizer *)</span>gestureRecognizer shouldRecognizeSimultaneouslyWithGestureRecognizer:<span class="params">(UIGestureRecognizer *)</span>otherGestureRecognizer;</span><br></pre></td></tr></table></figure>
<p>是否支持多手势触发，返回YES，则可以多个手势一起触发方法，返回NO则为互斥.</p>
<figure class="highlight erlang"><table><tr><td class="code"><pre><span class="line">- <span class="params">(BOOL)</span>gestureRecognizer:<span class="params">(UIGestureRecognizer *)</span>gestureRecognizer shouldRequireFailureOfGestureRecognizer:<span class="params">(UIGestureRecognizer *)</span>otherGestureRecognizer;</span><br></pre></td></tr></table></figure>
<p>这个方法返回YES，第一个手势和第二个互斥时，第一个会失效</p>
<figure class="highlight erlang"><table><tr><td class="code"><pre><span class="line">- <span class="params">(BOOL)</span>gestureRecognizer:<span class="params">(UIGestureRecognizer *)</span>gestureRecognizer shouldBeRequiredToFailByGestureRecognizer:<span class="params">(UIGestureRecognizer *)</span>otherGestureRecognizer;</span><br></pre></td></tr></table></figure>
<p>这个方法返回YES，第一个和第二个互斥时，第二个会失效 </p>
<h6 id="手势状态"><a href="#手势状态" class="headerlink" title="手势状态"></a><strong><strong>手势状态</strong></strong></h6><p>和其他事件一样手势也是有个状态机，它用一个state属性描述。</p>
<figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">@property(nonatomic,readonly) UIGestureRecognizerState <span class="keyword">state</span>;</span><br></pre></td></tr></table></figure>

<p>它的描述值如下：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, <span class="built_in">UIGestureRecognizerState</span>) &#123;</span><br><span class="line">    <span class="built_in">UIGestureRecognizerStatePossible</span>,   <span class="comment">// 默认的状态，这个时候的手势并没有具体的情形状态</span></span><br><span class="line">    <span class="built_in">UIGestureRecognizerStateBegan</span>,      <span class="comment">// 手势开始被识别的状态</span></span><br><span class="line">    <span class="built_in">UIGestureRecognizerStateChanged</span>,    <span class="comment">// 手势识别发生改变的状态</span></span><br><span class="line">    <span class="built_in">UIGestureRecognizerStateEnded</span>,      <span class="comment">// 手势识别结束，将会执行触发的方法</span></span><br><span class="line">    <span class="built_in">UIGestureRecognizerStateCancelled</span>,  <span class="comment">// 手势识别取消</span></span><br><span class="line">    <span class="built_in">UIGestureRecognizerStateFailed</span>,     <span class="comment">// 识别失败，方法将不会被调用</span></span><br><span class="line">    <span class="built_in">UIGestureRecognizerStateRecognized</span> = <span class="built_in">UIGestureRecognizerStateEnded</span> </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/08/08/iOS-%E4%BA%8B%E4%BB%B6%E5%8F%8A%E6%89%8B%E5%8A%BF%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B/000006.png"></p>
<p>左侧是非连续手势(比如单击)的状态机，右侧是连续手势(比如滑动)的状态机。所有的手势的开始状态都是UIGestureRecognizerStatePossible。<br>非连续的手势要么识别成功(UIGestureRecognizerStateRecognized)，要么识别失败(UIGestureRecognizerStateFailed)。<br>连续的手势识别到第一个手势时，变成UIGestureRecognizerStateBegan，然后变成UIGestureRecognizerStateChanged，并且不断地在这个状态下循环，当用户最后一个手指离开view时，变成UIGestureRecognizerStateEnded，当然如果手势不再符合它的模式的时候，状态也可能变成UIGestureRecognizerStateCancelled。</p>
<h6 id="手势与事件处理"><a href="#手势与事件处理" class="headerlink" title="手势与事件处理"></a><strong><strong>手势与事件处理</strong></strong></h6><p>我们前面讲到了当一个view有关联手势的时候，手势的优先级会比事件来的高，因此在我们触摸带手势的view的时候，如果先被手势识别器识别了，事件就不会传递给view 的UIResponder进行处理，但是我们知道手势是有状态的，也就是说手势识别是有一个过程的，因此在手势未被完全识别之前，事件是会被同时发送到UIResponder，以及UIGestureRecognizer，一旦手势识别器识别了某个手势之后，UIResponder就会的touchesCancelled:withEvent就会被调用，此后的事件都被UIGestureRecognizer独占，也就是只发往UIGestureRecognizer。如果识别失败手势状态将会被识别为UIGestureRecognizerStateFailed，这时候事件会继续发送给UIResponder，直到结束。</p>
<p>简单得说就是，在手势识别器未判定手势识别成功之前，事件会发给手势识别器和UIResponder,一旦手势识别器判定为识别成功就拦截了整个事件，UIResponder会收到cancel的信号，后续就不会继续收到对应的事件了，所有的后续事件都交给手势识别器进行处理。<br>同样在手势识别器未判定手势识别成功之前，事件会发给手势识别器和UIResponder,如果手势识别器识别失败，那么就会被标记为UIGestureRecognizerStateFailed，然后后续的事件都交给UIResponder进行处理。</p>
<ul>
<li>cancelsTouchesInView</li>
</ul>
<p>默认为YES。表示当手势识别器成功识别了手势之后，会通知Application取消响应链对事件的响应，并不再传递事件给UIResponder。若设置成NO，表示手势识别成功后不取消响应链对事件的响应，事件依旧会传递给UIResponder。</p>
<h6 id="手势其他用法"><a href="#手势其他用法" class="headerlink" title="手势其他用法"></a><strong><strong>手势其他用法</strong></strong></h6><p>我们添加的两个手势都是单击手势，会产生冲突，触发是很随机的，如果我们想设置一下当手势互斥时要优先触发的手势，可以使用如下的方法：</p>
<pre><code>- (void)requireGestureRecognizerToFail:(UIGestureRecognizer *)otherGestureRecognizer;
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">比如我们在秀场直播间，双击屏幕会产生关注，如果单击屏幕会有点赞效果,就可以通过这种方式解决。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
// 单击的 Recognizer
UITapGestureRecognizer* singleRecognizer;
singleRecognizer = [[UITapGestureRecognizer alloc] initWithTarget:selfaction:@selector(handleSingleTapFrom)];
singleTapRecognizer.numberOfTapsRequired = 1; // 单击
[self.view addGestureRecognizer:singleRecognizer];

// 双击的 Recognizer
UITapGestureRecognizer* double;
doubleRecognizer = [[UITapGestureRecognizer alloc] initWithTarget:selfaction:@selector(handleDoubleTapFrom)];
doubleTapRecognizer.numberOfTapsRequired = 2; // 双击
[self.view addGestureRecognizer:doubleRecognizer];

// 如果双击确定检测失败才会触发单击
[singleRecognizer requireGestureRecognizerToFail:doubleRecognizer];
[singleRecognizer release];
[doubleRecognizer release];
```


老规矩上图

![](./iOS-事件及手势处理流程/000007.png)







</code></pre>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/iOS-%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/">iOS 理论基础</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/iOS-理论基础/">iOS 理论基础</a>
  </div>

</div>



<div class="comments-count">
	
	  	<span></span>
		<a href="/2019/08/08/iOS-事件及手势处理流程/#comments" class="ds-thread-count comments-count-link" data-thread-key="2019/08/08/iOS-事件及手势处理流程/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/08/06/Core-graphic-使用/" title="Core Graphic" itemprop="url">Core Graphic</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Edgar" target="_blank" itemprop="author">Edgar</a>
		
  <p class="article-time">
    <time datetime="2019-08-05T17:28:51.000Z" itemprop="datePublished"> Published 2019-08-06</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h5 id="1-开篇叨叨"><a href="#1-开篇叨叨" class="headerlink" title="1. 开篇叨叨"></a><strong><strong>1. 开篇叨叨</strong></strong></h5><p>能不叨叨就不叨叨。</p>
<h5 id="2-什么时候会触发视图绘制"><a href="#2-什么时候会触发视图绘制" class="headerlink" title="2. 什么时候会触发视图绘制"></a><strong><strong>2. 什么时候会触发视图绘制</strong></strong></h5><figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="bullet">* </span>调用setNeedsDisplay/setNeedsDisplayInRect </span><br><span class="line"><span class="bullet">* </span>遮挡当前视图的其他视图被移动或删除时</span><br><span class="line"><span class="bullet">* </span>设置视图的hidden属性，改变视图的显示状态</span><br><span class="line"><span class="bullet">* </span>视图滚出屏幕，然后再重新回到屏幕上</span><br></pre></td></tr></table></figure>

<p>其实可以推断后面的几项实际上也是通过调用setNeedsDisplay&#x2F;setNeedsDisplayInRect来标记当前控件需要重新绘制。<br>这部分工作是在CPU中完成的，因此速度不如GPU绘制的效率高，因此尽可能避免使用绘制，多使用现有的控件组合来达到需求。</p>
<h5 id="2-Core-Graphic-简介"><a href="#2-Core-Graphic-简介" class="headerlink" title="2. Core Graphic 简介"></a><strong><strong>2. Core Graphic 简介</strong></strong></h5><p>iOS支持两套图形API族：Core Graphics和OpenGL ES，而Core Graphics 是一套基于C的API框架，使用了Quartz作为绘图引擎, 和Open GL不同的是Core Graphics使用的是CPU进行绘制Open GL使用GPU进行绘制，使用Core Graphics 绘制一个图形一般是遵循以下步骤：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1.</span> 创建/获取上下文</span><br><span class="line"><span class="bullet">2.</span> 创建路径并添加到上下文中。</span><br><span class="line"><span class="bullet">3.</span> 进行绘图内容的设置（画笔颜色、粗细、填充区域颜色、阴影、连接点形状等）</span><br><span class="line"><span class="bullet">4.</span> 开始绘图</span><br><span class="line"><span class="bullet">5.</span> 释放路径</span><br></pre></td></tr></table></figure>

<p>这里需要注意的是Core Graphics中带有Ref后缀的类，其实例对象可能有指向其他 Core Graphics “对象”的强引用指针，但是不能被ARC管理，所以创建了这些对象，使用完之后记得手动释放，否则会有内存泄漏的问题。并且但凡名字中带有create 或者 copy 的函数创建了一个 Core Graphics “对象”，就必须调用对应的Release函数并传入该对象的指针将其释放，这是刚开始的时候很容易犯的错误。</p>
<p>从上面的过程来看，这部分总共有三个部分需要重点掌握：</p>
<p>一个是绘制上下文，也就是绘制的内容绘制到哪里？如何屏蔽多个环境之间的差异。<br>一个是绘制坐标系统，也就是我们怎么定义绘制的位置和长度的概念，<br>另一个就是Core Graphic API,也就是Core Graphic能够支持哪些绘制方法。</p>
<h5 id="3-绘图上下文"><a href="#3-绘图上下文" class="headerlink" title="3. 绘图上下文"></a><strong><strong>3. 绘图上下文</strong></strong></h5><p>我们绘图的时候是需要一个载体或者说输出目标用来显示绘图信息，并且决定绘制的东西输出到哪个地方，Core Graphics框架就使用图形上下文来描述这个载体，这些上下文以堆栈形式存放，我们绘制的时候都是往栈顶的图形上下文上绘制，每个图形上下文包括画笔颜色、文本颜色、当前字体、变形，以及绘制内容所存储的位置等。之所以需要使用Context是因为Core Graphics可以在多种设备上绘制，比如在手机屏幕上，这也是最为常见的，再必须还可以在PDF上绘制，也可以再图片上进行绘制，每种设备上都存在很大的差异，Core Graphics 使用Context将这部分差异给隔离开来。让绘制内容与绘制步骤与设备无关。</p>
<p>Core Graphics 目前支持如下几种绘图上下文：</p>
<figure class="highlight mathematica"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="variable">Bitmap</span> <span class="built_in">Graphics</span> <span class="built_in">Context</span><span class="operator">:</span> 将<span class="variable">RGB</span>图像或者黑白图像绘制到一个位图对象中<span class="operator">.</span></span><br><span class="line"><span class="number">2.</span> <span class="built_in">PDF</span> <span class="built_in">Graphics</span> <span class="built_in">Context</span><span class="operator">:</span> <span class="built_in">PDF</span>图形上下文可以帮助开发者创建<span class="built_in">PDF</span>文件，将内容绘制进<span class="built_in">PDF</span>文件中<span class="operator">.</span></span><br><span class="line"><span class="number">3.</span> <span class="variable">Window</span> <span class="built_in">Graphics</span> <span class="built_in">Context</span><span class="operator">:</span> 用于将内容绘制到<span class="variable">OS</span>系统中的窗口上</span><br><span class="line"><span class="number">4.</span> <span class="variable">Layer</span> <span class="built_in">Context</span><span class="operator">:</span> 用于将内容绘制在<span class="variable">Layer</span>图层上</span><br><span class="line"><span class="number">5.</span> <span class="variable">Printer</span> <span class="built_in">Graphics</span> <span class="built_in">Context</span><span class="operator">:</span> 用于将内容绘制在打印输出源上</span><br></pre></td></tr></table></figure>

<p><img src="/2019/08/06/Core-graphic-%E4%BD%BF%E7%94%A8/00001.png"></p>
<h6 id="CGContextSaveGState-x2F-CGContextRestoreGState-与-UIGraphicsPushContext-x2F-UIGraphicsPopContext区别"><a href="#CGContextSaveGState-x2F-CGContextRestoreGState-与-UIGraphicsPushContext-x2F-UIGraphicsPopContext区别" class="headerlink" title="* CGContextSaveGState&#x2F;CGContextRestoreGState 与 UIGraphicsPushContext&#x2F;UIGraphicsPopContext区别"></a>* <strong><strong>CGContextSaveGState&#x2F;CGContextRestoreGState 与 UIGraphicsPushContext&#x2F;UIGraphicsPopContext区别</strong></strong></h6><p>想象一个场景，比如我们现在需要修改上下文并使其恢复原样。举个例子，我们现在有一个使用特定颜色绘制特定形状的函数。由于只能有一只画笔，因此在更改颜色后，就会影响调用函数的结果。为了避免这个副作用，你可以使用CGContextSaveGState和CGContextRestoreGState将上下文入栈和出栈。下面是一个很有说服力的例子：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">[[<span class="built_in">UIColor</span> redColor] setStroke];                         <span class="comment">//将线条颜色设置为红色</span></span><br><span class="line"><span class="built_in">CGContextSaveGState</span>(<span class="built_in">UIGraphicsGetCurrentContext</span>());     <span class="comment">//将带有红色线条颜色的上下文保存到上下文的状态堆栈</span></span><br><span class="line">[[<span class="built_in">UIColor</span> blackColor] setStroke];                       <span class="comment">//将当前上下文堆栈中的线条颜色设置为黑色</span></span><br><span class="line"><span class="built_in">CGContextRestoreGState</span>(<span class="built_in">UIGraphicsGetCurrentContext</span>());  <span class="comment">//恢复上一次保留的堆栈节点</span></span><br><span class="line"><span class="built_in">UIRectFill</span>(<span class="built_in">CGRectMake</span>(<span class="number">10</span>, <span class="number">10</span>, <span class="number">100</span>, <span class="number">100</span>));               <span class="comment">//这时候绘制的是红色的线条</span></span><br></pre></td></tr></table></figure>
<p>UIGraphicsPushContext并不能保存上下文的当前状态，而是完全切换上下文。假设你正在当前<strong>视图</strong>上下文中绘制什么东西，这时想要在<strong>位图</strong>上下文中绘制完全不同的东西。如果要使用UIKit来进行任意绘图，你会希望保存当前的UIKit上下文，包括所有已经绘制的内容，接着切换到一个全新的绘图上下文中。这就是UIGraphicsPushContext的功能。创建完位图后，再调用UIGraphicsPopContext将你的旧上下文出栈。这种情况很少见只会在要使用UIKit在新的位图上下文中绘图时才会发生。只要你使用的是Core Graphics函数，就不需要去执行上下文入栈和出栈，因为Core Graphics函数将上下文视作参数。<br>这是极其有用的常见操作，因为其常用性，苹果公司为我们创建了一个叫做UIGraphicsBeginImageContext的快捷方式。它负责将旧的上下文入栈、为新上下文分配内存、创建新的上下文、翻转坐标系统，并使其作为当前上下文使用。它替你完成了大部分的工作。</p>
<p>下图是Graphics Context与Graphics state的大致结构</p>
<p><img src="/2019/08/06/Core-graphic-%E4%BD%BF%E7%94%A8/00002.png"></p>
<h5 id="4-具体绘图方法"><a href="#4-具体绘图方法" class="headerlink" title="4. 具体绘图方法"></a><strong><strong>4. 具体绘图方法</strong></strong></h5><h6 id="4-1-位图图片上下文"><a href="#4-1-位图图片上下文" class="headerlink" title="4.1 位图图片上下文"></a><strong><strong>4.1 位图图片上下文</strong></strong></h6><p>位图上下文的绘制不需要在drawRect:方法中进行，在一个普通的OC方法中就可以绘制。</p>
<p>关于UIGraphicsPushContext&#x2F;UIGraphicsPopContext 与 UIGraphicsBeginImageContextWithOptions的区别用两个场景再说明：<br>当前正在使用CoreGraphics绘制图形A，想要使用UIKit绘制完全不同的图形B，此时希望保存当前绘图context及已绘制内容这时候需要用到UIGraphicsPushContext&#x2F;UIGraphicsPopContext。<br>如果想在切换绘图context后，继续使用CoreGraphics绘图（而非UIKit），则不需要使用UIGraphicsPushContext&#x2F;UIGraphicsPopContext。</p>
<p>位图上下文可以通过如下两种方式创建：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UIGraphicsBeginImageContextWithOptions</span>(<span class="built_in">CGSize</span> size, <span class="type">BOOL</span> opaque, <span class="built_in">CGFloat</span> scale);</span><br><span class="line">这里需要注意的是scale可以用[<span class="built_in">UIScreen</span> mainScreen].scale来获取，但实际上设为<span class="number">0</span>后，系统就会自动设置正确的比例了。</span><br></pre></td></tr></table></figure>

<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UIGraphicsBeginImageContext</span>(<span class="built_in">CGSize</span> size);</span><br><span class="line">相当于<span class="built_in">UIGraphicsBeginImageContextWithOptions</span>的opaque参数为<span class="literal">NO</span>,scale因子为<span class="number">1.0</span></span><br></pre></td></tr></table></figure>

<p>一般推荐使用第一种方式来创建，第一种方式除了可以指定图片的大小外，还可以指定图片是否透明，以及图片的scale。需要注意的是上面两种方式都会在创建一个基于位图的上下文,并将其设置为当前上下文，所以后续操作如果需要使用到上下文对象就可以通过UIGraphicsGetCurrentContext来获取。</p>
<p>一般使用步骤如下：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取图片</span></span><br><span class="line"><span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageWithContentsOfFile:[[<span class="built_in">NSBundle</span> mainBundle] pathForResource:name ofType:<span class="literal">nil</span>]];</span><br><span class="line"><span class="comment">// 1.开启图形上下文，并将ImageContext放置到栈顶</span></span><br><span class="line"><span class="built_in">UIGraphicsBeginImageContext</span>(image.size);</span><br><span class="line"><span class="comment">// 2.获取到当前栈顶的图形上下文</span></span><br><span class="line"><span class="built_in">CGContextRef</span> context = <span class="built_in">UIGraphicsGetCurrentContext</span>();</span><br><span class="line"><span class="comment">// 3. 使用Core Graphics API 在当前上下文中绘制</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ........</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.从上下文中获取图片</span></span><br><span class="line"><span class="built_in">UIImage</span> *newImage = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</span><br><span class="line"><span class="comment">// 5.关闭图形上下文</span></span><br><span class="line"><span class="built_in">UIGraphicsEndImageContext</span>();</span><br><span class="line"><span class="comment">//返回图片</span></span><br><span class="line"><span class="keyword">return</span> newImage;</span><br></pre></td></tr></table></figure>

<p>下面分别使用UIKit和CoreGraphics实现的一个例子：</p>
<p>使用UIKit实现</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取图片上下文</span></span><br><span class="line"><span class="built_in">UIGraphicsBeginImageContextWithOptions</span>(<span class="built_in">CGSizeMake</span>(<span class="number">100</span>,<span class="number">100</span>), <span class="literal">NO</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 绘图</span></span><br><span class="line"><span class="built_in">UIBezierPath</span>* p = [<span class="built_in">UIBezierPath</span> bezierPathWithOvalInRect:<span class="built_in">CGRectMake</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">100</span>,<span class="number">100</span>)];</span><br><span class="line">[[<span class="built_in">UIColor</span> blueColor] setFill];</span><br><span class="line">[p fill];</span><br><span class="line"><span class="comment">// 从图片上下文中获取绘制的图片</span></span><br><span class="line"><span class="built_in">UIImage</span>* im = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</span><br><span class="line"><span class="comment">// 关闭图片上下文</span></span><br><span class="line"><span class="built_in">UIGraphicsEndImageContext</span>();</span><br></pre></td></tr></table></figure>
<p>使用CoreGraphics实现</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取图片上下文</span></span><br><span class="line"><span class="built_in">UIGraphicsBeginImageContextWithOptions</span>(<span class="built_in">CGSizeMake</span>(<span class="number">100</span>,<span class="number">100</span>), <span class="literal">NO</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 绘图</span></span><br><span class="line"><span class="built_in">CGContextRef</span> con = <span class="built_in">UIGraphicsGetCurrentContext</span>();</span><br><span class="line"><span class="built_in">CGContextAddEllipseInRect</span>(con, <span class="built_in">CGRectMake</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">100</span>,<span class="number">100</span>));</span><br><span class="line"><span class="built_in">CGContextSetFillColorWithColor</span>(con, [<span class="built_in">UIColor</span> blueColor].CGColor);</span><br><span class="line"><span class="built_in">CGContextFillPath</span>(con);</span><br><span class="line"><span class="comment">// 从图片上下文中获取绘制的图片</span></span><br><span class="line"><span class="built_in">UIImage</span>* im = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</span><br><span class="line"><span class="comment">// 关闭图片上下文</span></span><br><span class="line"><span class="built_in">UIGraphicsEndImageContext</span>();</span><br></pre></td></tr></table></figure>

<h6 id="4-2-drawInRect"><a href="#4-2-drawInRect" class="headerlink" title="4.2 drawInRect"></a><strong><strong>4.2 drawInRect</strong></strong></h6><p>在系统调用drawInRect方法之前会创建一个新的Context，因此在drawInRect一般而言不需要创建新的Context,只需要通过UIGraphicsGetCurrentContext来获取即可。</p>
<p>使用UIKit实现</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>) drawRect: (<span class="built_in">CGRect</span>) rect &#123;</span><br><span class="line">    <span class="built_in">UIBezierPath</span>* p = [<span class="built_in">UIBezierPathbezierPathWithOvalInRect</span>:<span class="built_in">CGRectMake</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">100</span>,<span class="number">100</span>)];</span><br><span class="line">    [[<span class="built_in">UIColor</span> blueColor] setFill];</span><br><span class="line">    [p fill];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用CoreGraphics实现</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>) drawRect: (<span class="built_in">CGRect</span>) rect &#123;</span><br><span class="line">    <span class="built_in">CGContextRef</span> con = <span class="built_in">UIGraphicsGetCurrentContext</span>();<span class="comment">//当前视图的上下文</span></span><br><span class="line">    <span class="built_in">CGContextAddEllipseInRect</span>(con, <span class="built_in">CGRectMake</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">100</span>,<span class="number">100</span>));</span><br><span class="line">    <span class="built_in">CGContextSetFillColorWithColor</span>(con, [<span class="built_in">UIColor</span> blueColor].CGColor);</span><br><span class="line">    <span class="built_in">CGContextFillPath</span>(con);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="4-2-drawLayer-inContext"><a href="#4-2-drawLayer-inContext" class="headerlink" title="4.2 drawLayer:inContext"></a><strong><strong>4.2 drawLayer:inContext</strong></strong></h6><p>讲到这里得复习下Core Graphic的绘图方法的调用流程：</p>
<p><img src="/2019/08/06/Core-graphic-%E4%BD%BF%E7%94%A8/00003.png"></p>
<p>上图在介绍iOS渲染的时候已经讲解过了，我们这里再重新提一下第二个分支的过程，第二个分支开始的时候会创建一个新的backing store,然后开始走drawInContext，这时候会先看delegate是否实现了drawRect如果有则用drawRect,否则调用drawLayer:inContext:并将管理新建backing store的context传递出来，因此我们在绘制的时候只要使用传递出来的context就可以直接绘制到指定到layer</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)drawLayer:(<span class="built_in">CALayer</span> *)layer inContext:(<span class="built_in">CGContextRef</span>)ctx &#123;</span><br><span class="line">    <span class="built_in">CGContextAddEllipseInRect</span>(ctx, <span class="built_in">CGRectMake</span>(<span class="number">100</span>,<span class="number">100</span>,<span class="number">100</span>,<span class="number">100</span>));</span><br><span class="line">    <span class="built_in">CGContextSetFillColorWithColor</span>(ctx, [<span class="built_in">UIColor</span> blueColor].CGColor);</span><br><span class="line">    <span class="built_in">CGContextFillPath</span>(ctx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> () </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="type">id</span> myLayerDelegate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line">- (<span class="type">void</span>)viewDidLoad &#123;</span><br><span class="line">    MyView *myView = [[MyView alloc] initWithFrame:<span class="keyword">self</span>.view.bounds];</span><br><span class="line">    <span class="keyword">self</span>.view addSubview:myView];</span><br><span class="line">    <span class="built_in">CALayer</span> *layer = [<span class="built_in">CALayer</span> layer];</span><br><span class="line">    layer.backgroundColor = [<span class="built_in">UIColor</span> magentaColor].CGColor;</span><br><span class="line">    layer.bounds = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">300</span>, <span class="number">500</span>);</span><br><span class="line">    layer.anchorPoint = <span class="built_in">CGPointZero</span>;</span><br><span class="line">    layer.delegate = [[MyLayerDelegate alloc] init];</span><br><span class="line">    [layer setNeedsDisplay];</span><br><span class="line">    [myView.layer addSublayer:layer];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="4-绘制坐标系统"><a href="#4-绘制坐标系统" class="headerlink" title="4. 绘制坐标系统"></a><strong><strong>4. 绘制坐标系统</strong></strong></h5><p>UIView 有几个比较重要的位置坐标属性：frame, bounds, position，center，anchorPoint</p>
<p><img src="/2019/08/06/Core-graphic-%E4%BD%BF%E7%94%A8/00005.png"></p>
<figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">* frame 表示视图，图层的外部坐标，也就是当前UIView相对于父视图的坐标</span><br><span class="line">* bounds 表示视图，图层的内部坐标。原点位于左上角,它的作用主要是用于存放宽高尺寸。</span><br><span class="line">* center 和 position 代表相对于父图层<span class="built_in">anchor</span>Point所在的位置，center 是视图的称呼，postion是图层里面的称呼，二者是同一个值。</span><br><span class="line">* <span class="built_in">anchor</span>Point 可以看成是一个UIView的移动支点。我们设置center或者position的时候就是移动<span class="built_in">anchor</span>Point坐标，<span class="built_in">anchor</span>Point用单位坐标来描述，也就是图层的相对坐标，图层左上角是&#123;<span class="number">0</span>, <span class="number">0</span>&#125;，右下角是&#123;<span class="number">1</span>, <span class="number">1</span>&#125;，因此默认坐标是&#123;<span class="number">0.5</span>, <span class="number">0.5</span>&#125;。<span class="built_in">anchor</span>Point可以通过指定x和y值小于<span class="number">0</span>或者大于<span class="number">1</span>，使它放置在图层范围之外。</span><br></pre></td></tr></table></figure>

<p>frame是一个关联属性，是根据bounds，center和transform计算出来的，后面的任何一个值变化都会影响到frame的值。而frame值一旦改变也会对bounds，center和transform产生影响。同时也需要注意的是当图层做变换后，frame实际上代表了覆盖在图层旋转之后的整个轴对齐的矩形区域。这时候frame宽高和bounds有可能不一样了。</p>
<h6 id="4-1-UIView坐标系"><a href="#4-1-UIView坐标系" class="headerlink" title="4.1 UIView坐标系"></a><strong><strong>4.1 UIView坐标系</strong></strong></h6><p>而在iOS的UIView中，统一使用左手坐标系，也就是坐标原点在左上角. </p>
<h6 id="4-2-Quartz坐标系"><a href="#4-2-Quartz坐标系" class="headerlink" title="4.2 Quartz坐标系"></a><strong><strong>4.2 Quartz坐标系</strong></strong></h6><p>Quartz（Core Graphics）坐标系使用的是右手坐标系,原点在左下角, 所以所有使用Core Graphics画图的坐标系都是右手坐标系，当使用CG的相关函数画图到UIView上的时候，需要注意CTM的Flip变换，要不然会出现界面上图形倒过来的现象。由于UIKit的提供的高层方法会自动处理CTM（比如UIImage的drawInRect方法），所以无需自己在CG的上下文中做处理。</p>
<p><img src="/2019/08/06/Core-graphic-%E4%BD%BF%E7%94%A8/00004.png"></p>
<p>当通过CGContextDrawImage绘制图片到一个context中时，如果传入的是UIImage的CGImageRef，因为UIKit和CG坐标系y轴相反，所以图片绘制将会上下颠倒。可以用下面几种方式来解决：</p>
<ol>
<li>在绘制到context前通过矩阵垂直翻转坐标系</li>
</ol>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="constructor">CGContextTranslateCTM(<span class="params">context</span>, 0, <span class="params">height</span>)</span>;</span><br><span class="line"><span class="constructor">CGContextScaleCTM(<span class="params">context</span>, 1.0, -1.0)</span>;</span><br><span class="line"><span class="constructor">CGContextDrawImage(<span class="params">context</span>, CGRectMake(0, 0, <span class="params">width</span>, <span class="params">height</span>)</span>, uiImage.CGImage);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用UIImage的drawInRect函数，该函数内部能自动处理图片的正确方向</li>
</ol>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">UIGraphicsPushContext</span>(context);</span><br><span class="line"><span class="selector-attr">[uiImage drawInRect:CGRectMake(0, 0, width, height)]</span>;</span><br><span class="line"><span class="built_in">UIGraphicsPopContext</span>();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="4-3-坐标转换"><a href="#4-3-坐标转换" class="headerlink" title="4.3 坐标转换"></a><strong><strong>4.3 坐标转换</strong></strong></h6><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将像素point由point所在视图(方法调用者)转换到目标视图view中，返回在目标视图view中的像素值</span></span><br><span class="line">- [(<span class="built_in">CGPoint</span>)convertPoint:(<span class="built_in">CGPoint</span>)point] toView:(<span class="built_in">UIView</span> *)view;</span><br><span class="line"><span class="comment">// 将像素point从view中转换到当前视图(方法调用者)中，返回在当前视图中的像素值 </span></span><br><span class="line">- (<span class="built_in">CGPoint</span>)[convertPoint:(<span class="built_in">CGPoint</span>)point fromView:(<span class="built_in">UIView</span> *)view;]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将rect由rect所在视图转换到目标视图view中，返回在目标视图view中的rect</span></span><br><span class="line">- [(<span class="built_in">CGRect</span>)convertRect:(<span class="built_in">CGRect</span>)rect] toView:(<span class="built_in">UIView</span> *)view;</span><br><span class="line"><span class="comment">// 将rect从view中转换到当前视图中，返回在当前视图中的rect</span></span><br><span class="line">- [(<span class="built_in">CGRect</span>)convertRect:(<span class="built_in">CGRect</span>)rect fromView:(<span class="built_in">UIView</span> *)view]; </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>使用convertPoint:toView:时，调用者应为covertPoint的父视图。即调用者应为point的父控件。toView即为需要转换到的视图坐标系，以此视图的左上角为（0，0）点。</li>
<li>使用convertPoint:fromView:时正好相反，调用者为需要转换到的视图坐标系。fromView为point所在的父控件。</li>
<li>toView可以为nil。此时相当于toView传入self.view.window</li>
</ul>
<p>这里特地将同个坐标的用方括号扩起来，方便理解，也就是说括号内的是在同一个坐标系上。</p>
<h6 id="4-4-坐标关系"><a href="#4-4-坐标关系" class="headerlink" title="4.4 坐标关系"></a><strong><strong>4.4 坐标关系</strong></strong></h6><ul>
<li>点是否在范围内的判断</li>
</ul>
<p>需要判断点是否在某个范围内可以使用如下方法：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">BOOL</span>)pointInside:(<span class="built_in">CGPoint</span>)point withEvent:(<span class="keyword">nullable</span> <span class="built_in">UIEvent</span> *)event;</span><br></pre></td></tr></table></figure>

<p>使用注意：<br>point必须为调用者的坐标系，即调用者的左上角为（0，0）的坐标系。<br>比如确定redView的中心点是否在blueView上：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">//转换为blueView坐标系点</span></span><br><span class="line"><span class="built_in">CGPoint</span> redCenterInBlueView = [<span class="keyword">self</span>.grayView convertPoint:<span class="keyword">self</span>.redView.center toView:<span class="keyword">self</span>.blueView];</span><br><span class="line"><span class="type">BOOL</span> isInside = [<span class="keyword">self</span>.blueView pointInside:redCenterInBlueView withEvent:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure>

<h5 id="5-Core-Graphic-API"><a href="#5-Core-Graphic-API" class="headerlink" title="5. Core Graphic API"></a><strong><strong>5. Core Graphic API</strong></strong></h5><p>整个Core Graphic API 十分丰富，这里只是列举一部分比较核心的来介绍：<br>完整的可以查看官方文档：<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/coregraphics?language=objc">Core Graphic API</a></p>
<p>这里比较重要的是画圆弧的时候弧度的起始角度和结束角度，以及顺时针逆时针方向，我在网上找了一张图解释得很到位大家可以参照下。</p>
<p><img src="/2019/08/06/Core-graphic-%E4%BD%BF%E7%94%A8/00000.png"></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/5e96e754d9cb">深入理解UIBezierPath画圆弧addArcWithCenter</a></p>
<h5 id="6-CGPath-和-UIBezierPath-区别"><a href="#6-CGPath-和-UIBezierPath-区别" class="headerlink" title="6. CGPath 和 UIBezierPath() 区别"></a><strong><strong>6. CGPath 和 UIBezierPath() 区别</strong></strong></h5><p>CGPath是CoreGraphics库的类,而UIBezierPath是UIKit中的类. UIBezierPath是对CGPath的一种封装，可以很方便在二者之间进行转换,CGPath相对而言更底层，在速度性能上较UIBezierPath高，并且它具备UIBezierPath不具备的更高级的功能，但是UIBezierPath在使用上十分易用，所以除非在万不得己的情况下一般推荐使用UIBezierPath。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/iOS-%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/">iOS 理论基础</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/iOS-理论基础/">iOS 理论基础</a>
  </div>

</div>



<div class="comments-count">
	
	  	<span></span>
		<a href="/2019/08/06/Core-graphic-使用/#comments" class="ds-thread-count comments-count-link" data-thread-key="2019/08/06/Core-graphic-使用/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/08/06/iOS-内置布局方式对比-布局相关函数介绍-布局相关三方开源项目对比/" title="iOS 布局总结" itemprop="url">iOS 布局总结</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Edgar" target="_blank" itemprop="author">Edgar</a>
		
  <p class="article-time">
    <time datetime="2019-08-05T17:19:21.000Z" itemprop="datePublished"> Published 2019-08-06</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h5 id="0-较好的相关网站"><a href="#0-较好的相关网站" class="headerlink" title="0. 较好的相关网站"></a><strong><strong>0. 较好的相关网站</strong></strong></h5><p><a target="_blank" rel="noopener" href="https://uiiiuiii.com/screen/index.htm">各种设备的屏幕尺寸查询</a><br><a target="_blank" rel="noopener" href="https://www.paintcodeapp.com/news/ultimate-guide-to-iphone-resolutions">Paint Code屏幕尺寸查询</a></p>
<h5 id="1-目录"><a href="#1-目录" class="headerlink" title="1. 目录"></a><strong><strong>1. 目录</strong></strong></h5><ul>
<li>iOS界面开发中常用的概念</li>
<li>iOS坐标系统及坐标转换</li>
<li>iOS布局相关函数</li>
<li>AutoresizingMask,AutoLayout,frame 布局</li>
<li>三方开源布局引擎对比</li>
<li>iOS界面适配</li>
</ul>
<h5 id="2-开篇叨叨"><a href="#2-开篇叨叨" class="headerlink" title="2. 开篇叨叨"></a><strong><strong>2. 开篇叨叨</strong></strong></h5><p>iPhone刚推出的时候尺寸比较单一，只有3.5英寸，这时候用frame就可以轻松搞定布局，后面推出了4.0英寸，4.7英寸，5.5英寸，5.8英寸，6.1英寸，6.5英寸，各种尺寸的屏幕，这给界面适配带来了很大困难，后面引入的刘海屏等更加剧了界面适配的难度。下图是iPhone和iPad不同机型的尺寸数据：</p>
<p><img src="/2019/08/06/iOS-%E5%86%85%E7%BD%AE%E5%B8%83%E5%B1%80%E6%96%B9%E5%BC%8F%E5%AF%B9%E6%AF%94-%E5%B8%83%E5%B1%80%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E4%BB%8B%E7%BB%8D-%E5%B8%83%E5%B1%80%E7%9B%B8%E5%85%B3%E4%B8%89%E6%96%B9%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E5%AF%B9%E6%AF%94/0001.png"><br><img src="/2019/08/06/iOS-%E5%86%85%E7%BD%AE%E5%B8%83%E5%B1%80%E6%96%B9%E5%BC%8F%E5%AF%B9%E6%AF%94-%E5%B8%83%E5%B1%80%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E4%BB%8B%E7%BB%8D-%E5%B8%83%E5%B1%80%E7%9B%B8%E5%85%B3%E4%B8%89%E6%96%B9%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E5%AF%B9%E6%AF%94/0001.jpg"><br><img src="/2019/08/06/iOS-%E5%86%85%E7%BD%AE%E5%B8%83%E5%B1%80%E6%96%B9%E5%BC%8F%E5%AF%B9%E6%AF%94-%E5%B8%83%E5%B1%80%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E4%BB%8B%E7%BB%8D-%E5%B8%83%E5%B1%80%E7%9B%B8%E5%85%B3%E4%B8%89%E6%96%B9%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E5%AF%B9%E6%AF%94/0002.jpg"></p>
<p>为了解决这个问题苹果公司推出了 AutoresizingMask，用来协调子视图与父视图之间的关系。而后又相继推出了AutoLayout供开发者进行屏幕适配，目前用得比较多的就是AutoLayout和frame布局，但是AutoLayout其实质是用一个个约束条件来约束布局参数，这些约束条件会被转换成一个不等式组，布局视图的阶段，其实就是解方程组的阶段，约束越多性能越低，对于十分复杂的界面是十分不适用的，因此一般大型项目都会回归到基于frame的布局，当然不会是手动计算，有很多开源的布局引擎比如YogaKit，比如LayoutKit都将针对frame的布局形式简化成十分易用，并且性能优于AutoLayout的布局形式，这篇博客将从界面开发的基础概念出发，介绍界面的组成，坐标系统，布局相关函数，原生三大布局方式，三方开源布局引擎以及iOS适配的方方面面。</p>
<p>后续还会针对个人正在使用的基于frame的开源布局引擎YogaKit以及基于AutoLayout的Masonry布局引擎进行源码分析。</p>
<h5 id="3-正文"><a href="#3-正文" class="headerlink" title="3. 正文"></a><strong><strong>3. 正文</strong></strong></h5><h6 id="3-1-iOS界面开发中常用的概念"><a href="#3-1-iOS界面开发中常用的概念" class="headerlink" title="3.1 iOS界面开发中常用的概念"></a><strong><strong>3.1 iOS界面开发中常用的概念</strong></strong></h6><h6 id="3-2-点（Point）-屏幕像素-Pixel-对角线长度-，屏幕密度，屏幕模式，宽高比"><a href="#3-2-点（Point）-屏幕像素-Pixel-对角线长度-，屏幕密度，屏幕模式，宽高比" class="headerlink" title="3.2 点（Point） 屏幕像素 (Pixel) 对角线长度 ，屏幕密度，屏幕模式，宽高比"></a><strong><strong>3.2 点（Point） 屏幕像素 (Pixel) 对角线长度 ，屏幕密度，屏幕模式，宽高比</strong></strong></h6><p>说到点和屏幕像素就会扯到逻辑像素和物理像素这两个概念，逻辑像素的单位是pt，它是按照内容的尺寸计算的单位，也就是这里所说的点，而物理像素就是这里的屏幕像素(Pixel) 。如果使用Sketch或Adobe XD设计界面，那么只要使用pt作为单位设计出一套就可以了，我们在开发的时候也只需要以pt为单位的进行开发。而屏幕像素一般是用来结合对角线长度来描述整个屏幕的ppi（每英寸的像素数），用于描述屏幕的细腻程度。计算方式如下</p>
<figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">V<span class="comment">(长像素数)</span>*<span class="comment">(长像素数)</span> + <span class="comment">(宽像素数)</span> * <span class="comment">(宽像素数)</span> = 对角线像素数  （V表示开根号）</span><br><span class="line"></span><br><span class="line">PPI = 对角线像素数/对角线长度</span><br></pre></td></tr></table></figure>
<p>屏幕模式用于匹配App素材。为适配不同的屏幕，iOS App 的同一个图标，往往会准备 1x、2x、3x 等几个图片素材。假如屏幕 scale &#x3D; 3，就会优先选取 3x 素材；假如屏幕 scale &#x3D; 2, 就优先选择 2x 素材。scale也决定着点和像素之间的关系。当屏幕模式为 1x, 一个点就等于 1 个像素，当屏幕模式为 2x，一个点就等于 2 个像素。也就是说：</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">pixel</span> <span class="operator">=</span> point * scale</span><br></pre></td></tr></table></figure>
<p>宽高比则是在视频图片适配的时候比较重要，比如在手机上显示同一个视频，视频等比例铺满高度，在 iPhone X 左右两边就被裁掉更多内容。而视频等比例适应宽度，iPhone X 上下就被留更多的黑边。</p>
<h6 id="3-3-布局坐标系及关键的属性"><a href="#3-3-布局坐标系及关键的属性" class="headerlink" title="3.3 布局坐标系及关键的属性"></a><strong><strong>3.3 布局坐标系及关键的属性</strong></strong></h6><p>在iOS中有两大比较典型的坐标系，一个是UIKit的坐标系，零点位于左上角，一个是Core Graphic坐标系，零点位于左下角。<br>在布局使用的坐标系为UIKit坐标系，也就是说原点位于左上角。</p>
<p>UIView 有几个比较重要的布局属性：frame, bounds, position，center，anchorPoint</p>
<figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">* frame 表示视图，图层的外部坐标，也就是当前UIView相对于父视图的坐标</span><br><span class="line">* bounds 表示视图，图层的内部坐标。原点位于左上角,它的作用主要是用于存放宽高尺寸。</span><br><span class="line">* center 和 position 代表相对于父图层<span class="built_in">anchor</span>Point所在的位置，center 是视图的称呼，postion是图层里面的称呼，二者是同一个值。</span><br><span class="line">* <span class="built_in">anchor</span>Point 可以看成是一个UIView的移动支点。我们设置center或者position的时候就是移动<span class="built_in">anchor</span>Point坐标，<span class="built_in">anchor</span>Point用单位坐标来描述，也就是图层的相对坐标，图层左上角是&#123;<span class="number">0</span>, <span class="number">0</span>&#125;，右下角是&#123;<span class="number">1</span>, <span class="number">1</span>&#125;，因此默认坐标是&#123;<span class="number">0.5</span>, <span class="number">0.5</span>&#125;。<span class="built_in">anchor</span>Point可以通过指定x和y值小于<span class="number">0</span>或者大于<span class="number">1</span>，使它放置在图层范围之外。</span><br></pre></td></tr></table></figure>

<p><img src="/2019/08/06/iOS-%E5%86%85%E7%BD%AE%E5%B8%83%E5%B1%80%E6%96%B9%E5%BC%8F%E5%AF%B9%E6%AF%94-%E5%B8%83%E5%B1%80%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E4%BB%8B%E7%BB%8D-%E5%B8%83%E5%B1%80%E7%9B%B8%E5%85%B3%E4%B8%89%E6%96%B9%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E5%AF%B9%E6%AF%94/0003.png"></p>
<p>frame是一个关联属性，是根据bounds，center和transform计算出来的，后面的任何一个值变化都会影响到frame的值。而frame值一旦改变也会对bounds，center和transform产生影响。同时也需要注意的是当图层做变换后，frame实际上代表了覆盖在图层旋转之后的整个轴对齐的矩形区域。这时候frame宽高和bounds有可能不一样了。</p>
<h6 id="3-4-iOS布局相关函数"><a href="#3-4-iOS布局相关函数" class="headerlink" title="3.4 iOS布局相关函数"></a><strong><strong>3.4 iOS布局相关函数</strong></strong></h6><p>为什么需要理解这块，因为刚接触iOS开发的时候最耗时的还是调试界面布局上面，这主要是对view 的 frame何时真正更新不是很清楚。该小结争取解开这个环节中的各个疑惑。</p>
<p>首先我们在触摸屏幕的时候会产生一系列的事件，这些事件由系统进行分发并传递到应用中，并通过一定的回调调用我们相应事件的响应方法，在响应方法中我们可能会修改当前界面上某个View,这时候系统并不会直接对view进行修改，重绘，因为有可能还会有其他事件需要相应。这时候只是将这些view标记为脏视图，当这些方法调用返回后，控制流回到主Runloop中，在Runloop进入休眠之前,会先进入Update cycle，在 Update cycle 中完成布局并重新渲染整个界面，由于iOS设备会以每秒60帧的速度刷新界面，这个时间很短用户在和应用交互时几乎感觉不到刷新UI时候带来的更新延迟，在整个过程系统会调用如下几个关键函数，这里会先介绍各个函数的功能，然后看下这些函数是怎么结合起来的。</p>
<h6 id="3-4-1-frame布局"><a href="#3-4-1-frame布局" class="headerlink" title="3.4.1 frame布局"></a><strong><strong>3.4.1 frame布局</strong></strong></h6><h6 id="3-4-1-1-自动触发布局"><a href="#3-4-1-1-自动触发布局" class="headerlink" title="3.4.1.1 自动触发布局"></a><strong><strong>3.4.1.1 自动触发布局</strong></strong></h6><p>在某些节点系统会帮我们自动给视图打上需要布局的标记，在下一个Update cycle的时候layoutSubviews会被调用，而不需要手动触发：</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="bullet">* </span>通过addSubView 新增子view的时候</span><br><span class="line"><span class="bullet">* </span>设置self.view及子视图的frame.size会触发layoutSubviews，当然前提是frame.size的值设置前后发生了变化,注意，此处不是origin</span><br><span class="line"><span class="bullet">* </span>滚动UIScrollView的时候会触发</span><br><span class="line"><span class="bullet">* </span>横竖屏幕切换会触发</span><br><span class="line"><span class="bullet">* </span>更新视图的 constraints</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="3-4-1-2-手动触发布局"><a href="#3-4-1-2-手动触发布局" class="headerlink" title="3.4.1.2 手动触发布局"></a><strong><strong>3.4.1.2 手动触发布局</strong></strong></h6><ol>
<li>setNeedsLayout</li>
</ol>
<p>在事件响应函数中我们可能会提交不是需要非常实时呈现在界面上的事件，这种情况下就可以调用这个方法，告诉系统该视图需要重新进行布局计算，也就是将当前视图标记为脏数据。这个方法会立刻执行并返回，但是在返回后并不会立即更新View.它会在下一个Update cycle中调用layoutSubviews集中对脏数据进行更新，这就导致了setNeedsLayout返回后到视图被重新绘制并布局之间有一段任意时间的间隔，但是这个延迟不会对用户造成影响，反而能将关键的时间留给其他事件的响应，这是一个比较正常的情景。</p>
<ol start="2">
<li>layoutIfNeeded</li>
</ol>
<p>layoutIfNeeded和setNeedsLayout一样也会触发layoutSubviews，但是这两个方法是有区别的：调用setNeedsLayout()并不会立刻触发layoutSubviews函数而是会延迟到Upate cycle中触发。而layoutIfNeeded会立刻触发，但是这里需要注意的是如果调用了layoutIfNeeded之前，并没有调用setNeedsLayout将视图标记为脏视图，那么就不会调用 layoutsubview。如果你在同一个 run loop 内调用两次 layoutIfNeeded，并且两次之间没有更新视图，第二个调用同样不会触发 layoutSubviews 方法，也就是说layoutIfNeeded必须结合setNeedsLayout使用。</p>
<h6 id="3-4-1-3-布局回调节点"><a href="#3-4-1-3-布局回调节点" class="headerlink" title="3.4.1.3 布局回调节点"></a><strong><strong>3.4.1.3 布局回调节点</strong></strong></h6><p><strong><strong>1. layoutSubviews</strong></strong></p>
<p>这个方法会在需要对界面进行重新定位和大小调整的时候被调用，它负责给出当前view和每个子view的位置和大小。这个方法十分耗时因为它会在每个子视图上起作用并且调用它们相应的layoutSubviews方法，所以我们可以在需要重新定位或者更改大小的情形下重载它，但是这个方法不能直接调用。但是可以通过上面介绍的setNeedsLayout方法以及layoutIfNeeded方法进行触发，如果不是非常必要可以通过调用setNeedsLayout后将这个方法的调用时机放在Update Cycle 中。这样会比调用setNeedsLayout立刻调用layoutIfNeeded这种方案消耗的资源要小得多。<br>这里需要注意的是layoutSubviews会先对父视图进行layoutSubviews，完成后再调用子视图的layoutSubviews</p>
<p>总结下layoutSubviews的触发点：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、init初始化不会触发layoutSubviews，但是用initWithFrame进行初始化的时候，当rect的值不是<span class="built_in">CGRectZero</span>时也会触发</span><br><span class="line"><span class="number">2</span>、addSubview会触发layoutSubviews。</span><br><span class="line"><span class="number">3</span>、设置view的frame会触发layoutSubviews，当然前提是frame的值设置前后发生了变化。</span><br><span class="line"><span class="number">4</span>、滚动一个<span class="built_in">UIScrollView</span>会触发layoutSubviews。</span><br><span class="line"><span class="number">5</span>、旋转屏幕会触发父<span class="built_in">UIView</span>上的layoutSubviews事件。</span><br><span class="line"><span class="number">6</span>、改变一个<span class="built_in">UIView</span>大小的时候也会触发父<span class="built_in">UIView</span>上的layoutSubviews事件。</span><br><span class="line"><span class="number">7</span>、直接调用setLayoutSubviews。</span><br></pre></td></tr></table></figure>

<p><strong><strong>2. viewWillLayoutSubviews</strong></strong></p>
<p>viewWillLayoutSubviews&#x2F;viewDidLayoutSubviews 是UIViewController中的方法，它会在ViewController的根view的layoutSubviews被调用之前被触发。</p>
<p><strong><strong>3. viewDidLayoutSubviews</strong></strong></p>
<p>viewDidLayoutSubviews会在ViewController的根view的layoutSubviews被调用之后被触发，在这个节点上viewController中的根view以及子view的尺寸都已经确定了，所以我们可以把所有依赖于布局或者大小的代码放在 viewDidLayoutSubviews 中，而不是放在 viewDidLoad 或者 viewDidAppear 中。</p>
<ul>
<li><strong><strong>sizeThatFits</strong></strong></li>
</ul>
<p>sizeThatFits有两种功能:</p>
<ol>
<li>给一个限定的宽度和高度让view在这个范围内进行自适应size </li>
<li>在某个View中重写sizeThatFits，并返回需要的尺寸</li>
</ol>
<ul>
<li><strong><strong>sizeToFit</strong></strong></li>
</ul>
<p>当调用UIView的sizeToFit后会调用sizeThatFits方法来计算UIView的bounds.size然后改变frame.size,注意 Autolayout 约束过的 view 该方法失效</p>
<figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line">- (CGSize)sizeThatFits:(CGSize)<span class="built_in">size</span> &#123;</span><br><span class="line"></span><br><span class="line">    CGFloat w = <span class="built_in">size</span>.width;</span><br><span class="line">    w -= <span class="number">2</span> * <span class="variable">_margin</span>;</span><br><span class="line">    <span class="variable">_cacheSize1</span> = [<span class="variable">_label1</span> sizeThatFits:CGSizeMake(w, MAXFLOAT)];</span><br><span class="line">    <span class="variable">_cacheSize2</span> = [<span class="variable">_label2</span> sizeThatFits:CGSizeMake(w, MAXFLOAT)];</span><br><span class="line">    CGFloat h = <span class="number">3</span> * <span class="variable">_margin</span> + <span class="variable">_cacheSize1</span>.height + <span class="variable">_cacheSize2</span>.height;</span><br><span class="line">    return CGSizeMake(<span class="built_in">size</span>.width, h);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">IDLCustomView *customerView = [[IDLCustomView alloc] init];</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">[customerView sizeToFit];</span><br><span class="line">[self.view addSubview:customerView];</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="3-4-2-自动布局"><a href="#3-4-2-自动布局" class="headerlink" title="3.4.2 自动布局"></a><strong><strong>3.4.2 自动布局</strong></strong></h6><p>自动布局相对于frame布局来说多出了一步–约束计算,整个自动布局包括如下三个阶段：</p>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>. 约束计算： 从子<span class="keyword">View</span>-&gt;父<span class="keyword">View</span>，系统会计算并给视图设置所有要求的约束，更新约束或者手动调用setNeedsUpdateConstraints都会触发这个过程。</span><br><span class="line"><span class="number">2</span>. 布局阶段： 从父<span class="keyword">View</span>-&gt;子<span class="keyword">View</span>，布局引擎计算并设置视图和子视图的frame，这个阶段也可以通过手动和自动方式触发，上面已经做过详细的介绍了。</span><br><span class="line"><span class="number">3</span>. 显示阶段： 从父<span class="keyword">View</span>-&gt;子<span class="keyword">View</span>，重绘视图的内容，如果实现了<span class="keyword">draw</span> 方法则会被调用。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong><strong>1. updateConstraints</strong></strong></p>
<p>这个方法绝不能显式调用，而应该被重载，需要注意的是在updateConstraints方法中只做必须要更新的约束。约束的初始化工作一般在视图的初始化方法或者 viewDidLoad() 方法中指定，通常情况下，开启或者关闭 constrains、更改 constrain 的属性或者从视图层级中移除一个视图时都会设置一个内部的标记，这个标记会在下一个更新周期中触发updateConstrains。当然和布局一样也可以手动触发updateConstrains，比如setNeedsUpdateConstraints，updateConstraintsIfNeeded。</p>
<p><strong><strong>2. setNeedsUpdateConstraints</strong></strong></p>
<p>setNeedsUpdateConstraints和setNeedsLayout一样会保证在下一次更新周期中更新约束。</p>
<p><strong><strong>3. updateConstraintsIfNeeded</strong></strong></p>
<p>updateConstraintsIfNeeded 和 layoutIfNeeded一样会立即触发updateConstraints()，而不会等到主线程Runloop进入休眠前调用。</p>
<p><strong><strong>4. invalidateIntrinsicContentSize</strong></strong></p>
<p>自动布局中某些视图拥有intrinsicContentSize属性，这是视图根据它的内容得到的自然尺寸，它是由所包含的元素的约束决定，但也可以通过重载提供自定义行为。我们可以调用invalidateIntrinsicContentSize()方法设置一个标记表示这个视图的intrinsicContentSize 已经过期，需要在下一个布局阶段重新计算。</p>
<h6 id="3-4-3-显示"><a href="#3-4-3-显示" class="headerlink" title="3.4.3 显示"></a><strong><strong>3.4.3 显示</strong></strong></h6><p><strong><strong>1. setNeedsDisplay</strong></strong></p>
<p>类似于setNeedsLayout，setNeedsUpdateConstraints，它会将需要重绘的视图标记为脏视图，但是不会立刻调用而是在下一个Update Cycle 中遍历所有已标标记的视图，并调用它们的draw 方法，如果只想重绘部分视图，可以调用 setNeedsDisplayInRect，并把需要重绘的矩形部分传进去。</p>
<p><strong><strong>2. drawRect</strong></strong></p>
<p>UIView的drawRect方法类似于视图布局的layoutSubviews是重绘视图的节点，但是不同于layoutSubviews，drawRect方法不会触发后续对视图的子视图方法的调用，视图的显示方法里没有类似布局中的layoutIfNeeded 这样可以触发立即更新的方法。</p>
<p>还需要注意的是layoutSubviews方法会先于drawRect调用。</p>
<p><img src="/2019/08/06/iOS-%E5%86%85%E7%BD%AE%E5%B8%83%E5%B1%80%E6%96%B9%E5%BC%8F%E5%AF%B9%E6%AF%94-%E5%B8%83%E5%B1%80%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E4%BB%8B%E7%BB%8D-%E5%B8%83%E5%B1%80%E7%9B%B8%E5%85%B3%E4%B8%89%E6%96%B9%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E5%AF%B9%E6%AF%94/0004.png"></p>
<h6 id="3-5AutoresizingMask"><a href="#3-5AutoresizingMask" class="headerlink" title="3.5AutoresizingMask"></a><strong><strong>3.5AutoresizingMask</strong></strong></h6><p>AutoresizingMask 仅适用于约束父子控件之间的关系，我们知道UIView有个autoresizingMask属性，当UIView的autoresizesSubviews是YES时, 那么一旦bounds发生了变化，当前view的子view会根据它自身的autoresizingMask属性来自动适应其与superView之间的位置和大小。</p>
<p>需要注意的是Autoresizing只能设置父子视图之间的关系，不能设置兄弟视图之间的关系，当然也不能设置完全不相关的两个视图之间的关系。<br>autoresizing是约束子控件和父控件之间的位置关系的，UIViewController的根view并没有父控件，所以不能通过autoresizing来约束UIViewController的根view。</p>
<p>autoresizingMask是一个枚举类型,默认值为UIViewAutoresizingNone</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_OPTIONS</span>(<span class="built_in">NSUInteger</span>, <span class="built_in">UIViewAutoresizing</span>) &#123;</span><br><span class="line">    <span class="built_in">UIViewAutoresizingNone</span>                 = <span class="number">0</span>,</span><br><span class="line">    <span class="built_in">UIViewAutoresizingFlexibleLeftMargin</span>   = <span class="number">1</span> &lt;&lt; <span class="number">0</span>,</span><br><span class="line">    <span class="built_in">UIViewAutoresizingFlexibleWidth</span>        = <span class="number">1</span> &lt;&lt; <span class="number">1</span>,</span><br><span class="line">    <span class="built_in">UIViewAutoresizingFlexibleRightMargin</span>  = <span class="number">1</span> &lt;&lt; <span class="number">2</span>,</span><br><span class="line">    <span class="built_in">UIViewAutoresizingFlexibleTopMargin</span>    = <span class="number">1</span> &lt;&lt; <span class="number">3</span>,</span><br><span class="line">    <span class="built_in">UIViewAutoresizingFlexibleHeight</span>       = <span class="number">1</span> &lt;&lt; <span class="number">4</span>,</span><br><span class="line">    <span class="built_in">UIViewAutoresizingFlexibleBottomMargin</span> = <span class="number">1</span> &lt;&lt; <span class="number">5</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UIViewAutoresizingNone</span> view的frame不会随superview的改变而改变</span><br><span class="line"><span class="built_in">UIViewAutoresizingFlexibleLeftMargin</span> 自动调整view与superview左边的距离保证右边距离不变</span><br><span class="line"><span class="built_in">UIViewAutoresizingFlexibleRightMargin</span> 自动调整view与superview右边的距离保证左边距不变</span><br><span class="line"><span class="built_in">UIViewAutoresizingFlexibleWidth</span> 自动调整view的宽，保证与superView的左右边距不变</span><br><span class="line"><span class="built_in">UIViewAutoresizingFlexibleHeight</span> 自动调整view的高，保证与superView的顶部和底部距离不变</span><br><span class="line"><span class="built_in">UIViewAutoresizingFlexibleTopMargin</span> 自动调整view与superview顶部的距离保证底部距离不变</span><br><span class="line"><span class="built_in">UIViewAutoresizingFlexibleBottomMargin</span> 自动调整view与superview底部部的距离保证顶部距离不变</span><br></pre></td></tr></table></figure>


<h6 id="3-6-AutoLayout"><a href="#3-6-AutoLayout" class="headerlink" title="3.6 AutoLayout"></a><strong><strong>3.6 AutoLayout</strong></strong></h6><h6 id="3-6-1-AutoLayout-工作原理"><a href="#3-6-1-AutoLayout-工作原理" class="headerlink" title="3.6.1 AutoLayout 工作原理"></a><strong><strong>3.6.1 AutoLayout 工作原理</strong></strong></h6><p>iOS 6 之后推出了AutoLayout，它主要是为了替代Autoresizing，AutoLayout和Autoresizing是不能在同一个项目中共存。<br>AutoLayout主要由基于Cassary线性方程解析引擎，约束规则组成的，我们在开发的时候会以比较直观的方式对视图控件添加约束，比如某个视图的左边距距离另一个视图的右边边距20pt的距离，每条约束会被转换成一个多元一次方程，一个视图往往有多条约束，这样每个视图都会形成一个多元一次方程组，这些方程组作为布局引擎的输入，经过布局引擎计算后得到视图的frame数据。再进入布局流程，完成整个页面的布局。</p>
<p>下图是整个Auto Layout的流程图：</p>
<p><img src="/2019/08/06/iOS-%E5%86%85%E7%BD%AE%E5%B8%83%E5%B1%80%E6%96%B9%E5%BC%8F%E5%AF%B9%E6%AF%94-%E5%B8%83%E5%B1%80%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E4%BB%8B%E7%BB%8D-%E5%B8%83%E5%B1%80%E7%9B%B8%E5%85%B3%E4%B8%89%E6%96%B9%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E5%AF%B9%E6%AF%94/0005.png"></p>
<p>为一个View添加约束需要如下步骤：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1.</span> 设置View的translatesAutoresizingMaskIntoConstraints属性为NO</span><br><span class="line"><span class="bullet">2.</span> 根据实际需要的效果创建约束</span><br><span class="line"><span class="bullet">3.</span> 把约束添加到对应位置，iOS 8+直接通过active激活某条约束；</span><br></pre></td></tr></table></figure>

<h6 id="3-6-2-AutoLayout-约束的组成"><a href="#3-6-2-AutoLayout-约束的组成" class="headerlink" title="3.6.2 AutoLayout 约束的组成"></a><strong><strong>3.6.2 AutoLayout 约束的组成</strong></strong></h6><p>下图是一个约束条件组成部分：</p>
<p><img src="/2019/08/06/iOS-%E5%86%85%E7%BD%AE%E5%B8%83%E5%B1%80%E6%96%B9%E5%BC%8F%E5%AF%B9%E6%AF%94-%E5%B8%83%E5%B1%80%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E4%BB%8B%E7%BB%8D-%E5%B8%83%E5%B1%80%E7%9B%B8%E5%85%B3%E4%B8%89%E6%96%B9%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E5%AF%B9%E6%AF%94/0006.png"></p>
<ul>
<li>Item1,Item2:表示该约束关系对应的两个视图，当约束等式表示尺寸时，其中一个Item为nil。</li>
<li>Attribute1,Attribute2：NSLayoutAttribute类型，表示约束属性。当约束等式表示尺寸时，其中一个Attribute为NSLayoutAttributeNotAnAttribute，表示占位，无任何意义。</li>
</ul>
<p>目前可用的约束属性有如下几种类型：</p>
<table>
<thead>
<tr>
<th>约束属性</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td>NSLayoutAttributeWidth NSLayoutAttributeHeight</td>
<td>视图的尺寸：宽、高</td>
</tr>
<tr>
<td>NSLayoutAttributeLeft NSLayoutAttributeRight</td>
<td>视图的X轴方向的位置：左、右</td>
</tr>
<tr>
<td>NSLayoutAttributeLeading NSLayoutAttributeTrailing</td>
<td>视图的X轴方向的位置：前、后</td>
</tr>
<tr>
<td>NSLayoutAttributeTop NSLayoutAttributeBottom</td>
<td>视图Y轴方向的位置：顶、底</td>
</tr>
<tr>
<td>NSLayoutAttributeBaseline</td>
<td>视图Y轴方向的位置：底部基准线</td>
</tr>
<tr>
<td>NSLayoutAttributeCenterX NSLayoutAttributeCenterY</td>
<td>视图的中心点：视图在X轴的中心点、视图在Y轴的中心点</td>
</tr>
</tbody></table>
<ul>
<li>Relationship：NSLayoutRelation类型，表示约束关系，可以是如下几种关系：</li>
</ul>
<table>
<thead>
<tr>
<th>约束关系</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td>NSLayoutRelationLessThanOrEqual</td>
<td>小于等于</td>
</tr>
<tr>
<td>NSLayoutRelationGreaterThanOrEqual</td>
<td>大于等于</td>
</tr>
<tr>
<td>NSLayoutRelationLessThanOrEqual</td>
<td>等于</td>
</tr>
</tbody></table>
<ul>
<li>Multiplier：CGFloat类型，表示倍数关系，一般用于尺寸</li>
<li>Constant：CGFloat类型，表示常数。</li>
<li>UILayoutPriority: 无论是我们创建的约束，还是系统创建的约束(IntrinsicContentSize相关的约束)都必须指定一个约束优先级<br>UILayoutPriority，布局引擎按照线性方程的优先级从高到底对线性方程组进行解析，当设置的约束欠缺会导致线性方程组有多个解，可能导致视图丢失，错位等问题。当设置的约束过多，会导致线程方程组无解。这会产生约束冲突，同样可能造成布局错误，这时候往往有错误Log输出。<br>默认创建出来的约束优先级为UILayoutPriorityRequired（1000),其他优先级小于1000的约束称为可选约束。<br>Auto Layout Engine会按优先级从高到低满足约束集合中的每一个约束，如果无法满足某个可选约束，则忽略；当优先级不同的两个约束描述的是同一个布局关系，Auto Layout会跳过优先级较低的约束。</li>
</ul>
<h6 id="3-6-3-AutoLayout-约束的安装与移除"><a href="#3-6-3-AutoLayout-约束的安装与移除" class="headerlink" title="3.6.3 AutoLayout 约束的安装与移除"></a><strong><strong>3.6.3 AutoLayout 约束的安装与移除</strong></strong></h6><h6 id="约束安装"><a href="#约束安装" class="headerlink" title="约束安装"></a>约束安装</h6><p>在早期的版本中往哪里添加约束需要我们自己判断，这种情况下一般有三种情况：</p>
<ol>
<li>约束为对视图本身宽高尺寸进行约束的时候，则约束直接添加到该视图本身</li>
<li>约束表示两个视图的布局关系的时候，则将约束添加到两个视图所在的视图树的第一个公共祖先</li>
<li>约束表示两个有层次关系的view之间的约束关系的时候，则将约束添加到层次较高的view上</li>
</ol>
<p>约束安装需要调用addConstraints方法来进行</p>
<h6 id="约束移除"><a href="#约束移除" class="headerlink" title="约束移除"></a>约束移除</h6><p>移除约束需要使用removeConstraint&#x2F;removeConstraints进行移除，当视图通过removeFromSuperView被整个移除的时候，与该视图相关的全部约束都会自动移除</p>
<p>iOS 版本之后，Auto Layout推出新的接口。NSLayoutConstraint多了一个active属性，用于激活、失效一个约束。不需要再考虑约束安装位置。原本用于添加、移除约束的接口addConstraint&#x2F;addConstraints、removeConstraint&#x2F;removeConstraints，接口文档表示在后续的版本升级将会过期，建议避免使用。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UIView</span> *grayView = [[<span class="built_in">UIView</span> alloc] init];</span><br><span class="line">grayView.backgroundColor = [<span class="built_in">UIColor</span> lightGrayColor];</span><br><span class="line">[<span class="keyword">self</span>.view addSubview:grayView];    </span><br><span class="line">grayView.translatesAutoresizingMaskIntoConstraints = <span class="literal">NO</span>;</span><br><span class="line">    </span><br><span class="line"><span class="built_in">NSLayoutConstraint</span> *left = [<span class="built_in">NSLayoutConstraint</span> constraintWithItem:grayView attribute:<span class="built_in">NSLayoutAttributeLeft</span> relatedBy:<span class="built_in">NSLayoutRelationEqual</span> toItem:<span class="keyword">self</span>.view attribute:<span class="built_in">NSLayoutAttributeLeft</span> multiplier:<span class="number">1.0</span> constant:<span class="number">50</span>];</span><br><span class="line"><span class="built_in">NSLayoutConstraint</span> *top = [<span class="built_in">NSLayoutConstraint</span> constraintWithItem:grayView attribute:<span class="built_in">NSLayoutAttributeTop</span> relatedBy:<span class="built_in">NSLayoutRelationEqual</span> toItem:<span class="keyword">self</span>.view attribute:<span class="built_in">NSLayoutAttributeTop</span> multiplier:<span class="number">1.0</span> constant:<span class="number">100</span>];</span><br><span class="line"><span class="built_in">NSLayoutConstraint</span> *width = [<span class="built_in">NSLayoutConstraint</span> constraintWithItem:grayView attribute:<span class="built_in">NSLayoutAttributeWidth</span> relatedBy:<span class="built_in">NSLayoutRelationEqual</span> toItem:<span class="literal">nil</span> attribute:<span class="built_in">NSLayoutAttributeNotAnAttribute</span> multiplier:<span class="number">1.0</span> constant:<span class="number">100</span>];</span><br><span class="line"><span class="built_in">NSLayoutConstraint</span> *height = [<span class="built_in">NSLayoutConstraint</span> constraintWithItem:grayView attribute:<span class="built_in">NSLayoutAttributeHeight</span> relatedBy:<span class="built_in">NSLayoutRelationEqual</span> toItem:<span class="literal">nil</span> attribute:<span class="built_in">NSLayoutAttributeNotAnAttribute</span> multiplier:<span class="number">1.0</span> constant:<span class="number">100</span>];</span><br><span class="line">        </span><br><span class="line">[<span class="keyword">self</span>.view addConstraints:@[left, top]];</span><br><span class="line">[grayView addConstraints:@[width, height]];</span><br><span class="line"></span><br><span class="line"><span class="comment">//  iOS8+</span></span><br><span class="line"><span class="comment">//  left.active = YES;</span></span><br><span class="line"><span class="comment">//  top.active = YES;</span></span><br><span class="line"><span class="comment">//  width.active = YES;</span></span><br><span class="line"><span class="comment">//  height.active = YES;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h6 id="3-6-4-Alignment-Rect"><a href="#3-6-4-Alignment-Rect" class="headerlink" title="3.6.4 Alignment Rect"></a><strong><strong>3.6.4 Alignment Rect</strong></strong></h6><p>在AutoLayout中约束使用的是Alignment Rect 而不是frame，这两者有什么区别呢？一般情况下是没有区别的，只有在一个图片包含阴影、外边框、角标等修饰元素的时候,frame和Alignment Rect才存在差别，结合下面图片可以很明显看出二者的差异。</p>
<p><img src="/2019/08/06/iOS-%E5%86%85%E7%BD%AE%E5%B8%83%E5%B1%80%E6%96%B9%E5%BC%8F%E5%AF%B9%E6%AF%94-%E5%B8%83%E5%B1%80%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E4%BB%8B%E7%BB%8D-%E5%B8%83%E5%B1%80%E7%9B%B8%E5%85%B3%E4%B8%89%E6%96%B9%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E5%AF%B9%E6%AF%94/0007.png"></p>
<p>(a) 是设计给出的切图 ，(c) 是切图的frame，它会将阴影和角标的外边距包括进去，但是这会导致一个问题就是center和right会偏移我们想要的位置，这在居中对齐的时候是很麻烦的一件事情，这种情况下就可以使用Alignment Rect来指定(b)中的框框为自动布局的外框。</p>
<p>如果视图是UIImageView，可以通过UIImage的方法imageWithAlignmentRectInsets来调整对齐矩形，插入内边距。</p>
<p>举个例子，设计给出一个右下角分别有20间距的阴影，导致其中心位置稍稍偏高和偏左，这时候我们要使用imageWithAlignmentRectInsets取出指定矩形区域内的图像。这时候就需要定义一个inset表示距离矩形的顶边、左边、底边和右边的间隙，用来描述从矩形的边移进(使用正值)或移出(使用负值)多远。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UIImage</span> *image = [[<span class="built_in">UIImage</span> imageNamed:<span class="string">@&quot;Shadowed.png&quot;</span>]  </span><br><span class="line">imageWithAlignmentRectInsets:<span class="built_in">UIEdgeInsetsMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">20</span>, <span class="number">20</span>)];  </span><br><span class="line"><span class="built_in">UIImageView</span> *imageView = [[<span class="built_in">UIImageView</span> alloc] initWithImage:image]; </span><br></pre></td></tr></table></figure>

<p>对于UIView它提供了方法对应的方法我们在子类中重写它就可以达到效果，由 frame 得到 alignment rect 可以使用：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// The alignment rectangle for the specified frame.</span></span><br><span class="line">- (<span class="built_in">CGRect</span>)alignmentRectForFrame:(<span class="built_in">CGRect</span>)frame;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当然也可以从 alignment rect 反过来得到 frame：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The frame for the specified alignment rectangle.</span></span><br><span class="line">- (<span class="built_in">CGRect</span>)frameForAlignmentRect:(<span class="built_in">CGRect</span>)alignmentRect;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="3-6-5-IntrinsicContentSize"><a href="#3-6-5-IntrinsicContentSize" class="headerlink" title="3.6.5 IntrinsicContentSize"></a><strong><strong>3.6.5 IntrinsicContentSize</strong></strong></h6><p>一般情况下，要确定一个View的布局需要确定位置及尺寸，但是对于那些拥有固有内容大小的View，只需要指定它的位置约束就可以了，首先需要明确下IntrinsicContentSize的情况：</p>
<ul>
<li>UIView 没有 IntrinsicContentSize,但是在自定义的View中，可以覆盖intrinsicContentSize方法来返回Intrinsic Content   Size，并可以通过调用invalidateIntrinsicContentSize来通知布局系统在下一个布局过程采用新的Intrinsic Content Size。</li>
<li>UISlider 在iOS下只定义了width</li>
<li>UILabel、UIButton、UISwitch、UITextField的IntrinsicContentSize同时存在width、height<br>其中UILabel、UIButton与视图文字数量、字体大小相关，即使没有设置内容，也有IntrinsicContentSize；</li>
<li>UITextView、UIImageView的IntrinsicContentSize是动态变化的<br>UITextView 的 IntrinsicContentSize 与内容、是否可滚动、约束相关。<br>UIImageView 当没有设置image就没有IntrinsicContentSize，当设置了image，IntrinsicContentSize就是设置的image对应的Size;</li>
</ul>
<h6 id="3-6-6-Compression-Resistance-amp-amp-Content-Hugging"><a href="#3-6-6-Compression-Resistance-amp-amp-Content-Hugging" class="headerlink" title="3.6.6 Compression Resistance &amp;&amp;  Content Hugging"></a><strong><strong>3.6.6 Compression Resistance &amp;&amp;  Content Hugging</strong></strong></h6><p>Compression Resistance 压缩阻力，在有外界力量向内压缩的时候这个值用于表示抗压缩的能力<br>Content Hugging 内容凝聚力，在有外力将Uiview向外面拉的时候，这个值用于表示拉伸的阻力</p>
<p>对于同一个View，Content Hugging和Compression Resistance不会同时起作用。当一个Label有文字的时候，label会存在一个内容的Size。<br>如果有外力让其size扩张，Content Hugging会起作用，外力大于Content Hugging的力量，label的size由外力决定，反之，label的Size由内容决定。<br>如果有外力让其size压缩，Compression Resistance会起作用，外力大于Compression Resistance的力量，label的size由外力决定，反之，label的Size由内容决定。</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[label1 setContentCompressionResistancePriority:UILayoutPriorityRequired-1 forAxis:UILayoutConstraintAxisHorizontal]</span><span class="comment">;</span></span><br><span class="line"><span class="section">[label1 setContentHuggingPriority:UILayoutPriorityRequired-1 forAxis:UILayoutConstraintAxisHorizontal]</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>

<h6 id="3-7-NSLayoutAnchor"><a href="#3-7-NSLayoutAnchor" class="headerlink" title="3.7 NSLayoutAnchor"></a><strong><strong>3.7 NSLayoutAnchor</strong></strong></h6><p>NSLayoutAnchor 是iOS 9之后推出的一种比NSLayoutConstraint更方便的方案，它将NSLayoutAnchor作为UIView的属性：</p>
<table>
<thead>
<tr>
<th>布局锚点类型</th>
<th>对应的子类</th>
<th>布局属性</th>
</tr>
</thead>
<tbody><tr>
<td>X轴方向</td>
<td>NSLayoutXAxisAnchor</td>
<td>leadingAnchor、trailingAnchor、leftAnchor、rightAnchor、centerXAnchor</td>
</tr>
<tr>
<td>Y轴方向</td>
<td>NSLayoutYAxisAnchor</td>
<td>topAnchor、bottomAnchor、centerYAnchor、firstBaselineAnchor、lastBaselineAnchor</td>
</tr>
<tr>
<td>尺寸</td>
<td>NSLayoutDimension</td>
<td>widthAnchor、heightAnchor</td>
</tr>
</tbody></table>
<p>这里有一篇关于NSLayoutAnchor写得比较好的文章可以供大家深入学习。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/b94b28a8a642">NSLayoutAnchor详解</a></li>
<li><a target="_blank" rel="noopener" href="https://peteruncle.com/2018/01/28/NSLayoutAnchor%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/#%E5%8A%A8%E6%89%8B%E5%AE%8C%E6%95%B4%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E4%BB%A3%E7%A0%81%E5%B8%83%E5%B1%80">NSLayoutAnchor基础知识</a></li>
</ul>
<h6 id="3-8-其他比较少用的布局方式"><a href="#3-8-其他比较少用的布局方式" class="headerlink" title="3.8 其他比较少用的布局方式"></a><strong><strong>3.8 其他比较少用的布局方式</strong></strong></h6><h6 id="3-8-1-VFL"><a href="#3-8-1-VFL" class="headerlink" title="3.8.1 VFL"></a><strong><strong>3.8.1 VFL</strong></strong></h6><p>使用字符串来描述约束关系，这种没有校验的方式，一般项目都不会采用。</p>
<h6 id="3-8-2-sizeClass"><a href="#3-8-2-sizeClass" class="headerlink" title="3.8.2 sizeClass"></a><strong><strong>3.8.2 sizeClass</strong></strong></h6><p>sizeClass 只能用于StoryBoard,个人比较偏向在项目中使用纯代码实现布局，StoryBoard编译速度慢，并且团队合作的情况下如果出现冲突很难解决。</p>
<h6 id="3-8-3-Interface-Builder"><a href="#3-8-3-Interface-Builder" class="headerlink" title="3.8.3 Interface Builder"></a><strong><strong>3.8.3 Interface Builder</strong></strong></h6><p>同上原因：不喜欢用storyboard，喜欢纯代码方式实现布局。</p>
<h6 id="3-8-4-UIStackView"><a href="#3-8-4-UIStackView" class="headerlink" title="3.8.4 UIStackView"></a><strong><strong>3.8.4 UIStackView</strong></strong></h6><p>UIStackView 是iOS 9 推出的布局方案，如果需要兼容之前的版本可以使用FDStackView这个开源库，UIStackView在某些成行成列的布局中比较好用，比如九宫格布局之类的，如果是比较复杂的布局，就会有比较深的嵌套，维护起来很蛋疼，建议谨慎使用。</p>
<h6 id="3-8-三方开源布局引擎对比"><a href="#3-8-三方开源布局引擎对比" class="headerlink" title="3.8 三方开源布局引擎对比"></a><strong><strong>3.8 三方开源布局引擎对比</strong></strong></h6><h6 id="3-8-1-Masonry-17438-Stars"><a href="#3-8-1-Masonry-17438-Stars" class="headerlink" title="3.8.1 Masonry 17438 Stars"></a><strong><strong>3.8.1 <a target="_blank" rel="noopener" href="https://github.com/SnapKit/Masonry">Masonry 17438 Stars</a></strong></strong></h6><p>Masonry是我接触iOS开发时候使用的第一个布局引擎，它也是目前遇到的Stars数量最多的一个布局引擎，如果没有Masonry我会觉得AutoLayout是一个蛋疼的设计，有了Masonry有种从地狱到天堂的感觉，但是它底层是基于AutoLayout，所以在复杂界面性能上较差，因此在项目中期切换到基于frame封装的布局引擎了。但是整个封装还是十分优雅的，在中小型项目或者简单布局完全可以胜任。</p>
<h6 id="3-8-2-YogaKit-12141-Stars"><a href="#3-8-2-YogaKit-12141-Stars" class="headerlink" title="3.8.2 YogaKit 12141 Stars"></a><strong><strong>3.8.2 <a target="_blank" rel="noopener" href="https://github.com/facebook/yoga">YogaKit 12141 Stars</a></strong></strong></h6><p>这是我个人项目中用的一个布局引擎，它是一个跨平台的底层基于C++实现的，使用的是目前前端比较火的Flex Box，之所以用它有如下理由：</p>
<ol>
<li>它是跨平台的Android,iOS,Reactive Native都可以使用，在iOS平台上对应的库为YogaKit,在Android 平台上对应的库为Litho</li>
<li>基于FlexBox的这个是前端必须掌握的布局模式，使用它可以缩小下技术栈。</li>
<li>轻量,易用，基于frame布局性能上面有保证</li>
</ol>
<p>其实最重要的原因还是想统一下技术栈。</p>
<h6 id="3-8-3-ComponentKit-5053-Stars"><a href="#3-8-3-ComponentKit-5053-Stars" class="headerlink" title="3.8.3 ComponentKit 5053 Stars"></a><strong><strong>3.8.3 <a target="_blank" rel="noopener" href="https://github.com/facebook/componentkit">ComponentKit 5053 Stars</a></strong></strong></h6><p>ComponentKit 是Facebook推出的，它最初是为Facebook News Feed开发的，目前它被应用于Facebook的全部iOS应用。它可以在后台对UI提前测量和布局,因此不会阻碍UI线程。在 ComponentKit中我们处理的对象是一个个Component,它是一个NSObject子类，而不是UIView，我们在描述布局的时候只需要描述component，然后提交给ComponentKit渲染，如果UI有变化，只需要重新生成component然后全部刷新，ComponentKit负责处理这些变化。总结来说ComponentKit有如下优点：</p>
<ol>
<li>将对UI的变化转换成状态的变化</li>
<li>可以在后台进行测量和布局</li>
<li>可以对布局进行缓存</li>
</ol>
<p>它使用起来有点像Flutter的UI布局，对于描述复杂界面，整个代码会显得很庞大，不过结合懒加载写法这一点可以克服，后续有机会会在自己的业余项目中体验下它，这里就不再做介绍了。</p>
<h6 id="3-8-4-LayoutKit-2872-Stars"><a href="#3-8-4-LayoutKit-2872-Stars" class="headerlink" title="3.8.4 LayoutKit 2872 Stars"></a><strong><strong>3.8.4 <a target="_blank" rel="noopener" href="https://github.com/linkedin/LayoutKit">LayoutKit 2872 Stars</a></strong></strong></h6><p>说实话在选型的时候LayoutKit有吸引到我，如果不是因为Yoga可以跨平台我可能会选择它，下面是LayoutKit文档中对它的描述：</p>
<blockquote>
<p>LayoutKit has many benefits over using Auto Layout:</p>
</blockquote>
<blockquote>
<ul>
<li>Fast: LayoutKit is as fast as manual layout code and is significantly faster than Auto Layout.</li>
<li>Asynchronous: Layouts can be computed in a background thread so user interactions are not interrupted.</li>
<li>Declarative: Layouts are declared with immutable data structures. This makes layout code easier to develop, document, code review, test, debug, profile, and maintain.</li>
<li>Cacheable: Layout results are immutable data structures so they can be precomputed in the background and cached to increase user perceived performance.</li>
</ul>
</blockquote>
<blockquote>
<p>LayoutKit also provides benefits that make it as easy to use as Auto Layout:</p>
</blockquote>
<blockquote>
<p>UIKit friendly: LayoutKit produces UIViews and also provides an adapter that makes it easy to use with UITableView and UICollectionView.<br>Internationalization: LayoutKit automatically adjusts view frames for right-to-left languages.<br>Swift: LayoutKit can be used in Swift applications and playgrounds.<br>Tested and production ready: LayoutKit is covered by unit tests and is being used inside of recent versions of the LinkedIn and LinkedIn Job Search iOS apps.<br>Open-source: Not a black box like Auto Layout.<br>Apache License (v2): Your lawyers will be happy that there are no patent shenanigans.</p>
</blockquote>
<p>总结起来就是： 速度块， 异步，对结果进行缓存，可以很方便得支持从右往左的语言，可以在Swift语言中使用。</p>
<h6 id="3-8-5-MyLinearLayout-3503-Stars"><a href="#3-8-5-MyLinearLayout-3503-Stars" class="headerlink" title="3.8.5 MyLinearLayout 3503 Stars"></a><strong><strong>3.8.5 <a target="_blank" rel="noopener" href="https://github.com/youngsoft/MyLinearLayout">MyLinearLayout 3503 Stars</a></strong></strong></h6><p>MyLinearLayout是国内开发者开发的它是基于frame布局的方式，TangramKit是它的Swift版本，MyLayout功能强大而且简单易用，不论在功能，用法还是性能上都是一个不错的布局引擎。也是个十分值得推荐的布局引擎。</p>
<h6 id="3-8-6-Texture-5737-Stars"><a href="#3-8-6-Texture-5737-Stars" class="headerlink" title="3.8.6 Texture 5737 Stars"></a><strong><strong>3.8.6 <a href="hhttps://github.com/TextureGroup/Texture">Texture 5737 Stars</a></strong></strong></h6><p>Texture 内部支持ASLayoutSpect 和 Yoga 两种布局引擎，但是因为如果整个引入会显得太过庞大，目前还没考虑切换到Texture 不过后续会在列表页面使用它Texture + IGListKit应该是一个不错的组合。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/iOS-%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/">iOS 理论基础</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/iOS-理论基础/">iOS 理论基础</a>
  </div>

</div>



<div class="comments-count">
	
	  	<span></span>
		<a href="/2019/08/06/iOS-内置布局方式对比-布局相关函数介绍-布局相关三方开源项目对比/#comments" class="ds-thread-count comments-count-link" data-thread-key="2019/08/06/iOS-内置布局方式对比-布局相关函数介绍-布局相关三方开源项目对比/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/08/04/iOS-渲染系统工作原理介绍/" title="iOS 渲染系统工作原理介绍" itemprop="url">iOS 渲染系统工作原理介绍</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Edgar" target="_blank" itemprop="author">Edgar</a>
		
  <p class="article-time">
    <time datetime="2019-08-03T17:27:31.000Z" itemprop="datePublished"> Published 2019-08-04</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h5 id="0-开篇叨叨"><a href="#0-开篇叨叨" class="headerlink" title="0. 开篇叨叨"></a><strong><strong>0. 开篇叨叨</strong></strong></h5><p>这篇博客主要从原理的角度来向大家介绍下一个界面是如何在CPU和GPU的配合下显示到屏幕上的，后续博客还会对Core Graphic，OpenGL, Core Animation的使用一一介绍，优化部分也会单独抽到后续的博客中进行介绍。下面是该博客的内容目录：</p>
<ul>
<li>iOS 渲染框架组成概述</li>
<li>界面渲染的整体流程</li>
<li>离屏渲染</li>
</ul>
<h5 id="1-iOS-渲染框架组成概述"><a href="#1-iOS-渲染框架组成概述" class="headerlink" title="1. iOS 渲染框架组成概述"></a><strong><strong>1. iOS 渲染框架组成概述</strong></strong></h5><p><img src="/2019/08/04/iOS-%E6%B8%B2%E6%9F%93%E7%B3%BB%E7%BB%9F%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D/0001.png"></p>
<p>上图是iOS 渲染框架组成部分,其中UIKit位于最上层，组成界面的各个元素基本上都来自UIKit,我们可以给它设置布局，可以通过绘制改变它的显示内容，除此之外还负责事件的接收，其实界面的显示是由它的一个被称为图层的属性CALayer来完成的。这个放在后面详细介绍。UIKit的下一层是Core Animation,最开始接触iOS的时候，我一直以为Core Animation只是用于生成动画的，实际上动画的生成只是Core Animation的冰山一角，可以说在iOS上绝大多数的原生控件都是通过Core Animation绘制出来的，Core Animation在这里最重要的任务是尽可能快地合成图层送到下一级。位于Core Animation之下是Open GL 以及 Core Graphic，其中Open GL 使用GPU进行渲染，而Core Graphic则是使用Qurtaz 2D引擎使用CPU进行渲染，这里个人理解Core Graphic不单单只有CPU参与，最终渲染到屏幕上还是需要GPU参与，这部分在下个小结中将会进行详细介绍，各个GPU厂商的实现是不同的，为了隔离这个不同，在GPU的上层添加了GPU驱动层,经过GPU处理后的数据会放到帧缓冲区中，最终显示到显示器上。</p>
<h5 id="2-界面渲染的整体流程"><a href="#2-界面渲染的整体流程" class="headerlink" title="2.界面渲染的整体流程"></a><strong><strong>2.界面渲染的整体流程</strong></strong></h5><p><img src="/2019/08/04/iOS-%E6%B8%B2%E6%9F%93%E7%B3%BB%E7%BB%9F%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D/0002.png"></p>
<p><img src="/2019/08/04/iOS-%E6%B8%B2%E6%9F%93%E7%B3%BB%E7%BB%9F%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D/0005.png"></p>
<h5 id="2-1-UIView-amp-amp-CALayer"><a href="#2-1-UIView-amp-amp-CALayer" class="headerlink" title="2.1 UIView &amp;&amp; CALayer"></a><strong><strong>2.1 UIView &amp;&amp; CALayer</strong></strong></h5><p>对于UIView和CALayer大家都比较熟悉，UIView内部包含着一个CALayer属性，它继承自NSObject，负责界面上的内容显示，而UIView继承自UIResponder它作为CALayer的CALayerDelegate负责事件的响应，以及创建并管理它的图层，以确保当子视图在层级关系中添加或者被移除的时候，它们关联的图层也同样对应在层级关系树当中有相同的操作。每个View被创建的时候都会自动创建一个CALayer,同时还可以在后续的操作中添加多个layer。</p>
<p>我们先来看下UIView 和 CALayer的结构：<br>上面我们介绍了二者的分工，UIView 负责事件的响应，CALayer负责内容的显示，但是为什么需要有这样的分工？归根到底是因为Mac上和iPhone上的事件存在很大的区别？iPhone 上的事件绝大多数是屏幕触摸事件，而Mac上还有鼠标，键盘等事件，但是显示上却是高度一致的，因此就可以将这部分显示的给拎出来，作为CALayer单独存在。<br>CALayer有个id类型的contents属性，它指向内存中的一个成为backing storage的存储空间。往contents上赋值的时候就会将图片存储到这个backing storage中，这里虽然是id类型，但是如果传递其他类型进去会不显示，这里为什么使用id类型而不是明确的CGImageRef，也还是为了兼容，因为图像类型在Mac OS中是NSImage类型而在iOS上却是CGImageRef类型。</p>
<p><img src="/2019/08/04/iOS-%E6%B8%B2%E6%9F%93%E7%B3%BB%E7%BB%9F%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D/00017.png"></p>
<p>下面是整个UIView 和 CALayer的结构图：</p>
<p><img src="/2019/08/04/iOS-%E6%B8%B2%E6%9F%93%E7%B3%BB%E7%BB%9F%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D/0003.png"></p>
<p>接下来看下最重要的一点：我们怎么将要显示的内容绘制到CALayer上，下图是整个流程，总共分成两大分支：</p>
<ol>
<li>第一个分支是通过给layer.contents赋值，将内容绘制到CALayer 默认的backing store上，在我们调用[UIView setNeedsDisplay]的时候，会间接触发[view.layer setNeedsDisplay],紧接着调用[view.layer display] 在这个方法中会判断delegate 是否实现了displaylayer如果有则将layer传递出去，在这里可以对contents进行赋值，也就是说可以选择覆写CALayer的display方法为content赋值，或者直接对CALayer的content赋值，或者作为代理为在displaylayer方法中对content赋值。</li>
</ol>
<p>比如<strong><strong>SDAnimatedImageView中</strong></strong>有如下代码：</p>
<pre><code><figure class="highlight gml"><table><tr><td class="code"><pre><span class="line">- (void)displayLayer:(CALayer *)<span class="variable language_">layer</span> &#123;</span><br><span class="line">    UIImage *currentFrame = <span class="variable language_">self</span>.currentFrame;</span><br><span class="line">    <span class="keyword">if</span> (currentFrame) &#123;</span><br><span class="line">        <span class="variable language_">layer</span>.contentsScale = currentFrame.scale;</span><br><span class="line">        <span class="variable language_">layer</span>.contents = (__bridge <span class="variable language_">id</span>)currentFrame.CGImage;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
<p>YYText中的*<em><strong>YYTextAsyncLayer</strong></em>**覆写了display方法</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">void</span>)display &#123;</span><br><span class="line">    <span class="keyword">super</span>.contents = <span class="keyword">super</span>.contents;</span><br><span class="line"><span class="string">    [self _displayAsync:_displaysAsynchronously]</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>第二个分支开始的时候会创建一个新的backing store,然后开始走drawInContext，这时候会先看delegate是否实现了drawRect如果有则用drawRect,否则调用drawLayer:inContext:并将管理新建backing store的context传递出来。<br>这里需要注意的是drawRect: 方法没有默认的实现，因为对UIView来说，寄宿图并不是必须的，但是如果UIView检测到drawRect: 方法被调用了，它就会为视图分配一个寄宿图。因此如果没有自定义绘制的任务就不要在子类中写一个空的-drawRect:方法。</li>
</ol>
<p><img src="/2019/08/04/iOS-%E6%B8%B2%E6%9F%93%E7%B3%BB%E7%BB%9F%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D/0004.png"></p>
<p>因此只有在创建单独的图层外，我们很少会用到CALayerDelegate，因为在UIView创建了它的Root Layer时，它就会自动地把Root Layer的delegate设置为它自己，并内部提供了-displayLayer:的实现。如果我们需要重新对控件进行自定义也不必实现-displayLayer:和-drawLayer:inContext:方法。通常做法是实现UIView的-drawRect:方法，UIView就会帮你做完剩下的工作，包括在需要重绘的时候调用-display方法。</p>
<h5 id="2-2-Core-Graphics-amp-amp-图片加载"><a href="#2-2-Core-Graphics-amp-amp-图片加载" class="headerlink" title="2.2 Core Graphics &amp;&amp; 图片加载"></a><strong><strong>2.2 Core Graphics &amp;&amp; 图片加载</strong></strong></h5><p>从上面的流程可以看出，可以通过两种方式给一个控件显示需要展示的内容，一种是通过设置layer的contents，一种是通过覆写对应的代理方法，在代理方法中会传出新建backing store的CGContextRef,我们可以使用它向backing store中绘制内容。这里需要注意两点：</p>
<ol>
<li>使用第一种方式的时候，由于从磁盘文件中加载出来的图片文件往往是经过压缩的，因此在将它设置到contents之前需要对图片进行解压，这一步是可以在后台线程完成的，这往往是一个性能优化点。</li>
<li>使用第二种方式的时候需要注意的是这种方式会新建一个backing store所以是十分耗费资源的。这也是尽量不要使用重写drawRect来绘制界面的原因。</li>
</ol>
<p>最后需要明确一点经过这个步骤我们得到的是Bitmap数据，这个Bitmap将会被输送到后续流程。</p>
<h5 id="2-3-在提交到Render-Server前都做了什么工作"><a href="#2-3-在提交到Render-Server前都做了什么工作" class="headerlink" title="2.3 在提交到Render Server前都做了什么工作"></a><strong><strong>2.3 在提交到Render Server前都做了什么工作</strong></strong></h5><p>在一个界面从开始到提交到Render Server前一共可以分成三个步骤：</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="bullet">* </span>Layout</span><br><span class="line"><span class="bullet">* </span>Prepare &amp;&amp; Display</span><br><span class="line"><span class="bullet">* </span>Commit</span><br></pre></td></tr></table></figure>

<h5 id="2-3-1-Layout"><a href="#2-3-1-Layout" class="headerlink" title="2.3.1 Layout"></a><strong><strong>2.3.1 Layout</strong></strong></h5><p>在一个控件被加到界面上的时候，首先会触发控件的布局，从而确定出整个层级树中每个控件的frame。这部分大家可以看下我之前写的iOS布局总结，这里就不做重复介绍了。  </p>
<h5 id="2-3-2-Prepare-amp-amp-Display"><a href="#2-3-2-Prepare-amp-amp-Display" class="headerlink" title="2.3.2 Prepare &amp;&amp; Display"></a><strong><strong>2.3.2 Prepare &amp;&amp; Display</strong></strong></h5><p>这部分主要是由CPU参与，在2.1 和 2.2已经描述得相对比较详细了，这部分会涉及到图片的解码，文本绘制，或者通过CALayer暴露出来的CGContextRef在backing store中进行绘制。图片解码一般发生在Prepare阶段。存储在backing store的 bitmap后续就会被打包送到Render Server中。</p>
<h5 id="2-3-3-Commit"><a href="#2-3-3-Commit" class="headerlink" title="2.3.3 Commit"></a><strong><strong>2.3.3 Commit</strong></strong></h5><p>当RunLoop即将进入休眠期间或者即将退出的时候，会通过已经注册的通知回调执行_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv函数，在这个函数会递归将待处理的图层进行打包压缩，并通过IPC方式发送到Render Server，这里还需要提到一点：这时候的Core Animation会创建一个OpenGL ES纹理并将2.3.2 中backing store中的位图上传到对应的纹理中。</p>
<h5 id="2-4-在送到GPU之前Core-Animation-都做了什处理"><a href="#2-4-在送到GPU之前Core-Animation-都做了什处理" class="headerlink" title="2.4 在送到GPU之前Core Animation 都做了什处理"></a><strong><strong>2.4 在送到GPU之前Core Animation 都做了什处理</strong></strong></h5><p>Render Server在拿到压缩后的数据的时候，首先对这些数据进行解压，从而拿到图层树，然后根据图层树的层次结构，每个层的alpha值opeue值，RGBA值、以及图层的frame值等对被遮挡的图层进行过滤，最终得到渲染树，渲染树就是指将图层树对应每个图层的信息，比如顶点坐标、顶点颜色这些信息，抽离出来，形成的树状结构。渲染树就是下一步送往GPU进行渲染的数据。</p>
<h5 id="2-5-在GPU中做了哪些处理"><a href="#2-5-在GPU中做了哪些处理" class="headerlink" title="2.5 在GPU中做了哪些处理"></a><strong><strong>2.5 在GPU中做了哪些处理</strong></strong></h5><p>这步骤输入的是两类数据，一个是渲染指令，一个是2.4 生成的顶点，以及对应的纹理数据，输出的是像素数据</p>
<p><img src="/2019/08/04/iOS-%E6%B8%B2%E6%9F%93%E7%B3%BB%E7%BB%9F%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D/0006.png"></p>
<p>整个管线从整体来讲可以分成两大阶段：</p>
<ol>
<li>将3D 坐标转换到2D 的屏幕坐标系</li>
<li>把2D 坐标系转换为有颜色的像素值。</li>
</ol>
<p>往细得分可以分成六个阶段：</p>
<ul>
<li>顶点着色器（Vertex Shader）</li>
<li>图元装配（Shape Assembly）</li>
<li>几何着色器（Geometry Shader）</li>
<li>光栅化（Rasterization）</li>
<li>片段着色器（Fragment Shader）</li>
<li>测试与混合（Tests and Blending）</li>
</ul>
<p>下面是整个流程的示意图：</p>
<p>其中蓝色部分是代表着色器，着色器是运行在GPU上的非常独立的可编程小程序，可以通过这些小程序来控制整个管线的各个部分。</p>
<p><img src="/2019/08/04/iOS-%E6%B8%B2%E6%9F%93%E7%B3%BB%E7%BB%9F%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D/0008.png"></p>
<h5 id="2-5-1-顶点着色器"><a href="#2-5-1-顶点着色器" class="headerlink" title="2.5.1 顶点着色器"></a><strong><strong>2.5.1 顶点着色器</strong></strong></h5><p>在Render Server 拿到顶点数据并输入到渲染管线的时候，顶点着色器会对每个顶点数据进行一次运算，每个顶点都对应一组顶点数组，这些数组可以用于存储：顶点坐标，表面法线，RGBA颜色，辅助颜色，颜色索引，雾坐标，纹理坐标以及多边形边界标志等。</p>
<ul>
<li><strong><strong>Step 1 模型坐标系 –&gt; 世界坐标系</strong></strong></li>
</ul>
<p>模型坐标系是为了方便建立模型而设立的坐标，在模型坐标系中我们不用考虑模型显示在屏幕的哪个位置，它是模型的自身坐标系，描述的是模型的各个部分相对于模型原点的坐标值。<br>要理解世界坐标系就需要先理解世界这个概念，在一个世界中可以存在很多模型，打个比方，整个银河系是一个世界，这个世界上存在很多的行星，这里的行星可以看成是一个个模型，模型本身也有它的坐标系，在Step 1 阶段就是将模型安放到制定的世界中，并将模型上的坐标转换为在这个世界中的坐标值。</p>
<p><img src="/2019/08/04/iOS-%E6%B8%B2%E6%9F%93%E7%B3%BB%E7%BB%9F%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D/00010.png"><br><img src="/2019/08/04/iOS-%E6%B8%B2%E6%9F%93%E7%B3%BB%E7%BB%9F%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D/0009.png"></p>
<p>上图第一张为三个茶壶各自的模型坐标系，第二张表示三个茶壶被放置到同一个世界坐标系的时候各个茶壶的坐标情况。</p>
<ul>
<li><strong><strong>Step 2 世界坐标系 –&gt; 相机坐标系</strong></strong></li>
</ul>
<p>在将多个模型放到同一个世界上并拥有同一个世界坐标系后，就需要考虑另一个问题，从哪个视角捕获我们想要的场景，相机坐标系中的坐标，就是从相机的角度来解释世界坐标系中位置，OpenGL中相机始终位于原点，指向-Z轴，而以相反的方式来调整场景中物体，从而达到相同的观察效果。</p>
<p><img src="/2019/08/04/iOS-%E6%B8%B2%E6%9F%93%E7%B3%BB%E7%BB%9F%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D/00011.png"></p>
<ul>
<li><strong><strong>Step 3 相机坐标系 –&gt; 裁剪坐标系</strong></strong></li>
</ul>
<p>投影是顺着相机的视角，将物体投射到屏幕上，投影方式有很多种，OpenGL中主要使用两种方式，即透视投影和正交投影，经过投影后我们获得的是二维的图像。</p>
<p><img src="/2019/08/04/iOS-%E6%B8%B2%E6%9F%93%E7%B3%BB%E7%BB%9F%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D/00012.png"></p>
<ul>
<li><strong><strong>Step 4 规范化设备坐标系 –&gt; 屏幕坐标系</strong></strong></li>
</ul>
<p>这个步骤最终决定生成的二维图像到底显示在屏幕的什么位置和显示窗口的大小。</p>
<h5 id="2-5-2-图元装配"><a href="#2-5-2-图元装配" class="headerlink" title="2.5.2 图元装配"></a><strong><strong>2.5.2 图元装配</strong></strong></h5><p>该阶段将顶点着色器输出的所有顶点作为输入，并将所有的点装配成指定图元的形状。图元是渲染的单位，用于表示如何渲染顶点数据,OpenGL ES 支持三种图元—– 点、线、三角形。也就是说图元装配的过程就是将顶点连接起来，形成一个个所支持的图元元素。</p>
<h5 id="2-5-3-几何着色器"><a href="#2-5-3-几何着色器" class="headerlink" title="2.5.3 几何着色器"></a><strong><strong>2.5.3 几何着色器</strong></strong></h5><p>几何着色器把图元形式的一系列顶点的集合作为输入，它可以通过产生新顶点构造出新的图元来生成其他形状，它是一个可选的阶段。</p>
<h5 id="2-5-4-光栅化"><a href="#2-5-4-光栅化" class="headerlink" title="2.5.4 光栅化"></a><strong><strong>2.5.4 光栅化</strong></strong></h5><p>光栅化会把图元映射为最终屏幕上相应的像素，生成供片段着色器使用的片段。在片段着色器运行之前会执行裁切。裁切会丢弃超出你的视图以外的所有像素，用来提升执行效率。</p>
<h5 id="2-5-5-片段着色器"><a href="#2-5-5-片段着色器" class="headerlink" title="2.5.5 片段着色器"></a><strong><strong>2.5.5 片段着色器</strong></strong></h5><p>在经过光栅化后得到的是一个一个片段，在介绍片段着色器之前，先了解下什么是片段，OpenGL中的一个片段是OpenGL渲染一个像素所需的所有数据，它包含位置，颜色，纹理坐标等信息。这些值是由图元的顶点信息进行插值计算得到的。片段着色器的主要目的是计算一个像素的最终颜色，这也是所有OpenGL高级效果产生的地方。通常，片段着色器包含3D场景的数据（比如光照、阴影、光的颜色等等），这些数据可以被用来计算最终像素的颜色。</p>
<p>其中贴图是最重要的部分，我们的 Resources资源中，可以包含纹理等数据，片段着色器可以根据顶点着色器输出的顶点纹理坐标对纹理进行采样，以计算该片段的颜色值。从而调整成各种各样不同的效果图。除了纹理贴图外另一个很重要的功能就是光照特效：我们可以传给片段着色器一个光源位置和光源颜色，就可以根据一定的公式计算出一个新的颜色值，这样就可以实现光照特效。</p>
<h5 id="2-5-6-测试和混合阶段"><a href="#2-5-6-测试和混合阶段" class="headerlink" title="2.5.6 测试和混合阶段"></a><strong><strong>2.5.6 测试和混合阶段</strong></strong></h5><p>这个阶段检测片段的对应的深度值，用它们来判断这个像素是其它物体的前面还是后面，决定是否应该丢弃。这个阶段也会检查alpha值并对物体进行混合(Blend)。所以，即使在片段着色器中计算出来了一个像素输出的颜色，在渲染多个三角形的时候最后的像素颜色也可能完全不同。总得来说这个阶段主要决定同一个位置的物体到底哪一个可以显示在屏幕上以及颜色的混合。</p>
<p>到目前位置我们拿到各个点的最终像素值，最后我们要做的就是将这些像素值写到帧缓存器中，等待VSync信号到来。</p>
<h5 id="2-6-显示的原理"><a href="#2-6-显示的原理" class="headerlink" title="2.6 显示的原理"></a><strong><strong>2.6 显示的原理</strong></strong></h5><p>在介绍显示原理前需要先了解下CRT显示器的原理。CRT 的电子枪会从屏幕的左上角从上到下一行行扫描，扫描完成后显示器就呈现一帧画面，随后电子枪回到初始位置继续下一次扫描。但是这里存在生产者消费者现象，对于屏幕而言它是消费者，而GPU是生产者，为了同步二者的节奏显示器通过用硬件时钟产生一系列的定时信号，当电子枪换到新的一行，准备进行扫描时，显示器会发出一个水平同步信号，简称 HSync，而当一帧画面绘制完成后，电子枪回复到原位，准备画下一帧前，显示器会发出一个垂直同步信号，简称 VSync，并且在显示器和GPU之间使用了双缓存机制，在显示器显示某帧数据的时候，GPU可以往另一个缓存中提交渲染好的数据，在VSync信号到来的时候，视频控制器切换到另一个缓存用于显示，也就是说在Vsync信号到来的时候另一个缓存必须填满渲染数据，也就是之前的步骤必须完成，在iOS设备中，每秒60帧，每帧16.7ms。那么如果在16.7ms还没渲染完呢？这时候视频控制器就不会将缓存切换到未完成的帧，而是继续显示当前的内容。这就给人们带来视觉上的卡顿。因此在UI线程尽量少处理耗时操作。</p>
<p><img src="/2019/08/04/iOS-%E6%B8%B2%E6%9F%93%E7%B3%BB%E7%BB%9F%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D/00013.png"><br><img src="/2019/08/04/iOS-%E6%B8%B2%E6%9F%93%E7%B3%BB%E7%BB%9F%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D/00016.png"></p>
<h5 id="2-7-动画渲染"><a href="#2-7-动画渲染" class="headerlink" title="2.7 动画渲染"></a><strong><strong>2.7 动画渲染</strong></strong></h5><p>iOS 动画的渲染也是基于上述 Core Animation 流水线完成的，所以大致的流程也是类似的，但是它需要CAdisplayLink 定时器协助下完成整个动画。</p>
<p><img src="/2019/08/04/iOS-%E6%B8%B2%E6%9F%93%E7%B3%BB%E7%BB%9F%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D/00014.png"></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1.</span> 调用 animationWithDuration:animations: 方法</span><br><span class="line"><span class="bullet">2.</span> 在 Animation Block 中进行 Layout，Display，Prepare，Commit 等步骤。</span><br><span class="line"><span class="bullet">3.</span> Render Server 根据 Animation 逐帧进行渲染。</span><br></pre></td></tr></table></figure>

<h5 id="3-离屏渲染"><a href="#3-离屏渲染" class="headerlink" title="3.离屏渲染"></a><strong><strong>3.离屏渲染</strong></strong></h5><h5 id="3-1-什么是离屏渲染"><a href="#3-1-什么是离屏渲染" class="headerlink" title="3.1 什么是离屏渲染"></a><strong><strong>3.1 什么是离屏渲染</strong></strong></h5><p>上面介绍的渲染为当前屏幕渲染(On-Screen Rendering)，也就是GPU的操作是在当前用于显示的屏幕缓冲区中进行的，但是还有一种渲染模式为离屏渲染，它发生在某些图层元素未预先合成之前不能直接在当前屏幕上绘制的情况下，这种情况下系统会新开一个缓冲区，在这里进行渲染操作。</p>
<h5 id="3-2-触发离屏渲染的因素"><a href="#3-2-触发离屏渲染的因素" class="headerlink" title="3.2 触发离屏渲染的因素"></a><strong><strong>3.2 触发离屏渲染的因素</strong></strong></h5><p>离屏渲染一般发生在如下几种情况：</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="bullet">* </span>shouldRasterize = YES（开启光栅化）</span><br><span class="line"><span class="bullet">* </span>edge antialiasing（抗锯齿）</span><br><span class="line"><span class="bullet">* </span>group opacity（不透明）</span><br><span class="line"></span><br><span class="line"><span class="bullet">* </span>circleRadius (圆角)</span><br><span class="line"><span class="bullet">* </span>masks（遮罩）</span><br><span class="line"><span class="bullet">* </span>shadows（阴影）</span><br></pre></td></tr></table></figure>

<h5 id="3-3-为什么离屏渲染会比较耗时"><a href="#3-3-为什么离屏渲染会比较耗时" class="headerlink" title="3.3 为什么离屏渲染会比较耗时"></a><strong><strong>3.3 为什么离屏渲染会比较耗时</strong></strong></h5><p>之所以耗时是因为离屏渲染涉及到两个开销较大的操作：</p>
<ol>
<li><strong><strong>创建新缓冲区</strong></strong></li>
</ol>
<p>要想进行离屏渲染，首先要创建一个新的缓冲区。</p>
<ol start="2">
<li><strong><strong>上下文切换</strong></strong></li>
</ol>
<p>离屏渲染的整个过程，需要多次切换上下文环境：先是从当前屏幕切换到离屏；等到离屏渲染结束以后，将离屏缓冲区的渲染结果显示到屏幕上有需要将上下文环境从离屏切换到当前屏幕。而上下文环境的切换是要付出很大代价的。</p>
<p>所以能够避免离屏渲染尽量避免。</p>
<p>下图为Marks离屏渲染过程图，可以看到它其实是分两大部分，一部分用于渲染图层纹理，一部分用于生成遮罩纹理。最后再将这两部分合成。</p>
<p><img src="/2019/08/04/iOS-%E6%B8%B2%E6%9F%93%E7%B3%BB%E7%BB%9F%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D/00015.png"></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/72653360">关于iOS离屏渲染的深入研究</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/23cc01ada2ba">iOS 和常见的离屏渲染Say Goodbye！</a></li>
</ul>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/iOS-%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/">iOS 理论基础</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/iOS-理论基础/">iOS 理论基础</a>
  </div>

</div>



<div class="comments-count">
	
	  	<span></span>
		<a href="/2019/08/04/iOS-渲染系统工作原理介绍/#comments" class="ds-thread-count comments-count-link" data-thread-key="2019/08/04/iOS-渲染系统工作原理介绍/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/08/01/iOS-生命周期/" title="iOS 生命周期" itemprop="url">iOS 生命周期</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Edgar" target="_blank" itemprop="author">Edgar</a>
		
  <p class="article-time">
    <time datetime="2019-07-31T17:30:29.000Z" itemprop="datePublished"> Published 2019-08-01</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h5 id="App-生命周期"><a href="#App-生命周期" class="headerlink" title="App 生命周期"></a><strong><strong>App 生命周期</strong></strong></h5><h6 id="应用程序的五种状态"><a href="#应用程序的五种状态" class="headerlink" title="应用程序的五种状态"></a><strong><strong>应用程序的五种状态</strong></strong></h6><p>应用程序的五种状态：</p>
<ol>
<li><p><strong><strong>未运行状态</strong></strong>：程序尚未启动，或者应用正在运行但是中途被系统停止，当设备内存紧张的时候，也会将挂起的应用当前状态写入到内存，然后退出应用并释放内存，这时候我们虽然能够在任务栏看到图标，但是它已经退出，我们称之为应用墓碑。</p>
</li>
<li><p><strong><strong>未激活状态</strong></strong>：当前应用正在前台运行，但是焦点被其他抢去。比较典型的是用户锁屏或者离开应用去响应来电，信息等事件等时候。还有一种是比较常见的就是在不同状态切换的时候会短暂处于该状态,这时候App会停止运行，但是依然占用内存空间，用于保存当前状态。</p>
</li>
<li><p><strong><strong>激活状态</strong></strong>：当前应用正常运行，应用焦点在当前应用上，所有的事件都会被分发到当前应用，这时应用占用内存和CPU时间。</p>
</li>
<li><p><strong><strong>后台状态</strong></strong>：当前应用还是存活的，并且能够执行代码，但是默认处于这种情况的时间不长（最多十分钟），当我们按下Home键的时候会进入后台状态，如果不继续申请在后台运行的时间会快速进入挂起状态。</p>
</li>
<li><p><strong><strong>挂起状态</strong></strong>: 应用处在后台，并且已经停止执行代码。这时候应用还驻留在内存中，并没有被系统完全回收，只有在系统发出低内存告警的时候，系统才会把处于挂起状态的应用清除出内存给前台正在运行的应用。这时候不占用CPU资源，但是内存依然占用。</p>
</li>
</ol>
<h6 id="AppDelegate"><a href="#AppDelegate" class="headerlink" title="AppDelegate"></a><strong><strong>AppDelegate</strong></strong></h6><p>App 生命周期的切换会通过AppDelegate来通知开发者，因此我们可以在AppDelegate中的关键方法中注入我们需要的逻辑从而完成任务，下面是一些常见方法：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">//告诉代理进程启动但还没进入状态保存</span></span><br><span class="line">- (<span class="type">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application willFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions</span><br><span class="line"><span class="comment">// 启动基本完成,程序准备开始运行</span></span><br><span class="line">- (<span class="type">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions</span><br><span class="line"><span class="comment">// 当应用程序将要进入非活动状态执行，在此期间，应用程序不接收消息或事件，比如打来电话</span></span><br><span class="line">- (<span class="type">void</span>)applicationWillResignActive:(<span class="built_in">UIApplication</span> *)application</span><br><span class="line"><span class="comment">// 当应用程序进入活动状态执行，此方法跟上面那个方法相反</span></span><br><span class="line">- (<span class="type">void</span>)applicationDidBecomeActive:(<span class="built_in">UIApplication</span> *)application</span><br><span class="line"><span class="comment">// 当程序被推送到后台的时候调用。所以要设置后台继续运行，则在这个函数里面设置即可</span></span><br><span class="line">- (<span class="type">void</span>)applicationDidEnterBackground:(<span class="built_in">UIApplication</span> *)application</span><br><span class="line"><span class="comment">// 当程序从后台将要重新回到前台时候调用，此方法跟上面的那个方法相反</span></span><br><span class="line">- (<span class="type">void</span>)applicationWillEnterForeground:(<span class="built_in">UIApplication</span> *)application</span><br><span class="line"><span class="comment">// 当程序将要退出是被调用，通常是用来保存数据和一些退出前的清理工作</span></span><br><span class="line">- (<span class="type">void</span>)applicationWillTerminate:(<span class="built_in">UIApplication</span> *)application </span><br></pre></td></tr></table></figure>

<p><img src="/2019/08/01/iOS-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/00002.png"></p>
<h6 id="一些关键场景下的状态及回调"><a href="#一些关键场景下的状态及回调" class="headerlink" title="一些关键场景下的状态及回调"></a><strong><strong>一些关键场景下的状态及回调</strong></strong></h6><ul>
<li>应用冷启动：</li>
</ul>
<p><img src="/2019/08/01/iOS-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/00003.png"><br><img src="/2019/08/01/iOS-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/00004.gif"></p>
<p>相关方法：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">-<span class="selector-attr">[AppDelegate application:didFinishLaunchingWithOptions:]</span></span><br><span class="line">-<span class="selector-attr">[AppDelegate applicationDidBecomeActive:]</span> </span><br></pre></td></tr></table></figure>

<ul>
<li>应用热启动 - 点击图标再次打开程序:</li>
</ul>
<p><img src="/2019/08/01/iOS-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/00007.png"><br><img src="/2019/08/01/iOS-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/00008.gif"></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">-<span class="selector-attr">[AppDelegate applicationWillEnterForeground:]</span></span><br><span class="line">-<span class="selector-attr">[AppDelegate applicationDidBecomeActive:]</span></span><br></pre></td></tr></table></figure>

<ul>
<li>解锁:</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">-<span class="selector-attr">[AppDelegate applicationWillEnterForeground:]</span></span><br><span class="line">-<span class="selector-attr">[AppDelegate applicationDidBecomeActive:]</span></span><br></pre></td></tr></table></figure>

<ul>
<li>按下home键，应用进入后台：</li>
</ul>
<p><img src="/2019/08/01/iOS-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/00005.png"><br><img src="/2019/08/01/iOS-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/00006.gif"></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">-<span class="selector-attr">[AppDelegate applicationWillResignActive:]</span></span><br><span class="line">-<span class="selector-attr">[AppDelegate applicationDidEnterBackground:]</span></span><br></pre></td></tr></table></figure>

<ul>
<li>锁屏：</li>
</ul>
<p><img src="/2019/08/01/iOS-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/000011.gif"></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">-<span class="selector-attr">[AppDelegate applicationWillResignActive:]</span></span><br><span class="line">-<span class="selector-attr">[AppDelegate applicationDidEnterBackground:]</span></span><br></pre></td></tr></table></figure>

<ul>
<li>其他应用中断了当前应用：</li>
</ul>
<p><img src="/2019/08/01/iOS-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/00009.png"><br><img src="/2019/08/01/iOS-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/000010.gif"></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">-<span class="selector-attr">[AppDelegate applicationWillResignActive:]</span></span><br></pre></td></tr></table></figure>

<p>返回</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">-<span class="selector-attr">[AppDelegate applicationDidBecomeActive:]</span></span><br></pre></td></tr></table></figure>

<h6 id="如何优化性能"><a href="#如何优化性能" class="headerlink" title="如何优化性能"></a><strong><strong>如何优化性能</strong></strong></h6><p>主要是如下几个地方：</p>
<ol>
<li>applicationWillResignActive: 在应用失去焦点的时候：<br>可以停止视频播放，游戏播放，减少帧率，挂起不必要的操作队列。</li>
<li>applicationDidEnterBackground：在应用进入后台的时候：<br>这时候需要保存用户数据或状态信息，在进入后台时，写到磁盘去，因为程序可能在后台被杀死。再有就是释放尽可能释放的内存。<br>可以通过去掉对大图片，大视频，大文件的强引用，在回收的时候就可以先回收这部分资源。</li>
<li>applicationWillTerminate：在系统内存中，必须清除无用数据，但是这个方法有时间限制，默认是5s。<br>如果超过时间还有未完成的任务，我们的程序就会被终止而且从内存中清除</li>
</ol>
<h5 id="App后台限制"><a href="#App后台限制" class="headerlink" title="App后台限制"></a><strong><strong>App后台限制</strong></strong></h5><p>iOS设备为了节省电量一般会使用假后台机制</p>
<p>我们开发的应用在用户按下Home之后，App会转入后台运行，系统默认会给应用短暂的后台时间（iOS7 180s，iOS6 600s），来让用户做一些必要的处理，如果这段时间过去之后，还是可以告诉系统未完成任务，还需要点时间，通过向系统发出申请来争取更多的时间，系统批准申请后可以继续运行，但是不会超过10分钟。这10分钟过去之后，无论怎么向系统申请，系统都会挂起应用，直到用户再次点击后才会继续运行。但是这对于一些应用是完全不够的，比如一款即时通讯软件，一般在后台都需要保持长链接不断，才能保证应用在后台还能收到消息，再比如你的音乐播放器软件，即使处于后台你也希望它能够继续播放音乐。<br>当然iOS也并非全部任务都不能在后台执行，某些任务比如播放音频,获取位置更新,或者从服务器获取最新内容这些任务是可以在后台长时间运行的，只要我们在应用的配置中，指定应用包含这些服务，一旦审核通过，就可以让我们在后台长时间执行任务，而不会被挂起，具体有哪些模式可以在Capabilities 下的Background Mode中选定指定的类型。</p>
<p><img src="/2019/08/01/iOS-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/00001.png"></p>
<p>下面有个较好的关于Background Mode的翻译文章可以看下<br>中文翻译:<a target="_blank" rel="noopener" href="https://github.com/hehonghui/iOS-tech-frontier/blob/master/issue-3/iOS%E5%90%8E%E5%8F%B0%E6%A8%A1%E5%BC%8F%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97.md">iOS后台模式开发指南</a></p>
<p>英文原著:<a target="_blank" rel="noopener" href="https://www.raywenderlich.com/5817-background-modes-tutorial-getting-started">Background Modes Tutorial: Getting Started</a></p>
<p>但是我们最常见的是通过backgroundTaskIdentifier来申请后台运行的时间，下面是关键代码：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)applicationDidEnterBackground:(<span class="built_in">UIApplication</span> *)application &#123;</span><br><span class="line">    <span class="keyword">self</span>.backgroundTaskIdentifier = [application beginBackgroundTaskWithExpirationHandler:^&#123;</span><br><span class="line">        <span class="comment">//后台任务到期，取消任务</span></span><br><span class="line">        [application endBackgroundTask:<span class="keyword">self</span>.backgroundTaskIdentifier];</span><br><span class="line">        <span class="keyword">self</span>.backgroundTaskIdentifier = <span class="built_in">UIBackgroundTaskInvalid</span>;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)applicationWillEnterForeground:(<span class="built_in">UIApplication</span> *)application &#123;</span><br><span class="line">    <span class="comment">//进入前台的时候取消任务</span></span><br><span class="line">    [application endBackgroundTask:<span class="keyword">self</span>.backgroundTaskIdentifier];</span><br><span class="line">    <span class="keyword">self</span>.backgroundTaskIdentifier = <span class="built_in">UIBackgroundTaskInvalid</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="UIViewController生命周期"><a href="#UIViewController生命周期" class="headerlink" title="UIViewController生命周期"></a><strong><strong>UIViewController生命周期</strong></strong></h5><p><img src="/2019/08/01/iOS-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/000012.png"></p>
<h6 id="生命周期方法介绍"><a href="#生命周期方法介绍" class="headerlink" title="生命周期方法介绍"></a><strong><strong>生命周期方法介绍</strong></strong></h6><h6 id="1-load、initialize、init"><a href="#1-load、initialize、init" class="headerlink" title="1. load、initialize、init"></a><strong><strong>1. load、initialize、init</strong></strong></h6><ul>
<li>在main函数执行前，会初始化objc运行时环境，这时会加载所有类并调用类的load方法，一般在这个方法中实现方法交换(Method Swizzle);</li>
<li>initialize方法会在类第一次收到消息之前被调用，可以用来初始化静态变量；</li>
<li>init用来在类的内存被设置好后初始化成员变量.</li>
</ul>
<h6 id="2-initWithCoder、initWithNibName、awakeFromNib"><a href="#2-initWithCoder、initWithNibName、awakeFromNib" class="headerlink" title="2. initWithCoder、initWithNibName、awakeFromNib"></a><strong><strong>2. initWithCoder、initWithNibName、awakeFromNib</strong></strong></h6><ul>
<li>initWithCoder:反归档,如果对象是从文件解析来的就会调用。</li>
<li>awakeFromNib:从xib或者storyboard加载完毕会调用。</li>
<li>initWithNibName:使用代码创建对象的时候会调用这个方法。</li>
</ul>
<p>用storyboard创建界面的顺序：</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">initialize</span> -&gt;</span> <span class="function"><span class="title">initWithCoder</span> -&gt;</span> <span class="function"><span class="title">awakeFromNib</span> -&gt;</span> loadView</span><br></pre></td></tr></table></figure>
<p>用Xib或者纯代码创建界面的顺序：</p>
<p>如果用init函数来初始化：</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">initialize</span> -&gt;</span> <span class="function"><span class="title">init</span> -&gt;</span> <span class="function"><span class="title">initWithNibName</span> -&gt;</span> loadView</span><br></pre></td></tr></table></figure>

<p>如果用initWithNibName函数来初始化：</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">initialize</span> -&gt;</span> <span class="function"><span class="title">initWithNibName</span> -&gt;</span> loadView</span><br></pre></td></tr></table></figure>

<h6 id="3-loadView"><a href="#3-loadView" class="headerlink" title="3. loadView"></a><strong><strong>3. loadView</strong></strong></h6><ul>
<li><p>当你alloc并init了一个ViewController时，这个ViewController是还没有创建view的.</p>
</li>
<li><p>loadView用于加载控制器管理的 view，不能直接手动调用该方法</p>
</li>
<li><p>UIViewController的self.view是通过懒加载方式创建的，每次调用控制器的view属性时并且view为nil时，loadView函数就会被调用.加载成功后接着调用viewDidLoad函数，如果self.view已经是非空的情况下会直接调用viewDidLoad函数。</p>
</li>
<li><p>如果在loadView函数中自定义了view，那么xib、storyboard中对页面的设置会失效，因为它是在加载之后调用的，所以如果使用 Interface Builder创建view，则务必不要重写该方法</p>
</li>
<li><p>[super loadView]默认的逻辑:如果控制器由xib或storyboard初始化,那么会根据xib或storyboard的传入的名字来初始化view；如果没有显示的指定名称，就默认加载和控制器同名的文件；如果没有找到文件，就会创建一个空白的UIView，这个view的frame为屏幕的大小。所以在覆写该方法的时候不应该再调用父类的该方法。</p>
</li>
</ul>
<h6 id="4-viewDidLoad"><a href="#4-viewDidLoad" class="headerlink" title="4. viewDidLoad"></a><strong><strong>4. viewDidLoad</strong></strong></h6><ul>
<li>在loadView执行完成后，view将会被加载到内存这时候调用viewDidLoad主要完成界面的初始化，例如添加子控件，以及约束的初始化</li>
</ul>
<h6 id="5-viewWillAppear"><a href="#5-viewWillAppear" class="headerlink" title="5. viewWillAppear"></a><strong><strong>5. viewWillAppear</strong></strong></h6><ul>
<li>每次进入页面都会执行viewWillAppear，该方法中可以进行操作即将显示的 view。</li>
</ul>
<h6 id="6-updateViewConstraints"><a href="#6-updateViewConstraints" class="headerlink" title="6. updateViewConstraints"></a><strong><strong>6. updateViewConstraints</strong></strong></h6><ul>
<li>在该函数中用于更新视图的约束.在控制器的view更新视图布局时，会调用updateViewConstraints函数,可以重写这个函数来更新当前视图的布局.这个函数只有在Autolayout布局的时候才会被调用。初始化约束时，最好写到init或viewDidLoad类似的函数中，updateViewConstraints适合于更新约束</li>
</ul>
<h6 id="7-viewWillLayoutSubviews"><a href="#7-viewWillLayoutSubviews" class="headerlink" title="7. viewWillLayoutSubviews"></a><strong><strong>7. viewWillLayoutSubviews</strong></strong></h6><ul>
<li><p>该方法在通知控制器将要布局 view 的子控件时调用。</p>
</li>
<li><p>在这个函数中布局子视图，如果用了Autolayout,那么会在viewWillLayoutSubviews和viewDidLayoutSubviews之间用Autolayout机制布局，但是需要注意的是该方法调用时，AutoLayout 未起作用。</p>
</li>
</ul>
<h6 id="8-viewDidLayoutSubviews"><a href="#8-viewDidLayoutSubviews" class="headerlink" title="8. viewDidLayoutSubviews"></a><strong><strong>8. viewDidLayoutSubviews</strong></strong></h6><ul>
<li>控制器的子视图的布局已完成，这里获取的frame才是最正确的frame。如果用约束来布局，在该函数去设置视图的frame 是无效的。如果用frame来布局的，在该函数中去设置视图的frame是有效的。self.view在该函数中去设置frame是有效的。该方法调用时，AutoLayout 已经完成。</li>
</ul>
<h6 id="9-viewDidAppear"><a href="#9-viewDidAppear" class="headerlink" title="9. viewDidAppear"></a><strong><strong>9. viewDidAppear</strong></strong></h6><ul>
<li>该方法在控制器 view 已经添加到视图层次时被调用</li>
</ul>
<h6 id="10-viewWillDisappear"><a href="#10-viewWillDisappear" class="headerlink" title="10. viewWillDisappear"></a><strong><strong>10. viewWillDisappear</strong></strong></h6><ul>
<li>view即将消失的时候调用</li>
</ul>
<h6 id="11-viewDidDisappear"><a href="#11-viewDidDisappear" class="headerlink" title="11. viewDidDisappear"></a><strong><strong>11. viewDidDisappear</strong></strong></h6><ul>
<li>该方法在控制器 view 已经从视图层次移除时被调用</li>
</ul>
<h6 id="12-dealloc"><a href="#12-dealloc" class="headerlink" title="12. dealloc"></a><strong><strong>12. dealloc</strong></strong></h6><ul>
<li>用于释放自身持有的资源.</li>
</ul>
<h6 id="13-didReceiveMemoryWarning"><a href="#13-didReceiveMemoryWarning" class="headerlink" title="13. didReceiveMemoryWarning"></a><strong><strong>13. didReceiveMemoryWarning</strong></strong></h6><p>当系统内存不足时，当前控制器以及所在的Navigation堆栈上的控制器都会调用didReceiveMemoryWarning函数.该函数会判断当前控制器的view是否显示在window上，如果没有会将view以及子view全部销毁.</p>
<h6 id="14-UI相关代码规范"><a href="#14-UI相关代码规范" class="headerlink" title="14 UI相关代码规范"></a><strong><strong>14 UI相关代码规范</strong></strong></h6><ol>
<li>ViewController init里不要调用self.view,一般在init里应该只有关键数据的初始化。</li>
<li>如果确实需要重写loadView，在重写的代码中只初始化view，其他的工作放在viewDidLoad方法中完成。</li>
<li>viewDidLoad 这时候view已经有了，可以创建并添加界面上的其他子视图，以及设置这些视图的属性。</li>
<li>viewWillAppear 这个一般在view被添加到superview之前，切换动画之前调用，一般可以用于弹出键盘，status bar和navigationbar颜色设置等。</li>
<li>viewWillLayoutSubViews&#x2F;viewDidLayoutSubviews  viewDidLayoutSubviews的时候frame值已经确定了，可以在这里做一些依赖frame的操作</li>
<li>viewDidAppear 这时候view已经被加入到superview上了。</li>
</ol>
<p>下面是View加载的流程：</p>
<p><img src="/2019/08/01/iOS-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/000013.png"></p>
<p>下面是View卸载的流程：</p>
<p><img src="/2019/08/01/iOS-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/000014.png"></p>
<h5 id="UIView-的关键函数"><a href="#UIView-的关键函数" class="headerlink" title="UIView 的关键函数"></a><strong><strong>UIView 的关键函数</strong></strong></h5><ul>
<li><strong><strong>didAddSubview</strong></strong><blockquote>
<p>Tells the view that a subview was added.</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>当前View添加子View的时候会被调用</p>
</blockquote>
<blockquote>
<p>The default implementation of this method does nothing. Subclasses can override it to perform additional actions when subviews are added. This method is called in response to adding a subview using any of the relevant view methods.</p>
</blockquote>
<figure class="highlight erlang"><table><tr><td class="code"><pre><span class="line">- <span class="params">(void)</span>didAddSubview:<span class="params">(UIView *)</span>subview;</span><br></pre></td></tr></table></figure>


<ul>
<li><strong><strong>willMoveToSuperview</strong></strong></li>
</ul>
<blockquote>
<p>Tells the view that its superview is about to change to the specified superview.</p>
</blockquote>
<blockquote>
<p>在某个View的SuperView改变的时候会调用这个方法</p>
</blockquote>
<blockquote>
<p>The default implementation of this method does nothing. Subclasses can override it to perform additional actions whenever the superview changes.</p>
</blockquote>
<figure class="highlight erlang"><table><tr><td class="code"><pre><span class="line">- <span class="params">(void)</span>willMoveToSuperview:<span class="params">(UIView *)</span>newSuperview;</span><br></pre></td></tr></table></figure>


<ul>
<li><strong><strong>didMoveToSuperview</strong></strong></li>
</ul>
<blockquote>
<p>Tells the view that its superview changed.</p>
</blockquote>
<blockquote>
<p>在view已经添加到superview上的时候被调用</p>
</blockquote>
<blockquote>
<p>The default implementation of this method does nothing. Subclasses can override it to perform additional actions whenever the superview changes.</p>
</blockquote>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">- (void)didMoveToSuperview<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong><strong>willMoveToWindow</strong></strong></li>
</ul>
<blockquote>
<p>Tells the view that its window object is about to change.</p>
</blockquote>
<blockquote>
<p>在view的window将要发生改变的时候调用,这个在willDisapear之后的阶段</p>
</blockquote>
<blockquote>
<p>The default implementation of this method does nothing. Subclasses can override it to perform additional actions whenever the window changes.</p>
</blockquote>
<figure class="highlight erlang"><table><tr><td class="code"><pre><span class="line">- <span class="params">(void)</span>willMoveToWindow:<span class="params">(UIWindow *)</span>newWindow;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><strong>didMoveToWindow</strong></strong></li>
</ul>
<blockquote>
<p>Tells the view that its window object changed.</p>
</blockquote>
<blockquote>
<p>在view的window发生改变的时候调用,这个在willDisapear之后的阶段</p>
</blockquote>
<blockquote>
<p>The default implementation of this method does nothing. Subclasses can override it to perform additional actions whenever the window changes.</p>
</blockquote>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">- (void)didMoveToWindow<span class="comment">;</span></span><br></pre></td></tr></table></figure>


<ul>
<li><strong><strong>willRemoveSubview</strong></strong></li>
</ul>
<blockquote>
<p>Tells the view that a subview is about to be removed.</p>
</blockquote>
<blockquote>
<p>在子view将要被移除的时候调用</p>
</blockquote>
<blockquote>
<p>The default implementation of this method does nothing. Subclasses can override it to perform additional actions whenever subviews are removed. This method is called when the subview’s superview changes or when the subview is removed from the view hierarchy completely.</p>
</blockquote>
<figure class="highlight erlang"><table><tr><td class="code"><pre><span class="line">- <span class="params">(void)</span>willRemoveSubview:<span class="params">(UIView *)</span>subview;</span><br></pre></td></tr></table></figure>


<ul>
<li><strong><strong>removeFromSuperview</strong></strong></li>
</ul>
<blockquote>
<p>Unlinks the view from its superview and its window, and removes it from the responder chain.</p>
</blockquote>
<blockquote>
<p>将当前View从父View和它的window，以及响应链移除</p>
</blockquote>
<blockquote>
<p>If the view’s superview is not nil, the superview releases the view.Calling this method removes any constraints that refer to the view you are removing, or that refer to any view in the subtree of the view you are removing.</p>
</blockquote>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">- (void)removeFromSuperview<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>下面是在界面上添加一个view 然后在view的各个关键节点上加上log输出的结果：</p>
<figure class="highlight mel"><table><tr><td class="code"><pre><span class="line">-[IDLViewController viewDidLoad] :@@@==viewDidLoad</span><br><span class="line">-[IDLQuarzCoreSampleView willMoveToSuperview:] :@@@======================================willMoveToSuperview:</span><br><span class="line">-[IDLQuarzCoreSampleView didMoveToSuperview] :@@@======================================didMoveToSuperview</span><br><span class="line">-[IDLViewController onViewWillAppear:] :@@@==onViewWillAppear</span><br><span class="line">-[IDLQuarzCoreSampleView willMoveToWindow:] :@@@======================================willMoveToWindow:</span><br><span class="line">-[IDLQuarzCoreSampleView didMoveToWindow] :@@@======================================didMoveToWindow</span><br><span class="line">-[IDLViewController updateViewConstraints] :@@@==updateViewConstraints</span><br><span class="line">-[IDLViewController viewWillLayoutSubviews] :@@@==viewWillLayoutSubviews</span><br><span class="line">-[IDLViewController viewDidLayoutSubviews] :@@@==viewDidLayoutSubviews</span><br><span class="line">-[IDLViewController viewWillLayoutSubviews] :@@@==viewWillLayoutSubviews</span><br><span class="line">-[IDLViewController viewDidLayoutSubviews] :@@@==viewDidLayoutSubviews</span><br><span class="line">-[IDLQuarzCoreSampleView layoutSubviews] :@@@======================================layoutSubviews</span><br><span class="line">-[IDLQuarzCoreSampleView drawRect:] :@@@======================================drawRect:</span><br><span class="line">-[IDLViewController onViewDidAppear:] :@@@==onViewDidAppear</span><br></pre></td></tr></table></figure>

<p>下面是让viewcontroller不可见时候的调用log输出：</p>
<figure class="highlight mel"><table><tr><td class="code"><pre><span class="line">-[IDLViewController onViewWillDisappear:] :@@@==onViewWillDisappear</span><br><span class="line">-[IDLQuarzCoreSampleView willMoveToWindow:] :@@@======================================willMoveToWindow:</span><br><span class="line">-[IDLQuarzCoreSampleView didMoveToWindow] :@@@======================================didMoveToWindow</span><br><span class="line">-[IDLViewController onViewDidDisappear:] :@@@==onViewDidDisappear</span><br></pre></td></tr></table></figure>

<p>从上面结果我们做个总结：</p>
<ol>
<li><p>在ViewController viewDidLoad 之后，我们会在父view调用addSubView，将当前view添加到superView上面，这时候会调用当前view的willMoveToSuperview，didMoveToSuperview方法，这之后再去寻找自己的subView并依次添加。在添加子view的过程中didAddSubview会被反复调用。等到所有的subView都在内存层面加载完成了，会调用一次viewWillAppear，这时候会调用当前view的willMoveToWindow，didMoveToWindow然后会把加载好的一层层view，分别绘制到window上面。然后layoutSubview，drawRect，最后onViewDidAppear。</p>
</li>
<li><p>UIView生命周期移除阶段。会先调用willMoveToWindow表示当前view将会从window上移除，继而调用didMoveToWindow，这里需要注意的是这时候传入的window为nil，然后再removeFromSuperView，dealloc，dealloc之后再removeSubview。</p>
</li>
<li><p>如果没有子视图，则不会接收到didAddSubview和willRemoveSubview消息。</p>
</li>
<li><p>和superView，window相关的方法，可以通过参数判断是创建还是销毁，如果指针不为空，是创建，如果为空，就是销毁。</p>
</li>
<li><p>removeFromSuperview和dealloc在view的生命周期中，调且只调用一次，可以用来removeObserver，移除计时器等操作。</p>
</li>
</ol>
<p>UIView约束，布局，绘图介绍iOS渲染的那篇博客已经介绍过了，但是这里还是把这块再拎出来介绍下，毕竟不是很大块。</p>
<ul>
<li><strong><strong>约束相关</strong></strong></li>
</ul>
<p><img src="/2019/08/01/iOS-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/000016.png"></p>
<ul>
<li><p><strong><strong>监控约束变化</strong></strong> : APP启动后，随着RunLoop的运行，系统在其内部监听着约束变化（Constraints Change）：如激活或失效约束、修改优先级、修改常量值，添加，删除视图等操作，都可以导致约束发生变化。</p>
</li>
<li><p><strong><strong>重新计算布局</strong></strong> : 在接收到布局变化后，布局引擎会根据变化的约束重新计算布局，并通过对其父视图调用setNeedsLayout方法将需要更新布局的视图进行标记，之后便进入延迟布局阶段（Deffered Layout Pass）。这里需要注意的是在进入延迟布局阶段之前，Layout Engine已经将更新的约束计算完毕并将视图的新frame求出。但并不在此时更新视图。</p>
</li>
<li><p><strong><strong>延迟布局阶段</strong></strong> ：此阶段的主要作用是将错误位置的视图重新定位。其在视图层级中执行，分为两步：</p>
</li>
<li><p>更新约束：从下往上（子视图到父视图），依次遍历视图层级，调用View的updateConstraints方法（或ViewController的updateViewConstraints方法）来更新约束,我们可以在此覆盖本方法来设置自定义约束，且在此设置时，执行效率最高。记得最后调用父类实现。</p>
</li>
<li><p>给视图及子视图重新设定位置（给view的frame赋值）：从上到下依次调用View的layoutSubViews方法（或ViewController的viewLayoutSubViews方法），从Layout Engine中取出预算好的frame进行赋值。</p>
</li>
</ul>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="bullet">* </span>setNeedsUpdateConstraints：标记需要updateConstraints。</span><br><span class="line"><span class="bullet">* </span>updateConstraintsIfNeeded：若需要，马上调用updateConstraints应用约束更新。</span><br><span class="line"><span class="bullet">* </span>needsUpdateConstraints：返回是否需要updateConstraints。</span><br><span class="line"><span class="bullet">* </span>updateConstraints：更新约束，在这里一般只针对某个view的现有约束进行更新，约束的初始化一般放在viewDidLoad方法中，注意：要在最后调用[super updateConstraints]</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><strong>布局相关</strong></strong></li>
</ul>
<pre><code>* layoutSubviews:在需要进行布局的时候会调用这个方法，我们可以通过覆写这个方法来确定每个view的frame。
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">手动触发layoutSubviews：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
* setNeedsLayout:此方法会将view当前的layout设置为无效的，并在下一个upadte cycle里去触发layout更新。
* layoutIfNeeded:使用此方法强制立即进行layout,从当前view开始，此方法会遍历整个view层次(包括superviews)请求layout。因此，调用此方法会强制整个view层次布局。
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">哪些条件下会自动触发layoutSubviews：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
1、init初始化不会触发layoutSubviews，但是用initWithFrame进行初始化的时候，当rect的值不是CGRectZero时也会触发
2、addSubview会触发layoutSubviews。
3、设置view的frame会触发layoutSubviews，当然前提是frame的值设置前后发生了变化。
4、改变一个UIView大小的时候也会触发父UIView上的layoutSubviews事件。
5、滚动一个UIScrollView会触发layoutSubviews。
6、旋转屏幕会触发父UIView上的layoutSubviews事件。

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="bullet">*</span> <span class="strong">****</span>绘制相关<span class="strong">****</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
* setNeedsDisplay:标记整个视图的边界矩形需要重绘.
* drawRect:如果你的View画自定义的内容，就要实现该方法。若使用UIView绘图，只能在drawRect：方法中获取相应的ContextRef并绘图,其他方法中获取将获取到一个invalidate 的ContextRef不能用于绘制。
* 若使用CAlayer绘图，只能在drawInContext: 中绘制,或者在Delegate中的相应方法绘制.
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="section">哪些条件下会自动触发drawRect:</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
* 如果在UIView初始化时没有设置rect大小将直接导致drawRect不被自动调用。drawRect 调用是在loadView,viewDidLoad 两方法之后掉用的.所以可以在控制器中设置一些在draw阶段需要的值。
* 该方法在调用sizeToFit后被调用，所以可以先调用sizeToFit计算出size。然后系统自动调用drawRect:方法。
* 通过设置contentMode属性值为UIViewContentModeRedraw。那么将在每次设置或更改frame的时候自动调用drawRect:。
* 直接调用setNeedsDisplay，或者setNeedsDisplayInRect:触发drawRect:但是有个前提条件是rect不能为0。
 <figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="bullet">*</span> 这些方法在UIViewController生命周期的位置：</span><br><span class="line"><span class="code">    在一个UIView init初始化后会把三个标记都置为YES。然后在VC的布局方式中,viewWillLayoutSubviews中会调用updateConstraints，在viewDidLayoutSubviews会调用layoutSubviews，drawRect。</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">    其中updateConstraints是子 -&gt; 父。layoutSubviews和drawRect是父 -&gt; 子。</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="bullet">*</span> sizeToFit</span><br><span class="line"></span><br></pre></td></tr></table></figure>
* sizeToFit会自动调用sizeThatFits方法；
* sizeToFit不应该在子类中被重写，应该重写sizeThatFits
* sizeThatFits传入的参数是receiver当前的size，返回一个适合的size
* sizeToFit可以被手动直接调用
* sizeToFit和sizeThatFits方法都没有递归，只负责自己
```

最后来一张总结的图，来自之前的一篇博客《图解生命周期》
![](/iOS-生命周期/000015.png)


###### TODO App 保活方案
</code></pre>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/iOS-%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/">iOS 理论基础</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/iOS-理论基础/">iOS 理论基础</a>
  </div>

</div>



<div class="comments-count">
	
	  	<span></span>
		<a href="/2019/08/01/iOS-生命周期/#comments" class="ds-thread-count comments-count-link" data-thread-key="2019/08/01/iOS-生命周期/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/07/28/iOS-设计规范整理/" title="iOS 设计规范整理" itemprop="url">iOS 设计规范整理</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Edgar" target="_blank" itemprop="author">Edgar</a>
		
  <p class="article-time">
    <time datetime="2019-07-28T03:45:26.000Z" itemprop="datePublished"> Published 2019-07-28</time>
    
  </p>
</header>
    <div class="article-content">
        
        
        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>



<div class="comments-count">
	
	  	<span></span>
		<a href="/2019/07/28/iOS-设计规范整理/#comments" class="ds-thread-count comments-count-link" data-thread-key="2019/07/28/iOS-设计规范整理/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/07/26/iOS-音视频专题目录篇/" title="iOS 音视频专题目录篇" itemprop="url">iOS 音视频专题目录篇</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Edgar" target="_blank" itemprop="author">Edgar</a>
		
  <p class="article-time">
    <time datetime="2019-07-25T18:28:52.000Z" itemprop="datePublished"> Published 2019-07-26</time>
    
  </p>
</header>
    <div class="article-content">
        
        
        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>



<div class="comments-count">
	
	  	<span></span>
		<a href="/2019/07/26/iOS-音视频专题目录篇/#comments" class="ds-thread-count comments-count-link" data-thread-key="2019/07/26/iOS-音视频专题目录篇/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>







  <nav id="page-nav" class="clearfix">
    <a class="extend prev" rel="prev" href="/page/7/">&lt;span&gt;&lt;&#x2F;span&gt;Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><a class="page-number" href="/page/10/">10</a><span class="space">&hellip;</span><a class="page-number" href="/page/30/">30</a><a class="extend next" rel="next" href="/page/9/">Next&lt;span&gt;&lt;&#x2F;span&gt;</a>
  </nav>

</div>
      <div class="openaside"><a class="navbutton" href="#" title="Show Sidebar"></a></div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="Hide Sidebar"></a></div>
<aside class="clearfix">
<div id="authorInfo">
	
		<div class="author-img"></div>		
	
	<div class="social-info" class="clearfix">
		
		
		<a href="https://github.com/tbfungeek" target="_blank" class="icon-github" title="github"></a>
		
		
		
		
		
		
		
		
		
		
		<a href="mailto:tbfungeek@163.com" target="_blank" class="icon-email" title="Email Me"></a>
		

	</div>
</div>

  
<div class="categorieslist">
	<p class="asidetitle">Categories</p>
		<ul>
		
		  
			<li><a href="/categories/Android-小经验/" title="Android 小经验">Android 小经验<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Android-源码分析/" title="Android 源码分析">Android 源码分析<sup>21</sup></a></li>
		  
		
		  
			<li><a href="/categories/Android其他/" title="Android其他">Android其他<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Android初步/" title="Android初步">Android初步<sup>21</sup></a></li>
		  
		
		  
			<li><a href="/categories/Android进阶/" title="Android进阶">Android进阶<sup>100</sup></a></li>
		  
		
		  
			<li><a href="/categories/Hexo-使用/" title="Hexo 使用">Hexo 使用<sup>10</sup></a></li>
		  
		
		  
			<li><a href="/categories/JavaScript理论/" title="JavaScript理论">JavaScript理论<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Objective-C-相关/" title="Objective C 相关">Objective C 相关<sup>24</sup></a></li>
		  
		
		  
			<li><a href="/categories/OpenCV/" title="OpenCV">OpenCV<sup>6</sup></a></li>
		  
		
		  
			<li><a href="/categories/ROS/" title="ROS">ROS<sup>9</sup></a></li>
		  
		
		  
			<li><a href="/categories/iOS-工具使用/" title="iOS 工具使用">iOS 工具使用<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/iOS-开源库分析/" title="iOS 开源库分析">iOS 开源库分析<sup>36</sup></a></li>
		  
		
		  
			<li><a href="/categories/iOS-理论基础/" title="iOS 理论基础">iOS 理论基础<sup>14</sup></a></li>
		  
		
		  
			<li><a href="/categories/iOS-进阶/" title="iOS 进阶">iOS 进阶<sup>4</sup></a></li>
		  
		
		  
			<li><a href="/categories/个人收藏/" title="个人收藏">个人收藏<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/代码规范/" title="代码规范">代码规范<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/其他/" title="其他">其他<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/博客分类目录/" title="博客分类目录">博客分类目录<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/叨叨系列/" title="叨叨系列">叨叨系列<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/开源代码分析/" title="开源代码分析">开源代码分析<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/开源库分析/" title="开源库分析">开源库分析<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/树莓派/" title="树莓派">树莓派<sup>4</sup></a></li>
		  
		
		  
			<li><a href="/categories/版本控制/" title="版本控制">版本控制<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/直播/" title="直播">直播<sup>6</sup></a></li>
		  
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">Tags</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/iOS-开源库分析/" title="iOS 开源库分析">iOS 开源库分析<sup>36</sup></a></li>
			
		
			
				<li><a href="/tags/Android-设计模式/" title="Android 设计模式">Android 设计模式<sup>29</sup></a></li>
			
		
			
				<li><a href="/tags/Objective-C-相关/" title="Objective C 相关">Objective C 相关<sup>24</sup></a></li>
			
		
			
				<li><a href="/tags/Android基础/" title="Android基础">Android基础<sup>21</sup></a></li>
			
		
			
				<li><a href="/tags/AOSP-源码/" title="AOSP 源码">AOSP 源码<sup>17</sup></a></li>
			
		
			
				<li><a href="/tags/Android-常用第三方库/" title="Android 常用第三方库">Android 常用第三方库<sup>15</sup></a></li>
			
		
			
				<li><a href="/tags/iOS-理论基础/" title="iOS 理论基础">iOS 理论基础<sup>14</sup></a></li>
			
		
			
				<li><a href="/tags/Hexo-使用/" title="Hexo 使用">Hexo 使用<sup>10</sup></a></li>
			
		
			
				<li><a href="/tags/ROS/" title="ROS">ROS<sup>9</sup></a></li>
			
		
			
				<li><a href="/tags/Android-动画进阶/" title="Android 动画进阶">Android 动画进阶<sup>8</sup></a></li>
			
		
			
				<li><a href="/tags/Android-JNI/" title="Android JNI">Android JNI<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/Android-绘图进阶/" title="Android 绘图进阶">Android 绘图进阶<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/Android性能优化/" title="Android性能优化">Android性能优化<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/Android-自动化测试/" title="Android 自动化测试">Android 自动化测试<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/OpenCV/" title="OpenCV">OpenCV<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/直播/" title="直播">直播<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/Android-开源源码/" title="Android 开源源码">Android 开源源码<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/Android-自定义View进阶/" title="Android 自定义View进阶">Android 自定义View进阶<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/树莓派/" title="树莓派">树莓派<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/iOS-进阶/" title="iOS 进阶">iOS 进阶<sup>4</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">Links</p>
    <ul>
        
          <li>
            
            	<a href="https://hexo.io" target="_blank" title="Hexo">Hexo</a>
            
          </li>
        
          <li>
            
            	<a href="https://pages.github.com/" target="_blank" title="GitHub">GitHub</a>
            
          </li>
        
          <li>
            
            	<a href="http://pf18.github.io/" target="_blank" title="PF18">PF18</a>
            
          </li>
        
          <li>
            
            	<a href="http://toutiao.io/" target="_blank" title="开发者头条">开发者头条</a>
            
          </li>
        
          <li>
            
            	<a href="http://www.jcodecraeer.com/" target="_blank" title="泡在网上的日子">泡在网上的日子</a>
            
          </li>
        
    </ul>
</div>

  


  <div class="rsspart">
	<a href="atom.xml" target="_blank" title="rss">RSS</a>
</div>

  
  <div class="tagcloudlist">
    <p class="asidetitle">Tag Cloud</p>
    <div class="tagcloudlist clearfix">
       <a href="/tags/AOSP-%E6%BA%90%E7%A0%81/" style="font-size: 17.14px;">AOSP 源码</a> <a href="/tags/Android-APK-%E7%AD%BE%E5%90%8D/" style="font-size: 10px;">Android APK 签名</a> <a href="/tags/Android-JNI/" style="font-size: 12.86px;">Android JNI</a> <a href="/tags/Android-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E8%BF%9B%E9%98%B6/" style="font-size: 10.71px;">Android 事件处理进阶</a> <a href="/tags/Android-%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6/" style="font-size: 13.57px;">Android 动画进阶</a> <a href="/tags/Android-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%80%E5%8F%91/" style="font-size: 10px;">Android 多线程开发</a> <a href="/tags/Android-%E5%B0%8F%E7%BB%8F%E9%AA%8C/" style="font-size: 10px;">Android 小经验</a> <a href="/tags/Android-%E5%B8%B8%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/" style="font-size: 16.43px;">Android 常用第三方库</a> <a href="/tags/Android-%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/" style="font-size: 10px;">Android 开发流程</a> <a href="/tags/Android-%E5%BC%80%E6%BA%90%E6%BA%90%E7%A0%81/" style="font-size: 12.14px;">Android 开源源码</a> <a href="/tags/Android-%E7%BB%98%E5%9B%BE%E8%BF%9B%E9%98%B6/" style="font-size: 12.86px;">Android 绘图进阶</a> <a href="/tags/Android-%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/" style="font-size: 12.86px;">Android 自动化测试</a> <a href="/tags/Android-%E8%87%AA%E5%AE%9A%E4%B9%89View%E8%BF%9B%E9%98%B6/" style="font-size: 12.14px;">Android 自定义View进阶</a> <a href="/tags/Android-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 19.29px;">Android 设计模式</a> <a href="/tags/Android%E5%85%B6%E4%BB%96/" style="font-size: 10px;">Android其他</a> <a href="/tags/Android%E5%9F%BA%E7%A1%80/" style="font-size: 17.86px;">Android基础</a> <a href="/tags/Android%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/" style="font-size: 10px;">Android开发流程</a> <a href="/tags/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" style="font-size: 12.86px;">Android性能优化</a> <a href="/tags/Android%E6%B7%B7%E6%B7%86%E6%8A%80%E6%9C%AF/" style="font-size: 10px;">Android混淆技术</a> <a href="/tags/Android%E8%B4%A8%E9%87%8F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/" style="font-size: 11.43px;">Android质量管理工具</a> <a href="/tags/Android%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/" style="font-size: 10px;">Android逆向工程</a> <a href="/tags/Git-github/" style="font-size: 10px;">Git && github</a> <a href="/tags/Hexo-%E4%BD%BF%E7%94%A8/" style="font-size: 15px;">Hexo 使用</a> <a href="/tags/JavaScript/" style="font-size: 10px;">JavaScript</a> <a href="/tags/Linux-%E4%BD%BF%E7%94%A8/" style="font-size: 10px;">Linux 使用</a> <a href="/tags/Objective-C-%E7%9B%B8%E5%85%B3/" style="font-size: 18.57px;">Objective C 相关</a> <a href="/tags/OpenCV/" style="font-size: 12.86px;">OpenCV</a> <a href="/tags/ROS/" style="font-size: 14.29px;">ROS</a> <a href="/tags/iOS-%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/" style="font-size: 10.71px;">iOS 工具使用</a> <a href="/tags/iOS-%E5%BC%80%E6%BA%90%E5%BA%93%E5%88%86%E6%9E%90/" style="font-size: 20px;">iOS 开源库分析</a> <a href="/tags/iOS-%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/" style="font-size: 15.71px;">iOS 理论基础</a> <a href="/tags/iOS-%E8%BF%9B%E9%98%B6/" style="font-size: 12.14px;">iOS 进阶</a> <a href="/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/" style="font-size: 10px;">代码规范</a> <a href="/tags/%E5%8D%9A%E5%AE%A2%E5%88%86%E7%B1%BB%E7%9B%AE%E5%BD%95/" style="font-size: 10.71px;">博客分类目录</a> <a href="/tags/%E5%8F%A8%E5%8F%A8%E7%B3%BB%E5%88%97/" style="font-size: 10px;">叨叨系列</a> <a href="/tags/%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/" style="font-size: 11.43px;">工具的使用</a> <a href="/tags/%E5%BC%80%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/" style="font-size: 10.71px;">开源代码分析</a> <a href="/tags/%E5%BC%80%E6%BA%90%E5%BA%93%E5%88%86%E6%9E%90/" style="font-size: 10px;">开源库分析</a> <a href="/tags/%E6%9D%82%E7%B1%BB/" style="font-size: 10px;">杂类</a> <a href="/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/" style="font-size: 12.14px;">树莓派</a> <a href="/tags/%E7%9B%B4%E6%92%AD/" style="font-size: 12.86px;">直播</a> <a href="/tags/%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/" style="font-size: 10.71px;">编程技巧</a> <a href="/tags/%E7%BD%91%E7%AB%99%E6%94%B6%E8%97%8F/" style="font-size: 10px;">网站收藏</a> <a href="/tags/%E9%87%8D%E8%A6%81%E6%8E%A7%E4%BB%B6/" style="font-size: 11.43px;">重要控件</a>
    </div>
  </div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
		
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/hsihohuang/kiddochan" target="_blank" title="Kiddochan">Kiddochan</a> © 2022 
		
		<a href="/about" target="_blank" title="Edgar">Edgar</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
        
    }
  });
});
</script>










<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?7c9443b0374f1cf6b1dbb5ab84d939cb";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="Back to Top"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
 </html>
