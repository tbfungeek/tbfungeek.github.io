
 <!DOCTYPE HTML>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
  
    <title>Edgar&#39;s Blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="Edgar">
    

    
    <meta name="description" content="Android | 全栈工程师">
<meta property="og:type" content="website">
<meta property="og:title" content="Edgar&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/page/27/index.html">
<meta property="og:site_name" content="Edgar&#39;s Blog">
<meta property="og:description" content="Android | 全栈工程师">
<meta property="og:locale">
<meta property="article:author" content="Edgar">
<meta name="twitter:card" content="summary">

    
    <link rel="alternative" href="atom.xml" title="Edgar&#39;s Blog" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/unnamed4_n_mSY_icon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/profile.png">
    <link rel="apple-touch-icon-precomposed" href="/img/profile.png">
    
    
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 6.2.0"></head>

  <body>
    <header>
      
<div>
		
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="Edgar&#39;s Blog">Edgar&#39;s Blog</a></h1>
				<h2 class="blog-motto"></h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="Menu">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
					<li>
 					
					<form class="search" action="/search/index.html" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" autocomplete="off" name="q" maxlength="20" placeholder="Search" />
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main">

   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/03/25/Android-初步之Android组件-Service/" title="Android 初步之Android组件  Service" itemprop="url">Android 初步之Android组件  Service</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Edgar" target="_blank" itemprop="author">Edgar</a>
		
  <p class="article-time">
    <time datetime="2016-03-25T05:32:04.000Z" itemprop="datePublished"> Published 2016-03-25</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h4 id="Service-特点"><a href="#Service-特点" class="headerlink" title="Service 特点"></a>Service 特点</h4><ul>
<li>适用于耗时操作，并且不需要与用户交互的功能。</li>
<li>其他应用程序组件能够启动服务并且即使用户切换到另一个应用，服务还可以在后台运行。</li>
<li>组件能够绑定到服务并与之交互，甚至执行进程间通信。</li>
<li>Service 比处于非活动状态的Activity更高的优先级，因此当系统请求资源时，它们被终止的可能性很小。如果运行时过早得终止了一个已经启动的Service，只要有足够的资源可用，则运行时就会重新启动它。</li>
<li>一个Service的优先级可以提升到和前台Activity的优先级一样高。</li>
<li>开发人员可以将服务设为私有从而阻止其他应用程序访问。</li>
<li>虽然Service在运行的时候没有专门的GUI，但是它们和Acitivity以及BroadCast Receiver一样还是运行在应用程序进程的主线程中，因此必须通过Thread和AsyncTask类把耗时的进程移到后台进程中。通过使用独立的线程，开发人员能减少应用不相应错误的风险，并且应用程序主线程仍然用于用户与Activity交互。</li>
</ul>
<h4 id="Service-的类型"><a href="#Service-的类型" class="headerlink" title="Service 的类型"></a>Service 的类型</h4><ul>
<li>Started Service：当应用程序组件通过调用startService()方法启动服务时候，服务处于started状态。一旦启动，服务能够在后台无期限运行，即使启动它的组件已经被销毁。通常，Started Service执行单个操作并且不会向调用者返回结果。如果操作完成，服务需要停止自身.</li>
<li>Bound Service :当应用程序通过bindService()方法绑定到服务的时候，服务处于bound状态，绑定服务提供客户端-服务器接口，以允许组件与服务交互，发送请求，获得结果，甚至使用进程间通信跨进程完成这些操作。仅当其他应用程序组件与之绑定的时候，绑定服务才能运行。多个组件可以绑定到一个服务上。只有在他们都解除绑定的时候服务被销毁。<br>服务也可以同时属于上述两种类型既可以启动，无限期运行，可能绑定。这取决于是否实现一些回调方法:onStartCommand()方法允许组件启动，onBind方法允许组件绑定服务。</li>
</ul>
<h4 id="Service的生命周期"><a href="#Service的生命周期" class="headerlink" title="Service的生命周期"></a>Service的生命周期</h4><ol>
<li>OnStarted方式启动<br><img src="/2016/03/25/Android-%E5%88%9D%E6%AD%A5%E4%B9%8BAndroid%E7%BB%84%E4%BB%B6-Service/1.png"></li>
<li>OnBound方式启动<br><img src="/2016/03/25/Android-%E5%88%9D%E6%AD%A5%E4%B9%8BAndroid%E7%BB%84%E4%BB%B6-Service/2.png"></li>
</ol>
<ul>
<li><p>onStartCommand()<br>当其他组件，如Activity调用startService()方法请求服务启动的时候，系统调用该方法，一旦该方法执行，服务就启动，并在后台无限期运行。如果开发人员实现该方法，则需要在任务完成时候调用stopSelf()或者stopService()方法停止服务。</p>
</li>
<li><p>onBind()<br>当其他组件调用bindService方法想与服务绑定的时候，系统调用该方法，在该方法的实现中，开发人员必须通过返回IBinder提供客户端用来与服务通信的接口。该方法必须实现，但是如果不想允许绑定，则应该返回null;</p>
</li>
<li><p>onCreate()<br>当服务第一创建时，系统调用该方法执行一次性建立(在系统调用onStartCommand()或onBind()方法前)如果服务已经运行，该方法不被调用，从而保证在Android系统中一个Service只有一个实例。</p>
</li>
<li><p>onDestroy()<br>当服务不再使用并即将销毁时，系统调用该方法。服务应该实现该方法来清除诸如线程，注册监听器，接收者等资源。这是服务受到的最后调用。</p>
</li>
</ul>
<h4 id="Service的声明"><a href="#Service的声明" class="headerlink" title="Service的声明"></a>Service的声明</h4><p>开发人员必须在应用程序配置文件中声明全部的Service，方法是在<application>标签中添加<service>子标签。<br><img src="/2016/03/25/Android-%E5%88%9D%E6%AD%A5%E4%B9%8BAndroid%E7%BB%84%E4%BB%B6-Service/3.png"></service></application></p>
<h4 id="创建Service"><a href="#创建Service" class="headerlink" title="创建Service"></a>创建Service</h4><h5 id="一般方式创建"><a href="#一般方式创建" class="headerlink" title="一般方式创建"></a>一般方式创建</h5><p>应用程序组件例如Activity能通过StartService()方法或者传递Intent对象来启动服务，在Intent对象中指定了服务并且包含服务所需要的全部数据，服务使用onStartCommand方法接收Intent。<br>实验及结果分析:代码见TestService</p>
<ul>
<li>按下Start Service 启动服务，这是输出结果如下:<br><img src="/2016/03/25/Android-%E5%88%9D%E6%AD%A5%E4%B9%8BAndroid%E7%BB%84%E4%BB%B6-Service/4.png"></li>
<li>按下后退键和Home键，不会输出onDestroy，说明即使按下这两个键，服务仍然在后台运行，可以在Setting-&gt;Application 中查看到。</li>
<li>再次点击App图标进入输出如下结果：说明一个Service在Android 系统中只存在一个实例，在已经存在的情况下不会再次调用onCreate创建新的Service。<br><img src="/2016/03/25/Android-%E5%88%9D%E6%AD%A5%E4%B9%8BAndroid%E7%BB%84%E4%BB%B6-Service/5.png"></li>
<li>按下StopService，结果如下:<br><img src="/2016/03/25/Android-%E5%88%9D%E6%AD%A5%E4%B9%8BAndroid%E7%BB%84%E4%BB%B6-Service/6.png"></li>
</ul>
<h5 id="继承IntentService类"><a href="#继承IntentService类" class="headerlink" title="继承IntentService类"></a>继承IntentService类</h5><p>IntentService:这是Service的子类，它每次使用一个工作线程来处理全部启动请求，在不必同时处理多个请求时候，这是最佳选择。开发人员需要实现onHandleIntent方法，它接收每次启动请求的Intent以便完成后台的任务</p>
<ul>
<li>创建区别于主线程的默认工作线程来执行发送到onStartCommand方法的全部Intent</li>
<li>创建工作队列每次传递一个Intent到onHandleIntent方法实现，这样就不必担心多线程。</li>
<li>所有启动请求处理完毕后停止服务，这样就不要调用stopself方法。<br>实现方法：</li>
<li>提供OnBind方法实现，其返回值是null;</li>
<li>提供onStartCommand方法的默认实现，它先发送Intent到默认队列，然后到onHandleIntent方法实现。<br>我们要做的工作就是实现onHandleIntent方法，同时由于IntentService并没有提供空参数的构造方法因此必须提供一个构造方法。<br>例子：</li>
</ul>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public <span class="keyword">class</span> HelloIntentService extends IntentService &#123;</span><br><span class="line">	public <span class="constructor">HelloIntentService()</span> &#123;</span><br><span class="line">		super(<span class="string">&quot;Hello Service&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	protected void on<span class="constructor">HandleIntent(Intent <span class="params">intent</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">		long endTime = <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>current<span class="constructor">TimeMillis()</span>+<span class="number">5</span>*<span class="number">1000</span>;</span><br><span class="line">		<span class="keyword">while</span>(<span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>current<span class="constructor">TimeMillis()</span>&lt;endTime)&#123;</span><br><span class="line">			synchronized (this) &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					wait(endTime-<span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>current<span class="constructor">TimeMillis()</span>);</span><br><span class="line">				&#125; catch (InterruptedException e) &#123;</span><br><span class="line">					e.print<span class="constructor">StackTrace()</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;;</span><br><span class="line">			<span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">&quot;onHandleIntent&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	public <span class="built_in">int</span> on<span class="constructor">StartCommand(Intent <span class="params">intent</span>, <span class="params">int</span> <span class="params">flags</span>, <span class="params">int</span> <span class="params">startId</span>)</span> &#123;</span><br><span class="line">		<span class="module-access"><span class="module"><span class="identifier">Toast</span>.</span></span>make<span class="constructor">Text(<span class="params">this</span>, <span class="string">&quot;Server Start:  &quot;</span>+<span class="string">&quot;flags:&quot;</span>+<span class="params">flags</span>+<span class="string">&quot;start ID:&quot;</span>+<span class="params">startId</span>, Toast.LENGTH_LONG)</span>.show<span class="literal">()</span>;</span><br><span class="line">		return super.on<span class="constructor">StartCommand(<span class="params">intent</span>, <span class="params">flags</span>, <span class="params">startId</span>)</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	public IBinder on<span class="constructor">Bind(Intent <span class="params">intent</span>)</span> &#123;</span><br><span class="line">		return null;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Button btn = null;</span><br><span class="line">protected void on<span class="constructor">Create(Bundle <span class="params">savedInstanceState</span>)</span> &#123;</span><br><span class="line">    super.on<span class="constructor">Create(<span class="params">savedInstanceState</span>)</span>;</span><br><span class="line">    set<span class="constructor">ContentView(R.<span class="params">layout</span>.<span class="params">activity_main</span>)</span>;</span><br><span class="line">    btn = (Button) find<span class="constructor">ViewById(R.<span class="params">id</span>.<span class="params">btn</span>)</span>;</span><br><span class="line">    btn.set<span class="constructor">OnClickListener(<span class="params">new</span> OnClickListener()</span> &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void on<span class="constructor">Click(View <span class="params">arg0</span>)</span> &#123;</span><br><span class="line">            Intent intent= <span class="keyword">new</span> <span class="constructor">Intent(MainActivity.<span class="params">this</span>,HelloIntentService.<span class="params">class</span>)</span>;</span><br><span class="line">            start<span class="constructor">Service(<span class="params">intent</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实验结果分析：</p>
<p>按下Start IntentService 后输出如下结果:<br>从结果可以看出，IntentService 会在onHandleIntent方法中处理业务逻辑部分，同时在处理完成后会自动销毁服务，而不需调用stopself&#x2F;stopService方法。（调用StopService方法不会调用onDestroy方法销毁服务）</p>
<p><img src="/2016/03/25/Android-%E5%88%9D%E6%AD%A5%E4%B9%8BAndroid%E7%BB%84%E4%BB%B6-Service/7.png"></p>
<h5 id="继承Service类"><a href="#继承Service类" class="headerlink" title="继承Service类"></a>继承Service类</h5><p>使用IntentService类可以简化启动服务的实现，然而，如果需要让服务处理多线程，取代使用工作队列启动请求，也就是说为每次请求创建一个新线程并且立即运行它们，避免等待前一个请求的结束，则可以继承Service类来处理各个Intent<br>Service:是所有服务的基类，当继承该类的时候，创建新线程来执行服务的全部工作是非常重要的，因为默认服务默认是使用应用程序主线程，这可能会降低应用程序Activity的运行性能。<br>这种方法要自己使用stopself或者stopService方法结束服务，并且需要自己创建线程来处理服务的内部逻辑<br>使用这种方式的时候onStartCommand必须返回一个整数。用于表示系统停止服务后如何继续服务。</p>
<figure class="highlight pf"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>. START_NOT_STICKY:如果系统在<span class="keyword">on</span>StartCommand方法返回后停止服务，则系统不会重新创建服务，除非有PendingIntent要发送。在避免在不必要时运行服务和应用程序能简单地重启任何未完成工作的时候，这是最佳选择。</span><br><span class="line"><span class="number">2</span>. START_STICKY:如果系统在<span class="keyword">on</span>StartCommand方法返回后停止服务，则系统会重新创建服务并调用<span class="keyword">on</span>StartCommand方法。但是不重新发送最后的Intent，相反系统使用空Intent调用<span class="keyword">on</span>StartCommand方法，除非有PeddingIntent来启动服务。此时，这些Intent会发送。这适合多媒体播放器，它们不执行命令但是无限期运行并等待工作。</span><br><span class="line"><span class="number">3</span>. START_REDELIVER_INTENT:如果系统在<span class="keyword">on</span>StartCommand方法返回后停止服务，重新创建服务并使用发送给服务的最后Intent调用<span class="keyword">on</span>StartCommand方法，全部PenddingIntent必须依次发送，这适合积极执行应该立即恢复工作的服务。如下载文件。</span><br></pre></td></tr></table></figure>

<h4 id="启动和停止服务"><a href="#启动和停止服务" class="headerlink" title="启动和停止服务"></a>启动和停止服务</h4><p>启动服务不能直接调用onStartCommand方法，而是使用Acitivity或者其他应用程序组件通过传递Intent对象到startService()方法启动服务。Android系统自动调用服务的onStartCommand方法并将Intent传递给它，如果服务还没有运行系统首先调用onCreate()方法，接着调用onStartCommand方法。<br>如果服务没有绑定，StartService方法发送的Intent是应用程序和服务之间唯一的通信方式，然而如果需要获得服务的放回结果，则可以通过启动该服务的客户端能为广播创建PeddingIntent并通过启动服务的Intent发送它，服务接下来能使用广播发送结果。</p>
<p>Started Service方式的服务，系统不会停止或者销毁它，它的生命周期必须自己管理。除非它必须回收系统内存并且在onStartCommand方法返回后服务继续运行，因此服务必须调用stopSelf方法停止自身或者其他组件调用stopService方法停止服务。<br>stopself(startid)方法可以确保停止服务的请求总是基于最近接收到的启动请求。</p>
<h4 id="创建Bound-Service"><a href="#创建Bound-Service" class="headerlink" title="创建Bound Service"></a>创建Bound Service</h4><p>绑定服务是允许其他应用程序绑定并且与之交互的Service类实现类。为了提供绑定，开发人员必须实现onBind回调方法。该方法返回iBinder对象，它定义了客户端用来与服务交互的程序接口.<br>客户端能通过bindService方法绑定到服务，此时客户端必须提供ServiceConnection接口的实现类。它监视客户端与服务之间的联系，bindService立刻放回，但是当Android系统创建客户端与服务之间的连接时，它调用ServiceConnection 接口中的onServiceConnection方法来发送客户端用来发送与服务通信的IBinder对象。<br>多个客户端能够同时连接到服务，但是仅当第一个客户端绑定的时候，系统调用服务的onBind方法来获取Ibinder对象，系统接着发送同一个IBinder对象到其他的绑定的客户端但是不再调用onBind方法,当最后的客户端与服务解除绑定的时候，系统销毁服务。<br><img src="/2016/03/25/Android-%E5%88%9D%E6%AD%A5%E4%B9%8BAndroid%E7%BB%84%E4%BB%B6-Service/8.png"><br><img src="/2016/03/25/Android-%E5%88%9D%E6%AD%A5%E4%B9%8BAndroid%E7%BB%84%E4%BB%B6-Service/9.png"></p>
<h4 id="绑定和解除绑定"><a href="#绑定和解除绑定" class="headerlink" title="绑定和解除绑定"></a>绑定和解除绑定</h4><p>应用程序能调用bindService方法绑定到服务，android系统接下来调用服务的onBind方法，它返回IBinder来与服务通信。绑定是异步的bindService方法立刻返回，为了接收IBinder。客户端必须创建ServiceConnection实例然后传递到bindService方法。<br>只有Activity，Service，Content Provider能够绑定到服务，BroadcastReceiver不能绑定到服务。<br>如果需要从客户端绑定服务需要完成如下工作:</p>
<ol>
<li>实现ServiceConnection这需要重写onServiceConnected和onserviceDisconnected方法</li>
<li>调用bindService传递ServiceConnection实现。</li>
<li>当系统调用onServiceConnected方法的时候，就可以使用接口定义的方法。</li>
<li>调用unbindService解除绑定。</li>
</ol>
<h4 id="将Service移到前台"><a href="#将Service移到前台" class="headerlink" title="将Service移到前台"></a>将Service移到前台</h4><p>在确定哪个应用程序或者应用程序组件可以被终止的时候，Android给正在运行的Service赋予了第二高的优先级，仅仅次于处于激活状态，并且在前台与用户交互的活动Acitivity，在Service需要直接和用户进行交互的情况下，可以将Service的优先级提高到和前台Activity一样高，可以通过调用Service的startForeground方法来将一个服务移到前台，同样可以调用stopForeground来将一个服务移到后台。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> NOTIFICATION_ID = <span class="number">1</span>;</span><br><span class="line">Intent intent = <span class="keyword">new</span> <span class="constructor">Intent(<span class="params">this</span>, MainActivity.<span class="params">class</span>)</span>;</span><br><span class="line">PendingIntent pi = <span class="module-access"><span class="module"><span class="identifier">PendingIntent</span>.</span></span>get<span class="constructor">Activity(<span class="params">this</span>, 1, <span class="params">intent</span>, 0)</span>;</span><br><span class="line">Notification notification = <span class="keyword">new</span> <span class="constructor">Notification(R.<span class="params">drawable</span>.<span class="params">ic_launcher</span>, <span class="string">&quot;前台服务&quot;</span>, System.<span class="params">currentTimeMillis</span>()</span>);</span><br><span class="line">notification.set<span class="constructor">LatestEventInfo(<span class="params">this</span>, <span class="string">&quot;前台服务&quot;</span>, <span class="string">&quot;这个是被移到前台的服务&quot;</span>, <span class="params">pi</span>)</span>;</span><br><span class="line">notification.flags =notification.flags<span class="pattern-match">|<span class="constructor">Notification</span>.<span class="constructor">FLAG_ONGOING_EVENT</span>;</span></span><br><span class="line"><span class="pattern-match">start<span class="constructor">Foreground(NOTIFICATION_ID,<span class="params">notification</span>)</span>;</span></span><br></pre></td></tr></table></figure>
<p><img src="/2016/03/25/Android-%E5%88%9D%E6%AD%A5%E4%B9%8BAndroid%E7%BB%84%E4%BB%B6-Service/10.png"></p>
<h4 id="提升服务存活可能性的方法"><a href="#提升服务存活可能性的方法" class="headerlink" title="提升服务存活可能性的方法"></a>提升服务存活可能性的方法</h4><p><a target="_blank" rel="noopener" href="http://blog.csdn.net/mad1989/article/details/22492519">http://blog.csdn.net/mad1989/article/details/22492519</a></p>
<ul>
<li>onStartCommand方法，返回START_STICKY</li>
<li>提升service优先级<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line">&lt;service  </span><br><span class="line">	android:name=<span class="string">&quot;xxxxxxx&quot;</span>  </span><br><span class="line">	android:enabled=<span class="string">&quot;true&quot;</span> &gt;  </span><br><span class="line">	&lt;intent<span class="params">-filter</span> android:priority=<span class="string">&quot;1000&quot;</span> &gt;  </span><br><span class="line">		<span class="params">...</span><span class="params">...</span><span class="params">...</span><span class="params">...</span><span class="params">...</span>  </span><br><span class="line">	&lt;/intent<span class="params">-filter</span>&gt;  </span><br><span class="line">&lt;/service&gt;  </span><br></pre></td></tr></table></figure></li>
<li>使用startForeground()提升service进程优先级</li>
<li>onDestroy方法里重启service</li>
<li>监听系统广播判断Service状态</li>
<li>将应用升级为系统应用</li>
<li>Application加上Persistent属性</li>
</ul>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line">&lt;application  </span><br><span class="line">	android:name=<span class="string">&quot;xxxxxxxxxxx&quot;</span>  </span><br><span class="line">	android:allowBackup=<span class="string">&quot;true&quot;</span>  </span><br><span class="line">	android:icon=<span class="string">&quot;@drawable/ic_launcher&quot;</span>  </span><br><span class="line">	android:label=<span class="string">&quot;@string/app_name&quot;</span>  </span><br><span class="line">	android:persistent=<span class="string">&quot;true&quot;</span></span><br><span class="line">	android:theme=<span class="string">&quot;@style/AppTheme&quot;</span> &gt;  </span><br><span class="line">&lt;/application&gt;  </span><br></pre></td></tr></table></figure>



        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Android%E5%88%9D%E6%AD%A5/">Android初步</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/Android基础/">Android基础</a>
  </div>

</div>



<div class="comments-count">
	
	  	<span></span>
		<a href="/2016/03/25/Android-初步之Android组件-Service/#comments" class="ds-thread-count comments-count-link" data-thread-key="2016/03/25/Android-初步之Android组件-Service/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/03/24/Android-初步之Android组件-Activity/" title="Android 初步之Android组件  Activity" itemprop="url">Android 初步之Android组件  Activity</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Edgar" target="_blank" itemprop="author">Edgar</a>
		
  <p class="article-time">
    <time datetime="2016-03-24T04:56:56.000Z" itemprop="datePublished"> Published 2016-03-24</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h4 id="Activity-是啥"><a href="#Activity-是啥" class="headerlink" title="Activity 是啥"></a>Activity 是啥</h4><ul>
<li>Activity是用于负责提供用户交互的可视化界面，一个应用程序可以有一个或者多个Activity，一般情况下，每个窗口都是满屏的，但是它也可以是一个小的，位于其他窗口之上的浮动窗口。</li>
<li>Android允许同时运行多个应用程序，应用程序可以拥有前台进程和后台进程，然而在同一时刻只能由一个应用程序的Activity处于前台。</li>
</ul>
<h4 id="Activity-生命周期"><a href="#Activity-生命周期" class="headerlink" title="Activity 生命周期"></a>Activity 生命周期</h4><p><img src="/2016/03/24/Android-%E5%88%9D%E6%AD%A5%E4%B9%8BAndroid%E7%BB%84%E4%BB%B6-Activity/1.png"></p>
<h6 id="完整生命周期："><a href="#完整生命周期：" class="headerlink" title="完整生命周期："></a>完整生命周期：</h6><p>从第一次调用onCreate开始到onDestroy为止，Activity在onCreate中设置所有全局状态以完成初始化，而在onDestroy中释放所有的系统资源：</p>
<ul>
<li><p>onCreate：当一个Activity首次运行的时候被回调，负责初始化任务，onCreate方法仅具有一个传入参数，即一个Bundle对象，但对于首次启动的Activity而言，这个参数为空，如果这个Activity先前因为内存的原因而被终止，现在又需要重新启动，那么Bundle对象中将包含Activity先前的状态信息，这样它才能被重新初始化。<br>主要任务:填充用户UI，将数据绑定到控件，得到Fragment引用，启动Service和定时器</p>
</li>
<li><p>onRestoreInstanceState ：在onCreate方法完成后调用该函数用于恢复UI状态。<br>onRestoreInstanceState 只有在当前视图被系统销毁了时候被调用，因此有时候onSaveInstanceState方法和onRestoreInstanceState方法不一定是成对出现的</p>
</li>
<li><p>onDestroy：销毁Activity的时候被调用。<br>主要任务:确保清除了onCreate创建的所有资源，并保证所有的外部连接如网络或数据库已经被关闭。</p>
</li>
</ul>
<h6 id="可视生命周期"><a href="#可视生命周期" class="headerlink" title="可视生命周期:"></a>可视生命周期:</h6><p>从onStart到onStop。在此期间，用户是可见的但是可能还未获得焦点，尚且不能与用户交互。 在这两个方法之间，可以保留用来向用户显示这个Activity所需要的资源，例如，当用户看不到显示的内容的时候，可以在onStart中注册一个BroadCastReceiver广播接收器来监控可能影响的UI变化，而在onStop中来注销，onStart和onStop方法可以随着应用是否被用户可用而被多次调用。</p>
<ul>
<li>onStart:当一个Activity即将显示时被回调，可见生命周期的开始。在这个阶段可以完成如注册专门用于更新用户界面的BroadCast Receiver等工作。</li>
<li>onStop:停止Activity的时候被调用。当前Activit处于不可视状态。<br>主要任务:暂停或者停止动画，线程，传感器监听器，GPS查找，定时器，启动Service和定时器，或者其他用于更新用户界面的进程，当UI不可见的时候更新它是没有意义的，不但耗费了资源，却没起到实际的作用。当UI再次可用的时候，可使用onStart或者OnRestart方法来恢复或者重启这些线程。</li>
</ul>
<h6 id="前台生命周期"><a href="#前台生命周期" class="headerlink" title="前台生命周期:"></a>前台生命周期:</h6><p>从OnResume调用起，至相应的onPause调用为止，在此期间，Activity位于前台最上面并与用户开始进行交互.</p>
<ul>
<li><p>onResume:这时候该Activity可以接受用户的输入事件，与用户进行交互，同时当Activity由于暂停恢复为活动状态的时候这个方法被调用。调用该方法后，该Activity位于Activity栈顶。在这个方法中不需要重新加载UI状态，因为当要求加载UI状态的时候，它会由onCreate和onRestoreInstanceState方法处理。</p>
</li>
<li><p>onPause:暂停的时候被回调，在该方法中通常用于存储持久的数据，在该方法中应该终止在OnrResume方法中播放的所有音频，视频和动画，同时在该方法中还必须解除某些资源，例如：在手动管理而非自动管理情况下的数据库Cursor对象。onPause方法是Activity在后台最后一次能够有机会进行清理工作，释放无需资源的地方，如果没有及时释放，这些资源将有可能不能被彻底释放掉。同时需要保存所有未提交的数据，以免由于程序终止后不再返回而丢失数据。<br>应该尽量保证在onResume ,onPause方法中代码较少，以保证前台和后台之间进行切换的时候应用程序能够保持响应。在onPause方法中释放越多的资源，转入后台的Activity被终止的可能性就越小。</p>
</li>
<li><p>onSaveInstanceState:这个方法提供了把Activity的UI状态保存在Bundle中的机会，这个Bundle会被传递给onCreate和onRestoreInstanceState方法。一般在这个方法中保存，复选状态，用户焦点，已经输入但未被提交的用户输入，从而保证当Activity下次变成活动的时候，可以呈现出与之前相同的UI。<br>这里需要注意的它是只有在非你本来意愿销毁了你的activity的时候被系统调用。但是在activity是被用户主动销毁的情况下（例如我们人为按下back键）不会被调用，下面是一些常见的情况：</p>
</li>
</ul>
<ol>
<li>当用户按下HOME键时</li>
<li>按下电源键灭屏的时候</li>
<li>从一个Activity A中启动一个新的Activity时。</li>
<li>在指定configchange属性的情况下切换屏幕方向<br>布局中的每一个View默认实现了onSaveInstanceState()方法，这样的话，这个UI的任何改变都会自动的存储并在activity重新创建的时候自动的恢复。但是这种情况只有在你为这个UI提供了唯一的ID之后才起作用，如果没有提供ID，将不会存储它的状态。<br>onSaveInstanceState()如果被调用，这个方法会在onStop()前被触发，但系统并不保证是否在onPause()之前或者之后触发</li>
</ol>
<h6 id="典型的Activity生命周期："><a href="#典型的Activity生命周期：" class="headerlink" title="典型的Activity生命周期："></a>典型的Activity生命周期：</h6><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">启动Activity: <span class="built_in">onCreate</span>()—&gt;<span class="built_in">onStart</span>()—&gt;<span class="built_in">onResume</span>()，Activity进入运行状态。</span><br><span class="line">Activity退居后台，且系统内存不足， 系统会杀死这个后台状态的Activity，若再次回到这个Activity,则会走<span class="built_in">onCreate</span>()–&gt;<span class="built_in">onStart</span>()—&gt;<span class="built_in">onResume</span>()</span><br><span class="line">Activity退居后台: 当前Activity转到新的Activity界面或按Home键回到主屏： <span class="built_in">onPause</span>()—&gt;<span class="built_in">onStop</span>()，进入停滞状态。</span><br><span class="line">Activity返回前台: <span class="built_in">onRestart</span>()—&gt;<span class="built_in">onStart</span>()—&gt;<span class="built_in">onResume</span>()，再次回到运行状态。</span><br><span class="line">锁定屏与解锁屏幕 只会调用<span class="built_in">onPause</span>()，而不会调用<span class="built_in">onStop</span>()方法，开屏后则调用<span class="built_in">onResume</span>()</span><br></pre></td></tr></table></figure>

<h4 id="Activity任务堆栈"><a href="#Activity任务堆栈" class="headerlink" title="Activity任务堆栈"></a>Activity任务堆栈</h4><p>直接上图不解释：<br><img src="/2016/03/24/Android-%E5%88%9D%E6%AD%A5%E4%B9%8BAndroid%E7%BB%84%E4%BB%B6-Activity/2.png"></p>
<p>我们可以通过android:launchMode &#x3D; “standard|singleInstance|singleTask|singleTop”来控制Acivity任务栈。</p>
<figure class="highlight nestedtext"><table><tr><td class="code"><pre><span class="line"><span class="attribute">standard</span><span class="punctuation"> :</span> <span class="string">标准模式,每次启动Activity都会创建一个新的Activity实例,并且将其压入任务栈栈顶,而不管这个Activity是否已经存在。</span></span><br><span class="line"><span class="attribute">singleTop</span><span class="punctuation"> :</span> <span class="string">这种模式下,如果新Activity已经位于任务栈的栈顶,那么此Activity不会被重新创建,同时Activity的onNewIntent()方法会被回调.如果Activity已经存在但是不在栈顶,那么作用于standard模式一样.</span></span><br><span class="line"><span class="attribute">singleTask</span><span class="punctuation">:</span> <span class="string">创建这样的Activity的时候,系统会先确认它所需任务栈已经创建,否则先创建任务栈.然后放入Activity,如果栈中已经有一个Activity实例,那么这个Activity就会被调到栈顶,并调用onNewIntent(),并且singleTask会清理在当前Activity上面的所有Activity.</span></span><br><span class="line"><span class="attribute">singleInstance</span><span class="punctuation"> :</span> <span class="string">这种模式的Activity只能单独位于一个任务栈内,由于栈内复用的特性,后续请求均不会创建新的Activity,除非这个独特的任务栈被系统销毁了</span></span><br></pre></td></tr></table></figure>
<p>如果对上面的不大理解可以参考如下的文章，说的很详细，为了避免作者把文章取消所以把重点的引用如下：<br><a target="_blank" rel="noopener" href="http://www.cnblogs.com/xiaoQLu/archive/2011/09/29/2195742.html">http://www.cnblogs.com/xiaoQLu/archive/2011/09/29/2195742.html</a></p>
<figure class="highlight mathematica"><table><tr><td class="code"><pre><span class="line"><span class="variable">standard</span>：<span class="variable">Activity</span>的默认加载方法，即使某个<span class="variable">Activity</span>在<span class="variable">Task</span>栈中已经存在，另一个<span class="variable">activity</span>通过<span class="variable">Intent</span>跳转到该<span class="variable">activity</span>，同样会新创建一个实例压入栈中。例如：现在栈的情况为：<span class="variable">A</span> <span class="variable">B</span> <span class="built_in">C</span> <span class="built_in">D</span>，在<span class="built_in">D</span>这个<span class="variable">Activity</span>中通过<span class="variable">Intent</span>跳转到<span class="built_in">D</span>，那么现在的栈情况为： <span class="variable">A</span> <span class="variable">B</span> <span class="built_in">C</span> <span class="built_in">D</span> <span class="built_in">D</span> 。此时如果栈顶的<span class="built_in">D</span>通过<span class="variable">Intent</span>跳转到<span class="variable">B</span>，则栈情况为：<span class="variable">A</span> <span class="variable">B</span> <span class="built_in">C</span> <span class="built_in">D</span> <span class="built_in">D</span> <span class="variable">B</span>。此时如果依次按返回键，<span class="built_in">D</span>  <span class="built_in">D</span> <span class="built_in">C</span> <span class="variable">B</span> <span class="variable">A</span>将会依次弹出栈而显示在界面上。</span><br><span class="line"><span class="variable">singleTop</span>：如果某个<span class="variable">Activity</span>的<span class="built_in">Launch</span> <span class="variable">mode</span>设置成<span class="variable">singleTop</span>，那么当该<span class="variable">Activity</span>位于栈顶的时候，再通过<span class="variable">Intent</span>跳转到本身这个<span class="variable">Activity</span>，则将不会创建一个新的实例压入栈中。例如：现在栈的情况为：<span class="variable">A</span> <span class="variable">B</span> <span class="built_in">C</span> <span class="built_in">D</span>。<span class="built_in">D</span>的<span class="built_in">Launch</span> <span class="variable">mode</span>设置成了<span class="variable">singleTop</span>，那么在<span class="built_in">D</span>中启动<span class="variable">Intent</span>跳转到<span class="built_in">D</span>，那么将不会新创建一个<span class="built_in">D</span>的实例压入栈中，此时栈的情况依然为：<span class="variable">A</span> <span class="variable">B</span> <span class="built_in">C</span> <span class="built_in">D</span>。但是如果此时<span class="variable">B</span>的模式也是<span class="variable">singleTop</span>，<span class="built_in">D</span>跳转到<span class="variable">B</span>，那么则会新建一个<span class="variable">B</span>的实例压入栈中，因为此时<span class="variable">B</span>不是位于栈顶，此时栈的情况就变成了：<span class="variable">A</span> <span class="variable">B</span> <span class="built_in">C</span> <span class="built_in">D</span> <span class="variable">B</span>。</span><br><span class="line"><span class="variable">singleTask</span>：如果某个<span class="variable">Activity</span>是<span class="variable">singleTask</span>模式，那么<span class="variable">Task</span>栈中将会只有一个该<span class="variable">Activity</span>的实例。例如：现在栈的情况为：<span class="variable">A</span> <span class="variable">B</span> <span class="built_in">C</span> <span class="built_in">D</span>。<span class="variable">B</span>的<span class="built_in">Launch</span> <span class="variable">mode</span>为<span class="variable">singleTask</span>，此时<span class="built_in">D</span>通过<span class="variable">Intent</span>跳转到<span class="variable">B</span>，则栈的情况变成了：<span class="variable">A</span> <span class="variable">B</span>。而<span class="built_in">C</span>和<span class="built_in">D</span>被弹出销毁了，也就是说位于<span class="variable">B</span>之上的实例都被销毁了。</span><br><span class="line"><span class="variable">singleInstance</span>：将<span class="variable">Activity</span>压入一个新建的任务栈中。例如：<span class="variable">Task</span>栈<span class="number">1</span>的情况为：<span class="variable">A</span> <span class="variable">B</span> <span class="built_in">C</span>。<span class="built_in">C</span>通过<span class="variable">Intent</span>跳转到<span class="built_in">D</span>，而<span class="built_in">D</span>的<span class="built_in">Launch</span> <span class="variable">mode</span>为<span class="variable">singleInstance</span>，则将会新建一个<span class="variable">Task</span>栈<span class="number">2</span>。此时<span class="variable">Task</span>栈<span class="number">1</span>的情况还是为：<span class="variable">A</span> <span class="variable">B</span> <span class="built_in">C</span>。<span class="variable">Task</span>栈<span class="number">2</span>的情况为：<span class="built_in">D</span>。此时屏幕界面显示<span class="built_in">D</span>的内容，如果这时<span class="built_in">D</span>又通过<span class="variable">Intent</span>跳转到<span class="built_in">D</span>，则<span class="variable">Task</span>栈<span class="number">2</span>中也不会新建一个<span class="built_in">D</span>的实例，所以两个栈的情况也不会变化。而如果<span class="built_in">D</span>跳转到<span class="built_in">C</span>，则栈<span class="number">1</span>的情况变成了：<span class="variable">A</span> <span class="variable">B</span> <span class="built_in">C</span> <span class="built_in">C</span>，因为<span class="built_in">C</span>的<span class="built_in">Launch</span> <span class="variable">mode</span>为<span class="variable">standard</span>，此时如果再按返回键，则栈<span class="number">1</span>变成：<span class="variable">A</span> <span class="variable">B</span> <span class="built_in">C</span>。也就是说现在界面还显示<span class="built_in">C</span>的内容，不是<span class="built_in">D</span>。</span><br></pre></td></tr></table></figure>


<h4 id="Activity-状态"><a href="#Activity-状态" class="headerlink" title="Activity 状态"></a>Activity 状态</h4><p>上面介绍了Activity的堆栈接下来就来介绍下，Activity的状态，Activity状态是由其在Activity堆栈的位置决定的：<br><img src="/2016/03/24/Android-%E5%88%9D%E6%AD%A5%E4%B9%8BAndroid%E7%BB%84%E4%BB%B6-Activity/3.png"></p>
<h4 id="Android应用程序生命周期"><a href="#Android应用程序生命周期" class="headerlink" title="Android应用程序生命周期"></a>Android应用程序生命周期</h4><p>Android应用不能控制它们自己的生命周期，它是由Android运行时控制的，默认情况下每个应用程序都是通过它们自己的进程运行的，每个进程都运行在独立的Dalvik实例中，每个应用程序的内存和进程管理都是由运行时专门进行处理的。<br>回收资源的时候，进程被终止的顺序是由它们的应用优先级所决定的，一个应用程序的优先级等同于它的优先级最高的组件的优先级。<br>当两个应用程序优先级相同的时候，在较低优先级状态运行时间最长的进程将会首先被终止。<br>进程的优先级也受进程间依赖性的影响，如果一个应用程序依赖于第二个应用程序所提供的Service或者Content Provider，那么第二个应用程序至少拥有与它所支持的这个应用程序相同的优先级。</p>
<h4 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h4><ol>
<li>活动进程：指的是有组件正在和用户进行交互的应用程序进程，Android尝试回收其他应用状态资源来支持这些进程运行。</li>
</ol>
<p>活动的进程包括:</p>
<ul>
<li>处于活动状态的Activity。</li>
<li>正在运行，且已被标记为前台运行的Service</li>
<li>正在执行onCreate ，onStart，onDestroy事件处理的Service。</li>
<li>正在执行onReceiver 事件处理程序的BroadCast Receiver</li>
</ul>
<ol start="2">
<li><p>可见进程：可见但是非活动的进程是指那些包含“可见”Acitivity的进程。</p>
</li>
<li><p>启动服务进程:已经启动的Service的进程，因为后台Service没有直接和用户交互，所以它的优先级要比可见进程或者前台Service低。</p>
</li>
<li><p>后台进程:不可见并且没有任何正在运行的Service的Activity进程，通常会有大量的后台进程。</p>
</li>
<li><p>空进程:为了提高系统整体性能，Android经常在应用程序的生存周期结束后仍然把它们保存在内存中，Android通过维护这个缓存来减少应用程序被再次启动时的启动时间。<br><img src="/2016/03/24/Android-%E5%88%9D%E6%AD%A5%E4%B9%8BAndroid%E7%BB%84%E4%BB%B6-Activity/4.png"></p>
</li>
</ol>
<h4 id="Activity的创建"><a href="#Activity的创建" class="headerlink" title="Activity的创建"></a>Activity的创建</h4><ol>
<li>创建一个类继承自Activity，并重写相应的方法。</li>
<li>编写布局文件，设置布局。</li>
<li>在Android  Manifest中配置Activity。</li>
</ol>
<h4 id="Activity属性"><a href="#Activity属性" class="headerlink" title="Activity属性"></a>Activity属性</h4><p><img src="/2016/03/24/Android-%E5%88%9D%E6%AD%A5%E4%B9%8BAndroid%E7%BB%84%E4%BB%B6-Activity/5.png"></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Android%E5%88%9D%E6%AD%A5/">Android初步</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/Android基础/">Android基础</a>
  </div>

</div>



<div class="comments-count">
	
	  	<span></span>
		<a href="/2016/03/24/Android-初步之Android组件-Activity/#comments" class="ds-thread-count comments-count-link" data-thread-key="2016/03/24/Android-初步之Android组件-Activity/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/03/23/Android-初步之四大组件/" title="Android 初步之Android组件 Context" itemprop="url">Android 初步之Android组件 Context</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Edgar" target="_blank" itemprop="author">Edgar</a>
		
  <p class="article-time">
    <time datetime="2016-03-23T13:14:37.000Z" itemprop="datePublished"> Published 2016-03-23</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>Android 开发是基于Java环境开发的，但是你如果写过测试用例的话你就会有个感觉就是，它和Java还是有很大区别的，比如你不能随便new一个类让它运行起来，我们在测试用例中有的使用要费劲心思来创建和待测试一样的运行环境，这里要介绍的Context就是一种上下文环境，下面内容是来自我在入职初期学习时候做的PPT来的，所以比较简洁不过大概涵盖了Context所涉及的知识点。<br>如上面提到的Android是基于组件，每个组件的运行都要有一个环境才能够正常工作，所以不是简单地New一个对象调用就能创建实例了，而是要有它们各自的上下文环境Context。在Android开发初期大家可能最难理解的就是这个Context了吧，至少我当时是萌逼状态的。<br><img src="/2016/03/23/Android-%E5%88%9D%E6%AD%A5%E4%B9%8B%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6/0.png"></p>
<h4 id="Context的作用"><a href="#Context的作用" class="headerlink" title="Context的作用"></a>Context的作用</h4><ul>
<li>可以通过 Context识别调用者的实例。<br>(例如:TextView label &#x3D; new TextView(this)<br>意味着view拥有一个指向Activity的引用，进而引用Activity占有的资源).</li>
<li>管理应用程序特定的配置细节</li>
<li>管理应用程序范围的操作和数据</li>
<li>访问当前包的资源(getResources、getAssets)</li>
<li>启动其他组件（Activity、Service、Broadcast）</li>
<li>得到各种系统服务（getSystemService）</li>
<li>使用Application Context来访问设置和资源可以在多个Activity实例中共享</li>
</ul>
<h4 id="Application-Context"><a href="#Application-Context" class="headerlink" title="Application  Context"></a>Application  Context</h4><p>Application-Context的生命周期是整个应用，Application Context可以通过Context.getApplicationContext或者Activity.getApplication方法获取。<br>在Activity或者Service中可以通过getApplication()函数获得，不管通过何种方法在哪里获得的，在一个进程内，总是获得到同一个实例。</p>
<h5 id="Application通常有如下常用用途："><a href="#Application通常有如下常用用途：" class="headerlink" title="Application通常有如下常用用途："></a>Application通常有如下常用用途：</h5><p>1.获得当前应用的主题，资源文件中的内容等<br>2.使用Application同步Activity之间的状态，例子见备注部分：</p>
<h5 id="实现在任何位置获取Applcation-Context-方法："><a href="#实现在任何位置获取Applcation-Context-方法：" class="headerlink" title="实现在任何位置获取Applcation  Context 方法："></a>实现在任何位置获取Applcation  Context 方法：</h5><p>在Android中只有Activity, Provider等组件中才能使用API获取Application Context，但是在某些工具类中往往需要它来访问资源。这就需要我们自定义一个Application类来解决这个问题：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> static <span class="type">MyApplication</span> instance;  </span><br><span class="line">    public static <span class="type">MyApplication</span> getInstance() &#123;  </span><br><span class="line">        <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">    public void onCreate() &#123;  </span><br><span class="line">	<span class="keyword">super</span>.onCreate();  </span><br><span class="line">       	 instance = <span class="keyword">this</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>为了能正确地调用MyApplication.getInstance()，需要在manifest中<application>中加入name&#x3D;”mypackage.MyApplication”。 </application></p>
<h4 id="获取Context的方式"><a href="#获取Context的方式" class="headerlink" title="获取Context的方式"></a>获取Context的方式</h4><ul>
<li><p>可以使用getApplicationContext()方法从当前进程中获取Context，这个方法在例如Activity或者Service中能够找到。通常我们使用Context对象时，要优先考虑这个全局的进程Context。</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Context</span> <span class="built_in">context</span> = getApplicationContext()；</span><br></pre></td></tr></table></figure></li>
<li><p>getContext()当前Activity对象的Context对象</p>
</li>
<li><p>Activity.this 返回当前的Activity实例，这个和上一个有点类似。</p>
</li>
</ul>
<h4 id="使用应用程序Context"><a href="#使用应用程序Context" class="headerlink" title="使用应用程序Context"></a>使用应用程序Context</h4><p>获得了一个应用程序Context后，就可以用它来访问应用程序范围的功能和服务了，这些功能和服务包括：</p>
<ul>
<li>获取应用程序资源，例如字符串，图像和XML文件：<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">String greeting = get<span class="constructor">Resource()</span>.get<span class="constructor">String(R.<span class="params">string</span>.<span class="params">hello</span>)</span>;</span><br></pre></td></tr></table></figure></li>
<li>访问应用程序首选项使用getSharedPreferences来访问共享的应用程序首选项</li>
<li>管理私有的应用程序文件以及目录</li>
<li>获取未编译的应用程序组件使用getAssets方法来获取应用程序的资源</li>
<li>获取系统服务</li>
<li>管理私有的应用程序数据库</li>
<li>使用应用程序权限</li>
</ul>
<p><img src="/2016/03/23/Android-%E5%88%9D%E6%AD%A5%E4%B9%8B%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6/333.png"></p>
<h4 id="应用程序的Context数目"><a href="#应用程序的Context数目" class="headerlink" title="应用程序的Context数目"></a>应用程序的Context数目</h4><p>在Android中 Context的子类有：Application，Activity，Service，所以：</p>
<figure class="highlight coq"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Context</span>数量 = Activity数量 + Service数量 + <span class="number">1</span> (Application <span class="keyword">Context</span>)</span><br></pre></td></tr></table></figure>

<h4 id="错误使用带来的问题："><a href="#错误使用带来的问题：" class="headerlink" title="错误使用带来的问题："></a>错误使用带来的问题：</h4><p>Context 错误使用会带来很严重的内存泄漏的问题，这个在内存优化部分有做过介绍，比如下面的例子,这是一个非常简单的懒汉式单例：</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    </span><br><span class="line">   <span class="keyword"> private</span> Context mContext;</span><br><span class="line">   <span class="keyword"> private</span><span class="keyword"> static</span> Singleton instance;</span><br><span class="line">   <span class="keyword"> private</span> Singleton(Context context) &#123;</span><br><span class="line">        this.mContext = context;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword"> public</span><span class="keyword"> static</span> Singleton getInstance(Context context) &#123;</span><br><span class="line">       <span class="built_in"> if </span>(instance == null) &#123;</span><br><span class="line">           <span class="built_in"> instance </span>=<span class="built_in"> new </span>Singleton(context);</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="built_in"> return </span>instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们知道单例的生命周期要长于一般的组件，一般是常驻内存的，如果在创建这个单例的时候传入的是Activity的上下文那么除了应用退出，否则Activity的上下文会一直被单例持有，所以导致即使Activity被销毁掉，也不能被GC回收，从而导致了内存泄漏。</p>
<h4 id="使用Context要注意的几点"><a href="#使用Context要注意的几点" class="headerlink" title="使用Context要注意的几点"></a>使用Context要注意的几点</h4><p>一般Context造成的内存泄漏，几乎都是当Context销毁的时候，却因为被引用导致销毁失败，而Application的Context对象可以理解为随着进程存在的，所以我们总结出使用Context的正确姿势：</p>
<ul>
<li>在开发中尽量使用Application的Context，特别是生命周期长的情况下。不要让生命周期长于组件的对象持有组件的引用。</li>
<li>非静态内部类会隐式持有外部类实例的引用，如果需要使用内部类那么需要将外部实例引用作为弱引用持有，从而避免内存泄漏。</li>
</ul>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Android%E5%88%9D%E6%AD%A5/">Android初步</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/Android基础/">Android基础</a>
  </div>

</div>



<div class="comments-count">
	
	  	<span></span>
		<a href="/2016/03/23/Android-初步之四大组件/#comments" class="ds-thread-count comments-count-link" data-thread-key="2016/03/23/Android-初步之四大组件/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/03/23/Android-初步之Android组件-概图/" title="Android 初步之Android组件 概图" itemprop="url">Android 初步之Android组件 概图</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Edgar" target="_blank" itemprop="author">Edgar</a>
		
  <p class="article-time">
    <time datetime="2016-03-23T04:50:36.000Z" itemprop="datePublished"> Published 2016-03-23</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p><img src="/2016/03/23/Android-%E5%88%9D%E6%AD%A5%E4%B9%8BAndroid%E7%BB%84%E4%BB%B6-%E6%A6%82%E5%9B%BE/1.png"></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Android%E5%88%9D%E6%AD%A5/">Android初步</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/Android基础/">Android基础</a>
  </div>

</div>



<div class="comments-count">
	
	  	<span></span>
		<a href="/2016/03/23/Android-初步之Android组件-概图/#comments" class="ds-thread-count comments-count-link" data-thread-key="2016/03/23/Android-初步之Android组件-概图/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/03/23/Android-初步之Android-SDK-目录结构/" title="Android 初步之Android SDK 目录结构" itemprop="url">Android 初步之Android SDK 目录结构</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Edgar" target="_blank" itemprop="author">Edgar</a>
		
  <p class="article-time">
    <time datetime="2016-03-23T04:48:55.000Z" itemprop="datePublished"> Published 2016-03-23</time>
    
  </p>
</header>
    <div class="article-content">
        
        <ol>
<li>add-ons： 这里面保存着附加库，比如Google Maps。</li>
<li>docs： 这里面是Android SDK API参考文档，所有的API都可以在这里查到。</li>
<li>tools： 作为SDK根目录下的tools文件夹，这里包含了重要的工具，比如ddms用于启动Android调试工具，比如logcat、屏幕截图和文件管理器，而draw9patch则是绘制android平台的可缩放png图片的工具，sqlite3可以在PC上操作SQLite数据库， 而monkeyrunner则是一个不错的压力测试应用，模拟用户随机按键，mksdcard则是模拟器SD映像的创建工具，emulator是 Android SDK模拟器主程序，不过从android 1.5开始，需要输入合适的参数才能启动模拟器，traceview作为android平台上重要的调试工具。</li>
<li>extas： 附件文档</li>
<li>platforms： 是每个平台的SDK真正的文件，里面会根据APILevel划分的SDK版本，这里就以Android2.2来说，进入后有 一个android-8的文件夹，android-8进入后是Android2.2 SDK的主要文件，其中ant为ant编译脚本，data保存着一些系统资源，images是模拟器映像文件，skins则是Android模拟器的皮肤，templates是工程创建的默认模板，android.jar则 是该版本的主要framework文件，tools目录里面包含了重要的编译工具，比如aapt、aidl、逆向调试工具dexdump和编译脚本dx。</li>
<li>platform-tools保存着一些通用工具，比如adb、和aapt、aidl、dx等文件，这里和platforms目录中tools文件夹有些重复，主要是从android2.3开始这些工具被划分为通用了。</li>
<li>samples是Android SDK自带的默认示例工程</li>
<li>system-images    系统镜像</li>
<li>sources Android 资源文件夹</li>
<li>temp 缓存目录</li>
</ol>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Android%E5%88%9D%E6%AD%A5/">Android初步</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/Android基础/">Android基础</a>
  </div>

</div>



<div class="comments-count">
	
	  	<span></span>
		<a href="/2016/03/23/Android-初步之Android-SDK-目录结构/#comments" class="ds-thread-count comments-count-link" data-thread-key="2016/03/23/Android-初步之Android-SDK-目录结构/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/03/23/Android-初步之Android-体系结构/" title="Android 初步之Android 体系结构" itemprop="url">Android 初步之Android 体系结构</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Edgar" target="_blank" itemprop="author">Edgar</a>
		
  <p class="article-time">
    <time datetime="2016-03-23T04:46:49.000Z" itemprop="datePublished"> Published 2016-03-23</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>想必大家接触Android的时候最早接触的图就是下面这张吧，它是Android整个架构图，虽然Android 系统已经发展到Android M，并且Android N 也快发布，但是整个架构还是不变的。</p>
<p><img src="/2016/03/23/Android-%E5%88%9D%E6%AD%A5%E4%B9%8BAndroid-%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/1.png"></p>
<p><img src="/2016/03/23/Android-%E5%88%9D%E6%AD%A5%E4%B9%8BAndroid-%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/2.png"></p>
<ul>
<li>Linux内核  Android核心系统服务依赖于Linux内核，如安全性、内存管理、进程管理、网络协议栈和驱动模型。Linux内核也是作为硬件与软件栈的抽象层。驱动：显示驱动、摄像头驱动、键盘驱动、WiFi驱动、Audio驱动、flash内存驱动、Binder（IPC）驱动、电源管理等。</li>
<li>系统库和Android运行时</li>
</ul>
<p><img src="/2016/03/23/Android-%E5%88%9D%E6%AD%A5%E4%B9%8BAndroid-%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/4.png"></p>
<p>系统库包括九个子系统，分别是图层管理、媒体库、SQLite、OpenGL ES、FreeType、WebKit、SGL、SSL和libc。<br>Android运行时包括核心库和Dalvik虚拟机，前者既兼容了大多数Java语言所需要调用的功能函数，又包括了Android的核心库，比如android.os、android.net、android.media等等。<br>后者是一种基于寄存器的java虚拟机，Dalvik虚拟机主要是完成对生命周期的管理、堆栈的管理、线程的管理、安全和异常的管理以及垃圾回收等重要功能。</p>
<p>系统库：</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">libc            C语言标准库</span><br><span class="line">Surface Menager 主要管理多个应用程序同时执行时，各个程序之间的显示与存储</span><br><span class="line">Media Framework 系统多媒体库</span><br><span class="line">SQLite          关系型数据库</span><br><span class="line">OpenGL <span class="built_in">ES</span>       <span class="number">3D</span>效果支持</span><br><span class="line">FreeType        位图及矢量库</span><br><span class="line">WebKit          Web 浏览器引擎</span><br><span class="line">SGL             <span class="number">2D</span>图形引擎</span><br><span class="line">SSL              位于TCP/<span class="built_in">IP</span>与各种应用层协议之间，为数据通信提供支持</span><br></pre></td></tr></table></figure>


<ul>
<li>应用程序框架层</li>
</ul>
<p><img src="/2016/03/23/Android-%E5%88%9D%E6%AD%A5%E4%B9%8BAndroid-%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/3.png"></p>
<p>该层是Android应用开发的基础，开发人员大部分情况是在和它打交道。应用程序框架层包括活动管理器、窗口管理器、内容提供者、视图系统、包管理器、电话管理器、资源管理器、位置管理器、通知管理器和XMPP服务十个部分。在Android平台上，开发人员可以完全访问核心应用程序所使用的API框架。并且，任何一个应用程序都可以发布自身的功能模块，而其他应用程序则可以使用这些已发布的功能模块。基于这样的重用机制，用户就可以方便地替换平台本身的各种应用程序组件。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">Activity Manager 活动管理器用于管理应用程序生命周期</span><br><span class="line"><span class="keyword">View</span> <span class="keyword">System</span>   视图管理器，用来构建应用程序如列表，表格，文本框，按钮等</span><br><span class="line"><span class="keyword">Window</span> Manager窗口管理者</span><br><span class="line">Content Provider 内容提供者</span><br><span class="line">Notification Manager 通知管理者，用来设置在状态栏中显示的提示信息</span><br><span class="line">Package Manager 包管理者，用来对Android系统内的应用程序进行管理</span><br><span class="line">Telephony Manager 电话管理者，用来对联系人及通话记录等信息进行管理</span><br><span class="line">Resource Manager  资源管理者，用来提供非代码资源的访问</span><br><span class="line"><span class="keyword">Location</span> Manager  位置管理者，用来提供使用者的当前位置等信息</span><br><span class="line">XMPP Service  Service服务</span><br></pre></td></tr></table></figure>


<ul>
<li>应用程序层</li>
</ul>
<p><img src="/2016/03/23/Android-%E5%88%9D%E6%AD%A5%E4%B9%8BAndroid-%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/6.png"></p>
<p>该层提供一些核心应用程序包，例如电子邮件、短信、日历、地图、浏览器和联系人管理等。同时，开发者可以利用Java语言设计和编写属于自己的应用程序，而这些程序与那些核心应用程序彼此平等、友好共处。</p>
<p>对于Android系统架构推荐如下两篇博客：<br><a target="_blank" rel="noopener" href="http://developer.51cto.com/art/201001/180207.htm">http://developer.51cto.com/art/201001/180207.htm</a><br><a target="_blank" rel="noopener" href="http://mobile.51cto.com/android-235496.htm">http://mobile.51cto.com/android-235496.htm</a></p>
<h4 id="Delvik虚拟机以及ART"><a href="#Delvik虚拟机以及ART" class="headerlink" title="Delvik虚拟机以及ART"></a>Delvik虚拟机以及ART</h4><p>这篇博客将会在以后的时间添加这一部分，先占个坑！</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Android%E5%88%9D%E6%AD%A5/">Android初步</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/Android基础/">Android基础</a>
  </div>

</div>



<div class="comments-count">
	
	  	<span></span>
		<a href="/2016/03/23/Android-初步之Android-体系结构/#comments" class="ds-thread-count comments-count-link" data-thread-key="2016/03/23/Android-初步之Android-体系结构/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/03/22/树莓派3-安装ROS-Indigo/" title="树莓派3 安装ROS Indigo" itemprop="url">树莓派3 安装ROS Indigo</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Edgar" target="_blank" itemprop="author">Edgar</a>
		
  <p class="article-time">
    <time datetime="2016-03-22T10:53:40.000Z" itemprop="datePublished"> Published 2016-03-22</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>硬件设备：<br>RapsBerry 3<br>操作系统：<br>Rapsbian OS jessie</p>
<ol>
<li>Setup ROS Repositories</li>
</ol>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">$ sudo sh -c <span class="string">&#x27;echo &quot;deb http://packages.ros.org/ros/ubuntu jessie main&quot; &gt; /etc/apt/sources.list.d/ros-latest.list&#x27;</span></span><br><span class="line">$ wget https:<span class="regexp">//</span>raw.githubusercontent.com<span class="regexp">/ros/</span>rosdistro<span class="regexp">/master/</span>ros.key -O - | sudo apt-key add -</span><br></pre></td></tr></table></figure>

<p>2.更新软件源</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">$ sudo apt-<span class="built_in">get</span> update</span><br><span class="line">$ sudo apt-<span class="built_in">get</span> upgrade</span><br></pre></td></tr></table></figure>

<p>3.Install Bootstrap Dependencies	</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">$ sudo apt-<span class="built_in">get</span> install <span class="keyword">python</span>-pip <span class="keyword">python</span>-setuptools <span class="keyword">python</span>-yaml <span class="keyword">python</span>-distribute <span class="keyword">python</span>-docutils <span class="keyword">python</span>-dateutil <span class="keyword">python</span>-six</span><br><span class="line">$ sudo pip install rosdep rosinstall_generator wstool rosinstall</span><br></pre></td></tr></table></figure>

<p>4.Initializing rosdep	</p>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>sudo rosdep init</span><br><span class="line"><span class="variable">$ </span>rosdep update</span><br></pre></td></tr></table></figure>

<p>Installation</p>
<p>Now, we will download and build ROS Indigo.</p>
<p>Create a catkin Workspace</p>
<p>In order to build the core packages, you will need a catkin workspace. Create one now:</p>
<p>$ mkdir ~&#x2F;ros_catkin_ws<br>$ cd ~&#x2F;ros_catkin_ws</p>
<p>Next we will want to fetch the core packages so we can build them. We will use wstool for this. Select the wstool command for the particular variant you want to install:</p>
<p>ROS-Comm: (recommended) ROS package, build, and communication libraries. No GUI tools.</p>
<pre><code>$ rosinstall_generator ros_comm --rosdistro indigo --deps --wet-only --exclude roslisp --tar &gt; indigo-ros_comm-wet.rosinstall
$ wstool init src indigo-ros_comm-wet.rosinstall


This will add all of the catkin or wet packages in the given variant and then fetch the sources into the ~/ros_catkin_ws/src directory. The command will take a few minutes to download all of the core ROS packages into the src folder. The -j8 option downloads 8 packages in parallel. 




Resolve Dependencies
</code></pre>
<p>Before you can build your catkin workspace, you need to make sure that you have all the required dependencies. We use the rosdep tool for this, however, a couple of dependencies are not available in the repositories. They must be manually built first.</p>
<p>Unavailable Dependencies</p>
<p>Following packages are not available for Raspbian:</p>
<p>Raspbian Wheezy: libconsole-bridge-dev, liburdfdom-headers-dev, liburdfdom-dev, liblz4-dev, collada-dom-dev</p>
<p>Raspbian Jessie: collada-dom-dev</p>
<p>The following packages are needed for each ROS variant:</p>
<p>Ros_Comm: libconsole-bridge-dev, liblz4-dev</p>
<p>Desktop: libconsole-bridge-dev, liblz4-dev, liburdfdom-headers-dev, liburdfdom-dev, collada-dom-dev</p>
<p>The required packages can be built from source in a new directory:</p>
<pre><code>$ mkdir ~/ros_catkin_ws/external_src
$ sudo apt-get install checkinstall cmake
$ sudo sh -c &#39;echo &quot;deb-src http://mirrordirector.raspbian.org/raspbian/ testing main contrib non-free rpi&quot; &gt;&gt; /etc/apt/sources.list&#39;
$ sudo apt-get update
</code></pre>
<p>libconsole-bridge-dev:</p>
<pre><code>$ cd ~/ros_catkin_ws/external_src
$ sudo apt-get build-dep console-bridge
$ apt-get source -b console-bridge
$ sudo dpkg -i libconsole-bridge0.2*.deb libconsole-bridge-dev_*.deb



liblz4-dev:

$ cd ~/ros_catkin_ws/external_src
$ apt-get source -b lz4
$ sudo dpkg -i liblz4-*.deb



Resolving Dependencies with rosdep
</code></pre>
<p>The remaining dependencies should be resolved by running rosdep:</p>
<p>Raspbian Wheezy:</p>
<p>$ cd ~&#x2F;ros_catkin_ws<br>$ rosdep install –from-paths src –ignore-src –rosdistro indigo -y -r –os&#x3D;debian:wheezy</p>
<p>Raspbian Jessie:</p>
<p>$ cd ~&#x2F;ros_catkin_ws<br>$ rosdep install –from-paths src –ignore-src –rosdistro indigo -y -r –os&#x3D;debian:jessie</p>
<p>Building the catkin Workspace</p>
<p>Once you have completed downloading the packages and have resolved the dependencies, you are ready to build the catkin packages.</p>
<p>Invoke catkin_make_isolated:</p>
<p>$ sudo .&#x2F;src&#x2F;catkin&#x2F;bin&#x2F;catkin_make_isolated –install -DCMAKE_BUILD_TYPE&#x3D;Release –install-space &#x2F;opt&#x2F;ros&#x2F;indigo</p>
<p>Note: This will install ROS in the equivalent file location to Ubuntu in &#x2F;opt&#x2F;ros&#x2F;indigo however you can modify this as you wish.</p>
<p>For rviz, you will also have to apply this patch.</p>
<p>Should the compilation fail with an “internal compiler error”, it may be because you’re out of memory. A quick fix for this is to add swap space to the Pi and recompile. If the error persists try building with the -j2 option instead of the default -j4 option:</p>
<p>$ sudo .&#x2F;src&#x2F;catkin&#x2F;bin&#x2F;catkin_make_isolated –install -DCMAKE_BUILD_TYPE&#x3D;Release –install-space &#x2F;opt&#x2F;ros&#x2F;indigo -j2</p>
<p>Now ROS should be installed! Remember to source the new installation:</p>
<p>$ source &#x2F;opt&#x2F;ros&#x2F;indigo&#x2F;setup.bash</p>
<p>Or optionally source the setup.bash in the ~&#x2F;.bashrc, so that ROS environment variables are automatically added to your bash session every time a new shell is launched:</p>
<p>$ “source &#x2F;opt&#x2F;ros&#x2F;indigo&#x2F;setup.bash” &gt;&gt; ~&#x2F;.bashrc</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/ROS/">ROS</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/ROS/">ROS</a>
  </div>

</div>



<div class="comments-count">
	
	  	<span></span>
		<a href="/2016/03/22/树莓派3-安装ROS-Indigo/#comments" class="ds-thread-count comments-count-link" data-thread-key="2016/03/22/树莓派3-安装ROS-Indigo/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/03/21/睡前学习ROS之-运行ROS-Master和-ROS-参数服务器/" title="睡前学习ROS之 运行ROS Master和 ROS 参数服务器" itemprop="url">睡前学习ROS之 运行ROS Master和 ROS 参数服务器</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Edgar" target="_blank" itemprop="author">Edgar</a>
		
  <p class="article-time">
    <time datetime="2016-03-21T13:23:18.000Z" itemprop="datePublished"> Published 2016-03-21</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>我们在介绍Hello World的时候介绍了roscore 命令，但是并没有介绍它具体做了什么操作：<br>其实在运行这个命令的时我们启动了如下的组件：</p>
<ul>
<li>ROS Master</li>
<li>ROS 参数服务器</li>
<li>Rosout log节点<br>前两者已经在上述的章节进行了介绍，至于roscore节点它是用于从其他ROS节点中收集Log信息，并将其存储在log文件中。</li>
</ul>
<p>下面就先运行roscore命令看下效果，运行命令后会弹出如下的Log：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">//</span>产生的Log文件</span><br><span class="line">... logging to <span class="regexp">/home/</span>pi<span class="regexp">/.ros/</span>log<span class="regexp">/674306a0-06fc-11e6-8a8b-b827eb2bb378/</span>roslaunch-raspberrypi-<span class="number">2054</span>.log</span><br><span class="line">Checking log directory <span class="keyword">for</span> disk usage. This may take awhile.</span><br><span class="line">Press Ctrl-C to interrupt</span><br><span class="line">Done checking log file disk usage. Usage is &lt;<span class="number">1</span>GB.</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span>这个命令将会启动roscore.xml ROS启动文件，这个文件会自动启动ros master和ros参数服务器，下面这个地方显示的就是ROS参数服务器的地址和端口</span><br><span class="line">started roslaunch server http:<span class="regexp">//</span>raspberrypi:<span class="number">41429</span>/</span><br><span class="line">ros_comm version <span class="number">1.11</span>.<span class="number">18</span></span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span>这个部分显示的是ros版本以及ros版本号信息的参数</span><br><span class="line">SUMMARY</span><br><span class="line">========</span><br><span class="line"></span><br><span class="line">PARAMETERS</span><br><span class="line"> * /rosdistro: indigo</span><br><span class="line"> * /rosversion: <span class="number">1.11</span>.<span class="number">18</span></span><br><span class="line"></span><br><span class="line">NODES</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span>显示ROS_MASTER_URI信息</span><br><span class="line">auto-starting new master</span><br><span class="line">process[master]: started with pid [<span class="number">2065</span>]</span><br><span class="line">ROS_MASTER_URI=http:<span class="regexp">//</span>raspberrypi:<span class="number">11311</span>/</span><br><span class="line"></span><br><span class="line">setting /run_id to <span class="number">674306</span>a0-<span class="number">06</span>fc-<span class="number">11</span>e6-<span class="number">8</span>a8b-b827eb2bb378</span><br><span class="line">process[rosout-<span class="number">1</span>]: started with pid [<span class="number">2078</span>]</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span>启动rosout服务</span><br><span class="line">started core service [/rosout]</span><br></pre></td></tr></table></figure>
        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/ROS/">ROS</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/ROS/">ROS</a>
  </div>

</div>



<div class="comments-count">
	
	  	<span></span>
		<a href="/2016/03/21/睡前学习ROS之-运行ROS-Master和-ROS-参数服务器/#comments" class="ds-thread-count comments-count-link" data-thread-key="2016/03/21/睡前学习ROS之-运行ROS-Master和-ROS-参数服务器/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/03/20/睡前ROS学习之ROS数据存储/" title="睡前ROS学习之ROS 数据存储" itemprop="url">睡前ROS学习之ROS 数据存储</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Edgar" target="_blank" itemprop="author">Edgar</a>
		
  <p class="article-time">
    <time datetime="2016-03-20T15:31:26.000Z" itemprop="datePublished"> Published 2016-03-20</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>ROS 数据可以以Bag形式也可以存储在Parameter Service上</p>
<p>ROS Parameter:</p>
<p>我们在实现一个机器人的时候，我们一定会遇到需要存储很多参数的情况，当这些参数不断增加的时候我们可能会需要将这些参数存储在文件中，在某些时刻还需要在多个程序间共享这些参数，ROS 为了满足这种需求提供了一个参数服务器，它是一个共享的服务器，所有的ROS节点都可以共享这些参数，任何一个节点都可以对参数服务器上的参数进行增删查改操作。参数服务器可以存储各种类型的数据，并且还可以设置访问的范围是否只有当前的节点可以访问或者全部节点都可以访问。</p>
<ul>
<li>32-bit integers</li>
<li>Booleans</li>
<li>strings</li>
<li>doubles</li>
<li>iso8601 dates</li>
<li>lists</li>
<li>base64-encoded binary	data</li>
</ul>
<p>我们还可以存储字典参数：</p>
<p>&#x2F;camera&#x2F;name:’nikon’ #string type<br>&#x2F;camera&#x2F;fps	: 30 #integer<br>&#x2F;camera&#x2F;exposure:1.2 #float<br>&#x2F;camera&#x2F;active : true #boolean</p>
<p>和参数服务器相关的命令：</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="symbol">$</span> rosparam <span class="keyword">set</span> <span class="keyword">parameter</span> <span class="comment">value :</span>这个命令用于将某个参数设置为某个值</span><br><span class="line">$ rosparam <span class="comment">get parameter_name :</span> 获得某个参数的值</span><br><span class="line">$ rosparam <span class="comment">load [YAML file] :</span> 从<span class="comment">YAML</span>文件中加载参数到参数服务器</span><br><span class="line">$ rosparam <span class="comment">dump [YAML file] :</span> 这个命令将会将参数服务器中的数据存储到<span class="comment">YAML</span>文件</span><br><span class="line">$ rosparam <span class="comment">delete [parameter_name] :</span> 将会从参数服务器中删除某个参数</span><br><span class="line">$ rosparam <span class="comment">list :</span> 将会列出所有的参数名</span><br></pre></td></tr></table></figure>

<hr>
<hr>
<p>ROS Bags：</p>
<p>ROS bag用于存储来自topic和service的消息数据，它是通过rosbag命令创建的，它会订阅一个或者更多的topic并且以它接收到的方式存储起来。<br>下面是rosbag的常用方法：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="variable">$rosbag</span>	record  <span class="selector-attr">[topic_1]</span> -o <span class="selector-attr">[bag_name]</span>： 这个命令将会将指定的topic记录到一个bag文件中，我们还可以使用-a作为参数记录所有的topic</span><br><span class="line"></span><br><span class="line"><span class="variable">$rosbag</span>	play <span class="selector-attr">[bag_name]</span> :这个会回放存在的bag文件.</span><br></pre></td></tr></table></figure>
<p>下面推荐一个很好用的bag回放GUI工具：<br><a target="_blank" rel="noopener" href="http://wiki.ros.org/rqt_bag">http://wiki.ros.org/rqt</a></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/ROS/">ROS</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/ROS/">ROS</a>
  </div>

</div>



<div class="comments-count">
	
	  	<span></span>
		<a href="/2016/03/20/睡前ROS学习之ROS数据存储/#comments" class="ds-thread-count comments-count-link" data-thread-key="2016/03/20/睡前ROS学习之ROS数据存储/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/03/19/睡前ROS学习之ROS-Message/" title="睡前ROS学习之ROS 通信方式" itemprop="url">睡前ROS学习之ROS 通信方式</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Edgar" target="_blank" itemprop="author">Edgar</a>
		
  <p class="article-time">
    <time datetime="2016-03-19T15:31:26.000Z" itemprop="datePublished"> Published 2016-03-19</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>ROS Message：<br>之前介绍了 ROS 节点之间的通信方式，其中一种就是Message机制它是一种基于发布&#x2F;订阅的轻量级通信方式，消息是一种包含位域类型的简单数据结构，ROS提供标准的原始数据类型和原始数据类型的数组。ROS使用MD5校验方式来确认发布者和订阅者是否正在交换同样类型的数据。<br>和之前介绍的ROS节点一样，ROS也提供了一个内置的称为rosmsg的命令来获取ROS消息的信息，下面是常见的命令：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">rosmsg show <span class="selector-attr">[message]</span>显示消息的描述</span><br><span class="line">rosmsg list 显示所有的消息</span><br><span class="line">rosmsg md5 <span class="selector-attr">[message]</span>：显示某个消息的md5sum</span><br><span class="line">rosmsg package <span class="selector-attr">[package_name]</span>: 显示所有在这个包里面的消息</span><br><span class="line">rosmsg packages :列出包含消息的包</span><br></pre></td></tr></table></figure>

<p>ROS Topic：</p>
<p>ROS Topic 是一个用于ROS 节点交换消息的命名总线，Topic可以匿名地发送和订阅消息，这就意味着消息的产生和消费是解偶的，二者之间没有强行绑定的关系，ROS节点不在乎是谁在发布Topic，哪个节点在订阅Topic，它只关心topic的名字以及当前的消息类型时候和我要求的匹配。Topic和稍候介绍的Service的最大区别是它是单向的。</p>
<p>和之前介绍的ROS Message一样，ROS也提供了一个内置的称为rostopic的命令来获取ROS topic的信息，下面是常见的命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$rostopic</span> bw  /topic :用于显示指定topic所占用的带宽</span><br><span class="line"><span class="variable">$rostopic</span> <span class="built_in">echo</span> /topic :用于显示指定topic的内容</span><br><span class="line"><span class="variable">$rostopic</span> find /message_type：这个命令用于指定给定消息类型的topic</span><br><span class="line"><span class="variable">$rostopic</span> hz  /topic :这个命令用于显示给定topic的发布速度</span><br><span class="line"><span class="variable">$rostopic</span> info /topic :这个会打印所有激活的topic消息</span><br><span class="line"><span class="variable">$rostopic</span> list:	这个会显示ROS系统中所有激活的topic</span><br><span class="line"><span class="variable">$rostopic</span> pub /topic message_type args :这个命令可以用于向一个topic上发布一个指定类型的消息</span><br><span class="line"><span class="variable">$rostopic</span> <span class="built_in">type</span> /topic:这个会显示指定topic的消息类型</span><br></pre></td></tr></table></figure>
<p>ROS Service：</p>
<p>ROS Service 是基于请求&#x2F;答复形式的交互形式，主要用于分布式系统中ROS服务是通过一对消息来定义的，其中一个用于定义请求数据类型，另一个用于定义答复数据类型，服务的定义一般位于一个包的srv目录的src文件内。在ROS 服务中一个节点作为ROS服务，ROS 客户端可以从这个服务中请求服务，等到服务完成后会发送结果到它的客户端上。</p>
<p>下面是用于ROS服务的命令：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="variable">$rosservice</span>	call <span class="built_in">/service </span>args： 这个命令将会使用特定的参数调用服务</span><br><span class="line"><span class="variable">$rosservice</span>	<span class="built_in">find</span> service_type :	这个命令将会查找指定服务类型的服务</span><br><span class="line"><span class="variable">$rosservice</span>	<span class="built_in">info</span> /services : 这个将会打印关于指定服务的消息</span><br><span class="line"><span class="variable">$rosservice</span>	list : 这个将会列出系统上的所有服务</span><br><span class="line"><span class="variable">$rosservice</span><span class="built_in">	type </span><span class="built_in">/service </span>:	这个命令将会打印某个服务的服务类型</span><br><span class="line"><span class="variable">$rosservice</span>	uri	<span class="built_in">/service </span>:	这个命令将会打印服务的ROSRPC URI</span><br></pre></td></tr></table></figure>


        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/ROS/">ROS</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/ROS/">ROS</a>
  </div>

</div>



<div class="comments-count">
	
	  	<span></span>
		<a href="/2016/03/19/睡前ROS学习之ROS-Message/#comments" class="ds-thread-count comments-count-link" data-thread-key="2016/03/19/睡前ROS学习之ROS-Message/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>







  <nav id="page-nav" class="clearfix">
    <a class="extend prev" rel="prev" href="/page/26/">&lt;span&gt;&lt;&#x2F;span&gt;Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/25/">25</a><a class="page-number" href="/page/26/">26</a><span class="page-number current">27</span><a class="page-number" href="/page/28/">28</a><a class="page-number" href="/page/29/">29</a><a class="page-number" href="/page/30/">30</a><a class="extend next" rel="next" href="/page/28/">Next&lt;span&gt;&lt;&#x2F;span&gt;</a>
  </nav>

</div>
      <div class="openaside"><a class="navbutton" href="#" title="Show Sidebar"></a></div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="Hide Sidebar"></a></div>
<aside class="clearfix">
<div id="authorInfo">
	
		<div class="author-img"></div>		
	
	<div class="social-info" class="clearfix">
		
		
		<a href="https://github.com/tbfungeek" target="_blank" class="icon-github" title="github"></a>
		
		
		
		
		
		
		
		
		
		
		<a href="mailto:tbfungeek@163.com" target="_blank" class="icon-email" title="Email Me"></a>
		

	</div>
</div>

  
<div class="categorieslist">
	<p class="asidetitle">Categories</p>
		<ul>
		
		  
			<li><a href="/categories/Android-小经验/" title="Android 小经验">Android 小经验<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Android-源码分析/" title="Android 源码分析">Android 源码分析<sup>21</sup></a></li>
		  
		
		  
			<li><a href="/categories/Android其他/" title="Android其他">Android其他<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Android初步/" title="Android初步">Android初步<sup>21</sup></a></li>
		  
		
		  
			<li><a href="/categories/Android进阶/" title="Android进阶">Android进阶<sup>100</sup></a></li>
		  
		
		  
			<li><a href="/categories/Hexo-使用/" title="Hexo 使用">Hexo 使用<sup>10</sup></a></li>
		  
		
		  
			<li><a href="/categories/JavaScript理论/" title="JavaScript理论">JavaScript理论<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Objective-C-相关/" title="Objective C 相关">Objective C 相关<sup>24</sup></a></li>
		  
		
		  
			<li><a href="/categories/OpenCV/" title="OpenCV">OpenCV<sup>6</sup></a></li>
		  
		
		  
			<li><a href="/categories/ROS/" title="ROS">ROS<sup>9</sup></a></li>
		  
		
		  
			<li><a href="/categories/iOS-工具使用/" title="iOS 工具使用">iOS 工具使用<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/iOS-开源库分析/" title="iOS 开源库分析">iOS 开源库分析<sup>36</sup></a></li>
		  
		
		  
			<li><a href="/categories/iOS-理论基础/" title="iOS 理论基础">iOS 理论基础<sup>14</sup></a></li>
		  
		
		  
			<li><a href="/categories/iOS-进阶/" title="iOS 进阶">iOS 进阶<sup>4</sup></a></li>
		  
		
		  
			<li><a href="/categories/个人收藏/" title="个人收藏">个人收藏<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/代码规范/" title="代码规范">代码规范<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/其他/" title="其他">其他<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/博客分类目录/" title="博客分类目录">博客分类目录<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/叨叨系列/" title="叨叨系列">叨叨系列<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/开源代码分析/" title="开源代码分析">开源代码分析<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/开源库分析/" title="开源库分析">开源库分析<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/树莓派/" title="树莓派">树莓派<sup>4</sup></a></li>
		  
		
		  
			<li><a href="/categories/版本控制/" title="版本控制">版本控制<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/直播/" title="直播">直播<sup>6</sup></a></li>
		  
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">Tags</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/iOS-开源库分析/" title="iOS 开源库分析">iOS 开源库分析<sup>36</sup></a></li>
			
		
			
				<li><a href="/tags/Android-设计模式/" title="Android 设计模式">Android 设计模式<sup>29</sup></a></li>
			
		
			
				<li><a href="/tags/Objective-C-相关/" title="Objective C 相关">Objective C 相关<sup>24</sup></a></li>
			
		
			
				<li><a href="/tags/Android基础/" title="Android基础">Android基础<sup>21</sup></a></li>
			
		
			
				<li><a href="/tags/AOSP-源码/" title="AOSP 源码">AOSP 源码<sup>17</sup></a></li>
			
		
			
				<li><a href="/tags/Android-常用第三方库/" title="Android 常用第三方库">Android 常用第三方库<sup>15</sup></a></li>
			
		
			
				<li><a href="/tags/iOS-理论基础/" title="iOS 理论基础">iOS 理论基础<sup>14</sup></a></li>
			
		
			
				<li><a href="/tags/Hexo-使用/" title="Hexo 使用">Hexo 使用<sup>10</sup></a></li>
			
		
			
				<li><a href="/tags/ROS/" title="ROS">ROS<sup>9</sup></a></li>
			
		
			
				<li><a href="/tags/Android-动画进阶/" title="Android 动画进阶">Android 动画进阶<sup>8</sup></a></li>
			
		
			
				<li><a href="/tags/Android-JNI/" title="Android JNI">Android JNI<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/Android-绘图进阶/" title="Android 绘图进阶">Android 绘图进阶<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/Android性能优化/" title="Android性能优化">Android性能优化<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/Android-自动化测试/" title="Android 自动化测试">Android 自动化测试<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/OpenCV/" title="OpenCV">OpenCV<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/直播/" title="直播">直播<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/Android-开源源码/" title="Android 开源源码">Android 开源源码<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/Android-自定义View进阶/" title="Android 自定义View进阶">Android 自定义View进阶<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/树莓派/" title="树莓派">树莓派<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/iOS-进阶/" title="iOS 进阶">iOS 进阶<sup>4</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">Links</p>
    <ul>
        
          <li>
            
            	<a href="https://hexo.io" target="_blank" title="Hexo">Hexo</a>
            
          </li>
        
          <li>
            
            	<a href="https://pages.github.com/" target="_blank" title="GitHub">GitHub</a>
            
          </li>
        
          <li>
            
            	<a href="http://pf18.github.io/" target="_blank" title="PF18">PF18</a>
            
          </li>
        
          <li>
            
            	<a href="http://toutiao.io/" target="_blank" title="开发者头条">开发者头条</a>
            
          </li>
        
          <li>
            
            	<a href="http://www.jcodecraeer.com/" target="_blank" title="泡在网上的日子">泡在网上的日子</a>
            
          </li>
        
    </ul>
</div>

  


  <div class="rsspart">
	<a href="atom.xml" target="_blank" title="rss">RSS</a>
</div>

  
  <div class="tagcloudlist">
    <p class="asidetitle">Tag Cloud</p>
    <div class="tagcloudlist clearfix">
       <a href="/tags/AOSP-%E6%BA%90%E7%A0%81/" style="font-size: 17.14px;">AOSP 源码</a> <a href="/tags/Android-APK-%E7%AD%BE%E5%90%8D/" style="font-size: 10px;">Android APK 签名</a> <a href="/tags/Android-JNI/" style="font-size: 12.86px;">Android JNI</a> <a href="/tags/Android-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E8%BF%9B%E9%98%B6/" style="font-size: 10.71px;">Android 事件处理进阶</a> <a href="/tags/Android-%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6/" style="font-size: 13.57px;">Android 动画进阶</a> <a href="/tags/Android-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%80%E5%8F%91/" style="font-size: 10px;">Android 多线程开发</a> <a href="/tags/Android-%E5%B0%8F%E7%BB%8F%E9%AA%8C/" style="font-size: 10px;">Android 小经验</a> <a href="/tags/Android-%E5%B8%B8%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/" style="font-size: 16.43px;">Android 常用第三方库</a> <a href="/tags/Android-%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/" style="font-size: 10px;">Android 开发流程</a> <a href="/tags/Android-%E5%BC%80%E6%BA%90%E6%BA%90%E7%A0%81/" style="font-size: 12.14px;">Android 开源源码</a> <a href="/tags/Android-%E7%BB%98%E5%9B%BE%E8%BF%9B%E9%98%B6/" style="font-size: 12.86px;">Android 绘图进阶</a> <a href="/tags/Android-%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/" style="font-size: 12.86px;">Android 自动化测试</a> <a href="/tags/Android-%E8%87%AA%E5%AE%9A%E4%B9%89View%E8%BF%9B%E9%98%B6/" style="font-size: 12.14px;">Android 自定义View进阶</a> <a href="/tags/Android-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 19.29px;">Android 设计模式</a> <a href="/tags/Android%E5%85%B6%E4%BB%96/" style="font-size: 10px;">Android其他</a> <a href="/tags/Android%E5%9F%BA%E7%A1%80/" style="font-size: 17.86px;">Android基础</a> <a href="/tags/Android%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/" style="font-size: 10px;">Android开发流程</a> <a href="/tags/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" style="font-size: 12.86px;">Android性能优化</a> <a href="/tags/Android%E6%B7%B7%E6%B7%86%E6%8A%80%E6%9C%AF/" style="font-size: 10px;">Android混淆技术</a> <a href="/tags/Android%E8%B4%A8%E9%87%8F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/" style="font-size: 11.43px;">Android质量管理工具</a> <a href="/tags/Android%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/" style="font-size: 10px;">Android逆向工程</a> <a href="/tags/Git-github/" style="font-size: 10px;">Git && github</a> <a href="/tags/Hexo-%E4%BD%BF%E7%94%A8/" style="font-size: 15px;">Hexo 使用</a> <a href="/tags/JavaScript/" style="font-size: 10px;">JavaScript</a> <a href="/tags/Linux-%E4%BD%BF%E7%94%A8/" style="font-size: 10px;">Linux 使用</a> <a href="/tags/Objective-C-%E7%9B%B8%E5%85%B3/" style="font-size: 18.57px;">Objective C 相关</a> <a href="/tags/OpenCV/" style="font-size: 12.86px;">OpenCV</a> <a href="/tags/ROS/" style="font-size: 14.29px;">ROS</a> <a href="/tags/iOS-%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/" style="font-size: 10.71px;">iOS 工具使用</a> <a href="/tags/iOS-%E5%BC%80%E6%BA%90%E5%BA%93%E5%88%86%E6%9E%90/" style="font-size: 20px;">iOS 开源库分析</a> <a href="/tags/iOS-%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/" style="font-size: 15.71px;">iOS 理论基础</a> <a href="/tags/iOS-%E8%BF%9B%E9%98%B6/" style="font-size: 12.14px;">iOS 进阶</a> <a href="/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/" style="font-size: 10px;">代码规范</a> <a href="/tags/%E5%8D%9A%E5%AE%A2%E5%88%86%E7%B1%BB%E7%9B%AE%E5%BD%95/" style="font-size: 10.71px;">博客分类目录</a> <a href="/tags/%E5%8F%A8%E5%8F%A8%E7%B3%BB%E5%88%97/" style="font-size: 10px;">叨叨系列</a> <a href="/tags/%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/" style="font-size: 11.43px;">工具的使用</a> <a href="/tags/%E5%BC%80%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/" style="font-size: 10.71px;">开源代码分析</a> <a href="/tags/%E5%BC%80%E6%BA%90%E5%BA%93%E5%88%86%E6%9E%90/" style="font-size: 10px;">开源库分析</a> <a href="/tags/%E6%9D%82%E7%B1%BB/" style="font-size: 10px;">杂类</a> <a href="/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/" style="font-size: 12.14px;">树莓派</a> <a href="/tags/%E7%9B%B4%E6%92%AD/" style="font-size: 12.86px;">直播</a> <a href="/tags/%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/" style="font-size: 10.71px;">编程技巧</a> <a href="/tags/%E7%BD%91%E7%AB%99%E6%94%B6%E8%97%8F/" style="font-size: 10px;">网站收藏</a> <a href="/tags/%E9%87%8D%E8%A6%81%E6%8E%A7%E4%BB%B6/" style="font-size: 11.43px;">重要控件</a>
    </div>
  </div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
		
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/hsihohuang/kiddochan" target="_blank" title="Kiddochan">Kiddochan</a> © 2022 
		
		<a href="/about" target="_blank" title="Edgar">Edgar</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
        
    }
  });
});
</script>










<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?7c9443b0374f1cf6b1dbb5ab84d939cb";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="Back to Top"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
 </html>
