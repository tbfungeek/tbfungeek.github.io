
 <!DOCTYPE HTML>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
  
    <title>Edgar&#39;s Blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="Edgar">
    

    
    <meta name="description" content="Android | 全栈工程师">
<meta property="og:type" content="website">
<meta property="og:title" content="Edgar&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/page/11/index.html">
<meta property="og:site_name" content="Edgar&#39;s Blog">
<meta property="og:description" content="Android | 全栈工程师">
<meta property="og:locale">
<meta property="article:author" content="Edgar">
<meta name="twitter:card" content="summary">

    
    <link rel="alternative" href="atom.xml" title="Edgar&#39;s Blog" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/unnamed4_n_mSY_icon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/profile.png">
    <link rel="apple-touch-icon-precomposed" href="/img/profile.png">
    
    
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 6.2.0"></head>

  <body>
    <header>
      
<div>
		
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="Edgar&#39;s Blog">Edgar&#39;s Blog</a></h1>
				<h2 class="blog-motto"></h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="Menu">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
					<li>
 					
					<form class="search" action="/search/index.html" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" autocomplete="off" name="q" maxlength="20" placeholder="Search" />
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main">

   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/12/22/iOS-直播技术总结-四-音视频数据采集/" title="iOS 直播技术总结 [四] 图解 音视频数据采集" itemprop="url">iOS 直播技术总结 [四] 图解 音视频数据采集</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Edgar" target="_blank" itemprop="author">Edgar</a>
		
  <p class="article-time">
    <time datetime="2017-12-21T17:30:43.000Z" itemprop="datePublished"> Published 2017-12-22</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p><img src="/2017/12/22/iOS-%E7%9B%B4%E6%92%AD%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93-%E5%9B%9B-%E9%9F%B3%E8%A7%86%E9%A2%91%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86/001.png"></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/%E7%9B%B4%E6%92%AD/">直播</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/直播/">直播</a>
  </div>

</div>



<div class="comments-count">
	
	  	<span></span>
		<a href="/2017/12/22/iOS-直播技术总结-四-音视频数据采集/#comments" class="ds-thread-count comments-count-link" data-thread-key="2017/12/22/iOS-直播技术总结-四-音视频数据采集/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/12/20/iOS-直播技术总结-三-图解-AV-Foundation初步结构与音视频基础知识/" title="iOS 直播技术总结 [三] 图解 AV Foundation初步结构与音视频基础知识" itemprop="url">iOS 直播技术总结 [三] 图解 AV Foundation初步结构与音视频基础知识</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Edgar" target="_blank" itemprop="author">Edgar</a>
		
  <p class="article-time">
    <time datetime="2017-12-20T14:01:29.000Z" itemprop="datePublished"> Published 2017-12-20</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p><img src="/2017/12/20/iOS-%E7%9B%B4%E6%92%AD%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93-%E4%B8%89-%E5%9B%BE%E8%A7%A3-AV-Foundation%E5%88%9D%E6%AD%A5%E7%BB%93%E6%9E%84%E4%B8%8E%E9%9F%B3%E8%A7%86%E9%A2%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/001.png"><br><img src="/2017/12/20/iOS-%E7%9B%B4%E6%92%AD%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93-%E4%B8%89-%E5%9B%BE%E8%A7%A3-AV-Foundation%E5%88%9D%E6%AD%A5%E7%BB%93%E6%9E%84%E4%B8%8E%E9%9F%B3%E8%A7%86%E9%A2%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/002.png"></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>



<div class="comments-count">
	
	  	<span></span>
		<a href="/2017/12/20/iOS-直播技术总结-三-图解-AV-Foundation初步结构与音视频基础知识/#comments" class="ds-thread-count comments-count-link" data-thread-key="2017/12/20/iOS-直播技术总结-三-图解-AV-Foundation初步结构与音视频基础知识/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/12/19/iOS-直播技术总结-二-图解CDN架构/" title="iOS 直播技术总结[二] 图解CDN架构" itemprop="url">iOS 直播技术总结[二] 图解CDN架构</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Edgar" target="_blank" itemprop="author">Edgar</a>
		
  <p class="article-time">
    <time datetime="2017-12-19T14:04:51.000Z" itemprop="datePublished"> Published 2017-12-19</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p><img src="/2017/12/19/iOS-%E7%9B%B4%E6%92%AD%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93-%E4%BA%8C-%E5%9B%BE%E8%A7%A3CDN%E6%9E%B6%E6%9E%84/001.png"></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/%E7%9B%B4%E6%92%AD/">直播</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/直播/">直播</a>
  </div>

</div>



<div class="comments-count">
	
	  	<span></span>
		<a href="/2017/12/19/iOS-直播技术总结-二-图解CDN架构/#comments" class="ds-thread-count comments-count-link" data-thread-key="2017/12/19/iOS-直播技术总结-二-图解CDN架构/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/12/19/iOS-直播技术总结-一-图解iOS移动端直播技术框架/" title="iOS 直播技术总结[一] 图解iOS移动端直播技术框架" itemprop="url">iOS 直播技术总结[一] 图解iOS移动端直播技术框架</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Edgar" target="_blank" itemprop="author">Edgar</a>
		
  <p class="article-time">
    <time datetime="2017-12-19T14:01:30.000Z" itemprop="datePublished"> Published 2017-12-19</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p><img src="/2017/12/19/iOS-%E7%9B%B4%E6%92%AD%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93-%E4%B8%80-%E5%9B%BE%E8%A7%A3iOS%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9B%B4%E6%92%AD%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6/001.png"></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/%E7%9B%B4%E6%92%AD/">直播</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/直播/">直播</a>
  </div>

</div>



<div class="comments-count">
	
	  	<span></span>
		<a href="/2017/12/19/iOS-直播技术总结-一-图解iOS移动端直播技术框架/#comments" class="ds-thread-count comments-count-link" data-thread-key="2017/12/19/iOS-直播技术总结-一-图解iOS移动端直播技术框架/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/08/02/开源代码分析之Glide/" title="开源代码分析之Glide" itemprop="url">开源代码分析之Glide</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Edgar" target="_blank" itemprop="author">Edgar</a>
		
  <p class="article-time">
    <time datetime="2017-08-02T14:01:05.000Z" itemprop="datePublished"> Published 2017-08-02</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>今天要和大家一起分析的是图片加载开源库Glide,目前图片加载比较流行的开源库有Picasso,Glide,Fresco等，我用过的只有Picasso和Glide，Picasso给我的唯一感觉就是代码精简，功能强大。而Glide 相对而言代码要比Picasso复杂得多。之前项目中一直用Picasso但是后来项目中需要支持Gif才切换到Glide.Glide 特点也很明显，就是它能够响应生命周期事件以及网络状态监听事件，会随着这两类事件启动，暂停，恢复网络请求。两者的相同点就是接口相近，所以从Picasso切换到Glide不会有任何的困难。</p>
<p>好了我们先来分析下源码：</p>
<p>首先是Glide对象的创建：<br>这里的设计思想比较值得借鉴: 首先使用单例+建造者模式来创建出Glide,而将GlideMode相当于一个插件从AndroidMenifest解析出来，每个插件可以往Glide里面添加配置以及对应的组件实例.<br>这里 applyOption 以及 registerComponents 分别将 GlideBuilder 以及glide.registry 丢进去，在两个方法中将当前插件的配置信息以及插件本身注册到Glide中。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public static Glide get(Context context) &#123;</span><br><span class="line"><span class="keyword">if</span> (glide<span class="operator"> == </span>null) &#123;</span><br><span class="line">    synchronized (<span class="module-access"><span class="module"><span class="identifier">Glide</span>.</span></span><span class="keyword">class</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (glide<span class="operator"> == </span>null) &#123;</span><br><span class="line">        Context applicationContext = context.get<span class="constructor">ApplicationContext()</span>;</span><br><span class="line">        <span class="comment">//使用ManifestParser来解析AndroidMenifest中的GlideModule配置</span></span><br><span class="line">        List&lt;GlideModule&gt; modules = <span class="keyword">new</span> <span class="constructor">ManifestParser(<span class="params">applicationContext</span>)</span>.parse<span class="literal">()</span>;</span><br><span class="line">        <span class="comment">//创建一个GlideBuilder</span></span><br><span class="line">        GlideBuilder builder = <span class="keyword">new</span> <span class="constructor">GlideBuilder(<span class="params">applicationContext</span>)</span>;</span><br><span class="line">        <span class="keyword">for</span> (GlideModule <span class="keyword">module</span> : modules) &#123;</span><br><span class="line">        <span class="comment">//将从AndroidMannifest解析出来的GlideMode组件的配置添加到GlideBuilder</span></span><br><span class="line">        <span class="keyword">module</span>.apply<span class="constructor">Options(<span class="params">applicationContext</span>, <span class="params">builder</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建出对应的Glide</span></span><br><span class="line">        glide = builder.create<span class="constructor">Glide()</span>;</span><br><span class="line">        <span class="keyword">for</span> (GlideModule <span class="keyword">module</span> : modules) &#123;</span><br><span class="line">        <span class="comment">//将从AndroidMannifest解析出来的GlideMode组件添加到glide.registry</span></span><br><span class="line">        <span class="keyword">module</span>.register<span class="constructor">Components(<span class="params">applicationContext</span>, <span class="params">glide</span>.<span class="params">registry</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">return glide;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际的Glide是通过GlideBuilder的createGlide中创建的，这个套路在Picasso中也应用过，在这里主要判断加载图片所需的部件是否都进行了设置如果没有设置那么就赋给它默认的对象。<br>Glide中的主要可设置的组件有如下：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1.</span> 线程池</span><br><span class="line"><span class="bullet">2.</span> 设备缓存计算器</span><br><span class="line"><span class="bullet">3.</span> Bitmap 对象池</span><br><span class="line"><span class="bullet">4.</span> 字节数组对象池</span><br><span class="line"><span class="bullet">5.</span> 内存缓存</span><br><span class="line"><span class="bullet">6.</span> 磁盘缓存</span><br><span class="line"><span class="bullet">7.</span> Glide图片加载引擎</span><br><span class="line"><span class="bullet">8.</span> 解码格式</span><br></pre></td></tr></table></figure>
<p>这些会在涉及到的环节进行展开介绍。需要注意的是在解码格式的设置上，如果图片不支持透明度那么就使用565的格式，如果有透明度那么就使用8888的格式。这两种在保存的图片大小上会有影响。很显然8888的格式保存下来文件会相对大。但是效果会好很多。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">Glide create<span class="constructor">Glide()</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (sourceService<span class="operator"> == </span>null) &#123;</span><br><span class="line">    <span class="comment">//判断线程池是否已经设置,如果没有设置，那么会使用默认的先进先出优先级队列线程池，最大的线程数为当前唤醒的CPU核数</span></span><br><span class="line">    <span class="comment">//它主要用于当从缓存中没有找到对应的对象时执行Glide的加载，解码和转换任务</span></span><br><span class="line">    final <span class="built_in">int</span> cores = <span class="module-access"><span class="module"><span class="identifier">Math</span>.</span></span>max(<span class="number">1</span>, <span class="module-access"><span class="module"><span class="identifier">Runtime</span>.</span></span>get<span class="constructor">Runtime()</span>.available<span class="constructor">Processors()</span>);</span><br><span class="line">    sourceService = <span class="keyword">new</span> <span class="constructor">FifoPriorityThreadPoolExecutor(<span class="string">&quot;source&quot;</span>, <span class="params">cores</span>)</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (diskCacheService<span class="operator"> == </span>null) &#123;</span><br><span class="line">    <span class="comment">//它主要用于当从缓存中有对应的对象时，用来执行Glide的加载，解码和转换任务</span></span><br><span class="line">    <span class="comment">//如果缓存线程池没有特殊指定那么将会使用最大线程数为1的先入先出优先级队列线程池</span></span><br><span class="line">    diskCacheService = <span class="keyword">new</span> <span class="constructor">FifoPriorityThreadPoolExecutor(<span class="string">&quot;disk-cache&quot;</span>, 1)</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (memorySizeCalculator<span class="operator"> == </span>null) &#123;</span><br><span class="line">    <span class="comment">//某个设备缓存计算器，计算结果取决于一些常量和当前设备的信息（宽，高，像素密度）</span></span><br><span class="line">    memorySizeCalculator = <span class="keyword">new</span> MemorySizeCalculator.<span class="constructor">Builder(<span class="params">context</span>)</span>.build<span class="literal">()</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (bitmapPool<span class="operator"> == </span>null) &#123;</span><br><span class="line">    <span class="comment">//Bitmap对象池初始化</span></span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.HONEYCOMB) &#123;</span><br><span class="line">      <span class="comment">//通过memorySizeCalculator计算出缓存大小</span></span><br><span class="line">      <span class="built_in">int</span> size = memorySizeCalculator.get<span class="constructor">BitmapPoolSize()</span>;</span><br><span class="line">      <span class="keyword">if</span> (DecodeFormat.REQUIRE_ARGB_8888) &#123;</span><br><span class="line">        bitmapPool = <span class="keyword">new</span> <span class="constructor">LruBitmapPool(<span class="params">size</span>, Collections.<span class="params">singleton</span>(Bitmap.Config.ARGB_8888)</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        bitmapPool = <span class="keyword">new</span> <span class="constructor">LruBitmapPool(<span class="params">size</span>)</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      bitmapPool = <span class="keyword">new</span> <span class="constructor">BitmapPoolAdapter()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (byteArrayPool<span class="operator"> == </span>null) &#123;</span><br><span class="line">    <span class="comment">//基于LRU算法的数组缓存池</span></span><br><span class="line">    byteArrayPool = <span class="keyword">new</span> <span class="constructor">LruByteArrayPool()</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (memoryCache<span class="operator"> == </span>null) &#123;</span><br><span class="line">    <span class="comment">//内存缓存</span></span><br><span class="line">    memoryCache = <span class="keyword">new</span> <span class="constructor">LruResourceCache(<span class="params">memorySizeCalculator</span>.<span class="params">getMemoryCacheSize</span>()</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (diskCacheFactory<span class="operator"> == </span>null) &#123;</span><br><span class="line">    <span class="comment">//磁盘缓存</span></span><br><span class="line">    diskCacheFactory = <span class="keyword">new</span> <span class="constructor">InternalCacheDiskCacheFactory(<span class="params">context</span>, Glide.DEFAULT_DISK_CACHE_SIZE)</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (engine<span class="operator"> == </span>null) &#123;</span><br><span class="line">    <span class="comment">//负责开启加载任务以及管理活跃的或者缓存的图片资源</span></span><br><span class="line">    engine = <span class="keyword">new</span> <span class="constructor">Engine(<span class="params">memoryCache</span>, <span class="params">diskCacheFactory</span>, <span class="params">diskCacheService</span>, <span class="params">sourceService</span>)</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//解码格式</span></span><br><span class="line">  <span class="keyword">if</span> (decodeFormat<span class="operator"> == </span>null) &#123;</span><br><span class="line">    <span class="comment">//图片的加载格式（ARGB_8888或RGB_565），默认ARGB_8888，判断规则如下</span></span><br><span class="line">    <span class="comment">//如果支持透明或者使用了透明则使用ARGB_8888</span></span><br><span class="line">    <span class="comment">//如果不支持透明则使用ARGB_565</span></span><br><span class="line">    decodeFormat = DecodeFormat.DEFAULT;</span><br><span class="line">  &#125;</span><br><span class="line">  return <span class="keyword">new</span> <span class="constructor">Glide(<span class="params">engine</span>, <span class="params">memoryCache</span>, <span class="params">bitmapPool</span>, <span class="params">byteArrayPool</span>, <span class="params">context</span>, <span class="params">decodeFormat</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>紧接着就是调用Glide 构造方法来创建对象。在Glide 构造方法中最主要的任务就是注册一系列内置的图片资源编解码器，创建ImageViewTargetFactory，新建RequestOptions，并为其设置图片编码格式。最后将全局中比较常用的Glide,Register,RequestOption,Engine存放到GlideContext 中供后续使用，这个也是比较常用的方式。注册器会在后面进行进一步介绍。这里先主要看下整个流程。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">@<span class="constructor">TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)</span></span><br><span class="line">  <span class="constructor">Glide(Engine <span class="params">engine</span>, MemoryCache <span class="params">memoryCache</span>, BitmapPool <span class="params">bitmapPool</span>, ByteArrayPool <span class="params">byteArrayPool</span>, Context <span class="params">context</span>, DecodeFormat <span class="params">decodeFormat</span>)</span> &#123;</span><br><span class="line">    this.engine = engine;</span><br><span class="line">    this.bitmapPool = bitmapPool;</span><br><span class="line">    this.byteArrayPool = byteArrayPool;</span><br><span class="line">    this.memoryCache = memoryCache;</span><br><span class="line">    <span class="comment">//BitmapPool的预填充器</span></span><br><span class="line">    bitmapPreFiller = <span class="keyword">new</span> <span class="constructor">BitmapPreFiller(<span class="params">memoryCache</span>, <span class="params">bitmapPool</span>, <span class="params">decodeFormat</span>)</span>;</span><br><span class="line">    Resources resources = context.get<span class="constructor">Resources()</span>;</span><br><span class="line">    <span class="comment">//从给定的inputstream中解码图片</span></span><br><span class="line">    Downsampler downsampler = <span class="keyword">new</span> <span class="constructor">Downsampler(<span class="params">resources</span>.<span class="params">getDisplayMetrics</span>()</span>, bitmapPool, byteArrayPool);</span><br><span class="line">    <span class="comment">//Gif图片资源的解码器</span></span><br><span class="line">    ByteBufferGifDecoder byteBufferGifDecoder = <span class="keyword">new</span> <span class="constructor">ByteBufferGifDecoder(<span class="params">context</span>, <span class="params">bitmapPool</span>, <span class="params">byteArrayPool</span>)</span>;</span><br><span class="line">    <span class="comment">//用于管理组件注册器，我们还可以自己自定义组件通过GlideModule registerComponents来进行注册</span></span><br><span class="line">    registry = <span class="keyword">new</span> <span class="constructor">Registry(<span class="params">context</span>)</span></span><br><span class="line">        <span class="comment">//添加到encoderRegistry public &lt;Data&gt; Registry register(Class&lt;Data&gt; dataClass, Encoder&lt;Data&gt; encoder)</span></span><br><span class="line">        .register(<span class="module-access"><span class="module"><span class="identifier">ByteBuffer</span>.</span></span><span class="keyword">class</span>, <span class="keyword">new</span> <span class="constructor">ByteBufferEncoder()</span>)<span class="comment">//将ByteBuffers 数据写入到文件中</span></span><br><span class="line">        .register(<span class="module-access"><span class="module"><span class="identifier">InputStream</span>.</span></span><span class="keyword">class</span>, <span class="keyword">new</span> <span class="constructor">StreamEncoder(<span class="params">byteArrayPool</span>)</span>)<span class="comment">//将inputStream数据写入到文件中</span></span><br><span class="line">        <span class="comment">//..................</span></span><br><span class="line">        <span class="comment">/* Transcoders */</span></span><br><span class="line">        .register(<span class="module-access"><span class="module"><span class="identifier">Bitmap</span>.</span></span><span class="keyword">class</span>, <span class="module-access"><span class="module"><span class="identifier">BitmapDrawable</span>.</span></span><span class="keyword">class</span>, <span class="keyword">new</span> <span class="constructor">BitmapDrawableTranscoder(<span class="params">resources</span>, <span class="params">bitmapPool</span>)</span>)</span><br><span class="line">        .register(<span class="module-access"><span class="module"><span class="identifier">Bitmap</span>.</span></span><span class="keyword">class</span>, byte<span class="literal">[]</span>.<span class="keyword">class</span>, <span class="keyword">new</span> <span class="constructor">BitmapBytesTranscoder()</span>)</span><br><span class="line">        .register(<span class="module-access"><span class="module"><span class="identifier">GifDrawable</span>.</span></span><span class="keyword">class</span>, byte<span class="literal">[]</span>.<span class="keyword">class</span>, <span class="keyword">new</span> <span class="constructor">GifDrawableBytesTranscoder()</span>);</span><br><span class="line">    <span class="comment">//用于负责生成特定类型的Target</span></span><br><span class="line">    ImageViewTargetFactory imageViewTargetFactory = <span class="keyword">new</span> <span class="constructor">ImageViewTargetFactory()</span>;</span><br><span class="line">    <span class="comment">//设置解码格式</span></span><br><span class="line">    RequestOptions options = <span class="keyword">new</span> <span class="constructor">RequestOptions()</span>.format(decodeFormat);</span><br><span class="line">    <span class="comment">//通过Context形式暴露出来</span></span><br><span class="line">    glideContext = <span class="keyword">new</span> <span class="constructor">GlideContext(<span class="params">context</span>, <span class="params">registry</span>, <span class="params">imageViewTargetFactory</span>, <span class="params">options</span>, <span class="params">engine</span>, <span class="params">this</span>)</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>到目前为止，Glide对象创建结束，我们回顾下整个过程：</p>
<ol>
<li>首先是从AndroidManifest查找是否有用户自定义的GlideModule，如果有的话将其解析出来，每个GlideModule一般有两个方法，applyOptions和registerComponents ，applyOptions负责将自定义GlideModule中的配置添加到GlideBuilder中，而registerComponents 负责将当前GlideModule添加到Register中。</li>
<li>然后在GlideBuilder 的createGlide方法中为没有设置的Glide重要组件设置默认状态。</li>
<li>最后调用Glide构造方法创建对象。在构造方法中主要是完成各种资源编解码器的注册，以及Target的构建工厂对象的创建。以及设置解码格式和Glide图片加载引擎。</li>
<li>通过 GlideContext将后续处理常用的组件暴露出来。</li>
</ol>
<p>Glide创建出来后就进入了with阶段：<br>之前提到的Glide 图片加载过程中会响应Activity&#x2F;Fragment生命周期 以及网络状态而启动，恢复，暂停图片加载请求都是在这个环节中体现的。这个环节中主要的两个对象是RequestManagerFragment 以及 ConnectivityMonitor。<br>好了我们接下来就来带着这两个问题进一步阅读源码：</p>
<p>大家可以发现Glide.java 中有很多with方法，为什么需要重载这么多个呢？它们之间的区别是什么呢？</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">使用context启动的请求将只会拥有应用等级的<span class="keyword">options</span>，不会根据生命周期事件来自动开始或者停止图片的加载。通常而言，如果资源在一个子Fragment中的一个<span class="keyword">View</span>中使用，那么<span class="keyword">load</span>就应该使用子Fragment作为参数的<span class="keyword">with</span>方法。如果资源应用在父Fragment中的<span class="keyword">View</span>中，那么<span class="keyword">load</span>就应该使用父Fragment作为参数的<span class="keyword">with</span>方法。同样的道理如果资源在Activity中使用那么就应该使用Activity作为参数的<span class="keyword">with</span>方法，使用Context作为参数的一般用于不在常用的fragment或者activity生命周期的资源，比如services或者notification中资源</span><br></pre></td></tr></table></figure>
<p>我们以最常用的Activty的情况作为分析情景：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestManager <span class="title">with</span>(<span class="params">Activity activity</span>)</span> &#123;</span><br><span class="line">    RequestManagerRetriever retriever = RequestManagerRetriever.<span class="keyword">get</span>();</span><br><span class="line">    <span class="keyword">return</span> retriever.<span class="keyword">get</span>(activity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一阶段我们先看下怎么获取到RequestManagerFragment,首先我们应该明白RequestManagerFragment和我们开发过程中常见的Fragment的区别是它是一个没有界面不可见的一个Fragment，但是它有Fragment所拥有的生命周期。我们可以借助这一点来实现前面提到的图片加载请求状态随着生命周期的改变而改变。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> RequestManager <span class="keyword">get</span>(Activity activity) &#123;</span><br><span class="line">  <span class="keyword">if</span> (Util.isOnBackgroundThread() || Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.HONEYCOMB) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">get</span>(activity.getApplicationContext());</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//获取它的FragmentManager，并且将activity以及FragmentManager传入fragmentGet获取RequestManagerFragment</span></span><br><span class="line">    android.app.FragmentManager fm = activity.getFragmentManager();</span><br><span class="line">    <span class="comment">//获取RequestManagerFragment</span></span><br><span class="line">    <span class="keyword">return</span> fragmentGet(activity, fm);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么对于Activity而言这个Fragment藏在哪里呢？它和Activty所拥有的一般Fragment一样都归到Activity FragmentManager中统一管理。我们看下这个过程：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">RequestManager fragment<span class="constructor">Get(Context <span class="params">context</span>, <span class="params">android</span>.<span class="params">app</span>.FragmentManager <span class="params">fm</span>)</span> &#123;</span><br><span class="line">  <span class="comment">//从指定的FragmentManager获取对应的RequestManagerFragment，</span></span><br><span class="line">  <span class="comment">//如果没有那么就直接新建一个RequestManagerFragment添加到FragmentManager</span></span><br><span class="line">  RequestManagerFragment current = get<span class="constructor">RequestManagerFragment(<span class="params">fm</span>)</span>;</span><br><span class="line">  <span class="comment">//从RequestManagerFragment中获取RequestManager</span></span><br><span class="line">  RequestManager requestManager = current.get<span class="constructor">RequestManager()</span>;</span><br><span class="line">  <span class="comment">//如果都没获取到那么就新建一个RequestManager将其设置到RequestManagerFragment</span></span><br><span class="line">  <span class="keyword">if</span> (requestManager<span class="operator"> == </span>null) &#123;</span><br><span class="line">    requestManager = <span class="keyword">new</span> <span class="constructor">RequestManager(<span class="params">context</span>, <span class="params">current</span>.<span class="params">getLifecycle</span>()</span>, current.get<span class="constructor">RequestManagerTreeNode()</span>);</span><br><span class="line">    current.set<span class="constructor">RequestManager(<span class="params">requestManager</span>)</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  return requestManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面代码可以看出，这个阶段首先会先从FragmentManger 中获取，如果没获取到就会新建一个并添加到FragmentManager，获取完RequestManagerFragment后就从中获取RequestManager,下面是获取RequestManagerFragment的过程代码：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">RequestManagerFragment get<span class="constructor">RequestManagerFragment(<span class="params">final</span> <span class="params">android</span>.<span class="params">app</span>.FragmentManager <span class="params">fm</span>)</span> &#123;</span><br><span class="line">  <span class="comment">//使用Fragment查找TAG为com.bumptech.glide.manager的Fragment</span></span><br><span class="line">  RequestManagerFragment current = (RequestManagerFragment) fm.find<span class="constructor">FragmentByTag(FRAGMENT_TAG)</span>;</span><br><span class="line">  <span class="keyword">if</span> (current<span class="operator"> == </span>null) &#123;</span><br><span class="line">    <span class="comment">//尝试从pendingRequestManagerFragments获取,有可能还在缓存中</span></span><br><span class="line">    current = pendingRequestManagerFragments.get(fm);</span><br><span class="line">    <span class="keyword">if</span> (current<span class="operator"> == </span>null) &#123;</span><br><span class="line">      <span class="comment">//新建一个RequestManagerFragment，添加到pendingRequestManagerFragments缓存</span></span><br><span class="line">      current = <span class="keyword">new</span> <span class="constructor">RequestManagerFragment()</span>;</span><br><span class="line">      pendingRequestManagerFragments.put(fm, current);</span><br><span class="line">      <span class="comment">//将新建的RequestManagerFragment添加到FragmentManager中</span></span><br><span class="line">      fm.<span class="keyword">begin</span><span class="constructor">Transaction()</span>.add(current, FRAGMENT_TAG).commit<span class="constructor">AllowingStateLoss()</span>;</span><br><span class="line">      <span class="comment">//提交成功后移除pendingRequestManagerFragments中的RequestManagerFragment</span></span><br><span class="line">      <span class="comment">//但是为什么不直接调用pendingRequestManagerFragments.remove方法呢？</span></span><br><span class="line">      handler.obtain<span class="constructor">Message(ID_REMOVE_FRAGMENT_MANAGER, <span class="params">fm</span>)</span>.send<span class="constructor">ToTarget()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return current;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们上面介绍了RequestManagerFragment的获取方式，那么RequestManagerFragment又是怎么将请求和生命周期给对应起来的呢？在回答这个问题之前我们先来看下RequestManagerFragment的结构，RequestManagerFragment中有两个重要对象ActivityFragmentLifecycle，RequestManager<br>前者是生命周期的触发者，需要响应生命周期的部件都需要监听它，而RequstManger负责请求的管理，它里面有个RequestTracker 用于实行请求的管理。RequstManaer是生命周期事件的响应者，RequestManagerFragment触发对应生命周期后通过ActivityFragmentLifecycle传出来，ActivityFragmentLifecycle再通知监听它的监听者。对应的监听者在不同的生命周期作出不同的响应。</p>
<p>我们来看下这部分的代码<br>ActivityFragmentLifecycle 是在RequestManagerFragment构造方法中创建的，如下所示：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RequestManagerFragment</span>()</span> &#123;</span><br><span class="line">  <span class="keyword">this</span>(<span class="keyword">new</span> ActivityFragmentLifecycle());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>RequestManager是通过setRequestManager进行注入的，这个可以看之前的代码介绍。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">setRequestManager</span>(<span class="params">RequestManager requestManager</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">requestManager</span> = requestManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们再看下RequestManagerFragment的生命周期中做了什么，和之前说的一样它在对应的生命周期中触发lifecycle事件，</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">onStart</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>.<span class="title function_">onStart</span>();</span><br><span class="line">    lifecycle.<span class="title function_">onStart</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">onStop</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>.<span class="title function_">onStop</span>();</span><br><span class="line">    lifecycle.<span class="title function_">onStop</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">onDestroy</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>.<span class="title function_">onDestroy</span>();</span><br><span class="line">    lifecycle.<span class="title function_">onDestroy</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ActivityFragmentLifecycle 很简单就是注册对应生命周期事件的观察者，一旦ActivtyFragmentLifeCyble被RequestManagerFragment 生命周期所触发，那么ActivtyFragmentLifeCycle也会将对应的事件通知到各个观察者。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">  public void add<span class="constructor">Listener(LifecycleListener <span class="params">listener</span>)</span> &#123;</span><br><span class="line">    <span class="comment">//添加监听器，并将当前状态通知到其观察者</span></span><br><span class="line">    lifecycleListeners.add(listener);</span><br><span class="line">    <span class="keyword">if</span> (isDestroyed) &#123;</span><br><span class="line">      listener.on<span class="constructor">Destroy()</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isStarted) &#123;</span><br><span class="line">      listener.on<span class="constructor">Start()</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      listener.on<span class="constructor">Stop()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void remove<span class="constructor">Listener(LifecycleListener <span class="params">listener</span>)</span> &#123;</span><br><span class="line">    lifecycleListeners.remove(listener);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void on<span class="constructor">Start()</span> &#123;</span><br><span class="line">    isStarted = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (LifecycleListener lifecycleListener : <span class="module-access"><span class="module"><span class="identifier">Util</span>.</span></span>get<span class="constructor">Snapshot(<span class="params">lifecycleListeners</span>)</span>) &#123;</span><br><span class="line">      lifecycleListener.on<span class="constructor">Start()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void on<span class="constructor">Stop()</span> &#123;</span><br><span class="line">    isStarted = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (LifecycleListener lifecycleListener : <span class="module-access"><span class="module"><span class="identifier">Util</span>.</span></span>get<span class="constructor">Snapshot(<span class="params">lifecycleListeners</span>)</span>) &#123;</span><br><span class="line">      lifecycleListener.on<span class="constructor">Stop()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void on<span class="constructor">Destroy()</span> &#123;</span><br><span class="line">    isDestroyed = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (LifecycleListener lifecycleListener : <span class="module-access"><span class="module"><span class="identifier">Util</span>.</span></span>get<span class="constructor">Snapshot(<span class="params">lifecycleListeners</span>)</span>) &#123;</span><br><span class="line">      lifecycleListener.on<span class="constructor">Destroy()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>ActivtyFragmentLifeCycle 有两个重要的观察者：RequestManager 和 ConnectivityMonitor。所以这个阶段的整个过程如下图所示：</p>
<p><img src="/2017/08/02/%E5%BC%80%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BGlide/glide001.png"></p>
<p>到此为止with阶段代码分析完毕，我们来简单回顾下：<br>这个阶段主要是完成请求随着生命周期的状态改变而改变状态的工作。主要涉及到四个重要对象一个是RequestManagerFragment 一个是 ActivityFragmentLifeCycle ,还有两个是RequestManger,以及ConnectivityMonitor。三者之间的关系以及如何实现请求随着生命周期的状态改变而改变状态这个在上面已经详细介绍过了。这个需要重点了解下。</p>
<p>接下来是as阶段：</p>
<p>load 有多种实现，现将这些实现都罗列如下：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将资源指定加载为Bitmap，即使实际上可能是一个动画也会将资源加载为Bitmap</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RequestBuilder&lt;Bitmap&gt; <span class="title">asBitmap</span>()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">as</span>(Bitmap.<span class="keyword">class</span>).transition(<span class="keyword">new</span> BitmapTransitionOptions()).apply(DECODE_TYPE_BITMAP);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 尝试将资源总是以GifDrawable形式加载</span></span><br><span class="line"><span class="comment"> * 这种情况如果数据不是GIF，则会失败。因此，这只能使用与下面的情况：</span></span><br><span class="line"><span class="comment"> * 如果数据代表动画GIF，并且调用者想要与GifDrawable进行交互</span></span><br><span class="line"><span class="comment"> * 通常情况只需要使用asDrawable就足够了，因为它会确定给定的数据是否代表动画GIF并返回相应的Drawable</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RequestBuilder&lt;GifDrawable&gt; <span class="title">asGif</span>()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">as</span>(GifDrawable.<span class="keyword">class</span>).transition(<span class="keyword">new</span> DrawableTransitionOptions()).apply(DECODE_TYPE_GIF);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 尝试使用注册的ResourceDecoder来加载指定的资源</span></span><br><span class="line"><span class="comment"> * 默认情况下，返回的要么是个BitmapDrawable要么是个GifDrawable 但是如果其他用于解码Drawable的解码器有注册，那么它们有可能也会被返回</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RequestBuilder&lt;Drawable&gt; <span class="title">asDrawable</span>()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">as</span>(Drawable.<span class="keyword">class</span>).transition(<span class="keyword">new</span> DrawableTransitionOptions());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面最终都是调用如下方法：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 尝试使用任何注册的能够解析给定的资源class或者给定资源class子类的ResourceDecoder来加载资源</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> &lt;ResourceType&gt; <span class="function"><span class="title">RequestBuilder</span>&lt;<span class="title">ResourceType</span>&gt; <span class="title">as</span>(<span class="params">Class&lt;ResourceType&gt; resourceClass</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RequestBuilder&lt;&gt;(context, <span class="keyword">this</span>, resourceClass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从这里可以看出load阶段的工作就是创建一个RequestBuilder。</p>
<p>创建了一个RequestBuilder后就可以调用load开始加载了。我们来看下load阶段：</p>
<p>和as以及with阶段一样load也有各种重载，但是最终还是调用：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> RequestBuilder&lt;TranscodeType&gt; loadGeneric(Object model) &#123;</span><br><span class="line">  <span class="comment">//这个很简单设置model并且将isModelSet设置为true</span></span><br><span class="line">  <span class="keyword">this</span>.model = model;</span><br><span class="line">  isModelSet = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里只是简单得设置了model并将isModelSet标识为设为true后返回。很简单吧，其实Picasso这个阶段也很简单，不信可以看下我之前写的博客。</p>
<p>Glide对象创建了，请求状态随生命周期改变而改变实现了，RequestBuilder创建出来了，model设置了,接下来就是最重要的图片加载流程了，也就是into阶段：</p>
<p>into阶段实际上就是开始加载图片数据，并将图片数据设置到Target上，我们这里以ImageView为Target来看下这个流程：<br>  <figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Target&lt;TranscodeType&gt; <span class="title">into</span>(<span class="params">ImageView view</span>)</span> &#123;</span><br><span class="line">  <span class="comment">//..........</span></span><br><span class="line">  <span class="keyword">if</span> (!requestOptions.isTransformationSet() &amp;&amp; view.getScaleType() != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (requestOptions.isLocked()) &#123;</span><br><span class="line">      requestOptions = requestOptions.clone();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">switch</span> (view.getScaleType()) &#123;</span><br><span class="line">      <span class="keyword">case</span> CENTER_CROP:</span><br><span class="line">        requestOptions.optionalCenterCrop(context);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> FIT_CENTER:</span><br><span class="line">      <span class="keyword">case</span> FIT_START:</span><br><span class="line">      <span class="keyword">case</span> FIT_END:</span><br><span class="line">        requestOptions.optionalFitCenter(context);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="comment">//$CASES-OMITTED$</span></span><br><span class="line">      <span class="literal">default</span>:</span><br><span class="line">        <span class="comment">// Do nothing.</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">into</span>(context.buildImageViewTarget(view, transcodeClass));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在这个阶段最重要的是最后一行代码into(context.buildImageViewTarget(view, transcodeClass))</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public &lt;X&gt; Target&lt;X&gt; build<span class="constructor">ImageViewTarget(ImageView <span class="params">imageView</span>, Class&lt;X&gt; <span class="params">transcodeClass</span>)</span> &#123;</span><br><span class="line">  return imageViewTargetFactory.build<span class="constructor">Target(<span class="params">imageView</span>, <span class="params">transcodeClass</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里使用Glide对象构造阶段创建的ImageViewTargetFactory来创建出我们需要的Target,具体需要创建什么Target需要根据transcodeClass来决定。</p>
<figure class="highlight cos"><table><tr><td class="code"><pre><span class="line">public &lt;Z&gt; Target&lt;Z&gt; buildTarget(ImageView <span class="keyword">view</span>, <span class="keyword">Class</span>&lt;Z&gt; clazz) &#123;</span><br><span class="line">    <span class="keyword">if</span> (Bitmap.<span class="keyword">class</span>.equals(clazz)) &#123;</span><br><span class="line">      <span class="keyword">return</span> (Target&lt;Z&gt;) <span class="keyword">new</span> BitmapImageViewTarget(<span class="keyword">view</span>)<span class="comment">;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Drawable.<span class="keyword">class</span>.isAssignableFrom(clazz)) &#123;</span><br><span class="line">      <span class="keyword">return</span> (Target&lt;Z&gt;) <span class="keyword">new</span> DrawableImageViewTarget(<span class="keyword">view</span>)<span class="comment">;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">          <span class="string">&quot;Unhandled class: &quot;</span> + clazz + <span class="string">&quot;, try .as*(Class).transcode(ResourceTranscoder)&quot;</span>)<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>而transcodeClass 是在创建RequestBuilder的时候传入的，而RequestBuilder是在as方法中创建的，所以这里的resourceClass就是buildTarget所对应的transcodeClass。所以我们调用asBitmap 的时候这里传入的就是Bitmap.class，调用asGif的时候这里传入的就是GifDrawable.class，如果我们调用asDrawable的时候，这里传入的就是Drawable.class。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;ResourceType&gt; <span class="function"><span class="title">RequestBuilder</span>&lt;<span class="title">ResourceType</span>&gt; <span class="title">as</span>(<span class="params">Class&lt;ResourceType&gt; resourceClass</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> RequestBuilder&lt;&gt;(context, <span class="keyword">this</span>, resourceClass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不管怎样buildTarget 返回的就两个对象要么是BitmapImageViewTarget要么是DrawableImageViewTarget</p>
<p>BitmapImageViewTarget –&gt; ImageViewTarget<Bitmap><br>DrawableImageViewTarget –&gt; ImageViewTarget<Drawable></Drawable></Bitmap></p>
<p>但是我们前面已经提到asDrawable 和asGif两个都是对应的DrawableImageViewTarget那么这两个会有什么区别呢？我们看下DrawableImageViewTarget,两种区别在于是否继承自Animatable，GifDrawable是继承自Animatable 所以在资源获取结束后会调用start方法让它动起来。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">onResourceReady</span>(<span class="params">Drawable resource, Transition&lt;? <span class="variable language_">super</span> Drawable&gt; transition</span>) &#123;</span><br><span class="line">  <span class="title class_">ViewGroup</span>.<span class="property">LayoutParams</span> layoutParams = view.<span class="title function_">getLayoutParams</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!(resource <span class="keyword">instanceof</span> <span class="title class_">Animatable</span>) &amp;&amp; layoutParams != <span class="literal">null</span> &amp;&amp; layoutParams.<span class="property">width</span> &gt; <span class="number">0</span></span><br><span class="line">      &amp;&amp; layoutParams.<span class="property">height</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    resource = <span class="keyword">new</span> <span class="title class_">FixedSizeDrawable</span>(resource, layoutParams.<span class="property">width</span>, layoutParams.<span class="property">height</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">super</span>.<span class="title function_">onResourceReady</span>(resource, transition);</span><br><span class="line">  <span class="keyword">if</span> (resource <span class="keyword">instanceof</span> <span class="title class_">Animatable</span>) &#123;</span><br><span class="line">    ((<span class="title class_">Animatable</span>) resource).<span class="title function_">start</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">onStart</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (resource <span class="keyword">instanceof</span> <span class="title class_">Animatable</span>) &#123;</span><br><span class="line">    ((<span class="title class_">Animatable</span>) resource).<span class="title function_">start</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">onStop</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (resource <span class="keyword">instanceof</span> <span class="title class_">Animatable</span>) &#123;</span><br><span class="line">    ((<span class="title class_">Animatable</span>) resource).<span class="title function_">stop</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们再继续顺着继承树看下去，</p>
<p>BitmapImageViewTarget –&gt; ImageViewTarget<Bitmap>      –&gt; ViewTarget –&gt; BaseTarget<br>DrawableImageViewTarget –&gt; ImageViewTarget<Drawable>  –&gt; ViewTarget –&gt; BaseTarget</Drawable></Bitmap></p>
<p>ViewTarget 中有几个重要的回调函数onLoadStarted，onLoadFailed ，onLoadCleared ，onResourceReady<br>分别在启动加载，加载失败，清除加载，资源获取完毕的情况下回调，主要用于设置占位图片，错误图片以及加载完的图片</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">onLoadStarted</span>(<span class="params">Drawable placeholder</span>) &#123;</span><br><span class="line">  <span class="title function_">setResource</span>(<span class="literal">null</span>);</span><br><span class="line">  <span class="title function_">setDrawable</span>(placeholder);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">onLoadFailed</span>(<span class="params">Drawable errorDrawable</span>) &#123;</span><br><span class="line">  <span class="title function_">setResource</span>(<span class="literal">null</span>);</span><br><span class="line">  <span class="title function_">setDrawable</span>(errorDrawable);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">onLoadCleared</span>(<span class="params">Drawable placeholder</span>) &#123;</span><br><span class="line">  <span class="title function_">setResource</span>(<span class="literal">null</span>);</span><br><span class="line">  <span class="title function_">setDrawable</span>(placeholder);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">onResourceReady</span>(<span class="params">Z resource, Transition&lt;? <span class="variable language_">super</span> Z&gt; transition</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (transition == <span class="literal">null</span> || !transition.<span class="title function_">transition</span>(resource, <span class="variable language_">this</span>)) &#123;</span><br><span class="line">    <span class="title function_">setResource</span>(resource);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个继承树根真深，还得继续刨：<br>ViewTarget有两个重要的任务就是获取这个view的Size以及设置tag：<br>这里有个重要的对象SizeDeterminer，获取View的尺寸就是通过这个类来完成的。它首先会先通过getWidth()和getHeight()来获取View的宽高，如果有一个为0的话，它会检查View的LayoutParams从中获取宽高大小，如果还是没有那么就会监听OnPreDrawListener回调从而等到在绘制之前进行测量的时候回调。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public void get<span class="constructor">Size(SizeReadyCallback <span class="params">cb</span>)</span> &#123;</span><br><span class="line">  <span class="comment">//调用View的getWidth 和 getHeight获取，如果获取不到尝试LayoutParams中获取</span></span><br><span class="line">  <span class="built_in">int</span> currentWidth = get<span class="constructor">ViewWidthOrParam()</span>;</span><br><span class="line">  <span class="built_in">int</span> currentHeight = get<span class="constructor">ViewHeightOrParam()</span>;</span><br><span class="line">  <span class="comment">//如果通过上述两种方式能够获取到宽高，那么就直接调用onSizeReady将宽高传出</span></span><br><span class="line">  <span class="keyword">if</span> (is<span class="constructor">SizeValid(<span class="params">currentWidth</span>)</span><span class="operator"> &amp;&amp; </span>is<span class="constructor">SizeValid(<span class="params">currentHeight</span>)</span>) &#123;</span><br><span class="line">    cb.on<span class="constructor">SizeReady(<span class="params">currentWidth</span>, <span class="params">currentHeight</span>)</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//如果通过上述两种方式都不能获取到高度那么只能通过添加OnPreDrawListener来等到该View 测量结束后返回宽高</span></span><br><span class="line">    <span class="keyword">if</span> (!cbs.contains(cb)) &#123;</span><br><span class="line">      cbs.add(cb);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (layoutListener<span class="operator"> == </span>null) &#123;</span><br><span class="line">      final ViewTreeObserver observer = view.get<span class="constructor">ViewTreeObserver()</span>;</span><br><span class="line">      layoutListener = <span class="keyword">new</span> <span class="constructor">SizeDeterminerLayoutListener(<span class="params">this</span>)</span>;</span><br><span class="line">      observer.add<span class="constructor">OnPreDrawListener(<span class="params">layoutListener</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在测量结束的时候会调用checkCurrentDimens来检查当前的宽高</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onPreDraw</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">SizeDeterminer</span> <span class="variable">sizeDeterminer</span> <span class="operator">=</span> sizeDeterminerRef.get();</span><br><span class="line">  <span class="keyword">if</span> (sizeDeterminer != <span class="literal">null</span>) &#123;</span><br><span class="line">    sizeDeterminer.checkCurrentDimens();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在checkCurrentDimens 会重新获取并检查View的宽高如果获取到了就通过notifyCbs来通知对应的监听者。<br>并将其从OnPreDrawListener监听队列中返回。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> void check<span class="constructor">CurrentDimens()</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (cbs.is<span class="constructor">Empty()</span>) &#123;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">int</span> currentWidth = get<span class="constructor">ViewWidthOrParam()</span>;</span><br><span class="line">  <span class="built_in">int</span> currentHeight = get<span class="constructor">ViewHeightOrParam()</span>;</span><br><span class="line">  <span class="keyword">if</span> (!is<span class="constructor">SizeValid(<span class="params">currentWidth</span>)</span><span class="operator"> || </span>!is<span class="constructor">SizeValid(<span class="params">currentHeight</span>)</span>) &#123;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  notify<span class="constructor">Cbs(<span class="params">currentWidth</span>, <span class="params">currentHeight</span>)</span>;</span><br><span class="line">  ViewTreeObserver observer = view.get<span class="constructor">ViewTreeObserver()</span>;</span><br><span class="line">  <span class="keyword">if</span> (observer.is<span class="constructor">Alive()</span>) &#123;</span><br><span class="line">    observer.remove<span class="constructor">OnPreDrawListener(<span class="params">layoutListener</span>)</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  layoutListener = null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以整个继承树的完成工作如下：<br>DrawableImageViewTarget –&gt; ImageViewTarget<Drawable>  –&gt; ViewTarget –&gt; BaseTarget<br>将加载的图片设置到Target,如果是Gif启动播放Gif –&gt; 设置占位图，错误图缩率图等 –&gt; 获取图片尺寸，设置Tag –&gt; 存储Request<br>有了上述的了解我们再继续返回看into的流程：</Drawable></p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;Y <span class="keyword">extends</span> Target&lt;TranscodeType&gt;&gt; <span class="function">Y <span class="title">into</span><span class="params">(Y <span class="keyword">target</span>)</span> </span>&#123;</span><br><span class="line">  Util.assertMainThread();</span><br><span class="line">  <span class="comment">//Target不能为空</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">target</span> == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;You must pass in a non null Target&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//model必须设置</span></span><br><span class="line">  <span class="keyword">if</span> (!isModelSet) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;You must first put a model (try #load())&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//获取当前target中的请求</span></span><br><span class="line">  Request previous = <span class="keyword">target</span>.getRequest();</span><br><span class="line">  <span class="comment">//如果当前target存在请求，那么清除target对应的请求</span></span><br><span class="line">  <span class="keyword">if</span> (previous != <span class="keyword">null</span>) &#123;</span><br><span class="line">    requestManager.clear(<span class="keyword">target</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//锁定requestOptions不让在加载过程中修改</span></span><br><span class="line">  requestOptions.lock();</span><br><span class="line">  <span class="comment">//创建请求</span></span><br><span class="line">  Request request = buildRequest(<span class="keyword">target</span>);</span><br><span class="line">  <span class="comment">//将request 设置给 target</span></span><br><span class="line">  <span class="keyword">target</span>.setRequest(request);</span><br><span class="line">  <span class="comment">//requestManager开始跟踪这个请求</span></span><br><span class="line">  requestManager.track(<span class="keyword">target</span>, request);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">target</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>into方法中会首先检查当前target是否有请求正在进行如果有那么先清除原先的请求。调用buildRequest来创建该次请求，并调用setRequest将请求与target进行绑定（也就是为当前View打上request的标签，并将request保存下来）。然后通过ReqestManager对该请求进行track。</p>
<p>这里关注两点</p>
<ol>
<li>buildRequest怎么创建出请求。</li>
<li>ReqestManager怎么使用创建出来的请求进行处理.<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function">Request <span class="title">buildRequest</span><span class="params">(Target&lt;TranscodeType&gt; <span class="keyword">target</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> buildRequestRecursive(<span class="keyword">target</span>, <span class="keyword">null</span>, transitionOptions, requestOptions.getPriority(), requestOptions.getOverrideWidth(), requestOptions.getOverrideHeight());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function">Request <span class="title">buildRequestRecursive</span><span class="params">(Target&lt;TranscodeType&gt; <span class="keyword">target</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">if</span> (thumbnailBuilder != <span class="keyword">null</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Base case: no thumbnail.</span></span><br><span class="line">    <span class="comment">//没有缩率图的情况</span></span><br><span class="line">    <span class="function"><span class="keyword">return</span> <span class="title">obtainRequest</span><span class="params">(<span class="keyword">target</span>, requestOptions, parentCoordinator, transitionOptions, priority, overrideWidth, overrideHeight)</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function">Request <span class="title">obtainRequest</span><span class="params">(Target&lt;TranscodeType&gt; <span class="keyword">target</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    BaseRequestOptions&lt;?&gt; requestOptions, RequestCoordinator requestCoordinator,</span></span></span><br><span class="line"><span class="params"><span class="function">    TransitionOptions&lt;?, ? <span class="keyword">super</span> TranscodeType&gt; transitionOptions, Priority priority,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">int</span> overrideWidth, <span class="keyword">int</span> overrideHeight)</span> </span>&#123;</span><br><span class="line">  requestOptions.lock();</span><br><span class="line">  RequestContext&lt;?, TranscodeType&gt; requestContext = <span class="keyword">new</span> RequestContext&lt;&gt;(context, model, transcodeClass, requestOptions, priority, overrideWidth, overrideHeight);</span><br><span class="line">  <span class="keyword">return</span> SingleRequest.obtain(requestContext, <span class="keyword">target</span>, requestListener, requestCoordinator, context.getEngine(), transitionOptions.getTransitionFactory());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
为了避免频繁创建和释放请求对象，这里使用了一个请求对象池，最多可以缓存150个请求。每次会从这个请求池中优先获取，只有在请求池为空的情况下才会新建一个请求，获取到一个请求对象后，就可以使用当前的请求参数初始化获取到的请求对象。这样就可以在这次请求中使用了。<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="operator">&lt;</span><span class="type">R</span><span class="operator">&gt;</span> <span class="type">SingleRequest</span>&lt;<span class="type">R</span>&gt; obtain(<span class="type">RequestContext</span>&lt;?, <span class="type">R</span>&gt; requestContext, <span class="type">Target</span>&lt;<span class="type">R</span>&gt; target,</span><br><span class="line">    <span class="type">RequestListener</span>&lt;<span class="type">R</span>&gt; requestListener, <span class="type">RequestCoordinator</span> requestCoordinator, <span class="type">Engine</span> engine,</span><br><span class="line">    <span class="type">TransitionFactory</span>&lt;? <span class="keyword">super</span> <span class="type">R</span>&gt; animationFactory) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//尝试从对象池中获取</span></span><br><span class="line">  <span class="meta">@SuppressWarnings</span>(<span class="string">&quot;unchecked&quot;</span>)</span><br><span class="line">  <span class="type">SingleRequest</span>&lt;<span class="type">R</span>&gt; request <span class="operator">=</span> (<span class="type">SingleRequest</span>&lt;<span class="type">R</span>&gt;) <span class="type">REQUEST_POOL</span>.acquire();</span><br><span class="line">  <span class="comment">//获取失败则新建一个请求</span></span><br><span class="line">  <span class="keyword">if</span> (request <span class="operator">==</span> null) &#123;</span><br><span class="line">    request <span class="operator">=</span> new <span class="type">SingleRequest</span>&lt;&gt;();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//初始化请求</span></span><br><span class="line">  request.<span class="keyword">init</span>(requestContext, target, requestListener, requestCoordinator, engine, animationFactory);</span><br><span class="line">  <span class="keyword">return</span> request;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>了解了请求的创建过程后我们继续看下如果使用获取的请求进行加载图片：<br>我们看下RequestManager track方法：</p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">track</span><span class="params">(Target&lt;?&gt; <span class="keyword">target</span>, Request request)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//监听生命周期</span></span><br><span class="line">  lifecycle.addListener(<span class="keyword">target</span>);</span><br><span class="line">  <span class="comment">//跟踪请求</span></span><br><span class="line">  requestTracker.runRequest(request);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>track中处理很简单，就是让target监听生命周期后，调用requestTracker.runRequest。还记得上面介绍Target的时候有提到生命周期对Target的影响了吧– 在Target为GifDrawble的时候Target会随着生命周期启动和停止播放动画。</p>
<p>Ok 我们继续看runRequest，上面已经知道request是一个SingleRequest，SingleRequest中启动请求是通过begin方法来完成的。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runRequest</span>(<span class="params">Request request</span>)</span> &#123;</span><br><span class="line">  <span class="comment">//添加请求到列表中</span></span><br><span class="line">  requests.<span class="keyword">add</span>(request);</span><br><span class="line">  <span class="keyword">if</span> (!isPaused) &#123;</span><br><span class="line">    <span class="comment">//如果是非暂停状态，那么就启动请求</span></span><br><span class="line">    request.begin();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//如果是暂停状态那么就加入到pendingRequests中</span></span><br><span class="line">    pendingRequests.<span class="keyword">add</span>(request);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>begin 方法中会先获取View的尺寸，然后通过onSizeReady传出，实际的加载也是在onSizeReady中进行的。<br>在开始加载之前先调用onLoadStarted显示占位图片。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public void <span class="keyword">begin</span><span class="literal">()</span> &#123;</span><br><span class="line">  <span class="comment">//没有设置Model的情况</span></span><br><span class="line">  <span class="keyword">if</span> (requestContext.get<span class="constructor">Model()</span><span class="operator"> == </span>null) &#123;</span><br><span class="line">    on<span class="constructor">LoadFailed()</span>;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//等待分配尺寸</span></span><br><span class="line">  status = Status.WAITING_FOR_SIZE;</span><br><span class="line">  <span class="comment">//先获取RequestContext 中的宽高，看下是否有效</span></span><br><span class="line">  <span class="built_in">int</span> overrideWidth = requestContext.get<span class="constructor">OverrideWidth()</span>;</span><br><span class="line">  <span class="built_in">int</span> overrideHeight = requestContext.get<span class="constructor">OverrideHeight()</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="module-access"><span class="module"><span class="identifier">Util</span>.</span></span>is<span class="constructor">ValidDimensions(<span class="params">overrideWidth</span>, <span class="params">overrideHeight</span>)</span>) &#123;</span><br><span class="line">    <span class="comment">//如果有效那么直接通过回调将其传出</span></span><br><span class="line">    on<span class="constructor">SizeReady(<span class="params">overrideWidth</span>, <span class="params">overrideHeight</span>)</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//如果无效那么调用之前介绍的getSize来获取View的尺寸</span></span><br><span class="line">    target.get<span class="constructor">Size(<span class="params">this</span>)</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ((status<span class="operator"> == </span>Status.RUNNING<span class="operator"> || </span>status<span class="operator"> == </span>Status.WAITING_FOR_SIZE)<span class="operator"></span></span><br><span class="line"><span class="operator">      &amp;&amp; </span>can<span class="constructor">NotifyStatusChanged()</span>) &#123;</span><br><span class="line">    <span class="comment">//显示占位图片</span></span><br><span class="line">    target.on<span class="constructor">LoadStarted(<span class="params">requestContext</span>.<span class="params">getPlaceholderDrawable</span>()</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看下onSizeReady，转了大半圈感觉终于走到了正道，之前都是各种做铺垫，在onSizeReady中会通过engine.load进行图片的加载。关于请求的信息都放在了requestContext中。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">onSizeReady</span><span class="params">(<span class="type">int</span> width, <span class="type">int</span> height)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (status != Status.WAITING_FOR_SIZE) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//将状态切换到RUNNING状态</span></span><br><span class="line">  status = Status.RUNNING;</span><br><span class="line">  <span class="comment">//.............</span></span><br><span class="line">  <span class="comment">//表示当前是从内存缓存中加载的，这个用于在onResourceReady返回的时候告诉回调这个资源是来自哪里的。</span></span><br><span class="line">  loadedFromMemoryCache = <span class="literal">true</span>;</span><br><span class="line">  <span class="comment">//使用Engine加载图片</span></span><br><span class="line">  loadStatus = engine.<span class="built_in">load</span>(requestContext, width, height, <span class="keyword">this</span>);</span><br><span class="line">  <span class="comment">//根据最终获取到的资源是否为空来设置loadedFromMemoryCache</span></span><br><span class="line">  loadedFromMemoryCache = resource != null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在看load代码之前我先给大家剧透下整个加载流程，大家可以结合下面的代码注释对细节进行查看：<br>整个流程如下：</p>
<ol>
<li>检查内存缓存，如果内存缓存中有需要的数据那么就直接使用内存缓存中的数据</li>
<li>如果内存缓存中没有想要的图像数据，那么检查最近的活跃资源（ActiveResources）是否有我们想要的资源</li>
<li>如果ActiveResources也没有，我们就继续检查最近的加载任务,如果存在将回调添加到正在加载的任务中，</li>
<li>上面都没办法获取到我们需要的资源那么就，启动新的加载任务开始加载</li>
</ol>
<p>可能大家都听说过两级缓存，内存缓存，磁盘缓存，但是Glide在这基础上添加了一层活跃资源缓存，那么什么是活跃资源呢？<br>活跃资源指的是那些不止一次被加载并没有进行过资源释放的图片，一旦被释放，那么该资源则会从近期活跃资源中删除并进入到内存缓存中，但是如果该资源再次从内存缓存中读取，则会重新添加到活跃资源中</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public &lt;Z, R&gt; LoadStatus load(RequestContext&lt;?, R&gt; requestContext, <span class="built_in">int</span> width, <span class="built_in">int</span> height,</span><br><span class="line">    ResourceCallback cb) &#123;</span><br><span class="line"></span><br><span class="line">  requestContext.set<span class="constructor">Dimens(<span class="params">width</span>, <span class="params">height</span>)</span>;</span><br><span class="line">  <span class="comment">//根据各个属性生成的内存缓存唯一键值</span></span><br><span class="line">  EngineKey key = keyFactory.build<span class="constructor">Key(<span class="params">requestContext</span>, <span class="params">width</span>, <span class="params">height</span>)</span>;</span><br><span class="line">  <span class="comment">//使用生成的key从缓存中尝试获取缓存资源</span></span><br><span class="line">  EngineResource&lt;?&gt; cached = load<span class="constructor">FromCache(<span class="params">key</span>,<span class="params">requestContext</span>.<span class="params">isMemoryCacheable</span>()</span><span class="comment">/*如果为false那么将会跳过从内存缓存中获取的步骤*/</span>);</span><br><span class="line">  <span class="keyword">if</span> (cached != null) &#123;</span><br><span class="line">    <span class="comment">//如果缓存中有可用资源，那么将其返回给回调，通知资源已经准备结束</span></span><br><span class="line">    cb.on<span class="constructor">ResourceReady(<span class="params">cached</span>)</span>;</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//如果内存缓存中没有对应的资源，那么就尝试从ActiveResource 中尝试获取</span></span><br><span class="line">  EngineResource&lt;?&gt; active = load<span class="constructor">FromActiveResources(<span class="params">key</span>,<span class="params">requestContext</span>.<span class="params">isMemoryCacheable</span>()</span><span class="comment">/*如果为false那么将会跳过从内存缓存中获取的步骤*/</span>);</span><br><span class="line">  <span class="keyword">if</span> (active != null) &#123;</span><br><span class="line">    cb.on<span class="constructor">ResourceReady(<span class="params">active</span>)</span>;</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//尝试从线程池中获取特定的任务</span></span><br><span class="line">  EngineJob current = jobs.get(key);</span><br><span class="line">  <span class="keyword">if</span> (current != null) &#123;</span><br><span class="line">    <span class="comment">//找到有正在下载符合当前要求的资源，那么就不重复下载该资源，直接通过添加回调来复用这个资源</span></span><br><span class="line">    current.add<span class="constructor">Callback(<span class="params">cb</span>)</span>;</span><br><span class="line">    return <span class="keyword">new</span> <span class="constructor">LoadStatus(<span class="params">cb</span>, <span class="params">current</span>)</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//如果在线程池中没有找到符合要求的特定资源，那么就通过engineJobFactory这个工厂类来生成一个EngineJob，</span></span><br><span class="line">  EngineJob&lt;R&gt; engineJob = engineJobFactory.build(key, requestContext.is<span class="constructor">MemoryCacheable()</span>);</span><br><span class="line">  DecodeJob&lt;R&gt; decodeJob = <span class="keyword">new</span> DecodeJob&lt;&gt;(requestContext, key, width, height, diskCacheProvider, engineJob);</span><br><span class="line">  <span class="comment">//将engineJob添加到job池中</span></span><br><span class="line">  jobs.put(key, engineJob);</span><br><span class="line">  <span class="comment">//添加回调</span></span><br><span class="line">  engineJob.add<span class="constructor">Callback(<span class="params">cb</span>)</span>;</span><br><span class="line">  <span class="comment">//启动decodeJob</span></span><br><span class="line">  engineJob.start(decodeJob);</span><br><span class="line">  return <span class="keyword">new</span> <span class="constructor">LoadStatus(<span class="params">cb</span>, <span class="params">engineJob</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们先看下内存缓存部分：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> EngineResource&lt;?&gt; load<span class="constructor">FromCache(Key <span class="params">key</span>, <span class="params">boolean</span> <span class="params">isMemoryCacheable</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!isMemoryCacheable) &#123;</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//从缓存中获取EngineResource</span></span><br><span class="line">  EngineResource&lt;?&gt; cached = get<span class="constructor">EngineResourceFromCache(<span class="params">key</span>)</span>;</span><br><span class="line">  <span class="keyword">if</span> (cached != null) &#123;</span><br><span class="line">    cached.acquire<span class="literal">()</span>;</span><br><span class="line">    <span class="comment">//从缓存中获取到后将资源通过一个软引用添加到active resource缓存中。</span></span><br><span class="line">    activeResources.put(key, <span class="keyword">new</span> <span class="constructor">ResourceWeakReference(<span class="params">key</span>, <span class="params">cached</span>, <span class="params">getReferenceQueue</span>()</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  return cached;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在内存缓存获取到我们所需要的数据后会将其添加到Active Resource中.</p>
<figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> EngineResource&lt;?&gt; <span class="title function_">getEngineResourceFromCache</span>(Key <span class="built_in">key</span>) &#123;</span><br><span class="line">  <span class="comment">//将匹配的数据从缓存中取出</span></span><br><span class="line">  Resource&lt;?&gt; cached = cache.<span class="property">remove</span>(<span class="built_in">key</span>);</span><br><span class="line">  <span class="keyword">final</span> EngineResource result;</span><br><span class="line">  <span class="keyword">if</span> (cached == <span class="literal">null</span>) &#123;</span><br><span class="line">    result = <span class="literal">null</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cached <span class="keyword">instanceof</span> EngineResource) &#123;</span><br><span class="line">    result = (EngineResource) cached;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    result = <span class="keyword">new </span><span class="class title_">EngineResource</span>(cached, <span class="literal">true</span> <span class="comment">/*isMemoryCacheable*/</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着我们再看下Active Resource 缓存中获取数据的过程：<br>Active Resource 的缓存数据存在activeResources中，使用弱引用来持有。在内存不足的时候这部分会被gc掉。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> EngineResource&lt;?&gt; loadFromActiveResources(Key key, boolean isMemoryCacheable) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!isMemoryCacheable) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  EngineResource&lt;?&gt; active = <span class="literal">null</span>;</span><br><span class="line">  WeakReference&lt;EngineResource&lt;?&gt;&gt; activeRef = activeResources.<span class="keyword">get</span>(key);</span><br><span class="line">  <span class="keyword">if</span> (activeRef != <span class="literal">null</span>) &#123;</span><br><span class="line">    active = activeRef.<span class="keyword">get</span>();</span><br><span class="line">    <span class="keyword">if</span> (active != <span class="literal">null</span>) &#123;</span><br><span class="line">      active.acquire();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      activeResources.remove(key);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> active;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>介绍完内存缓存以及Active Resource缓存后我们看下磁盘缓存：<br>在磁盘缓存开始前会先在当前获取数据的队列中查看是否先前已经启动，如果先前已经启动的话就不重新创建了。这样可以达到复用数据的目的。最后的最后才会启动从磁盘中获取缓存数据的任务。</p>
<p>DecodeJob是一个Runnable的实现类，主要负责从磁盘加载数据，调用start方法后，这个线程就会run起来。<br>它的作用如下：</p>
<ol>
<li>确定数据的加载来源（Resource，Data，Source）</li>
<li>创建对应来源的DataFetcherGenerator</li>
<li>执行DataFetcherGenerator 获取数据</li>
</ol>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>()</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//运行加载任务</span></span><br><span class="line">    runWrapped();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">    callback.onLoadFailed();</span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">runWrapped</span>()</span> &#123;</span><br><span class="line">   <span class="keyword">switch</span> (runReason) &#123;</span><br><span class="line">    <span class="keyword">case</span> INITIALIZE:</span><br><span class="line">      <span class="comment">//第一次我们从这里开始分析</span></span><br><span class="line">      stage = getNextStage(Stage.INITIALIZE);<span class="comment">//确定资源的加载来源</span></span><br><span class="line">      generator = getNextGenerator();</span><br><span class="line">      runGenerators();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SWITCH_TO_SOURCE_SERVICE:<span class="comment">//从硬盘获取资源失败 ，尝试重新获取</span></span><br><span class="line">      runGenerators();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> DECODE_DATA:<span class="comment">//从一个不属于我们的线程中获取数据，然后切换到我们自己的线程中处理数据</span></span><br><span class="line">      decodeFromRetrievedData();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="literal">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Unrecognized run reason: &quot;</span> + runReason);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们第一次进入的时候runReason为INITIALIZE，这时候会先通过getNextStage来获取当前阶段的下一阶段。首先在看代码之前我们需要先明白Data和Resource的区别：<br>Resource：原始的图片（或gif）数据<br>Data：经过处理（旋转，缩放）后的数据</p>
<p>该方法的大致逻辑如下:</p>
<ol>
<li>如果是初始状态，则判断是否解码已缓存的Resource，true是解码Resource。false的话则会通过递归进入第二个判断分支</li>
<li>判断是否解码已缓存的Data，true是解码Data,false的话则会通过递归进入第三个判断分支</li>
<li>该阶段则需要从数据源去解码。</li>
</ol>
<p>简单的来说，就是根据Resource—&gt;Data—&gt;source的顺序去解码加载数据,该阶段Stage的确定，影响着下一阶段DataFetcherGenerator相应子类的实例创建</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Stage <span class="title function_">getNextStage</span><span class="params">(Stage current)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (current == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">DiskCacheStrategy</span> <span class="variable">strategy</span> <span class="operator">=</span> requestContext.getDiskCacheStrategy();</span><br><span class="line">  <span class="keyword">switch</span> (current) &#123;</span><br><span class="line">    <span class="keyword">case</span> INITIALIZE:</span><br><span class="line">      <span class="keyword">return</span> strategy.decodeCachedResource() ? Stage.RESOURCE_CACHE : getNextStage(Stage.RESOURCE_CACHE);</span><br><span class="line">    <span class="keyword">case</span> RESOURCE_CACHE:</span><br><span class="line">      <span class="keyword">return</span> strategy.decodeCachedData() ? Stage.DATA_CACHE : getNextStage(Stage.DATA_CACHE);</span><br><span class="line">    <span class="keyword">case</span> DATA_CACHE:</span><br><span class="line">      <span class="keyword">return</span> Stage.SOURCE;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过getNextStage已经获取到适当的状态后紧接着就是通过getNextGenerateor生成获取数据的DataFetcherGenerator</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> DataFetcherGenerator <span class="title">getNextGenerator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (stage == null) &#123;</span><br><span class="line">    <span class="keyword">return</span> null;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">switch</span> (stage) &#123;</span><br><span class="line">    <span class="keyword">case</span> RESOURCE_CACHE:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">ResourceCacheGenerator</span>(width, height, diskCacheProvider.<span class="built_in">getDiskCache</span>(), requestContext, <span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">case</span> DATA_CACHE:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">DataCacheGenerator</span>(requestContext.<span class="built_in">getCacheKeys</span>(), width, height, diskCacheProvider.<span class="built_in">getDiskCache</span>(), requestContext, <span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">case</span> SOURCE:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> SourceGenerator&lt;&gt;(width, height, requestContext, diskCacheProvider.<span class="built_in">getDiskCache</span>(), <span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">IllegalStateException</span>(<span class="string">&quot;Unrecognized stage: &quot;</span> + stage);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DataFetcherGenerator使用已注册的ModelLoaders和Model来生成一系列的DataFetcher。有如下实现类<br>ResourceCacheGenerator：经过处理的资源数据缓存文件(采样转换等处理)<br>DataCacheGenerator：未经处理的资源数据缓存文件<br>SourceGenerator：源数据的生成器，包含了根据来源创建的ModelLoader和Model(文件路径，URL…)</p>
<p>下面我们一一来看下这些DataFetcherGenerator</p>
<p>####### ResourceCacheGenerator</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public boolean start<span class="constructor">Next()</span> &#123;</span><br><span class="line">  <span class="comment">//获取当前的缓存的key列表</span></span><br><span class="line">  List&lt;Key&gt; sourceIds = requestContext.get<span class="constructor">CacheKeys()</span>;</span><br><span class="line">  <span class="comment">//获取当前注册的Resource class</span></span><br><span class="line">  List&lt;Class&lt;?&gt;&gt; resourceClasses = requestContext.get<span class="constructor">RegisteredResourceClasses()</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (modelLoaders<span class="operator"> == </span>null<span class="operator"> || </span>!has<span class="constructor">NextModelLoader()</span>) &#123;</span><br><span class="line">    resourceClassIndex++;</span><br><span class="line">    <span class="keyword">if</span> (resourceClassIndex &gt;= resourceClasses.size<span class="literal">()</span>) &#123;</span><br><span class="line">      sourceIdIndex++;</span><br><span class="line">      <span class="keyword">if</span> (sourceIdIndex &gt;= sourceIds.size<span class="literal">()</span>) &#123;</span><br><span class="line">        return <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      resourceClassIndex = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Key sourceId = sourceIds.get(sourceIdIndex);</span><br><span class="line">    Class&lt;?&gt; resourceClass = resourceClasses.get(resourceClassIndex);</span><br><span class="line">    Transformation&lt;?&gt; transformation = requestContext.get<span class="constructor">Transformation(<span class="params">resourceClass</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成对应的key</span></span><br><span class="line">    Key key = <span class="keyword">new</span> <span class="constructor">ResourceCacheKey(<span class="params">sourceId</span>, <span class="params">requestContext</span>.<span class="params">getSignature</span>()</span>, width, height,transformation，resourceClass, requestContext.get<span class="constructor">Options()</span>);</span><br><span class="line">    <span class="comment">//从磁盘缓存中获取对应的缓存文件</span></span><br><span class="line">    cacheFile = diskCache.get(key);</span><br><span class="line">    <span class="keyword">if</span> (cacheFile != null) &#123;</span><br><span class="line">      <span class="comment">//存在缓存文件</span></span><br><span class="line">      this.sourceKey = sourceId;</span><br><span class="line">      <span class="comment">//获取ModeLoaders  获取到之后modelLoaders != null 那么就退出循环，这个过程主要是从Register中获取到注册的ModeLoader</span></span><br><span class="line">      modelLoaders = requestContext.get<span class="constructor">ModelLoaders(<span class="params">cacheFile</span>)</span>;</span><br><span class="line">      modelLoaderIndex = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fetcher = null;</span><br><span class="line">  <span class="keyword">while</span> (fetcher<span class="operator"> == </span>null<span class="operator"> &amp;&amp; </span>has<span class="constructor">NextModelLoader()</span>) &#123;</span><br><span class="line">    <span class="comment">//获取ModeLoader</span></span><br><span class="line">    ModelLoader&lt;File, ?&gt; modelLoader = modelLoaders.get(modelLoaderIndex++);</span><br><span class="line">    <span class="comment">//获取Fetcher,如果获取到了就不再循环了</span></span><br><span class="line">    fetcher = modelLoader.build<span class="constructor">LoadData(<span class="params">cacheFile</span>, <span class="params">width</span>, <span class="params">height</span>, <span class="params">requestContext</span>.<span class="params">getOptions</span>()</span>).fetcher;</span><br><span class="line">    <span class="keyword">if</span> (fetcher != null) &#123;</span><br><span class="line">      <span class="comment">//使用Fetcher加载数据</span></span><br><span class="line">      fetcher.load<span class="constructor">Data(<span class="params">requestContext</span>.<span class="params">getPriority</span>()</span>, this);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return fetcher != null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="DataCacheGenerator"><a href="#DataCacheGenerator" class="headerlink" title="DataCacheGenerator"></a>DataCacheGenerator</h6><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public boolean start<span class="constructor">Next()</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//第一次调用的时候modelLoaders == null  这里只执行一次</span></span><br><span class="line">  <span class="keyword">while</span> (modelLoaders<span class="operator"> == </span>null<span class="operator"> || </span>!has<span class="constructor">NextModelLoader()</span>) &#123;</span><br><span class="line">    sourceIdIndex++;</span><br><span class="line">    <span class="keyword">if</span> (sourceIdIndex &gt;= sourceIds.size<span class="literal">()</span>) &#123;</span><br><span class="line">      return <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取要加载的数据源的Id</span></span><br><span class="line">    Key sourceId = sourceIds.get(sourceIdIndex);</span><br><span class="line">    <span class="comment">//生成缓存key</span></span><br><span class="line">    Key originalKey = <span class="keyword">new</span> <span class="constructor">DataCacheKey(<span class="params">sourceId</span>, <span class="params">requestContext</span>.<span class="params">getSignature</span>()</span>);</span><br><span class="line">    <span class="comment">//使用key值获取缓存文件</span></span><br><span class="line">    cacheFile = diskCache.get(originalKey);</span><br><span class="line">    <span class="keyword">if</span> (cacheFile != null) &#123;</span><br><span class="line">      <span class="comment">//如果找到缓存文件，那么使用缓存文件类型来获取已经注册的Model的加载器</span></span><br><span class="line">      this.sourceKey = sourceId;</span><br><span class="line">      modelLoaders = requestContext.get<span class="constructor">ModelLoaders(<span class="params">cacheFile</span>)</span>;</span><br><span class="line">      <span class="comment">//重置加载器列表index</span></span><br><span class="line">      modelLoaderIndex = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fetcher = null;</span><br><span class="line">  <span class="comment">//如果有一次fetcher ！= null就停止，如果没有fetcher 并且全部已经遍历结束则退出循环</span></span><br><span class="line">  <span class="keyword">while</span> (fetcher<span class="operator"> == </span>null<span class="operator"> &amp;&amp; </span>has<span class="constructor">NextModelLoader()</span>) &#123;</span><br><span class="line">    <span class="comment">//获取ModelLoader</span></span><br><span class="line">    ModelLoader&lt;File, ?&gt; modelLoader = modelLoaders.get(modelLoaderIndex++);</span><br><span class="line">    <span class="comment">//获取fetcher</span></span><br><span class="line">    fetcher = modelLoader.build<span class="constructor">LoadData(<span class="params">cacheFile</span>, <span class="params">width</span>, <span class="params">height</span>, <span class="params">requestContext</span>.<span class="params">getOptions</span>()</span>).fetcher;</span><br><span class="line">    <span class="comment">//使用fetcher获取数据</span></span><br><span class="line">    <span class="keyword">if</span> (fetcher != null) &#123;</span><br><span class="line">      fetcher.load<span class="constructor">Data(<span class="params">requestContext</span>.<span class="params">getPriority</span>()</span>, this);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return fetcher != null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="SourceGenerator"><a href="#SourceGenerator" class="headerlink" title="SourceGenerator"></a>SourceGenerator</h6><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> boolean startNext() &#123;</span><br><span class="line">  <span class="comment">//如果已经有缓存数据那么就切换到DataCacheGenerator</span></span><br><span class="line">  <span class="keyword">if</span> (dataToCache != <span class="literal">null</span>) &#123;</span><br><span class="line">    cacheData();</span><br><span class="line">    dataToCache = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//如果之前有缓存的话这里的sourceCacheGenerator 为 DataCacheGenerator，那么这里将会调用startNext获取到Fetcher而后调用loadData加载数据。</span></span><br><span class="line">  <span class="keyword">if</span> (sourceCacheGenerator != <span class="literal">null</span> &amp;&amp; sourceCacheGenerator.startNext()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//如果没有缓存就会继续走到这里</span></span><br><span class="line">  sourceCacheGenerator = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  loadData = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">while</span> (loadData == <span class="literal">null</span> &amp;&amp; hasNextModelLoader()) &#123;</span><br><span class="line">    loadData = loadDataList.<span class="keyword">get</span>(loadDataListIndex++);</span><br><span class="line">    <span class="keyword">if</span> (loadData != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">//加载数据</span></span><br><span class="line">      loadData.fetcher.loadData(requestContext.getPriority(), <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> loadData != <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> void cache<span class="constructor">Data()</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//获取对应的编码器</span></span><br><span class="line">    Encoder&lt;Object&gt; encoder = requestContext.get<span class="constructor">SourceEncoder(<span class="params">dataToCache</span>)</span>;</span><br><span class="line">    DataCacheWriter&lt;Object&gt; writer = <span class="keyword">new</span> DataCacheWriter&lt;&gt;(encoder, dataToCache, requestContext.get<span class="constructor">Options()</span>);</span><br><span class="line">    <span class="comment">//生成DataCacheKey</span></span><br><span class="line">    Key originalKey = <span class="keyword">new</span> <span class="constructor">DataCacheKey(<span class="params">loadData</span>.<span class="params">sourceKey</span>, <span class="params">requestContext</span>.<span class="params">getSignature</span>()</span>);</span><br><span class="line">    <span class="comment">//将数据写入到磁盘缓存中</span></span><br><span class="line">    diskCache.put(originalKey, writer);</span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">    loadData.fetcher.cleanup<span class="literal">()</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//将Generator切换到DataCacheGenerator</span></span><br><span class="line">  sourceCacheGenerator =</span><br><span class="line">      <span class="keyword">new</span> <span class="constructor">DataCacheGenerator(Collections.<span class="params">singletonList</span>(<span class="params">loadData</span>.<span class="params">sourceKey</span>)</span>, width, height,</span><br><span class="line">          diskCache, requestContext, this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里需要注意下，SourceGenerator可以根据磁盘缓存策略选择是直接返回还是先写到磁盘再从缓存文件中加载。</p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="literal">void</span> onDataReady(Object <span class="built_in">data</span>) &#123;</span><br><span class="line">  <span class="comment">//根据当前磁盘缓存策略，如果需要对数据进行缓存，那么将数据赋给dataToCache</span></span><br><span class="line">  DiskCacheStrategy diskCacheStrategy = requestContext.getDiskCacheStrategy();</span><br><span class="line">  <span class="comment">//这个分支是先将数据写入到磁盘缓存，再从缓存文件中加载。</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">data</span> != <span class="built_in">null</span> &amp;&amp; diskCacheStrategy.isDataCacheable(loadData.fetcher.getDataSource())) &#123;</span><br><span class="line">    dataToCache = <span class="built_in">data</span>;</span><br><span class="line">    <span class="comment">// We might be being called back on someone else&#x27;s thread. Before doing anything, we should</span></span><br><span class="line">    <span class="comment">// reschedule to get back onto Glide&#x27;s thread.</span></span><br><span class="line">    <span class="comment">// 这时候我们可能在其他线程中进行加载的，但是在做任何操作的时候必须重新切换到Glide线程</span></span><br><span class="line">    cb.reschedule();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//如果当前缓存策略不要求对数据进行缓存那么直接通过回调返回</span></span><br><span class="line">    cb.onDataFetcherReady(loadData.sourceKey, <span class="built_in">data</span>, loadData.fetcher,</span><br><span class="line">        loadData.fetcher.getDataSource());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看完上面的三个DataFetcher后我们看下在DecodeJob中怎么通过这些Fetcher进行获取数据，这就涉及到runGenerators这个方法：<br>如果获取成功则直接回调onDataFetcherReady，如果失败则通过reschedule重新调度</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> void run<span class="constructor">Generators()</span> &#123;</span><br><span class="line">  currentThread = <span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>current<span class="constructor">Thread()</span>;</span><br><span class="line">  <span class="keyword">while</span> (!isCancelled<span class="operator"> &amp;&amp; </span>generator != null<span class="operator"></span></span><br><span class="line"><span class="operator">          &amp;&amp; </span>!generator.start<span class="constructor">Next()</span><span class="comment">/*如果fetch成功获取并且通过通过fetch能够成功获取到数据则返回true这时候不执行while当中的循环*/</span>) &#123;</span><br><span class="line">    stage = get<span class="constructor">NextStage(<span class="params">stage</span>)</span>;</span><br><span class="line">    generator = get<span class="constructor">NextGenerator()</span>;</span><br><span class="line">    <span class="keyword">if</span> (stage<span class="operator"> == </span>Stage.SOURCE) &#123;</span><br><span class="line">      runReason = RunReason.SWITCH_TO_SOURCE_SERVICE;</span><br><span class="line">      callback.reschedule(this);</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// We&#x27;ve run out of stages and generators, give up.</span></span><br><span class="line">  <span class="keyword">if</span> (stage<span class="operator"> == </span>null) &#123;</span><br><span class="line">    callback.on<span class="constructor">LoadFailed()</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看完上面代码密密麻麻的，但是最主要的代码就一句generator.startNext()也就是上面介绍DataFetcher的时候重点注解的那个方法，在那个方法中会调用对应的Fetcher来获取数据。后续的部分会着重介绍一个从网络上获取数据的Fetcher,这里先着重介绍流程。好了我们继续：<br>不论是哪种Fetcher,获取完数据后都会回调DecodeJob里面的onDataFetcherReady</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> void onDataFetcherReady(Key sourceKey, Object <span class="keyword">data</span>, DataFetcher&lt;?&gt; fetcher,</span><br><span class="line">    DataSource dataSource) &#123;</span><br><span class="line">  <span class="comment">//各个Generator加载数据结束的时候会到这里</span></span><br><span class="line">  <span class="keyword">this</span>.currentSourceKey = sourceKey;  <span class="comment">//对应的数据key</span></span><br><span class="line">  <span class="keyword">this</span>.currentData = <span class="keyword">data</span>;            <span class="comment">//解码前的原始数据</span></span><br><span class="line">  <span class="keyword">this</span>.currentFetcher = fetcher;      <span class="comment">//获取数据的fetcher</span></span><br><span class="line">  <span class="keyword">this</span>.currentDataSource = dataSource;<span class="comment">//数据类别</span></span><br><span class="line">  <span class="keyword">if</span> (Thread.currentThread() != currentThread) &#123;</span><br><span class="line">    runReason = RunReason.DECODE_DATA;</span><br><span class="line">    callback.reschedule(<span class="keyword">this</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//从原始数据中对数据进行解码</span></span><br><span class="line">    decodeFromRetrievedData();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>private void decodeFromRetrievedData() {<br>  &#x2F;&#x2F;对原始数据进行解码<br>  Resource<R> resource &#x3D; decodeFromData(currentFetcher, currentData, currentDataSource);<br>  if (resource !&#x3D; null) {<br>    &#x2F;&#x2F;通过回调进行返回<br>    callback.onResourceReady(resource);<br>    cleanup();<br>  } else {<br>    runGenerators();<br>  }<br>}</R></p>
<p>private <Data> Resource<R> decodeFromData(DataFetcher&lt;?&gt; fetcher, Data data, DataSource dataSource) {<br>  try {<br>    if (data &#x3D;&#x3D; null) {<br>      return null;<br>    }<br>    Resource<R> result &#x3D; decodeFromFetcher(data, dataSource);<br>    return result;<br>  } finally {<br>    fetcher.cleanup();<br>  }<br>}</R></R></Data></p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;<span class="built_in">Data</span>&gt; Resource&lt;R&gt; decodeFromFetcher(<span class="built_in">Data</span> <span class="built_in">data</span>, DataSource dataSource) &#123;</span><br><span class="line">    <span class="comment">//从requestContext中获取当前数据类型的解码器</span></span><br><span class="line">    LoadPath&lt;<span class="built_in">Data</span>, ?, R&gt; path = requestContext.getLoadPath((Class&lt;<span class="built_in">Data</span>&gt;) <span class="built_in">data</span>.getClass());</span><br><span class="line">    <span class="keyword">if</span> (path != <span class="built_in">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> runLoadPath(<span class="built_in">data</span>, dataSource, path);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>getLoadPath的任务是从注册表中获取特定数据类型，转换类型的图像解码器：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">&lt;Data&gt; LoadPath&lt;Data, ?, TranscodeClass&gt; get<span class="constructor">LoadPath(Class&lt;Data&gt; <span class="params">dataClass</span>)</span> &#123;</span><br><span class="line">  return glideContext.get<span class="constructor">Registry()</span>.get<span class="constructor">LoadPath(<span class="params">dataClass</span>, <span class="params">getResourceClass</span>()</span>, transcodeClass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里调用getLoadPath了从loadPathCache中获取对应数据类型的解码器，loadPathCache 是一个缓存，这个大家见怪不怪了：</p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">public</span> &lt;<span class="built_in">Data</span>, TResource, Transcode&gt; LoadPath&lt;<span class="built_in">Data</span>, TResource, Transcode&gt; getLoadPath(</span><br><span class="line">    Class&lt;<span class="built_in">Data</span>&gt; dataClass, Class&lt;TResource&gt; resourceClass, Class&lt;Transcode&gt; transcodeClass) &#123;</span><br><span class="line"></span><br><span class="line">  LoadPath&lt;<span class="built_in">Data</span>, TResource, Transcode&gt; result = loadPathCache.get(dataClass, resourceClass, transcodeClass);</span><br><span class="line">  <span class="keyword">if</span> (result == <span class="built_in">null</span> &amp;&amp; !loadPathCache.contains(dataClass, resourceClass, transcodeClass)) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取解码器列表</span></span><br><span class="line">    <span class="built_in">List</span>&lt;DecodePath&lt;<span class="built_in">Data</span>, TResource, Transcode&gt;&gt; decodePaths = getDecodePaths(dataClass, resourceClass,transcodeClass);</span><br><span class="line">    <span class="comment">//有可能从数据类中没法解码或者转换当前类型</span></span><br><span class="line">    <span class="keyword">if</span> (decodePaths.isEmpty()) &#123;</span><br><span class="line">      result = <span class="built_in">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result = <span class="literal">new</span> LoadPath&lt;&gt;(dataClass, decodePaths);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//添加到loadPathCache</span></span><br><span class="line">    loadPathCache.put(dataClass, resourceClass, transcodeClass, result);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是从注册表中获取符合要求的解码器列表的实现：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="operator">&lt;</span><span class="type">Data</span>, <span class="type">TResource</span>, <span class="type">Transcode</span><span class="operator">&gt;</span> <span class="type">List</span>&lt;<span class="type">DecodePath</span>&lt;<span class="type">Data</span>, <span class="type">TResource</span>, <span class="type">Transcode</span>&gt;&gt; getDecodePaths(</span><br><span class="line">      <span class="type">Class</span>&lt;<span class="type">Data</span>&gt; dataClass, <span class="type">Class</span>&lt;<span class="type">TResource</span>&gt; resourceClass, <span class="type">Class</span>&lt;<span class="type">Transcode</span>&gt; transcodeClass) &#123;</span><br><span class="line">    <span class="comment">//从注册表中获取解码器信息列表</span></span><br><span class="line">    <span class="type">List</span>&lt;<span class="type">DecodePath</span>&lt;<span class="type">Data</span>, <span class="type">TResource</span>, <span class="type">Transcode</span>&gt;&gt; decodePaths <span class="operator">=</span> new <span class="type">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">List</span>&lt;<span class="type">Class</span>&lt;<span class="type">TResource</span>&gt;&gt; registeredResourceClasses <span class="operator">=</span> decoderRegistry.getResourceClasses(dataClass, resourceClass);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">Class</span>&lt;<span class="type">TResource</span>&gt; registeredResourceClass : registeredResourceClasses) &#123;</span><br><span class="line">      <span class="comment">//获取图像变换列表</span></span><br><span class="line">      <span class="type">List</span>&lt;<span class="type">Class</span>&lt;<span class="type">Transcode</span>&gt;&gt; registeredTranscodeClasses <span class="operator">=</span></span><br><span class="line">          transcoderRegistry.getTranscodeClasses(registeredResourceClass, transcodeClass);</span><br><span class="line">      <span class="comment">//获取到对应类型，对应变换的解码器</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">Class</span>&lt;<span class="type">Transcode</span>&gt; registeredTranscodeClass : registeredTranscodeClasses) &#123;</span><br><span class="line">        <span class="type">List</span>&lt;<span class="type">ResourceDecoder</span>&lt;<span class="type">Data</span>, <span class="type">TResource</span>&gt;&gt; decoders <span class="operator">=</span></span><br><span class="line">            decoderRegistry.getDecoders(dataClass, registeredResourceClass);</span><br><span class="line">        <span class="comment">//这里就是我们需要的解码器</span></span><br><span class="line">        <span class="type">ResourceTranscoder</span>&lt;<span class="type">TResource</span>, <span class="type">Transcode</span>&gt; transcoder <span class="operator">=</span></span><br><span class="line">            transcoderRegistry.get(registeredResourceClass, registeredTranscodeClass);</span><br><span class="line">        <span class="comment">//添加到符合要求的解码器列表</span></span><br><span class="line">        decodePaths.add(new <span class="type">DecodePath</span>&lt;&gt;(dataClass, decoders, transcoder));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> decodePaths;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经过层层调用后我们就获取到了当前数据的解码器，拿到解码器后不用说要做的事情就是对数据进行解码了，我们看下这部分内容：</p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;<span class="built_in">Data</span>, ResourceType&gt; Resource&lt;R&gt; runLoadPath(<span class="built_in">Data</span> <span class="built_in">data</span>, DataSource dataSource, LoadPath&lt;<span class="built_in">Data</span>, ResourceType, R&gt; path) &#123;</span><br><span class="line">  <span class="keyword">return</span> path.load(<span class="built_in">data</span>, requestContext, width, height, <span class="literal">new</span> DecodeCallback&lt;ResourceType&gt;(dataSource));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们接下来看下LoadPath的load方法，这里最关键的部分就是path.decode这个方法，它就是调用从注册表中获取到的解码器到decode方法对数据进行解码的。</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Resource&lt;Transcode&gt; load(Data data, RequestContext&lt;?, Transcode&gt; context,</span><br><span class="line">    <span class="keyword">int</span> width, <span class="keyword">int</span> height, DecodePath.DecodeCallback&lt;ResourceType&gt; decodeCallback) &#123;</span><br><span class="line">  Preconditions.checkNotNull(data);</span><br><span class="line"></span><br><span class="line">  Resource&lt;Transcode&gt; result = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">Options</span> <span class="keyword">options</span> = context.getOptions();</span><br><span class="line">  DataRewinder&lt;Data&gt; rewinder = context.getRewinder(data);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">size</span> = decodePaths.<span class="keyword">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">size</span>; i++) &#123;</span><br><span class="line">      DecodePath&lt;Data, ResourceType, Transcode&gt; path = decodePaths.get(i);</span><br><span class="line">      result = path.decode(rewinder, width, height, <span class="keyword">options</span>, decodeCallback);</span><br><span class="line">      <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    rewinder.cleanup();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里为止整个数据获取，解码都完成了，那么我们接下来顺着原路返回，看下怎么将这些经过解码后的图片设置到对应的Target上，我们先回到Engine类：<br>它有一个叫做onEngineJobComplete的回调，是在上面加载数据，解码数据之后对调的。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public void on<span class="constructor">EngineJobComplete(Key <span class="params">key</span>, EngineResource&lt;?&gt; <span class="params">resource</span>)</span> &#123;</span><br><span class="line">  <span class="module-access"><span class="module"><span class="identifier">Util</span>.</span></span><span class="keyword">assert</span><span class="constructor">MainThread()</span>;</span><br><span class="line">  <span class="keyword">if</span> (resource != null) &#123;</span><br><span class="line">    resource.set<span class="constructor">ResourceListener(<span class="params">key</span>, <span class="params">this</span>)</span>;</span><br><span class="line">    <span class="keyword">if</span> (resource.is<span class="constructor">Cacheable()</span>) &#123;</span><br><span class="line">      activeResources.put(key, <span class="keyword">new</span> <span class="constructor">ResourceWeakReference(<span class="params">key</span>, <span class="params">resource</span>, <span class="params">getReferenceQueue</span>()</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  jobs.remove(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里处理很简单就是将加载后的数据添加到activeResources，下一次的时候就可以从activeResources中获取了。</p>
<p>还记得前面介绍Engine.load的时候如果从内存缓存以及Active Resource缓存中获取到数据后是怎么处理的吧。是的就是调用：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">cb.on<span class="constructor">ResourceReady(<span class="params">cached</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>cb 是啥，看代码可以看出SingleRequest,所以我们看下SingleRequest的onResourceReady</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void on<span class="constructor">ResourceReady(Resource&lt;?&gt; <span class="params">resource</span>)</span> &#123;</span><br><span class="line">  Class&lt;R&gt; transcodeClass = requestContext.get<span class="constructor">TranscodeClass()</span>;</span><br><span class="line">  <span class="keyword">if</span> (resource<span class="operator"> == </span>null) &#123;</span><br><span class="line">    on<span class="constructor">LoadFailed()</span>;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  Object received = resource.get<span class="literal">()</span>;</span><br><span class="line">  <span class="keyword">if</span> (received<span class="operator"> == </span>null<span class="operator"> || </span>!transcodeClass.is<span class="constructor">AssignableFrom(<span class="params">received</span>.<span class="params">getClass</span>()</span>)) &#123;</span><br><span class="line">    release<span class="constructor">Resource(<span class="params">resource</span>)</span>;</span><br><span class="line">    on<span class="constructor">LoadFailed()</span>;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!can<span class="constructor">SetResource()</span>) &#123;</span><br><span class="line">    release<span class="constructor">Resource(<span class="params">resource</span>)</span>;</span><br><span class="line">    status = Status.COMPLETE;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//这里是关键</span></span><br><span class="line">  on<span class="constructor">ResourceReady((Resource&lt;R&gt;)</span> resource, (R) received);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> void on<span class="constructor">ResourceReady(Resource&lt;R&gt; <span class="params">resource</span>, R <span class="params">result</span>)</span> &#123;</span><br><span class="line">  boolean isFirstResource = is<span class="constructor">FirstReadyResource()</span>;</span><br><span class="line">  status = Status.COMPLETE;</span><br><span class="line">  this.resource = resource;</span><br><span class="line">  <span class="keyword">if</span> (requestListener<span class="operator"> == </span>null<span class="operator"></span></span><br><span class="line"><span class="operator">      || </span>!requestListener.on<span class="constructor">ResourceReady(<span class="params">result</span>, <span class="params">requestContext</span>.<span class="params">getModel</span>()</span>, target,loadedFromMemoryCache, isFirstResource)) &#123;</span><br><span class="line">        <span class="comment">//这里是终点，终于快结束了，累死我了。</span></span><br><span class="line">    Transition&lt;? super R&gt; animation = animationFactory.build(loadedFromMemoryCache, isFirstResource);</span><br><span class="line">    target.on<span class="constructor">ResourceReady(<span class="params">result</span>, <span class="params">animation</span>)</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  notify<span class="constructor">LoadSuccess()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面终于看到target了。既然都讲到这了我就再回头看下吧，比如我们当前是一个GifDrawable，那么Target就是DrawableImageTarget<br>我们就再来看下它的onResourceReady</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public void on<span class="constructor">ResourceReady(Drawable <span class="params">resource</span>, Transition&lt;? <span class="params">super</span> Drawable&gt; <span class="params">transition</span>)</span> &#123;</span><br><span class="line">  ViewGroup.LayoutParams layoutParams = view.get<span class="constructor">LayoutParams()</span>;</span><br><span class="line">  <span class="keyword">if</span> (!(resource instanceof Animatable)<span class="operator"> &amp;&amp; </span>layoutParams != null<span class="operator"> &amp;&amp; </span>layoutParams.width &gt; <span class="number">0</span><span class="operator"></span></span><br><span class="line"><span class="operator">      &amp;&amp; </span>layoutParams.height &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    resource = <span class="keyword">new</span> <span class="constructor">FixedSizeDrawable(<span class="params">resource</span>, <span class="params">layoutParams</span>.<span class="params">width</span>, <span class="params">layoutParams</span>.<span class="params">height</span>)</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  super.on<span class="constructor">ResourceReady(<span class="params">resource</span>, <span class="params">transition</span>)</span>;</span><br><span class="line">  <span class="keyword">if</span> (resource instanceof Animatable) &#123;</span><br><span class="line">    ((Animatable) resource).start<span class="literal">()</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它调用了父类也就是ImageViewTarget的onResourceReady，在这里会调用传入的Transition对图像进行一次转换，然后调用setResource设置到对应的Target上。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">onResourceReady</span>(<span class="params">Z resource, Transition&lt;? <span class="variable language_">super</span> Z&gt; transition</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (transition == <span class="literal">null</span> || !transition.<span class="title function_">transition</span>(resource, <span class="variable language_">this</span>)) &#123;</span><br><span class="line">    <span class="title function_">setResource</span>(resource);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以总的就是先将图像转换，设置到ImageView上，然后如果是gif就调用start方法开始播放。整个流程结束了，真他妈累。对了好像还忘记给大家介绍HttpUrlFetcher了。实在讲不动了就贴个标有注释的代码给大家吧。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HttpUrlFetcher</span> <span class="keyword">implements</span> <span class="title class_">DataFetcher</span>&lt;InputStream&gt; &#123;</span><br><span class="line">  </span><br><span class="line">  HttpUrlFetcher(GlideUrl glideUrl, <span class="type">int</span> timeout, HttpUrlConnectionFactory connectionFactory) &#123;</span><br><span class="line">    <span class="built_in">this</span>.glideUrl = glideUrl;</span><br><span class="line">    <span class="built_in">this</span>.timeout = timeout;</span><br><span class="line">    <span class="built_in">this</span>.connectionFactory = connectionFactory;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">loadData</span><span class="params">(Priority priority, DataCallback&lt;? <span class="built_in">super</span> InputStream&gt; callback)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> LogTime.getLogTime();</span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      result = loadDataWithRedirects(glideUrl.toURL(), <span class="number">0</span> <span class="comment">/*redirects*/</span>, <span class="literal">null</span> <span class="comment">/*lastUrl*/</span>, glideUrl.getHeaders());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将数据通过回调返回</span></span><br><span class="line">    callback.onDataReady(result);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> InputStream <span class="title function_">loadDataWithRedirects</span><span class="params">(URL url, <span class="type">int</span> redirects, URL lastUrl, Map&lt;String, String&gt; headers)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//重定向次数超过5次</span></span><br><span class="line">    <span class="keyword">if</span> (redirects &gt;= MAXIMUM_REDIRECTS) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IOException</span>(<span class="string">&quot;Too many (&gt; &quot;</span> + MAXIMUM_REDIRECTS + <span class="string">&quot;) redirects!&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (lastUrl != <span class="literal">null</span> &amp;&amp; url.toURI().equals(lastUrl.toURI())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IOException</span>(<span class="string">&quot;In re-direct loop&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (URISyntaxException e) &#123;</span><br><span class="line">        <span class="comment">// Do nothing, this is best effort.</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建HttpURLConnection</span></span><br><span class="line">    urlConnection = connectionFactory.build(url);</span><br><span class="line">    <span class="comment">//往HttpURLConnection 添加 Head参数</span></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; headerEntry : headers.entrySet()) &#123;</span><br><span class="line">      urlConnection.addRequestProperty(headerEntry.getKey(), headerEntry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置超时时间</span></span><br><span class="line">    urlConnection.setConnectTimeout(timeout);</span><br><span class="line">    urlConnection.setReadTimeout(timeout);</span><br><span class="line">    <span class="comment">//设置不使用缓存</span></span><br><span class="line">    urlConnection.setUseCaches(<span class="literal">false</span>);</span><br><span class="line">    urlConnection.setDoInput(<span class="literal">true</span>);</span><br><span class="line">    <span class="comment">//连接</span></span><br><span class="line">    urlConnection.connect();</span><br><span class="line">    <span class="keyword">if</span> (isCancelled) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">statusCode</span> <span class="operator">=</span> urlConnection.getResponseCode();</span><br><span class="line">    <span class="keyword">if</span> (statusCode / <span class="number">100</span> == <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="comment">//获取内容大小</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">contentLength</span> <span class="operator">=</span> urlConnection.getHeaderField(CONTENT_LENGTH_HEADER);</span><br><span class="line">      <span class="comment">//获取输入流InputStream</span></span><br><span class="line">      stream = ContentLengthInputStream.obtain(urlConnection.getInputStream(), contentLength);</span><br><span class="line">      <span class="keyword">return</span> stream;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (statusCode / <span class="number">100</span> == <span class="number">3</span>) &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">redirectUrlString</span> <span class="operator">=</span> urlConnection.getHeaderField(<span class="string">&quot;Location&quot;</span>);</span><br><span class="line">      <span class="keyword">if</span> (TextUtils.isEmpty(redirectUrlString)) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IOException</span>(<span class="string">&quot;Received empty or null redirect url&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//从连接中获取Location字段进行重定向</span></span><br><span class="line">      <span class="type">URL</span> <span class="variable">redirectUrl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(url, redirectUrlString);</span><br><span class="line">      <span class="keyword">return</span> loadDataWithRedirects(redirectUrl, redirects + <span class="number">1</span>, url, headers);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//请求失败</span></span><br><span class="line">      <span class="keyword">if</span> (statusCode == -<span class="number">1</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IOException</span>(<span class="string">&quot;Unable to retrieve response code from HttpUrlConnection.&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IOException</span>(<span class="string">&quot;Request failed &quot;</span> + statusCode + <span class="string">&quot;: &quot;</span></span><br><span class="line">          + urlConnection.getResponseMessage());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">interface</span> <span class="title class_">HttpUrlConnectionFactory</span> &#123;</span><br><span class="line">    HttpURLConnection <span class="title function_">build</span><span class="params">(URL url)</span> <span class="keyword">throws</span> IOException;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">DefaultHttpUrlConnectionFactory</span> <span class="keyword">implements</span> <span class="title class_">HttpUrlConnectionFactory</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> HttpURLConnection <span class="title function_">build</span><span class="params">(URL url)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">      <span class="comment">//获取HttpURLConnection</span></span><br><span class="line">      <span class="keyword">return</span> (HttpURLConnection) url.openConnection();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>



<div class="comments-count">
	
	  	<span></span>
		<a href="/2017/08/02/开源代码分析之Glide/#comments" class="ds-thread-count comments-count-link" data-thread-key="2017/08/02/开源代码分析之Glide/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/07/16/Android开源框架之Dagger2/" title="开源代码分析之Dagger2" itemprop="url">开源代码分析之Dagger2</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Edgar" target="_blank" itemprop="author">Edgar</a>
		
  <p class="article-time">
    <time datetime="2017-07-16T05:15:00.000Z" itemprop="datePublished"> Published 2017-07-16</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h4 id="1-在项目中引入Dagger2"><a href="#1-在项目中引入Dagger2" class="headerlink" title="1. 在项目中引入Dagger2"></a>1. 在项目中引入Dagger2</h4><p>Dagger2 搞Android开发以及Java开发的同学估计即使没有使用过也应该听说过这个开源库吧。它是一个依赖注入库.源码地址如下所示：<br><a target="_blank" rel="noopener" href="https://github.com/google/dagger">Dagger2 github地址</a></p>
<p>在项目中引入Dagger2<br>project的build.gradle添加</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">     ... <span class="regexp">//</span> 其他classpath</span><br><span class="line">     classpath <span class="string">&#x27;com.neenbedankt.gradle.plugins:android-apt:1.8&#x27;</span> <span class="regexp">//</span>添加apt命令</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>module的build.gradle添加</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">//</span> 添加其他插件</span><br><span class="line">apply plugin: <span class="string">&#x27;com.neenbedankt.android-apt&#x27;</span><span class="regexp">//</span>添加apt命令</span><br><span class="line">dependencies &#123;</span><br><span class="line">    apt <span class="string">&#x27;com.google.dagger:dagger-compiler:2.0.2&#x27;</span> <span class="regexp">//</span>指定注解处理器</span><br><span class="line">    compile <span class="string">&#x27;com.google.dagger:dagger:2.0.2&#x27;</span>  <span class="regexp">//</span>dagger公用api</span><br><span class="line">    provided <span class="string">&#x27;org.glassfish:javax.annotation:10.0-b28&#x27;</span>  <span class="regexp">//</span>添加android缺失的部分javax注解</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-Dagger2简介"><a href="#2-Dagger2简介" class="headerlink" title="2. Dagger2简介"></a>2. Dagger2简介</h4><p>在介绍如何使用Dagger2之前我们必须先搞清楚一件事–为甚么需要使用Dagger2,也就是Dagger2的功能，刚刚提到了Dagger2 是一个依赖注入框架，那么什么是依赖注入呢？为什么要使用依赖注入呢？</p>
<p>我们传统的开发过程中如果某个类中需要一个依赖可以通过在这个类中创建需要的依赖，这样的缺点显而易见，比方我们需要在一个已经开发成熟的项目中更换某个类的实现，再具体点，比如我们在<br>现有项目中使用的是Picasso作为图像处理框架，但是某天项目中需要显示gif,这时候我们可能考虑到Glide库能够支持Gif播放，所以我们想要将图像处理框架更换为Glide<br>如果原先没有设计好的话可能改动的代码就很庞大。而且极为容易出错。但是如果使用了依赖注入框架，那么这个问题就变得很简单了，只需要修改对应的Module就可以了，对代码不需要大幅的改动。（这里的前提条件是这两个库接口上是相似的）</p>
<p>那么什么是依赖注入呢？这里我就谈谈自己对依赖注入的理解：<br>依赖注入就是将使用依赖的代码部分与依赖生成的部分分开，这样做的好处就是：因为对象是在一个独立、不耦合的地方初始化，所以当注入抽象方法的时候，我们只需要修改对象的实现方法，而不用大改代码库。并且可以通过注入这些依赖的Mock对象来进行模拟测试。从而使得对项目的测试更加方便。</p>
<p>有Dagger2就说明有Dagger的存在，关于这段历史大家如果感兴趣的话可以去网上了解下,这里就不展开介绍了，Dagger2的最大改进就是，它使用了Java注解处理器，完全去除了反射机制,在编译的时候检查并分析依赖关系。使得在效率上得到很大的提升。</p>
<h4 id="3-Dagger2结构"><a href="#3-Dagger2结构" class="headerlink" title="3. Dagger2结构"></a>3. Dagger2结构</h4><p>下面是Dagger2的大致结构：</p>
<p><img src="/2017/07/16/Android%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6%E4%B9%8BDagger2/dagger000.png"></p>
<p>整个依赖注入体系分成三个部分：</p>
<ol>
<li>依赖提供方： 用于生成并提供依赖对象的一方。</li>
<li>依赖需求方： 需要使用注入依赖的一方</li>
<li>依赖注入器： 连接依赖提供方和依赖需求方的注入器。它负责将依赖提供方生成的依赖对象注入到依赖需求方。换个角度来说就是依赖需求方需要注入依赖的时候可以顺着这个注入器找到依赖提供方。</li>
</ol>
<h4 id="4-Dagger2-重要的注解"><a href="#4-Dagger2-重要的注解" class="headerlink" title="4. Dagger2 重要的注解"></a>4. Dagger2 重要的注解</h4><p>了解了大体的结构后我们就需要了解下Dagger2中常用的一些注解，其实Dagger2的注解并不太多，但是需要注意的是这些注解的理解。</p>
<h5 id="Inject"><a href="#Inject" class="headerlink" title="@Inject:"></a>@Inject:</h5><p>我们看到上图中依赖注入器左右两端各有一个@Inject注解也就是说@Inject既可以用在提供方也可以用在依赖需求方，用在依赖提供方的时候一般用来注解待注入对象的构造函数,用在依赖需求方的时候一般用来注解需要Dagger2进行依赖注入的成员变量。</p>
<p>@Module:<br>我们看到依赖提供方还有个@Module注解，它的作用是什么呢？我们知道提供方已经有了一个@Inject为什么还需要@Module呢？我们考虑一个情景我们现有项目中使用了第三方的类库，在不采用导入第三方类库源码或者源代码非开源的情况，如果用Inject要怎么处理，根本不可能使用Inject注解加入这些类中是吧，那这还怎么办呢？这时候就需要@Module出场了。Modules类是由一系列专门提供依赖的方法组成，所以我们定义一个类，用@Module注解，这样Dagger在构造类的实例的时候，就知道从哪里去找到需要的依赖。</p>
<p>那么这两种方式有没优先级区分呢？<br>有的，它的查找规则如下：</p>
<ol>
<li>首先会先从Module的@Provides方法集合中查找</li>
<li>如果查找不到，则查找成员变量类型是否有@Inject构造方法。<br>也就是说@Module中的优先级会比@Inject注解的构造方法优先级更高，还有个需要注意的是@Modules不仅仅只用于那些第三方项目中不可见源码的对象注入，可以使用@Inject注入的对象，使用@Module一样可以注入。</li>
</ol>
<h5 id="Provide"><a href="#Provide" class="headerlink" title="@Provide"></a>@Provide</h5><p>提到@Module就不得不提到 @Provide，我们用这个注解来告诉Dagger2被这个注解的方法是被用来提供依赖的，具体提供哪种依赖对象是由返回值决定的，一般这类方法规定以provide作为开头，后面的可以随意。Module中@Provides方法可以是带输入参数的方法，其参数由Module集合中的其他@Provides方法提供，或者自动调用构造方法，也就是说如果找不到@Provides方法提供对应参数的对象，Dagger2就会自动调用带@Inject参数的构造方法生成相应对象。</p>
<p>下面是一个最基本的@Module的写法</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Module</span></span><br><span class="line"><span class="comment">//1 注明本类属于Module</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FruitModule</span>&#123;</span><br><span class="line">    <span class="meta">@Provides</span> </span><br><span class="line">    <span class="comment">//2 注明该方法是用来提供依赖对象的特殊方法</span></span><br><span class="line">    <span class="comment">//  返回值（被依赖的类类型）</span></span><br><span class="line">    <span class="comment">//  方法名（provideXxx必须以provide开头，后面随意）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title class_">Fruit</span> <span class="title function_">provideFruit</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Apple</span>(<span class="title class_">Color</span>.<span class="property">RED</span>,<span class="title class_">Size</span>.<span class="property">BIG</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Named"><a href="#Named" class="headerlink" title="@Named"></a>@Named</h5><p>如果待注入方需要依赖同个类的两种不同的对象的时候，那要怎么办，我们可能会想就写两个@Provides方法，而且这两个@Provides方法都是返回需要的类型，但是我们前面提到过Dagger2是靠返回值的类型来判断具体选择哪个@Provide方法来提供依赖的，现在有两个provide方法返回同一个类型，那就比较尴尬了，这种现象也有专门的叫法叫做注入迷失，为了解决这个问题这就需要使用@Named来进行区分了：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Module</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FruitModule</span>&#123;</span><br><span class="line">    <span class="meta">@Named</span>(<span class="string">&quot;typeA&quot;</span>)</span><br><span class="line">    <span class="meta">@Provides</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title class_">Fruit</span> <span class="title function_">provideApple</span>(<span class="params"></span>)&#123;  <span class="comment">//提供Apple给对应的mFruitA</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Apple</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Named</span>(<span class="string">&quot;typeB&quot;</span>)</span><br><span class="line">    <span class="meta">@Provides</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title class_">Fruit</span> <span class="title function_">provdeBanana</span>(<span class="params"></span>)&#123; <span class="comment">//提供Banana给对应的mFruitB</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Banana</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在待注入方也要使用@Named来标记到底使用的是哪个依赖，具体的待注入方以及注入会在下面进行介绍。</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@Named</span>(<span class="string">&quot;typeA&quot;</span>) //添加标记<span class="keyword">@Name</span>(<span class="string">&quot;typeA&quot;</span>)，只获取对应的<span class="keyword">@Name</span>(<span class="string">&quot;typeA&quot;</span>)的依赖   <span class="keyword">@Inject</span></span><br><span class="line">Fruit mFruitA; </span><br><span class="line"><span class="keyword">@Named</span>(<span class="string">&quot;typeB&quot;</span>) //添加标记<span class="keyword">@Name</span>(<span class="string">&quot;typeA&quot;</span>)，只获取对应的<span class="keyword">@Name</span>(<span class="string">&quot;typeA&quot;</span>)的依赖    <span class="keyword">@Inject</span></span><br><span class="line">Fruit mFruitB;</span><br></pre></td></tr></table></figure>

<h5 id="Qualifier"><a href="#Qualifier" class="headerlink" title="@Qualifier"></a>@Qualifier</h5><p>上面的方式只能使用字符串作为区分标签，一般来说是够用的，但是如果你需要其他的方式作为区分标签可以使用Qualifier进行定义了：</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@Qualifier</span>   <span class="comment">//必须，表示IntNamed是用来做区分用途</span></span><br><span class="line"><span class="variable">@Documented</span>           <span class="comment">//规范要求是Documented，当然不写也问题不大，但是建议写，做提示作用</span></span><br><span class="line"><span class="variable">@Retention</span>(RetentionPolicy.RUNTIME)  <span class="comment">//规范要求是Runtime级别</span></span><br><span class="line">public <span class="variable">@interface</span> IntNamed&#123;</span><br><span class="line">    <span class="selector-tag">int</span> <span class="selector-tag">value</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用法和@Named注解类似就不展开介绍了。</p>
<h5 id="Component"><a href="#Component" class="headerlink" title="@Component:"></a>@Component:</h5><p>Components从根本上来说就是一个注入器，也可以说是@Inject和@Module的桥梁，它的主要作用就是连接这两个部分。它注释的类必须是接口或抽象类。<br>既然它是注入器，必定由两个部分构成，一个是提供方，一个是需求方，提供方是由module引入，需求方是由inject方法引入。Component的职责就是在inject目标中有使用@Inject<br>注解的成员变量的时候顺着 Component 所管理的 Module中进行查找需要的依赖，但是如果不需要@ Module那么就不需要定义Component了，也就是说Component 是用于管理 @Module的，可以通过Component中的modules属性把Module加入Component，modules可以加入多个Module。<br>这样Component获取依赖时候会自动从多个Module中查找获取，需要注意的是Module间不能有重复方法，不然也会照成上面所提到的依赖迷失。</p>
<p>添加多个module有两种方法</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>. <span class="keyword">@Component</span>(modules=&#123;××××，×××&#125;) </span><br><span class="line"><span class="number">2</span>. <span class="keyword">@Module</span>（includes=&#123;××××，×××&#125;）这种方法一般用于构建更高层的Module时候使用</span><br></pre></td></tr></table></figure>

<p>假设ComponentA依赖ComponentB，B必须定义带返回值的方法来提供A缺少的依赖<br>ComponentA依赖ComponentB的代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义ComponentB</span></span><br><span class="line"><span class="meta">@Component(modules=&#123;××××××××&#125;)</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ComponentB</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义ComponentA</span></span><br><span class="line">@<span class="constructor">Component(<span class="params">dependencies</span>=&#123;ComponentB.<span class="params">class</span>&#125;,<span class="params">modules</span>=&#123;××××××××&#125;)</span><span class="comment">//使用dependencies</span></span><br><span class="line">interface ComponentA&#123;<span class="operator"></span></span><br><span class="line"><span class="operator">    ...</span></span><br><span class="line"><span class="operator"></span>&#125;</span><br></pre></td></tr></table></figure>
<p>这样，当使用ComponentA注入Container时，如果找不到对应的依赖，就会到ComponentB中查找。但是，ComponentB必须显式把这些A找不到的依赖提供给A。怎么提供呢，只需要在ComponentB中添加方法即可，如下</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@Component</span>(modules=&#123;××××××××&#125;)</span><br><span class="line">interface ComponentB&#123;</span><br><span class="line">    <span class="comment">// 假设A中module中找不到apple，banana，oranges，但是B的module有，B必须提供带返回值的方法如下</span></span><br><span class="line">    Apple <span class="built_in">apple</span>();</span><br><span class="line">    Banana <span class="built_in">banana</span>();</span><br><span class="line">    Oranges <span class="built_in">oranges</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Component 当中定义的方法可以分成两类：</p>
<ol>
<li>注入的目标对象以injectXXX作为方法名开始, 同一个Component可以有多个inject方法，也即是说可以注入到多个目标对象。注意inject的参数不能是父类，必须是你注入的那个类，因为这里写啥，Dagger就回去对应的类中寻找@Inject注解进行注入</li>
<li>需要暴露给依赖components的方法，如果不在这里列出那么使用dependencies方式的时候就不会暴露出来。</li>
</ol>
<p>下面是一个最基本的Component 定义方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component(modules=&#123;FruitModule.class&#125;)</span>     <span class="comment">//指明Component在哪些Module中查找依赖</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">FruitComponent</span>&#123;            <span class="comment">//接口，Dagger2框架将自动生成Component的实现类，对应的类名是Dagger×××××</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">inject</span><span class="params">(Container container)</span>;       <span class="comment">//注入方法，在待注入容器中调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@Component的注入</p>
<p>Component注入有两种方式：</p>
<ol>
<li>基本方式</li>
</ol>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Container&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span>()</span>&#123;</span><br><span class="line">         DaggerFruitComponent.create().inject(<span class="keyword">this</span>); <span class="comment">//使用FruitComponent的实现类注入</span></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>上面简单例子中，当调用DaggerFruitComponent.create(）实际上等价于DaggerFruitComponent.builder().build()。在构建的过程中，默认使用Module无参构造器产生实例。<br>如果需要传入特定的Module实例，可以使用</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">DaggerFruitComponent</span>.</span></span>builder<span class="literal">()</span></span><br><span class="line">.<span class="keyword">module</span><span class="constructor">A(<span class="params">new</span> ModuleA()</span>) <span class="comment">//指定Module实例</span></span><br><span class="line">.<span class="keyword">module</span><span class="constructor">B(<span class="params">new</span> ModuleB()</span>)</span><br><span class="line">.build<span class="literal">()</span></span><br></pre></td></tr></table></figure>
<p>如果Module只有有参构造器，则必须显式传入Module实例。</p>
<p>这里还留有一个问题等到讲 Component 依赖以及子Component的时候讲，那就是在Component依赖以及子Component的情况下怎么进行依赖注入。</p>
<h5 id="Scope-amp-amp-Singleton"><a href="#Scope-amp-amp-Singleton" class="headerlink" title="@Scope  &amp;&amp;  @Singleton"></a>@Scope  &amp;&amp;  @Singleton</h5><p>在学Dagger2的时候最难理解的部分就是@Scope 以及 Component依赖，子Component.还有就是如何在项目中组织Component。<br>我们接下来先来看下@Scope的作用，在不使用@Scope 的时候我们的例子如下，我们注入到MainActivity后将这两个对象打印出来，<br> <figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">Apple</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
 <figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Module</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FruidModule</span> &#123;</span><br><span class="line">    <span class="meta">@Provides</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title class_">Apple</span> <span class="title function_">provideApple</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Apple</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component(modules = &#123;FruidModule.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">FruidComponent</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">inject</span><span class="params">(MainActivity activity)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


 <figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@Inject</span></span><br><span class="line">Apple apple1;</span><br><span class="line"><span class="keyword">@Inject</span></span><br><span class="line">Apple apple2;</span><br><span class="line"><span class="keyword">@Override</span></span><br><span class="line">protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">    super<span class="selector-class">.onCreate</span>(savedInstanceState);</span><br><span class="line">    <span class="built_in">setContentView</span>(R.layout.activity_main);</span><br><span class="line">    DaggerFruidComponent<span class="selector-class">.builder</span>()<span class="selector-class">.build</span>()<span class="selector-class">.inject</span>(this);</span><br><span class="line">    LogManager<span class="selector-class">.getInstance</span>()<span class="selector-class">.info</span>(apple1.toString());</span><br><span class="line">    LogManager<span class="selector-class">.getInstance</span>()<span class="selector-class">.info</span>(apple2.toString());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印出来的结果如下：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="number">07</span>-<span class="number">18</span> <span class="number">20</span>:<span class="number">24</span>:<span class="number">15.355</span> <span class="number">3059</span>-<span class="number">3059</span>/com<span class="selector-class">.idealist</span><span class="selector-class">.tbfungeek</span><span class="selector-class">.mvpframework</span> I/MainActivity: class -&gt; MainActivity method -&gt; <span class="built_in">onCreate</span>() line -&gt; <span class="number">29</span> <span class="selector-attr">[ Message ]</span> com<span class="selector-class">.idealist</span><span class="selector-class">.tbfungeek</span><span class="selector-class">.mvpframework</span>.Apple@<span class="number">3</span>dd96071</span><br><span class="line"><span class="number">07</span>-<span class="number">18</span> <span class="number">20</span>:<span class="number">24</span>:<span class="number">15.355</span> <span class="number">3059</span>-<span class="number">3059</span>/com<span class="selector-class">.idealist</span><span class="selector-class">.tbfungeek</span><span class="selector-class">.mvpframework</span> I/MainActivity: class -&gt; MainActivity method -&gt; <span class="built_in">onCreate</span>() line -&gt; <span class="number">30</span> <span class="selector-attr">[ Message ]</span> com<span class="selector-class">.idealist</span><span class="selector-class">.tbfungeek</span><span class="selector-class">.mvpframework</span>.Apple@<span class="number">1956</span>ae56</span><br></pre></td></tr></table></figure>

<p>接着我们再做个对比实验：</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@Scope</span></span><br><span class="line"><span class="variable">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line">public <span class="variable">@interface</span> FruidScope &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@Module</span></span><br><span class="line">public class FruidModule &#123;</span><br><span class="line">    <span class="variable">@FruidScope</span></span><br><span class="line">    <span class="variable">@Provides</span></span><br><span class="line">    public Apple provideApple() &#123;</span><br><span class="line">        <span class="selector-tag">return</span> <span class="selector-tag">new</span> <span class="selector-tag">Apple</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@FruidScope</span></span><br><span class="line"><span class="variable">@Component</span>(modules = &#123;FruidModule.class&#125;)</span><br><span class="line">public interface FruidComponent &#123;</span><br><span class="line">    <span class="selector-tag">void</span> <span class="selector-tag">inject</span>(MainActivity activity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@FruidScope</span></span><br><span class="line"><span class="variable">@Inject</span></span><br><span class="line">Apple apple1;</span><br><span class="line"><span class="variable">@FruidScope</span></span><br><span class="line"><span class="variable">@Inject</span></span><br><span class="line">Apple apple2;</span><br><span class="line"></span><br><span class="line"><span class="variable">@Override</span></span><br><span class="line">protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">    <span class="selector-tag">super</span><span class="selector-class">.onCreate</span>(savedInstanceState);</span><br><span class="line">    <span class="selector-tag">setContentView</span>(R.layout.activity_main);</span><br><span class="line">    <span class="selector-tag">BaseApplication</span><span class="selector-class">.getAppDelegate</span>()<span class="selector-class">.getRefWatcher</span>()<span class="selector-class">.watch</span>(this);</span><br><span class="line">    <span class="selector-tag">DaggerFruidComponent</span><span class="selector-class">.builder</span>()<span class="selector-class">.build</span>()<span class="selector-class">.inject</span>(this);</span><br><span class="line">    <span class="selector-tag">LogManager</span><span class="selector-class">.getInstance</span>()<span class="selector-class">.info</span>(apple1.toString());</span><br><span class="line">    <span class="selector-tag">LogManager</span><span class="selector-class">.getInstance</span>()<span class="selector-class">.info</span>(apple2.toString());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line"><span class="number">07</span>-<span class="number">18</span> <span class="number">20</span>:<span class="number">27</span>:<span class="number">36.364</span> <span class="number">5818</span>-<span class="number">5818</span>/? V/A<span class="function"><span class="title">ctivityLifeCycleManager</span>$1: class -&gt;</span> A<span class="function"><span class="title">ctivityLifeCycleManager</span>$1 method -&gt;</span> <span class="function"><span class="title">onActivityCreated</span>() line -&gt;</span> <span class="number">61</span> [ M<span class="function"><span class="title">essage</span> ] onCreate --&gt;</span> MainActivity</span><br><span class="line"><span class="number">07</span>-<span class="number">18</span> <span class="number">20</span>:<span class="number">27</span>:<span class="number">36.388</span> <span class="number">5818</span>-<span class="number">5818</span>/? I/M<span class="function"><span class="title">ainActivity</span>: class -&gt;</span> M<span class="function"><span class="title">ainActivity</span> method -&gt;</span> <span class="function"><span class="title">onCreate</span>() line -&gt;</span> <span class="number">28</span> [ Message ] com.idealist.tbfungeek.mvpframework.Apple@<span class="number">3</span>dd96071</span><br><span class="line"><span class="number">07</span>-<span class="number">18</span> <span class="number">20</span>:<span class="number">27</span>:<span class="number">36.388</span> <span class="number">5818</span>-<span class="number">5818</span>/? I/M<span class="function"><span class="title">ainActivity</span>: class -&gt;</span> M<span class="function"><span class="title">ainActivity</span> method -&gt;</span> <span class="function"><span class="title">onCreate</span>() line -&gt;</span> <span class="number">29</span> [ Message ] com.idealist.tbfungeek.mvpframework.Apple@<span class="number">3</span>dd96071</span><br></pre></td></tr></table></figure>
<p>发现了什么没？我们在没有用scope注解的时候两个对象实际是不同的两个对象，但是如果用scope注解标记后两个返回的是同一个对象。</p>
<p>最早看到Singleton注解的时候我第一反应就是只要用上这个注解就可以实现单例模式了，但是它并非我们通常以为的单例，Java中，单例通常保存在一个静态域中，这样的单例往往要等到虚拟机关闭时候，该单例所占用的资源才释放。但是，Dagger通过Singleton创建出来的单例并不保持在静态域上，而是保留在Component实例中。也就是这种单例只是针对对应的Component。如果要实现传统意义上的单例模式，那么就需要通过一定的方法保证对应的Component是全局单例的。</p>
<p>下面是来自网络上的一个很经典的例子，估计看过后大家一定会豁然开朗：</p>
<p>在实际开发中我们可能还需要一种局部单例的控件（这个应该是更常用），比如说我们有三个Activity，MainActivity，BActivity和CActivity，我们想让MainActivity和BActivity共享同一个实例，而让CActivity获取另外一个实例，这又该怎么实现呢？在Dagger2中，我们可以通过自定义Scope来实现局部单例。那就动手吧：<br>首先让我们先来定义一个局部作用域：</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@Scope</span>  </span><br><span class="line"><span class="variable">@Retention</span>(RetentionPolicy.RUNTIME)  </span><br><span class="line">public <span class="variable">@interface</span> UserScope &#123;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>然后在我们的UserModule和ActivityComponent中应用该局部作用域：</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@Module</span>  </span><br><span class="line">public class UserModule &#123;  </span><br><span class="line">    <span class="variable">@Provides</span>  </span><br><span class="line">    <span class="variable">@UserScope</span>  </span><br><span class="line">    User providesUser() &#123;  </span><br><span class="line">        <span class="selector-tag">return</span> <span class="selector-tag">new</span> <span class="selector-tag">User</span>();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@UserScope</span>  </span><br><span class="line"><span class="variable">@Component</span>(modules = UserModule.class)  </span><br><span class="line">public interface ActivityComponent &#123;  </span><br><span class="line">    <span class="selector-tag">void</span> <span class="selector-tag">inject</span>(MainActivity activity);  </span><br><span class="line">  </span><br><span class="line">    <span class="selector-tag">void</span> <span class="selector-tag">inject</span>(BActivity activity);  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>大家注意，我的ActivityComponent作为一个注入器只可以向MainActivity和BActivity两个Activity中注入依赖，不可以向CActivity中注入依赖。最后，要让该局部作用域产生单例效果，需要我们在自定义的Appliation类中来初始化这个Component，如下：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;  </span><br><span class="line">    <span class="type">ActivityComponent</span> activityComponent;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    public void onCreate() &#123;  </span><br><span class="line">        <span class="keyword">super</span>.onCreate();  </span><br><span class="line">        activityComponent = <span class="type">DaggerActivityComponent</span>.builder().userModule(<span class="keyword">new</span> <span class="type">UserModule</span>()).build();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="type">ActivityComponent</span> getActivityComponent()&#123;  </span><br><span class="line">        <span class="keyword">return</span> activityComponent;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>接下来我们在MainActivity和BActivity中注入依赖，MainActivity如下：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">@Inject  </span><br><span class="line">User user;  </span><br><span class="line">@Inject  </span><br><span class="line">User user2;  </span><br><span class="line"><span class="keyword">private</span> TextView tv;  </span><br><span class="line"><span class="keyword">private</span> TextView tv2;  </span><br><span class="line">  </span><br><span class="line">@Override  </span><br><span class="line">protected void on<span class="constructor">Create(Bundle <span class="params">savedInstanceState</span>)</span> &#123;  </span><br><span class="line">    super.on<span class="constructor">Create(<span class="params">savedInstanceState</span>)</span>;  </span><br><span class="line">    set<span class="constructor">ContentView(R.<span class="params">layout</span>.<span class="params">activity_main</span>)</span>;  </span><br><span class="line">    ((MyApp) get<span class="constructor">Application()</span>).get<span class="constructor">ActivityComponent()</span>.inject(this);  </span><br><span class="line">    tv = ((TextView) find<span class="constructor">ViewById(R.<span class="params">id</span>.<span class="params">tv</span>)</span>);  </span><br><span class="line">    tv2 = ((TextView) find<span class="constructor">ViewById(R.<span class="params">id</span>.<span class="params">tv2</span>)</span>);  </span><br><span class="line">    tv.set<span class="constructor">Text(<span class="params">user</span>.<span class="params">toString</span>()</span>);  </span><br><span class="line">    tv2.set<span class="constructor">Text(<span class="params">user2</span>.<span class="params">toString</span>()</span>);  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>BActivity如下：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">@Inject  </span><br><span class="line">User user;  </span><br><span class="line">  </span><br><span class="line">@Override  </span><br><span class="line">protected void on<span class="constructor">Create(Bundle <span class="params">savedInstanceState</span>)</span> &#123;  </span><br><span class="line">    super.on<span class="constructor">Create(<span class="params">savedInstanceState</span>)</span>;  </span><br><span class="line">    set<span class="constructor">ContentView(R.<span class="params">layout</span>.<span class="params">activity_b</span>)</span>;  </span><br><span class="line">    ((MyApp) get<span class="constructor">Application()</span>).get<span class="constructor">ActivityComponent()</span>.inject(this);  </span><br><span class="line">    TextView tv = (TextView) find<span class="constructor">ViewById(R.<span class="params">id</span>.<span class="params">tv</span>)</span>;  </span><br><span class="line">    tv.set<span class="constructor">Text(<span class="params">user</span>.<span class="params">toString</span>()</span>);  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>那么如果我还想在CActivity中使用User对象该怎么办呢？再来一个CUserModule和CActivityComponent呗！<br>CUserModule如下：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Module</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CUserModule</span> &#123;  </span><br><span class="line">    <span class="meta">@Provides</span>  </span><br><span class="line">    <span class="title class_">User</span> <span class="title function_">providesUser</span>(<span class="params"></span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>这里我没有再注明单例了哦！<br>CActivityComponent如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component(modules = CUserModule.class)</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CActivityComponent</span> &#123;  </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">inject</span><span class="params">(CActivity activity)</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>在CActivity中注入依赖：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">@Inject  </span><br><span class="line">User user;  </span><br><span class="line">@Override  </span><br><span class="line">protected void on<span class="constructor">Create(Bundle <span class="params">savedInstanceState</span>)</span> &#123;  </span><br><span class="line">    super.on<span class="constructor">Create(<span class="params">savedInstanceState</span>)</span>;  </span><br><span class="line">    set<span class="constructor">ContentView(R.<span class="params">layout</span>.<span class="params">activity_c</span>)</span>;  </span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">DaggerCActivityComponent</span>.</span></span>builder<span class="literal">()</span>.c<span class="constructor">UserModule(<span class="params">new</span> CUserModule()</span>).build<span class="literal">()</span>.inject(this);  </span><br><span class="line">    TextView tv = (TextView) find<span class="constructor">ViewById(R.<span class="params">id</span>.<span class="params">tv</span>)</span>;  </span><br><span class="line">    tv.set<span class="constructor">Text(<span class="params">user</span>.<span class="params">toString</span>()</span>);  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>大家看到，MainActivity和BActivity是同一个实例，而CActivity则是另外一个实例。</p>
<p>同时还需要注意一点就是：一个@Module和component中可以有多个scope对象。这些scope将一个component划分成多个不同的区域：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Module</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FruidModule</span> &#123;</span><br><span class="line">    <span class="meta">@FruidScope</span></span><br><span class="line">    <span class="meta">@Provides</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title class_">Apple</span> <span class="title function_">provideApple</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Apple</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@FruidScope1</span></span><br><span class="line">    <span class="meta">@Provides</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title class_">Pear</span> <span class="title function_">providePear</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Pear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@FruidScope1</span></span><br><span class="line"><span class="variable">@FruidScope</span></span><br><span class="line"><span class="variable">@Component</span>(modules = &#123;FruidModule.class&#125;)</span><br><span class="line">public interface FruidComponent &#123;</span><br><span class="line">    <span class="selector-tag">void</span> <span class="selector-tag">inject</span>(MainActivity activity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@FruidScope</span></span><br><span class="line"> <span class="variable">@Inject</span></span><br><span class="line"> Apple apple1;</span><br><span class="line"> <span class="variable">@FruidScope</span></span><br><span class="line"> <span class="variable">@Inject</span></span><br><span class="line"> Apple apple2;</span><br><span class="line"></span><br><span class="line"> <span class="variable">@FruidScope1</span></span><br><span class="line"> <span class="variable">@Inject</span></span><br><span class="line"> Pear apple3;</span><br><span class="line"></span><br><span class="line"> <span class="variable">@FruidScope1</span></span><br><span class="line"> <span class="variable">@Inject</span></span><br><span class="line"> Pear apple4;</span><br><span class="line"></span><br><span class="line"> <span class="variable">@Override</span></span><br><span class="line"> protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">     <span class="selector-tag">super</span><span class="selector-class">.onCreate</span>(savedInstanceState);</span><br><span class="line">     <span class="selector-tag">setContentView</span>(R.layout.activity_main);</span><br><span class="line">     <span class="selector-tag">BaseApplication</span><span class="selector-class">.getAppDelegate</span>()<span class="selector-class">.getRefWatcher</span>()<span class="selector-class">.watch</span>(this);</span><br><span class="line">     <span class="selector-tag">DaggerFruidComponent</span><span class="selector-class">.builder</span>()<span class="selector-class">.build</span>()<span class="selector-class">.inject</span>(this);</span><br><span class="line">     <span class="selector-tag">LogManager</span><span class="selector-class">.getInstance</span>()<span class="selector-class">.info</span>(apple1.toString());</span><br><span class="line">     <span class="selector-tag">LogManager</span><span class="selector-class">.getInstance</span>()<span class="selector-class">.info</span>(apple2.toString());</span><br><span class="line">     <span class="selector-tag">LogManager</span><span class="selector-class">.getInstance</span>()<span class="selector-class">.info</span>(apple3.toString());</span><br><span class="line">     <span class="selector-tag">LogManager</span><span class="selector-class">.getInstance</span>()<span class="selector-class">.info</span>(apple4.toString());</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line"><span class="number">07</span>-<span class="number">18</span> <span class="number">21</span>:<span class="number">09</span>:<span class="number">07.245</span> <span class="number">5676</span>-<span class="number">5676</span>/? I/M<span class="function"><span class="title">ainActivity</span>: class -&gt;</span> M<span class="function"><span class="title">ainActivity</span> method -&gt;</span> <span class="function"><span class="title">onCreate</span>() line -&gt;</span> <span class="number">36</span> [ Message ] com.idealist.tbfungeek.mvpframework.Apple@<span class="number">3</span>dd96071</span><br><span class="line"><span class="number">07</span>-<span class="number">18</span> <span class="number">21</span>:<span class="number">09</span>:<span class="number">07.245</span> <span class="number">5676</span>-<span class="number">5676</span>/? I/M<span class="function"><span class="title">ainActivity</span>: class -&gt;</span> M<span class="function"><span class="title">ainActivity</span> method -&gt;</span> <span class="function"><span class="title">onCreate</span>() line -&gt;</span> <span class="number">37</span> [ Message ] com.idealist.tbfungeek.mvpframework.Apple@<span class="number">3</span>dd96071</span><br><span class="line"><span class="number">07</span>-<span class="number">18</span> <span class="number">21</span>:<span class="number">09</span>:<span class="number">07.245</span> <span class="number">5676</span>-<span class="number">5676</span>/? I/M<span class="function"><span class="title">ainActivity</span>: class -&gt;</span> M<span class="function"><span class="title">ainActivity</span> method -&gt;</span> <span class="function"><span class="title">onCreate</span>() line -&gt;</span> <span class="number">38</span> [ Message ] com.idealist.tbfungeek.mvpframework.Pear@<span class="number">1956</span>ae56</span><br><span class="line"><span class="number">07</span>-<span class="number">18</span> <span class="number">21</span>:<span class="number">09</span>:<span class="number">07.246</span> <span class="number">5676</span>-<span class="number">5676</span>/? I/M<span class="function"><span class="title">ainActivity</span>: class -&gt;</span> M<span class="function"><span class="title">ainActivity</span> method -&gt;</span> <span class="function"><span class="title">onCreate</span>() line -&gt;</span> <span class="number">39</span> [ Message ] com.idealist.tbfungeek.mvpframework.Pear@<span class="number">1956</span>ae56</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在使用scope的时候我们还需要注意如下两点：</p>
<ol>
<li><p>编译器会检查 Component管理的Modules，若发现标注Component的自定义Scope注解与Modules中的标注创建类实例方法的注解不一样，就会报错。所以Component和Modules中的scope必须匹配。</p>
</li>
<li><p>如果两个Component间有依赖关系，那么它们不能使用相同的Scope。</p>
</li>
</ol>
<h5 id="Subcomponent-amp-amp-dependencies"><a href="#Subcomponent-amp-amp-dependencies" class="headerlink" title="@Subcomponent  &amp;&amp; dependencies"></a>@Subcomponent  &amp;&amp; dependencies</h5><p>如果一个Component的功能不能满足你的需求，我们需要对它进行拓展，这时候有两种方法</p>
<ol>
<li>使用Component(dependencies&#x3D;××.classs)</li>
<li>使用@Subcomponent，Subcomponent用于拓展原有component。这时候注意子component同时具备两种不同生命周期的scope。子Component具备了父Component拥有的Scope，也具备了自己的Scope。</li>
</ol>
<p>那么它们的不同之处在哪里呢？@Component 只能获取到依赖的 Component 所暴露出来的对象，而 @Subcomponent 则可以获取到父类所有的对象。</p>
<p>Subcomponent其功能效果优点类似component的dependencies。但是使用@Subcomponent不需要在父component中显式添加子component需要用到的对象，只需要添加返回子Component的方法即可，子Component能自动在父Component中查找缺失的依赖。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//父Component：</span></span><br><span class="line"><span class="meta">@PerApp</span></span><br><span class="line"><span class="meta">@Component(modules=××××)</span></span><br><span class="line"><span class="keyword">public</span> AppComponent&#123;</span><br><span class="line">    SubComponent <span class="title function_">subcomponent</span><span class="params">()</span>;  <span class="comment">//1.只需要在父Component添加返回子Component的方法即可</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子Component：</span></span><br><span class="line"><span class="meta">@PerAcitivity</span>   <span class="comment">//2.注意子Component的Scope范围小于父Component</span></span><br><span class="line"><span class="meta">@Subcomponent(modules=××××)</span>   <span class="comment">//3.使用@Subcomponent</span></span><br><span class="line"><span class="keyword">public</span> SubComponent&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">inject</span><span class="params">(SomeActivity activity)</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SomeActivity</span> <span class="keyword">extends</span> <span class="title class_">Activity</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        App.getComponent().subCpmponent().inject(<span class="built_in">this</span>);<span class="comment">//4.调用subComponent方法创建出子Component</span></span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过Subcomponent，子Component就好像同时拥有两种Scope，当注入的元素来自父Component的Module，则这些元素会缓存在父Component，当注入的元素来自子Component的Module，则这些元素会缓存在子Component中。</p>
<h4 id="5-参考文章"><a href="#5-参考文章" class="headerlink" title="5. 参考文章"></a>5. 参考文章</h4><p>下面是较好的文章，如果看了该博客还是不大明白可以通过下面的文章来进一步阅读</p>
<ol>
<li><p><a target="_blank" rel="noopener" href="http://blog.csdn.net/android_study_ok/article/details/52384247">“一盘沙拉”带你入门Dagger2</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://blog.csdn.net/duo2005duo/article/details/50618171">Android常用开源工具-Dagger2入门</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://www.jianshu.com/p/a23c50cb4094">从零开始的Android新项目4 - Dagger2篇</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://blog.csdn.net/u012702547/article/details/52200927">解锁Dagger2使用姿势</a><br><a target="_blank" rel="noopener" href="http://www.jianshu.com/p/1d42d2e6f4a5">Android：dagger2让你爱不释手-重点概念讲解、融合篇</a></p>
</li>
</ol>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>



<div class="comments-count">
	
	  	<span></span>
		<a href="/2017/07/16/Android开源框架之Dagger2/#comments" class="ds-thread-count comments-count-link" data-thread-key="2017/07/16/Android开源框架之Dagger2/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/05/26/开源代码分析之EventBus/" title="开源代码分析之EventBus" itemprop="url">开源代码分析之EventBus</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Edgar" target="_blank" itemprop="author">Edgar</a>
		
  <p class="article-time">
    <time datetime="2017-05-26T13:35:42.000Z" itemprop="datePublished"> Published 2017-05-26</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>提到EventBus同样是每个Android 开发所必须掌握的一个开源库，它是一个事件发布订阅系统，用法十分简单，但是能够在很大程度上解决模块间存在的耦合问题，当某个模块的某个事件产生的时候，对应的事件通过post方法将其发布到Eventbus上，再由EventBus对该事件进行分发，如果某个类需要响应某个事件，必须事先通过register方法进行注册将自己订阅到总线上，这样EventBus就会根据实际的情况将事件源post出来的事件分发到有处理指定事件类型能力的订阅者方法上。一旦订阅者订阅了对应的事件，订阅者将会接收到对应类型的事件，直到调用unregitser方法取消注册。事件订阅方法必须使用@Subscribe注释，并且必须是public方法。返回值必须是void，并且只能有一个参数，该参数的类型为事件对象类型，用法就这么简单，三言两语就搞定了。但是这篇博客的关注点不在于它的使用上，这篇博客想从源码角度来对EventBus原理进行分析看下上述提到的功能是如何实现的。</p>
<p>但是在分析源码之前还是先要熟悉下EventBus是如何使用的，毕竟我们熟悉源码的目的也是为了应用。<br>首先我们先看下下面两张对比图：<br><img src="/2017/05/26/%E5%BC%80%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BEventBus/event_without_android.png"><br><img src="/2017/05/26/%E5%BC%80%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BEventBus/event_bus_android.png"></p>
<p>第一张是没有使用EventBus的项目结构图，可以看出整个结构几乎呈网状，这样的结构相对来说耦合度就相对高。<br>而第二张整个结构呈现的是星型结构，EventBus处于星型结构的核心位置，主要负责事件的接送与调度。事件的产生源和事件的消费者耦合度就大大得降低了，大家只和EventBus进行交互，事件源将事件分发到事件总线，订阅者不会相互交互而是监听事件总线分发的事件。所以订阅者和事件源避免了之间的强约束。</p>
<p>这篇博客介绍的是EventBus 3.xEventBus 3 相对于之前的版本引入了EventBusAnnotationProcessor，我们可以使用编译时注解的方式来使用Eventbus了。在EventBus 早期的版本中事件注册信息的获取采用的是反射机制，这样就会导致效率上的降低，在EventBus 3的版本上并行使用反射和编译时注解两种方式，我们可以根据自己的实际需求来选择采用哪种方式。这个在后面源代码分析的时候会进行介绍。</p>
<h4 id="在项目中引入EventBus-3-x"><a href="#在项目中引入EventBus-3-x" class="headerlink" title="在项目中引入EventBus 3.x"></a>在项目中引入EventBus 3.x</h4><p>这里推荐大家使用编译时注解方式。我这边为了方便起见，也只介绍使用编译时注解的方式引入。<br>这里需要注意的是目前很多教程注解预编译所采用的是android-apt的方式，不过随着Android Gradle 插件 2.2 版本的发布，Android Studio推出了编译时预处理官方插件，所以Apt工具的作者也就宣布不再维护该工具了。目前使用的是annotationProcessor来取代android-apt方式。<br>如果大家使用的是还是android-apt方式的话，建议通过如下方式来切换到annotationProcess方式。</p>
<p>切换步骤：<br>首先要确保Android Gradle插件版本是2.2以上：</p>
<ol>
<li>修改Project 的build.gradle配置</li>
</ol>
<p>android-apt方式</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    <span class="keyword">classpath</span> <span class="string">&#x27;com.android.tools.build:gradle:2.2.3&#x27;</span></span><br><span class="line">    <span class="keyword">classpath</span> <span class="string">&#x27;com.neenbedankt.gradle.plugins:android-apt:1.8&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改后annotationProcessor  方式</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    <span class="keyword">classpath</span> <span class="string">&#x27;com.android.tools.build:gradle:2.2.3&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是把原先的</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">classpath</span> &#x27;com.neenbedankt.gradle.plugins:android-apt:<span class="number">1</span>.<span class="number">8</span>&#x27; 去掉</span><br></pre></td></tr></table></figure>



<ol start="2">
<li>修改module的build.gradle配置</li>
</ol>
<p>android-apt方式</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">buildscript</span> &#123;</span><br><span class="line">    <span class="keyword">repositories</span> &#123;</span><br><span class="line">        jcenter()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">dependencies</span> &#123;</span><br><span class="line">        <span class="keyword">classpath</span> <span class="string">&#x27;com.neenbedankt.gradle.plugins:android-apt:1.8&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">````</span><br><span class="line">apply plugin: <span class="string">&#x27;com.neenbedankt.android-apt&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>dependencies {<br>    compile ‘org.greenrobot:eventbus:3.0.0’<br>    apt’org.greenrobot:eventbus-annotation-processor:3.0.1’<br>}</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">修改后annotationProcessor  方式，只保留<span class="keyword">dependencies</span> 里面的引用并且把apt 换成annotationProcessor就可以了</span><br></pre></td></tr></table></figure>
<p>dependencies {<br>    compile ‘org.greenrobot:eventbus:3.0.0’<br>    annotationProcessor  ‘org.greenrobot:eventbus-annotation-processor:3.0.1’<br>}</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attribute">3</span>. EventBus <span class="number">3</span>.<span class="number">0</span> Index类的制定方式</span><br><span class="line"></span><br><span class="line"><span class="attribute">android</span>-apt方式</span><br></pre></td></tr></table></figure>
<p>apt  {<br>    arguments {<br>        eventBusIndex “org.greenrobot.eventbus.demo.MyEventBusIndex”<br>    }<br>}</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">修改后annotationProcessor  方式</span><br></pre></td></tr></table></figure>
<p>defaultConfig {<br>    javaCompileOptions {<br>        annotationProcessorOptions {<br>            arguments &#x3D; [ eventBusIndex : ‘org.greenrobot.eventbus.demo.MyEventBusIndex’ ]<br>        }<br>    }<br>}</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">紧接着rebuild下项目，就会发现在build目录下上面指定报名下生成了一个MyEventBusIndex，这个文件是怎么生成的我们在介绍源码的时候会进行介绍，这里先不管这些。我们接下来就需要将生成的索引添加到EventBus中供事件分发是时候查找。我们知道EventBus默认有一个单例，可以通过<span class="built_in">getDefault</span>()获取，但是这里我要做的是使用EventBusBuilder对其进行配置后再将Builder生成的EventBus作为默认的EventBus.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>EventBus.builder().addIndex(new MyEventBusIndex()).installDefaultEventBus();</p>
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">#### EventBus 的使用：</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 定义订阅方法：</span><br><span class="line">EventBus使用注解@Subscribe的方式来定义订阅方法。这里面我们需要重点了解下threadMode，sticky，priority这三个属性的含义：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>@Subscribe(threadMode &#x3D; ThreadMode.POSTING,sticky &#x3D; false,priority &#x3D; 1)<br>public void onMessageEvent(MessageEvent event) {<br>    tv.setText(event.message);<br>}</p>
<figure class="highlight nestedtext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attribute">（1）ThreadMode </span><span class="punctuation">:</span></span><br><span class="line"><span class="punctuation"></span></span><br><span class="line"><span class="attribute">这时候订阅者执行的线程与事件的发布者所在的线程为同一个线程。也就是说</span></span><br><span class="line"><span class="attribute"></span></span><br><span class="line"><span class="attribute"></span></span><br><span class="line"><span class="attribute">ThreadMode</span><span class="punctuation">:</span> <span class="string">POSTING </span></span><br><span class="line"><span class="attribute">事件由哪个线程发布的，订阅者就在哪个线程中执行。这时候订阅者执行的线程与事件的发布者所在的线程为同一个线程,这个是EventBus默认的线程模式</span></span><br><span class="line"><span class="attribute"></span></span><br><span class="line"><span class="attribute">ThreadMode</span><span class="punctuation">:</span> <span class="string">MAIN </span></span><br><span class="line"><span class="attribute">订阅方法是在Android的主线程中运行的。如果提交的线程也是主线程，那么他就和ThreadMode.POSTING一样了。当然在由于是在主线程中运行的，所以在这里就不能执行一些耗时的任务。</span></span><br><span class="line"><span class="attribute"></span></span><br><span class="line"><span class="attribute">ThreadMode</span><span class="punctuation">:</span> <span class="string">BACKGROUND </span></span><br><span class="line"><span class="attribute">这种模式下，我们的订阅者将会在后台线程中执行。如果发布者是在主线程中进行的事件发布，那么订阅者将会重新开启一个子线程运行，若是发布者在不是在主线程中进行的事件发布，那么这时候订阅者就在发布者所在的线程中执行任务。</span></span><br><span class="line"><span class="attribute"></span></span><br><span class="line"><span class="attribute">ThreadMode</span><span class="punctuation">:</span> <span class="string">ASYNC </span></span><br><span class="line"><span class="attribute">这种模式下，订阅者将会独立运行在一个线程中。不管发布者是在主线程还是在子线程中进行事件的发布，订阅者都是在重新开启一个线程来执行任务。</span></span><br><span class="line"><span class="attribute"></span></span><br><span class="line"><span class="attribute"></span></span><br><span class="line"><span class="attribute">（2）priority</span><span class="punctuation">:</span></span><br><span class="line"><span class="punctuation"></span></span><br><span class="line">在订阅者中我们也可以为其设置优先级，优先级高的将会首先接收到发布者所发布的事件。并且我们还能在高优先中取消事件，这时候的优先级的订阅者将接收不到事件。这类似于BroadcastReceiver中的取消广播。不过这里有一点我们要注意，对于订阅者的优先级只是针对于相同的ThreadMode中。</span><br><span class="line"></span><br><span class="line">(3) sticky</span><br><span class="line">sticky与一般的事件的区别是sticky事件发送事件之后再订阅该事件还能收到所订阅事件的最新事件。一般事件在事件发生后才订阅是不会收到之前发送的事件的。</span><br><span class="line">注解方法定义还需要注意，必须是public方法，必须只有一个参数，不能是抽象或者static方法。</span><br><span class="line"></span><br><span class="line">2. 订阅事件：</span><br><span class="line">register（this） 这个就不需要介绍了。对于sticky事件在注册的时候会立刻收到最新的事件。</span><br><span class="line">3. 取消订阅：</span><br><span class="line">unregister(this) 一定要记得取消订阅否则会继续接收到事件。这是一个很尴尬的事情。</span><br><span class="line">4. 发布事件：</span><br><span class="line">post(xxxx) postSticky 将事件发布到事件总线上让EventBus来调度。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">##### EventBus源码解析：</span></span><br><span class="line"></span><br><span class="line">1. EventBus 实例的创建</span><br><span class="line">EventBus 的实例创建使用的是单例模式 + 建造者模式：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>public static EventBus getDefault() {<br>    &#x2F;&#x2F;使用单例的方法创建eventbus<br>    &#x2F;&#x2F;getDefault方法使用了double check(双重检查锁定模式)，多了一层判断，故可以减少上锁开销。<br>    if (defaultInstance &#x3D;&#x3D; null) {<br>        synchronized (EventBus.class) {<br>            if (defaultInstance &#x3D;&#x3D; null) {<br>                defaultInstance &#x3D; new EventBus();<br>            }<br>        }<br>    }<br>    return defaultInstance;<br>}</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">在创建的时候我们会通过丢进去一个设置好各种属性后的<span class="keyword">Builder，然后在EventBus构造函数上从Builder上获取已经设置好的各种属性，这个在很多开源代码中都使用过这种方式，比如picasso </span>Okhttp等，这种比较适合于有多个属性需要设置的情况。但是我们这里的重点在于EventBus有哪些属性，在下面代码中对一些部件进行了注释，还有一些没有注释的是比较重要的，需要在后面分析中重点提到的，我们接着往下看。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>public EventBus() {<br>    this(DEFAULT_BUILDER);<br>}</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<p>private static final EventBusBuilder DEFAULT_BUILDER &#x3D; new EventBusBuilder();</p>
<p>EventBus(EventBusBuilder builder) {</p>
<pre><code>//这三个变量很重要后面会重点介绍
subscriptionsByEventType = new HashMap&lt;&gt;();
typesBySubscriber = new HashMap&lt;&gt;();
stickyEvents = new ConcurrentHashMap&lt;&gt;();

//三个事件分发器对应不同的threadMode
//主线程分发器
mainThreadPoster = new HandlerPoster(this, Looper.getMainLooper(), 10);
//后台线程分发器
backgroundPoster = new BackgroundPoster(this);
//异步线程分发器
asyncPoster = new AsyncPoster(this);
//这个是执行任务的线程池
executorService = builder.executorService;


//这个是我们上面提到的在使用EventBus编译时注解方式的时候会通过addIndex将编译时生成的Index注入。subscriberInfoIndexes就是用于存放这些Index的。
indexCount = builder.subscriberInfoIndexes != null ? builder.subscriberInfoIndexes.size() : 0;
//这个类负责查找订阅者方法
subscriberMethodFinder = new SubscriberMethodFinder(builder.subscriberInfoIndexes, builder.strictMethodVerification, builder.ignoreGeneratedIndex);


//下面是和调试相关的开关:
//是否打印订阅异常
logSubscriberExceptions = builder.logSubscriberExceptions;
//是否打印没有订阅者的Log
logNoSubscriberMessages = builder.logNoSubscriberMessages;
//是否发送订阅者异常
sendSubscriberExceptionEvent = builder.sendSubscriberExceptionEvent;
//是否发送没有订阅者的事件
sendNoSubscriberEvent = builder.sendNoSubscriberEvent;
//是否抛出订阅异常
throwSubscriberException = builder.throwSubscriberException;

//eventInheritance 设置为true的时候会发送事件以及当前事件所实现的接口以及当前事件的父类事件。
eventInheritance = builder.eventInheritance;
</code></pre>
<p>}</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">2.</span> 注册订阅者</span><br><span class="line"></span><br><span class="line">要将当前某个类作为某个事件的订阅者需要调用EventBus的<span class="keyword">register</span>方法：</span><br></pre></td></tr></table></figure>
<p>public void register(Object subscriber) {<br>    &#x2F;&#x2F;获取订阅者的class对象<br>    Class&lt;?&gt; subscriberClass &#x3D; subscriber.getClass();<br>    &#x2F;&#x2F;在这个类中查找对应的订阅方法以及父类的订阅方法<br>    List<SubscriberMethod> subscriberMethods &#x3D; subscriberMethodFinder.findSubscriberMethods(subscriberClass);<br>    synchronized (this) {<br>        for (SubscriberMethod subscriberMethod : subscriberMethods) {<br>            &#x2F;&#x2F;针对每个订阅方法调用subscribe进行订阅<br>            subscribe(subscriber, subscriberMethod);<br>        }<br>    }<br>}</SubscriberMethod></p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line">这里会使用SubscriberMethodFinder对作为参数传入对象的<span class="keyword">class</span>进行查找，找到对应的订阅方法以及父类的订阅方法。我们先看下这部分代码：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>List<SubscriberMethod> findSubscriberMethods(Class<?> subscriberClass) {
    //先从缓存中获取某个订阅类的订阅方法
    List<SubscriberMethod> subscriberMethods = METHOD_CACHE.get(subscriberClass);
    if (subscriberMethods != null) {
        //如果缓存中有那么就直接使用缓存中的缓存方法
        return subscriberMethods;
    }
    //使用不同的方式来寻找订阅方法，EventBus3.0版本提供了EventBusAnnotationProcessor这个类,用于在编译期获取并缓存@Subscribe注解的方法
    //ignoreGeneratedIndex = false 的时候使用编译期间获取到的Subscribe注释的方法
    if (ignoreGeneratedIndex) {
        //使用’findUsingReflection(Class<?> subscriberClass)‘方法，进行反射来获取<br>        subscriberMethods &#x3D; findUsingReflection(subscriberClass);<br>    } else {<br>        &#x2F;&#x2F;使用编译期间获取到的Subscribe注释方法<br>        &#x2F;&#x2F;通过 findUsingInfo(Class&lt;?&gt; subscriberClass) 在apt中进行查找获取<br>        subscriberMethods &#x3D; findUsingInfo(subscriberClass);<br>    }</SubscriberMethod></SubscriberMethod></p>
<pre><code>//如果在当前类以及父类中没找到任何的订阅方法抛出异常
if (subscriberMethods.isEmpty()) &#123;
    throw new EventBusException(&quot;Subscriber &quot; + subscriberClass
            + &quot; and its super classes have no public methods with the @Subscribe annotation&quot;);
&#125; else &#123;
    //如果有找到那么添加到缓存中以便后续查找使用，存储的方式为订阅类-----&gt;订阅方法
    METHOD_CACHE.put(subscriberClass, subscriberMethods);
    return subscriberMethods;
&#125;
</code></pre>
<p>}</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">查找订阅方法有两类一种是使用反射的方式来获取到<span class="variable">@SubScriber</span>注解的方法，另一种是EventBus3.<span class="number">0</span> 版本之后会使用编译时注解方式在编译的时候获取并缓存<span class="variable">@Subscribe</span>注解的方法，后一种大家在上一篇介绍Butterknife源码的时候介绍了大致的方式，这里我还会带大家对EventBusAnnotationProcessor 这个注解处理器进行分析。</span><br><span class="line"></span><br><span class="line">找到当前类包含<span class="variable">@Subscribe</span>方法后会将这些方法添加到内存缓存中，以便后续查找方便，因为特别是反射方式是一种十分耗性能的方式，这个解决方案在Butterknife上我们也看到过。</span><br><span class="line">METHOD_CACHE 这个缓冲是以当前类的class对象作为key，每个key对应的值是当前类的所有使用<span class="variable">@Subscribe</span>注解的方法，也就是事件订阅方法。这里需要注意的是如果在当前类以及父类中没找到任何的订阅方法抛出异常。这是我第一次使用EventBus遇到的一个问题，记忆犹新。哈。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">接下来我们来看下这两种获取订阅方法的流程，首先我们看下通过反射的方式 --- findUsingReflection</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>private List<SubscriberMethod> findUsingReflection(Class&lt;?&gt; subscriberClass) {<br>    &#x2F;** 为FindState创建一个对象池,复用FindState对象,防止对象被多次new或者gc. *&#x2F;<br>    FindState findState &#x3D; prepareFindState();<br>    &#x2F;&#x2F;将订阅方法赋给FindState对象<br>    findState.initForSubscriber(subscriberClass);<br>    while (findState.clazz !&#x3D; null) {<br>        &#x2F;&#x2F;查找当前订阅类的订阅方法<br>        findUsingReflectionInSingleClass(findState);<br>        &#x2F;&#x2F;查找当前订阅类父类的订阅方法<br>        findState.moveToSuperclass();<br>    }<br>    &#x2F;&#x2F;将所有的订阅方法从findState中取出并返回<br>    return getMethodsAndRelease(findState);<br>}</SubscriberMethod></p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">首先在查找的时候，每次查找会对应一个FindState，这里为了避免频繁创建FindState对象，使用了复用对象池的方法，每次使用先在对象池中查找，如果有之前用过的就直接使用，避免了重新创建一个对象。实在没有的情况再通过<span class="keyword">new</span><span class="type"></span>的方式来创建，用完后并不是立即就释放不用，而是放到缓存中供下一次使用。</span><br></pre></td></tr></table></figure>
<p>private FindState prepareFindState() {<br>    synchronized (FIND_STATE_POOL) {<br>        for (int i &#x3D; 0; i &lt; POOL_SIZE; i++) {<br>            FindState state &#x3D; FIND_STATE_POOL[i];<br>            if (state !&#x3D; null) {<br>                FIND_STATE_POOL[i] &#x3D; null;<br>                return state;<br>            }<br>        }<br>    }<br>    return new FindState();<br>}</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">我们先看下FindState的结构</span><br><span class="line">![](<span class="regexp">/开源代码分析之EventBus/</span>findstate.png)</span><br><span class="line">FindState用于记录当前查的结果，我们首先会调用initForSubscriber来给FindState“打个标签”用于说明当前的FindState对象用于存放哪个订阅类的查找结果，然后在查找过程中会将查找结果先调用checkAdd以及checkAddWithMethodSignature对查找到的结果进行两级检测，然后再添加到subscriberMethods 中。</span><br><span class="line"></span><br><span class="line">我们接下来看下如何使用反射来查找订阅方法：</span><br></pre></td></tr></table></figure>
<p>&#x2F;&#x2F;对注册对类的方法进行遍历，必须是public 必须只有一个参数，必须使用@SubScribe注释，并且当前事件类型<br>private void findUsingReflectionInSingleClass(FindState findState) {<br>    Method[] methods;<br>    try {<br>        &#x2F;&#x2F; This is faster than getMethods, especially when subscribers are fat classes like Activities<br>        &#x2F;&#x2F;获取全部的方法<br>        methods &#x3D; findState.clazz.getDeclaredMethods();<br>    } catch (Throwable th) {<br>        &#x2F;&#x2F; Workaround for java.lang.NoClassDefFoundError, see <a target="_blank" rel="noopener" href="https://github.com/greenrobot/EventBus/issues/149">https://github.com/greenrobot/EventBus/issues/149</a><br>        methods &#x3D; findState.clazz.getMethods();<br>        findState.skipSuperClasses &#x3D; true;<br>    }<br>    for (Method method : methods) {<br>        &#x2F;&#x2F;获取方法的修饰符<br>        int modifiers &#x3D; method.getModifiers();<br>        &#x2F;&#x2F;在需要检查修饰符的情况下需要修饰符为public<br>        if ((modifiers &amp; Modifier.PUBLIC) !&#x3D; 0 &amp;&amp; (modifiers &amp; MODIFIERS_IGNORE) &#x3D;&#x3D; 0) {<br>            &#x2F;&#x2F;获取参数<br>            Class<?>[] parameterTypes = method.getParameterTypes();
            //如果参数为1个那么满足要求
            if (parameterTypes.length == 1) {
                //查看当前的注释释放包括Subscribe
                Subscribe subscribeAnnotation = method.getAnnotation(Subscribe.class);
                if (subscribeAnnotation != null) {
                    //如果有Subscribe注释，那么parameterTypes[0]就是事件类型
                    Class<?> eventType &#x3D; parameterTypes[0];<br>                    &#x2F;&#x2F;通过上面的层层筛选，获取到通过上述筛选的方法，以及方法中作为参数的事件类型，将其作为参数传递到findState进行检查<br>                    &#x2F;&#x2F;检查分两级，一般只需要一级检查，检查当前类中当前事件是否被某个方法已经注册处理，如果没有那么就添加到subscriberMethods中。<br>                    if (findState.checkAdd(method, eventType)) {<br>                        ThreadMode threadMode &#x3D; subscribeAnnotation.threadMode();<br>                        &#x2F;&#x2F;获取注释中的线程模型，事件类型，方法，优先级，是否是sticky方法<br>                        findState.subscriberMethods.add(new SubscriberMethod(method, eventType, threadMode,<br>                                subscribeAnnotation.priority(), subscribeAnnotation.sticky()));<br>                    }<br>                }<br>            } else if (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) {<br>                String methodName &#x3D; method.getDeclaringClass().getName() + “.” + method.getName();<br>                throw new EventBusException(“@Subscribe method “ + methodName +<br>                        “must have exactly 1 parameter but has “ + parameterTypes.length);<br>            }<br>        } else if (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) {<br>            String methodName &#x3D; method.getDeclaringClass().getName() + “.” + method.getName();<br>            throw new EventBusException(methodName +<br>                    “ is a illegal @Subscribe method: must be public, non-static, and non-abstract”);<br>        }<br>    }<br>}</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line">首先会检查方法的修饰符是否是<span class="keyword">public</span>，是否只有一个参数，是否目前已经有订阅方法订阅了该事件，订阅该事件的订阅方法是否是同一个方法。如果通过上述的检查，就会将这个订阅方法添加到FindState中的subscriberMethods。查找完当前类后会继续查找其父类。最后调用getMethodsAndRelease将FindState中存放的找到的订阅方法取出，然后将FindState添加到对象池中。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>private List<SubscriberMethod> findUsingInfo(Class&lt;?&gt; subscriberClass) {<br>    &#x2F;&#x2F;从池中取出一个不为空的FindState对象,避免了重新创建<br>    FindState findState &#x3D; prepareFindState();<br>    &#x2F;&#x2F;将当前的subscriberClass赋给FindState<br>    findState.initForSubscriber(subscriberClass);<br>    &#x2F;&#x2F;如果事件对象不为空<br>    while (findState.clazz !&#x3D; null) {<br>        &#x2F;&#x2F;从订阅者类到其父类，逐步获取订阅者信息<br>        findState.subscriberInfo &#x3D; getSubscriberInfo(findState);<br>        if (findState.subscriberInfo !&#x3D; null) {<br>            &#x2F;&#x2F;如果存在订阅者信息，那么获取订阅者方法<br>            SubscriberMethod[] array &#x3D; findState.subscriberInfo.getSubscriberMethods();<br>            for (SubscriberMethod subscriberMethod : array) {<br>                &#x2F;&#x2F;检查是否已经可以添加<br>                if (findState.checkAdd(subscriberMethod.method, subscriberMethod.eventType)) {<br>                    &#x2F;&#x2F;添加<br>                    findState.subscriberMethods.add(subscriberMethod);<br>                }<br>            }<br>        } else {<br>            &#x2F;&#x2F;在当个类中使用反射来获取对应的订阅方法<br>            findUsingReflectionInSingleClass(findState);<br>        }<br>        &#x2F;&#x2F;移动到它的父类继续查找<br>        findState.moveToSuperclass();<br>    }<br>    return getMethodsAndRelease(findState);<br>}</SubscriberMethod></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">上面的流程和之前介绍的用反射的流程一致，只不过在获取方式上存在差别：</span><br><span class="line">我们重点看下getSubscriberInfo 方法：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>private SubscriberInfo getSubscriberInfo(FindState findState) {</p>
<pre><code>//这部分很重要回头要认真看下有部分与EventBusAnnotationProcessor相关
if (subscriberInfoIndexes != null) &#123;
    for (SubscriberInfoIndex index : subscriberInfoIndexes) &#123;
        SubscriberInfo info = index.getSubscriberInfo(findState.clazz);
        if (info != null) &#123;
            return info;
        &#125;
    &#125;
&#125;
return null;
</code></pre>
<p>}</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">getSubscriberInfo 中会遍历<span class="keyword">subscriberInfoIndexes </span>取出其中的<span class="keyword">SubscribeInfo,subscriberInfoIndexes还记得是怎么来的吧，就是我们之前通过addIndex将编译生成的类添加进来。</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line">接下来我们就需要深究EventBusAnnotationProcessor 以及它生成的代码了：</span><br><span class="line">我们先看它的process方法，这个方法会在编译的时候执行。首先它会要求我们在<span class="keyword">build.gradle中有如下配置：</span></span><br></pre></td></tr></table></figure>
<p>defaultConfig {<br>    javaCompileOptions {<br>        annotationProcessorOptions {<br>            arguments &#x3D; [ eventBusIndex : ‘org.greenrobot.eventbus.demo.MyEventBusIndex’ ]<br>        }<br>    }<br>}</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">否则就不会继续进行，eventBusIndex主要用于指定要生成哪个类。</span><br></pre></td></tr></table></figure>
<p>@Override<br>public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment env) {<br>    Messager messager &#x3D; processingEnv.getMessager();<br>    try {<br>        &#x2F;&#x2F;首先需要在build.gradle中配置生成的EventBusIndex类的名字，如果没有那么就会打印出错误消息<br>        String index &#x3D; processingEnv.getOptions().get(OPTION_EVENT_BUS_INDEX);<br>        if (index &#x3D;&#x3D; null) {<br>            messager.printMessage(Diagnostic.Kind.ERROR, “No option “ + OPTION_EVENT_BUS_INDEX +<br>                    “ passed to annotation processor”);<br>            return false;<br>        }<br>        verbose &#x3D; Boolean.parseBoolean(processingEnv.getOptions().get(OPTION_VERBOSE));<br>        int lastPeriod &#x3D; index.lastIndexOf(‘.’);<br>        String indexPackage &#x3D; lastPeriod !&#x3D; -1 ? index.substring(0, lastPeriod) : null;<br>        round++;<br>        if (verbose) {<br>            messager.printMessage(Diagnostic.Kind.NOTE, “Processing round “ + round + “, new annotations: “ +<br>                    !annotations.isEmpty() + “, processingOver: “ + env.processingOver());<br>        }<br>        if (env.processingOver()) {<br>            if (!annotations.isEmpty()) {<br>                messager.printMessage(Diagnostic.Kind.ERROR,<br>                        “Unexpected processing state: annotations still available after processing over”);<br>                return false;<br>            }<br>        }<br>        &#x2F;&#x2F;如果当前方法没有注解那么就返回false<br>        if (annotations.isEmpty()) {<br>            return false;<br>        }</p>
<pre><code>    //收集订阅者
    collectSubscribers(annotations, env, messager);
    checkForSubscribersToSkip(messager, indexPackage);
    //如果不为空那么就创建Index文件
    if (!methodsByClass.isEmpty()) &#123;
        createInfoIndexFile(index);
    &#125; else &#123;
        messager.printMessage(Diagnostic.Kind.WARNING, &quot;No @Subscribe annotations found&quot;);
    &#125;
    writerRoundDone = true;
&#125; catch (RuntimeException e) &#123;
    // IntelliJ does not handle exceptions nicely, so log and print a message
    e.printStackTrace();
    messager.printMessage(Diagnostic.Kind.ERROR, &quot;Unexpected error in EventBusAnnotationProcessor: &quot; + e);
&#125;
return true;
</code></pre>
<p>}</p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">collectSubscribers 方法检查并收集订阅方法，如果有订阅方法那么就调用createInfoIndexFile生成对应的<span class="keyword">index</span>类。</span><br><span class="line"></span><br><span class="line">首先看下collectSubscribers 方法，我们会对传入注解处理器的所有方法注解进行便利。然后调用checkHasNoErrors对其进行检查。这个和FindState对象的checkAdd类似。如果检查通过了就会将其添加到methodsByClass中。其中该注解所处的类作为<span class="keyword">key</span>。对应的方法作为<span class="keyword">value</span>。</span><br></pre></td></tr></table></figure>
<p>private void collectSubscribers(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment env, Messager messager) {<br>    for (TypeElement annotation : annotations) {<br>        Set&lt;? extends Element&gt; elements &#x3D; env.getElementsAnnotatedWith(annotation);<br>        for (Element element : elements) {<br>            &#x2F;&#x2F;如果是可执行的元素<br>            if (element instanceof ExecutableElement) {<br>                ExecutableElement method &#x3D; (ExecutableElement) element;<br>                &#x2F;&#x2F;检查方法的修饰符以及参数个数<br>                if (checkHasNoErrors(method, messager)) {<br>                    TypeElement classElement &#x3D; (TypeElement) method.getEnclosingElement();<br>                    &#x2F;&#x2F;方法所处的类  ——-   方法<br>                    methodsByClass.putElement(classElement, method);<br>                }<br>            } else {<br>                messager.printMessage(Diagnostic.Kind.ERROR, “@Subscribe is only valid for methods”, element);<br>            }<br>        }<br>    }<br>}</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">紧接着我们看下checkHasNoErrors这个方法,这个方法主要检查方法的修饰符以及方法的参数个数。</span><br></pre></td></tr></table></figure>
<p>&#x2F;&#x2F;检测方法的修饰符，以及方法的参数个数<br>private boolean checkHasNoErrors(ExecutableElement element, Messager messager) {<br>    if (element.getModifiers().contains(Modifier.STATIC)) {<br>        messager.printMessage(Diagnostic.Kind.ERROR, “Subscriber method must not be static”, element);<br>        return false;<br>    }</p>
<pre><code>if (!element.getModifiers().contains(Modifier.PUBLIC)) &#123;
    messager.printMessage(Diagnostic.Kind.ERROR, &quot;Subscriber method must be public&quot;, element);
    return false;
&#125;

List&lt;? extends VariableElement&gt; parameters = ((ExecutableElement) element).getParameters();
if (parameters.size() != 1) &#123;
    messager.printMessage(Diagnostic.Kind.ERROR, &quot;Subscriber method must have exactly 1 parameter&quot;, element);
    return false;
&#125;
return true;
</code></pre>
<p>}</p>
<figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line">最后我们看下如何创建<span class="keyword">Index</span>文件：</span><br></pre></td></tr></table></figure>
<p>private void createInfoIndexFile(String index) {<br>        BufferedWriter writer &#x3D; null;<br>        try {<br>            JavaFileObject sourceFile &#x3D; processingEnv.getFiler().createSourceFile(index);<br>            int period &#x3D; index.lastIndexOf(‘.’);<br>            String myPackage &#x3D; period &gt; 0 ? index.substring(0, period) : null;<br>            String clazz &#x3D; index.substring(period + 1);<br>            writer &#x3D; new BufferedWriter(sourceFile.openWriter());<br>            if (myPackage !&#x3D; null) {<br>                writer.write(“package “ + myPackage + “;\n\n”);<br>            }<br>            writer.write(“import org.greenrobot.eventbus.meta.SimpleSubscriberInfo;\n”);<br>            writer.write(“import org.greenrobot.eventbus.meta.SubscriberMethodInfo;\n”);<br>            writer.write(“import org.greenrobot.eventbus.meta.SubscriberInfo;\n”);<br>            writer.write(“import org.greenrobot.eventbus.meta.SubscriberInfoIndex;\n\n”);<br>            writer.write(“import org.greenrobot.eventbus.ThreadMode;\n\n”);<br>            writer.write(“import java.util.HashMap;\n”);<br>            writer.write(“import java.util.Map;\n\n”);<br>            writer.write(“&#x2F;** This class is generated by EventBus, do not edit. *&#x2F;\n”);<br>            writer.write(“public class “ + clazz + “ implements SubscriberInfoIndex {\n”);<br>            writer.write(“    private static final Map&lt;Class<?>, SubscriberInfo> SUBSCRIBER_INDEX;\n\n");
            writer.write("    static {\n");
            writer.write("        SUBSCRIBER_INDEX = new HashMap<Class<?>, SubscriberInfo&gt;();\n\n”);<br>            writeIndexLines(writer, myPackage);<br>            writer.write(“    }\n\n”);<br>            writer.write(“    private static void putIndex(SubscriberInfo info) {\n”);<br>            writer.write(“        SUBSCRIBER_INDEX.put(info.getSubscriberClass(), info);\n”);<br>            writer.write(“    }\n\n”);<br>            writer.write(“    @Override\n”);<br>            writer.write(“    public SubscriberInfo getSubscriberInfo(Class&lt;?&gt; subscriberClass) {\n”);<br>            writer.write(“        SubscriberInfo info &#x3D; SUBSCRIBER_INDEX.get(subscriberClass);\n”);<br>            writer.write(“        if (info !&#x3D; null) {\n”);<br>            writer.write(“            return info;\n”);<br>            writer.write(“        } else {\n”);<br>            writer.write(“            return null;\n”);<br>            writer.write(“        }\n”);<br>            writer.write(“    }\n”);<br>            writer.write(“}\n”);<br>        } catch (IOException e) {<br>            throw new RuntimeException(“Could not write source for “ + index, e);<br>        } finally {<br>            if (writer !&#x3D; null) {<br>                try {<br>                    writer.close();<br>                } catch (IOException e) {<br>                    &#x2F;&#x2F;Silent<br>                }<br>            }<br>        }<br>    }</Class<?></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">这样代码看起开很难看，我们直接看生成的代码样子吧,大体长这样：</span><br></pre></td></tr></table></figure>

<p>&#x2F;** This class is generated by EventBus, do not edit. *&#x2F;<br>public class MyEventBusIndex implements SubscriberInfoIndex {<br>    private static final Map&lt;Class&lt;?&gt;, SubscriberInfo&gt; SUBSCRIBER_INDEX;</p>
<pre><code>static &#123;
    SUBSCRIBER_INDEX = new HashMap&lt;Class&lt;?&gt;, SubscriberInfo&gt;();
    putIndex(new SimpleSubscriberInfo(com.idealist.tbfungeek.core.mvp.view.core.BaseWebViewActivity.class, true,
            new SubscriberMethodInfo[] &#123;
        new SubscriberMethodInfo(&quot;onProcessMainEvent&quot;, BaseMainEvent.class, ThreadMode.MAIN),
        new SubscriberMethodInfo(&quot;onProcessAsyncEvent&quot;, BaseAsyncEvent.class, ThreadMode.ASYNC),
        new SubscriberMethodInfo(&quot;onProcessBgEvent&quot;, BaseBackgroundEvent.class, ThreadMode.BACKGROUND),
        new SubscriberMethodInfo(&quot;onProcessPostEvent&quot;, BasePostEvent.class),
    &#125;));

    putIndex(new SimpleSubscriberInfo(com.idealist.tbfungeek.core.mvp.view.core.BaseActivity.class, true,
            new SubscriberMethodInfo[] &#123;
        new SubscriberMethodInfo(&quot;onProcessMainEvent&quot;, BaseMainEvent.class, ThreadMode.MAIN),
        new SubscriberMethodInfo(&quot;onProcessAsyncEvent&quot;, BaseAsyncEvent.class, ThreadMode.ASYNC),
        new SubscriberMethodInfo(&quot;onProcessBgEvent&quot;, BaseBackgroundEvent.class, ThreadMode.BACKGROUND),
        new SubscriberMethodInfo(&quot;onProcessPostEvent&quot;, BasePostEvent.class),
    &#125;));

    putIndex(new SimpleSubscriberInfo(com.idealist.tbfungeek.core.mvp.view.core.BaseFragment.class, true,
            new SubscriberMethodInfo[] &#123;
        new SubscriberMethodInfo(&quot;onProcessMainEvent&quot;, BaseMainEvent.class, ThreadMode.MAIN),
        new SubscriberMethodInfo(&quot;onProcessAsyncEvent&quot;, BaseAsyncEvent.class, ThreadMode.ASYNC),
        new SubscriberMethodInfo(&quot;onProcessBgEvent&quot;, BaseBackgroundEvent.class, ThreadMode.BACKGROUND),
        new SubscriberMethodInfo(&quot;onProcessPostEvent&quot;, BasePostEvent.class),
    &#125;));

&#125;

private static void putIndex(SubscriberInfo info) &#123;
    SUBSCRIBER_INDEX.put(info.getSubscriberClass(), info);
&#125;

@Override
public SubscriberInfo getSubscriberInfo(Class&lt;?&gt; subscriberClass) &#123;
    SubscriberInfo info = SUBSCRIBER_INDEX.get(subscriberClass);
    if (info != null) &#123;
        return info;
    &#125; else &#123;
        return null;
    &#125;
&#125;
</code></pre>
<p>}</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">这里有个SUBSCRIBER_INDEX，每个当中存放着一个SimpleSubscriberInfo对象，每个SimpleSubscriberInfo对象由一个全路径名表示的<span class="keyword">class</span>对象。这个<span class="symbol">class</span>对象指明了当前是哪个订阅者，然后还包含着一个<span class="symbol">SubscriberMethodInfo</span>数组，这里面存放的是每个订阅者的信息，包括方法名，事件类。<span class="symbol">threadMode</span>等信息。我们上面也看到了在创建<span class="symbol">EventBusBuilder</span>的时候通过<span class="symbol">addindex</span>将这个生成的索引类对象注入。在<span class="symbol">findUsingInfo</span>方法中调用索引类的<span class="symbol">getSubscriberInfo</span>方法从<span class="symbol">SUBSCRIBER_INDEX</span>中取出对应的<span class="symbol">SubscriberInfo</span>也就是刚刚存放到里面的<span class="symbol">SimpleSubscriberInfo</span>，我们看下<span class="symbol">SimpleSubscriberInfo</span>的定义：</span><br></pre></td></tr></table></figure>
<p>public class SimpleSubscriberInfo extends AbstractSubscriberInfo {</p>
<pre><code>private final SubscriberMethodInfo[] methodInfos;

public SimpleSubscriberInfo(Class subscriberClass, boolean shouldCheckSuperclass, SubscriberMethodInfo[] methodInfos) &#123;
    super(subscriberClass, null, shouldCheckSuperclass);
    this.methodInfos = methodInfos;
&#125;

@Override
public synchronized SubscriberMethod[] getSubscriberMethods() &#123;
    int length = methodInfos.length;
    SubscriberMethod[] methods = new SubscriberMethod[length];
    for (int i = 0; i &lt; length; i++) &#123;
        SubscriberMethodInfo info = methodInfos[i];
        methods[i] = createSubscriberMethod(info.methodName, info.eventType, info.threadMode,
                info.priority, info.sticky);
    &#125;
    return methods;
&#125;
</code></pre>
<p>}</p>
<figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">这里的SubscriberMethodInfo 就是该订阅类的订阅订阅方法。在回头看下findUsingInfo方法。findUsingInfo中会继续调用SubscriberMethodInfo的getSubscriberMethods</span><br><span class="line">来获得SubscriberMethod。如果认真看的话我们会发现刚刚添加SubscriberMethodInfo的时候方法实用的是方法名称，而SubscriberMethod中存放的是<span class="keyword">Method</span>对象，也就是说这里还必须有个转换。这个转换就发生在<span class="title function_">createSubscriberMethod</span>中。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>protected SubscriberMethod createSubscriberMethod(String methodName, Class&lt;?&gt; eventType,<br>                                                    ThreadMode threadMode,int priority, boolean sticky) {<br>    try {<br>        &#x2F;&#x2F;从订阅类中获取指定方法名和事件类型的方法<br>        Method method &#x3D; subscriberClass.getDeclaredMethod(methodName, eventType);<br>        return new SubscriberMethod(method, eventType, threadMode, priority, sticky);<br>    } catch (NoSuchMethodException e) {<br>        throw new EventBusException(“Could not find subscriber method in “ + subscriberClass +<br>                “. Maybe a missing ProGuard rule?”, e);<br>    }<br>}</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">之后的逻辑就和之前的一样了，先进行检查后添加到FindState中的scribeMethod列表中，然后再拷贝出来并将FindState放回对象池。</span><br><span class="line"></span><br><span class="line">整个SubscriberFinder的流程如下图所示：</span><br><span class="line">不论是通过反射还是编译时注解大体的流程都一致的，都是先从FindState对象池中获取一个FindState用于存放查找的中间结果，然后调用SubscribeFinder针对订阅类中的订阅方法进行查找，查找到对应的订阅方法后，调用checkAdd进行检查是否有相同的方法订阅同一个事件，经过上述的步骤后获取到我们想要的订阅方法列表，最后将这个列表从FindState中拷贝出来，存放到subscribeMethods列表中，并将FindState放回到对象池中，以便下一次使用。</span><br><span class="line">![](<span class="regexp">/开源代码分析之EventBus/</span>subscribe_finder.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">我们获得当前订阅类中的订阅方法后我们还需要将其添加到事件总线中，以便事件总线根据对应的关系来分发事件源发送到事件。我们就来看下这部分代码：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) {<br>    &#x2F;<em>某某类中的某某方法 用于处理某个事件</em>&#x2F;<br>    &#x2F;&#x2F;获取当前订阅方法的事件类型（事件类型为订阅方法的参数）<br>    Class&lt;?&gt; eventType &#x3D; subscriberMethod.eventType;<br>    Subscription newSubscription &#x3D; new Subscription(subscriber&#x2F;<em>订阅类</em>&#x2F;, subscriberMethod&#x2F;<em>该订阅类的某个订阅方法</em>&#x2F;);</p>
<pre><code>//从subscriptionsByEventType获取事件类型为eventType的订阅者，看下该事件是否已经订阅了
CopyOnWriteArrayList&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType);
if (subscriptions == null) &#123;
    //如果为空（表示该事件还没找到订阅者）那么新建一个空的传进去
    subscriptions = new CopyOnWriteArrayList&lt;&gt;();
    subscriptionsByEventType.put(eventType, subscriptions);
&#125; else &#123;
    //如果不为空表示该事件已经有订阅者了，如果当前订阅者信息中已经有同样方法已经订阅了，那么抛出异常
    if (subscriptions.contains(newSubscription)) &#123;
        throw new EventBusException(&quot;Subscriber &quot; + subscriber.getClass() + &quot; already registered to event &quot;
                + eventType);
    &#125;
&#125;

//subscriptionsByEventType  按照事件类别对订阅者进行分类
// 事件类1
//    |-----订阅类1  ---- 方法1
//    |-----订阅类2  ---- 方法2
//    |-----订阅类3  ---- 方法3
//    |-----订阅类4  ---- 方法4
//    |-----订阅类5  ---- 方法5
//    |-----订阅类6  ---- 方法6
//    |-----订阅类7  ---- 方法7

//优先级从大到小，适当的位置插入
int size = subscriptions.size();
for (int i = 0; i &lt;= size; i++) &#123;
    if (i == size || subscriberMethod.priority &gt; subscriptions.get(i).subscriberMethod.priority) &#123;
        subscriptions.add(i, newSubscription);
        break;
    &#125;
&#125;

//typesBySubscriber
//       |--------事件类型
//       |--------事件类型
//       |--------事件类型
//       |--------事件类型
//       |--------事件类型
//当前订阅者订阅了哪些事件集合.
List&lt;Class&lt;?&gt;&gt; subscribedEvents = typesBySubscriber.get(subscriber);
if (subscribedEvents == null) &#123;
    subscribedEvents = new ArrayList&lt;&gt;();
    typesBySubscriber.put(subscriber, subscribedEvents);
&#125;
//将当前的事件类型添加到当前订阅者订阅的事件集合
subscribedEvents.add(eventType);

if (subscriberMethod.sticky) &#123;
    if (eventInheritance) &#123;
        // Existing sticky events of all subclasses of eventType have to be considered.
        // Note: Iterating over all events may be inefficient with lots of sticky events,
        // thus data structure should be changed to allow a more efficient lookup
        // (e.g. an additional map storing sub classes of super classes: Class -&gt; List&lt;Class&gt;).
        Set&lt;Map.Entry&lt;Class&lt;?&gt;, Object&gt;&gt; entries = stickyEvents.entrySet();
        for (Map.Entry&lt;Class&lt;?&gt;, Object&gt; entry : entries) &#123;
            Class&lt;?&gt; candidateEventType = entry.getKey();
            if (eventType.isAssignableFrom(candidateEventType)) &#123;
                Object stickyEvent = entry.getValue();
                checkPostStickyEventToSubscription(newSubscription, stickyEvent);
            &#125;
        &#125;
    &#125; else &#123;
        //如果当前事件类型是属于sticky事件类型，那么在注册的时候将其发送到订阅者
        Object stickyEvent = stickyEvents.get(eventType);
        checkPostStickyEventToSubscription(newSubscription, stickyEvent);
    &#125;
&#125;
</code></pre>
<p>}</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">看完上面代码注释后我们来介绍下EventBus中三个重要的列表：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>subscriptionsByEventType: key是某个事件类型，value是订阅这个事件类型的订阅者列表（按照优先级顺序排列）  这个是最重要，事件分发到时候就是依赖这个表<br>typesBySubscriber:key 是某个订阅者，value是这个订阅者所订阅的事件类型。<br>stickyEvents：sticky事件列表</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">关于这些列表的实际作用我们介绍完事件分发后再来看看这个在事件分发过程中是如何起作用的。</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 事件源发布事件：</span><br><span class="line">事件的发布是通过<span class="built_in">post</span>以及postSticky来发布的，我们先来看下通过<span class="built_in">post</span>发布普通事件的流程：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>public void post(Object event) {<br>    &#x2F;&#x2F;获取当前posting线程的状态<br>    PostingThreadState postingState &#x3D; currentPostingThreadState.get();<br>    &#x2F;&#x2F;获取事件队列<br>    List<Object> eventQueue &#x3D; postingState.eventQueue;<br>    &#x2F;&#x2F;将事件添加到事件队列中<br>    eventQueue.add(event);<br>    if (!postingState.isPosting) {<br>        &#x2F;&#x2F;是否是在主线程中<br>        postingState.isMainThread &#x3D; Looper.getMainLooper() &#x3D;&#x3D; Looper.myLooper();<br>        &#x2F;&#x2F;将postingState置为true<br>        postingState.isPosting &#x3D; true;<br>        if (postingState.canceled) {<br>            throw new EventBusException(“Internal error. Abort state was not reset”);<br>        }<br>        try {<br>            while (!eventQueue.isEmpty()) {<br>                &#x2F;&#x2F;将队头的元素发布出去<br>                postSingleEvent(eventQueue.remove(0), postingState);<br>            }<br>        } finally {<br>            postingState.isPosting &#x3D; false;<br>            postingState.isMainThread &#x3D; false;<br>        }<br>    }<br>}</Object></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">发布过程如下：</span><br><span class="line">（1） 将当前事件添加到事件队列列表中</span><br><span class="line">（2） 查看事件队列列表是否有缓存的事件，如果有那么将队头的事件发布出去</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>private void postSingleEvent(Object event, PostingThreadState postingState) throws Error {<br>    &#x2F;&#x2F;事件类<br>    Class<?> eventClass = event.getClass();
    //是否找到订阅者
    boolean subscriptionFound = false;
    /*如果eventInheritance 为true 那么当前事件以及接口，子接口父类事件都会被post*/
    if (eventInheritance) {
        //获取当前事件以及接口，子接口，以及父类，比如当前的事件类型为MotionEvents ，那么MotionEvents本身，以及它的接口子接口，以及父类都会被添加到eventTypes
        List<Class<?>&gt; eventTypes &#x3D; lookupAllEventTypes(eventClass);<br>        &#x2F;&#x2F;找到对应的事件类型以及子类型调用postSingleEventForEventType<br>        int countTypes &#x3D; eventTypes.size();<br>        for (int h &#x3D; 0; h &lt; countTypes; h++) {<br>            Class&lt;?&gt; clazz &#x3D; eventTypes.get(h);<br>            subscriptionFound |&#x3D; postSingleEventForEventType(event, postingState, clazz);<br>        }<br>    } else {<br>        &#x2F;&#x2F;调用postSingleEventForEventType<br>        subscriptionFound &#x3D; postSingleEventForEventType(event, postingState, eventClass);<br>    }<br>    &#x2F;&#x2F;如果没有找到订阅者<br>    if (!subscriptionFound) {<br>        &#x2F;&#x2F;如果打开没有订阅者的Log发出对应的Log<br>        if (logNoSubscriberMessages) {<br>            Log.d(TAG, “No subscribers registered for event “ + eventClass);<br>        }<br>        &#x2F;&#x2F;发送NoSubscriberEvent，我们可以注册这个来处理这个事件<br>        if (sendNoSubscriberEvent &amp;&amp; eventClass !&#x3D; NoSubscriberEvent.class &amp;&amp;<br>                eventClass !&#x3D; SubscriberExceptionEvent.class) {<br>            post(new NoSubscriberEvent(this, event));<br>        }<br>    }<br>}</Class<?></p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">首先这里面有个关键变量eventInheritance 这个变量如果是<span class="literal">true</span>，那么调用<span class="built_in">post</span>的时候不但会讲当前事件发布出去，也会将其父类以及接口类作为事件发布出去，这个值默认是<span class="literal">true</span>，这个需要注意下。</span><br><span class="line">紧接着最关键的代码在postSingleEventForEventType以及postToSubscription 中</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>private boolean postSingleEventForEventType(Object event, PostingThreadState postingState, Class&lt;?&gt; eventClass) {<br>    CopyOnWriteArrayList<Subscription> subscriptions;<br>    synchronized (this) {<br>        &#x2F;&#x2F;获取订阅这个事件的订阅者们，可以有多个<br>        subscriptions &#x3D; subscriptionsByEventType.get(eventClass);<br>    }<br>    if (subscriptions !&#x3D; null &amp;&amp; !subscriptions.isEmpty()) {<br>        for (Subscription subscription : subscriptions) {<br>            postingState.event &#x3D; event;<br>            postingState.subscription &#x3D; subscription;<br>            boolean aborted &#x3D; false;<br>            try {<br>                &#x2F;&#x2F;将事件传递给各个订阅类<br>                postToSubscription(subscription, event, postingState.isMainThread);<br>                aborted &#x3D; postingState.canceled;<br>            } finally {<br>                &#x2F;&#x2F;重置状态<br>                postingState.event &#x3D; null;<br>                postingState.subscription &#x3D; null;<br>                postingState.canceled &#x3D; false;<br>            }<br>            if (aborted) {<br>                break;<br>            }<br>        }<br>        return true;<br>    }<br>    return false;<br>}</Subscription></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<p>private void postToSubscription(Subscription subscription, Object event, boolean isMainThread) {<br>    &#x2F;&#x2F;根据订阅线程模式使用不同的poster进行订阅<br>    switch (subscription.subscriberMethod.threadMode) {<br>        case POSTING:<br>            &#x2F;&#x2F;当前进程中执行<br>            invokeSubscriber(subscription, event);<br>            break;<br>        case MAIN:<br>            &#x2F;&#x2F;在主线程中执行<br>            if (isMainThread) {<br>                &#x2F;&#x2F;如果当前线程是主线程那么直接在当前线程中运行<br>                invokeSubscriber(subscription, event);<br>            } else {<br>                &#x2F;&#x2F;如果当前线程不是主线程，那么使用主线程Handler运行<br>                mainThreadPoster.enqueue(subscription, event);<br>            }<br>            break;<br>        case BACKGROUND:<br>            if (isMainThread) {<br>                &#x2F;&#x2F;如果当前线程是主线程，那么使用backgroundPoster运行<br>                backgroundPoster.enqueue(subscription, event);<br>            } else {<br>                &#x2F;&#x2F;如果当前是后台线程，那么直接在这个后台线程中运行<br>                invokeSubscriber(subscription, event);<br>            }<br>            break;<br>        case ASYNC:<br>            &#x2F;&#x2F;如果是异步的都归到asyncPoster运行<br>            asyncPoster.enqueue(subscription, event);<br>            break;<br>        default:<br>            throw new IllegalStateException(“Unknown thread mode: “ + subscription.subscriberMethod.threadMode);<br>    }<br>}</p>
<figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line">当事件发送到事件总线中后会使用事件类型从我们第一阶段形成的subscriptionsByEventType列表中获取对应的subscription，需要注意的是一个事件可能有多个subscription，所以获取到的是subscription列表。然后再根据subscription中的threadMode的情况来触发invokeSubscriber方法。在这个方法中实际上是调用subscription中<span class="keyword">method</span>对象的<span class="title function_">invoke</span>方法来出发点对应的订阅方法。</span><br><span class="line"></span><br><span class="line">我们来详细看下不同<span class="title function_">threadMode</span>是如何处理的：</span><br><span class="line">（1）<span class="title function_">POSTING</span>：</span><br><span class="line">这种情况最为简单就是直接调用<span class="title function_">invokeSubscriber</span></span><br></pre></td></tr></table></figure>
<p>void invokeSubscriber(Subscription subscription, Object event) {<br>    try {<br>        &#x2F;&#x2F;触发订阅方法，并将事件类型作为参数传给它<br>        subscription.subscriberMethod.method.invoke(subscription.subscriber, event);<br>    } catch (InvocationTargetException e) {<br>        handleSubscriberException(subscription, event, e.getCause());<br>    } catch (IllegalAccessException e) {<br>        throw new IllegalStateException(“Unexpected exception”, e);<br>    }<br>}</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">(<span class="number">2</span>) <span class="selector-tag">MAIN</span>:</span><br><span class="line">这种情况会先判断当前线程是否是主线程，如果是的话就直接调用invokeSubscriber，如果不是的话就必须依靠mainThreadPoster了，我们看下mainThreadPoster：</span><br></pre></td></tr></table></figure>
<p>final class HandlerPoster extends Handler {</p>
<p>   &#x2F;&#x2F;……………..<br>    void enqueue(Subscription subscription, Object event) {<br>        &#x2F;&#x2F;从池中获取一个PendingPost<br>        PendingPost pendingPost &#x3D; PendingPost.obtainPendingPost(subscription, event);<br>        synchronized (this) {<br>            &#x2F;&#x2F;入队<br>            queue.enqueue(pendingPost);<br>            if (!handlerActive) {<br>                handlerActive &#x3D; true;<br>                if (!sendMessage(obtainMessage())) {<br>                    throw new EventBusException(“Could not send handler message”);<br>                }<br>            }<br>        }<br>    }</p>
<pre><code>@Override
public void handleMessage(Message msg) &#123;
    boolean rescheduled = false;
    try &#123;
        long started = SystemClock.uptimeMillis();
        while (true) &#123;
            PendingPost pendingPost = queue.poll();
            if (pendingPost == null) &#123;
                synchronized (this) &#123;
                    // Check again, this time in synchronized
                    pendingPost = queue.poll();
                    if (pendingPost == null) &#123;
                        handlerActive = false;
                        return;
                    &#125;
                &#125;
            &#125;
            eventBus.invokeSubscriber(pendingPost);
            long timeInMethod = SystemClock.uptimeMillis() - started;
            if (timeInMethod &gt;= maxMillisInsideHandleMessage) &#123;
                if (!sendMessage(obtainMessage())) &#123;
                    throw new EventBusException(&quot;Could not send handler message&quot;);
                &#125;
                rescheduled = true;
                return;
            &#125;
        &#125;
    &#125; finally &#123;
        handlerActive = rescheduled;
    &#125;
&#125;
</code></pre>
<p>}</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">在介绍mainPoster之前我们先来看下PendingPost,这里有个对象池，最大的大小为<span class="number">10000</span>，每次发布事件的时候不是直接通过<span class="keyword">new</span><span class="type"></span>一个PendingPost而是从对象池中取出一个已经存在的PendingPost，通过这种复用对象池来缓解频繁创建对象带来的性能问题。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>final class PendingPost {<br>    private final static List<PendingPost> pendingPostPool &#x3D; new ArrayList<PendingPost>();</PendingPost></PendingPost></p>
<pre><code>Object event;
Subscription subscription;
PendingPost next;

private PendingPost(Object event, Subscription subscription) &#123;
    this.event = event;
    this.subscription = subscription;
&#125;

static PendingPost obtainPendingPost(Subscription subscription, Object event) &#123;
    synchronized (pendingPostPool) &#123;
        int size = pendingPostPool.size();
        if (size &gt; 0) &#123;
            //从尾部取出后填充并返回
            PendingPost pendingPost = pendingPostPool.remove(size - 1);
            pendingPost.event = event;
            pendingPost.subscription = subscription;
            pendingPost.next = null;
            return pendingPost;
        &#125;
    &#125;
    //否则新建一个返回
    return new PendingPost(event, subscription);
&#125;

static void releasePendingPost(PendingPost pendingPost) &#123;
    pendingPost.event = null;
    pendingPost.subscription = null;
    pendingPost.next = null;
    synchronized (pendingPostPool) &#123;
        //释放后放入池中
        // Don&#39;t let the pool grow indefinitely
        if (pendingPostPool.size() &lt; 10000) &#123;
            pendingPostPool.add(pendingPost);
        &#125;
    &#125;
&#125;
</code></pre>
<p>}</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">我们回过头看mainThreadPoster，当我们post一个事件到mainThreadPoster的时候，会触发向Handler 发送消息，收到消息后会在handleMessage不断循环调用invokeScriber.直到队列中的PandingPost处理完，或者处理事件超过设定的最大事件处理时间。整个流程如下所示：</span><br><span class="line">!<span class="selector-attr">[]</span>(/开源代码分析之EventBus/mainposter.png)</span><br><span class="line"></span><br><span class="line">接着我们看下BackgroundPoster，这里会从线程池中获取一个线程，然后调用<span class="built_in">execute</span>(this) 触发BackgroundPoster的run方法，在run方法中会从PendingPostQueue中不断取出PendingPost调用invokeSubscriber</span><br></pre></td></tr></table></figure>
<p> final class BackgroundPoster implements Runnable {</p>
<pre><code>//..................
public void enqueue(Subscription subscription, Object event) &#123;
    //从池中获取一个可复用的PendingPost
    PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event);
    synchronized (this) &#123;
        //将其添加到队列中
        queue.enqueue(pendingPost);
        if (!executorRunning) &#123;
            executorRunning = true;
            //将线程池设置为阻塞状态
            eventBus.getExecutorService().execute(this);
        &#125;
    &#125;
&#125;

@Override
public void run() &#123;
    try &#123;
        try &#123;
            //这里会不断从队列中获取可执行的，一直执行直到队列为空的时候退出。
            while (true) &#123;
                PendingPost pendingPost = queue.poll(1000);
                if (pendingPost == null) &#123;
                    synchronized (this) &#123;
                        // Check again, this time in synchronized
                        pendingPost = queue.poll();
                        if (pendingPost == null) &#123;
                            executorRunning = false;
                            return;
                        &#125;
                    &#125;
                &#125;
                eventBus.invokeSubscriber(pendingPost);
            &#125;
        &#125; catch (InterruptedException e) &#123;
            Log.w(&quot;Event&quot;, Thread.currentThread().getName() + &quot; was interruppted&quot;, e);
        &#125;
    &#125; finally &#123;
        executorRunning = false;
    &#125;
&#125;
</code></pre>
<p>}<br> <figure class="highlight arcade"><table><tr><td class="code"><pre><span class="line">![](<span class="regexp">/开源代码分析之EventBus/</span>background.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> 最后我们再看AsyncPoster：</span><br><span class="line"> 整个大体的结构和backgroundPoster很相似，但是它们之间的区别在于，AsyncPoster每次会从线程池中获取一个线程来执行，而backgroundPoster会在同一个现场中完成。</span><br></pre></td></tr></table></figure><br> class AsyncPoster implements Runnable {</p>
<pre><code>//............
public void enqueue(Subscription subscription, Object event) &#123;
    //从池中取出一个可复用的PendingPost对象
    PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event);
    //插入到队列中
    queue.enqueue(pendingPost);
    //调用线程池从线程池中取出一个运行
    eventBus.getExecutorService().execute(this);
&#125;

@Override
public void run() &#123;
    //取出队列中的第一个
    PendingPost pendingPost = queue.poll();
    if(pendingPost == null) &#123;
        throw new IllegalStateException(&quot;No pending post available&quot;);
    &#125;
    //出发订阅者订阅方法
    eventBus.invokeSubscriber(pendingPost);
&#125;
</code></pre>
<p>}</p>
<pre><code>
![](/开源代码分析之EventBus/async.png)

到此整个EventBus的源码分析结束：
老规矩最后以一个图来总结整个流程：
首先我们需要先通过register来订阅某些事件，在调用register的时候，SubscriberFinder从订阅类中找出所有的订阅处理方法，并将其挂接在事件分发中心EventBus的subscriptionsByEventType列表中，如果有事件触发那么就会将事件发送到事件分发中心，事件分发中心就会从subscriptionsByEventType列表中查找订阅者方法。然后根据对应的threadMode在不同的poster中调用invokeScriber来执行订阅者方法。
![](/开源代码分析之EventBus/final.png)






















</code></pre>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/%E5%BC%80%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/">开源代码分析</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/开源代码分析/">开源代码分析</a>
  </div>

</div>



<div class="comments-count">
	
	  	<span></span>
		<a href="/2017/05/26/开源代码分析之EventBus/#comments" class="ds-thread-count comments-count-link" data-thread-key="2017/05/26/开源代码分析之EventBus/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/05/02/开源代码分析之Butterknife/" title="开源代码分析之Butterknife" itemprop="url">开源代码分析之Butterknife</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Edgar" target="_blank" itemprop="author">Edgar</a>
		
  <p class="article-time">
    <time datetime="2017-05-02T14:08:50.000Z" itemprop="datePublished"> Published 2017-05-02</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>作为Android应用开发工程师估计没有人没听过Butterknife吧，我们可以借助它来简化view的查找过程以及通过注释将监听器绑定到事件响应方法上，这样可以减少很多代码量。对于Butterknife的用法在之前的博客中已经做了相应的介绍，这部分主要是分析Butterknife的源码，在之后的博文中还会对编译时注解解析器的实现做对应的介绍，如果想要对这部分内容有比较深入的了解，可以看下 《Java 进阶系列之注解》 以及《一步一步编写编译时注解框架》以及该篇博客。</p>
<p>好了言归正传，我们在介绍之前看下Butterknife 的工作原理：<br>在没有Butterknife的情况下我们用的是 Android 原生的API方法findViewById,而有了Butterknife后我们就可以直接使用@BindView(R.id.text) , 但是如果仔细看过源码的同学，会发现到最后还是调用findViewById，只不过这个是编译时注解框架帮我们生成了对应的代码，换句话说Butterknife以带有注解的源码文件作为javac编译器输入，在编译的时候会调用注解解析工具，对这些源码中的注解进行解析，解析后再通过代码生成工具来产生对应的源码文件，最后将我们自己的源码文件和注解解析工具产生的源码一同作为编译器输入进行编译。</p>
<p>ok 了解了整个原理我们就可以进行深入研究了。</p>
<p>我们将分成两大部分进行分析：</p>
<ul>
<li>绑定View以及事件</li>
<li>注解解析器</li>
</ul>
<h4 id="项目结构-："><a href="#项目结构-：" class="headerlink" title="[项目结构]："></a>[项目结构]：</h4><p><img src="/2017/05/02/%E5%BC%80%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BButterknife/image002.png"></p>
<h4 id="绑定过程-："><a href="#绑定过程-：" class="headerlink" title="[绑定过程]："></a>[绑定过程]：</h4><p>在绑定实用的是bind方法，bing方法实现如下，它的实现十分简单，但是在介绍bind时候，必须要先大概知道什么是target，什么是source，简单讲target就是一个实体，它承载着source，目前butterknife支持的target 包括activity，dialog，以及view。source就是我们实际要查找控件的地方。也就是findViewById 应用的对象。下面是以activity为target，所以对应的source就是对应activity的DecorView.</p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="meta">@NonNull</span> <span class="meta">@UiThread</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function">Unbinder <span class="title">bind</span><span class="params">(@NonNull Activity <span class="keyword">target</span>)</span> </span>&#123;</span><br><span class="line">  View sourceView = <span class="keyword">target</span>.getWindow().getDecorView();</span><br><span class="line">  <span class="function"><span class="keyword">return</span> <span class="title">createBinding</span><span class="params">(<span class="keyword">target</span>, sourceView)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着我们来看下createBinding方法，在方法开始的时候会使用target的class对象来获取对应的ViewBinding的构造方法，target的ViewBinding对象是由ButterknifeProcessor生成的，这个会在后面介绍ButterknifeProcessor的时候进行详细展开介绍。获取到对应的ViewBinding对象后调用该对象的构造方法并返回。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="title class_">Unbinder</span> <span class="title function_">createBinding</span>(<span class="params"><span class="meta">@NonNull</span> <span class="built_in">Object</span> target, <span class="meta">@NonNull</span> View source</span>) &#123;</span><br><span class="line">    <span class="comment">//获取target的Class对象，比如 XXXActivity.class</span></span><br><span class="line">    <span class="title class_">Class</span>&lt;?&gt; targetClass = target.<span class="title function_">getClass</span>();</span><br><span class="line">    <span class="comment">//获取targetClass对应ViewBinding的构造方法</span></span><br><span class="line">    <span class="title class_">Constructor</span>&lt;? <span class="keyword">extends</span> <span class="title class_">Unbinder</span>&gt; constructor = <span class="title function_">findBindingConstructorForClass</span>(targetClass);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (constructor == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Unbinder</span>.<span class="property">EMPTY</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这样一来，ButterKnife.bind(this)传递进去的MainActivity会通过反射生成MainActivity_ViewBinding实例。</span></span><br><span class="line">    <span class="comment">//在这个实例的构造函数内，进行findViewById、setOnclickListener等操作</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">  </span><br><span class="line">      <span class="keyword">return</span> constructor.<span class="title function_">newInstance</span>(target, source);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (<span class="title class_">IllegalAccessException</span> e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Unable to invoke &quot;</span> + constructor, e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (<span class="title class_">InstantiationException</span> e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Unable to invoke &quot;</span> + constructor, e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (<span class="title class_">InvocationTargetException</span> e) &#123;</span><br><span class="line">      <span class="title class_">Throwable</span> cause = e.<span class="title function_">getCause</span>();</span><br><span class="line">      <span class="keyword">if</span> (cause <span class="keyword">instanceof</span> <span class="title class_">RuntimeException</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> (<span class="title class_">RuntimeException</span>) cause;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (cause <span class="keyword">instanceof</span> <span class="title class_">Error</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> (<span class="title class_">Error</span>) cause;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Unable to create binding instance.&quot;</span>, cause);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>findBindingConstructorForClass 的作用就是加载对应targetClass的ViewBinding对象的构造方法：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">@Nullable @CheckResult @UiThread</span><br><span class="line"><span class="keyword">private</span> static Constructor&lt;? extends Unbinder&gt; find<span class="constructor">BindingConstructorForClass(Class&lt;?&gt; <span class="params">cls</span>)</span> &#123;</span><br><span class="line">  <span class="comment">//首先将传入XXXXActivity 类对象 作为参数尝试从缓存中获取通过JavaPoet产生的ViewBinding的构造方法</span></span><br><span class="line">  <span class="comment">//内存缓存BINDINGS 的组成是以targetClass为key，targetClass ViewBinding 构造方法为value的一个Map</span></span><br><span class="line">  Constructor&lt;? extends Unbinder&gt; bindingCtor = <span class="module-access"><span class="module"><span class="identifier">BINDINGS</span>.</span></span>get(cls);</span><br><span class="line">  <span class="keyword">if</span> (bindingCtor != null) &#123;</span><br><span class="line">    <span class="keyword">if</span> (debug) <span class="module-access"><span class="module"><span class="identifier">Log</span>.</span></span>d(TAG, <span class="string">&quot;HIT: Cached in binding map.&quot;</span>);</span><br><span class="line">    return bindingCtor;</span><br><span class="line">  &#125;</span><br><span class="line">  String clsName = cls.get<span class="constructor">Name()</span>;</span><br><span class="line">  <span class="comment">//由于Butterknife 不能用于注释android以及java这些标准sdk的类所以先进行这种类型的过滤</span></span><br><span class="line">  <span class="keyword">if</span> (clsName.starts<span class="constructor">With(<span class="string">&quot;android.&quot;</span>)</span><span class="operator"> || </span>clsName.starts<span class="constructor">With(<span class="string">&quot;java.&quot;</span>)</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (debug) <span class="module-access"><span class="module"><span class="identifier">Log</span>.</span></span>d(TAG, <span class="string">&quot;MISS: Reached framework class. Abandoning search.&quot;</span>);</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//使用类加载器加载在编译阶段由JavaPoet生成的XXXX_ViewBinding类对象</span></span><br><span class="line">    Class&lt;?&gt; bindingClass = cls.get<span class="constructor">ClassLoader()</span>.load<span class="constructor">Class(<span class="params">clsName</span> + <span class="string">&quot;_ViewBinding&quot;</span>)</span>;</span><br><span class="line">    <span class="comment">//获取对应的构造方法类，并且会将得到的Constructor缓存起来，避免反射的性能问题。</span></span><br><span class="line">    bindingCtor = (Constructor&lt;? extends Unbinder&gt;) bindingClass.get<span class="constructor">Constructor(<span class="params">cls</span>, View.<span class="params">class</span>)</span>;</span><br><span class="line">    <span class="keyword">if</span> (debug) <span class="module-access"><span class="module"><span class="identifier">Log</span>.</span></span>d(TAG, <span class="string">&quot;HIT: Loaded binding class and constructor.&quot;</span>);</span><br><span class="line">  &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">    <span class="comment">//如果没有找到那么找它对应的父类ViewBinding的构造方法</span></span><br><span class="line">    <span class="keyword">if</span> (debug) <span class="module-access"><span class="module"><span class="identifier">Log</span>.</span></span>d(TAG, <span class="string">&quot;Not found. Trying superclass &quot;</span> + cls.get<span class="constructor">Superclass()</span>.get<span class="constructor">Name()</span>);</span><br><span class="line">    bindingCtor = find<span class="constructor">BindingConstructorForClass(<span class="params">cls</span>.<span class="params">getSuperclass</span>()</span>);</span><br><span class="line">  &#125; catch (NoSuchMethodException e) &#123;</span><br><span class="line">    throw <span class="keyword">new</span> <span class="constructor">RuntimeException(<span class="string">&quot;Unable to find binding constructor for &quot;</span> + <span class="params">clsName</span>, <span class="params">e</span>)</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//将其添加到缓存中,后续使用的时候就不需要进行再次使用反射了从而加快了效率</span></span><br><span class="line">  <span class="module-access"><span class="module"><span class="identifier">BINDINGS</span>.</span></span>put(cls, bindingCtor);</span><br><span class="line">  return bindingCtor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了提高整体性能，这里使用了BINDINGS这个Map作为内存缓存。BINDINGS的定义如下：</p>
<figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Map&lt;<span class="keyword">Class</span>&lt;?&gt;, <span class="keyword">Constructor</span>&lt;? <span class="title function_">extends</span> <span class="title function_">Unbinder</span>&gt;&gt; <span class="title function_">BINDINGS</span> = <span class="title function_">new</span> <span class="title function_">LinkedHashMap</span>&lt;&gt;<span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<p>它的键值为我们的target 的类对象，我们以MainActivity为例子，那么key为MainActivity.class 对应的值呢？就是MainActivity_ViewBinding的构造方法，这个构造方法只有一个参数（View）.<br>这个阶段的整个过程如下：<br>拿着target类对象到BINDINGS缓存中去匹配，看下是否有缓存，如果有缓存那么使用缓存，如果没有那么就获取JavaPoet产生的MainActivity_ViewBinding(View view)的构造方法，并添加到缓冲中，供后续使用，为啥要缓存？<br>因为这里获取MainActivity_ViewBinding的构造方法使用的是反射的方式，对性能有所影响，使用缓存可以减少反射的使用次数，但是这里有一个疑问就是会不会因为Butterknife的大量使用从而导致缓存占用很大的空间，这个问题又是如何克服的？我们带着这个问题继续。获取到构造方法后我们new出一个实例对象，这里可以看出 MainActivity_ViewBinding.java继承的是Unbinder，而Unbinder中的unbind方法有可能就是处理缓存清除的工作。<br>我们看下Butterknife sample例子中产生的一个代码：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public <span class="keyword">class</span> G_ViewBinding&lt;T extends G&gt; extends E_ViewBinding&lt;T&gt; &#123;</span><br><span class="line">  <span class="keyword">private</span> View view16908290;</span><br><span class="line"></span><br><span class="line">  @UiThread</span><br><span class="line">  public <span class="constructor">G_ViewBinding(<span class="params">final</span> T <span class="params">target</span>, View <span class="params">source</span>)</span> &#123;</span><br><span class="line">    super(target, source);</span><br><span class="line"></span><br><span class="line">    View view;</span><br><span class="line">    target.button2 = <span class="module-access"><span class="module"><span class="identifier">Utils</span>.</span></span>find<span class="constructor">RequiredView(<span class="params">source</span>, <span class="params">android</span>.R.<span class="params">id</span>.<span class="params">button2</span>, <span class="string">&quot;field &#x27;button2&#x27;&quot;</span>)</span>;</span><br><span class="line">    view = <span class="module-access"><span class="module"><span class="identifier">Utils</span>.</span></span>find<span class="constructor">RequiredView(<span class="params">source</span>, <span class="params">android</span>.R.<span class="params">id</span>.<span class="params">content</span>, <span class="string">&quot;method &#x27;onClick&#x27;&quot;</span>)</span>;</span><br><span class="line">    view16908290 = view;</span><br><span class="line">    view.set<span class="constructor">OnClickListener(<span class="params">new</span> DebouncingOnClickListener()</span> &#123;</span><br><span class="line">      @Override</span><br><span class="line">      public void <span class="keyword">do</span><span class="constructor">Click(View <span class="params">p0</span>)</span> &#123;</span><br><span class="line">        target.on<span class="constructor">Click()</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    Context context = source.get<span class="constructor">Context()</span>;</span><br><span class="line">    Resources res = context.get<span class="constructor">Resources()</span>;</span><br><span class="line">    Resources.Theme theme = context.get<span class="constructor">Theme()</span>;</span><br><span class="line">    target.grayColor = <span class="module-access"><span class="module"><span class="identifier">Utils</span>.</span></span>get<span class="constructor">Color(<span class="params">res</span>, <span class="params">theme</span>, <span class="params">android</span>.R.<span class="params">color</span>.<span class="params">darker_gray</span>)</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void unbind<span class="literal">()</span> &#123;</span><br><span class="line">    T target = this.target;</span><br><span class="line">    super.unbind<span class="literal">()</span>;</span><br><span class="line">    target.button2 = null;</span><br><span class="line">    view16908290.set<span class="constructor">OnClickListener(<span class="params">null</span>)</span>;</span><br><span class="line">    view16908290 = null;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们先不看上面的具体代码，只看unbind方法。它会递归地将对应的view对象设置成null，从而在gc的时候释放掉资源。</p>
<p>从上面代码看整个butterknife包的源码是十分简单的，最重要的在于xxxx_ViewBinding.class的生成，这就需要对butterknife-compiler包中的源码进行研究了，我们所有的注解都在butterknife-annotations这个包中，我们这里只以BindView注解作为分析对象：<br>具体的注解相关内容见《Java进阶之注解》 这篇博客。</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@Retention</span>(CLASS) <span class="variable">@Target</span>(FIELD)</span><br><span class="line">public <span class="variable">@interface</span> BindView &#123;</span><br><span class="line">  <span class="comment">/** View ID to which the field will be bound. */</span></span><br><span class="line">  <span class="variable">@IdRes</span> int value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面我们可以看出@BindView注解应用于属性定义中，并且只在源码级别以及class级别中存在，它的值为一个id类型的值。不允许其他类型的值作为参数。</p>
<h4 id="Butterknife注释解析器ButterknifeProcessor-："><a href="#Butterknife注释解析器ButterknifeProcessor-：" class="headerlink" title="[Butterknife注释解析器ButterknifeProcessor]："></a>[Butterknife注释解析器ButterknifeProcessor]：</h4><p>从上面一小结介绍可以看出Butterknife.java 中的工作很简单就是拿着targetClass找到对应的ViewBinding,至于ViewBinding怎么来的则是这一小结的介绍重点，在介绍ButterKnife注解解析器之前我们再次回顾下注解解析器在整个编译过程中的的作用：<br>我们知道Java使用Javac处理编译过程的，在Java的编译时期,Javac会先调用java注解处理器来进行处理。因此我们可以自定义注解处理器来做一些处理。注解处理器通常以java源码或者已编译的字节码作为输入，然后生成一些源码文件作为输出。在这个过程可以在已有的代码上添加一些方法，来帮我们做一些有用的事情。这些生成的 java 文件跟其他手动编写的java源码一样，会被 javac 编译。编译时解析是注解强大的地方之一。我们可以利用它在编译时帮你生成一些代码逻辑，避免了运行时利用反射解析所带来的性能开销。</p>
<p>下面是ButterKnifeProcessor的大体结构：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AutoService</span>(<span class="title class_">Processor</span>.<span class="property">class</span>)</span><br><span class="line"><span class="comment">//要解析编译时注释，可以通过创建一个继承自AbstractProcessor的注解处理器，然后实现相关方法。</span></span><br><span class="line"><span class="keyword">public</span> final <span class="keyword">class</span> <span class="title class_">ButterKnifeProcessor</span> <span class="keyword">extends</span> <span class="title class_ inherited__">AbstractProcessor</span> &#123;</span><br><span class="line">  <span class="comment">//指定支持的 java 版本，通常返回 SourceVersion.latestSupported()</span></span><br><span class="line">  <span class="meta">@Override</span> <span class="keyword">public</span> <span class="title class_">SourceVersion</span> <span class="title function_">getSupportedSourceVersion</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">SourceVersion</span>.<span class="title function_">latestSupported</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span> <span class="keyword">public</span> <span class="title class_">Set</span>&lt;<span class="title class_">String</span>&gt; <span class="title function_">getSupportedOptions</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Collections</span>.<span class="title function_">singleton</span>(<span class="variable constant_">OPTION_SDK_INT</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//init方法是在Processor创建时被javac调用并执行初始化操作。</span></span><br><span class="line">  <span class="comment">//做一些初始化操作，可以在这里获取Filer，Elements等辅助类</span></span><br><span class="line">  <span class="comment">//@param processingEnv 提供一系列的注解处理工具。</span></span><br><span class="line">  <span class="keyword">public</span> synchronized <span class="built_in">void</span> <span class="title function_">init</span>(<span class="params">ProcessingEnvironment env</span>) &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//注解处理器要处理的注解类型,值为完全限定名（就是带所在包名和路径的类全名） **/</span></span><br><span class="line">  <span class="meta">@Override</span> <span class="keyword">public</span> <span class="title class_">Set</span>&lt;<span class="title class_">String</span>&gt; <span class="title function_">getSupportedAnnotationTypes</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title class_">Set</span>&lt;<span class="title class_">String</span>&gt; types = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="title class_">Class</span>&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt; annotation : <span class="title function_">getSupportedAnnotations</span>()) &#123;</span><br><span class="line">      <span class="comment">//将支持的注释类型添加到types集合中</span></span><br><span class="line">      types.<span class="title function_">add</span>(annotation.<span class="title function_">getCanonicalName</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> types;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//注解处理需要执行一次或者多次。每次执行时，处理器方法被调用，并且传入了当前要处理的注解类型。可以在这个方法中扫描和处理注解，并生成Java代码。</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="built_in">boolean</span> <span class="title function_">process</span>(<span class="params"><span class="built_in">Set</span>&lt;? <span class="keyword">extends</span> TypeElement&gt; elements, RoundEnvironment env</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面我们就顺着这个框架对ButterKnifeProcessor进行分析：<br>我们首先看下<br>@AutoService(Processor.class)的作用：一旦在Processor类上加上注解@AutoService(Processor.class)，它自动帮你将这个类添加到META-INF&#x2F;service&#x2F;javax.naaotation.processing.Processor下Java的ServiceLoader会自己去找到这个类并进行编译处理。<br>接着是init方法：<br>init方法是在Processor创建时被javac调用并执行初始化操作。通过ProcessingEnvironment参数我们可以获得如下元素：<br>Messager ：用于打印Log,在编译的时候会在Message窗口中输出。<br>Elements ：用于处理编程元素的辅助类<br>Filer    ：用于注解处理器生成新文件的<br>Locale   ：用于获取时区信息的类<br>Types    ：用于操作类型的辅助方法<br>其中最常用的就是Elements以及Types和打印Log用到的Messager.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ProcessingEnvironment env)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.init(env);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取sdk 版本</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">sdk</span> <span class="operator">=</span> env</span><br><span class="line">.getOptions().get(OPTION_SDK_INT);</span><br><span class="line">    <span class="keyword">if</span> (sdk != <span class="literal">null</span>) &#123;</span><br><span class="line">  </span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.<span class="type">sd</span></span><br><span class="line">    <span class="variable">k</span> <span class="operator">=</span> Integer.parseInt(sdk);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">        env.getMessager().printMessage(Kind.WARNING, <span class="string">&quot;Unable to parse supplied minSdk option &#x27;&quot;</span> + sdk + <span class="string">&quot;&#x27;. Falling back to API 1 support.&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    elementUtils = env.getElementUtils();</span><br><span class="line">    typeUtils = env.getTypeUtils();</span><br><span class="line">    filer = env.getFiler();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      trees = Trees.instance(processingEnv);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException ignored) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>接着就是整个注解解析器的关键方法process，每次执行时，处理器方法被调用，并且传入了当前要处理的注解类型。可以在这个方法中扫描和处理注解，并生成Java代码。我们看下面的process方法，在这个方法中主要完成了两项任务，一个就是调用findAndParseTargets来获取bindingMap<br>bindingMap 是什么呢？它其实对应的是每个有调用bind绑定的target，举个例子来说，我们在MainActicity的onCreate方法调用了Butterknife的bind方法，那么ButterknifeProcessor就会产生一个对应的BindingSet，也就是说有多少个bind，bindingMap里面就有多少个BindingSet。然后再使用Javapost来为每个BingSet生成一个_ViewBinding.class.</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">boolean</span> <span class="title function_">process</span>(<span class="params"><span class="built_in">Set</span>&lt;? <span class="keyword">extends</span> TypeElement&gt; elements, RoundEnvironment env</span>) &#123;</span><br><span class="line">  <span class="title class_">Map</span>&lt;<span class="title class_">TypeElement</span>, <span class="title class_">BindingSet</span>&gt; bindingMap = <span class="title function_">findAndParseTargets</span>(env);</span><br><span class="line">  <span class="keyword">for</span> (<span class="title class_">Map</span>.<span class="property">Entry</span>&lt;<span class="title class_">TypeElement</span>, <span class="title class_">BindingSet</span>&gt; entry : bindingMap.<span class="title function_">entrySet</span>()) &#123;</span><br><span class="line">    <span class="title class_">TypeElement</span> typeElement = entry.</span><br><span class="line"><span class="title function_">getKey</span>();</span><br><span class="line">    <span class="title class_">BindingSet</span> binding = entry.<span class="title function_">getValue</span>();</span><br><span class="line">    <span class="title class_">JavaFile</span> javaFile = binding.<span class="title function_">brewJava</span>(sdk);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      javaFile.<span class="title function_">writeTo</span>(filer);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (<span class="title class_">IOExceptio</span></span><br><span class="line">n e) &#123;</span><br><span class="line">      <span class="title function_">error</span>(typeElement, </span><br><span class="line">  <span class="string">&quot;Unable to write binding for type %s: %s&quot;</span>, typeElement, e.<span class="title function_">getMessage</span>());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们先来看下findAndParseTarets，它的任务分成如下几个部分：</p>
<ol>
<li>调用scanForRClasses  分别通过RClassScanner IdScanner VarScanner 解析R 文件并将解析结果存放到symbols 中，至于symbols的作用是什么我们后面介绍</li>
<li>调用一系列parseXXXX方法解析各种注解</li>
<li>调用findAndParseListener 来解析各种事件注解</li>
<li>整理BindingSet的继承关系<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Map&lt;TypeElement, BindingSet&gt; find<span class="constructor">AndParseTargets(RoundEnvironment <span class="params">env</span>)</span> &#123;</span><br><span class="line">  Map&lt;TypeElement, BindingSet.Builder&gt; builderMap = <span class="keyword">new</span> LinkedHashMap&lt;&gt;<span class="literal">()</span>;</span><br><span class="line">  Set&lt;TypeElement&gt; erasedTargetNames = <span class="keyword">new</span> LinkedHashSet&lt;&gt;<span class="literal">()</span>;</span><br><span class="line">  <span class="comment">//建立view与R的id的关系</span></span><br><span class="line">  <span class="comment">//比如在Butterknife 编译出来的代码MainActivity_ViewBinding里持有一个全局变量view8131034512，</span></span><br><span class="line">  <span class="comment">// 这个其实就是MainActivity的tvTitle，后面的8131034512就是对应在R文件的id。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//分别通过RClassScanner IdScanner VarScanner 解析R 文件并将解析结果存放到symbols 中</span></span><br><span class="line">  scan<span class="constructor">ForRClasses(<span class="params">env</span>)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Process each @BindView element.</span></span><br><span class="line">  <span class="keyword">for</span> (Element element : env.get<span class="constructor">ElementsAnnotatedWith(BindView.<span class="params">class</span>)</span>) &#123;</span><br><span class="line">    <span class="comment">// we don&#x27;t SuperficialValidation.validateElement(element)</span></span><br><span class="line">    <span class="comment">// so that an unresolved View type can be generated by later processing rounds</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      parse<span class="constructor">BindView(<span class="params">element</span>, <span class="params">builderMap</span>, <span class="params">erasedTargetNames</span>)</span>;</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">      log<span class="constructor">ParsingError(<span class="params">element</span>, BindView.<span class="params">class</span>, <span class="params">e</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Process each annotation that corresponds to a listener.</span></span><br><span class="line">  <span class="keyword">for</span> (Class&lt;? extends Annotation&gt; listener : LISTENERS) &#123;</span><br><span class="line">    find<span class="constructor">AndParseListener(<span class="params">env</span>, <span class="params">listener</span>, <span class="params">builderMap</span>, <span class="params">erasedTargetNames</span>)</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  Deque&lt;Map.Entry&lt;TypeElement, BindingSet.Builder&gt;&gt; entries = <span class="keyword">new</span> ArrayDeque&lt;&gt;(builderMap.entry<span class="constructor">Set()</span>);</span><br><span class="line">  Map&lt;TypeElement, BindingSet&gt; bindingMap = <span class="keyword">new</span> LinkedHashMap&lt;&gt;<span class="literal">()</span>;</span><br><span class="line">  <span class="keyword">while</span> (!entries.is<span class="constructor">Empty()</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取出第一个元素</span></span><br><span class="line">    Map.Entry&lt;TypeElement, BindingSet.Builder&gt; entry = entries.remove<span class="constructor">First()</span>;</span><br><span class="line">    TypeElement <span class="keyword">type</span> = entry.get<span class="constructor">Key()</span>;</span><br><span class="line">    BindingSet.Builder builder = entry.get<span class="constructor">Value()</span>;</span><br><span class="line"></span><br><span class="line">    TypeElement parentType = find<span class="constructor">ParentType(<span class="params">type</span>, <span class="params">erasedTargetNames</span>)</span>;</span><br><span class="line">    <span class="keyword">if</span> (parentType<span class="operator"> == </span>null) &#123;</span><br><span class="line">      bindin</span><br><span class="line">  gMap.put(<span class="keyword">type</span>, builder.build<span class="literal">()</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      BindingSet parentBinding = bindingMap.get(parentType);</span><br><span class="line">      <span class="keyword">if</span> (parentBinding != null) &#123;</span><br><span class="line">        builder.set<span class="constructor">Parent(<span class="params">parentBinding</span>)</span>;</span><br><span class="line">        bindingMap.put(<span class="keyword">type</span>, builder.build<span class="literal">()</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Has a superclass binding but we haven&#x27;t built it yet. Re-enqueue for later.</span></span><br><span class="line">        entries.add<span class="constructor">Last(<span class="params">entry</span>)</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return bindingMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>首先看下scanForRClasses：<br>它的作用是解析R文件将获取到的数据存入symbols，用于作为后续标识每个元素的key。R 元素中的每一个变量对应symols中的一个元素。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> void scan<span class="constructor">ForRClasses(RoundEnvironment <span class="params">env</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (trees<span class="operator"> == </span>null) return;</span><br><span class="line">  RClassScanner scanner = <span class="keyword">new</span> <span class="constructor">RClassScanner()</span>;</span><br><span class="line">  <span class="keyword">for</span> (Class&lt;? extends Annotation&gt; annotation : get<span class="constructor">SupportedAnnotations()</span>) &#123;</span><br><span class="line">    <span class="comment">//遍历全部支持的注解，找出使用给定注释类型注释的元素 比如这里可以返回全部使用@BindView注解的元素</span></span><br><span class="line">    <span class="keyword">for</span> (Element element : env.get<span class="constructor">ElementsAnnotatedWith(<span class="params">annotation</span>)</span>) &#123;</span><br><span class="line">      JCTree tree = (JCTree) trees.get<span class="constructor">Tree(<span class="params">element</span>, <span class="params">getMirror</span>(<span class="params">element</span>, <span class="params">annotation</span>)</span>);</span><br><span class="line">      <span class="keyword">if</span> (tree != null) &#123;</span><br><span class="line">        <span class="comment">//获取对应元素（使用BindView元素）的包名的完全限定名称</span></span><br><span class="line">        <span class="comment">//首先根据element获取到包名，再利用RClassScanner寻找到R文件，在R文件里利用IdScanner寻找到内部类id，</span></span><br><span class="line">        <span class="comment">//在id类里利用VarScanner寻找到tvTitle的id。最后就可以得到view2131034112。</span></span><br><span class="line">        String respectivePackageName = elementUtils.get<span class="constructor">PackageOf(<span class="params">element</span>)</span>.get<span class="constructor">QualifiedName()</span>.<span class="keyword">to</span><span class="constructor">String()</span>;</span><br><span class="line">        <span class="comment">//扫描指定的包</span></span><br><span class="line">        scanner.set<span class="constructor">CurrentPackageName(<span class="params">respectivePackageName</span>)</span>;</span><br><span class="line">        tree.accept(scanner);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//包名  +  R Class</span></span><br><span class="line">  <span class="keyword">for</span> (Map.Entry&lt;String, Set&lt;String&gt;&gt; packageNameToRClassSet : scanner.get<span class="constructor">RClasses()</span>.entry<span class="constructor">Set()</span>) &#123;</span><br><span class="line">    String respectivePackageName = packageNameToRClassSet.get<span class="constructor">Key()</span>;</span><br><span class="line">    <span class="comment">//获取对应的R类</span></span><br><span class="line">    <span class="keyword">for</span> (String rClass : packageNameToRClassSet.get<span class="constructor">Value()</span>) &#123;</span><br><span class="line">      <span class="comment">//解析R类</span></span><br><span class="line">      <span class="comment">//respectivePackageName 元素的包名</span></span><br><span class="line">      parse<span class="constructor">RClass(<span class="params">respectivePackageName</span><span class="operator">/</span><span class="operator">*</span><span class="params">key</span><span class="operator">*</span><span class="operator">/</span>, <span class="params">rClass</span><span class="operator">/</span><span class="operator">*</span><span class="params">value</span><span class="operator">*</span><span class="operator">/</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>查找R文件使用的是RClassScanner,它是一个TreeScanner，它会找到整个项目的R文件: </p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">RClassScanner</span> <span class="keyword">extends</span> <span class="title class_ inherited__">TreeScanner</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> final <span class="title class_">Map</span>&lt;<span class="title class_">String</span>, <span class="title class_">Set</span>&lt;<span class="title class_">String</span>&gt;&gt; rClasses = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;();</span><br><span class="line">  <span class="keyword">private</span> <span class="title class_">String</span> currentPackageName;</span><br><span class="line">  <span class="comment">//数据结构 包名 + RC 类名集合</span></span><br><span class="line">  <span class="comment">//rClasses  ---| String 包名(currentPackageName) + RC 类名集合(rClassSet) Set&lt;String&gt; -&gt; symbol.getEnclosingElement().getEnclosingElement().enclClass().className()</span></span><br><span class="line">  <span class="comment">//             | String 包名(currentPackageName) + RC 类名集合(rClassSet) Set&lt;String&gt; -&gt; symbol.getEnclosingElement().getEnclosingElement().enclClass().className()</span></span><br><span class="line">  <span class="comment">//             | String 包名(currentPackageName) + RC 类名集合(rClassSet) Set&lt;String&gt; -&gt; symbol.getEnclosingElement().getEnclosingElement().enclClass().className()</span></span><br><span class="line">  <span class="comment">//             | String 包名(currentPackageName) + RC 类名集合(rClassSet) Set&lt;String&gt; -&gt; symbol.getEnclosingElement().getEnclosingElement().enclClass().className()</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">visitSelect</span>(<span class="params">JCTree.JCFieldAccess jcFieldAccess</span>) &#123;</span><br><span class="line">    <span class="title class_">Symbol</span> <span class="built_in">symbol</span> = jcFieldAccess.<span class="property">sym</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">symbol</span> != <span class="literal">null</span></span><br><span class="line">        &amp;&amp; <span class="built_in">symbol</span>.<span class="title function_">getEnclosingElement</span>() != <span class="literal">null</span></span><br><span class="line">        &amp;&amp; <span class="built_in">symbol</span>.<span class="title function_">getEnclosingElement</span>().<span class="title function_">getEnclosingElement</span>() != <span class="literal">null</span></span><br><span class="line">        &amp;&amp; <span class="built_in">symbol</span>.<span class="title function_">getEnclosingElement</span>().<span class="title function_">getEnclosingElement</span>().<span class="title function_">enclClass</span>() != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">//从缓存中获取对应的包名对应的 RClass 集合</span></span><br><span class="line">      <span class="title class_">Set</span>&lt;<span class="title class_">String</span>&gt; rClassSet = rClasses.<span class="title function_">get</span>(currentPackageName);</span><br><span class="line">      <span class="keyword">if</span> (rClassSet == <span class="literal">null</span>) &#123;</span><br><span class="line">        rClassSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        rClasses.<span class="title function_">put</span>(currentPackageName, rClassSet);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// getEnclosingElement 返回封装此元素（非严格意义上）的最里层元素。这里是对应的R Class 文件</span></span><br><span class="line">      rClassSet.<span class="title function_">add</span>(<span class="built_in">symbol</span>.<span class="title function_">getEnclosingElement</span>().<span class="title function_">getEnclosingElement</span>().<span class="title function_">enclClass</span>().<span class="title function_">className</span>());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 获取当前包的rClasses对象</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="title class_">Map</span>&lt;<span class="title class_">String</span>, <span class="title class_">Set</span>&lt;<span class="title class_">String</span>&gt;&gt; <span class="title function_">getRClasses</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> rClasses;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 设置当前扫描的包名</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> <span class="variable">respectivePackageName</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="built_in">void</span> <span class="title function_">setCurrentPackageName</span>(<span class="params"><span class="built_in">String</span> respectivePackageName</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">currentPackageName</span> = respectivePackageName;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在找到全部的R文件后在scanForRClass中会调用parseRClass对扫描到的R文件进行解析：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="built_in">void</span> <span class="title function_">parseRClass</span>(<span class="params"><span class="built_in">String</span> respectivePackageName, <span class="built_in">String</span> rClass</span>) &#123;</span><br><span class="line">    <span class="title class_">Element</span> element;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//对应的R元素</span></span><br><span class="line">      element = elementUtils.<span class="title function_">getTypeElement</span>(rClass);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (<span class="title class_">MirroredTypeException</span> mte) &#123;</span><br><span class="line">      element = typeUtils.<span class="title function_">asElement</span>(mte.<span class="title function_">getTypeMirror</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对应的R文件</span></span><br><span class="line">    <span class="title class_">JCTree</span> tree = (<span class="title class_">JCTree</span>) trees.<span class="title function_">getTree</span>(element);</span><br><span class="line">    <span class="keyword">if</span> (tree != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="title class_">IdScanner</span> idScanner = <span class="keyword">new</span> <span class="title class_">IdScanner</span>(symbols,</span><br><span class="line">              elementUtils.<span class="title function_">getPackageOf</span>(element).<span class="title function_">getQualifiedName</span>().<span class="title function_">toString</span>()<span class="comment">/*R class 全路径*/</span>,</span><br><span class="line">              respectivePackageName<span class="comment">/*目标元素的包名*/</span>);</span><br><span class="line">      tree.<span class="title function_">accept</span>(idScanner);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="title function_">parseCompiledR</span>(respectivePackageName, (<span class="title class_">TypeElement</span>) element);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>我们从上面代码中可以看到在parseRClass中会使用IdScanner 对当前扫描的R文件进行扫描：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> static <span class="class"><span class="keyword">class</span> <span class="title">IdScanner</span> <span class="keyword">extends</span> <span class="title">TreeScanner</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Map</span>&lt;<span class="type">QualifiedId</span>, <span class="type">Id</span>&gt; ids;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">String</span> rPackageName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">String</span> respectivePackageName;</span><br><span class="line"></span><br><span class="line">    <span class="type">IdScanner</span>(<span class="type">Map</span>&lt;<span class="type">QualifiedId</span>, <span class="type">Id</span>&gt; ids, <span class="type">String</span> rPackageName<span class="comment">/*R class 全路径*/</span>, <span class="type">String</span> respectivePackageName<span class="comment">/*对应的包名*/</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.ids = ids;</span><br><span class="line">      <span class="keyword">this</span>.rPackageName = rPackageName;</span><br><span class="line">      <span class="keyword">this</span>.respectivePackageName = respectivePackageName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    public void visitClassDef(<span class="type">JCTree</span>.<span class="type">JCClassDecl</span> jcClassDecl) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">JCTree</span> tree : jcClassDecl.defs) &#123;</span><br><span class="line">        <span class="comment">//每个指的是R 文件中的一个类 比如anim</span></span><br><span class="line">        <span class="keyword">if</span> (tree instanceof <span class="type">ClassTree</span>) &#123;</span><br><span class="line">          <span class="type">ClassTree</span> classTree = (<span class="type">ClassTree</span>) tree;</span><br><span class="line">          <span class="comment">//返回对应的类名比如 public static final class anim 返回的是 anim</span></span><br><span class="line">          <span class="type">String</span> className = classTree.getSimpleName().toString();</span><br><span class="line">          <span class="comment">//看下当前的类型是否在支持的范围内</span></span><br><span class="line">          <span class="keyword">if</span> (<span class="type">SUPPORTED_TYPES</span>.contains(className)) &#123;</span><br><span class="line">            <span class="comment">//获取到资源类型的全限定名 比如com.demo.example.R.anim</span></span><br><span class="line">            <span class="type">ClassName</span> rClassName = <span class="type">ClassName</span>.get(rPackageName, <span class="string">&quot;R&quot;</span>, className);</span><br><span class="line">            <span class="type">VarScanner</span> scanner = <span class="keyword">new</span> <span class="type">VarScanner</span>(ids, rClassName <span class="comment">/* 这里是某个资源类的全限定名*/</span>, respectivePackageName);</span><br><span class="line">            ((<span class="type">JCTree</span>) classTree).accept(scanner);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>在IdScanner 中会对R文件中的每个内部类进行扫描，判断当前的内部类是否是所支持的，如果是那么就调用VarScanner进行进一步扫描。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> static <span class="keyword">class</span> VarScanner extends TreeScanner &#123;</span><br><span class="line">   <span class="keyword">private</span> final Map&lt;QualifiedId, Id&gt; ids;</span><br><span class="line">   <span class="keyword">private</span> final ClassName className;</span><br><span class="line">   <span class="keyword">private</span> final String respectivePackageName;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="constructor">VarScanner(Map&lt;QualifiedId, Id&gt; <span class="params">ids</span>, ClassName <span class="params">className</span><span class="operator">/</span><span class="operator">*</span><span class="params">com</span>.<span class="params">demo</span>.<span class="params">example</span>.R.<span class="params">anim</span><span class="operator">*</span><span class="operator">/</span>, String <span class="params">respectivePackageName</span>)</span> &#123;</span><br><span class="line">     this.ids = ids;</span><br><span class="line">     this.className = className;</span><br><span class="line">     this.respectivePackageName = respectivePackageName;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   @Override public void visit<span class="constructor">VarDef(JCTree.JCVariableDecl <span class="params">jcVariableDecl</span>)</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (<span class="string">&quot;int&quot;</span>.equals(jcVariableDecl.get<span class="constructor">Type()</span>.<span class="keyword">to</span><span class="constructor">String()</span>)) &#123;</span><br><span class="line">       <span class="comment">//资源id</span></span><br><span class="line">       <span class="built_in">int</span> id = <span class="module-access"><span class="module"><span class="identifier">Integer</span>.</span></span>value<span class="constructor">Of(<span class="params">jcVariableDecl</span>.<span class="params">getInitializer</span>()</span>.<span class="keyword">to</span><span class="constructor">String()</span>);</span><br><span class="line">       <span class="comment">//资源名</span></span><br><span class="line">       String resourceName = jcVariableDecl.get<span class="constructor">Name()</span>.<span class="keyword">to</span><span class="constructor">String()</span>;</span><br><span class="line">       <span class="comment">// 元素所在包名，资源id</span></span><br><span class="line">       QualifiedId qualifiedId = <span class="keyword">new</span> <span class="constructor">QualifiedId(<span class="params">respectivePackageName</span>, <span class="params">id</span>)</span>;</span><br><span class="line">       <span class="comment">//[获取到资源类型的全限定名比如com.demo.example.R.anim]  [资源名abc_fade_in] [0x7f040000]</span></span><br><span class="line">       ids.put(qualifiedId, <span class="keyword">new</span> <span class="constructor">Id(<span class="params">id</span>, <span class="params">className</span>, <span class="params">resourceName</span>)</span>);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>VarScanner 也是一个TreeScanner，它的所用就是在R 文件内部类中扫描，并将扫描到的id 添加到symbos中。</p>
<p>介绍到这里我们做下简要，首先我们会通过RCScanner找到项目的R文件，再使用IdScanner对R文件中的内部类进行扫描，每个内部类对应一类资源，最后通过VarScanner对id进行扫描然后存入sybols这个map.</p>
<p>symbols定义如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Map</span>&lt;<span class="type">QualifiedId</span>, <span class="type">Id</span>&gt; symbols <span class="operator">=</span> new <span class="type">LinkedHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight brainfuck"><table><tr><td class="code"><pre><span class="line"><span class="comment">Key:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">QualifiedId</span> <span class="literal">---</span><span class="comment">|</span><span class="literal">---</span> <span class="comment">respectivePackageName 当前资源所在对包</span></span><br><span class="line">               <span class="comment">|</span><span class="literal">---</span> <span class="comment">id 当前资源id</span></span><br><span class="line"></span><br><span class="line"><span class="comment">Value</span>       <span class="literal">---</span><span class="comment">|</span><span class="literal">---</span> <span class="comment">id 当前资源id  比如 0x7f040000</span></span><br><span class="line">               <span class="comment">|</span><span class="literal">---</span><span class="comment"> className 获取到资源类型的全限定名 比如com</span><span class="string">.</span><span class="comment">demo</span><span class="string">.</span><span class="comment">example</span><span class="string">.</span><span class="comment">R</span><span class="string">.</span><span class="comment">anim</span></span><br><span class="line">               <span class="comment">|</span><span class="literal">---</span> <span class="comment">resourceName 资源名  比如 abc_fade_in</span></span><br></pre></td></tr></table></figure>


<p>介绍完scanForRClass我们继续了解下注解的解析过程：<br>在进行解析之前会先对注解所应用的对象做初步检查：</p>
<ul>
<li>验证对应的修饰符是否是static 或者 private ,注解是否正在修饰局部变量，是否处于私有类中，以及检查包名是否是在android以及java标准API包内，如果有上述的情况就返回false</li>
<li>获取使用该注解的元素对应类型是否继承自View</li>
</ul>
<p>如果校验无误，那么会先查询bingMap中是否已经有对应的BindingSet了，如果没有就创建一个并添加到bingMap中。如果有的话就完对应的BindingSet添加Field这些Field会在JavaPost创建对应源码文件的时候用于生成对应的成员变量。这个后面会进行详细介绍。<br>我们下面深入看两点：</p>
<ol>
<li>BindingSet是怎么创建的</li>
<li>addFeild是怎么添加的<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> void parse<span class="constructor">BindView(Element <span class="params">element</span>, Map&lt;TypeElement, BindingSet.Builder&gt; <span class="params">builderMap</span>, Set&lt;TypeElement&gt; <span class="params">erasedTargetNames</span>)</span> &#123;</span><br><span class="line">  TypeElement enclosingElement = (TypeElement) element.get<span class="constructor">EnclosingElement()</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//校验一:解析前初步校验</span></span><br><span class="line">  <span class="comment">//验证对应的修饰符是否是static 或者 private ,注解是否正在修饰局部变量，是否处于私有类中，以及检查包名是否是在android以及java标准API包内，如果有上述的情况就返回false</span></span><br><span class="line">  boolean hasError = is<span class="constructor">InaccessibleViaGeneratedCode(BindView.<span class="params">class</span>, <span class="string">&quot;fields&quot;</span>, <span class="params">element</span>)</span><span class="operator"> || </span>is<span class="constructor">BindingInWrongPackage(BindView.<span class="params">class</span>, <span class="params">element</span>)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//校验二:获取使用该注解的元素对应类型是否继承自View</span></span><br><span class="line">  TypeMirror elementType = element.<span class="keyword">as</span><span class="constructor">Type()</span>;</span><br><span class="line">  <span class="comment">// 是否是一个变量类型</span></span><br><span class="line">  <span class="keyword">if</span> (elementType.get<span class="constructor">Kind()</span><span class="operator"> == </span>TypeKind.TYPEVAR) &#123;</span><br><span class="line">    TypeVariable typeVariable = (TypeVariable) elementType;</span><br><span class="line">    <span class="comment">//获取它的父类</span></span><br><span class="line">    elementType = typeVariable.get<span class="constructor">UpperBound()</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  Name qualifiedName = enclosingElement.get<span class="constructor">QualifiedName()</span>;</span><br><span class="line">  Name simpleName = element.get<span class="constructor">SimpleName()</span>;</span><br><span class="line">  <span class="comment">//如果不是View类型并且不是接口那么就返回类型失败的错误</span></span><br><span class="line">  <span class="keyword">if</span> (!is<span class="constructor">SubtypeOfType(<span class="params">elementType</span>, VIEW_TYPE)</span><span class="operator"> &amp;&amp; </span>!is<span class="constructor">Interface(<span class="params">elementType</span>)</span>) &#123;</span><br><span class="line">    <span class="comment">//解析不了的类型</span></span><br><span class="line">    <span class="keyword">if</span> (elementType.get<span class="constructor">Kind()</span><span class="operator"> == </span>TypeKind.ERROR) &#123;</span><br><span class="line">      note(element, <span class="string">&quot;@%s field with unresolved type (%s) &quot;</span> + <span class="string">&quot;must elsewhere be generated as a View or interface. (%s.%s)&quot;</span>, <span class="module-access"><span class="module"><span class="identifier">BindView</span>.</span></span><span class="keyword">class</span>.get<span class="constructor">SimpleName()</span>, elementType, qualifiedName, simpleName);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//不是View的子类或者不是接口</span></span><br><span class="line">      error(element, <span class="string">&quot;@%s fields must extend from View or be an interface. (%s.%s)&quot;</span>, <span class="module-access"><span class="module"><span class="identifier">BindView</span>.</span></span><span class="keyword">class</span>.get<span class="constructor">SimpleName()</span>, qualifiedName, simpleName);</span><br><span class="line">      hasError = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//如果解析错误那么不继续解析</span></span><br><span class="line">  <span class="keyword">if</span> (hasError) &#123;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//获取BindView注解中的id值</span></span><br><span class="line">  <span class="built_in">int</span> id = element.get<span class="constructor">Annotation(BindView.<span class="params">class</span>)</span>.value<span class="literal">()</span>;</span><br><span class="line">  <span class="comment">//用包名和id生成一个QualifiedId:symble中存放的内容是以QualifiedId为键值</span></span><br><span class="line">  QualifiedId qualifiedId = element<span class="constructor">ToQualifiedId(<span class="params">element</span>, <span class="params">id</span>)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//从缓存中获取对应元素所在类的BindingSet.Builder，每个注解元素所在类都只有一个BindingSet.Builder</span></span><br><span class="line">  <span class="comment">//比如我们当前的元素位于MainActivity中，那么解析的时候就获取MainActivity对应的BindingSet.Builder</span></span><br><span class="line">  BindingSet.Builder builder = builderMap.get(enclosingElement<span class="comment">/*MainActivity*/</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//判断是否存在同一个id重复绑定的问题</span></span><br><span class="line">  <span class="keyword">if</span> (builder != null) &#123;</span><br><span class="line">    String existingBindingName = builder.find<span class="constructor">ExistingBindingName(<span class="params">getId</span>(<span class="params">qualifiedId</span>)</span>);</span><br><span class="line">    <span class="comment">//重复绑定的情况</span></span><br><span class="line">    <span class="keyword">if</span> (existingBindingName != null) &#123;</span><br><span class="line">      error(element, <span class="string">&quot;Attempt to use @%s for an already bound ID %d on &#x27;%s&#x27;. (%s.%s)&quot;</span>,</span><br><span class="line">              <span class="module-access"><span class="module"><span class="identifier">BindView</span>.</span></span><span class="keyword">class</span>.get<span class="constructor">SimpleName()</span>, id, existingBindingName,</span><br><span class="line">              enclosingElement.get<span class="constructor">QualifiedName()</span>, element.get<span class="constructor">SimpleName()</span>);</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//元素所处类对应包名/*MainActivity*/ + BindingSet.Builder</span></span><br><span class="line">    builder = get<span class="constructor">OrCreateBindingBuilder(<span class="params">builderMap</span>, <span class="params">enclosingElement</span>)</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//控件名 比如mTextView</span></span><br><span class="line">  String name = simpleName.<span class="keyword">to</span><span class="constructor">String()</span>;</span><br><span class="line">  <span class="comment">//获取对应的类型 TextView</span></span><br><span class="line">  TypeName <span class="keyword">type</span> = <span class="module-access"><span class="module"><span class="identifier">TypeName</span>.</span></span>get(elementType);</span><br><span class="line">  <span class="comment">//当前元素是否是必须的</span></span><br><span class="line">  boolean required = is<span class="constructor">FieldRequired(<span class="params">element</span>)</span>;</span><br><span class="line">  <span class="comment">//将当前的成员变量添加到BuildSet中   比如上述的例子:  id  /  TextView   mTextView    false</span></span><br><span class="line">  builder.add<span class="constructor">Field(<span class="params">getId</span>(<span class="params">qualifiedId</span>)</span>, <span class="keyword">new</span> <span class="constructor">FieldViewBinding(<span class="params">name</span>, <span class="params">type</span>, <span class="params">required</span>)</span>);</span><br><span class="line">  <span class="comment">// Add the type-erased version to the valid binding targets set.</span></span><br><span class="line">  erasedTargetNames.add(enclosingElement);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>BindingSet的创建是通过调用getOrCreateBindingBuilder方法来完成的：<br>它会先判断当前target类型是activity，dialog，还是一般的view，以及生成target对应的ViewBinding文件名。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">//builderMap 中存放的形式  key: 对应的包名 + 对应的BindingSet.Builder</span></span><br><span class="line"><span class="keyword">private</span> BindingSet.Builder get<span class="constructor">OrCreateBindingBuilder(Map&lt;TypeElement, BindingSet.Builder&gt; <span class="params">builderMap</span>, TypeElement <span class="params">enclosingElement</span>)</span> &#123;</span><br><span class="line">  BindingSet.Builder builder = builderMap.get(enclosingElement);</span><br><span class="line">  <span class="keyword">if</span> (builder<span class="operator"> == </span>null) &#123;</span><br><span class="line">    builder = <span class="module-access"><span class="module"><span class="identifier">BindingSet</span>.</span></span><span class="keyword">new</span><span class="constructor">Builder(<span class="params">enclosingElement</span><span class="operator">/</span><span class="operator">*</span>MainActivity<span class="operator">*</span><span class="operator">/</span>)</span>;</span><br><span class="line">    builderMap.put(enclosingElement, builder);</span><br><span class="line">  &#125;</span><br><span class="line">  return builder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 创建一个Builder，每个文件对应一个Builder，这里主要判断当前是否是View，是否是Activity，是否是Dialog，是否是Final，以及对应的报名</span></span><br><span class="line"><span class="comment">  * 参数为注解所处上层元素</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">static Builder <span class="keyword">new</span><span class="constructor">Builder(TypeElement <span class="params">enclosingElement</span>)</span> &#123;</span><br><span class="line">  TypeMirror typeMirror = enclosingElement.<span class="keyword">as</span><span class="constructor">Type()</span>;</span><br><span class="line">  <span class="comment">//判断当前是否View</span></span><br><span class="line">  boolean isView = is<span class="constructor">SubtypeOfType(<span class="params">typeMirror</span>, VIEW_TYPE)</span>;</span><br><span class="line">  <span class="comment">//判断当前是否Activity</span></span><br><span class="line">  boolean isActivity = is<span class="constructor">SubtypeOfType(<span class="params">typeMirror</span>, ACTIVITY_TYPE)</span>;</span><br><span class="line">  <span class="comment">//判断当前是否Dialog</span></span><br><span class="line">  boolean isDialog = is<span class="constructor">SubtypeOfType(<span class="params">typeMirror</span>, DIALOG_TYPE)</span>;</span><br><span class="line">  <span class="comment">//获取上层类的类型</span></span><br><span class="line">  TypeName targetType = <span class="module-access"><span class="module"><span class="identifier">TypeName</span>.</span></span>get(typeMirror);</span><br><span class="line">  <span class="keyword">if</span> (targetType instanceof ParameterizedTypeName) &#123;</span><br><span class="line">    targetType = ((ParameterizedTypeName) targetType).rawType;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//获取包名</span></span><br><span class="line">  String packageName = get<span class="constructor">Package(<span class="params">enclosingElement</span>)</span>.get<span class="constructor">QualifiedName()</span>.<span class="keyword">to</span><span class="constructor">String()</span>;</span><br><span class="line">  String className = enclosingElement.get<span class="constructor">QualifiedName()</span>.<span class="keyword">to</span><span class="constructor">String()</span>.substring(packageName.length<span class="literal">()</span> + <span class="number">1</span>).replace(<span class="character">&#x27;.&#x27;</span>, <span class="character">&#x27;$&#x27;</span>);</span><br><span class="line">  <span class="comment">//生成源码的文件名</span></span><br><span class="line">  ClassName bindingClassName = <span class="module-access"><span class="module"><span class="identifier">ClassName</span>.</span></span>get(packageName, className + <span class="string">&quot;_ViewBinding&quot;</span>);</span><br><span class="line">  boolean isFinal = enclosingElement.get<span class="constructor">Modifiers()</span>.contains(Modifier.FINAL);</span><br><span class="line">  return <span class="keyword">new</span> <span class="constructor">Builder(<span class="params">targetType</span>, <span class="params">bindingClassName</span>, <span class="params">isFinal</span>, <span class="params">isView</span>, <span class="params">isActivity</span>, <span class="params">isDialog</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那BindingSet的结构是怎样的呢？我们继续往下看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Builder</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> TypeName targetTypeName;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ClassName bindingClassName;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> isFinal;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> isView;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> isActivity;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> isDialog;</span><br><span class="line">  <span class="keyword">private</span> BindingSet parentBinding;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Id, ViewBinding.Builder&gt; viewIdMap = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ImmutableList.Builder&lt;FieldCollectionViewBinding&gt; collectionBindings = ImmutableList.builder();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ImmutableList.Builder&lt;ResourceBinding&gt; resourceBindings = ImmutableList.builder();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 添加Field</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">addField</span><span class="params">(Id id, FieldViewBinding binding)</span> &#123;</span><br><span class="line">    ViewBinding.<span class="type">Builder</span> <span class="variable">viewBinding</span> <span class="operator">=</span> getOrCreateViewBindings(id);</span><br><span class="line">    viewBinding.setFieldBinding(binding);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 添加方法</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="type">boolean</span> <span class="title function_">addMethod</span><span class="params">(Id id, ListenerClass listener, ListenerMethod method, MethodViewBinding binding)</span> &#123;</span><br><span class="line">    ViewBinding.<span class="type">Builder</span> <span class="variable">viewBinding</span> <span class="operator">=</span> getOrCreateViewBindings(id);</span><br><span class="line">    <span class="keyword">if</span> (viewBinding.hasMethodBinding(listener, method) &amp;&amp; !<span class="string">&quot;void&quot;</span>.equals(method.returnType())) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    viewBinding.addMethodBinding(listener, method, binding);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 添加Field集合</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">addFieldCollection</span><span class="params">(FieldCollectionViewBinding binding)</span> &#123;</span><br><span class="line">    collectionBindings.add(binding);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *  添加资源</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">addResource</span><span class="params">(ResourceBinding binding)</span> &#123;</span><br><span class="line">    resourceBindings.add(binding);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">setParent</span><span class="params">(BindingSet parent)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.parentBinding = parent;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 当前id是否已经被绑定了</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  String <span class="title function_">findExistingBindingName</span><span class="params">(Id id)</span> &#123;</span><br><span class="line">    ViewBinding.<span class="type">Builder</span> <span class="variable">builder</span> <span class="operator">=</span> viewIdMap.get(id);</span><br><span class="line">    <span class="keyword">if</span> (builder == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">FieldViewBinding</span> <span class="variable">fieldBinding</span> <span class="operator">=</span> builder.fieldBinding;</span><br><span class="line">    <span class="keyword">if</span> (fieldBinding == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fieldBinding.getName();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 往viewIdMap中获取ViewBinding.Builder</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="keyword">private</span> ViewBinding.Builder <span class="title function_">getOrCreateViewBindings</span><span class="params">(Id id)</span> &#123;</span><br><span class="line">    ViewBinding.<span class="type">Builder</span> <span class="variable">viewId</span> <span class="operator">=</span> viewIdMap.get(id);</span><br><span class="line">    <span class="keyword">if</span> (viewId == <span class="literal">null</span>) &#123;</span><br><span class="line">      viewId = <span class="keyword">new</span> <span class="title class_">ViewBinding</span>.Builder(id);</span><br><span class="line">      viewIdMap.put(id, viewId);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> viewId;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  BindingSet <span class="title function_">build</span><span class="params">()</span> &#123;</span><br><span class="line">    ImmutableList.Builder&lt;ViewBinding&gt; viewBindings = ImmutableList.builder();</span><br><span class="line">    <span class="keyword">for</span> (ViewBinding.Builder builder : viewIdMap.values()) &#123;</span><br><span class="line">      viewBindings.add(builder.build());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将当前的绑定数据传到BindingSet</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BindingSet</span>(targetTypeName, bindingClassName, isFinal, isView, isActivity, isDialog,</span><br><span class="line">        viewBindings.build(), collectionBindings.build(), resourceBindings.build(), parentBinding);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们从BindingSet的Builder可以看出它有如下的成员变量：</p>
<figure class="highlight cos"><table><tr><td class="code"><pre><span class="line">parentBinding       指向父类的BindingSet。</span><br><span class="line">viewIdMap           与<span class="keyword">View</span>相关的绑定信息，包括<span class="keyword">view</span>对象以及事件方法。</span><br><span class="line">collectionBindings  多个<span class="keyword">view</span>集体绑定的情况</span><br><span class="line">resourceBindings    资源绑定</span><br></pre></td></tr></table></figure>
<p>它有如下方法：</p>
<figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line">void addField(Id id, FieldViewBinding binding)  添加Field</span><br><span class="line">boolean addMethod(Id id, ListenerClass listener, ListenerMethod <span class="keyword">method</span>, <span class="title function_">MethodViewBinding</span> <span class="title function_">binding</span>)  添加事件方法</span><br><span class="line"><span class="title function_">void</span> <span class="title function_">addFieldCollection</span><span class="params">(FieldCollectionViewBinding binding)</span>  添加<span class="title function_">Field</span>集合</span><br><span class="line"><span class="title function_">void</span> <span class="title function_">addResource</span><span class="params">(ResourceBinding binding)</span>  添加资源</span><br></pre></td></tr></table></figure>

<p>介绍完BindView 我也把事件绑定的方法贴出来了，下面有较为详细的注释。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">findAndParseListener</span><span class="params">(RoundEnvironment env, Class&lt;? extends Annotation&gt; annotationClass, Map&lt;TypeElement, BindingSet.Builder&gt; builderMap, Set&lt;TypeElement&gt; erasedTargetNames)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (Element element : env.getElementsAnnotatedWith(annotationClass)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!SuperficialValidation.validateElement(element)) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        parseListenerAnnotation(annotationClass, element, builderMap, erasedTargetNames);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="type">StringWriter</span> <span class="variable">stackTrace</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringWriter</span>();</span><br><span class="line">        e.printStackTrace(<span class="keyword">new</span> <span class="title class_">PrintWriter</span>(stackTrace));</span><br><span class="line">        error(element, <span class="string">&quot;Unable to generate view binder for @%s.\n\n%s&quot;</span>,</span><br><span class="line">            annotationClass.getSimpleName(), stackTrace.toString());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">parseListenerAnnotation</span><span class="params">(Class&lt;? extends Annotation&gt; annotationClass, Element element, Map&lt;TypeElement, BindingSet.Builder&gt; builderMap, Set&lt;TypeElement&gt; erasedTargetNames)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// This should be guarded by the annotation&#x27;s @Target but it&#x27;s worth a check for safe casting.</span></span><br><span class="line">    <span class="comment">//首先检查当前元素是否是方法类型</span></span><br><span class="line">    <span class="keyword">if</span> (!(element <span class="keyword">instanceof</span> ExecutableElement) || element.getKind() != METHOD) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(String.format(<span class="string">&quot;@%s annotation must be on a method.&quot;</span>, annotationClass.getSimpleName()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">ExecutableElement</span> <span class="variable">executableElement</span> <span class="operator">=</span> (ExecutableElement) element;</span><br><span class="line">    <span class="type">TypeElement</span> <span class="variable">enclosingElement</span> <span class="operator">=</span> (TypeElement) element.getEnclosingElement();</span><br><span class="line">    <span class="comment">//获取注解中的id数组</span></span><br><span class="line">    <span class="type">Annotation</span> <span class="variable">annotation</span> <span class="operator">=</span> element.getAnnotation(annotationClass);</span><br><span class="line">    <span class="type">Method</span> <span class="variable">annotationValue</span> <span class="operator">=</span> annotationClass.getDeclaredMethod(<span class="string">&quot;value&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (annotationValue.getReturnType() != <span class="type">int</span>[].class) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(String.format(<span class="string">&quot;@%s annotation value() type not int[].&quot;</span>, annotationClass));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] ids = (<span class="type">int</span>[]) annotationValue.invoke(annotation);</span><br><span class="line">    <span class="comment">//方法名字</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> executableElement.getSimpleName().toString();</span><br><span class="line">    <span class="comment">//是否必须</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">required</span> <span class="operator">=</span> isListenerRequired(executableElement);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//校验是否错误</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">hasError</span> <span class="operator">=</span> isInaccessibleViaGeneratedCode(annotationClass, <span class="string">&quot;methods&quot;</span>, element);</span><br><span class="line">    hasError |= isBindingInWrongPackage(annotationClass, element);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找是否有重复的id</span></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">duplicateId</span> <span class="operator">=</span> findDuplicate(ids);</span><br><span class="line">    <span class="keyword">if</span> (duplicateId != <span class="literal">null</span>) &#123;</span><br><span class="line">      error(element, <span class="string">&quot;@%s annotation for method contains duplicate ID %d. (%s.%s)&quot;</span>,</span><br><span class="line">          annotationClass.getSimpleName(), duplicateId, enclosingElement.getQualifiedName(),</span><br><span class="line">          element.getSimpleName());</span><br><span class="line">      hasError = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取到对应ListenerClass</span></span><br><span class="line">    <span class="type">ListenerClass</span> <span class="variable">listener</span> <span class="operator">=</span> annotationClass.getAnnotation(ListenerClass.class);</span><br><span class="line">    <span class="keyword">if</span> (listener == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(</span><br><span class="line">          String.format(<span class="string">&quot;No @%s defined on @%s.&quot;</span>, ListenerClass.class.getSimpleName(),</span><br><span class="line">              annotationClass.getSimpleName()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*@ListenerClass(</span></span><br><span class="line"><span class="comment">            targetType = &quot;android.view.View&quot;,</span></span><br><span class="line"><span class="comment">            setter = &quot;setOnClickListener&quot;,</span></span><br><span class="line"><span class="comment">            type = &quot;butterknife.internal.DebouncingOnClickListener&quot;,</span></span><br><span class="line"><span class="comment">            method = @ListenerMethod(</span></span><br><span class="line"><span class="comment">                    name = &quot;doClick&quot;,</span></span><br><span class="line"><span class="comment">                    parameters = &quot;android.view.View&quot;</span></span><br><span class="line"><span class="comment">            )</span></span><br><span class="line"><span class="comment">    )*/</span></span><br><span class="line">    ListenerMethod method;</span><br><span class="line">    ListenerMethod[] methods = listener.method();</span><br><span class="line">    <span class="comment">//获取onClick注解中@ListenerClass中的method</span></span><br><span class="line">    <span class="keyword">if</span> (methods.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="comment">//不允许有两个以上的method</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(String.format(<span class="string">&quot;Multiple listener methods specified on @%s.&quot;</span>, annotationClass.getSimpleName()));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (methods.length == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="comment">//method 不允许和callbacks共存</span></span><br><span class="line">      <span class="keyword">if</span> (listener.callbacks() != ListenerClass.NONE.class) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(String.format(<span class="string">&quot;Both method() and callback() defined on @%s.&quot;</span>, annotationClass.getSimpleName()));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//获取到methods[0]</span></span><br><span class="line">      method = methods[<span class="number">0</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//如果没有method就获取callback</span></span><br><span class="line">      <span class="type">Method</span> <span class="variable">annotationCallback</span> <span class="operator">=</span> annotationClass.getDeclaredMethod(<span class="string">&quot;callback&quot;</span>);</span><br><span class="line">      Enum&lt;?&gt; callback = (Enum&lt;?&gt;) annotationCallback.invoke(annotation);</span><br><span class="line">      <span class="type">Field</span> <span class="variable">callbackField</span> <span class="operator">=</span> callback.getDeclaringClass().getField(callback.name());</span><br><span class="line">      method = callbackField.getAnnotation(ListenerMethod.class);</span><br><span class="line">      <span class="keyword">if</span> (method == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(</span><br><span class="line">            String.format(<span class="string">&quot;No @%s defined on @%s&#x27;s %s.%s.&quot;</span>, ListenerMethod.class.getSimpleName(),</span><br><span class="line">                annotationClass.getSimpleName(), callback.getDeclaringClass().getSimpleName(),</span><br><span class="line">                callback.name()));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//验证回调方法的参数（实际被注释的方法参数不能大于注解中提供的参数个数）</span></span><br><span class="line">    <span class="comment">// Verify that the method has equal to or less than the number of parameters as the listener.</span></span><br><span class="line">    <span class="comment">//获取实际的方法参数</span></span><br><span class="line">    List&lt;? <span class="keyword">extends</span> <span class="title class_">VariableElement</span>&gt; methodParameters = executableElement.getParameters();</span><br><span class="line">    <span class="comment">//如果注解目标参数大于ListenerMethod注解指定的参数个数就报错</span></span><br><span class="line">    <span class="keyword">if</span> (methodParameters.size() &gt; method.parameters().length) &#123;</span><br><span class="line">      error(element, <span class="string">&quot;@%s methods can have at most %s parameter(s). (%s.%s)&quot;</span>,</span><br><span class="line">          annotationClass.getSimpleName(), method.parameters().length,</span><br><span class="line">          enclosingElement.getQualifiedName(), element.getSimpleName());</span><br><span class="line">      hasError = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 验证返回类型（实际被注释的方法参数需要等于注解中提供的参数类型）</span></span><br><span class="line">    <span class="comment">// Verify method return type matches the listener.</span></span><br><span class="line">    <span class="type">TypeMirror</span> <span class="variable">returnType</span> <span class="operator">=</span> executableElement.getReturnType();</span><br><span class="line">    <span class="keyword">if</span> (returnType <span class="keyword">instanceof</span> TypeVariable) &#123;</span><br><span class="line">      <span class="type">TypeVariable</span> <span class="variable">typeVariable</span> <span class="operator">=</span> (TypeVariable) returnType;</span><br><span class="line">      returnType = typeVariable.getUpperBound();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!returnType.toString().equals(method.returnType())) &#123;</span><br><span class="line">      error(element, <span class="string">&quot;@%s methods must have a &#x27;%s&#x27; return type. (%s.%s)&quot;</span>,</span><br><span class="line">          annotationClass.getSimpleName(), method.returnType(),</span><br><span class="line">          enclosingElement.getQualifiedName(), element.getSimpleName());</span><br><span class="line">      hasError = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//校验结束，如果有问题就不在继续</span></span><br><span class="line">    <span class="keyword">if</span> (hasError) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Parameter[] parameters = Parameter.NONE;</span><br><span class="line">    <span class="comment">//省略参数的创建过程</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//name 名字  parameters 参数  required 是否必须</span></span><br><span class="line">    <span class="type">MethodViewBinding</span> <span class="variable">binding</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MethodViewBinding</span>(name, Arrays.asList(parameters), required);</span><br><span class="line">    <span class="comment">//创建一个BindingSet.Builder</span></span><br><span class="line">    BindingSet.<span class="type">Builder</span> <span class="variable">builder</span> <span class="operator">=</span> getOrCreateBindingBuilder(builderMap, enclosingElement);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> id : ids) &#123;</span><br><span class="line">      <span class="comment">//为每个id绑定一个方法</span></span><br><span class="line">      <span class="type">QualifiedId</span> <span class="variable">qualifiedId</span> <span class="operator">=</span> elementToQualifiedId(element, id);</span><br><span class="line">      <span class="comment">//ListenerClass listener = annotationClass.getAnnotation(ListenerClass.class);</span></span><br><span class="line">      <span class="keyword">if</span> (!builder.addMethod(getId(qualifiedId), listener, method, binding)) &#123;</span><br><span class="line">        error(element, <span class="string">&quot;Multiple listener methods with return value specified for ID %d. (%s.%s)&quot;</span>, id, enclosingElement.getQualifiedName(), element.getSimpleName());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Add the type-erased version to the valid binding targets set.</span></span><br><span class="line">    erasedTargetNames.add(enclosingElement);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>使用JavaPoest为每个BindingSet创建对应的_ViewBinding文件：<br>我们在此回到process方法</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">boolean</span> <span class="title function_">process</span>(<span class="params"><span class="built_in">Set</span>&lt;? <span class="keyword">extends</span> TypeElement&gt; elements, RoundEnvironment env</span>) &#123;</span><br><span class="line">  <span class="title class_">Map</span>&lt;<span class="title class_">TypeElement</span>, <span class="title class_">BindingSet</span>&gt; bindingMap = <span class="title function_">findAndParseTargets</span>(env);</span><br><span class="line">  <span class="keyword">for</span> (<span class="title class_">Map</span>.<span class="property">Entry</span>&lt;<span class="title class_">TypeElement</span>, <span class="title class_">BindingSet</span>&gt; entry : bindingMap.<span class="title function_">entrySet</span>()) &#123;</span><br><span class="line">    <span class="title class_">TypeElement</span> typeElement = entry.<span class="title function_">getKey</span>();</span><br><span class="line">    <span class="title class_">BindingSet</span> binding = entry.<span class="title function_">getValue</span>();</span><br><span class="line">    <span class="title class_">JavaFile</span> javaFile = binding.<span class="title function_">brewJava</span>(sdk);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      javaFile.<span class="title function_">writeTo</span>(filer);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (<span class="title class_">IOException</span> e) &#123;</span><br><span class="line">      <span class="title function_">error</span>(typeElement, <span class="string">&quot;Unable to write binding for type %s: %s&quot;</span>, typeElement, e.<span class="title function_">getMessage</span>());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们上面了解了如何从R文件中获取对应的信息构成后续作为Id使用的symbols。再对代码中使用到的Butterknife注解进行解析，获取到对应的View 绑定，事件方法绑定，资源绑定信息，添加到对应BingSet中，最后我们要了解的是最后一步 – 使用JavaPost来将BindingSet中收集到的View 绑定，事件方法绑定，资源绑定信息生成对应的源码：<br>我们先来看下brewJava 方法：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">JavaFile brew<span class="constructor">Java(<span class="params">int</span> <span class="params">sdk</span>)</span> &#123;</span><br><span class="line">    return JavaFile</span><br><span class="line">            .builder(bindingClassName.package<span class="constructor">Name()</span><span class="comment">/*com.package.xxxx.MainActivity_BindingView*/</span>, create<span class="constructor">Type(<span class="params">sdk</span>)</span>)</span><br><span class="line">            .add<span class="constructor">FileComment(<span class="string">&quot;Generated code from Butter Knife. Do not modify!&quot;</span>)</span></span><br><span class="line">            .build<span class="literal">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>brewJava 方法中最重要的就是createType，它是生成_ViewBinding的核心代码，下面给出了详细的注释：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> TypeSpec create<span class="constructor">Type(<span class="params">int</span> <span class="params">sdk</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用JavaPost 生成  &quot;public final class MainActivity_BindingView&quot;</span></span><br><span class="line">    TypeSpec.Builder result = <span class="module-access"><span class="module"><span class="identifier">TypeSpec</span>.</span></span><span class="keyword">class</span><span class="constructor">Builder(<span class="params">bindingClassName</span>.<span class="params">simpleName</span>()</span>).add<span class="constructor">Modifiers(PUBLIC)</span>;</span><br><span class="line">    <span class="keyword">if</span> (isFinal) &#123;</span><br><span class="line">      result.add<span class="constructor">Modifiers(FINAL)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成 public final class MainActivity_BindingView extends Unbinder</span></span><br><span class="line">    <span class="comment">//或者 public final class MainActivity_BindingView extends XXXXActivity_BindingView</span></span><br><span class="line">    <span class="comment">//查看是否父类有绑定，添加绑定类的父类</span></span><br><span class="line">    <span class="keyword">if</span> (parentBinding != null) &#123;</span><br><span class="line">      result.superclass(parentBinding.bindingClassName);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result.add<span class="constructor">Superinterface(UNBINDER)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//是否有方法或者值绑定，如果有那么添加target成员,在只有资源绑定的情况下就没有target成员变量</span></span><br><span class="line">    <span class="keyword">if</span> (has<span class="constructor">TargetField()</span>) &#123;</span><br><span class="line">      result.add<span class="constructor">Field(<span class="params">targetTypeName</span>, <span class="string">&quot;target&quot;</span>, PRIVATE)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建对应的构造方法</span></span><br><span class="line">    <span class="keyword">if</span> (isView) &#123;</span><br><span class="line">      result.add<span class="constructor">Method(<span class="params">createBindingConstructorForView</span>()</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isActivity) &#123;</span><br><span class="line">      result.add<span class="constructor">Method(<span class="params">createBindingConstructorForActivity</span>()</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDialog) &#123;</span><br><span class="line">      result.add<span class="constructor">Method(<span class="params">createBindingConstructorForDialog</span>()</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加一个废弃的方法用于在Butterknife.bind方法反射时候使用</span></span><br><span class="line">    <span class="keyword">if</span> (!constructor<span class="constructor">NeedsView()</span>) &#123;</span><br><span class="line">      result.add<span class="constructor">Method(<span class="params">createBindingViewDelegateConstructor</span>()</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    result.add<span class="constructor">Method(<span class="params">createBindingConstructor</span>(<span class="params">sdk</span>)</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加unbind方法</span></span><br><span class="line">    <span class="keyword">if</span> (has<span class="constructor">ViewBindings()</span><span class="operator"> || </span>parentBinding<span class="operator"> == </span>null) &#123;</span><br><span class="line">      result.add<span class="constructor">Method(<span class="params">createBindingUnbindMethod</span>(<span class="params">result</span>)</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    return result.build<span class="literal">()</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>那么我们在Butterknife bind方法中调用的构造函数是哪个呢：就是createBindingConstructor</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> MethodSpec create<span class="constructor">BindingConstructor(<span class="params">int</span> <span class="params">sdk</span>)</span> &#123;</span><br><span class="line">  <span class="comment">//添加一个无参数的构造方法</span></span><br><span class="line">  <span class="comment">//@UiThread</span></span><br><span class="line">  <span class="comment">//public class MainActivity_BindingView &#123;</span></span><br><span class="line">  <span class="comment">//   MainActivity_BindingView(Activity target,View source) &#123;</span></span><br><span class="line">  <span class="comment">//      super(target, source);</span></span><br><span class="line">  <span class="comment">//      this.target = target</span></span><br><span class="line">  <span class="comment">//   &#125;</span></span><br><span class="line">  <span class="comment">//&#125;</span></span><br><span class="line">  MethodSpec.Builder constructor = <span class="module-access"><span class="module"><span class="identifier">MethodSpec</span>.</span></span>constructor<span class="constructor">Builder()</span></span><br><span class="line">      .add<span class="constructor">Annotation(UI_THREAD)</span></span><br><span class="line">      .add<span class="constructor">Modifiers(PUBLIC)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (has<span class="constructor">MethodBindings()</span>) &#123;</span><br><span class="line">    constructor.add<span class="constructor">Parameter(<span class="params">targetTypeName</span>, <span class="string">&quot;target&quot;</span>, FINAL)</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    constructor.add<span class="constructor">Parameter(<span class="params">targetTypeName</span>, <span class="string">&quot;target&quot;</span>)</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//如果跟View相关那么添加成员变量source 否则添加成员变量context</span></span><br><span class="line">  <span class="keyword">if</span> (constructor<span class="constructor">NeedsView()</span>) &#123;</span><br><span class="line">    constructor.add<span class="constructor">Parameter(VIEW, <span class="string">&quot;source&quot;</span>)</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    constructor.add<span class="constructor">Parameter(CONTEXT, <span class="string">&quot;context&quot;</span>)</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (has<span class="constructor">UnqualifiedResourceBindings()</span>) &#123;</span><br><span class="line">    <span class="comment">// Aapt can change IDs out from underneath us, just suppress since all will work at runtime.</span></span><br><span class="line">    constructor.add<span class="constructor">Annotation(AnnotationSpec.<span class="params">builder</span>(SuppressWarnings.<span class="params">class</span>)</span></span><br><span class="line">        .add<span class="constructor">Member(<span class="string">&quot;value&quot;</span>, <span class="string">&quot;$S&quot;</span>, <span class="string">&quot;ResourceType&quot;</span>)</span></span><br><span class="line">        .build<span class="literal">()</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//是否有onTouch事件绑定</span></span><br><span class="line">  <span class="keyword">if</span> (has<span class="constructor">OnTouchMethodBindings()</span>) &#123;</span><br><span class="line">    constructor.add<span class="constructor">Annotation(AnnotationSpec.<span class="params">builder</span>(SUPPRESS_LINT)</span></span><br><span class="line">        .add<span class="constructor">Member(<span class="string">&quot;value&quot;</span>, <span class="string">&quot;$S&quot;</span>, <span class="string">&quot;ClickableViewAccessibility&quot;</span>)</span></span><br><span class="line">        .build<span class="literal">()</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//添加对父类构造方法的调用</span></span><br><span class="line">  <span class="keyword">if</span> (parentBinding != null) &#123;</span><br><span class="line">    <span class="keyword">if</span> (parentBinding.constructor<span class="constructor">NeedsView()</span>) &#123;</span><br><span class="line">      constructor.add<span class="constructor">Statement(<span class="string">&quot;super(target, source)&quot;</span>)</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (constructor<span class="constructor">NeedsView()</span>) &#123;</span><br><span class="line">      constructor.add<span class="constructor">Statement(<span class="string">&quot;super(target, source.getContext())&quot;</span>)</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      constructor.add<span class="constructor">Statement(<span class="string">&quot;super(target, context)&quot;</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    constructor.add<span class="constructor">Code(<span class="string">&quot;\n&quot;</span>)</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//给target赋值</span></span><br><span class="line">  <span class="keyword">if</span> (has<span class="constructor">TargetField()</span>) &#123;</span><br><span class="line">    constructor.add<span class="constructor">Statement(<span class="string">&quot;this.target = target&quot;</span>)</span>;</span><br><span class="line">    constructor.add<span class="constructor">Code(<span class="string">&quot;\n&quot;</span>)</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//添加View 绑定</span></span><br><span class="line">  <span class="keyword">if</span> (has<span class="constructor">ViewBindings()</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (has<span class="constructor">ViewLocal()</span>) &#123;</span><br><span class="line">      <span class="comment">// Local variable in which all views will be temporarily stored.</span></span><br><span class="line">      constructor.add<span class="constructor">Statement(<span class="string">&quot;$T view&quot;</span>, VIEW)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//添加绑定的View,这里是重点</span></span><br><span class="line">    <span class="keyword">for</span> (ViewBinding binding : viewBindings) &#123;</span><br><span class="line">      add<span class="constructor">ViewBinding(<span class="params">constructor</span>, <span class="params">binding</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (FieldCollectionViewBinding binding : collectionBindings) &#123;</span><br><span class="line">      constructor.add<span class="constructor">Statement(<span class="string">&quot;$L&quot;</span>, <span class="params">binding</span>.<span class="params">render</span>()</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!resourceBindings.is<span class="constructor">Empty()</span>) &#123;</span><br><span class="line">      constructor.add<span class="constructor">Code(<span class="string">&quot;\n&quot;</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//添加其他绑定</span></span><br><span class="line">  <span class="keyword">if</span> (!resourceBindings.is<span class="constructor">Empty()</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (constructor<span class="constructor">NeedsView()</span>) &#123;</span><br><span class="line">      constructor.add<span class="constructor">Statement(<span class="string">&quot;$T context = source.getContext()&quot;</span>, CONTEXT)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (has<span class="constructor">ResourceBindingsNeedingResource(<span class="params">sdk</span>)</span>) &#123;</span><br><span class="line">      constructor.add<span class="constructor">Statement(<span class="string">&quot;$T res = context.getResources()&quot;</span>, RESOURCES)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (ResourceBinding binding : resourceBindings) &#123;</span><br><span class="line">      constructor.add<span class="constructor">Statement(<span class="string">&quot;$L&quot;</span>, <span class="params">binding</span>.<span class="params">render</span>(<span class="params">sdk</span>)</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return constructor.build<span class="literal">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码已经注释很清楚了，我们直接讲最重要的：addViewBinding，在调用addViewBinding之前会调用hasViewBindings来判断当前是否有view绑定以及事件方法绑定，如果有才会调用addViewBinding.<br>在addViewBinding方法中会判断是否isRequired来决定是调用butterknife.internal.Utils的findRequiredViewAsType 还是findOptionalView</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_ invoke__">addViewBinding</span>(MethodSpec.Builder result, ViewBinding binding) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (binding.<span class="title function_ invoke__">isSingleFieldBinding</span>()) &#123;</span><br><span class="line">      FieldViewBinding fieldBinding = binding.<span class="title function_ invoke__">getFieldBinding</span>();</span><br><span class="line">      CodeBlock.Builder builder = CodeBlock.<span class="title function_ invoke__">builder</span>().<span class="title function_ invoke__">add</span>(<span class="string">&quot;target.<span class="subst">$L</span> = &quot;</span>, fieldBinding.<span class="title function_ invoke__">getName</span>());</span><br><span class="line">      <span class="comment">//生成target.mTextBtn =</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//是否需要强制转换</span></span><br><span class="line">      <span class="keyword">boolean</span> requiresCast = <span class="title function_ invoke__">requiresCast</span>(fieldBinding.<span class="title function_ invoke__">getType</span>());</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!requiresCast &amp;&amp; !fieldBinding.<span class="title function_ invoke__">isRequired</span>()) &#123;</span><br><span class="line">        <span class="comment">//生成 target.mTextBtn = source.findViewById(id)</span></span><br><span class="line">        builder.<span class="title function_ invoke__">add</span>(<span class="string">&quot;source.findViewById(<span class="subst">$L</span>)&quot;</span>, binding.<span class="title function_ invoke__">getId</span>().code);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        builder.<span class="title function_ invoke__">add</span>(<span class="string">&quot;<span class="subst">$T</span>.find&quot;</span>, UTILS);</span><br><span class="line">        builder.<span class="title function_ invoke__">add</span>(fieldBinding.<span class="title function_ invoke__">isRequired</span>() ? <span class="string">&quot;RequiredView&quot;</span> : <span class="string">&quot;OptionalView&quot;</span>);</span><br><span class="line">        <span class="comment">//调用butterknife.internal.Utils的findRequiredViewAsType 或者findOptionalView</span></span><br><span class="line">        <span class="keyword">if</span> (requiresCast) &#123;</span><br><span class="line">          builder.<span class="title function_ invoke__">add</span>(<span class="string">&quot;AsType&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        builder.<span class="title function_ invoke__">add</span>(<span class="string">&quot;(source, <span class="subst">$L</span>&quot;</span>, binding.<span class="title function_ invoke__">getId</span>().code);</span><br><span class="line">        <span class="keyword">if</span> (fieldBinding.<span class="title function_ invoke__">isRequired</span>() || requiresCast) &#123;</span><br><span class="line">          builder.<span class="title function_ invoke__">add</span>(<span class="string">&quot;, <span class="subst">$S</span>&quot;</span>, <span class="title function_ invoke__">asHumanDescription</span>(<span class="title function_ invoke__">singletonList</span>(fieldBinding)));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (requiresCast) &#123;</span><br><span class="line">          builder.<span class="title function_ invoke__">add</span>(<span class="string">&quot;, <span class="subst">$T</span>.class&quot;</span>, fieldBinding.<span class="title function_ invoke__">getRawType</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        builder.<span class="title function_ invoke__">add</span>(<span class="string">&quot;)&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      result.<span class="title function_ invoke__">addStatement</span>(<span class="string">&quot;<span class="subst">$L</span>&quot;</span>, builder.<span class="title function_ invoke__">build</span>());</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;MemberViewBinding&gt; requiredBindings = binding.<span class="title function_ invoke__">getRequiredBindings</span>();</span><br><span class="line">    <span class="keyword">if</span> (requiredBindings.<span class="title function_ invoke__">isEmpty</span>()) &#123;</span><br><span class="line">      result.<span class="title function_ invoke__">addStatement</span>(<span class="string">&quot;view = source.findViewById(<span class="subst">$L</span>)&quot;</span>, binding.<span class="title function_ invoke__">getId</span>().code);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!binding.<span class="title function_ invoke__">isBoundToRoot</span>()) &#123;</span><br><span class="line">      result.<span class="title function_ invoke__">addStatement</span>(<span class="string">&quot;view = <span class="subst">$T</span>.findRequiredView(source, <span class="subst">$L</span>, <span class="subst">$S</span>)&quot;</span>, UTILS,</span><br><span class="line">              binding.<span class="title function_ invoke__">getId</span>().code, <span class="title function_ invoke__">asHumanDescription</span>(requiredBindings));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//添加成员变量绑定</span></span><br><span class="line">    <span class="title function_ invoke__">addFieldBinding</span>(result, binding);</span><br><span class="line">    <span class="comment">//添加方法绑定</span></span><br><span class="line">    <span class="title function_ invoke__">addMethodBindings</span>(result, binding);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>findOptionalViewAsType 和 findRequiredViewAsType 有什么区别呢？我们从下面代码可以看出findRequiredViewAsType会在source中获取对应的控件，后判断是否获取到，如果没有获取到会抛出如下异常：</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">IllegalStateException</span>(<span class="string">&quot;Required view &#x27;&quot;</span></span><br><span class="line">    + name</span><br><span class="line">    + <span class="string">&quot;&#x27; with ID &quot;</span></span><br><span class="line">    + id</span><br><span class="line">    + <span class="string">&quot; for &quot;</span></span><br><span class="line">    + who</span><br><span class="line">    + <span class="string">&quot; was not found. If this view is optional add &#x27;@Nullable&#x27; (fields) or &#x27;@Optional&#x27;&quot;</span></span><br><span class="line">    + <span class="string">&quot; (methods) annotation.&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>而最终的类型转换是通过cls.cast 方法来完成的。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">findOptionalViewAsType</span>(<span class="params">View source, <span class="meta">@IdRes</span> int id, <span class="built_in">String</span> who,</span></span><br><span class="line"><span class="params">    Class&lt;T&gt; cls</span>) &#123;</span><br><span class="line">  <span class="title class_">View</span> view = source.<span class="title function_">findViewById</span>(id);</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">castView</span>(view, id, who, cls);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">findRequiredViewAsType</span>(<span class="params">View source, <span class="meta">@IdRes</span> int id, <span class="built_in">String</span> who,</span></span><br><span class="line"><span class="params">    Class&lt;T&gt; cls</span>) &#123;</span><br><span class="line">  <span class="title class_">View</span> view = <span class="title function_">findRequiredView</span>(source, id, who);</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">castView</span>(view, id, who, cls);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title class_">View</span> <span class="title function_">findRequiredView</span>(<span class="params">View source, <span class="meta">@IdRes</span> int id, <span class="built_in">String</span> who</span>) &#123;</span><br><span class="line">  <span class="title class_">View</span> view = source.<span class="title function_">findViewById</span>(id);</span><br><span class="line">  <span class="keyword">if</span> (view != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> view;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title class_">String</span> name = <span class="title function_">getResourceEntryName</span>(source, id);</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Required view &#x27;&quot;</span></span><br><span class="line">      + name</span><br><span class="line">      + <span class="string">&quot;&#x27; with ID &quot;</span></span><br><span class="line">      + id</span><br><span class="line">      + <span class="string">&quot; for &quot;</span></span><br><span class="line">      + who</span><br><span class="line">      + <span class="string">&quot; was not found. If this view is optional add &#x27;@Nullable&#x27; (fields) or &#x27;@Optional&#x27;&quot;</span></span><br><span class="line">      + <span class="string">&quot; (methods) annotation.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">castView</span>(<span class="params">View view, <span class="meta">@IdRes</span> int id, <span class="built_in">String</span> who, Class&lt;T&gt; cls</span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> cls.<span class="title function_">cast</span>(view);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (<span class="title class_">ClassCastException</span> e) &#123;</span><br><span class="line">    <span class="title class_">String</span> name = <span class="title function_">getResourceEntryName</span>(view, id);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;View &#x27;&quot;</span></span><br><span class="line">        + name</span><br><span class="line">        + <span class="string">&quot;&#x27; with ID &quot;</span></span><br><span class="line">        + id</span><br><span class="line">        + <span class="string">&quot; for &quot;</span></span><br><span class="line">        + who</span><br><span class="line">        + <span class="string">&quot; was of the wrong type. See cause for more info.&quot;</span>, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>到此为止整个Butterknife源码分析完毕。老规矩上图：<br><img src="/2017/05/02/%E5%BC%80%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BButterknife/image001.png"></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/%E5%BC%80%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/">开源代码分析</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/开源代码分析/">开源代码分析</a>
  </div>

</div>



<div class="comments-count">
	
	  	<span></span>
		<a href="/2017/05/02/开源代码分析之Butterknife/#comments" class="ds-thread-count comments-count-link" data-thread-key="2017/05/02/开源代码分析之Butterknife/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/05/02/一步一步编写编译时注释框架-1/" title="一步一步编写编译时注释框架[1]" itemprop="url">一步一步编写编译时注释框架[1]</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Edgar" target="_blank" itemprop="author">Edgar</a>
		
  <p class="article-time">
    <time datetime="2017-05-02T13:29:32.000Z" itemprop="datePublished"> Published 2017-05-02</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>我们之前在介绍Java注解的时候提到了注解有两种类型，一种是运行时注解，一种是编译时注解，运行时注解是在运行的时候通过反射解析注解，针对对应的注解采取对应的动作，编译时注解是在编译时通过收集附加在代码上的注解来标记一些内容，然后在编译的时候通过识别这些注解来动态生成一些代码。很显然运行时注解会因为java反射而引起较为严重的性能问题，所以尽量避免使用，而编译时注解的魅力在于：编译时按照预先使用注解规定的方案生成代码来避免编写重复代码，提高开发效率，且不影响性能。ß目前使用编译时注解的较为著名的开源框架有Butterknife,Dagger2等。</p>
<p>Annotation Processor Tool是用于编译期扫描和处理注解的工具，目前被集成在javac中。在编译的时候，javac通常会找到你定义的注解处理器，并执行注解处理。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>



<div class="comments-count">
	
	  	<span></span>
		<a href="/2017/05/02/一步一步编写编译时注释框架-1/#comments" class="ds-thread-count comments-count-link" data-thread-key="2017/05/02/一步一步编写编译时注释框架-1/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/02/06/Java-进阶系列之容器/" title="Java 进阶系列之容器" itemprop="url">Java 进阶系列之容器</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Edgar" target="_blank" itemprop="author">Edgar</a>
		
  <p class="article-time">
    <time datetime="2017-02-06T13:07:10.000Z" itemprop="datePublished"> Published 2017-02-06</time>
    
  </p>
</header>
    <div class="article-content">
        
        
        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>



<div class="comments-count">
	
	  	<span></span>
		<a href="/2017/02/06/Java-进阶系列之容器/#comments" class="ds-thread-count comments-count-link" data-thread-key="2017/02/06/Java-进阶系列之容器/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>







  <nav id="page-nav" class="clearfix">
    <a class="extend prev" rel="prev" href="/page/10/">&lt;span&gt;&lt;&#x2F;span&gt;Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="page-number" href="/page/10/">10</a><span class="page-number current">11</span><a class="page-number" href="/page/12/">12</a><a class="page-number" href="/page/13/">13</a><span class="space">&hellip;</span><a class="page-number" href="/page/30/">30</a><a class="extend next" rel="next" href="/page/12/">Next&lt;span&gt;&lt;&#x2F;span&gt;</a>
  </nav>

</div>
      <div class="openaside"><a class="navbutton" href="#" title="Show Sidebar"></a></div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="Hide Sidebar"></a></div>
<aside class="clearfix">
<div id="authorInfo">
	
		<div class="author-img"></div>		
	
	<div class="social-info" class="clearfix">
		
		
		<a href="https://github.com/tbfungeek" target="_blank" class="icon-github" title="github"></a>
		
		
		
		
		
		
		
		
		
		
		<a href="mailto:tbfungeek@163.com" target="_blank" class="icon-email" title="Email Me"></a>
		

	</div>
</div>

  
<div class="categorieslist">
	<p class="asidetitle">Categories</p>
		<ul>
		
		  
			<li><a href="/categories/Android-小经验/" title="Android 小经验">Android 小经验<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Android-源码分析/" title="Android 源码分析">Android 源码分析<sup>21</sup></a></li>
		  
		
		  
			<li><a href="/categories/Android其他/" title="Android其他">Android其他<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Android初步/" title="Android初步">Android初步<sup>21</sup></a></li>
		  
		
		  
			<li><a href="/categories/Android进阶/" title="Android进阶">Android进阶<sup>100</sup></a></li>
		  
		
		  
			<li><a href="/categories/Hexo-使用/" title="Hexo 使用">Hexo 使用<sup>10</sup></a></li>
		  
		
		  
			<li><a href="/categories/JavaScript理论/" title="JavaScript理论">JavaScript理论<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Objective-C-相关/" title="Objective C 相关">Objective C 相关<sup>24</sup></a></li>
		  
		
		  
			<li><a href="/categories/OpenCV/" title="OpenCV">OpenCV<sup>6</sup></a></li>
		  
		
		  
			<li><a href="/categories/ROS/" title="ROS">ROS<sup>9</sup></a></li>
		  
		
		  
			<li><a href="/categories/iOS-工具使用/" title="iOS 工具使用">iOS 工具使用<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/iOS-开源库分析/" title="iOS 开源库分析">iOS 开源库分析<sup>36</sup></a></li>
		  
		
		  
			<li><a href="/categories/iOS-理论基础/" title="iOS 理论基础">iOS 理论基础<sup>14</sup></a></li>
		  
		
		  
			<li><a href="/categories/iOS-进阶/" title="iOS 进阶">iOS 进阶<sup>4</sup></a></li>
		  
		
		  
			<li><a href="/categories/个人收藏/" title="个人收藏">个人收藏<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/代码规范/" title="代码规范">代码规范<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/其他/" title="其他">其他<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/博客分类目录/" title="博客分类目录">博客分类目录<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/叨叨系列/" title="叨叨系列">叨叨系列<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/开源代码分析/" title="开源代码分析">开源代码分析<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/开源库分析/" title="开源库分析">开源库分析<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/树莓派/" title="树莓派">树莓派<sup>4</sup></a></li>
		  
		
		  
			<li><a href="/categories/版本控制/" title="版本控制">版本控制<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/直播/" title="直播">直播<sup>6</sup></a></li>
		  
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">Tags</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/iOS-开源库分析/" title="iOS 开源库分析">iOS 开源库分析<sup>36</sup></a></li>
			
		
			
				<li><a href="/tags/Android-设计模式/" title="Android 设计模式">Android 设计模式<sup>29</sup></a></li>
			
		
			
				<li><a href="/tags/Objective-C-相关/" title="Objective C 相关">Objective C 相关<sup>24</sup></a></li>
			
		
			
				<li><a href="/tags/Android基础/" title="Android基础">Android基础<sup>21</sup></a></li>
			
		
			
				<li><a href="/tags/AOSP-源码/" title="AOSP 源码">AOSP 源码<sup>17</sup></a></li>
			
		
			
				<li><a href="/tags/Android-常用第三方库/" title="Android 常用第三方库">Android 常用第三方库<sup>15</sup></a></li>
			
		
			
				<li><a href="/tags/iOS-理论基础/" title="iOS 理论基础">iOS 理论基础<sup>14</sup></a></li>
			
		
			
				<li><a href="/tags/Hexo-使用/" title="Hexo 使用">Hexo 使用<sup>10</sup></a></li>
			
		
			
				<li><a href="/tags/ROS/" title="ROS">ROS<sup>9</sup></a></li>
			
		
			
				<li><a href="/tags/Android-动画进阶/" title="Android 动画进阶">Android 动画进阶<sup>8</sup></a></li>
			
		
			
				<li><a href="/tags/Android-JNI/" title="Android JNI">Android JNI<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/Android-绘图进阶/" title="Android 绘图进阶">Android 绘图进阶<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/Android性能优化/" title="Android性能优化">Android性能优化<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/Android-自动化测试/" title="Android 自动化测试">Android 自动化测试<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/OpenCV/" title="OpenCV">OpenCV<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/直播/" title="直播">直播<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/Android-开源源码/" title="Android 开源源码">Android 开源源码<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/Android-自定义View进阶/" title="Android 自定义View进阶">Android 自定义View进阶<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/树莓派/" title="树莓派">树莓派<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/iOS-进阶/" title="iOS 进阶">iOS 进阶<sup>4</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">Links</p>
    <ul>
        
          <li>
            
            	<a href="https://hexo.io" target="_blank" title="Hexo">Hexo</a>
            
          </li>
        
          <li>
            
            	<a href="https://pages.github.com/" target="_blank" title="GitHub">GitHub</a>
            
          </li>
        
          <li>
            
            	<a href="http://pf18.github.io/" target="_blank" title="PF18">PF18</a>
            
          </li>
        
          <li>
            
            	<a href="http://toutiao.io/" target="_blank" title="开发者头条">开发者头条</a>
            
          </li>
        
          <li>
            
            	<a href="http://www.jcodecraeer.com/" target="_blank" title="泡在网上的日子">泡在网上的日子</a>
            
          </li>
        
    </ul>
</div>

  


  <div class="rsspart">
	<a href="atom.xml" target="_blank" title="rss">RSS</a>
</div>

  
  <div class="tagcloudlist">
    <p class="asidetitle">Tag Cloud</p>
    <div class="tagcloudlist clearfix">
       <a href="/tags/AOSP-%E6%BA%90%E7%A0%81/" style="font-size: 17.14px;">AOSP 源码</a> <a href="/tags/Android-APK-%E7%AD%BE%E5%90%8D/" style="font-size: 10px;">Android APK 签名</a> <a href="/tags/Android-JNI/" style="font-size: 12.86px;">Android JNI</a> <a href="/tags/Android-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E8%BF%9B%E9%98%B6/" style="font-size: 10.71px;">Android 事件处理进阶</a> <a href="/tags/Android-%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6/" style="font-size: 13.57px;">Android 动画进阶</a> <a href="/tags/Android-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%80%E5%8F%91/" style="font-size: 10px;">Android 多线程开发</a> <a href="/tags/Android-%E5%B0%8F%E7%BB%8F%E9%AA%8C/" style="font-size: 10px;">Android 小经验</a> <a href="/tags/Android-%E5%B8%B8%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/" style="font-size: 16.43px;">Android 常用第三方库</a> <a href="/tags/Android-%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/" style="font-size: 10px;">Android 开发流程</a> <a href="/tags/Android-%E5%BC%80%E6%BA%90%E6%BA%90%E7%A0%81/" style="font-size: 12.14px;">Android 开源源码</a> <a href="/tags/Android-%E7%BB%98%E5%9B%BE%E8%BF%9B%E9%98%B6/" style="font-size: 12.86px;">Android 绘图进阶</a> <a href="/tags/Android-%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/" style="font-size: 12.86px;">Android 自动化测试</a> <a href="/tags/Android-%E8%87%AA%E5%AE%9A%E4%B9%89View%E8%BF%9B%E9%98%B6/" style="font-size: 12.14px;">Android 自定义View进阶</a> <a href="/tags/Android-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 19.29px;">Android 设计模式</a> <a href="/tags/Android%E5%85%B6%E4%BB%96/" style="font-size: 10px;">Android其他</a> <a href="/tags/Android%E5%9F%BA%E7%A1%80/" style="font-size: 17.86px;">Android基础</a> <a href="/tags/Android%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/" style="font-size: 10px;">Android开发流程</a> <a href="/tags/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" style="font-size: 12.86px;">Android性能优化</a> <a href="/tags/Android%E6%B7%B7%E6%B7%86%E6%8A%80%E6%9C%AF/" style="font-size: 10px;">Android混淆技术</a> <a href="/tags/Android%E8%B4%A8%E9%87%8F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/" style="font-size: 11.43px;">Android质量管理工具</a> <a href="/tags/Android%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/" style="font-size: 10px;">Android逆向工程</a> <a href="/tags/Git-github/" style="font-size: 10px;">Git && github</a> <a href="/tags/Hexo-%E4%BD%BF%E7%94%A8/" style="font-size: 15px;">Hexo 使用</a> <a href="/tags/JavaScript/" style="font-size: 10px;">JavaScript</a> <a href="/tags/Linux-%E4%BD%BF%E7%94%A8/" style="font-size: 10px;">Linux 使用</a> <a href="/tags/Objective-C-%E7%9B%B8%E5%85%B3/" style="font-size: 18.57px;">Objective C 相关</a> <a href="/tags/OpenCV/" style="font-size: 12.86px;">OpenCV</a> <a href="/tags/ROS/" style="font-size: 14.29px;">ROS</a> <a href="/tags/iOS-%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/" style="font-size: 10.71px;">iOS 工具使用</a> <a href="/tags/iOS-%E5%BC%80%E6%BA%90%E5%BA%93%E5%88%86%E6%9E%90/" style="font-size: 20px;">iOS 开源库分析</a> <a href="/tags/iOS-%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/" style="font-size: 15.71px;">iOS 理论基础</a> <a href="/tags/iOS-%E8%BF%9B%E9%98%B6/" style="font-size: 12.14px;">iOS 进阶</a> <a href="/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/" style="font-size: 10px;">代码规范</a> <a href="/tags/%E5%8D%9A%E5%AE%A2%E5%88%86%E7%B1%BB%E7%9B%AE%E5%BD%95/" style="font-size: 10.71px;">博客分类目录</a> <a href="/tags/%E5%8F%A8%E5%8F%A8%E7%B3%BB%E5%88%97/" style="font-size: 10px;">叨叨系列</a> <a href="/tags/%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/" style="font-size: 11.43px;">工具的使用</a> <a href="/tags/%E5%BC%80%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/" style="font-size: 10.71px;">开源代码分析</a> <a href="/tags/%E5%BC%80%E6%BA%90%E5%BA%93%E5%88%86%E6%9E%90/" style="font-size: 10px;">开源库分析</a> <a href="/tags/%E6%9D%82%E7%B1%BB/" style="font-size: 10px;">杂类</a> <a href="/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/" style="font-size: 12.14px;">树莓派</a> <a href="/tags/%E7%9B%B4%E6%92%AD/" style="font-size: 12.86px;">直播</a> <a href="/tags/%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/" style="font-size: 10.71px;">编程技巧</a> <a href="/tags/%E7%BD%91%E7%AB%99%E6%94%B6%E8%97%8F/" style="font-size: 10px;">网站收藏</a> <a href="/tags/%E9%87%8D%E8%A6%81%E6%8E%A7%E4%BB%B6/" style="font-size: 11.43px;">重要控件</a>
    </div>
  </div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
		
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/hsihohuang/kiddochan" target="_blank" title="Kiddochan">Kiddochan</a> © 2022 
		
		<a href="/about" target="_blank" title="Edgar">Edgar</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
        
    }
  });
});
</script>










<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?7c9443b0374f1cf6b1dbb5ab84d939cb";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="Back to Top"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
 </html>
