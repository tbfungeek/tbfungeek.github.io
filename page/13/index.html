
 <!DOCTYPE HTML>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
  
    <title>Edgar&#39;s Blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="Edgar">
    

    
    <meta name="description" content="Android | 全栈工程师">
<meta property="og:type" content="website">
<meta property="og:title" content="Edgar&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/page/13/index.html">
<meta property="og:site_name" content="Edgar&#39;s Blog">
<meta property="og:description" content="Android | 全栈工程师">
<meta property="og:locale">
<meta property="article:author" content="Edgar">
<meta name="twitter:card" content="summary">

    
    <link rel="alternative" href="atom.xml" title="Edgar&#39;s Blog" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/unnamed4_n_mSY_icon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/profile.png">
    <link rel="apple-touch-icon-precomposed" href="/img/profile.png">
    
    
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 6.2.0"></head>

  <body>
    <header>
      
<div>
		
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="Edgar&#39;s Blog">Edgar&#39;s Blog</a></h1>
				<h2 class="blog-motto"></h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="Menu">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
					<li>
 					
					<form class="search" action="/search/index.html" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" autocomplete="off" name="q" maxlength="20" placeholder="Search" />
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main">

   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/08/22/Android-源码分析之TODO-MVP-1/" title="Android 源码分析之TODO MVP" itemprop="url">Android 源码分析之TODO MVP</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Edgar" target="_blank" itemprop="author">Edgar</a>
		
  <p class="article-time">
    <time datetime="2016-08-22T04:30:23.000Z" itemprop="datePublished"> Published 2016-08-22</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>新的工作已经定了，在上班之前有点事情需要处理下，也趁机休息下，所以好几天没有更新博客了，但是心里还是惦记着今后需要写点什么，感觉还是有很多需要学习，但是接下来会偏向于通过实例来分析架构设计上的一些技术吧。总的来说今天的博客会从如下几方面进行展开：</p>
<ol>
<li>开源代码的架构分析</li>
<li>自定义View + 设计方面的知识 + MD 风格</li>
<li>AOSP源码分析</li>
<li>RectNative + H5</li>
<li>开源流媒体播放器源码分析<br>希望今年能够在架构上有所提高。</li>
</ol>
<p>好了，转入正题，今天想向大家介绍的是Google Sample发布的android开发中的框架设计例子，完整的源码大家可以在如下链接中下载：<br><a target="_blank" rel="noopener" href="https://github.com/googlesamples/android-architecture">Android Architecture</a></p>
<p>这里包括：</p>
<figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line">todo-mvp/ - Basic Model-View-Presenter architecture.</span><br><span class="line">todo-mvp-loaders/ - Based <span class="keyword">on</span> todo-mvp, fetches data <span class="keyword">using</span> Loaders.</span><br><span class="line">todo-mvp-databinding/ - Based <span class="keyword">on</span> todo-mvp, <span class="keyword">uses</span> the Data Binding <span class="keyword">Library</span>.</span><br><span class="line">todo-mvp-clean/ - Based <span class="keyword">on</span> todo-mvp, <span class="keyword">uses</span> concepts <span class="keyword">from</span> Clean Architecture.</span><br><span class="line">todo-mvp-dagger/ - Based <span class="keyword">on</span> todo-mvp, <span class="keyword">uses</span> Dagger2 <span class="keyword">for</span> Dependency Injection</span><br><span class="line">todo-mvp-contentproviders/ - Based <span class="keyword">on</span> todo-mvp-loaders, fetches data <span class="keyword">using</span> Loaders <span class="keyword">and</span> <span class="keyword">uses</span> Content Providers</span><br><span class="line">dev-todo-mvp-rxjava/ - Based <span class="keyword">on</span> todo-mvp, <span class="keyword">uses</span> RxJava <span class="keyword">for</span> concurrency <span class="keyword">and</span> data layer abstraction.</span><br><span class="line">todo-mvp-fragmentless/ - Based <span class="keyword">on</span> todo-mvp, <span class="keyword">uses</span> Android views instead <span class="keyword">of</span> Fragments.</span><br></pre></td></tr></table></figure>

<p>我们接下来将会一个个对上述代码进行分析，在继续往下看之前建议大家先看下我之前写的MVC，MVP，MVVM的介绍：<br>这篇博客将会对todo-mvp进行分析，它是后续所有的基础，在介绍之前我们先来看下它的类图：</p>
<p><img src="/2016/08/22/Android-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BTODO-MVP-1/1.png"><br>再和<br><img src="/2016/08/22/Android-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BTODO-MVP-1/2.png"><br>进行对比下这样会更容易理解整个MVP模式：</p>
<p>下面我们再来看下项目代码是怎么组织的：<br><img src="/2016/08/22/Android-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BTODO-MVP-1/3.png"></p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">addedittask</span></span><br><span class="line"><span class="attribute">statistics</span></span><br><span class="line"><span class="attribute">taskdetail</span></span><br><span class="line"><span class="attribute">tasks</span></span><br></pre></td></tr></table></figure>
<p>这三个包是并列的分别对应的是添加编辑任务的功能，统计功能，任务详细信息查询功能，任务展现功能，我们这边只以tasks（任务展现功能）功能作为分析对象。</p>
<p>module 层代码位于&#x2F;data  数据层上使用的是三级缓存：内存级别，本地数据级别，远程网络级别。<br>View 层代码位于TasksFragment中<br>Presenter 层代码位于TasksPresenter</p>
<p>TasksContract 是合同类，当中定义了MVP模式中使用到的View和Presenter接口。<br>TasksActivity创建了View和Presenter<br>BasePresenter 是所有Presenter的父接口<br>BaseView 是所有View层的父接口</p>
<p>了解了整个代码结构，大家就可以进行源码分析了。</p>
<p>首先看下BaseView这个接口，所有的View都会实现这个接口，它只有一个方法声明setPresenter，它是用于为View层设置Presenter。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">package com.example.android.architecture.blueprints.todoapp;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="symbol">BaseView</span>&lt;<span class="symbol">T</span>&gt; &#123;</span><br><span class="line">    <span class="built_in">void</span> setPresenter(T presenter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着我们同样看下所有Presenter的接口，这里同样也只有一个方法start。</p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.android.architecture.blueprints.todoapp;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BasePresenter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么这两个接口的作用是什么呢？我们可以在代码中看到所有的Presenter都会实现BasePresenter，所有的类都会实现BaseView。也就是说我们可以将所有的Presenter以及View的公共接口放置在这个地方声明。</p>
<p>我们接下来看下合同类：TasksContract<br>首先我们需要了解下合同类是用来干嘛的，合同类其实是用于规范View层和Presenter交互接口的类。其中合同类中View接口都是用于操作界面上的控制，Presenter接口基本上是通过Presenter来操作module层。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">TasksContract</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">interface</span> <span class="title">View</span> <span class="title">extends</span> <span class="title">BaseView</span>&lt;<span class="title">Presenter</span>&gt; &#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">setLoadingIndicator</span>(<span class="params">boolean active</span>)</span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">showTasks</span>(<span class="params">List&lt;Task&gt; tasks</span>)</span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">showAddTask</span>()</span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">showTaskDetailsUi</span>(<span class="params">String taskId</span>)</span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">showTaskMarkedComplete</span>()</span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">showTaskMarkedActive</span>()</span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">showCompletedTasksCleared</span>()</span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">showLoadingTasksError</span>()</span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">showNoTasks</span>()</span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">showActiveFilterLabel</span>()</span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">showCompletedFilterLabel</span>()</span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">showAllFilterLabel</span>()</span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">showNoActiveTasks</span>()</span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">showNoCompletedTasks</span>()</span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">showSuccessfullySavedMessage</span>()</span>;</span><br><span class="line">        <span class="function">boolean <span class="title">isActive</span>()</span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">showFilteringPopUpMenu</span>()</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">interface</span> <span class="title">Presenter</span> <span class="title">extends</span> <span class="title">BasePresenter</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">result</span>(<span class="params"><span class="built_in">int</span> requestCode, <span class="built_in">int</span> resultCode</span>)</span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">loadTasks</span>(<span class="params">boolean forceUpdate</span>)</span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">addNewTask</span>()</span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">openTaskDetails</span>(<span class="params">@NonNull Task requestedTask</span>)</span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">completeTask</span>(<span class="params">@NonNull Task completedTask</span>)</span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">activateTask</span>(<span class="params">@NonNull Task activeTask</span>)</span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">clearCompletedTasks</span>()</span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">setFiltering</span>(<span class="params">TasksFilterType requestType</span>)</span>;</span><br><span class="line">        <span class="function">TasksFilterType <span class="title">getFiltering</span>()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>介绍了重要的接口后我们看下具体的实现，首先看下TasksActivity：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public <span class="keyword">class</span> TasksActivity extends AppCompatActivity &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//................</span></span><br><span class="line">    <span class="keyword">private</span> TasksPresenter mTasksPresenter;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void on<span class="constructor">Create(Bundle <span class="params">savedInstanceState</span>)</span> &#123;</span><br><span class="line">        super.on<span class="constructor">Create(<span class="params">savedInstanceState</span>)</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//...........................</span></span><br><span class="line">        <span class="comment">//创建TaskFragment View</span></span><br><span class="line">        TasksFragment tasksFragment = (TasksFragment) get<span class="constructor">SupportFragmentManager()</span>.find<span class="constructor">FragmentById(R.<span class="params">id</span>.<span class="params">contentFrame</span>)</span>;</span><br><span class="line">        <span class="keyword">if</span> (tasksFragment<span class="operator"> == </span>null) &#123;</span><br><span class="line">            <span class="comment">//创建TaskFragment View</span></span><br><span class="line">            tasksFragment = <span class="module-access"><span class="module"><span class="identifier">TasksFragment</span>.</span></span><span class="keyword">new</span><span class="constructor">Instance()</span>;</span><br><span class="line">            <span class="module-access"><span class="module"><span class="identifier">ActivityUtils</span>.</span></span>add<span class="constructor">FragmentToActivity(<span class="params">getSupportFragmentManager</span>()</span>, tasksFragment, <span class="module-access"><span class="module"><span class="identifier">R</span>.</span></span>id.contentFrame);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个Presenter 这个Presenter持有一个Module以及一个TaskFragment这个View</span></span><br><span class="line">        mTasksPresenter = <span class="keyword">new</span> <span class="constructor">TasksPresenter(Injection.<span class="params">provideTasksRepository</span>(<span class="params">getApplicationContext</span>()</span>), tasksFragment);</span><br><span class="line">        <span class="comment">//..........................</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//..........................</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的逻辑很简单，就是创建一个TaskFragment作为View层。并将其添加到TasksActivity上，然后再创建一个TasksPresenter，TasksPresenter 中持有数据层TasksRepository，以及View层TasksFragment</p>
<p>我们先来看下View层：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TasksFragment</span> <span class="keyword">extends</span> <span class="title class_">Fragment</span> <span class="keyword">implements</span> <span class="title class_">TasksContract</span>.View &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TasksContract.Presenter mPresenter;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TasksAdapter mListAdapter;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> View mNoTasksView;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ImageView mNoTaskIcon;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TextView mNoTaskMainView;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TextView mNoTaskAddView;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> LinearLayout mTasksView;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TextView mFilteringLabelView;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TasksFragment</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// Requires empty public constructor</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> TasksFragment <span class="title function_">newInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TasksFragment</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(<span class="meta">@Nullable</span> Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        <span class="comment">//创建Adapter</span></span><br><span class="line">        mListAdapter = <span class="keyword">new</span> <span class="title class_">TasksAdapter</span>(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Task&gt;(<span class="number">0</span>), mItemListener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onResume</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onResume();</span><br><span class="line">        <span class="comment">//加载数据</span></span><br><span class="line">        mPresenter.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPresenter</span><span class="params">(<span class="meta">@NonNull</span> TasksContract.Presenter presenter)</span> &#123;</span><br><span class="line">        <span class="comment">//给当前的View设置Presenter</span></span><br><span class="line">        mPresenter = checkNotNull(presenter);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onActivityResult</span><span class="params">(<span class="type">int</span> requestCode, <span class="type">int</span> resultCode, Intent data)</span> &#123;</span><br><span class="line">        mPresenter.result(requestCode, resultCode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> View <span class="title function_">onCreateView</span><span class="params">(LayoutInflater inflater, ViewGroup container,</span></span><br><span class="line"><span class="params">                             Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="type">View</span> <span class="variable">root</span> <span class="operator">=</span> inflater.inflate(R.layout.tasks_frag, container, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Set up tasks view</span></span><br><span class="line">        <span class="type">ListView</span> <span class="variable">listView</span> <span class="operator">=</span> (ListView) root.findViewById(R.id.tasks_list);</span><br><span class="line">        listView.setAdapter(mListAdapter);</span><br><span class="line">        mFilteringLabelView = (TextView) root.findViewById(R.id.filteringLabel);</span><br><span class="line">        mTasksView = (LinearLayout) root.findViewById(R.id.tasksLL);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Set up  no tasks view</span></span><br><span class="line">        mNoTasksView = root.findViewById(R.id.noTasks);</span><br><span class="line">        mNoTaskIcon = (ImageView) root.findViewById(R.id.noTasksIcon);</span><br><span class="line">        mNoTaskMainView = (TextView) root.findViewById(R.id.noTasksMain);</span><br><span class="line">        mNoTaskAddView = (TextView) root.findViewById(R.id.noTasksAdd);</span><br><span class="line">        mNoTaskAddView.setOnClickListener(<span class="keyword">new</span> <span class="title class_">View</span>.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View v)</span> &#123;</span><br><span class="line">                mPresenter.addNewTask();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Set up floating action button</span></span><br><span class="line">        <span class="type">FloatingActionButton</span> <span class="variable">fab</span> <span class="operator">=</span> (FloatingActionButton) getActivity().findViewById(R.id.fab_add_task);</span><br><span class="line"></span><br><span class="line">        fab.setImageResource(R.drawable.ic_add);</span><br><span class="line">        fab.setOnClickListener(<span class="keyword">new</span> <span class="title class_">View</span>.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View v)</span> &#123;</span><br><span class="line">                mPresenter.addNewTask();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Set up progress indicator</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">ScrollChildSwipeRefreshLayout</span> <span class="variable">swipeRefreshLayout</span> <span class="operator">=</span> (ScrollChildSwipeRefreshLayout) root.findViewById(R.id.refresh_layout);</span><br><span class="line">        swipeRefreshLayout.setColorSchemeColors(</span><br><span class="line">                ContextCompat.getColor(getActivity(), R.color.colorPrimary),</span><br><span class="line">                ContextCompat.getColor(getActivity(), R.color.colorAccent),</span><br><span class="line">                ContextCompat.getColor(getActivity(), R.color.colorPrimaryDark)</span><br><span class="line">        );</span><br><span class="line">        <span class="comment">// Set the scrolling view in the custom SwipeRefreshLayout.</span></span><br><span class="line">        swipeRefreshLayout.setScrollUpChild(listView);</span><br><span class="line">        swipeRefreshLayout.setOnRefreshListener(<span class="keyword">new</span> <span class="title class_">SwipeRefreshLayout</span>.OnRefreshListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onRefresh</span><span class="params">()</span> &#123;</span><br><span class="line">                mPresenter.loadTasks(<span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        setHasOptionsMenu(<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...........................</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>View层中最重要的是setPresenter这个方法，通过这个方法让View层持有Presenter的引用，有了Presenter引用就可以将View层中的业务逻辑移到Presenter上，从而保证View层的轻便。<br>而View层中的方法大部分是和页面上控件操作有关。实现这些方法供Presenter调用。</p>
<p>我们再来看下数据层：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public <span class="keyword">class</span> Injection &#123;</span><br><span class="line"></span><br><span class="line">    public static TasksRepository provide<span class="constructor">TasksRepository(@NonNull Context <span class="params">context</span>)</span> &#123;</span><br><span class="line">        check<span class="constructor">NotNull(<span class="params">context</span>)</span>;</span><br><span class="line">        return <span class="module-access"><span class="module"><span class="identifier">TasksRepository</span>.</span></span>get<span class="constructor">Instance(TasksRemoteDataSource.<span class="params">getInstance</span>()</span>,<span class="module-access"><span class="module"><span class="identifier">TasksLocalDataSource</span>.</span></span>get<span class="constructor">Instance(<span class="params">context</span>)</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们先来看下TasksDataSource，这个是数据层的一个接口，这里定义了两个回调接口，这两个回调接口用于在数据层完成任务之后回调通知Presenter：</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">public</span> <span class="selector-tag">interface</span> <span class="selector-tag">TasksDataSource</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="selector-tag">interface</span> <span class="selector-tag">LoadTasksCallback</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="selector-tag">void</span> <span class="selector-tag">onTasksLoaded</span>(List&lt;Task&gt; tasks);</span><br><span class="line"></span><br><span class="line">        <span class="selector-tag">void</span> <span class="selector-tag">onDataNotAvailable</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="selector-tag">interface</span> <span class="selector-tag">GetTaskCallback</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="selector-tag">void</span> <span class="selector-tag">onTaskLoaded</span>(Task task);</span><br><span class="line"></span><br><span class="line">        <span class="selector-tag">void</span> <span class="selector-tag">onDataNotAvailable</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-tag">void</span> <span class="selector-tag">getTasks</span>(<span class="variable">@NonNull</span> LoadTasksCallback callback);</span><br><span class="line">    <span class="selector-tag">void</span> <span class="selector-tag">getTask</span>(<span class="variable">@NonNull</span> String taskId, <span class="variable">@NonNull</span> GetTaskCallback callback);</span><br><span class="line">    <span class="selector-tag">void</span> <span class="selector-tag">saveTask</span>(<span class="variable">@NonNull</span> Task task);</span><br><span class="line">    <span class="selector-tag">void</span> <span class="selector-tag">completeTask</span>(<span class="variable">@NonNull</span> Task task);</span><br><span class="line">    <span class="selector-tag">void</span> <span class="selector-tag">completeTask</span>(<span class="variable">@NonNull</span> String taskId);</span><br><span class="line">    <span class="selector-tag">void</span> <span class="selector-tag">activateTask</span>(<span class="variable">@NonNull</span> Task task);</span><br><span class="line">    <span class="selector-tag">void</span> <span class="selector-tag">activateTask</span>(<span class="variable">@NonNull</span> String taskId);</span><br><span class="line">    <span class="selector-tag">void</span> <span class="selector-tag">clearCompletedTasks</span>();</span><br><span class="line">    <span class="selector-tag">void</span> <span class="selector-tag">refreshTasks</span>();</span><br><span class="line">    <span class="selector-tag">void</span> <span class="selector-tag">deleteAllTasks</span>();</span><br><span class="line">    <span class="selector-tag">void</span> <span class="selector-tag">deleteTask</span>(<span class="variable">@NonNull</span> String taskId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>介绍了TasksDataSource我们就可以看下TasksRepository类的实现了。它有两个重要的实例对象mTasksRemoteDataSource，用于模拟网络层数据来源。mTasksLocalDataSource 用于表示本地数据来源这里代表的是数据库。<br>mCachedTasks 是内存缓存，使用mCacheIsDirty表示缓存内数据是否有效。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TasksRepository</span> <span class="keyword">implements</span> <span class="title class_">TasksDataSource</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="title class_">TasksRepository</span> <span class="variable constant_">INSTANCE</span> = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//模拟网络层数据来源</span></span><br><span class="line">    <span class="keyword">private</span> final <span class="title class_">TasksDataSource</span> mTasksRemoteDataSource;</span><br><span class="line">    <span class="comment">//模拟本地数据来源</span></span><br><span class="line">    <span class="keyword">private</span> final <span class="title class_">TasksDataSource</span> mTasksLocalDataSource;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 内存缓存</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title class_">Map</span>&lt;<span class="title class_">String</span>, <span class="title class_">Task</span>&gt; mCachedTasks;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于表示当前缓存数据是否有效</span></span><br><span class="line"><span class="comment">     * Marks the cache as invalid, to force an update the next time data is requested. This variable</span></span><br><span class="line"><span class="comment">     * has package local visibility so it can be accessed from tests.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">boolean</span> mCacheIsDirty = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title class_">TasksRepository</span>(<span class="meta">@NonNull</span> <span class="title class_">TasksDataSource</span> tasksRemoteDataSource,</span><br><span class="line">                            <span class="meta">@NonNull</span> <span class="title class_">TasksDataSource</span> tasksLocalDataSource) &#123;</span><br><span class="line">        mTasksRemoteDataSource = <span class="title function_">checkNotNull</span>(tasksRemoteDataSource);</span><br><span class="line">        mTasksLocalDataSource = <span class="title function_">checkNotNull</span>(tasksLocalDataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the single instance of this class, creating it if necessary.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tasksRemoteDataSource the backend data source</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tasksLocalDataSource  the device storage data source</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the &#123;<span class="doctag">@link</span> TasksRepository&#125; instance</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="comment">// 使用一个单例创建TasksRepository</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="title class_">TasksRepository</span> <span class="title function_">getInstance</span>(<span class="params">TasksDataSource tasksRemoteDataSource,</span></span><br><span class="line"><span class="params">                                              TasksDataSource tasksLocalDataSource</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable constant_">INSTANCE</span> == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="variable constant_">INSTANCE</span> = <span class="keyword">new</span> <span class="title class_">TasksRepository</span>(tasksRemoteDataSource, tasksLocalDataSource);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable constant_">INSTANCE</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Used to force &#123;<span class="doctag">@link</span> #getInstance(TasksDataSource, TasksDataSource)&#125; to create a new instance</span></span><br><span class="line"><span class="comment">     * next time it&#x27;s called.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="title function_">destroyInstance</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable constant_">INSTANCE</span> = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从缓存，本地数据源（SQLite）或者远程数据源中获取 Task</span></span><br><span class="line"><span class="comment">     * Gets tasks from cache, local data source (SQLite) or remote data source, whichever is</span></span><br><span class="line"><span class="comment">     * available first.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * Note: &#123;<span class="doctag">@link</span> LoadTasksCallback#onDataNotAvailable()&#125; is fired if all data sources fail to</span></span><br><span class="line"><span class="comment">     * get the data.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">getTasks</span>(<span class="params"><span class="meta">@NonNull</span> final LoadTasksCallback callback</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="title function_">checkNotNull</span>(callback);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Respond immediately with cache if available and not dirty</span></span><br><span class="line">        <span class="comment">// 如果内存中有内容并且缓存中的数据是可用的那么直接将缓存中的内容传递出去</span></span><br><span class="line">        <span class="keyword">if</span> (mCachedTasks != <span class="literal">null</span> &amp;&amp; !mCacheIsDirty) &#123;</span><br><span class="line">            callback.<span class="title function_">onTasksLoaded</span>(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(mCachedTasks.<span class="title function_">values</span>()));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mCacheIsDirty) &#123;</span><br><span class="line">            <span class="comment">///如果缓存中的数据不可用那么需要从网络中获取新的数据</span></span><br><span class="line">            <span class="comment">// If the cache is dirty we need to fetch new data from the network.</span></span><br><span class="line">            <span class="title function_">getTasksFromRemoteDataSource</span>(callback);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Query the local storage if available. If not, query the network.</span></span><br><span class="line">            <span class="comment">//这个一般发生在第一次，也就是这时候mCachedTasks = null 并且mCacheIsDirty = false</span></span><br><span class="line">            mTasksLocalDataSource.<span class="title function_">getTasks</span>(<span class="keyword">new</span> <span class="title class_">LoadTasksCallback</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">onTasksLoaded</span>(<span class="params">List&lt;Task&gt; tasks</span>) &#123;</span><br><span class="line">                    <span class="comment">//从数据库中加载数据到缓存</span></span><br><span class="line">                    <span class="title function_">refreshCache</span>(tasks);</span><br><span class="line">                    callback.<span class="title function_">onTasksLoaded</span>(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(mCachedTasks.<span class="title function_">values</span>()));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">onDataNotAvailable</span>(<span class="params"></span>) &#123;</span><br><span class="line">                    <span class="comment">//如果数据库中没有数据那么就从缓存中获取</span></span><br><span class="line">                    <span class="title function_">getTasksFromRemoteDataSource</span>(callback);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 要保存的时候将数据存储到远程数据库，本地数据库，以及缓存中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">saveTask</span>(<span class="params"><span class="meta">@NonNull</span> Task task</span>) &#123;</span><br><span class="line">        <span class="title function_">checkNotNull</span>(task);</span><br><span class="line">        <span class="comment">//保存到远程数据源中</span></span><br><span class="line">        mTasksRemoteDataSource.<span class="title function_">saveTask</span>(task);</span><br><span class="line">        <span class="comment">//保存到本地数据库中</span></span><br><span class="line">        mTasksLocalDataSource.<span class="title function_">saveTask</span>(task);</span><br><span class="line">        <span class="comment">// Do in memory cache update to keep the app UI up to date</span></span><br><span class="line">        <span class="comment">//保存到缓存中</span></span><br><span class="line">        <span class="keyword">if</span> (mCachedTasks == <span class="literal">null</span>) &#123;</span><br><span class="line">            mCachedTasks = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        mCachedTasks.<span class="title function_">put</span>(task.<span class="title function_">getId</span>(), task);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  添加完成任务，也就是将complete标志为设置为true</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">completeTask</span>(<span class="params"><span class="meta">@NonNull</span> Task task</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="title function_">checkNotNull</span>(task);</span><br><span class="line">        mTasksRemoteDataSource.<span class="title function_">completeTask</span>(task);</span><br><span class="line">        mTasksLocalDataSource.<span class="title function_">completeTask</span>(task);</span><br><span class="line">        <span class="title class_">Task</span> completedTask = <span class="keyword">new</span> <span class="title class_">Task</span>(task.<span class="title function_">getTitle</span>(), task.<span class="title function_">getDescription</span>(), task.<span class="title function_">getId</span>(), <span class="literal">true</span>);</span><br><span class="line">        <span class="comment">// Do in memory cache update to keep the app UI up to date</span></span><br><span class="line">        <span class="keyword">if</span> (mCachedTasks == <span class="literal">null</span>) &#123;</span><br><span class="line">            mCachedTasks = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        mCachedTasks.<span class="title function_">put</span>(task.<span class="title function_">getId</span>(), completedTask);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">completeTask</span>(<span class="params"><span class="meta">@NonNull</span> <span class="built_in">String</span> taskId</span>) &#123;</span><br><span class="line">        <span class="title function_">checkNotNull</span>(taskId);</span><br><span class="line">        <span class="title function_">completeTask</span>(<span class="title function_">getTaskWithId</span>(taskId));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加激活任务，实现上是简单得将complete设置成false</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">activateTask</span>(<span class="params"><span class="meta">@NonNull</span> Task task</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="title function_">checkNotNull</span>(task);</span><br><span class="line">        mTasksRemoteDataSource.<span class="title function_">activateTask</span>(task);</span><br><span class="line">        mTasksLocalDataSource.<span class="title function_">activateTask</span>(task);</span><br><span class="line">        <span class="title class_">Task</span> activeTask = <span class="keyword">new</span> <span class="title class_">Task</span>(task.<span class="title function_">getTitle</span>(), task.<span class="title function_">getDescription</span>(), task.<span class="title function_">getId</span>());</span><br><span class="line">        <span class="comment">// Do in memory cache update to keep the app UI up to date</span></span><br><span class="line">        <span class="keyword">if</span> (mCachedTasks == <span class="literal">null</span>) &#123;</span><br><span class="line">            mCachedTasks = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        mCachedTasks.<span class="title function_">put</span>(task.<span class="title function_">getId</span>(), activeTask);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">activateTask</span>(<span class="params"><span class="meta">@NonNull</span> <span class="built_in">String</span> taskId</span>) &#123;</span><br><span class="line">        <span class="title function_">checkNotNull</span>(taskId);</span><br><span class="line">        <span class="title function_">activateTask</span>(<span class="title function_">getTaskWithId</span>(taskId));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 清除完成的任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">clearCompletedTasks</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">        mTasksRemoteDataSource.<span class="title function_">clearCompletedTasks</span>();</span><br><span class="line">        mTasksLocalDataSource.<span class="title function_">clearCompletedTasks</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Do in memory cache update to keep the app UI up to date</span></span><br><span class="line">        <span class="keyword">if</span> (mCachedTasks == <span class="literal">null</span>) &#123;</span><br><span class="line">            mCachedTasks = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title class_">Iterator</span>&lt;<span class="title class_">Map</span>.<span class="property">Entry</span>&lt;<span class="title class_">String</span>, <span class="title class_">Task</span>&gt;&gt; it = mCachedTasks.<span class="title function_">entrySet</span>().<span class="title function_">iterator</span>();</span><br><span class="line">        <span class="keyword">while</span> (it.<span class="title function_">hasNext</span>()) &#123;</span><br><span class="line">            <span class="title class_">Map</span>.<span class="property">Entry</span>&lt;<span class="title class_">String</span>, <span class="title class_">Task</span>&gt; entry = it.<span class="title function_">next</span>();</span><br><span class="line">            <span class="keyword">if</span> (entry.<span class="title function_">getValue</span>().<span class="title function_">isCompleted</span>()) &#123;</span><br><span class="line">                it.<span class="title function_">remove</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Gets tasks from local data source (sqlite) unless the table is new or empty. In that case it</span></span><br><span class="line"><span class="comment">     * uses the network data source. This is done to simplify the sample.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * Note: &#123;<span class="doctag">@link</span> LoadTasksCallback#onDataNotAvailable()&#125; is fired if both data sources fail to</span></span><br><span class="line"><span class="comment">     * get the data.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  依次从缓存，本地，远程中查找某个任务</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> <span class="variable">taskId</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> <span class="variable">callback</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">getTask</span>(<span class="params"><span class="meta">@NonNull</span> final <span class="built_in">String</span> taskId, <span class="meta">@NonNull</span> final GetTaskCallback callback</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="title function_">checkNotNull</span>(taskId);</span><br><span class="line">        <span class="title function_">checkNotNull</span>(callback);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从缓存中获取指定任务id的任务</span></span><br><span class="line">        <span class="title class_">Task</span> cachedTask = <span class="title function_">getTaskWithId</span>(taskId);</span><br><span class="line">        <span class="comment">// Respond immediately with cache if available</span></span><br><span class="line">        <span class="keyword">if</span> (cachedTask != <span class="literal">null</span>) &#123;</span><br><span class="line">            callback.<span class="title function_">onTaskLoaded</span>(cachedTask);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从本地数据源以及远程数据源获取指定id的任务数据</span></span><br><span class="line">        <span class="comment">// Load from server/persisted if needed.</span></span><br><span class="line">        <span class="comment">// Is the task in the local data source? If not, query the network.</span></span><br><span class="line">        mTasksLocalDataSource.<span class="title function_">getTask</span>(taskId, <span class="keyword">new</span> <span class="title class_">GetTaskCallback</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">onTaskLoaded</span>(<span class="params">Task task</span>) &#123;</span><br><span class="line">                callback.<span class="title function_">onTaskLoaded</span>(task);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">onDataNotAvailable</span>(<span class="params"></span>) &#123;</span><br><span class="line">                mTasksRemoteDataSource.<span class="title function_">getTask</span>(taskId, <span class="keyword">new</span> <span class="title class_">GetTaskCallback</span>() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">onTaskLoaded</span>(<span class="params">Task task</span>) &#123;</span><br><span class="line">                        callback.<span class="title function_">onTaskLoaded</span>(task);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">onDataNotAvailable</span>(<span class="params"></span>) &#123;</span><br><span class="line">                        callback.<span class="title function_">onDataNotAvailable</span>();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将当前缓存设置为不可用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">refreshTasks</span>(<span class="params"></span>) &#123;</span><br><span class="line">        mCacheIsDirty = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除远程，本地，以及缓存中的任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">deleteAllTasks</span>(<span class="params"></span>) &#123;</span><br><span class="line">        mTasksRemoteDataSource.<span class="title function_">deleteAllTasks</span>();</span><br><span class="line">        mTasksLocalDataSource.<span class="title function_">deleteAllTasks</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mCachedTasks == <span class="literal">null</span>) &#123;</span><br><span class="line">            mCachedTasks = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        mCachedTasks.<span class="title function_">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将某个任务从缓存，本地数据库，远程数据库中删除</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> <span class="variable">taskId</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">deleteTask</span>(<span class="params"><span class="meta">@NonNull</span> <span class="built_in">String</span> taskId</span>) &#123;</span><br><span class="line">        mTasksRemoteDataSource.<span class="title function_">deleteTask</span>(<span class="title function_">checkNotNull</span>(taskId));</span><br><span class="line">        mTasksLocalDataSource.<span class="title function_">deleteTask</span>(<span class="title function_">checkNotNull</span>(taskId));</span><br><span class="line">        mCachedTasks.<span class="title function_">remove</span>(taskId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从远程中加载任务并添加到缓存和本地数据库</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> <span class="variable">callback</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">void</span> <span class="title function_">getTasksFromRemoteDataSource</span>(<span class="params"><span class="meta">@NonNull</span> final LoadTasksCallback callback</span>) &#123;</span><br><span class="line">        mTasksRemoteDataSource.<span class="title function_">getTasks</span>(<span class="keyword">new</span> <span class="title class_">LoadTasksCallback</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">onTasksLoaded</span>(<span class="params">List&lt;Task&gt; tasks</span>) &#123;</span><br><span class="line">                <span class="comment">///从远程加载数据后添加到缓存和本地数据库</span></span><br><span class="line">                <span class="title function_">refreshCache</span>(tasks);</span><br><span class="line">                <span class="title function_">refreshLocalDataSource</span>(tasks);</span><br><span class="line">                callback.<span class="title function_">onTasksLoaded</span>(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(mCachedTasks.<span class="title function_">values</span>()));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">onDataNotAvailable</span>(<span class="params"></span>) &#123;</span><br><span class="line">                callback.<span class="title function_">onDataNotAvailable</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用参数的tasks来填充mCachedTasks</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> <span class="variable">tasks</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">void</span> <span class="title function_">refreshCache</span>(<span class="params">List&lt;Task&gt; tasks</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mCachedTasks == <span class="literal">null</span>) &#123;</span><br><span class="line">            mCachedTasks = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        mCachedTasks.<span class="title function_">clear</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="title class_">Task</span> task : tasks) &#123;</span><br><span class="line">            mCachedTasks.<span class="title function_">put</span>(task.<span class="title function_">getId</span>(), task);</span><br><span class="line">        &#125;</span><br><span class="line">        mCacheIsDirty = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  用参数的tasks来填充mTasksLocalDataSource</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> <span class="variable">tasks</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">void</span> <span class="title function_">refreshLocalDataSource</span>(<span class="params">List&lt;Task&gt; tasks</span>) &#123;</span><br><span class="line">        mTasksLocalDataSource.<span class="title function_">deleteAllTasks</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="title class_">Task</span> task : tasks) &#123;</span><br><span class="line">            mTasksLocalDataSource.<span class="title function_">saveTask</span>(task);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从缓存中获取指定id的任务</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id  要获取任务的id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title class_">Task</span> <span class="title function_">getTaskWithId</span>(<span class="params"><span class="meta">@NonNull</span> <span class="built_in">String</span> id</span>) &#123;</span><br><span class="line">        <span class="title function_">checkNotNull</span>(id);</span><br><span class="line">        <span class="keyword">if</span> (mCachedTasks == <span class="literal">null</span> || mCachedTasks.<span class="title function_">isEmpty</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mCachedTasks.<span class="title function_">get</span>(id);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上述的好处是我们可以随便更换数据源数据获取的底层实现。而不需要改动到其他部分，只要我们修改方案的时候按照接口定义规范进行实现即可。这样对于多人开发也是有很大好处的，和其他部分解耦了就可以单独开发了。</p>
<p>我们再来看下Presenter表示层：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public <span class="keyword">class</span> TasksPresenter implements TasksContract.Presenter &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> final TasksRepository mTasksRepository;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> final TasksContract.View mTasksView;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TasksFilterType mCurrentFiltering = TasksFilterType.ALL_TASKS;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> boolean mFirstLoad = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    public <span class="constructor">TasksPresenter(@NonNull TasksRepository <span class="params">tasksRepository</span>, @NonNull TasksContract.View <span class="params">tasksView</span>)</span> &#123;</span><br><span class="line">        <span class="comment">//数据层</span></span><br><span class="line">        mTasksRepository = check<span class="constructor">NotNull(<span class="params">tasksRepository</span>, <span class="string">&quot;tasksRepository cannot be null&quot;</span>)</span>;</span><br><span class="line">        <span class="comment">//视图层</span></span><br><span class="line">        mTasksView = check<span class="constructor">NotNull(<span class="params">tasksView</span>, <span class="string">&quot;tasksView cannot be null!&quot;</span>)</span>;</span><br><span class="line">        <span class="comment">//将Presenter赋值给View层</span></span><br><span class="line">        mTasksView.set<span class="constructor">Presenter(<span class="params">this</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//加载任务数据</span></span><br><span class="line">    @Override</span><br><span class="line">    public void start<span class="literal">()</span> &#123;</span><br><span class="line">        load<span class="constructor">Tasks(<span class="params">false</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理返回值</span></span><br><span class="line">    @Override</span><br><span class="line">    public void result(<span class="built_in">int</span> requestCode, <span class="built_in">int</span> resultCode) &#123;</span><br><span class="line">        <span class="comment">// If a task was successfully added, show snackbar</span></span><br><span class="line">        <span class="keyword">if</span> (AddEditTaskActivity.REQUEST_ADD_TASK<span class="operator"> == </span>requestCode<span class="operator"> &amp;&amp; </span>Activity.RESULT_OK<span class="operator"> == </span>resultCode) &#123;</span><br><span class="line">            <span class="comment">//显示SnakeBar</span></span><br><span class="line">            mTasksView.show<span class="constructor">SuccessfullySavedMessage()</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//加载数据</span></span><br><span class="line">    @Override</span><br><span class="line">    public void load<span class="constructor">Tasks(<span class="params">boolean</span> <span class="params">forceUpdate</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// Simplification for sample: a network reload will be forced on first load.</span></span><br><span class="line">        load<span class="constructor">Tasks(<span class="params">forceUpdate</span> <span class="operator">||</span> <span class="params">mFirstLoad</span>, <span class="params">true</span>)</span>;</span><br><span class="line">        mFirstLoad = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @param forceUpdate   Pass in true to refresh the data in the &#123;@link TasksDataSource&#125;</span></span><br><span class="line"><span class="comment">     * @param showLoadingUI Pass in true to display a loading icon in the UI</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//加载数据</span></span><br><span class="line">    <span class="keyword">private</span> void load<span class="constructor">Tasks(<span class="params">boolean</span> <span class="params">forceUpdate</span>, <span class="params">final</span> <span class="params">boolean</span> <span class="params">showLoadingUI</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (showLoadingUI) &#123;</span><br><span class="line">            mTasksView.set<span class="constructor">LoadingIndicator(<span class="params">true</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (forceUpdate) &#123;</span><br><span class="line">            mTasksRepository.refresh<span class="constructor">Tasks()</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// The network request might be handled in a different thread so make sure Espresso knows</span></span><br><span class="line">        <span class="comment">// that the app is busy until the response is handled.</span></span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">EspressoIdlingResource</span>.</span></span>increment<span class="literal">()</span>; <span class="comment">// App is busy until further notice</span></span><br><span class="line"></span><br><span class="line">        mTasksRepository.get<span class="constructor">Tasks(<span class="params">new</span> TasksDataSource.LoadTasksCallback()</span> &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void on<span class="constructor">TasksLoaded(List&lt;Task&gt; <span class="params">tasks</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//创建需要显示的Task</span></span><br><span class="line">                List&lt;Task&gt; tasksToShow = <span class="keyword">new</span> ArrayList&lt;Task&gt;<span class="literal">()</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// This callback may be called twice, once for the cache and once for loading</span></span><br><span class="line">                <span class="comment">// the data from the server API, so we check before decrementing, otherwise</span></span><br><span class="line">                <span class="comment">// it throws &quot;Counter has been corrupted!&quot; exception.</span></span><br><span class="line">                <span class="keyword">if</span> (!<span class="module-access"><span class="module"><span class="identifier">EspressoIdlingResource</span>.</span></span>get<span class="constructor">IdlingResource()</span>.is<span class="constructor">IdleNow()</span>) &#123;</span><br><span class="line">                    <span class="module-access"><span class="module"><span class="identifier">EspressoIdlingResource</span>.</span></span>decrement<span class="literal">()</span>; <span class="comment">// Set app as idle.</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// We filter the tasks based on the requestType</span></span><br><span class="line">                <span class="keyword">for</span> (Task task : tasks) &#123;</span><br><span class="line">                    <span class="comment">//根据mCurrentFiltering 显示那种类型的任务</span></span><br><span class="line">                    switch (mCurrentFiltering) &#123;</span><br><span class="line">                        case ALL_TASKS:</span><br><span class="line">                            tasksToShow.add(task);</span><br><span class="line">                            break;</span><br><span class="line">                        case ACTIVE_TASKS:</span><br><span class="line">                            <span class="keyword">if</span> (task.is<span class="constructor">Active()</span>) &#123;</span><br><span class="line">                                tasksToShow.add(task);</span><br><span class="line">                            &#125;</span><br><span class="line">                            break;</span><br><span class="line">                        case COMPLETED_TASKS:</span><br><span class="line">                            <span class="keyword">if</span> (task.is<span class="constructor">Completed()</span>) &#123;</span><br><span class="line">                                tasksToShow.add(task);</span><br><span class="line">                            &#125;</span><br><span class="line">                            break;</span><br><span class="line">                        default:</span><br><span class="line">                            tasksToShow.add(task);</span><br><span class="line">                            break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// The view may not be able to handle UI updates anymore</span></span><br><span class="line">                <span class="keyword">if</span> (!mTasksView.is<span class="constructor">Active()</span>) &#123;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (showLoadingUI) &#123;</span><br><span class="line">                    mTasksView.set<span class="constructor">LoadingIndicator(<span class="params">false</span>)</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//处理这些任务</span></span><br><span class="line">                process<span class="constructor">Tasks(<span class="params">tasksToShow</span>)</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void on<span class="constructor">DataNotAvailable()</span> &#123;</span><br><span class="line">                <span class="comment">// The view may not be able to handle UI updates anymore</span></span><br><span class="line">                <span class="keyword">if</span> (!mTasksView.is<span class="constructor">Active()</span>) &#123;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">                mTasksView.show<span class="constructor">LoadingTasksError()</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> void process<span class="constructor">Tasks(List&lt;Task&gt; <span class="params">tasks</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (tasks.is<span class="constructor">Empty()</span>) &#123;</span><br><span class="line">            <span class="comment">// Show a message indicating there are no tasks for that filter type.</span></span><br><span class="line">            <span class="comment">//根据类型显示当前需要显示的空加载信息</span></span><br><span class="line">            process<span class="constructor">EmptyTasks()</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Show the list of tasks</span></span><br><span class="line">            <span class="comment">//显示任务</span></span><br><span class="line">            mTasksView.show<span class="constructor">Tasks(<span class="params">tasks</span>)</span>;</span><br><span class="line">            <span class="comment">// Set the filter label&#x27;s text.</span></span><br><span class="line">            show<span class="constructor">FilterLabel()</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> void show<span class="constructor">FilterLabel()</span> &#123;</span><br><span class="line">        switch (mCurrentFiltering) &#123;</span><br><span class="line">            case ACTIVE_TASKS:</span><br><span class="line">                mTasksView.show<span class="constructor">ActiveFilterLabel()</span>;</span><br><span class="line">                break;</span><br><span class="line">            case COMPLETED_TASKS:</span><br><span class="line">                mTasksView.show<span class="constructor">CompletedFilterLabel()</span>;</span><br><span class="line">                break;</span><br><span class="line">            default:</span><br><span class="line">                mTasksView.show<span class="constructor">AllFilterLabel()</span>;</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> void process<span class="constructor">EmptyTasks()</span> &#123;</span><br><span class="line">        switch (mCurrentFiltering) &#123;</span><br><span class="line">            case ACTIVE_TASKS:</span><br><span class="line">                mTasksView.show<span class="constructor">NoActiveTasks()</span>;</span><br><span class="line">                break;</span><br><span class="line">            case COMPLETED_TASKS:</span><br><span class="line">                mTasksView.show<span class="constructor">NoCompletedTasks()</span>;</span><br><span class="line">                break;</span><br><span class="line">            default:</span><br><span class="line">                mTasksView.show<span class="constructor">NoTasks()</span>;</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//AddEditTaskActivity</span></span><br><span class="line">    @Override</span><br><span class="line">    public void add<span class="constructor">NewTask()</span> &#123;</span><br><span class="line">        mTasksView.show<span class="constructor">AddTask()</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//TaskDetailActivity</span></span><br><span class="line">    @Override</span><br><span class="line">    public void <span class="keyword">open</span><span class="constructor">TaskDetails(@NonNull Task <span class="params">requestedTask</span>)</span> &#123;</span><br><span class="line">        check<span class="constructor">NotNull(<span class="params">requestedTask</span>, <span class="string">&quot;requestedTask cannot be null!&quot;</span>)</span>;</span><br><span class="line">        mTasksView.show<span class="constructor">TaskDetailsUi(<span class="params">requestedTask</span>.<span class="params">getId</span>()</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void complete<span class="constructor">Task(@NonNull Task <span class="params">completedTask</span>)</span> &#123;</span><br><span class="line">        check<span class="constructor">NotNull(<span class="params">completedTask</span>, <span class="string">&quot;completedTask cannot be null!&quot;</span>)</span>;</span><br><span class="line">        mTasksRepository.complete<span class="constructor">Task(<span class="params">completedTask</span>)</span>;</span><br><span class="line">        mTasksView.show<span class="constructor">TaskMarkedComplete()</span>;</span><br><span class="line">        load<span class="constructor">Tasks(<span class="params">false</span>, <span class="params">false</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void activate<span class="constructor">Task(@NonNull Task <span class="params">activeTask</span>)</span> &#123;</span><br><span class="line">        check<span class="constructor">NotNull(<span class="params">activeTask</span>, <span class="string">&quot;activeTask cannot be null!&quot;</span>)</span>;</span><br><span class="line">        mTasksRepository.activate<span class="constructor">Task(<span class="params">activeTask</span>)</span>;</span><br><span class="line">        mTasksView.show<span class="constructor">TaskMarkedActive()</span>;</span><br><span class="line">        load<span class="constructor">Tasks(<span class="params">false</span>, <span class="params">false</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void clear<span class="constructor">CompletedTasks()</span> &#123;</span><br><span class="line">        mTasksRepository.clear<span class="constructor">CompletedTasks()</span>;</span><br><span class="line">        mTasksView.show<span class="constructor">CompletedTasksCleared()</span>;</span><br><span class="line">        load<span class="constructor">Tasks(<span class="params">false</span>, <span class="params">false</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets the current task filtering type.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param requestType Can be &#123;@link TasksFilterType#ALL_TASKS&#125;,</span></span><br><span class="line"><span class="comment">     *                    &#123;@link TasksFilterType#COMPLETED_TASKS&#125;, or</span></span><br><span class="line"><span class="comment">     *                    &#123;@link TasksFilterType#ACTIVE_TASKS&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    @Override</span><br><span class="line">    public void set<span class="constructor">Filtering(TasksFilterType <span class="params">requestType</span>)</span> &#123;</span><br><span class="line">        mCurrentFiltering = requestType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public TasksFilterType get<span class="constructor">Filtering()</span> &#123;</span><br><span class="line">        return mCurrentFiltering;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>它持有View层和数据层，这些方法提供给View层调用，绝大部分的代码是调用View层以及数据层的实现，它只负责整个状态的逻辑。数据层和Presenter层的交互使用的是Callback回调机制，回调接口在数据层接口中定义的。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Android-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">Android 源码分析</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/Android-开源源码/">Android 开源源码</a>
  </div>

</div>



<div class="comments-count">
	
	  	<span></span>
		<a href="/2016/08/22/Android-源码分析之TODO-MVP-1/#comments" class="ds-thread-count comments-count-link" data-thread-key="2016/08/22/Android-源码分析之TODO-MVP-1/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/08/11/睡前叨叨/" title="睡前叨叨" itemprop="url">睡前叨叨</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Edgar" target="_blank" itemprop="author">Edgar</a>
		
  <p class="article-time">
    <time datetime="2016-08-10T16:59:06.000Z" itemprop="datePublished"> Published 2016-08-11</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h4 id="睡前叨叨-2016-08-11"><a href="#睡前叨叨-2016-08-11" class="headerlink" title="睡前叨叨 2016-08-11"></a>睡前叨叨 2016-08-11</h4><ol>
<li><p>今天乒乓球界的“藏獒” 科神，张继科，在睡梦中把对手给办了，哈哈，感觉科神要是想赢，只会输给比他更想赢的人。恭喜科神！！！！</p>
</li>
<li><p>明天要开始投简历找工作了，在这期间，有个小小的目标，就是培养自己的手绘爱好，下面是道具，后续会统一上传分享给大家，哎呀，小细腿露点了，呵呵。<br><img src="/2016/08/11/%E7%9D%A1%E5%89%8D%E5%8F%A8%E5%8F%A8/12.png"></p>
</li>
<li><p>这个月的睡前时间就交给娜姐了，后续也会写一些书评之类的，看时间是否允许了。<br><img src="/2016/08/11/%E7%9D%A1%E5%89%8D%E5%8F%A8%E5%8F%A8/22.png"></p>
</li>
<li><p>因为GitHub page在不翻墙的情况下会时不时得访问不了，这几天一直在找一个国内较好的博客网站，把这一百多篇博客搬过去，但是一粘贴过去格式都乱了，不好看，再调格式麻烦，找到开源中国感觉还可以，结果每天只能上传10篇，那我这边全搬过去要差不多半个月，心累，就不搬了，方正觉得这里写博客更好，比较清净，也不会为了写博客而写博客。最关键的是主题随便换，哈哈。得睡了，明天开始投简历了。</p>
</li>
</ol>
<p>“如果想要的还没来，就永远不要放弃，并相信该来的总会来”  — 不知道谁说的，没人认领就当我说的吧，哈哈。</p>
<h4 id="睡前叨叨-2016-08-14"><a href="#睡前叨叨-2016-08-14" class="headerlink" title="睡前叨叨 2016-08-14"></a>睡前叨叨 2016-08-14</h4><ol>
<li>博客计划<br>写一个刚入门的自己都能看懂的自定义View实例专题。<br>插件开发，热修复<br>分析开源框架（待定）</li>
</ol>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/%E5%8F%A8%E5%8F%A8%E7%B3%BB%E5%88%97/">叨叨系列</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/叨叨系列/">叨叨系列</a>
  </div>

</div>



<div class="comments-count">
	
	  	<span></span>
		<a href="/2016/08/11/睡前叨叨/#comments" class="ds-thread-count comments-count-link" data-thread-key="2016/08/11/睡前叨叨/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/08/03/Android-源码分析Zygote/" title="Android 源码分析之Zygote &amp;&amp; SystemServer" itemprop="url">Android 源码分析之Zygote &amp;&amp; SystemServer</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Edgar" target="_blank" itemprop="author">Edgar</a>
		
  <p class="article-time">
    <time datetime="2016-08-03T13:14:51.000Z" itemprop="datePublished"> Published 2016-08-03</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h4 id="Zygote"><a href="#Zygote" class="headerlink" title="Zygote"></a>Zygote</h4><p>故名思议就是“受精卵”的意思，受精卵的特点就是它是新生命的开始，并且受精卵一般都可以携带一些父辈的遗传信息。Zygote在Android系统中就相当于一个应用程序的受精卵一样，会生成出新的应用，我们知道Linux系统中要创建一个进程需要先调用fork方法，fork得到的进程大部分数据是和父辈进程是一致的，也就是说子进程和父进程之间共享着内存空间。只有在调用exec方法的时候才会用新的可执行文件的内容替换当前进程的代码段，数据段，堆栈等数据。但是在Android系统中Zygote在初始化的时候会创建Delvik虚拟机，在这个阶段会将系统的类库，资源文件，共享库加载到内存，在后续Zygote fork出子进程后，这个子进程也就有了上述资源，就不需要重新加载了，只需要装载APK中的字节码就可以直接运行了，所以会在很大程度上缩短启动进程的时间。</p>
<p><img src="/2016/08/03/Android-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90Zygote/11.png"></p>
<h4 id="SystemServer"><a href="#SystemServer" class="headerlink" title="SystemServer"></a>SystemServer</h4><p>一般我們在开发应用的时候如果要使用一个服务需要运行startService，来启动一个服务，但是我们在使用系统服务的时候却不需要，而是只需要调用getSystemService()来获得系统服务，这是因为我们上面提到的在系统启动的时候，Zygote会最早生成的一个SystemServer这个运行在Dalvik虚拟机上的Java进程。上面运行着多种系统服务，也就说这些服务在已经启动好了的，不需要我们重新启动。</p>
<p>下面是整个SystemServer以及MediaServer启动的整个过程，先上图，后补上详细的代码分析，哎，又欠了一大段文字，哈哈，不过我喜欢。大家看图估计看得更清楚些：</p>
<p><img src="/2016/08/03/Android-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90Zygote/221.png"></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Android-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">Android 源码分析</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/AOSP-源码/">AOSP 源码</a>
  </div>

</div>



<div class="comments-count">
	
	  	<span></span>
		<a href="/2016/08/03/Android-源码分析Zygote/#comments" class="ds-thread-count comments-count-link" data-thread-key="2016/08/03/Android-源码分析Zygote/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/08/03/Android-源码分析Android系统启动流程/" title="Android 源码分析Android系统启动流程" itemprop="url">Android 源码分析Android系统启动流程</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Edgar" target="_blank" itemprop="author">Edgar</a>
		
  <p class="article-time">
    <time datetime="2016-08-03T12:44:51.000Z" itemprop="datePublished"> Published 2016-08-03</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>这部分先上图，等有空的时候分析下这部分的源代码</p>
<ul>
<li>系统的整个启动流程</li>
<li>Init的执行流程</li>
<li>init.rc脚本的分析</li>
<li>属性系统的作用</li>
<li>属性系统的权限管理，属性系统对action的影响</li>
</ul>
<p><img src="/2016/08/03/Android-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90Android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/1.png"></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Android-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">Android 源码分析</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/AOSP-源码/">AOSP 源码</a>
  </div>

</div>



<div class="comments-count">
	
	  	<span></span>
		<a href="/2016/08/03/Android-源码分析Android系统启动流程/#comments" class="ds-thread-count comments-count-link" data-thread-key="2016/08/03/Android-源码分析Android系统启动流程/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/08/02/Android-进阶之源码分析基于NuPlayer的RTSP流媒体协议/" title="Android 源码分析之基于NuPlayer的RTSP流媒体协议" itemprop="url">Android 源码分析之基于NuPlayer的RTSP流媒体协议</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Edgar" target="_blank" itemprop="author">Edgar</a>
		
  <p class="article-time">
    <time datetime="2016-08-02T14:58:12.000Z" itemprop="datePublished"> Published 2016-08-02</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h5 id="RTSP-概述："><a href="#RTSP-概述：" class="headerlink" title="RTSP 概述："></a>RTSP 概述：</h5><p>RTSP 是Real Time Streaming Protocol（实时流媒体协议）的简称。RTSP提供一种可扩展的框架，使得能够提供可控制的，按需传输实时数据，比如音频和视频文件。RTSP对流媒体提供了诸如暂停，快进等控制，而它本身并不传输数据，RTSP作用相当于流媒体服务器的远程控制。传输数据可以通过传输层的TCP，UDP协议，RTSP也提供了基于 RTP传输机制的一些有效的方法。</p>
<h5 id="RTSP-模型："><a href="#RTSP-模型：" class="headerlink" title="RTSP 模型："></a>RTSP 模型：</h5><p>客户机在向视频服务器请求视频服务之前，首先通过HTTP协议从WEB服务器获取所请求视频服务的演示描述（Presentation description）文件，在RTSP中，每个演示（Presentation）及其所对应的媒体流都由一个RTSP URL标识。整个演示及媒体特性都在一个演示描述（Presentation description）文件中定义，该文件可能包括媒体编码方式、语言、RTSPURLs、目标地址、端口及其它参数。用户在向服务器请求某个连续媒体流的服务之前，必须首先从服务器获得该媒体流的演示描述（Presentation description ）文件以得到必需的参数。利用该文件提供的信息定位视频服务地址（包括视频服务器地址和端口号）及视频服务的编码方式等信息。<br>客户机根据上述信息向视频服务器请求视频服务。视频服务初始化完毕，视频服务器为该客户建立一个新的视频服务流，客户端与服务器运行实时流控制协议RTSP，以对该流进行各种VCR 控制信号的交换，如播放、暂停、快进、快退等。当服务完毕，客户端提出拆线（TEARDOWN）请求。服务器使用 RTP协议将媒体数据传输给客户端，一旦数据抵达客户端，客户端应用程序即可播放输出。在流式传输中，使用RTP&#x2F;RTCP和RTSP &#x2F;TCP两种不同的通信协议在客户端和服务器间建立联系。如下图：</p>
<p><img src="/2016/08/02/Android-%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E5%9F%BA%E4%BA%8ENuPlayer%E7%9A%84RTSP%E6%B5%81%E5%AA%92%E4%BD%93%E5%8D%8F%E8%AE%AE/1.png"></p>
<h5 id="RTSP-协议消息格式："><a href="#RTSP-协议消息格式：" class="headerlink" title="RTSP 协议消息格式："></a>RTSP 协议消息格式：</h5><ul>
<li>请求消息格式:</li>
</ul>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">方法   URI  RTSP版本   <span class="keyword">CR</span>  <span class="keyword">LF</span> </span><br><span class="line">消息头 <span class="keyword">CR</span>   <span class="keyword">LF</span>   <span class="keyword">CR</span>  <span class="keyword">LF</span> </span><br><span class="line">消息体 <span class="keyword">CR</span>   <span class="keyword">LF</span> </span><br></pre></td></tr></table></figure>

<p>其中方法包括OPTION回应中所有的命令,URI是接受方的地址,例如<br>rtsp:&#x2F;&#x2F;192.168.20.136</p>
<p>RTSP版本一般都是 RTSP&#x2F;1.0.每行后面的CR LF表示回车换行，需要接受端有相应的解析，最后一个消息头需要有两个CR LF</p>
<ul>
<li>回应消息格式:</li>
</ul>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">RTSP版本  状态码  解释 <span class="keyword">CR</span>  <span class="keyword">LF</span> </span><br><span class="line">消息头 <span class="keyword">CR</span>  <span class="keyword">LF</span>  <span class="keyword">CR</span>  <span class="keyword">LF</span> </span><br><span class="line">消息体 <span class="keyword">CR</span>  <span class="keyword">LF</span></span><br></pre></td></tr></table></figure>
<p>其中RTSP版本一般都是RTSP&#x2F;1.0,状态码是一个数值,200表示成功,解释是与状态码对应的文本解释。	</p>
<h5 id="简单的RTSP-交互过程"><a href="#简单的RTSP-交互过程" class="headerlink" title="简单的RTSP 交互过程:"></a>简单的RTSP 交互过程:</h5><p>下面以一次流媒体播放为例介绍整个播放过程的RTSP状态转换的流程：<br>其中C表示RTSP客户端,S表示RTSP服务端：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">C-&gt;S:OPTION     request        <span class="regexp">//</span>询问服务端有哪些方法可用</span><br><span class="line">S-&gt;C:OPTION     response       <span class="regexp">//</span>服务端回应信息中包括提供的所有可用方法 </span><br><span class="line"></span><br><span class="line">C-&gt;S:DESCRIBE    request        <span class="regexp">//</span>要求得到服务端提供的媒体初始化描述信息 </span><br><span class="line">S-&gt;C:DESCRIBE    response       <span class="regexp">//</span>服务端回应媒体初始化描述信息，主要是SDP</span><br><span class="line"></span><br><span class="line">C-&gt;S:SETUP       request        <span class="regexp">//</span>设置会话的属性，以及传输模式提醒服务端建立会话 </span><br><span class="line">S-&gt;C:SETUP       response       <span class="regexp">//</span>服务端建立会话，返回会话标识符，和会话相关信息 </span><br><span class="line"></span><br><span class="line">C-&gt;S:PLAY        request         <span class="regexp">//</span>客户端请求播放 </span><br><span class="line">S-&gt;C:PLAY        response       <span class="regexp">//</span>服务器回应该请求的信息 </span><br><span class="line"></span><br><span class="line">S-&gt;C:                           <span class="regexp">//</span>发送流媒体数据 </span><br><span class="line"></span><br><span class="line">C-&gt;S:TEARDOWN    request        <span class="regexp">//</span>客户端请求关闭会话 </span><br><span class="line">S-&gt;C:TEARDOWN    response <span class="regexp">//</span>服务端回应该请求 </span><br></pre></td></tr></table></figure>

<p>其中第SETUP和PLAY这两部是必需的，<br>OPTION 步骤只要服务器客户端约定好，有哪些方法可用，则option请求可以不要。<br>如果我们有其他途径得到媒体初始化描述信息，则我们也不需要通过RTSP中的DESCRIPTION请求来完成。<br>TEARDOWN，可以根据系统需求的设计来决定是否需要。<br><img src="/2016/08/02/Android-%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E5%9F%BA%E4%BA%8ENuPlayer%E7%9A%84RTSP%E6%B5%81%E5%AA%92%E4%BD%93%E5%8D%8F%E8%AE%AE/2.png"></p>
<h5 id="RTSP的主要命令表："><a href="#RTSP的主要命令表：" class="headerlink" title="RTSP的主要命令表："></a>RTSP的主要命令表：</h5><p><img src="/2016/08/02/Android-%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E5%9F%BA%E4%BA%8ENuPlayer%E7%9A%84RTSP%E6%B5%81%E5%AA%92%E4%BD%93%E5%8D%8F%E8%AE%AE/3.png"><br><img src="/2016/08/02/Android-%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E5%9F%BA%E4%BA%8ENuPlayer%E7%9A%84RTSP%E6%B5%81%E5%AA%92%E4%BD%93%E5%8D%8F%E8%AE%AE/4.png"><br><img src="/2016/08/02/Android-%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E5%9F%BA%E4%BA%8ENuPlayer%E7%9A%84RTSP%E6%B5%81%E5%AA%92%E4%BD%93%E5%8D%8F%E8%AE%AE/5.png"><br><img src="/2016/08/02/Android-%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E5%9F%BA%E4%BA%8ENuPlayer%E7%9A%84RTSP%E6%B5%81%E5%AA%92%E4%BD%93%E5%8D%8F%E8%AE%AE/6.png"><br><img src="/2016/08/02/Android-%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E5%9F%BA%E4%BA%8ENuPlayer%E7%9A%84RTSP%E6%B5%81%E5%AA%92%E4%BD%93%E5%8D%8F%E8%AE%AE/7.png"></p>
<h5 id="RTSP状态码："><a href="#RTSP状态码：" class="headerlink" title="RTSP状态码："></a>RTSP状态码：</h5><figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line">Status-Code <span class="operator">=</span></span><br><span class="line">| <span class="string">&quot;100&quot;</span> <span class="comment">; 				Continue</span></span><br><span class="line">| <span class="string">&quot;200&quot;</span> <span class="comment">; 				OK</span></span><br><span class="line">| <span class="string">&quot;201&quot;</span> <span class="comment">; 				Created</span></span><br><span class="line">| <span class="string">&quot;250&quot;</span> <span class="comment">; 				Low on Storage Space</span></span><br><span class="line">| <span class="string">&quot;300&quot;</span> <span class="comment">; 				Multiple Choices</span></span><br><span class="line">| <span class="string">&quot;301&quot;</span> <span class="comment">;				Moved Permanently</span></span><br><span class="line">| <span class="string">&quot;302&quot;</span> <span class="comment">; 				Moved Temporarily</span></span><br><span class="line">| <span class="string">&quot;303&quot;</span> <span class="comment">; 				See Other</span></span><br><span class="line">| <span class="string">&quot;304&quot;</span> <span class="comment">; 				Not Modified</span></span><br><span class="line">| <span class="string">&quot;305&quot;</span> <span class="comment">; 				Use Proxy</span></span><br><span class="line">| <span class="string">&quot;400&quot;</span> <span class="comment">; 				Bad Request</span></span><br><span class="line">| <span class="string">&quot;401&quot;</span> <span class="comment">; 				Unauthorized</span></span><br><span class="line">| <span class="string">&quot;402&quot;</span> <span class="comment">; 				Payment Required</span></span><br><span class="line">| <span class="string">&quot;403&quot;</span> <span class="comment">; 				Forbidden</span></span><br><span class="line">| <span class="string">&quot;404&quot;</span> <span class="comment">; 				Not Found</span></span><br><span class="line">| <span class="string">&quot;405&quot;</span> <span class="comment">; 				Method Not Allowed</span></span><br><span class="line">| <span class="string">&quot;406&quot;</span> <span class="comment">; 				Not Acceptable</span></span><br><span class="line">| <span class="string">&quot;407&quot;</span> <span class="comment">; 				Proxy Authentication Required</span></span><br><span class="line">| <span class="string">&quot;408&quot;</span> <span class="comment">; 				Request Time-out</span></span><br><span class="line">| <span class="string">&quot;410&quot;</span> <span class="comment">; 				Gone</span></span><br><span class="line">| <span class="string">&quot;411&quot;</span> <span class="comment">; 				Length Required</span></span><br><span class="line">| <span class="string">&quot;412&quot;</span> <span class="comment">; 				Precondition Failed</span></span><br><span class="line">| <span class="string">&quot;413&quot;</span> <span class="comment">; 				Request Entity Too Large</span></span><br><span class="line">| <span class="string">&quot;414&quot;</span> <span class="comment">; 				Request-URI Too Large</span></span><br><span class="line">| <span class="string">&quot;415&quot;</span> <span class="comment">; 				Unsupported Media Type</span></span><br><span class="line">| <span class="string">&quot;451&quot;</span> <span class="comment">; 				Parameter Not Understood</span></span><br><span class="line">| <span class="string">&quot;452&quot;</span> <span class="comment">; 				Conference Not Found</span></span><br><span class="line">| <span class="string">&quot;453&quot;</span> <span class="comment">; 				Not Enough Bandwidth</span></span><br><span class="line">| <span class="string">&quot;454&quot;</span> <span class="comment">; 				Session Not Found</span></span><br><span class="line">| <span class="string">&quot;455&quot;</span> <span class="comment">; 				Method Not Valid in This State</span></span><br><span class="line">| <span class="string">&quot;456&quot;</span> <span class="comment">; 				Header Field Not Valid for Resource</span></span><br><span class="line">| <span class="string">&quot;457&quot;</span> <span class="comment">; 				Invalid Range</span></span><br><span class="line">| <span class="string">&quot;458&quot;</span> <span class="comment">; 				Parameter Is Read-Only</span></span><br><span class="line">| <span class="string">&quot;459&quot;</span> <span class="comment">;				Aggregate operation not allowed</span></span><br><span class="line">| <span class="string">&quot;460&quot;</span> <span class="comment">; 				Only aggregate operation allowed</span></span><br><span class="line">| <span class="string">&quot;461&quot;</span> <span class="comment">; 				Unsupported transport</span></span><br><span class="line">| <span class="string">&quot;462&quot;</span> <span class="comment">; 				Destination unreachable</span></span><br><span class="line">| <span class="string">&quot;500&quot;</span> <span class="comment">; 				Internal Server Error</span></span><br><span class="line">| <span class="string">&quot;501&quot;</span> <span class="comment">; 				Not Implemented</span></span><br><span class="line">| <span class="string">&quot;502&quot;</span> <span class="comment">; 				Bad Gateway</span></span><br><span class="line">| <span class="string">&quot;503&quot;</span> <span class="comment">; 				Service Unavailable</span></span><br><span class="line">| <span class="string">&quot;504&quot;</span> <span class="comment">; 				Gateway Time-out</span></span><br><span class="line">| <span class="string">&quot;505&quot;</span> <span class="comment">; 				RTSP Version not supported</span></span><br><span class="line">| <span class="string">&quot;551&quot;</span> <span class="comment">; 				Option not supported</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="SDP的格式："><a href="#SDP的格式：" class="headerlink" title="SDP的格式："></a>SDP的格式：</h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">v=<span class="tag">&lt;<span class="name">version</span>&gt;</span>                            (协议版本)</span><br><span class="line">o=<span class="tag">&lt;<span class="name">username</span>&gt;</span> <span class="tag">&lt;<span class="name">session</span> <span class="attr">id</span>&gt;</span> <span class="tag">&lt;<span class="name">version</span>&gt;</span> <span class="tag">&lt;<span class="name">network</span> <span class="attr">type</span>&gt;</span> <span class="tag">&lt;<span class="name">address</span> <span class="attr">type</span>&gt;</span> <span class="tag">&lt;<span class="name">address</span>&gt;</span>                              （所有者/创建者和会话标识符）</span><br><span class="line">s=<span class="tag">&lt;<span class="name">session</span> <span class="attr">name</span>&gt;</span>                       （会话名称）</span><br><span class="line">i=<span class="tag">&lt;<span class="name">session</span> <span class="attr">description</span>&gt;</span>                （会话信息） </span><br><span class="line">u=<span class="tag">&lt;<span class="name">URI</span>&gt;</span>                                （URI 描述）</span><br><span class="line">e=<span class="tag">&lt;<span class="name">email</span> <span class="attr">address</span>&gt;</span>                      （Email 地址）</span><br><span class="line">p=<span class="tag">&lt;<span class="name">phone</span> <span class="attr">number</span>&gt;</span>                       （电话号码）</span><br><span class="line">c=<span class="tag">&lt;<span class="name">network</span> <span class="attr">type</span>&gt;</span> <span class="tag">&lt;<span class="name">address</span> <span class="attr">type</span>&gt;</span> <span class="tag">&lt;<span class="name">connection</span> <span class="attr">address</span>&gt;</span>   （连接信息）</span><br><span class="line">b=<span class="tag">&lt;<span class="name">modifier</span>&gt;</span>:<span class="tag">&lt;<span class="name">bandwidth-value</span>&gt;</span>         （带宽信息）</span><br><span class="line">t=<span class="tag">&lt;<span class="name">start</span> <span class="attr">time</span>&gt;</span> <span class="tag">&lt;<span class="name">stop</span> <span class="attr">time</span>&gt;</span>             （会话活动时间）</span><br><span class="line">r=<span class="tag">&lt;<span class="name">repeat</span> <span class="attr">interval</span>&gt;</span> <span class="tag">&lt;<span class="name">active</span> <span class="attr">duration</span>&gt;</span> <span class="tag">&lt;<span class="name">list</span> <span class="attr">of</span> <span class="attr">offsets</span> <span class="attr">from</span> <span class="attr">start-time</span>&gt;</span> </span><br><span class="line">                                        （0或多次重复次数）</span><br><span class="line">z=<span class="tag">&lt;<span class="name">adjustment</span> <span class="attr">time</span>&gt;</span> <span class="tag">&lt;<span class="name">offset</span>&gt;</span> <span class="tag">&lt;<span class="name">adjustment</span> <span class="attr">time</span>&gt;</span> <span class="tag">&lt;<span class="name">offset</span>&gt;</span>（时间区域调整）</span><br><span class="line">k=<span class="tag">&lt;<span class="name">method</span>&gt;</span>:<span class="tag">&lt;<span class="name">encryption</span> <span class="attr">key</span>&gt;</span>             （加密密钥）</span><br><span class="line">a=<span class="tag">&lt;<span class="name">attribute</span>&gt;</span>:<span class="tag">&lt;<span class="name">value</span>&gt;</span>                   （0 个或多个会话属性行）</span><br><span class="line">m=<span class="tag">&lt;<span class="name">media</span>&gt;</span> <span class="tag">&lt;<span class="name">port</span>&gt;</span> <span class="tag">&lt;<span class="name">transport</span>&gt;</span> <span class="tag">&lt;<span class="name">fmt</span> <span class="attr">list</span>&gt;</span> （媒体名称和传输地址）</span><br><span class="line"></span><br><span class="line">时间描述： </span><br><span class="line">t = （会话活动时间） </span><br><span class="line">r = * （0或多次重复次数） </span><br><span class="line">媒体描述： </span><br><span class="line">m = （媒体名称和传输地址） </span><br><span class="line">i = * （媒体标题） </span><br><span class="line">c = * （连接信息 — 如果包含在会话层则该字段可选） </span><br><span class="line">b = * （带宽信息） </span><br><span class="line">k = * （加密密钥） </span><br><span class="line">a = * （0 个或多个媒体属性行） </span><br></pre></td></tr></table></figure>
<h5 id="RTP协议："><a href="#RTP协议：" class="headerlink" title="RTP协议："></a>RTP协议：</h5><p>实时传输协议（Real-time Transport Protocol，RTP）是用来在单播或者多播的情境中传流媒体数据的数据传输协议。通常使用UDP来进行多媒体数据的传输，也不排除使用TCP或者ATM等其它协议作为它的载体，整个RTP 协议由两个密切相关的部分组成：RTP数据协议和RTP控制协议（也就是RTCP协议）。<br>RTP为Internet上端到端的实时传输提供时间信息和流同步，但它并不保证服务质量，服务质量由RTCP来提供。</p>
<ul>
<li>使用RTP协议进行数据传输的一个简要RTP的会话过程：</li>
</ul>
<p>当应用程序建立一个RTP会话时，应用程序将确定一对目的传输地址。目的传输地址由一个网络地址和一对端口组成，有两个端口：一个给RTP包，一个给RTCP包，也就是说RTP和RTCP数据包是分开传输的，这样可以使得RTP&#x2F;RTCP数据能够正确发送。其中RTP数据发向偶数的UDP端口，而对应的控制信号RTCP数据发向相邻的奇数UDP端口，这样就构成一个UDP端口对。<br>当发送数据的时候RTP协议从上层接收流媒体信息码流，封装成RTP数据包；RTCP从上层接收控制信息，封装成RTCP控制包。RTP将RTP 数据包发往UDP端口对中偶数端口；RTCP将RTCP控制包发往UDP端口对中的接收端口。<br>如果在一次会议中同时使用了音频和视频会议，这两种媒体将分别在不同的RTP会话中传送，每一个会话使用不同的传输地址（IP地址＋端口）。如果一个用户同时使用了两个会话，则每个会话对应的RTCP包都使用规范化名字CNAME（Canonical Name）。与会者可以根据RTCP包中的CNAME来获取相关联的音频和视频，然后根据RTCP包中的计时信息(Network time protocol)来实现音频和视频的同步。</p>
<ul>
<li>翻译器和混合器<br>在RTP协议中还引入了翻译器和混合器。翻译器和混合器都是RTP级的中继系统。<br>混合器的使用情景：<br>在Internet上举行视频会议时，可能有少数参加者通过低速链路与使用高速网络的多数参加者相连接。为了不强制所有会议参加者都使用低带宽和低质量的数据编码，RTP允许在低带宽区域附近使用混合器作为RTP级中继器。混合器从一个或多个信源接收RTP报文，对到达的数据报文进行重新同步和重新组合，这些重组的数据流被混合成一个数据流，将数据编码转化为在低带宽上可用的类型，并通过低速链路向低带宽区域转发。为了对多个输入信源进行统一的同步，混合器在多个媒体流之间进行定时调整，产生它自己的定时同步，因此所有从混合器输出的报文都把混合器作为同步信源。为了保证接收者能够正确识别混合器处理前的原始报文发送者，混合器在RTP报头中设置了CSRC标识符队列，以标识那些产生混和报文的原始同步信源。<br>翻译器的使用情景<br>在Internet环境中，一些会议的参加者可能被隔离在应用级防火墙的外面，这些参加者被禁止直接使用IP组播地址进行访问，虽然他们可能是通过高速链路连接的。在这些情况下，RTP允许使用转换器作为RTP级中继器。在防火墙两端分别安装一个转换器，防火墙之外的转换器过滤所有接收到的组播报文，并通过一条安全的连接传送给防火墙之内的转换器，内部转换器将这些组播报文再转发送给内部网络中的组播组成员</li>
</ul>
<h5 id="RTP协议报头格式"><a href="#RTP协议报头格式" class="headerlink" title="RTP协议报头格式"></a>RTP协议报头格式</h5><p><img src="/2016/08/02/Android-%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E5%9F%BA%E4%BA%8ENuPlayer%E7%9A%84RTSP%E6%B5%81%E5%AA%92%E4%BD%93%E5%8D%8F%E8%AE%AE/8.png"><br><img src="/2016/08/02/Android-%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E5%9F%BA%E4%BA%8ENuPlayer%E7%9A%84RTSP%E6%B5%81%E5%AA%92%E4%BD%93%E5%8D%8F%E8%AE%AE/9.png"></p>
<h5 id="RTCP协议报头格式"><a href="#RTCP协议报头格式" class="headerlink" title="RTCP协议报头格式"></a>RTCP协议报头格式</h5><p>如前面所述RTCP的主要功能是：服务质量的监视与反馈、媒体间的同步，以及多播组中成员的标识。在RTP会话期间，各参与者周期性地传送RTCP包。RTCP包中含有已发送的数据包的数量、丢失的数据包的数量等统计资料，因此，各参与者可以利用这些信息动态地改变传输速率，甚至改变有效载荷类型。RTP和RTCP配合使用，它们能以有效的反馈和最小的开销使传输效率最佳化，因而特别适合传送网上的实时数据。RTCP也是用UDP来传送的，但RTCP封装的仅仅是一些控制信息，因而分组很短，所以可以将多个RTCP分组封装在一个UDP包中。<br>RTCP有如下五种分组类型：<br><img src="/2016/08/02/Android-%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E5%9F%BA%E4%BA%8ENuPlayer%E7%9A%84RTSP%E6%B5%81%E5%AA%92%E4%BD%93%E5%8D%8F%E8%AE%AE/10.png"><br>下面是SR分组的格式：<br><img src="/2016/08/02/Android-%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E5%9F%BA%E4%BA%8ENuPlayer%E7%9A%84RTSP%E6%B5%81%E5%AA%92%E4%BD%93%E5%8D%8F%E8%AE%AE/11.png"><br><img src="/2016/08/02/Android-%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E5%9F%BA%E4%BA%8ENuPlayer%E7%9A%84RTSP%E6%B5%81%E5%AA%92%E4%BD%93%E5%8D%8F%E8%AE%AE/12.png"></p>
<h5 id="基于NuPLayer的RTSP-代码流程"><a href="#基于NuPLayer的RTSP-代码流程" class="headerlink" title="基于NuPLayer的RTSP 代码流程"></a>基于NuPLayer的RTSP 代码流程</h5><p>setDataSource 阶段的任务这里就不重复介绍了，它主要完成播放引擎的建立以及根据URL格式创建对应的Source，比如这里将要提到的RTSPSource，然后赋值给mSource。</p>
<p>我们直接来看prepare阶段：</p>
<p>先上图再看代码，结合图看会比较清晰<br><img src="/2016/08/02/Android-%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E5%9F%BA%E4%BA%8ENuPlayer%E7%9A%84RTSP%E6%B5%81%E5%AA%92%E4%BD%93%E5%8D%8F%E8%AE%AE/23.png"><br><img src="/2016/08/02/Android-%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E5%9F%BA%E4%BA%8ENuPlayer%E7%9A%84RTSP%E6%B5%81%E5%AA%92%E4%BD%93%E5%8D%8F%E8%AE%AE/24.png"><br><img src="/2016/08/02/Android-%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E5%9F%BA%E4%BA%8ENuPlayer%E7%9A%84RTSP%E6%B5%81%E5%AA%92%E4%BD%93%E5%8D%8F%E8%AE%AE/13.png"><br><img src="/2016/08/02/Android-%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E5%9F%BA%E4%BA%8ENuPlayer%E7%9A%84RTSP%E6%B5%81%E5%AA%92%E4%BD%93%E5%8D%8F%E8%AE%AE/14.png"></p>
<p>在prepare阶段我们首先会判断是否是SDP，mIsSDP这个变量是在初始化RTSPSource时候传入的，我们这里先分析mIsSDP &#x3D; false的情况。这种情况下首先创建一个MyHandler，并调用connect，与服务器建立连接。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void NuPlayer::RTSPSource::prepare<span class="constructor">Async()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//..........</span></span><br><span class="line">    sp&lt;AMessage&gt; notify = <span class="keyword">new</span> <span class="constructor">AMessage(<span class="params">kWhatNotify</span>, <span class="params">this</span>)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//检查当前状态是否为DISCONNECTED</span></span><br><span class="line">    <span class="constructor">CHECK_EQ(<span class="params">mState</span>, (<span class="params">int</span>)</span>DISCONNECTED);</span><br><span class="line">    <span class="comment">//设置当前状态为CONNECTING</span></span><br><span class="line">    mState = CONNECTING;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mIsSDP) &#123;</span><br><span class="line">        <span class="comment">//如果是SDP那么就需要创建一个SDPLoader 从服务器上加载一个描述文件</span></span><br><span class="line">        mSDPLoader = <span class="keyword">new</span> <span class="constructor">SDPLoader(<span class="params">notify</span>, (<span class="params">mFlags</span> &amp; <span class="params">kFlagIncognito</span>)</span> ? SDPLoader::kFlagIncognito : <span class="number">0</span>, mHTTPService);</span><br><span class="line">        mSDPLoader-&gt;load(mURL.c<span class="constructor">_str()</span>, mExtraHeaders.is<span class="constructor">Empty()</span> ? NULL : &amp;mExtraHeaders);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果不是SDP 那么就使用MyHandler 来进行连接</span></span><br><span class="line">        mHandler = <span class="keyword">new</span> <span class="constructor">MyHandler(<span class="params">mURL</span>.<span class="params">c_str</span>()</span>, notify, mUIDValid, mUID);</span><br><span class="line">        mLooper-&gt;register<span class="constructor">Handler(<span class="params">mHandler</span>)</span>;</span><br><span class="line">        mHandler-&gt;connect<span class="literal">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//启动缓存</span></span><br><span class="line">    start<span class="constructor">BufferingIfNecessary()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在介绍connect方法之前需要先了解mConn以及mRTPConn这两个成员变量，mConn是一个ARTSPConnection，它主要与服务器相连，发送和接收请求数据，mRTPConn是一个ARTPConnection 用于发送和接收媒体数据。<br>在connect方法中会使用mConn向服务器发起连接请求。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void connect<span class="literal">()</span> &#123;</span><br><span class="line">    <span class="comment">//mConn(new ARTSPConnection(mUIDValid, mUID)),</span></span><br><span class="line">    looper<span class="literal">()</span>-&gt;register<span class="constructor">Handler(<span class="params">mConn</span>)</span>;</span><br><span class="line">    <span class="comment">//mRTPConn(new ARTPConnection),</span></span><br><span class="line">    (<span class="number">1</span> ? mNetLooper : looper<span class="literal">()</span>)-&gt;register<span class="constructor">Handler(<span class="params">mRTPConn</span>)</span>;</span><br><span class="line">    sp&lt;AMessage&gt; notify = <span class="keyword">new</span> <span class="constructor">AMessage(&#x27;<span class="params">biny</span>&#x27;, <span class="params">this</span>)</span>;</span><br><span class="line">    mConn-&gt;observe<span class="constructor">BinaryData(<span class="params">notify</span>)</span>;</span><br><span class="line">    <span class="comment">//连接服务</span></span><br><span class="line">    sp&lt;AMessage&gt; reply = <span class="keyword">new</span> <span class="constructor">AMessage(&#x27;<span class="params">conn</span>&#x27;, <span class="params">this</span>)</span>;</span><br><span class="line">    mConn-&gt;connect(mOriginalSessionURL.c<span class="constructor">_str()</span>, reply);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void ARTSPConnection::connect(const <span class="built_in">char</span> *url, const sp&lt;AMessage&gt; &amp;reply) &#123;</span><br><span class="line">    <span class="comment">//发送一个kWhatConnect消息，注意这里传递的是一个url和reply</span></span><br><span class="line">    sp&lt;AMessage&gt; msg = <span class="keyword">new</span> <span class="constructor">AMessage(<span class="params">kWhatConnect</span>, <span class="params">this</span>)</span>;</span><br><span class="line">    msg-&gt;set<span class="constructor">String(<span class="string">&quot;url&quot;</span>, <span class="params">url</span>)</span>;</span><br><span class="line">    msg-&gt;set<span class="constructor">Message(<span class="string">&quot;reply&quot;</span>, <span class="params">reply</span>)</span>;</span><br><span class="line">    msg-&gt;post<span class="literal">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> kWhatConnect:</span><br><span class="line">    onConnect(msg);</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<p>在ARTSPConnection::onConnect中将会从传递过来的URl中解析host，port，path，mUser，mPass，并调用::connect 和服务器取得联系，最后调用postReceiveReponseEvent将请求的回复响应暂存起来。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void ARTSPConnection::on<span class="constructor">Connect(<span class="params">const</span> <span class="params">sp</span>&lt;AMessage&gt; &amp;<span class="params">msg</span>)</span> &#123;</span><br><span class="line">    ++mConnectionID;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (mState != DISCONNECTED) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mUIDValid) &#123;</span><br><span class="line">            HTTPBase::<span class="constructor">UnRegisterSocketUserTag(<span class="params">mSocket</span>)</span>;</span><br><span class="line">            HTTPBase::<span class="constructor">UnRegisterSocketUserMark(<span class="params">mSocket</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        close(mSocket);</span><br><span class="line">        mSocket = -<span class="number">1</span>;</span><br><span class="line">        flush<span class="constructor">PendingRequests()</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mState = CONNECTING;</span><br><span class="line">    AString url;</span><br><span class="line">    <span class="comment">//从消息中取下Url</span></span><br><span class="line">    <span class="constructor">CHECK(<span class="params">msg</span>-&gt;<span class="params">findString</span>(<span class="string">&quot;url&quot;</span>, &amp;<span class="params">url</span>)</span>);</span><br><span class="line">    sp&lt;AMessage&gt; reply;</span><br><span class="line">    <span class="comment">//从消息中取下replay</span></span><br><span class="line">    <span class="constructor">CHECK(<span class="params">msg</span>-&gt;<span class="params">findMessage</span>(<span class="string">&quot;reply&quot;</span>, &amp;<span class="params">reply</span>)</span>);</span><br><span class="line"></span><br><span class="line">    AString host, path;</span><br><span class="line">    unsigned port;</span><br><span class="line">    <span class="comment">//从URl中解析host，port，path，mUser，mPass</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="constructor">ParseURL(<span class="params">url</span>.<span class="params">c_str</span>()</span>, &amp;host, &amp;port, &amp;path, &amp;mUser, &amp;mPass)<span class="operator"></span></span><br><span class="line"><span class="operator">            || </span>(mUser.size<span class="literal">()</span> &gt; <span class="number">0</span><span class="operator"> &amp;&amp; </span>mPass.size<span class="literal">()</span><span class="operator"> == </span><span class="number">0</span>)) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//有用户名，但是没有密码，返回错误信息</span></span><br><span class="line">        <span class="comment">// If we have a user name but no password we have to give up</span></span><br><span class="line">        <span class="comment">// right here, since we currently have no way of asking the user</span></span><br><span class="line">        <span class="comment">// for this information.</span></span><br><span class="line">        <span class="constructor">ALOGE(<span class="string">&quot;Malformed rtsp url %s&quot;</span>, <span class="params">uriDebugString</span>(<span class="params">url</span>)</span>.c<span class="constructor">_str()</span>);</span><br><span class="line">        reply-&gt;set<span class="constructor">Int32(<span class="string">&quot;result&quot;</span>, ERROR_MALFORMED)</span>;</span><br><span class="line">        reply-&gt;post<span class="literal">()</span>;</span><br><span class="line">        mState = DISCONNECTED;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mUser.size<span class="literal">()</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="constructor">ALOGV(<span class="string">&quot;user = &#x27;%s&#x27;, pass = &#x27;%s&#x27;&quot;</span>, <span class="params">mUser</span>.<span class="params">c_str</span>()</span>, mPass.c<span class="constructor">_str()</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> hostent *ent = gethostbyname(host.c<span class="constructor">_str()</span>);</span><br><span class="line">    <span class="keyword">if</span> (ent<span class="operator"> == </span>NULL) &#123;</span><br><span class="line">        <span class="constructor">ALOGE(<span class="string">&quot;Unknown host %s&quot;</span>, <span class="params">host</span>.<span class="params">c_str</span>()</span>);</span><br><span class="line">        reply-&gt;set<span class="constructor">Int32(<span class="string">&quot;result&quot;</span>, -ENOENT)</span>;</span><br><span class="line">        reply-&gt;post<span class="literal">()</span>;</span><br><span class="line">        mState = DISCONNECTED;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mSocket = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mUIDValid) &#123;</span><br><span class="line">        HTTPBase::<span class="constructor">RegisterSocketUserTag(<span class="params">mSocket</span>, <span class="params">mUID</span>,(<span class="params">uint32_t</span>)</span>*(uint32_t*) <span class="string">&quot;RTSP&quot;</span>);</span><br><span class="line">        HTTPBase::<span class="constructor">RegisterSocketUserMark(<span class="params">mSocket</span>, <span class="params">mUID</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="constructor">MakeSocketBlocking(<span class="params">mSocket</span>, <span class="params">false</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> sockaddr_in remote;</span><br><span class="line">    memset(remote.sin_zero, <span class="number">0</span>, sizeof(remote.sin_zero));</span><br><span class="line">    remote.sin_family = AF_INET;</span><br><span class="line">    remote.sin_addr.s_addr = *(in_addr_t *)ent-&gt;h_addr;</span><br><span class="line">    remote.sin_port = htons(port);</span><br><span class="line">    <span class="comment">//连接到服务器</span></span><br><span class="line">    <span class="built_in">int</span> err = ::connect(mSocket, (const <span class="keyword">struct</span> sockaddr *)&amp;remote, sizeof(remote));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回服务器ip</span></span><br><span class="line">    reply-&gt;set<span class="constructor">Int32(<span class="string">&quot;server-ip&quot;</span>, <span class="params">ntohl</span>(<span class="params">remote</span>.<span class="params">sin_addr</span>.<span class="params">s_addr</span>)</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (errno<span class="operator"> == </span>EINPROGRESS) &#123;</span><br><span class="line">            sp&lt;AMessage&gt; msg = <span class="keyword">new</span> <span class="constructor">AMessage(<span class="params">kWhatCompleteConnection</span>, <span class="params">this</span>)</span>;</span><br><span class="line">            msg-&gt;set<span class="constructor">Message(<span class="string">&quot;reply&quot;</span>, <span class="params">reply</span>)</span>;</span><br><span class="line">            msg-&gt;set<span class="constructor">Int32(<span class="string">&quot;connection-id&quot;</span>, <span class="params">mConnectionID</span>)</span>;</span><br><span class="line">            msg-&gt;post<span class="literal">()</span>;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        reply-&gt;set<span class="constructor">Int32(<span class="string">&quot;result&quot;</span>, -<span class="params">errno</span>)</span>;</span><br><span class="line">        mState = DISCONNECTED;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mUIDValid) &#123;</span><br><span class="line">            HTTPBase::<span class="constructor">UnRegisterSocketUserTag(<span class="params">mSocket</span>)</span>;</span><br><span class="line">            HTTPBase::<span class="constructor">UnRegisterSocketUserMark(<span class="params">mSocket</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        close(mSocket);</span><br><span class="line">        mSocket = -<span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//成功的花返回result为OK</span></span><br><span class="line">        reply-&gt;set<span class="constructor">Int32(<span class="string">&quot;result&quot;</span>, OK)</span>;</span><br><span class="line">        <span class="comment">//设置状态为CONNECTED</span></span><br><span class="line">        mState = CONNECTED;</span><br><span class="line">        mNextCSeq = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//发送等待返回消息</span></span><br><span class="line">        post<span class="constructor">ReceiveReponseEvent()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//‘conn’</span></span><br><span class="line">    reply-&gt;post<span class="literal">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们接下来看下postReceiveReponseEvent</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title class_">ARTSPConnection</span>::<span class="title function_">postReceiveReponseEvent</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (mReceiveResponseEventPending) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sp&lt;<span class="title class_">AMessage</span>&gt; msg = <span class="keyword">new</span> <span class="title class_">AMessage</span>(kWhatReceiveResponse, <span class="variable language_">this</span>);</span><br><span class="line">    msg-&gt;<span class="title function_">post</span>();</span><br><span class="line">    mReceiveResponseEventPending = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用receiveRTSPReponse获得服务器的回复</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void ARTSPConnection::on<span class="constructor">ReceiveResponse()</span> &#123;</span><br><span class="line">    mReceiveResponseEventPending = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (mState != CONNECTED) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">struct</span> timeval tv;</span><br><span class="line">    tv.tv_sec = <span class="number">0</span>;</span><br><span class="line">    tv.tv_usec = kSelectTimeoutUs;</span><br><span class="line">    fd_set rs;</span><br><span class="line">    <span class="constructor">FD_ZERO(&amp;<span class="params">rs</span>)</span>;</span><br><span class="line">    <span class="constructor">FD_SET(<span class="params">mSocket</span>, &amp;<span class="params">rs</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//选择一个返回的连接</span></span><br><span class="line">    <span class="built_in">int</span> res = select(mSocket + <span class="number">1</span>, &amp;rs, NULL, NULL, &amp;tv);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (res<span class="operator"> == </span><span class="number">1</span>) &#123;</span><br><span class="line">        <span class="constructor">MakeSocketBlocking(<span class="params">mSocket</span>, <span class="params">true</span>)</span>;</span><br><span class="line">        <span class="built_in">bool</span> success = receive<span class="constructor">RTSPReponse()</span>;</span><br><span class="line">        <span class="constructor">MakeSocketBlocking(<span class="params">mSocket</span>, <span class="params">false</span>)</span>;</span><br><span class="line">        <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">            <span class="comment">// Something horrible, irreparable has happened.</span></span><br><span class="line">            flush<span class="constructor">PendingRequests()</span>;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    post<span class="constructor">ReceiveReponseEvent()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意这里的receiveRTSPReponse是有双重功能的，方面可以接收从服务器发来的请求，另一方面可以处理服务器发来的应答信号。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="built_in">bool</span> ARTSPConnection::receive<span class="constructor">RTSPReponse()</span> &#123;</span><br><span class="line"></span><br><span class="line">    AString statusLine;</span><br><span class="line">    <span class="keyword">if</span> (!receive<span class="constructor">Line(&amp;<span class="params">statusLine</span>)</span>) &#123;</span><br><span class="line">        return <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (statusLine<span class="operator"> == </span><span class="string">&quot;$&quot;</span>) &#123;</span><br><span class="line">        sp&lt;ABuffer&gt; buffer = receive<span class="constructor">BinaryData()</span>;</span><br><span class="line">        <span class="keyword">if</span> (buffer<span class="operator"> == </span>NULL) &#123;</span><br><span class="line">            return <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mObserveBinaryMessage != NULL) &#123;</span><br><span class="line">            sp&lt;AMessage&gt; notify = mObserveBinaryMessage-&gt;dup<span class="literal">()</span>;</span><br><span class="line">            notify-&gt;set<span class="constructor">Buffer(<span class="string">&quot;buffer&quot;</span>, <span class="params">buffer</span>)</span>;</span><br><span class="line">            notify-&gt;post<span class="literal">()</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="constructor">ALOGW(<span class="string">&quot;received binary data, but no one cares.&quot;</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        return <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//RTSP返回对象</span></span><br><span class="line">    sp&lt;ARTSPResponse&gt; response = <span class="keyword">new</span> ARTSPResponse;</span><br><span class="line">    response-&gt;mStatusLine = statusLine;</span><br><span class="line">    <span class="constructor">ALOGI(<span class="string">&quot;status: %s&quot;</span>, <span class="params">response</span>-&gt;<span class="params">mStatusLine</span>.<span class="params">c_str</span>()</span>);</span><br><span class="line">    ssize_t space1 = response-&gt;mStatusLine.find(<span class="string">&quot; &quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (space1 &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        return <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ssize_t space2 = response-&gt;mStatusLine.find(<span class="string">&quot; &quot;</span>, space1 + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (space2 &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        return <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bool</span> isRequest = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//判断返回的RTSP版本是否正确</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="constructor">IsRTSPVersion(AString(<span class="params">response</span>-&gt;<span class="params">mStatusLine</span>, 0, <span class="params">space1</span>)</span>)) &#123;</span><br><span class="line">        <span class="constructor">CHECK(IsRTSPVersion(AString(<span class="params">response</span>-&gt;<span class="params">mStatusLine</span>,<span class="params">space2</span> + 1,<span class="params">response</span>-&gt;<span class="params">mStatusLine</span>.<span class="params">size</span>()</span> - space2 - <span class="number">1</span>)));</span><br><span class="line">        isRequest = <span class="literal">true</span>;</span><br><span class="line">        response-&gt;mStatusCode = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//判断状态码是否正确</span></span><br><span class="line">        AString status<span class="constructor">CodeStr(<span class="params">response</span>-&gt;<span class="params">mStatusLine</span>, <span class="params">space1</span> + 1, <span class="params">space2</span> - <span class="params">space1</span> - 1)</span>;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="constructor">ParseSingleUnsignedLong(<span class="params">statusCodeStr</span>.<span class="params">c_str</span>()</span>, &amp;response-&gt;mStatusCode)<span class="operator"> || </span>response-&gt;mStatusCode &lt; <span class="number">100</span><span class="operator"> || </span>response-&gt;mStatusCode &gt; <span class="number">999</span>) &#123;</span><br><span class="line">            return <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AString line;</span><br><span class="line">    ssize_t lastDictIndex = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!receive<span class="constructor">Line(&amp;<span class="params">line</span>)</span>) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (line.empty<span class="literal">()</span>) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="constructor">ALOGV(<span class="string">&quot;line: &#x27;%s&#x27;&quot;</span>, <span class="params">line</span>.<span class="params">c_str</span>()</span>);</span><br><span class="line">        <span class="keyword">if</span> (line.c<span class="constructor">_str()</span><span class="literal">[<span class="number">0</span>]</span><span class="operator"> == </span><span class="character">&#x27; &#x27;</span><span class="operator"> || </span>line.c<span class="constructor">_str()</span><span class="literal">[<span class="number">0</span>]</span><span class="operator"> == </span><span class="character">&#x27;\t&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// Support for folded header values.</span></span><br><span class="line">            <span class="keyword">if</span> (lastDictIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// First line cannot be a continuation of the previous one.</span></span><br><span class="line">                return <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            AString &amp;value = response-&gt;mHeaders.edit<span class="constructor">ValueAt(<span class="params">lastDictIndex</span>)</span>;</span><br><span class="line">            value.append(line);</span><br><span class="line"></span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        ssize_t colonPos = line.find(<span class="string">&quot;:&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (colonPos &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// Malformed header line.</span></span><br><span class="line">            return <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        AString key(line, <span class="number">0</span>, colonPos);</span><br><span class="line">        key.trim<span class="literal">()</span>;</span><br><span class="line">        key.tolower<span class="literal">()</span>;</span><br><span class="line">        line.erase(<span class="number">0</span>, colonPos + <span class="number">1</span>);</span><br><span class="line">        lastDictIndex = response-&gt;mHeaders.add(key, line);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; response-&gt;mHeaders.size<span class="literal">()</span>; ++i) &#123;</span><br><span class="line">        response-&gt;mHeaders.edit<span class="constructor">ValueAt(<span class="params">i</span>)</span>.trim<span class="literal">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    unsigned long contentLength = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    ssize_t i = response-&gt;mHeaders.index<span class="constructor">OfKey(<span class="string">&quot;content-length&quot;</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        AString value = response-&gt;mHeaders.value<span class="constructor">At(<span class="params">i</span>)</span>;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="constructor">ParseSingleUnsignedLong(<span class="params">value</span>.<span class="params">c_str</span>()</span>, &amp;contentLength)) &#123;</span><br><span class="line">            return <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//接收mContent</span></span><br><span class="line">    <span class="keyword">if</span> (contentLength &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        response-&gt;mContent = <span class="keyword">new</span> <span class="constructor">ABuffer(<span class="params">contentLength</span>)</span>;</span><br><span class="line">        <span class="keyword">if</span> (receive(response-&gt;mContent-&gt;data<span class="literal">()</span>, contentLength) != OK) &#123;</span><br><span class="line">            return <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//isRequest 表示是服务器主动发送的请求，那么将调用handleServerRequest，否则表示是服务器被动响应客户端的请求，那么将通知服务器有响应了notifyResponseListener</span></span><br><span class="line">    return isRequest</span><br><span class="line">        ? handle<span class="constructor">ServerRequest(<span class="params">response</span>)</span></span><br><span class="line">        : notify<span class="constructor">ResponseListener(<span class="params">response</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>isRequest 表示是服务器主动发送的请求，那么将调用handleServerRequest，否则表示是服务器被动响应客户端的请求，那么将通知服务器有响应了notifyResponseListener，我们这里先看下这两个方法的实现：</p>
<p>看到handleServerRequest大家可能会有点失望，因为这里尚未实现这个功能所以只是向服务器返回一个“RTSP&#x2F;1.0 501 Not Implemented”的消息。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ARTSPConnection::handleServerRequest</span><span class="params">(<span class="type">const</span> sp&lt;ARTSPResponse&gt; &amp;request)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Implementation of server-&gt;client requests is optional for all methods</span></span><br><span class="line">    <span class="comment">// but we do need to respond, even if it&#x27;s just to say that we don&#x27;t</span></span><br><span class="line">    <span class="comment">// support the method.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里我们不实现任何答复行为只是简单反馈我们尚未实现这个功能</span></span><br><span class="line">    <span class="type">ssize_t</span> space1 = request-&gt;mStatusLine.<span class="built_in">find</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">    <span class="built_in">CHECK_GE</span>(space1, <span class="number">0</span>);</span><br><span class="line">    AString response;</span><br><span class="line">    response.<span class="built_in">append</span>(<span class="string">&quot;RTSP/1.0 501 Not Implemented\r\n&quot;</span>);</span><br><span class="line">    <span class="type">ssize_t</span> i = request-&gt;mHeaders.<span class="built_in">indexOfKey</span>(<span class="string">&quot;cseq&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        AString value = request-&gt;mHeaders.<span class="built_in">valueAt</span>(i);</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> cseq;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">ParseSingleUnsignedLong</span>(value.<span class="built_in">c_str</span>(), &amp;cseq)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        response.<span class="built_in">append</span>(<span class="string">&quot;CSeq: &quot;</span>);</span><br><span class="line">        response.<span class="built_in">append</span>(cseq);</span><br><span class="line">        response.<span class="built_in">append</span>(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    response.<span class="built_in">append</span>(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">    <span class="type">size_t</span> numBytesSent = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (numBytesSent &lt; response.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="type">ssize_t</span> n =</span><br><span class="line">            <span class="built_in">send</span>(mSocket, response.<span class="built_in">c_str</span>() + numBytesSent,</span><br><span class="line">                 response.<span class="built_in">size</span>() - numBytesSent, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span> &amp;&amp; errno == EINTR) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// Server closed the connection.</span></span><br><span class="line">                <span class="built_in">ALOGE</span>(<span class="string">&quot;Server unexpectedly closed the connection.&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">ALOGE</span>(<span class="string">&quot;Error sending rtsp response (%s).&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">performDisconnect</span>();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        numBytesSent += (<span class="type">size_t</span>)n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>notifyResponseListener的实现比较清晰，它会根据服务器发来的应答响应，找出响应该应答的Message，然后将response返回给MyHandler，进行处理。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> ARTSPConnection::<span class="title function_ invoke__">notifyResponseListener</span>(</span><br><span class="line">        <span class="keyword">const</span> sp&lt;ARTSPResponse&gt; &amp;response) &#123;</span><br><span class="line">    ssize_t i;</span><br><span class="line">    <span class="comment">//在队列中查找尚未处理的请求</span></span><br><span class="line">    status_t err = <span class="title function_ invoke__">findPendingRequest</span>(response, &amp;i);</span><br><span class="line">    <span class="title function_ invoke__">if</span> (err != OK) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//发送服务器的回复给它</span></span><br><span class="line">    sp&lt;AMessage&gt; reply = mPendingRequests.<span class="title function_ invoke__">valueAt</span>(i);</span><br><span class="line">    mPendingRequests.<span class="title function_ invoke__">removeItemsAt</span>(i);</span><br><span class="line">    reply<span class="punctuation">-&gt;</span><span class="title function_ invoke__">setInt32</span>(<span class="string">&quot;result&quot;</span>, OK);</span><br><span class="line">    reply<span class="punctuation">-&gt;</span><span class="title function_ invoke__">setObject</span>(<span class="string">&quot;response&quot;</span>, response);</span><br><span class="line">    reply<span class="punctuation">-&gt;</span><span class="title function_ invoke__">post</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好了我们言归正传，我们看下MyHandler中对conn回复怎么处理：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">case &#x27;conn&#x27;:</span><br><span class="line">&#123;</span><br><span class="line">    int32_t result;</span><br><span class="line">    <span class="comment">//取出反馈结果</span></span><br><span class="line">    <span class="constructor">CHECK(<span class="params">msg</span>-&gt;<span class="params">findInt32</span>(<span class="string">&quot;result&quot;</span>, &amp;<span class="params">result</span>)</span>);</span><br><span class="line">    <span class="keyword">if</span> (result<span class="operator"> == </span>OK) &#123;</span><br><span class="line">        <span class="comment">//发送请求描述符的消息</span></span><br><span class="line">        AString request;</span><br><span class="line">        request = <span class="string">&quot;DESCRIBE &quot;</span>;</span><br><span class="line">        request.append(mSessionURL);</span><br><span class="line">        request.append(<span class="string">&quot; RTSP/1.0\r\n&quot;</span>);</span><br><span class="line">        request.append(<span class="string">&quot;Accept: application/sdp\r\n&quot;</span>);</span><br><span class="line">        request.append(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">        sp&lt;AMessage&gt; reply = <span class="keyword">new</span> <span class="constructor">AMessage(&#x27;<span class="params">desc</span>&#x27;, <span class="params">this</span>)</span>;</span><br><span class="line">        mConn-&gt;send<span class="constructor">Request(<span class="params">request</span>.<span class="params">c_str</span>()</span>, reply);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        (<span class="keyword">new</span> <span class="constructor">AMessage(&#x27;<span class="params">disc</span>&#x27;, <span class="params">this</span>)</span>)-&gt;post<span class="literal">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里比较简单就是收到答复之后，直接判断结果是OK还是不OK，如果OK那么就发送一个DESCRIBE的请求。我们重点看下，onSendRequest理解这个很重要：<br>在onSendRequest中会对请求加工处理下，比如添加Cseq等操作，然后就会调用send向服务器发送请求。并将请求以Cseq为键码，replay为回复消息的待处理请求队列中。</p>
<figure class="highlight wren"><table><tr><td class="code"><pre><span class="line"><span class="variable">void</span> <span class="title class_">ARTSPConnection</span>::<span class="title function_">onSendRequest</span>(<span class="params">const</span> <span class="params">sp</span>&lt;<span class="params">AMessage</span>&gt; &amp;<span class="params">msg</span>) &#123;</span><br><span class="line">    <span class="variable">sp</span><span class="operator">&lt;</span><span class="title class_">AMessage</span><span class="operator">&gt;</span> <span class="variable">reply</span>;</span><br><span class="line">    <span class="title function_">CHECK</span>(<span class="variable">msg</span><span class="operator">-</span><span class="operator">&gt;</span><span class="title function_">findMessage</span>(<span class="string">&quot;reply&quot;</span>, <span class="operator">&amp;</span><span class="variable">reply</span>));</span><br><span class="line">    <span class="comment">//对请求进行加工处理</span></span><br><span class="line">    <span class="title class_">AString</span> <span class="variable">request</span>;</span><br><span class="line">    <span class="title function_">CHECK</span>(<span class="variable">msg</span><span class="operator">-</span><span class="operator">&gt;</span><span class="title function_">findString</span>(<span class="string">&quot;request&quot;</span>, <span class="operator">&amp;</span><span class="variable">request</span>));</span><br><span class="line">    <span class="comment">// Just in case we need to re-issue the request with proper authentication</span></span><br><span class="line">    <span class="comment">// later, stash it away.</span></span><br><span class="line">    <span class="variable">reply</span><span class="operator">-</span><span class="operator">&gt;</span><span class="title function_">setString</span>(<span class="string">&quot;original-request&quot;</span>, <span class="variable">request</span>.<span class="property">c_str</span>(), <span class="variable">request</span>.<span class="property">size</span>());</span><br><span class="line">    <span class="title function_">addAuthentication</span>(<span class="operator">&amp;</span><span class="variable">request</span>);</span><br><span class="line">    <span class="title function_">addUserAgent</span>(<span class="operator">&amp;</span><span class="variable">request</span>);</span><br><span class="line">    <span class="comment">// Find the boundary between headers and the body.</span></span><br><span class="line">    <span class="variable">ssize_t</span> <span class="variable">i</span> <span class="operator">=</span> <span class="variable">request</span>.<span class="property">find</span>(<span class="string">&quot;<span class="char escape_">\r</span><span class="char escape_">\n</span><span class="char escape_">\r</span><span class="char escape_">\n</span>&quot;</span>);</span><br><span class="line">    <span class="title function_">CHECK_GE</span>(<span class="variable">i</span>, <span class="number">0</span>);</span><br><span class="line">    int32_t <span class="variable">cseq</span> <span class="operator">=</span> <span class="variable">mNextCSeq</span><span class="operator">+</span><span class="operator">+</span>;</span><br><span class="line">    <span class="title class_">AString</span> <span class="variable">cseqHeader</span> <span class="operator">=</span> <span class="string">&quot;CSeq: &quot;</span>;</span><br><span class="line">    <span class="variable">cseqHeader</span>.<span class="property">append</span>(<span class="variable">cseq</span>);</span><br><span class="line">    <span class="variable">cseqHeader</span>.<span class="property">append</span>(<span class="string">&quot;<span class="char escape_">\r</span><span class="char escape_">\n</span>&quot;</span>);</span><br><span class="line">    <span class="variable">request</span>.<span class="property">insert</span>(<span class="variable">cseqHeader</span>, <span class="variable">i</span> <span class="operator">+</span> <span class="number">2</span>);</span><br><span class="line">    <span class="title function_">ALOGV</span>(<span class="string">&quot;request: &#x27;%s&#x27;&quot;</span>, <span class="variable">request</span>.<span class="property">c_str</span>());</span><br><span class="line"></span><br><span class="line">    <span class="variable">size_t</span> <span class="variable">numBytesSent</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="variable">numBytesSent</span> <span class="operator">&lt;</span> <span class="variable">request</span>.<span class="property">size</span>()) &#123;</span><br><span class="line">        <span class="comment">//如果请求还没完全发送结束那么继续发送</span></span><br><span class="line">        <span class="variable">ssize_t</span> <span class="variable">n</span> <span class="operator">=</span> <span class="title function_">send</span>(<span class="variable">mSocket</span>, <span class="variable">request</span>.<span class="property">c_str</span>() <span class="operator">+</span> <span class="variable">numBytesSent</span>,<span class="variable">request</span>.<span class="property">size</span>() <span class="operator">-</span> <span class="variable">numBytesSent</span>, <span class="number">0</span>);&#125;</span><br><span class="line">        <span class="comment">//忽略错误处理代码</span></span><br><span class="line">        <span class="variable">numBytesSent</span> <span class="operator">+</span><span class="operator">=</span> (<span class="variable">size_t</span>)<span class="variable">n</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将请求添加到mPendingRequests，等待服务器回复</span></span><br><span class="line">    <span class="variable">mPendingRequests</span>.<span class="property">add</span>(<span class="variable">cseq</span>, <span class="variable">reply</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回到上面提到的notifyResponseListener结合onSendRequest以及findPendingRequest是否看出了整个事件处理的流程？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">ARTSPConnection::findPendingRequest</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> sp&lt;ARTSPResponse&gt; &amp;response, <span class="type">ssize_t</span> *index)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    *index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">ssize_t</span> i = response-&gt;mHeaders.<span class="built_in">indexOfKey</span>(<span class="string">&quot;cseq&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// This is an unsolicited server-&gt;client message.</span></span><br><span class="line">        *index = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">    &#125;</span><br><span class="line">    AString value = response-&gt;mHeaders.<span class="built_in">valueAt</span>(i);</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> cseq;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">ParseSingleUnsignedLong</span>(value.<span class="built_in">c_str</span>(), &amp;cseq)) &#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR_MALFORMED;</span><br><span class="line">    &#125;</span><br><span class="line">    i = mPendingRequests.<span class="built_in">indexOfKey</span>(cseq);</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -ENOENT;</span><br><span class="line">    &#125;</span><br><span class="line">    *index = i;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>onSendRequest 会不断将请求放入mPendingRequests中，而每次服务器给出应答的时候会调用notifyResponseListener，notifyResponseListener会从mPendingRequests中取出一个应答消息，并发送消息给MyHandler进行处理，而notifyResponseListener又会阻塞等待下一个服务器的应答信号。</p>
<p>OK我们接下来看下收到‘desc’信号后的处理：</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">case <span class="string">&#x27;desc&#x27;</span>:</span><br><span class="line">&#123;</span><br><span class="line">    int32_t result;</span><br><span class="line">    CHECK(<span class="function"><span class="title">msg</span>-&gt;</span>findInt32(<span class="string">&quot;result&quot;</span>, &amp;result));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result == OK) &#123;</span><br><span class="line">        sp&lt;RefBase&gt; obj;</span><br><span class="line">        CHECK(<span class="function"><span class="title">msg</span>-&gt;</span>findObject(<span class="string">&quot;response&quot;</span>, &amp;obj));</span><br><span class="line">        sp&lt;ARTSPResponse&gt; response = static_cast&lt;ARTSPResponse *&gt;(obj.get());</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="title">if</span> (response-&gt;</span><span class="function"><span class="title">mStatusCode</span> == 301 || response-&gt;</span>mStatusCode == <span class="number">302</span>) &#123;</span><br><span class="line">            <span class="comment">//重定向连接</span></span><br><span class="line">            <span class="comment">//............</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">if</span> (response-&gt;</span>mStatusCode != <span class="number">200</span>) &#123;</span><br><span class="line">            result = UNKNOWN_ERROR;</span><br><span class="line">        &#125; <span class="function"><span class="title">else</span> <span class="keyword">if</span> (response-&gt;</span>mContent == NULL) &#123;</span><br><span class="line">            result = ERROR_MALFORMED;</span><br><span class="line">            ALOGE(<span class="string">&quot;The response has no content.&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//获得ASessionDescription</span></span><br><span class="line">            mSessionDesc = new ASessionDescription;</span><br><span class="line">            <span class="function"><span class="title">mSessionDesc</span>-&gt;</span><span class="function"><span class="title">setTo</span>(response-&gt;</span><span class="function"><span class="title">mContent</span>-&gt;</span><span class="function"><span class="title">data</span>(),response-&gt;</span><span class="function"><span class="title">mContent</span>-&gt;</span>size());</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="title">if</span> (!mSessionDesc-&gt;</span>isValid()) &#123;</span><br><span class="line">                <span class="comment">//............</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//............</span></span><br><span class="line">                <span class="function"><span class="title">if</span> (mSessionDesc-&gt;</span>countTracks() &lt; <span class="number">2</span>) &#123;</span><br><span class="line">                    <span class="comment">// There&#x27;s no actual tracks in this session.</span></span><br><span class="line">                    <span class="comment">// The first &quot;track&quot; is merely session meta</span></span><br><span class="line">                    <span class="comment">// data.</span></span><br><span class="line">                    ALOGW(<span class="string">&quot;Session doesn&#x27;t contain any playable &quot;</span></span><br><span class="line">                         <span class="string">&quot;tracks. Aborting.&quot;</span>);</span><br><span class="line">                    result = ERROR_UNSUPPORTED;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//这里才是真正要处理的代码</span></span><br><span class="line">                    setupTrack(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码很长我们忽略不重要的，直接看setupTrack。</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">void setupTrack(size_t index) &#123;</span><br><span class="line"></span><br><span class="line">    sp&lt;APacketSource&gt; source = new APacketSource(mSessionDesc, index);</span><br><span class="line">    AString url;</span><br><span class="line">    CHECK(<span class="function"><span class="title">mSessionDesc</span>-&gt;</span>findAttribute(index, <span class="string">&quot;a=control&quot;</span>, &amp;url));</span><br><span class="line">    AString trackURL;</span><br><span class="line">    <span class="comment">//获得多媒体文件的Uri</span></span><br><span class="line">    CHECK(MakeURL(mBaseURL.c_str(), url.c_str(), &amp;trackURL));</span><br><span class="line"></span><br><span class="line">    mTracks.push(TrackInfo());</span><br><span class="line">    TrackInfo *info = &amp;mTracks.editItemAt(mTracks.size() - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//设置uri</span></span><br><span class="line">    <span class="function"><span class="title">info</span>-&gt;</span>mURL = trackURL;</span><br><span class="line">    <span class="comment">//设置APacketSource</span></span><br><span class="line">    <span class="function"><span class="title">info</span>-&gt;</span>mPacketSource = source;</span><br><span class="line">    <span class="function"><span class="title">info</span>-&gt;</span>mUsingInterleavedTCP = <span class="literal">false</span>;</span><br><span class="line">    <span class="function"><span class="title">info</span>-&gt;</span>mFirstSeqNumInSegment = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="title">info</span>-&gt;</span>mNewSegment = <span class="literal">true</span>;</span><br><span class="line">    <span class="function"><span class="title">info</span>-&gt;</span>mRTPSocket = -<span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="title">info</span>-&gt;</span>mRTCPSocket = -<span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="title">info</span>-&gt;</span>mRTPAnchor = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="title">info</span>-&gt;</span>mNTPAnchorUs = -<span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="title">info</span>-&gt;</span>mNormalPlayTimeRTP = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="title">info</span>-&gt;</span>mNormalPlayTimeUs = <span class="number">0</span>ll;</span><br><span class="line"></span><br><span class="line">    unsigned long PT;</span><br><span class="line">    AString formatDesc;</span><br><span class="line">    AString formatParams;</span><br><span class="line">    <span class="function"><span class="title">mSessionDesc</span>-&gt;</span>getFormatType(index, &amp;PT, &amp;formatDesc, &amp;formatParams);</span><br><span class="line"></span><br><span class="line">    int32_t timescale;</span><br><span class="line">    int32_t numChannels;</span><br><span class="line">    ASessionDescription::ParseFormatDesc(formatDesc.c_str(), &amp;timescale, &amp;numChannels);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">info</span>-&gt;</span>mTimeScale = timescale;</span><br><span class="line">    <span class="function"><span class="title">info</span>-&gt;</span>mEOSReceived = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    ALOGV(<span class="string">&quot;track #%zu URL=%s&quot;</span>, mTracks.size(), trackURL.c_str());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//建立SETUP请求</span></span><br><span class="line">    AString request = <span class="string">&quot;SETUP &quot;</span>;</span><br><span class="line">    request.append(trackURL);</span><br><span class="line">    request.append(<span class="string">&quot; RTSP/1.0\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (mTryTCPInterleaving) &#123;</span><br><span class="line">        size_t interleaveIndex = <span class="number">2</span> * (mTracks.size() - <span class="number">1</span>);</span><br><span class="line">        <span class="function"><span class="title">info</span>-&gt;</span>mUsingInterleavedTCP = <span class="literal">true</span>;</span><br><span class="line">        <span class="function"><span class="title">info</span>-&gt;</span>mRTPSocket = interleaveIndex;</span><br><span class="line">        <span class="function"><span class="title">info</span>-&gt;</span>mRTCPSocket = interleaveIndex + <span class="number">1</span>;</span><br><span class="line">        request.append(<span class="string">&quot;Transport: RTP/AVP/TCP;interleaved=&quot;</span>);</span><br><span class="line">        request.append(interleaveIndex);</span><br><span class="line">        request.append(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">        request.append(interleaveIndex + <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        unsigned rtpPort;</span><br><span class="line">        ARTPConnection::MakePortPair(</span><br><span class="line">                &amp;<span class="function"><span class="title">info</span>-&gt;</span><span class="function"><span class="title">mRTPSocket</span>, &amp;info-&gt;</span>mRTCPSocket, &amp;rtpPort);</span><br><span class="line">        <span class="keyword">if</span> (mUIDValid) &#123;</span><br><span class="line">            HTTPB<span class="function"><span class="title">ase</span>::RegisterSocketUserTag(info-&gt;</span>mRTPSocket, mUID,</span><br><span class="line">                                            (uint32_t)*(uint32_t*) <span class="string">&quot;RTP_&quot;</span>);</span><br><span class="line">            HTTPB<span class="function"><span class="title">ase</span>::RegisterSocketUserTag(info-&gt;</span>mRTCPSocket, mUID,</span><br><span class="line">                                            (uint32_t)*(uint32_t*) <span class="string">&quot;RTP_&quot;</span>);</span><br><span class="line">            HTTPB<span class="function"><span class="title">ase</span>::RegisterSocketUserMark(info-&gt;</span>mRTPSocket, mUID);</span><br><span class="line">            HTTPB<span class="function"><span class="title">ase</span>::RegisterSocketUserMark(info-&gt;</span>mRTCPSocket, mUID);</span><br><span class="line">        &#125;</span><br><span class="line">        request.append(<span class="string">&quot;Transport: RTP/AVP/UDP;unicast;client_port=&quot;</span>);</span><br><span class="line">        request.append(rtpPort);</span><br><span class="line">        request.append(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">        request.append(rtpPort + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    request.append(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (index &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        request.append(<span class="string">&quot;Session: &quot;</span>);</span><br><span class="line">        request.append(mSessionID);</span><br><span class="line">        request.append(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    request.append(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">    sp&lt;AMessage&gt; reply = new AMessage(<span class="string">&#x27;setu&#x27;</span>, this);</span><br><span class="line">    <span class="function"><span class="title">reply</span>-&gt;</span>setSize(<span class="string">&quot;index&quot;</span>, index);</span><br><span class="line">    <span class="function"><span class="title">reply</span>-&gt;</span>setSize(<span class="string">&quot;track-index&quot;</span>, mTracks.size() - <span class="number">1</span>);</span><br><span class="line">    <span class="function"><span class="title">mConn</span>-&gt;</span>sendRequest(request.c_str(), reply);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的逻辑也很简单就是将要获取到的歌曲信息存放到mTracks，并使用sendRequest发起setu请求，sendRequest就不再作详细介绍了，我们直接看下‘setu’返回后的处理：</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">case <span class="string">&#x27;setu&#x27;</span>:</span><br><span class="line">&#123;</span><br><span class="line">    size_t index;</span><br><span class="line">    CHECK(<span class="function"><span class="title">msg</span>-&gt;</span>findSize(<span class="string">&quot;index&quot;</span>, &amp;index));</span><br><span class="line">    TrackInfo *track = NULL;</span><br><span class="line">    size_t trackIndex;</span><br><span class="line">    <span class="function"><span class="title">if</span> (msg-&gt;</span>findSize(<span class="string">&quot;track-index&quot;</span>, &amp;trackIndex)) &#123;</span><br><span class="line">        track = &amp;mTracks.editItemAt(trackIndex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int32_t result;</span><br><span class="line">    CHECK(<span class="function"><span class="title">msg</span>-&gt;</span>findInt32(<span class="string">&quot;result&quot;</span>, &amp;result));</span><br><span class="line">    <span class="keyword">if</span> (result == OK) &#123;</span><br><span class="line">        CHECK(track != NULL);</span><br><span class="line">        sp&lt;RefBase&gt; obj;</span><br><span class="line">        CHECK(<span class="function"><span class="title">msg</span>-&gt;</span>findObject(<span class="string">&quot;response&quot;</span>, &amp;obj));</span><br><span class="line">        sp&lt;ARTSPResponse&gt; response =</span><br><span class="line">            static_cast&lt;ARTSPResponse *&gt;(obj.get());</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">if</span> (response-&gt;</span>mStatusCode != <span class="number">200</span>) &#123;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="function"><span class="title">ssize_t</span> i = response-&gt;</span>mHeaders.indexOfKey(<span class="string">&quot;session&quot;</span>);</span><br><span class="line">            CHECK_GE(i, <span class="number">0</span>);</span><br><span class="line">            <span class="comment">//得到SessionID</span></span><br><span class="line">            <span class="function"><span class="title">mSessionID</span> = response-&gt;</span>mHeaders.valueAt(i);</span><br><span class="line">            mKeepAliveTimeoutUs = kDefaultKeepAliveTimeoutUs;</span><br><span class="line">            AString timeoutStr;</span><br><span class="line">            <span class="comment">//........................</span></span><br><span class="line">            sp&lt;AMessage&gt; notify = new AMessage(<span class="string">&#x27;accu&#x27;</span>, this);</span><br><span class="line">            <span class="function"><span class="title">notify</span>-&gt;</span>setSize(<span class="string">&quot;track-index&quot;</span>, trackIndex);</span><br><span class="line">            <span class="function"><span class="title">i</span> = response-&gt;</span>mHeaders.indexOfKey(<span class="string">&quot;transport&quot;</span>);</span><br><span class="line">            CHECK_GE(i, <span class="number">0</span>);</span><br><span class="line">            <span class="function"><span class="title">if</span> (track-&gt;</span><span class="function"><span class="title">mRTPSocket</span> != -1 &amp;&amp; track-&gt;</span>mRTCPSocket != -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="function"><span class="title">if</span> (!track-&gt;</span>mUsingInterleavedTCP) &#123;</span><br><span class="line">                    AS<span class="function"><span class="title">tring</span> transport = response-&gt;</span>mHeaders.valueAt(i);</span><br><span class="line">                    <span class="comment">// We are going to continue even if we were</span></span><br><span class="line">                    <span class="comment">// unable to poke a hole into the firewall...</span></span><br><span class="line">                    pokeAHole(</span><br><span class="line">                            <span class="function"><span class="title">track</span>-&gt;</span>mRTPSocket,</span><br><span class="line">                            <span class="function"><span class="title">track</span>-&gt;</span>mRTCPSocket,</span><br><span class="line">                            transport);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="function"><span class="title">mRTPConn</span>-&gt;</span>addStream(</span><br><span class="line">                        <span class="function"><span class="title">track</span>-&gt;</span><span class="function"><span class="title">mRTPSocket</span>, track-&gt;</span>mRTCPSocket,</span><br><span class="line">                        mSessionDesc, index,</span><br><span class="line">                        <span class="function"><span class="title">notify</span>, track-&gt;</span>mUsingInterleavedTCP);</span><br><span class="line">                mSetupTracksSuccessful = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                result = BAD_VALUE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面最重要的就是获取SessionID并调用mRTPConn-&gt;addStream完ARTPConnection中添加一个流，我们看下addStream：</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">void ARTPConnection::addStream(</span><br><span class="line">        int rtpSocket, int rtcpSocket,</span><br><span class="line">        const sp&lt;ASessionDescription&gt; &amp;sessionDesc,</span><br><span class="line">        size_t index,</span><br><span class="line">        const sp&lt;AMessage&gt; &amp;notify,</span><br><span class="line">        bool injected) &#123;</span><br><span class="line">    sp&lt;AMessage&gt; msg = new AMessage(kWhatAddStream, this);</span><br><span class="line">    <span class="function"><span class="title">msg</span>-&gt;</span>setInt32(<span class="string">&quot;rtp-socket&quot;</span>, rtpSocket);</span><br><span class="line">    <span class="function"><span class="title">msg</span>-&gt;</span>setInt32(<span class="string">&quot;rtcp-socket&quot;</span>, rtcpSocket);</span><br><span class="line">    <span class="function"><span class="title">msg</span>-&gt;</span>setObject(<span class="string">&quot;session-desc&quot;</span>, sessionDesc);</span><br><span class="line">    <span class="function"><span class="title">msg</span>-&gt;</span>setSize(<span class="string">&quot;index&quot;</span>, index);</span><br><span class="line">    <span class="function"><span class="title">msg</span>-&gt;</span>setMessage(<span class="string">&quot;notify&quot;</span>, notify);</span><br><span class="line">    <span class="function"><span class="title">msg</span>-&gt;</span>setInt32(<span class="string">&quot;injected&quot;</span>, injected);</span><br><span class="line">    <span class="function"><span class="title">msg</span>-&gt;</span>post();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">case kWhatAddStream:</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">onAddStream</span>(msg);</span><br><span class="line">    break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void ARTPConnection::on<span class="constructor">AddStream(<span class="params">const</span> <span class="params">sp</span>&lt;AMessage&gt; &amp;<span class="params">msg</span>)</span> &#123;</span><br><span class="line">    <span class="comment">//将Stream信息添加到mStreams</span></span><br><span class="line">    mStreams.push<span class="constructor">_back(StreamInfo()</span>);</span><br><span class="line">    StreamInfo *info = &amp;*--mStreams.<span class="keyword">end</span><span class="literal">()</span>;</span><br><span class="line">    int32_t s;</span><br><span class="line">    <span class="comment">//获得rtp-socket</span></span><br><span class="line">    <span class="constructor">CHECK(<span class="params">msg</span>-&gt;<span class="params">findInt32</span>(<span class="string">&quot;rtp-socket&quot;</span>, &amp;<span class="params">s</span>)</span>);</span><br><span class="line">    info-&gt;mRTPSocket = s;</span><br><span class="line">    <span class="comment">//获得rtcp-socket</span></span><br><span class="line">    <span class="constructor">CHECK(<span class="params">msg</span>-&gt;<span class="params">findInt32</span>(<span class="string">&quot;rtcp-socket&quot;</span>, &amp;<span class="params">s</span>)</span>);</span><br><span class="line">    info-&gt;mRTCPSocket = s;</span><br><span class="line"></span><br><span class="line">    int32_t injected;</span><br><span class="line">    <span class="constructor">CHECK(<span class="params">msg</span>-&gt;<span class="params">findInt32</span>(<span class="string">&quot;injected&quot;</span>, &amp;<span class="params">injected</span>)</span>);</span><br><span class="line"></span><br><span class="line">    info-&gt;mIsInjected = injected;</span><br><span class="line">    <span class="comment">//获得session-desc</span></span><br><span class="line">    sp&lt;RefBase&gt; obj;</span><br><span class="line">    <span class="constructor">CHECK(<span class="params">msg</span>-&gt;<span class="params">findObject</span>(<span class="string">&quot;session-desc&quot;</span>, &amp;<span class="params">obj</span>)</span>);</span><br><span class="line">    info-&gt;mSessionDesc = static_cast&lt;ASessionDescription *&gt;(obj.get<span class="literal">()</span>);</span><br><span class="line"></span><br><span class="line">    <span class="constructor">CHECK(<span class="params">msg</span>-&gt;<span class="params">findSize</span>(<span class="string">&quot;index&quot;</span>, &amp;<span class="params">info</span>-&gt;<span class="params">mIndex</span>)</span>);</span><br><span class="line">    <span class="constructor">CHECK(<span class="params">msg</span>-&gt;<span class="params">findMessage</span>(<span class="string">&quot;notify&quot;</span>, &amp;<span class="params">info</span>-&gt;<span class="params">mNotifyMsg</span>)</span>);</span><br><span class="line"></span><br><span class="line">    info-&gt;mNumRTCPPacketsReceived = <span class="number">0</span>;</span><br><span class="line">    info-&gt;mNumRTPPacketsReceived = <span class="number">0</span>;</span><br><span class="line">    memset(&amp;info-&gt;mRemoteRTCPAddr, <span class="number">0</span>, sizeof(info-&gt;mRemoteRTCPAddr));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发送轮询查询事件</span></span><br><span class="line">    <span class="keyword">if</span> (!injected) &#123;</span><br><span class="line">        post<span class="constructor">PollEvent()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中重点关注的是postPollEvent：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title class_">ARTPConnection</span>::<span class="title function_">postPollEvent</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (mPollEventPending) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sp&lt;<span class="title class_">AMessage</span>&gt; msg = <span class="keyword">new</span> <span class="title class_">AMessage</span>(kWhatPollStreams, <span class="variable language_">this</span>);</span><br><span class="line">    msg-&gt;<span class="title function_">post</span>();</span><br><span class="line">    mPollEventPending = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">case kWhatPollStreams:</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">onPollStreams</span>();</span><br><span class="line">    break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">void ARTPConnection::onPollStreams() &#123;</span><br><span class="line">    mPollEventPending = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mStreams.empty()) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    struct timeval tv;</span><br><span class="line">    tv.tv_sec = <span class="number">0</span>;</span><br><span class="line">    tv.tv_usec = kSelectTimeoutUs;</span><br><span class="line"></span><br><span class="line">    fd_set rs;</span><br><span class="line">    FD_ZERO(&amp;rs);</span><br><span class="line"></span><br><span class="line">    int maxSocket = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (List&lt;StreamInfo&gt;::iterator it = mStreams.begin();</span><br><span class="line">         it != mStreams.end(); ++it) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((*it).mIsInjected) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        FD_SET(<span class="function"><span class="title">it</span>-&gt;</span>mRTPSocket, &amp;rs);</span><br><span class="line">        FD_SET(<span class="function"><span class="title">it</span>-&gt;</span>mRTCPSocket, &amp;rs);</span><br><span class="line">        <span class="function"><span class="title">if</span> (it-&gt;</span>mRTPSocket &gt; maxSocket) &#123;</span><br><span class="line">            <span class="function"><span class="title">maxSocket</span> = it-&gt;</span>mRTPSocket;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="title">if</span> (it-&gt;</span>mRTCPSocket &gt; maxSocket) &#123;</span><br><span class="line">            <span class="function"><span class="title">maxSocket</span> = it-&gt;</span>mRTCPSocket;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (maxSocket == -<span class="number">1</span>) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//选择一个网络请求</span></span><br><span class="line">    int res = select(maxSocket + <span class="number">1</span>, &amp;rs, NULL, NULL, &amp;tv);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (res &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//在这里接收服务器发过来的数据</span></span><br><span class="line">        List&lt;StreamInfo&gt;::iterator it = mStreams.begin();</span><br><span class="line">        <span class="keyword">while</span> (it != mStreams.end()) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((*it).mIsInjected) &#123;</span><br><span class="line">                ++it;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            status_t err = OK;</span><br><span class="line">            <span class="comment">//接受从服务器发来的数据</span></span><br><span class="line">            <span class="function"><span class="title">if</span> (FD_ISSET(it-&gt;</span>mRTPSocket, &amp;rs)) &#123;</span><br><span class="line">                <span class="comment">//调用的是status_t ARTPConnection::receive(StreamInfo *s, bool receiveRTP)</span></span><br><span class="line">                err = receive(&amp;*it, <span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//接受从服务器发来的数据</span></span><br><span class="line">            <span class="function"><span class="title">if</span> (err == OK &amp;&amp; FD_ISSET(it-&gt;</span>mRTCPSocket, &amp;rs)) &#123;</span><br><span class="line">                <span class="comment">//调用的是status_t ARTPConnection::receive(StreamInfo *s, bool receiveRTP)</span></span><br><span class="line">                err = receive(&amp;*it, <span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            ++it;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int64_t nowUs = ALooper::GetNowUs();</span><br><span class="line">    <span class="keyword">if</span> (mLastReceiverReportTimeUs &lt;= <span class="number">0</span>|| mLastReceiverReportTimeUs + <span class="number">5000000</span>ll &lt;= nowUs) &#123;</span><br><span class="line">        <span class="comment">//新建一个缓存区</span></span><br><span class="line">        sp&lt;ABuffer&gt; buffer = new ABuffer(kMaxUDPSize);</span><br><span class="line">        List&lt;StreamInfo&gt;::iterator it = mStreams.begin();</span><br><span class="line">        <span class="keyword">while</span> (it != mStreams.end()) &#123;</span><br><span class="line">            StreamInfo *s = &amp;*it;</span><br><span class="line">            <span class="function"><span class="title">if</span> (s-&gt;</span>mIsInjected) &#123;</span><br><span class="line">                ++it;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="title">if</span> (s-&gt;</span>mNumRTCPPacketsReceived == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// We have never received any RTCP packets on this stream,</span></span><br><span class="line">                <span class="comment">// we don&#x27;t even know where to send a report.</span></span><br><span class="line">                ++it;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="title">buffer</span>-&gt;</span>setRange(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="function"><span class="title">for</span> (size_t i = 0; i &lt; s-&gt;</span>mSources.size(); ++i) &#123;</span><br><span class="line">                <span class="function"><span class="title">sp</span>&lt;ARTPSource&gt; source = s-&gt;</span>mSources.valueAt(i);</span><br><span class="line">                <span class="comment">//填充buffer</span></span><br><span class="line">                <span class="function"><span class="title">source</span>-&gt;</span>addReceiverReport(buffer);</span><br><span class="line">                <span class="keyword">if</span> (mFlags &amp; kRegularlyRequestFIR) &#123;</span><br><span class="line">                    <span class="function"><span class="title">source</span>-&gt;</span>addFIR(buffer);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="title">if</span> (buffer-&gt;</span>size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                ALOGV(<span class="string">&quot;Sending RR...&quot;</span>);</span><br><span class="line">                ssize_t n;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="comment">//通過RTCPSocket發送</span></span><br><span class="line">                    <span class="function"><span class="title">n</span> = sendto(s-&gt;</span><span class="function"><span class="title">mRTCPSocket</span>, buffer-&gt;</span><span class="function"><span class="title">data</span>(), buffer-&gt;</span><span class="function"><span class="title">size</span>(), 0,(const struct sockaddr *)&amp;s-&gt;</span><span class="function"><span class="title">mRemoteRTCPAddr</span>, sizeof(s-&gt;</span>mRemoteRTCPAddr));</span><br><span class="line">                &#125; <span class="keyword">while</span> (n &lt; <span class="number">0</span> &amp;&amp; errno == EINTR);</span><br><span class="line">                CHECK_EQ(<span class="function"><span class="title">n</span>, (ssize_t)buffer-&gt;</span>size());</span><br><span class="line">                mLastReceiverReportTimeUs = nowUs;</span><br><span class="line">            &#125;</span><br><span class="line">            ++it;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mStreams.empty()) &#123;</span><br><span class="line">        postPollEvent();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再onPollStreams中会阻塞监听服务器发过来的媒体数据，并调用receive对其进行处理，并定期发送RTCP消息给服务器。</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">status_t ARTPConnection::receive(StreamInfo *s, bool receiveRTP) &#123;</span><br><span class="line">    </span><br><span class="line">    ALOGV(<span class="string">&quot;receiving %s&quot;</span>, receiveRTP ? <span class="string">&quot;RTP&quot;</span> : <span class="string">&quot;RTCP&quot;</span>);</span><br><span class="line"></span><br><span class="line">    CHECK(!<span class="function"><span class="title">s</span>-&gt;</span>mIsInjected);</span><br><span class="line"></span><br><span class="line">    sp&lt;ABuffer&gt; buffer = new ABuffer(<span class="number">65536</span>);</span><br><span class="line"></span><br><span class="line">    socklen_t remoteAddrLen =</span><br><span class="line">        (!<span class="function"><span class="title">receiveRTP</span> &amp;&amp; s-&gt;</span>mNumRTCPPacketsReceived == <span class="number">0</span>)</span><br><span class="line">            ? <span class="function"><span class="title">sizeof</span>(s-&gt;</span>mRemoteRTCPAddr) : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    ssize_t nbytes;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">//从服务器接收数据</span></span><br><span class="line">        nbytes = recvfrom(</span><br><span class="line">            <span class="function"><span class="title">receiveRTP</span> ? s-&gt;</span><span class="function"><span class="title">mRTPSocket</span> : s-&gt;</span>mRTCPSocket,</span><br><span class="line">            <span class="function"><span class="title">buffer</span>-&gt;</span><span class="keyword">data</span>(),</span><br><span class="line">            <span class="function"><span class="title">buffer</span>-&gt;</span>capacity(),</span><br><span class="line">            <span class="number">0</span>,</span><br><span class="line">            <span class="function"><span class="title">remoteAddrLen</span> &gt; 0 ? (struct sockaddr *)&amp;s-&gt;</span>mRemoteRTCPAddr : NULL,</span><br><span class="line">            remoteAddrLen &gt; <span class="number">0</span> ? &amp;remoteAddrLen : NULL);</span><br><span class="line">    &#125; <span class="keyword">while</span> (nbytes &lt; <span class="number">0</span> &amp;&amp; errno == EINTR);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nbytes &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        return -ECONNRESET;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">buffer</span>-&gt;</span>setRange(<span class="number">0</span>, nbytes);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ALOGI(&quot;received %d bytes.&quot;, buffer-&gt;size());</span></span><br><span class="line"></span><br><span class="line">    status_t err;</span><br><span class="line">    <span class="comment">//解析RTP 或者 parseRTCP</span></span><br><span class="line">    <span class="keyword">if</span> (receiveRTP) &#123;</span><br><span class="line">        err = parseRTP(s, buffer);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        err = parseRTCP(s, buffer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>receive方法中会调用recvfrom。将数据从服务器中读取到缓存，并调用parseRTP或者parseRTCP对缓存中的数据进行处理</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">ARTPConnection::parseRTP</span><span class="params">(StreamInfo *s, <span class="type">const</span> sp&lt;ABuffer&gt; &amp;buffer)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">const</span> <span class="type">uint8_t</span> *data = buffer-&gt;<span class="built_in">data</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((data[<span class="number">0</span>] &gt;&gt; <span class="number">6</span>) != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// Unsupported version.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (data[<span class="number">0</span>] &amp; <span class="number">0x20</span>) &#123;</span><br><span class="line">        <span class="comment">// Padding present.</span></span><br><span class="line"></span><br><span class="line">        <span class="type">size_t</span> paddingLength = data[size - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (paddingLength + <span class="number">12</span> &gt; size) &#123;</span><br><span class="line">            <span class="comment">// If we removed this much padding we&#x27;d end up with something</span></span><br><span class="line">            <span class="comment">// that&#x27;s too short to be a valid RTP header.</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        size -= paddingLength;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> numCSRCs = data[<span class="number">0</span>] &amp; <span class="number">0x0f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> payloadOffset = <span class="number">12</span> + <span class="number">4</span> * numCSRCs;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size &lt; payloadOffset) &#123;</span><br><span class="line">        <span class="comment">// Not enough data to fit the basic header and all the CSRC entries.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (data[<span class="number">0</span>] &amp; <span class="number">0x10</span>) &#123;</span><br><span class="line">        <span class="comment">// Header eXtension present.</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (size &lt; payloadOffset + <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="comment">// Not enough data to fit the basic header, all CSRC entries</span></span><br><span class="line">            <span class="comment">// and the first 4 bytes of the extension header.</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> <span class="type">uint8_t</span> *extensionData = &amp;data[payloadOffset];</span><br><span class="line"></span><br><span class="line">        <span class="type">size_t</span> extensionLength =</span><br><span class="line">            <span class="number">4</span> * (extensionData[<span class="number">2</span>] &lt;&lt; <span class="number">8</span> | extensionData[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (size &lt; payloadOffset + <span class="number">4</span> + extensionLength) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        payloadOffset += <span class="number">4</span> + extensionLength;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> srcId = <span class="built_in">u32at</span>(&amp;data[<span class="number">8</span>]);</span><br><span class="line"></span><br><span class="line">    sp&lt;ARTPSource&gt; source = <span class="built_in">findSource</span>(s, srcId);</span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> rtpTime = <span class="built_in">u32at</span>(&amp;data[<span class="number">4</span>]);</span><br><span class="line"></span><br><span class="line">    sp&lt;AMessage&gt; meta = buffer-&gt;<span class="built_in">meta</span>();</span><br><span class="line">    meta-&gt;<span class="built_in">setInt32</span>(<span class="string">&quot;ssrc&quot;</span>, srcId);</span><br><span class="line">    meta-&gt;<span class="built_in">setInt32</span>(<span class="string">&quot;rtp-time&quot;</span>, rtpTime);</span><br><span class="line">    meta-&gt;<span class="built_in">setInt32</span>(<span class="string">&quot;PT&quot;</span>, data[<span class="number">1</span>] &amp; <span class="number">0x7f</span>);</span><br><span class="line">    meta-&gt;<span class="built_in">setInt32</span>(<span class="string">&quot;M&quot;</span>, data[<span class="number">1</span>] &gt;&gt; <span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">    buffer-&gt;<span class="built_in">setInt32Data</span>(<span class="built_in">u16at</span>(&amp;data[<span class="number">2</span>]));</span><br><span class="line">    buffer-&gt;<span class="built_in">setRange</span>(payloadOffset, size - payloadOffset);</span><br><span class="line">    <span class="comment">//这里十分重要void ARTPSource::processRTPPacket(const sp&lt;ABuffer&gt; &amp;buffer)</span></span><br><span class="line">    source-&gt;<span class="built_in">processRTPPacket</span>(buffer);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在parsRTP中根据RTP格式对缓存区中的数据进行解析，最后调用ARTPSource::processRTPPacket进行后续处理。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void ARTPSource::process<span class="constructor">RTPPacket(<span class="params">const</span> <span class="params">sp</span>&lt;ABuffer&gt; &amp;<span class="params">buffer</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (queue<span class="constructor">Packet(<span class="params">buffer</span>)</span><span class="operator"> &amp;&amp; </span>mAssembler != NULL) &#123;</span><br><span class="line">        mAssembler-&gt;on<span class="constructor">PacketReceived(<span class="params">this</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>processRTPPacket中调用Assembler来将数据进行重组，这里最重要的方法是assembleMore</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void ARTPAssembler::on<span class="constructor">PacketReceived(<span class="params">const</span> <span class="params">sp</span>&lt;ARTPSource&gt; &amp;<span class="params">source</span>)</span> &#123;</span><br><span class="line">    AssemblyStatus status;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//assembleMore</span></span><br><span class="line">        status = assemble<span class="constructor">More(<span class="params">source</span>)</span>;</span><br><span class="line">        <span class="keyword">if</span> (status<span class="operator"> == </span>WRONG_SEQUENCE_NUMBER) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mFirstFailureTimeUs &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ALooper::<span class="constructor">GetNowUs()</span> - mFirstFailureTimeUs &gt; <span class="number">10000l</span>l) &#123;</span><br><span class="line">                    mFirstFailureTimeUs = -<span class="number">1</span>;</span><br><span class="line">                    <span class="comment">// LOG(VERBOSE) &lt;&lt; &quot;waited too long for packet.&quot;;</span></span><br><span class="line">                    packet<span class="constructor">Lost()</span>;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mFirstFailureTimeUs = ALooper::<span class="constructor">GetNowUs()</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mFirstFailureTimeUs = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (status<span class="operator"> == </span>NOT_ENOUGH_DATA) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">ARTPAssembler</span>::<span class="title class_">AssemblyStatus</span> <span class="title class_">AMPEG4AudioAssembler</span>::<span class="title function_">assembleMore</span>(<span class="params"></span></span><br><span class="line"><span class="params">        <span class="keyword">const</span> sp&lt;ARTPSource&gt; &amp;source</span>) &#123;</span><br><span class="line">        <span class="comment">//调用addPacket</span></span><br><span class="line">    <span class="title class_">AssemblyStatus</span> status = <span class="title function_">addPacket</span>(source);</span><br><span class="line">    <span class="keyword">if</span> (status == <span class="variable constant_">MALFORMED_PACKET</span>) &#123;</span><br><span class="line">        mAccessUnitDamaged = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里实际上是对无序的数据包进行排序，并调用submitAccessUnit提交AU数据。</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">ARTPAssembler::AssemblyStatus AMPEG4AudioAssembler::addPacket(</span><br><span class="line">        <span class="keyword">const</span> sp&lt;ARTPSource&gt; &amp;source) &#123;</span><br><span class="line"></span><br><span class="line">    List&lt;sp&lt;ABuffer&gt; &gt; *queue = source-&gt;queue();</span><br><span class="line">    <span class="keyword">if</span> (queue-&gt;empty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> NOT_ENOUGH_DATA;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mNextExpectedSeqNoValid) &#123;</span><br><span class="line">        List&lt;sp&lt;ABuffer&gt; &gt;::iterator <span class="literal">it</span> = queue-&gt;begin();</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">it</span> != queue-&gt;end()) &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="function"><span class="params">((uint32_t)(*<span class="literal">it</span>)-&gt;int32Data() &gt;= mNextExpectedSeqNo)</span> &#123;</span></span><br><span class="line"><span class="function">                <span class="title">break</span>;</span></span><br><span class="line"><span class="function">            &#125;</span></span><br><span class="line"><span class="function">            <span class="title">it</span> = <span class="title">queue</span>-&gt;</span>erase(<span class="literal">it</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (queue-&gt;empty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> NOT_ENOUGH_DATA;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sp&lt;ABuffer&gt; buffer = *queue-&gt;begin();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mNextExpectedSeqNoValid) &#123;</span><br><span class="line">        mNextExpectedSeqNoValid = <span class="literal">true</span>;</span><br><span class="line">        mNextExpectedSeqNo = (uint32_t)buffer-&gt;int32Data();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((uint32_t)buffer-&gt;int32Data() != mNextExpectedSeqNo) &#123;</span><br><span class="line"><span class="comment">#if VERBOSE</span></span><br><span class="line">        LOG(VERBOSE) &lt;&lt; <span class="string">&quot;Not the sequence number I expected&quot;</span>;</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">        <span class="keyword">return</span> WRONG_SEQUENCE_NUMBER;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    uint32_t rtpTime;</span><br><span class="line">    CHECK<span class="function"><span class="params">(buffer-&gt;meta()-&gt;findInt32(<span class="string">&quot;rtp-time&quot;</span>, (int32_t *)&amp;rtpTime))</span>;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    //提交<span class="title">AccessUnit</span></span></span><br><span class="line"><span class="function">    <span class="title">if</span> <span class="params">(mPackets.size() &gt; <span class="number">0</span> &amp;&amp; rtpTime != mAccessUnitRTPTime)</span> &#123;</span></span><br><span class="line"><span class="function">        <span class="title">submitAccessUnit</span><span class="params">()</span>;</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function">    <span class="title">mAccessUnitRTPTime</span> = <span class="title">rtpTime</span>;</span></span><br><span class="line"><span class="function">    //将缓存添加到<span class="title">mPackets</span></span></span><br><span class="line"><span class="function">    <span class="title">mPackets</span>.<span class="title">push_back</span><span class="params">(buffer)</span>;</span></span><br><span class="line"><span class="function">    <span class="title">queue</span>-&gt;</span>erase(queue-&gt;begin());</span><br><span class="line">    ++mNextExpectedSeqNo;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>submitAccessUnit中回调‘accu’，交给MyHandler处理</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void AMPEG4AudioAssembler::submit<span class="constructor">AccessUnit()</span> &#123;</span><br><span class="line">    <span class="constructor">CHECK(!<span class="params">mPackets</span>.<span class="params">empty</span>()</span>);</span><br><span class="line"></span><br><span class="line">#<span class="keyword">if</span> VERBOSE</span><br><span class="line">    <span class="constructor">LOG(VERBOSE)</span> &lt;&lt; <span class="string">&quot;Access unit complete (&quot;</span> &lt;&lt; mPackets.size<span class="literal">()</span> &lt;&lt; <span class="string">&quot; packets)&quot;</span>;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    sp&lt;ABuffer&gt; accessUnit = <span class="constructor">MakeCompoundFromPackets(<span class="params">mPackets</span>)</span>;</span><br><span class="line">    accessUnit = remove<span class="constructor">LATMFraming(<span class="params">accessUnit</span>)</span>;</span><br><span class="line">    <span class="constructor">CopyTimes(<span class="params">accessUnit</span>, <span class="operator">*</span><span class="params">mPackets</span>.<span class="params">begin</span>()</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mAccessUnitDamaged) &#123;</span><br><span class="line">        accessUnit-&gt;meta<span class="literal">()</span>-&gt;set<span class="constructor">Int32(<span class="string">&quot;damaged&quot;</span>, <span class="params">true</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mPackets.clear<span class="literal">()</span>;</span><br><span class="line">    mAccessUnitDamaged = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//回调‘accu’</span></span><br><span class="line">    sp&lt;AMessage&gt; msg = mNotifyMsg-&gt;dup<span class="literal">()</span>;</span><br><span class="line">    msg-&gt;set<span class="constructor">Buffer(<span class="string">&quot;access-unit&quot;</span>, <span class="params">accessUnit</span>)</span>;</span><br><span class="line">    msg-&gt;post<span class="literal">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">case <span class="string">&#x27;accu&#x27;</span>:</span><br><span class="line">&#123;</span><br><span class="line">    int32_t timeUpdate;</span><br><span class="line">    <span class="function"><span class="title">if</span> (msg-&gt;</span>findInt32(<span class="string">&quot;time-update&quot;</span>, &amp;timeUpdate) &amp;&amp; timeUpdate) &#123;</span><br><span class="line">        size_t trackIndex;</span><br><span class="line">        CHECK(<span class="function"><span class="title">msg</span>-&gt;</span>findSize(<span class="string">&quot;track-index&quot;</span>, &amp;trackIndex));</span><br><span class="line"></span><br><span class="line">        uint32_t rtpTime;</span><br><span class="line">        uint64_t ntpTime;</span><br><span class="line">        CHECK(<span class="function"><span class="title">msg</span>-&gt;</span>findInt32(<span class="string">&quot;rtp-time&quot;</span>, (int32_t *)&amp;rtpTime));</span><br><span class="line">        CHECK(<span class="function"><span class="title">msg</span>-&gt;</span>findInt64(<span class="string">&quot;ntp-time&quot;</span>, (int64_t *)&amp;ntpTime));</span><br><span class="line"></span><br><span class="line">        onTimeUpdate(trackIndex, rtpTime, ntpTime);</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int32_t first;</span><br><span class="line">    <span class="function"><span class="title">if</span> (msg-&gt;</span>findInt32(<span class="string">&quot;first-rtcp&quot;</span>, &amp;first)) &#123;</span><br><span class="line">        mReceivedFirstRTCPPacket = <span class="literal">true</span>;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">if</span> (msg-&gt;</span>findInt32(<span class="string">&quot;first-rtp&quot;</span>, &amp;first)) &#123;</span><br><span class="line">        mReceivedFirstRTPPacket = <span class="literal">true</span>;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ++mNumAccessUnitsReceived;</span><br><span class="line">    postAccessUnitTimeoutCheck();</span><br><span class="line"></span><br><span class="line">    size_t trackIndex;</span><br><span class="line">    CHECK(<span class="function"><span class="title">msg</span>-&gt;</span>findSize(<span class="string">&quot;track-index&quot;</span>, &amp;trackIndex));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (trackIndex &gt;= mTracks.size()) &#123;</span><br><span class="line">        ALOGV(<span class="string">&quot;late packets ignored.&quot;</span>);</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TrackInfo *track = &amp;mTracks.editItemAt(trackIndex);</span><br><span class="line"></span><br><span class="line">    int32_t eos;</span><br><span class="line">    <span class="function"><span class="title">if</span> (msg-&gt;</span>findInt32(<span class="string">&quot;eos&quot;</span>, &amp;eos)) &#123;</span><br><span class="line">        ALOGI(<span class="string">&quot;received BYE on track index %zu&quot;</span>, trackIndex);</span><br><span class="line">        <span class="keyword">if</span> (!mAllTracksHaveTime &amp;&amp; dataReceivedOnAllChannels()) &#123;</span><br><span class="line">            ALOGI(<span class="string">&quot;No time established =&gt; fake existing data&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="title">track</span>-&gt;</span>mEOSReceived = <span class="literal">true</span>;</span><br><span class="line">            mTryFakeRTCP = <span class="literal">true</span>;</span><br><span class="line">            mReceivedFirstRTCPPacket = <span class="literal">true</span>;</span><br><span class="line">            fakeTimestamps();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            postQueueEOS(trackIndex, ERROR_END_OF_STREAM);</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sp&lt;ABuffer&gt; accessUnit;</span><br><span class="line">    <span class="comment">//取出accessUnit</span></span><br><span class="line">    CHECK(<span class="function"><span class="title">msg</span>-&gt;</span>findBuffer(<span class="string">&quot;access-unit&quot;</span>, &amp;accessUnit));</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">uint32_t</span> seqNum = (uint32_t)accessUnit-&gt;</span>int32Data();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mSeekPending) &#123;</span><br><span class="line">        ALOGV(<span class="string">&quot;we&#x27;re seeking, dropping stale packet.&quot;</span>);</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">if</span> (seqNum &lt; track-&gt;</span>mFirstSeqNumInSegment) &#123;</span><br><span class="line">        ALOGV(<span class="string">&quot;dropping stale access-unit (%d &lt; %d)&quot;</span>,</span><br><span class="line">             <span class="function"><span class="title">seqNum</span>, track-&gt;</span>mFirstSeqNumInSegment);</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">if</span> (track-&gt;</span>mNewSegment) &#123;</span><br><span class="line">        <span class="function"><span class="title">track</span>-&gt;</span>mNewSegment = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//调用onAccessUnitComplete</span></span><br><span class="line">    onAccessUnitComplete(trackIndex, accessUnit);</span><br><span class="line">    break;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>‘accu’取出AU数据后调用onAccessUnitComplete进行处理，我们接下来看下这部分逻辑：</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">void onAccessUnitComplete(</span><br><span class="line">        int32_t trackIndex, const sp&lt;ABuffer&gt; &amp;accessUnit) &#123;</span><br><span class="line">    ALOGV(<span class="string">&quot;onAccessUnitComplete track %d&quot;</span>, trackIndex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!mPlayResponseParsed)&#123;</span><br><span class="line">        ALOGI(<span class="string">&quot;play response is not parsed, storing accessunit&quot;</span>);</span><br><span class="line">        TrackInfo *track = &amp;mTracks.editItemAt(trackIndex);</span><br><span class="line">        <span class="function"><span class="title">track</span>-&gt;</span>mPackets.push_back(accessUnit);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    handleFirstAccessUnit();</span><br><span class="line"></span><br><span class="line">    TrackInfo *track = &amp;mTracks.editItemAt(trackIndex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mAllTracksHaveTime) &#123;</span><br><span class="line">        ALOGV(<span class="string">&quot;storing accessUnit, no time established yet&quot;</span>);</span><br><span class="line">        <span class="function"><span class="title">track</span>-&gt;</span>mPackets.push_back(accessUnit);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">while</span> (!track-&gt;</span>mPackets.empty()) &#123;</span><br><span class="line">        <span class="function"><span class="title">sp</span>&lt;ABuffer&gt; accessUnit = *track-&gt;</span>mPackets.begin();</span><br><span class="line">        <span class="function"><span class="title">track</span>-&gt;</span><span class="function"><span class="title">mPackets</span>.erase(track-&gt;</span>mPackets.begin());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (addMediaTimestamp(trackIndex, track, accessUnit)) &#123;</span><br><span class="line">            <span class="comment">//postQueueAccessUnit</span></span><br><span class="line">            postQueueAccessUnit(trackIndex, accessUnit);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (addMediaTimestamp(trackIndex, track, accessUnit)) &#123;</span><br><span class="line">        postQueueAccessUnit(trackIndex, accessUnit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">if</span> (track-&gt;</span>mEOSReceived) &#123;</span><br><span class="line">        postQueueEOS(trackIndex, ERROR_END_OF_STREAM);</span><br><span class="line">        <span class="function"><span class="title">track</span>-&gt;</span>mEOSReceived = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">void postQueueAccessUnit(</span><br><span class="line">        size_t trackIndex, const sp&lt;ABuffer&gt; &amp;accessUnit) &#123;</span><br><span class="line">    <span class="function"><span class="title">sp</span>&lt;AMessage&gt; msg = mNotify-&gt;</span>dup();</span><br><span class="line">    <span class="function"><span class="title">msg</span>-&gt;</span>setInt32(<span class="string">&quot;what&quot;</span>, kWhatAccessUnit);</span><br><span class="line">    <span class="function"><span class="title">msg</span>-&gt;</span>setSize(<span class="string">&quot;trackIndex&quot;</span>, trackIndex);</span><br><span class="line">    <span class="function"><span class="title">msg</span>-&gt;</span>setBuffer(<span class="string">&quot;accessUnit&quot;</span>, accessUnit);</span><br><span class="line">    <span class="function"><span class="title">msg</span>-&gt;</span>post();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在RTSPSource中调用AnotherPacketSource  queueAccessUnit(accessUnit)</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">case MyHandler::kWhatAccessUnit:</span><br><span class="line">&#123;</span><br><span class="line">    size_t trackIndex;</span><br><span class="line">    CHECK(<span class="function"><span class="title">msg</span>-&gt;</span>findSize(<span class="string">&quot;trackIndex&quot;</span>, &amp;trackIndex));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mTSParser == NULL) &#123;</span><br><span class="line">        CHECK_LT(trackIndex, mTracks.size());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        CHECK_EQ(trackIndex, <span class="number">0</span>u);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sp&lt;ABuffer&gt; accessUnit;</span><br><span class="line">    CHECK(<span class="function"><span class="title">msg</span>-&gt;</span>findBuffer(<span class="string">&quot;accessUnit&quot;</span>, &amp;accessUnit));</span><br><span class="line"></span><br><span class="line">    int32_t damaged;</span><br><span class="line">    <span class="function"><span class="title">if</span> (accessUnit-&gt;</span><span class="function"><span class="title">meta</span>()-&gt;</span>findInt32(<span class="string">&quot;damaged&quot;</span>, &amp;damaged)</span><br><span class="line">            &amp;&amp; damaged) &#123;</span><br><span class="line">        ALOGI(<span class="string">&quot;dropping damaged access unit.&quot;</span>);</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mTSParser != NULL) &#123;</span><br><span class="line">        size_t offset = <span class="number">0</span>;</span><br><span class="line">        status_t err = OK;</span><br><span class="line">        <span class="function"><span class="title">while</span> (offset + 188 &lt;= accessUnit-&gt;</span>size()) &#123;</span><br><span class="line">            <span class="function"><span class="title">err</span> = mTSParser-&gt;</span>feedTSPacket(</span><br><span class="line">                    <span class="function"><span class="title">accessUnit</span>-&gt;</span><span class="keyword">data</span>() + offset, <span class="number">188</span>);</span><br><span class="line">            <span class="keyword">if</span> (err != OK) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            offset += <span class="number">188</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">if</span> (offset &lt; accessUnit-&gt;</span>size()) &#123;</span><br><span class="line">            err = ERROR_MALFORMED;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (err != OK) &#123;</span><br><span class="line">            sp&lt;AnotherPacketSource&gt; source = getSource(<span class="literal">false</span> <span class="comment">/* audio */</span>);</span><br><span class="line">            <span class="keyword">if</span> (source != NULL) &#123;</span><br><span class="line">                <span class="function"><span class="title">source</span>-&gt;</span>signalEOS(err);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            source = getSource(<span class="literal">true</span> <span class="comment">/* audio */</span>);</span><br><span class="line">            <span class="keyword">if</span> (source != NULL) &#123;</span><br><span class="line">                <span class="function"><span class="title">source</span>-&gt;</span>signalEOS(err);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TrackInfo *info = &amp;mTracks.editItemAt(trackIndex);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">sp</span>&lt;AnotherPacketSource&gt; source = info-&gt;</span>mSource;</span><br><span class="line">    <span class="keyword">if</span> (source != NULL) &#123;</span><br><span class="line">        uint32_t rtpTime;</span><br><span class="line">        CHECK(<span class="function"><span class="title">accessUnit</span>-&gt;</span><span class="function"><span class="title">meta</span>()-&gt;</span>findInt32(<span class="string">&quot;rtp-time&quot;</span>, (int32_t *)&amp;rtpTime));</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">if</span> (!info-&gt;</span>mNPTMappingValid) &#123;</span><br><span class="line">            <span class="comment">// This is a live stream, we didn&#x27;t receive any normal</span></span><br><span class="line">            <span class="comment">// playtime mapping. We won&#x27;t map to npt time.</span></span><br><span class="line">            <span class="function"><span class="title">source</span>-&gt;</span>queueAccessUnit(accessUnit);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int64_t nptUs =</span><br><span class="line">            ((<span class="function"><span class="title">double</span>)rtpTime - (double)info-&gt;</span>mRTPTime)</span><br><span class="line">                / <span class="function"><span class="title">info</span>-&gt;</span>mTimeScale</span><br><span class="line">                * <span class="number">1000000</span>ll</span><br><span class="line">                + <span class="function"><span class="title">info</span>-&gt;</span>mNormalPlaytimeUs;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">accessUnit</span>-&gt;</span><span class="function"><span class="title">meta</span>()-&gt;</span>setInt64(<span class="string">&quot;timeUs&quot;</span>, nptUs);</span><br><span class="line">        <span class="comment">//。。。。。。。。。。。。。。。</span></span><br><span class="line">        <span class="function"><span class="title">source</span>-&gt;</span>queueAccessUnit(accessUnit);</span><br><span class="line">    &#125;</span><br><span class="line">    break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>queueAccessUnit(accessUnit);将AU数据存放到AnotherPacketSource 的mBuffers中供解码器解码播放：</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line"><span class="literal">void</span> AnotherPacketSource::queueAccessUnit(<span class="keyword">const</span> sp&lt;ABuffer&gt; &amp;buffer) &#123;</span><br><span class="line">    int32_t damaged;</span><br><span class="line">    <span class="keyword">if</span> <span class="function"><span class="params">(buffer-&gt;meta()-&gt;findInt32(<span class="string">&quot;damaged&quot;</span>, &amp;damaged) &amp;&amp; damaged)</span> &#123;</span></span><br><span class="line"><span class="function">        // <span class="title">LOG</span><span class="params">(VERBOSE)</span> &lt;&lt; &quot;<span class="title">discarding</span> <span class="title">damaged</span> <span class="title">AU</span>&quot;;</span></span><br><span class="line"><span class="function">        <span class="title">return</span>;</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="title">Mutex</span>::<span class="title">Autolock</span> <span class="title">autoLock</span><span class="params">(mLock)</span>;</span></span><br><span class="line"><span class="function">    <span class="title">mBuffers</span>.<span class="title">push_back</span><span class="params">(buffer)</span>;</span></span><br><span class="line"><span class="function">    <span class="title">mCondition</span>.<span class="title">signal</span><span class="params">()</span>;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="title">int32_t</span> <span class="title">discontinuity</span>;</span></span><br><span class="line"><span class="function">    <span class="title">if</span> <span class="params">(buffer-&gt;meta()-&gt;findInt32(<span class="string">&quot;discontinuity&quot;</span>, &amp;discontinuity))</span>&#123;</span></span><br><span class="line"><span class="function">        <span class="title">ALOGV</span><span class="params">(<span class="string">&quot;queueing a discontinuity with queueAccessUnit&quot;</span>)</span>;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">        <span class="title">mLastQueuedTimeUs</span> = 0<span class="title">ll</span>;</span></span><br><span class="line"><span class="function">        <span class="title">mEOSResult</span> = <span class="title">OK</span>;</span></span><br><span class="line"><span class="function">        <span class="title">mLatestEnqueuedMeta</span> = <span class="title">NULL</span>;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">        <span class="title">mDiscontinuitySegments</span>.<span class="title">push_back</span><span class="params">(DiscontinuitySegment())</span>;</span></span><br><span class="line"><span class="function">        <span class="title">return</span>;</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="title">int64_t</span> <span class="title">lastQueuedTimeUs</span>;</span></span><br><span class="line"><span class="function">    <span class="title">CHECK</span><span class="params">(buffer-&gt;meta()-&gt;findInt64(<span class="string">&quot;timeUs&quot;</span>, &amp;lastQueuedTimeUs))</span>;</span></span><br><span class="line"><span class="function">    <span class="title">mLastQueuedTimeUs</span> = <span class="title">lastQueuedTimeUs</span>;</span></span><br><span class="line"><span class="function">    <span class="title">ALOGV</span><span class="params">(<span class="string">&quot;queueAccessUnit timeUs=%&quot;</span> PRIi64 <span class="string">&quot; us (%.2f secs)&quot;</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">            mLastQueuedTimeUs, mLastQueuedTimeUs / <span class="number">1E</span>6)</span>;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    // <span class="title">CHECK</span><span class="params">(!mDiscontinuitySegments.empty())</span>;</span></span><br><span class="line"><span class="function">    <span class="title">DiscontinuitySegment</span> &amp;<span class="title">tailSeg</span> = *<span class="params">(--mDiscontinuitySegments.end())</span>;</span></span><br><span class="line"><span class="function">    <span class="title">if</span> <span class="params">(lastQueuedTimeUs &gt; tailSeg.mMaxEnqueTimeUs)</span> &#123;</span></span><br><span class="line"><span class="function">        <span class="title">tailSeg</span>.<span class="title">mMaxEnqueTimeUs</span> = <span class="title">lastQueuedTimeUs</span>;</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function">    <span class="title">if</span> <span class="params">(tailSeg.mMaxDequeTimeUs == -<span class="number">1</span>)</span> &#123;</span></span><br><span class="line"><span class="function">        <span class="title">tailSeg</span>.<span class="title">mMaxDequeTimeUs</span> = <span class="title">lastQueuedTimeUs</span>;</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="title">if</span> <span class="params">(mLatestEnqueuedMeta == NULL)</span> &#123;</span></span><br><span class="line"><span class="function">        <span class="title">mLatestEnqueuedMeta</span> = <span class="title">buffer</span>-&gt;</span>meta<span class="function"><span class="params">()</span>-&gt;</span>dup();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        int64_t latestTimeUs = <span class="number">0</span>;</span><br><span class="line">        int64_t frameDeltaUs = <span class="number">0</span>;</span><br><span class="line">        CHECK(mLatestEnqueuedMeta-&gt;findInt64(<span class="string">&quot;timeUs&quot;</span>, &amp;latestTimeUs));</span><br><span class="line">        <span class="keyword">if</span> (lastQueuedTimeUs &gt; latestTimeUs) &#123;</span><br><span class="line">            mLatestEnqueuedMeta = buffer-&gt;meta<span class="function"><span class="params">()</span>-&gt;</span>dup();</span><br><span class="line">            frameDeltaUs = lastQueuedTimeUs - latestTimeUs;</span><br><span class="line">            mLatestEnqueuedMeta-&gt;setInt64(<span class="string">&quot;durationUs&quot;</span>, frameDeltaUs);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!mLatestEnqueuedMeta-&gt;findInt64(<span class="string">&quot;durationUs&quot;</span>, &amp;frameDeltaUs)) &#123;</span><br><span class="line">            <span class="regexp">// For B frames</span></span><br><span class="line"><span class="regexp">            frameDeltaUs = latestTimeUs - lastQueuedTimeUs;</span></span><br><span class="line"><span class="regexp">            mLatestEnqueuedMeta-&gt;setInt64(&quot;durationUs&quot;, frameDeltaUs);</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<p>开始播放流程，这部分和介绍HLS的时候是重复的，方便查看，所以粘贴了过来，大体的任务就是初始化解码器，然后开始从输入缓冲区往解码器中添加数据。</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line"><span class="literal">void</span> NuPlayer::start() &#123;</span><br><span class="line">    <span class="function"><span class="params">(<span class="keyword">new</span> AMessage(kWhatStart, this))</span>-&gt;</span>post();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> kWhatStart:</span><br><span class="line">&#123;</span><br><span class="line">    ALOGV(<span class="string">&quot;kWhatStart&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (mStarted) &#123;</span><br><span class="line">        <span class="comment">//...............</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        onStart();</span><br><span class="line">    &#125;</span><br><span class="line">    mPausedByClient = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void NuPlayer::on<span class="constructor">Start(<span class="params">int64_t</span> <span class="params">startPositionUs</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!mSourceStarted) &#123;</span><br><span class="line">        mSourceStarted = <span class="literal">true</span>;</span><br><span class="line">        mSource-&gt;start<span class="literal">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mOffloadAudio = <span class="literal">false</span>;</span><br><span class="line">    mAudioEOS = <span class="literal">false</span>;</span><br><span class="line">    mVideoEOS = <span class="literal">false</span>;</span><br><span class="line">    mStarted = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    uint32_t flags = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    sp&lt;MetaData&gt; audioMeta = mSource-&gt;get<span class="constructor">FormatMeta(<span class="params">true</span> <span class="operator">/</span><span class="operator">*</span> <span class="params">audio</span> <span class="operator">*</span><span class="operator">/</span>)</span>;</span><br><span class="line">    audio_stream_type_t streamType = AUDIO_STREAM_MUSIC;</span><br><span class="line">    <span class="keyword">if</span> (mAudioSink != NULL) &#123;</span><br><span class="line">        streamType = mAudioSink-&gt;get<span class="constructor">AudioStreamType()</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sp&lt;AMessage&gt; videoFormat = mSource-&gt;get<span class="constructor">Format(<span class="params">false</span> <span class="operator">/</span><span class="operator">*</span> <span class="params">audio</span> <span class="operator">*</span><span class="operator">/</span>)</span>;</span><br><span class="line"></span><br><span class="line">    sp&lt;AMessage&gt; notify = <span class="keyword">new</span> <span class="constructor">AMessage(<span class="params">kWhatRendererNotify</span>, <span class="params">this</span>)</span>;</span><br><span class="line">    ++mRendererGeneration;</span><br><span class="line">    notify-&gt;set<span class="constructor">Int32(<span class="string">&quot;generation&quot;</span>, <span class="params">mRendererGeneration</span>)</span>;</span><br><span class="line">    mRenderer = <span class="keyword">new</span> <span class="constructor">Renderer(<span class="params">mAudioSink</span>, <span class="params">notify</span>, <span class="params">flags</span>)</span>;</span><br><span class="line">    mRendererLooper = <span class="keyword">new</span> ALooper;</span><br><span class="line">    mRendererLooper-&gt;set<span class="constructor">Name(<span class="string">&quot;NuPlayerRenderer&quot;</span>)</span>;</span><br><span class="line">    mRendererLooper-&gt;start(<span class="literal">false</span>, <span class="literal">false</span>, ANDROID_PRIORITY_AUDIO);</span><br><span class="line">    mRendererLooper-&gt;register<span class="constructor">Handler(<span class="params">mRenderer</span>)</span>;</span><br><span class="line"></span><br><span class="line">    status_t err = mRenderer-&gt;set<span class="constructor">PlaybackSettings(<span class="params">mPlaybackSettings</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">float</span> rate = get<span class="constructor">FrameRate()</span>;</span><br><span class="line">    <span class="keyword">if</span> (rate &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        mRenderer-&gt;set<span class="constructor">VideoFrameRate(<span class="params">rate</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mVideoDecoder != NULL) &#123;</span><br><span class="line">        mVideoDecoder-&gt;set<span class="constructor">Renderer(<span class="params">mRenderer</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mAudioDecoder != NULL) &#123;</span><br><span class="line">        mAudioDecoder-&gt;set<span class="constructor">Renderer(<span class="params">mRenderer</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    post<span class="constructor">ScanSources()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>紧接着我们看下初始化编码器部分：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void NuPlayer::post<span class="constructor">ScanSources()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mScanSourcesPending) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    sp&lt;AMessage&gt; msg = <span class="keyword">new</span> <span class="constructor">AMessage(<span class="params">kWhatScanSources</span>, <span class="params">this</span>)</span>;</span><br><span class="line">    msg-&gt;set<span class="constructor">Int32(<span class="string">&quot;generation&quot;</span>, <span class="params">mScanSourcesGeneration</span>)</span>;</span><br><span class="line">    msg-&gt;post<span class="literal">()</span>;</span><br><span class="line">    mScanSourcesPending = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> kWhatScanSources:</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int32_t</span> generation;</span><br><span class="line"></span><br><span class="line">    mScanSourcesPending = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> mHadAnySourcesBefore =</span><br><span class="line">        (mAudioDecoder != <span class="literal">NULL</span>) || (mVideoDecoder != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// initialize video before audio because successful initialization of</span></span><br><span class="line">    <span class="comment">// video may change deep buffer mode of audio.</span></span><br><span class="line">    <span class="keyword">if</span> (mSurface != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">instantiateDecoder</span>(<span class="literal">false</span>, &amp;mVideoDecoder);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Don&#x27;t try to re-open audio sink if there&#x27;s an existing decoder.</span></span><br><span class="line">    <span class="keyword">if</span> (mAudioSink != <span class="literal">NULL</span> &amp;&amp; mAudioDecoder == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">instantiateDecoder</span>(<span class="literal">true</span>, &amp;mAudioDecoder);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">status_t NuPlayer::instantiate<span class="constructor">Decoder(<span class="params">bool</span> <span class="params">audio</span>, <span class="params">sp</span>&lt;DecoderBase&gt; <span class="operator">*</span><span class="params">decoder</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取格式</span></span><br><span class="line">    sp&lt;AMessage&gt; format = mSource-&gt;get<span class="constructor">Format(<span class="params">audio</span>)</span>;</span><br><span class="line">    format-&gt;set<span class="constructor">Int32(<span class="string">&quot;priority&quot;</span>, 0 <span class="operator">/</span><span class="operator">*</span> <span class="params">realtime</span> <span class="operator">*</span><span class="operator">/</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (audio) &#123;</span><br><span class="line">        sp&lt;AMessage&gt; notify = <span class="keyword">new</span> <span class="constructor">AMessage(<span class="params">kWhatAudioNotify</span>, <span class="params">this</span>)</span>;</span><br><span class="line">        ++mAudioDecoderGeneration;</span><br><span class="line">        notify-&gt;set<span class="constructor">Int32(<span class="string">&quot;generation&quot;</span>, <span class="params">mAudioDecoderGeneration</span>)</span>;</span><br><span class="line">        determine<span class="constructor">AudioModeChange()</span>;</span><br><span class="line">        <span class="keyword">if</span> (mOffloadAudio) &#123;</span><br><span class="line">          <span class="comment">//....................</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            *decoder = <span class="keyword">new</span> <span class="constructor">Decoder(<span class="params">notify</span>, <span class="params">mSource</span>, <span class="params">mPID</span>, <span class="params">mRenderer</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        sp&lt;AMessage&gt; notify = <span class="keyword">new</span> <span class="constructor">AMessage(<span class="params">kWhatVideoNotify</span>, <span class="params">this</span>)</span>;</span><br><span class="line">        ++mVideoDecoderGeneration;</span><br><span class="line">        notify-&gt;set<span class="constructor">Int32(<span class="string">&quot;generation&quot;</span>, <span class="params">mVideoDecoderGeneration</span>)</span>;</span><br><span class="line">        *decoder = <span class="keyword">new</span> <span class="constructor">Decoder(<span class="params">notify</span>, <span class="params">mSource</span>, <span class="params">mPID</span>, <span class="params">mRenderer</span>, <span class="params">mSurface</span>, <span class="params">mCCDecoder</span>)</span>;</span><br><span class="line">        <span class="comment">//...........................</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//解码器初始化</span></span><br><span class="line">    (*decoder)-&gt;init<span class="literal">()</span>;</span><br><span class="line">    <span class="comment">//配置解码器</span></span><br><span class="line">    (*decoder)-&gt;configure(format);</span><br><span class="line">    <span class="comment">//.........</span></span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里创建出解码器并初始化它。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void NuPlayer::DecoderBase::configure(const sp&lt;AMessage&gt; &amp;format) &#123;</span><br><span class="line">    sp&lt;AMessage&gt; msg = <span class="keyword">new</span> <span class="constructor">AMessage(<span class="params">kWhatConfigure</span>, <span class="params">this</span>)</span>;</span><br><span class="line">    msg-&gt;set<span class="constructor">Message(<span class="string">&quot;format&quot;</span>, <span class="params">format</span>)</span>;</span><br><span class="line">    msg-&gt;post<span class="literal">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void NuPlayer::DecoderBase::init<span class="literal">()</span> &#123;</span><br><span class="line">    mDecoderLooper-&gt;register<span class="constructor">Handler(<span class="params">this</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void NuPlayer::Decoder::on<span class="constructor">Configure(<span class="params">const</span> <span class="params">sp</span>&lt;AMessage&gt; &amp;<span class="params">format</span>)</span> &#123;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//创建MediaCodec</span></span><br><span class="line">    mCodec = MediaCodec::<span class="constructor">CreateByType(<span class="params">mCodecLooper</span>, <span class="params">mime</span>.<span class="params">c_str</span>()</span>, <span class="literal">false</span> <span class="comment">/* encoder */</span>, NULL <span class="comment">/* err */</span>, mPid);</span><br><span class="line">    <span class="comment">//配置MediaCodec</span></span><br><span class="line">    err = mCodec-&gt;configure(format, mSurface, NULL <span class="comment">/* crypto */</span>, <span class="number">0</span> <span class="comment">/* flags */</span>);</span><br><span class="line">    <span class="comment">//如果是视频文件则设置宽高</span></span><br><span class="line">    <span class="keyword">if</span> (!mIsAudio) &#123;</span><br><span class="line">        int32_t width, height;</span><br><span class="line">        <span class="keyword">if</span> (mOutputFormat-&gt;find<span class="constructor">Int32(<span class="string">&quot;width&quot;</span>, &amp;<span class="params">width</span>)</span>&amp;&amp; mOutputFormat-&gt;find<span class="constructor">Int32(<span class="string">&quot;height&quot;</span>, &amp;<span class="params">height</span>)</span>) &#123;</span><br><span class="line">            mStats-&gt;set<span class="constructor">Int32(<span class="string">&quot;width&quot;</span>, <span class="params">width</span>)</span>;</span><br><span class="line">            mStats-&gt;set<span class="constructor">Int32(<span class="string">&quot;height&quot;</span>, <span class="params">height</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//启动MediaCodec</span></span><br><span class="line">    err = mCodec-&gt;start<span class="literal">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">sp&lt;MediaCodec&gt; MediaCodec::<span class="constructor">CreateByType(<span class="params">const</span> <span class="params">sp</span>&lt;ALooper&gt; &amp;<span class="params">looper</span>, <span class="params">const</span> <span class="params">char</span> <span class="operator">*</span><span class="params">mime</span>, <span class="params">bool</span> <span class="params">encoder</span>, <span class="params">status_t</span> <span class="operator">*</span><span class="params">err</span>, <span class="params">pid_t</span> <span class="params">pid</span>)</span> &#123;</span><br><span class="line">    sp&lt;MediaCodec&gt; codec = <span class="keyword">new</span> <span class="constructor">MediaCodec(<span class="params">looper</span>, <span class="params">pid</span>)</span>;</span><br><span class="line">    const status_t ret = codec-&gt;init(mime, <span class="literal">true</span> <span class="comment">/* nameIsType */</span>, encoder);</span><br><span class="line">    return ret<span class="operator"> == </span>OK ? codec : NULL; <span class="comment">// NULL deallocates codec.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里说明mCodec是一个ACodec对象</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">status_t MediaCodec::init(const AString &amp;name, <span class="built_in">bool</span> nameIsType, <span class="built_in">bool</span> encoder) &#123;</span><br><span class="line">    mResourceManagerService-&gt;init<span class="literal">()</span>;</span><br><span class="line">    <span class="keyword">if</span> (nameIsType<span class="operator"> || </span>!strncasecmp(name.c<span class="constructor">_str()</span>, <span class="string">&quot;omx.&quot;</span>, <span class="number">4</span>)) &#123;</span><br><span class="line">        <span class="comment">//根据名称创建Codec</span></span><br><span class="line">        mCodec = <span class="keyword">new</span> ACodec;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!nameIsType&amp;&amp; !strncasecmp(name.c<span class="constructor">_str()</span>, <span class="string">&quot;android.filter.&quot;</span>, <span class="number">15</span>)) &#123;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    sp&lt;AMessage&gt; msg = <span class="keyword">new</span> <span class="constructor">AMessage(<span class="params">kWhatInit</span>, <span class="params">this</span>)</span>;</span><br><span class="line">    msg-&gt;set<span class="constructor">String(<span class="string">&quot;name&quot;</span>, <span class="params">name</span>)</span>;</span><br><span class="line">    msg-&gt;set<span class="constructor">Int32(<span class="string">&quot;nameIsType&quot;</span>, <span class="params">nameIsType</span>)</span>;</span><br><span class="line">    <span class="keyword">if</span> (nameIsType) &#123;</span><br><span class="line">        msg-&gt;set<span class="constructor">Int32(<span class="string">&quot;encoder&quot;</span>, <span class="params">encoder</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    return err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight mel"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> kWhatInit:</span><br><span class="line">&#123;</span><br><span class="line">   	<span class="comment">//....................</span></span><br><span class="line">    mCodec-&gt;initiateAllocateComponent(<span class="keyword">format</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void ACodec::initiate<span class="constructor">AllocateComponent(<span class="params">const</span> <span class="params">sp</span>&lt;AMessage&gt; &amp;<span class="params">msg</span>)</span> &#123;</span><br><span class="line">    msg-&gt;set<span class="constructor">What(<span class="params">kWhatAllocateComponent</span>)</span>;</span><br><span class="line">    msg-&gt;set<span class="constructor">Target(<span class="params">this</span>)</span>;</span><br><span class="line">    msg-&gt;post<span class="literal">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> ACodec::kWhatAllocateComponent:</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">onAllocateComponent</span>(msg);</span><br><span class="line">    handled = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里开始实例化编码器并设置状态</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">bool ACodec::UninitializedState::onAllocateComponent(const sp&lt;AMessage&gt; &amp;msg) &#123;</span><br><span class="line">    </span><br><span class="line">    Vector&lt;OMXCodec::CodecNameAndQuirks&gt; matchingCodecs;</span><br><span class="line">    AString mime;</span><br><span class="line">    AString componentName;</span><br><span class="line">    uint32_t quirks = <span class="number">0</span>;</span><br><span class="line">    int32_t encoder = <span class="literal">false</span>;</span><br><span class="line">    <span class="function"><span class="title">if</span> (msg-&gt;</span>findString(<span class="string">&quot;componentName&quot;</span>, &amp;componentName)) &#123;</span><br><span class="line">        ssize_t index = matchingCodecs.add();</span><br><span class="line">        OMXCodec::CodecNameAndQuirks *entry = &amp;matchingCodecs.editItemAt(index);</span><br><span class="line">        <span class="function"><span class="title">entry</span>-&gt;</span>mName = String8(componentName.c_str());</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">if</span> (!OMXCodec::findCodecQuirks(componentName.c_str(), &amp;entry-&gt;</span>mQuirks)) &#123;</span><br><span class="line">            <span class="function"><span class="title">entry</span>-&gt;</span>mQuirks = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        CHECK(<span class="function"><span class="title">msg</span>-&gt;</span>findString(<span class="string">&quot;mime&quot;</span>, &amp;mime));</span><br><span class="line">        <span class="function"><span class="title">if</span> (!msg-&gt;</span>findInt32(<span class="string">&quot;encoder&quot;</span>, &amp;encoder)) &#123;</span><br><span class="line">            encoder = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        OMXCodec::findMatchingCodecs(</span><br><span class="line">                mime.c_str(),</span><br><span class="line">                encoder, <span class="comment">// createEncoder</span></span><br><span class="line">                NULL,  <span class="comment">// matchComponentName</span></span><br><span class="line">                <span class="number">0</span>,     <span class="comment">// flags</span></span><br><span class="line">                &amp;matchingCodecs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sp&lt;CodecObserver&gt; observer = new CodecObserver;</span><br><span class="line">    IOMX::node_id node = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    status_t err = NAME_NOT_FOUND;</span><br><span class="line">    <span class="keyword">for</span> (size_t matchIndex = <span class="number">0</span>; matchIndex &lt; matchingCodecs.size();++matchIndex) &#123;</span><br><span class="line">        componentName = matchingCodecs.itemAt(matchIndex).mName.string();</span><br><span class="line">        quirks = matchingCodecs.itemAt(matchIndex).mQuirks;</span><br><span class="line"></span><br><span class="line">        pid_t tid = gettid();</span><br><span class="line">        int prevPriority = androidGetThreadPriority(tid);</span><br><span class="line">        androidSetThreadPriority(tid, ANDROID_PRIORITY_FOREGROUND);</span><br><span class="line">        <span class="function"><span class="title">err</span> = omx-&gt;</span>allocateNode(componentName.c_str(), observer, &amp;node);</span><br><span class="line">        androidSetThreadPriority(tid, prevPriority);</span><br><span class="line">        node = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    notify = new AMessage(kWhatOMXMessageList, mCodec);</span><br><span class="line">    <span class="function"><span class="title">observer</span>-&gt;</span>setNotificationMessage(notify);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">mCodec</span>-&gt;</span>mComponentName = componentName;</span><br><span class="line">    <span class="function"><span class="title">mCodec</span>-&gt;</span>mRenderTracker.setComponentName(componentName);</span><br><span class="line">    <span class="function"><span class="title">mCodec</span>-&gt;</span>mFlags = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="title">mCodec</span>-&gt;</span>mQuirks = quirks;</span><br><span class="line">    <span class="function"><span class="title">mCodec</span>-&gt;</span>mOMX = omx;</span><br><span class="line">    <span class="function"><span class="title">mCodec</span>-&gt;</span>mNode = node;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="title">sp</span>&lt;AMessage&gt; notify = mCodec-&gt;</span><span class="function"><span class="title">mNotify</span>-&gt;</span>dup();</span><br><span class="line">        <span class="function"><span class="title">notify</span>-&gt;</span>setInt32(<span class="string">&quot;what&quot;</span>, CodecBase::kWhatComponentAllocated);</span><br><span class="line">        <span class="function"><span class="title">notify</span>-&gt;</span><span class="function"><span class="title">setString</span>(&quot;componentName&quot;, mCodec-&gt;</span>mComponentName.c_str());</span><br><span class="line">        <span class="function"><span class="title">notify</span>-&gt;</span>post();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">mCodec</span>-&gt;</span><span class="function"><span class="title">changeState</span>(mCodec-&gt;</span>mLoadedState);</span><br><span class="line">    return <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解码器的配置</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">status_t MediaCodec::configure(</span><br><span class="line">        const sp&lt;AMessage&gt; &amp;format,</span><br><span class="line">        const sp&lt;Surface&gt; &amp;surface,</span><br><span class="line">        const sp&lt;ICrypto&gt; &amp;crypto,</span><br><span class="line">        uint32_t flags) &#123;</span><br><span class="line">    sp&lt;AMessage&gt; msg = <span class="keyword">new</span> <span class="constructor">AMessage(<span class="params">kWhatConfigure</span>, <span class="params">this</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mIsVideo) &#123;</span><br><span class="line">        format-&gt;find<span class="constructor">Int32(<span class="string">&quot;width&quot;</span>, &amp;<span class="params">mVideoWidth</span>)</span>;</span><br><span class="line">        format-&gt;find<span class="constructor">Int32(<span class="string">&quot;height&quot;</span>, &amp;<span class="params">mVideoHeight</span>)</span>;</span><br><span class="line">        <span class="keyword">if</span> (!format-&gt;find<span class="constructor">Int32(<span class="string">&quot;rotation-degrees&quot;</span>, &amp;<span class="params">mRotationDegrees</span>)</span>) &#123;</span><br><span class="line">            mRotationDegrees = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    msg-&gt;set<span class="constructor">Message(<span class="string">&quot;format&quot;</span>, <span class="params">format</span>)</span>;</span><br><span class="line">    msg-&gt;set<span class="constructor">Int32(<span class="string">&quot;flags&quot;</span>, <span class="params">flags</span>)</span>;</span><br><span class="line">    msg-&gt;set<span class="constructor">Object(<span class="string">&quot;surface&quot;</span>, <span class="params">surface</span>)</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//.....................</span></span><br><span class="line">    <span class="comment">// save msg for reset</span></span><br><span class="line">    mConfigureMsg = msg;</span><br><span class="line">	<span class="comment">//.....................</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt;= kMaxRetry; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// Don&#x27;t try to reclaim resource for the first time.</span></span><br><span class="line">            <span class="keyword">if</span> (!mResourceManagerService-&gt;reclaim<span class="constructor">Resource(<span class="params">resources</span>)</span>) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sp&lt;AMessage&gt; response;</span><br><span class="line">        err = <span class="constructor">PostAndAwaitResponse(<span class="params">msg</span>, &amp;<span class="params">response</span>)</span>;</span><br><span class="line">        <span class="comment">//.....................</span></span><br><span class="line">    &#125;</span><br><span class="line">    return err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">case kWhatConfigure:</span><br><span class="line">&#123;</span><br><span class="line">    sp&lt;AReplyToken&gt; replyID;</span><br><span class="line">    <span class="constructor">CHECK(<span class="params">msg</span>-&gt;<span class="params">senderAwaitsResponse</span>(&amp;<span class="params">replyID</span>)</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    sp&lt;RefBase&gt; obj;</span><br><span class="line">    <span class="constructor">CHECK(<span class="params">msg</span>-&gt;<span class="params">findObject</span>(<span class="string">&quot;surface&quot;</span>, &amp;<span class="params">obj</span>)</span>);</span><br><span class="line"></span><br><span class="line">    sp&lt;AMessage&gt; format;</span><br><span class="line">    <span class="constructor">CHECK(<span class="params">msg</span>-&gt;<span class="params">findMessage</span>(<span class="string">&quot;format&quot;</span>, &amp;<span class="params">format</span>)</span>);</span><br><span class="line"></span><br><span class="line">    int32_t push;</span><br><span class="line">    <span class="keyword">if</span> (msg-&gt;find<span class="constructor">Int32(<span class="string">&quot;push-blank-buffers-on-shutdown&quot;</span>, &amp;<span class="params">push</span>)</span><span class="operator"> &amp;&amp; </span>push != <span class="number">0</span>) &#123;</span><br><span class="line">        mFlags <span class="pattern-match">|= k<span class="constructor">FlagPushBlankBuffersOnShutdown</span>;</span></span><br><span class="line"><span class="pattern-match">    &#125;</span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match">    <span class="keyword">if</span> (obj != <span class="constructor">NULL</span>) &#123;</span></span><br><span class="line"><span class="pattern-match">        format-&gt;set<span class="constructor">Object(<span class="string">&quot;native-window&quot;</span>, <span class="params">obj</span>)</span>;</span></span><br><span class="line"><span class="pattern-match">        status<span class="constructor">_t</span> err = handle<span class="constructor">SetSurface(<span class="params">static_cast</span>&lt;Surface <span class="operator">*</span>&gt;(<span class="params">obj</span>.<span class="params">get</span>()</span>));</span></span><br><span class="line"><span class="pattern-match">        <span class="keyword">if</span> (err != <span class="constructor">OK</span>) &#123;</span></span><br><span class="line"><span class="pattern-match">            <span class="constructor">PostReplyWithError(<span class="params">replyID</span>, <span class="params">err</span>)</span>;</span></span><br><span class="line"><span class="pattern-match">            break;</span></span><br><span class="line"><span class="pattern-match">        &#125;</span></span><br><span class="line"><span class="pattern-match">    &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="pattern-match">        handle<span class="constructor">SetSurface(NULL)</span>;</span></span><br><span class="line"><span class="pattern-match">    &#125;</span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match">    m<span class="constructor">ReplyID</span> = reply<span class="constructor">ID</span>;</span></span><br><span class="line"><span class="pattern-match">    set<span class="constructor">State(CONFIGURING)</span>;</span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match">    void <span class="operator">*</span>crypto;</span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match">    uint32<span class="constructor">_t</span> flags;</span></span><br><span class="line"><span class="pattern-match">    <span class="constructor">CHECK(<span class="params">msg</span>-&gt;<span class="params">findInt32</span>(<span class="string">&quot;flags&quot;</span>, (<span class="params">int32_t</span> <span class="operator">*</span>)</span>&amp;flags));</span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match">    <span class="keyword">if</span> (flags &amp; <span class="constructor">CONFIGURE_FLAG_ENCODE</span>) &#123;</span></span><br><span class="line"><span class="pattern-match">        format-&gt;set<span class="constructor">Int32(<span class="string">&quot;encoder&quot;</span>, <span class="params">true</span>)</span>;</span></span><br><span class="line"><span class="pattern-match">        m<span class="constructor">Flags</span> |= k<span class="constructor">FlagIsEncoder</span>;</span></span><br><span class="line"><span class="pattern-match">    &#125;</span></span><br><span class="line"><span class="pattern-match">	<span class="operator">/</span><span class="operator">/</span>这里最重要</span></span><br><span class="line"><span class="pattern-match">    m<span class="constructor">Codec</span>-&gt;initiate<span class="constructor">ConfigureComponent(<span class="params">format</span>)</span>;</span></span><br><span class="line"><span class="pattern-match">    break;</span></span><br><span class="line"><span class="pattern-match">&#125;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void ACodec::initiate<span class="constructor">ConfigureComponent(<span class="params">const</span> <span class="params">sp</span>&lt;AMessage&gt; &amp;<span class="params">msg</span>)</span> &#123;</span><br><span class="line">    msg-&gt;set<span class="constructor">What(<span class="params">kWhatConfigureComponent</span>)</span>;</span><br><span class="line">    msg-&gt;set<span class="constructor">Target(<span class="params">this</span>)</span>;</span><br><span class="line">    msg-&gt;post<span class="literal">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> ACodec::kWhatConfigureComponent:</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">onConfigureComponent</span>(msg);</span><br><span class="line">    handled = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">bool ACodec::LoadedState::onConfigureComponent(</span><br><span class="line">        const sp&lt;AMessage&gt; &amp;msg) &#123;</span><br><span class="line">    ALOGV(<span class="string">&quot;onConfigureComponent&quot;</span>);</span><br><span class="line"></span><br><span class="line">    CHECK(<span class="function"><span class="title">mCodec</span>-&gt;</span>mNode != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    status_t err = OK;</span><br><span class="line">    AString mime;</span><br><span class="line">    <span class="function"><span class="title">if</span> (!msg-&gt;</span>findString(<span class="string">&quot;mime&quot;</span>, &amp;mime)) &#123;</span><br><span class="line">        err = BAD_VALUE;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="function"><span class="title">err</span> = mCodec-&gt;</span>configureCodec(mime.c_str(), msg);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="title">sp</span>&lt;AMessage&gt; notify = mCodec-&gt;</span><span class="function"><span class="title">mNotify</span>-&gt;</span>dup();</span><br><span class="line">        <span class="function"><span class="title">notify</span>-&gt;</span>setInt32(<span class="string">&quot;what&quot;</span>, CodecBase::kWhatComponentConfigured);</span><br><span class="line">        <span class="function"><span class="title">notify</span>-&gt;</span><span class="function"><span class="title">setMessage</span>(&quot;input-format&quot;, mCodec-&gt;</span>mInputFormat);</span><br><span class="line">        <span class="function"><span class="title">notify</span>-&gt;</span><span class="function"><span class="title">setMessage</span>(&quot;output-format&quot;, mCodec-&gt;</span>mOutputFormat);</span><br><span class="line">        <span class="function"><span class="title">notify</span>-&gt;</span>post();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">case CodecBase::kWhatComponentConfigured:</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (mState<span class="operator"> == </span>UNINITIALIZED<span class="operator"> || </span>mState<span class="operator"> == </span>INITIALIZED) &#123;</span><br><span class="line">        <span class="comment">// In case a kWhatError message came in and replied with error,</span></span><br><span class="line">        <span class="comment">// we log a warning and ignore.</span></span><br><span class="line">        <span class="constructor">ALOGW(<span class="string">&quot;configure interrupted by error, current state %d&quot;</span>, <span class="params">mState</span>)</span>;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="constructor">CHECK_EQ(<span class="params">mState</span>, CONFIGURING)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// reset input surface flag</span></span><br><span class="line">    mHaveInputSurface = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="constructor">CHECK(<span class="params">msg</span>-&gt;<span class="params">findMessage</span>(<span class="string">&quot;input-format&quot;</span>, &amp;<span class="params">mInputFormat</span>)</span>);</span><br><span class="line">    <span class="constructor">CHECK(<span class="params">msg</span>-&gt;<span class="params">findMessage</span>(<span class="string">&quot;output-format&quot;</span>, &amp;<span class="params">mOutputFormat</span>)</span>);</span><br><span class="line"></span><br><span class="line">    int32_t usingSwRenderer;</span><br><span class="line">    <span class="keyword">if</span> (mOutputFormat-&gt;find<span class="constructor">Int32(<span class="string">&quot;using-sw-renderer&quot;</span>, &amp;<span class="params">usingSwRenderer</span>)</span><span class="operator"></span></span><br><span class="line"><span class="operator">            &amp;&amp; </span>usingSwRenderer) &#123;</span><br><span class="line">        mFlags <span class="pattern-match">|= k<span class="constructor">FlagUsesSoftwareRenderer</span>;</span></span><br><span class="line"><span class="pattern-match">    &#125;</span></span><br><span class="line"><span class="pattern-match">    set<span class="constructor">State(CONFIGURED)</span>;</span></span><br><span class="line"><span class="pattern-match">    (<span class="keyword">new</span> <span class="constructor">AMessage</span>)-&gt;post<span class="constructor">Reply(<span class="params">mReplyID</span>)</span>;</span></span><br><span class="line"><span class="pattern-match">    break;</span></span><br><span class="line"><span class="pattern-match">&#125;</span></span><br></pre></td></tr></table></figure>
<p>这里才是解码器最详细的配置，有时间好好针对这个展开研究，这篇博客先针对整个流程进行分析：</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">status_t ACodec::configureCodec(</span><br><span class="line">        const char *mime, const sp&lt;AMessage&gt; &amp;msg) &#123;</span><br><span class="line">    int32_t encoder;</span><br><span class="line">    <span class="function"><span class="title">if</span> (!msg-&gt;</span>findInt32(<span class="string">&quot;encoder&quot;</span>, &amp;encoder)) &#123;</span><br><span class="line">        encoder = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sp&lt;AMessage&gt; inputFormat = new AMessage();</span><br><span class="line">    <span class="function"><span class="title">sp</span>&lt;AMessage&gt; outputFormat = mNotify-&gt;</span>dup(); <span class="comment">// will use this for kWhatOutputFormatChanged</span></span><br><span class="line"></span><br><span class="line">    mIsEncoder = encoder;</span><br><span class="line"></span><br><span class="line">    mInputMetadataType = kMetadataBufferTypeInvalid;</span><br><span class="line">    mOutputMetadataType = kMetadataBufferTypeInvalid;</span><br><span class="line"></span><br><span class="line">    status_t err = setComponentRole(encoder <span class="comment">/* isEncoder */</span>, mime);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err != OK) &#123;</span><br><span class="line">        return err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int32_t bitRate = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// FLAC encoder doesn&#x27;t need a bitrate, other encoders do</span></span><br><span class="line">    <span class="keyword">if</span> (encoder &amp;&amp; strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_FLAC)</span><br><span class="line">            &amp;&amp; !<span class="function"><span class="title">msg</span>-&gt;</span>findInt32(<span class="string">&quot;bitrate&quot;</span>, &amp;bitRate)) &#123;</span><br><span class="line">        return INVALID_OPERATION;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int32_t storeMeta;</span><br><span class="line">    <span class="keyword">if</span> (encoder</span><br><span class="line">            &amp;&amp; <span class="function"><span class="title">msg</span>-&gt;</span>findInt32(<span class="string">&quot;store-metadata-in-buffers&quot;</span>, &amp;storeMeta)</span><br><span class="line">            &amp;&amp; storeMeta != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="function"><span class="title">err</span> = mOMX-&gt;</span>storeMetaDataInBuffers(mNode, kPortIndexInput, OMX_TRUE, &amp;mInputMetadataType);</span><br><span class="line">        <span class="keyword">if</span> (err != OK) &#123;</span><br><span class="line">            ALOGE(<span class="string">&quot;[%s] storeMetaDataInBuffers (input) failed w/ err %d&quot;</span>,</span><br><span class="line">                    mComponentName.c_str(), err);</span><br><span class="line"></span><br><span class="line">            return err;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// For this specific case we could be using camera source even if storeMetaDataInBuffers</span></span><br><span class="line">        <span class="comment">// returns Gralloc source. Pretend that we are; this will force us to use nBufferSize.</span></span><br><span class="line">        <span class="keyword">if</span> (mInputMetadataType == kMetadataBufferTypeGrallocSource) &#123;</span><br><span class="line">            mInputMetadataType = kMetadataBufferTypeCameraSource;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        uint32_t usageBits;</span><br><span class="line">        <span class="function"><span class="title">if</span> (mOMX-&gt;</span>getParameter(</span><br><span class="line">                mNode, (OMX_INDEXTYPE)OMX_IndexParamConsumerUsageBits,</span><br><span class="line">                &amp;usageBits, sizeof(usageBits)) == OK) &#123;</span><br><span class="line">            <span class="function"><span class="title">inputFormat</span>-&gt;</span>setInt32(</span><br><span class="line">                    <span class="string">&quot;using-sw-read-often&quot;</span>, !!(usageBits &amp; GRALLOC_USAGE_SW_READ_OFTEN));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int32_t prependSPSPPS = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (encoder</span><br><span class="line">            &amp;&amp; <span class="function"><span class="title">msg</span>-&gt;</span>findInt32(<span class="string">&quot;prepend-sps-pps-to-idr-frames&quot;</span>, &amp;prependSPSPPS)</span><br><span class="line">            &amp;&amp; prependSPSPPS != <span class="number">0</span>) &#123;</span><br><span class="line">        OMX_INDEXTYPE index;</span><br><span class="line">        <span class="function"><span class="title">err</span> = mOMX-&gt;</span>getExtensionIndex(</span><br><span class="line">                mNode,</span><br><span class="line">                <span class="string">&quot;OMX.google.android.index.prependSPSPPSToIDRFrames&quot;</span>,</span><br><span class="line">                &amp;index);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (err == OK) &#123;</span><br><span class="line">            PrependSPSPPSToIDRFramesParams params;</span><br><span class="line">            InitOMXParams(&amp;params);</span><br><span class="line">            params.bEnable = OMX_TRUE;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="title">err</span> = mOMX-&gt;</span>setParameter(</span><br><span class="line">                    mNode, index, &amp;params, sizeof(params));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (err != OK) &#123;</span><br><span class="line">            ALOGE(<span class="string">&quot;Encoder could not be configured to emit SPS/PPS before &quot;</span></span><br><span class="line">                  <span class="string">&quot;IDR frames. (err %d)&quot;</span>, err);</span><br><span class="line"></span><br><span class="line">            return err;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Only enable metadata mode on encoder output if encoder can prepend</span></span><br><span class="line">    <span class="comment">// sps/pps to idr frames, since in metadata mode the bitstream is in an</span></span><br><span class="line">    <span class="comment">// opaque handle, to which we don&#x27;t have access.</span></span><br><span class="line">    int32_t video = !strncasecmp(mime, <span class="string">&quot;video/&quot;</span>, <span class="number">6</span>);</span><br><span class="line">    mIsVideo = video;</span><br><span class="line">    <span class="keyword">if</span> (encoder &amp;&amp; video) &#123;</span><br><span class="line">        OMX_BOOL enable = (OMX_BOOL) (prependSPSPPS</span><br><span class="line">            &amp;&amp; <span class="function"><span class="title">msg</span>-&gt;</span>findInt32(<span class="string">&quot;store-metadata-in-buffers-output&quot;</span>, &amp;storeMeta)</span><br><span class="line">            &amp;&amp; storeMeta != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">err</span> = mOMX-&gt;</span>storeMetaDataInBuffers(mNode, kPortIndexOutput, enable, &amp;mOutputMetadataType);</span><br><span class="line">        <span class="keyword">if</span> (err != OK) &#123;</span><br><span class="line">            ALOGE(<span class="string">&quot;[%s] storeMetaDataInBuffers (output) failed w/ err %d&quot;</span>,</span><br><span class="line">                mComponentName.c_str(), err);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">if</span> (!msg-&gt;</span>findInt64(</span><br><span class="line">                    <span class="string">&quot;repeat-previous-frame-after&quot;</span>,</span><br><span class="line">                    &amp;mRepeatFrameDelayUs)) &#123;</span><br><span class="line">            mRepeatFrameDelayUs = -<span class="number">1</span>ll;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">if</span> (!msg-&gt;</span>findInt64(<span class="string">&quot;max-pts-gap-to-encoder&quot;</span>, &amp;mMaxPtsGapUs)) &#123;</span><br><span class="line">            mMaxPtsGapUs = -<span class="number">1</span>ll;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">if</span> (!msg-&gt;</span>findFloat(<span class="string">&quot;max-fps-to-encoder&quot;</span>, &amp;mMaxFps)) &#123;</span><br><span class="line">            mMaxFps = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">if</span> (!msg-&gt;</span>findInt64(<span class="string">&quot;time-lapse&quot;</span>, &amp;mTimePerCaptureUs)) &#123;</span><br><span class="line">            mTimePerCaptureUs = -<span class="number">1</span>ll;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">if</span> (!msg-&gt;</span>findInt32(</span><br><span class="line">                    <span class="string">&quot;create-input-buffers-suspended&quot;</span>,</span><br><span class="line">                    (int32_t*)&amp;mCreateInputBuffersSuspended)) &#123;</span><br><span class="line">            mCreateInputBuffersSuspended = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> we only use native window for video decoders</span></span><br><span class="line">    sp&lt;RefBase&gt; obj;</span><br><span class="line">    <span class="function"><span class="title">bool</span> haveNativeWindow = msg-&gt;</span>findObject(<span class="string">&quot;native-window&quot;</span>, &amp;obj)</span><br><span class="line">            &amp;&amp; obj != NULL &amp;&amp; video &amp;&amp; !encoder;</span><br><span class="line">    mLegacyAdaptiveExperiment = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (video &amp;&amp; !encoder) &#123;</span><br><span class="line">        <span class="function"><span class="title">inputFormat</span>-&gt;</span>setInt32(<span class="string">&quot;adaptive-playback&quot;</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        int32_t usageProtected;</span><br><span class="line">        <span class="function"><span class="title">if</span> (msg-&gt;</span>findInt32(<span class="string">&quot;protected&quot;</span>, &amp;usageProtected) &amp;&amp; usageProtected) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!haveNativeWindow) &#123;</span><br><span class="line">                ALOGE(<span class="string">&quot;protected output buffers must be sent to an ANativeWindow&quot;</span>);</span><br><span class="line">                return PERMISSION_DENIED;</span><br><span class="line">            &#125;</span><br><span class="line">            mFlags |= kFlagIsGrallocUsageProtected;</span><br><span class="line">            mFlags |= kFlagPushBlankBuffersToNativeWindowOnShutdown;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (haveNativeWindow) &#123;</span><br><span class="line">        sp&lt;ANativeWindow&gt; nativeWindow =</span><br><span class="line">            static_cast&lt;ANativeWindow *&gt;(static_cast&lt;Surface *&gt;(obj.get()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// START of temporary support for automatic FRC - THIS WILL BE REMOVED</span></span><br><span class="line">        int32_t autoFrc;</span><br><span class="line">        <span class="function"><span class="title">if</span> (msg-&gt;</span>findInt32(<span class="string">&quot;auto-frc&quot;</span>, &amp;autoFrc)) &#123;</span><br><span class="line">            bool enabled = autoFrc;</span><br><span class="line">            OMX_CONFIG_BOOLEANTYPE config;</span><br><span class="line">            InitOMXParams(&amp;config);</span><br><span class="line">            config.bEnabled = (OMX_BOOL)enabled;</span><br><span class="line">            <span class="function"><span class="title">status_t</span> temp = mOMX-&gt;</span>setConfig(</span><br><span class="line">                    mNode, (OMX_INDEXTYPE)OMX_IndexConfigAutoFramerateConversion,</span><br><span class="line">                    &amp;config, sizeof(config));</span><br><span class="line">            <span class="keyword">if</span> (temp == OK) &#123;</span><br><span class="line">                <span class="function"><span class="title">outputFormat</span>-&gt;</span>setInt32(<span class="string">&quot;auto-frc&quot;</span>, enabled);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (enabled) &#123;</span><br><span class="line">                ALOGI(<span class="string">&quot;codec does not support requested auto-frc (err %d)&quot;</span>, temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// END of temporary support for automatic FRC</span></span><br><span class="line"></span><br><span class="line">        int32_t tunneled;</span><br><span class="line">        <span class="function"><span class="title">if</span> (msg-&gt;</span>findInt32(<span class="string">&quot;feature-tunneled-playback&quot;</span>, &amp;tunneled) &amp;&amp;</span><br><span class="line">            tunneled != <span class="number">0</span>) &#123;</span><br><span class="line">            ALOGI(<span class="string">&quot;Configuring TUNNELED video playback.&quot;</span>);</span><br><span class="line">            mTunneled = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            int32_t audioHwSync = <span class="number">0</span>;</span><br><span class="line">            <span class="function"><span class="title">if</span> (!msg-&gt;</span>findInt32(<span class="string">&quot;audio-hw-sync&quot;</span>, &amp;audioHwSync)) &#123;</span><br><span class="line">                ALOGW(<span class="string">&quot;No Audio HW Sync provided for video tunnel&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            err = configureTunneledVideoPlayback(audioHwSync, nativeWindow);</span><br><span class="line">            <span class="keyword">if</span> (err != OK) &#123;</span><br><span class="line">                ALOGE(<span class="string">&quot;configureTunneledVideoPlayback(%d,%p) failed!&quot;</span>,</span><br><span class="line">                        audioHwSync, nativeWindow.get());</span><br><span class="line">                return err;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            int32_t maxWidth = <span class="number">0</span>, maxHeight = <span class="number">0</span>;</span><br><span class="line">            <span class="function"><span class="title">if</span> (msg-&gt;</span>findInt32(<span class="string">&quot;max-width&quot;</span>, &amp;maxWidth) &amp;&amp;</span><br><span class="line">                    <span class="function"><span class="title">msg</span>-&gt;</span>findInt32(<span class="string">&quot;max-height&quot;</span>, &amp;maxHeight)) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="function"><span class="title">err</span> = mOMX-&gt;</span>prepareForAdaptivePlayback(</span><br><span class="line">                        mNode, kPortIndexOutput, OMX_TRUE, maxWidth, maxHeight);</span><br><span class="line">                <span class="keyword">if</span> (err != OK) &#123;</span><br><span class="line">                    ALOGW(<span class="string">&quot;[%s] prepareForAdaptivePlayback failed w/ err %d&quot;</span>,</span><br><span class="line">                            mComponentName.c_str(), err);</span><br><span class="line">                    <span class="comment">// allow failure</span></span><br><span class="line">                    err = OK;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="function"><span class="title">inputFormat</span>-&gt;</span>setInt32(<span class="string">&quot;max-width&quot;</span>, maxWidth);</span><br><span class="line">                    <span class="function"><span class="title">inputFormat</span>-&gt;</span>setInt32(<span class="string">&quot;max-height&quot;</span>, maxHeight);</span><br><span class="line">                    <span class="function"><span class="title">inputFormat</span>-&gt;</span>setInt32(<span class="string">&quot;adaptive-playback&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ALOGV(<span class="string">&quot;Configuring CPU controlled video playback.&quot;</span>);</span><br><span class="line">            mTunneled = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Explicity reset the sideband handle of the window for</span></span><br><span class="line">            <span class="comment">// non-tunneled video in case the window was previously used</span></span><br><span class="line">            <span class="comment">// for a tunneled video playback.</span></span><br><span class="line">            err = native_window_set_sideband_stream(nativeWindow.get(), NULL);</span><br><span class="line">            <span class="keyword">if</span> (err != OK) &#123;</span><br><span class="line">                ALOGE(<span class="string">&quot;set_sideband_stream(NULL) failed! (err %d).&quot;</span>, err);</span><br><span class="line">                return err;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Always try to enable dynamic output buffers on native surface</span></span><br><span class="line">            <span class="function"><span class="title">err</span> = mOMX-&gt;</span>storeMetaDataInBuffers(</span><br><span class="line">                    mNode, kPortIndexOutput, OMX_TRUE, &amp;mOutputMetadataType);</span><br><span class="line">            <span class="keyword">if</span> (err != OK) &#123;</span><br><span class="line">                ALOGE(<span class="string">&quot;[%s] storeMetaDataInBuffers failed w/ err %d&quot;</span>,</span><br><span class="line">                        mComponentName.c_str(), err);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// if adaptive playback has been requested, try JB fallback</span></span><br><span class="line">                <span class="comment">// <span class="doctag">NOTE:</span> THIS FALLBACK MECHANISM WILL BE REMOVED DUE TO ITS</span></span><br><span class="line">                <span class="comment">// LARGE MEMORY REQUIREMENT</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// we will not do adaptive playback on software accessed</span></span><br><span class="line">                <span class="comment">// surfaces as they never had to respond to changes in the</span></span><br><span class="line">                <span class="comment">// crop window, and we don&#x27;t trust that they will be able to.</span></span><br><span class="line">                int usageBits = <span class="number">0</span>;</span><br><span class="line">                bool canDoAdaptivePlayback;</span><br><span class="line"></span><br><span class="line">                <span class="function"><span class="title">if</span> (nativeWindow-&gt;</span>query(</span><br><span class="line">                        nativeWindow.get(),</span><br><span class="line">                        NATIVE_WINDOW_CONSUMER_USAGE_BITS,</span><br><span class="line">                        &amp;usageBits) != OK) &#123;</span><br><span class="line">                    canDoAdaptivePlayback = <span class="literal">false</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    canDoAdaptivePlayback =</span><br><span class="line">                        (usageBits &amp;</span><br><span class="line">                                (GRALLOC_USAGE_SW_READ_MASK |</span><br><span class="line">                                 GRALLOC_USAGE_SW_WRITE_MASK)) == <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                int32_t maxWidth = <span class="number">0</span>, maxHeight = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (canDoAdaptivePlayback &amp;&amp;</span><br><span class="line">                        <span class="function"><span class="title">msg</span>-&gt;</span>findInt32(<span class="string">&quot;max-width&quot;</span>, &amp;maxWidth) &amp;&amp;</span><br><span class="line">                        <span class="function"><span class="title">msg</span>-&gt;</span>findInt32(<span class="string">&quot;max-height&quot;</span>, &amp;maxHeight)) &#123;</span><br><span class="line">                    ALOGV(<span class="string">&quot;[%s] prepareForAdaptivePlayback(%dx%d)&quot;</span>,</span><br><span class="line">                            mComponentName.c_str(), maxWidth, maxHeight);</span><br><span class="line"></span><br><span class="line">                    <span class="function"><span class="title">err</span> = mOMX-&gt;</span>prepareForAdaptivePlayback(</span><br><span class="line">                            mNode, kPortIndexOutput, OMX_TRUE, maxWidth,</span><br><span class="line">                            maxHeight);</span><br><span class="line">                    ALOGW_IF(err != OK,</span><br><span class="line">                            <span class="string">&quot;[%s] prepareForAdaptivePlayback failed w/ err %d&quot;</span>,</span><br><span class="line">                            mComponentName.c_str(), err);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (err == OK) &#123;</span><br><span class="line">                        <span class="function"><span class="title">inputFormat</span>-&gt;</span>setInt32(<span class="string">&quot;max-width&quot;</span>, maxWidth);</span><br><span class="line">                        <span class="function"><span class="title">inputFormat</span>-&gt;</span>setInt32(<span class="string">&quot;max-height&quot;</span>, maxHeight);</span><br><span class="line">                        <span class="function"><span class="title">inputFormat</span>-&gt;</span>setInt32(<span class="string">&quot;adaptive-playback&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// allow failure</span></span><br><span class="line">                err = OK;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ALOGV(<span class="string">&quot;[%s] storeMetaDataInBuffers succeeded&quot;</span>,</span><br><span class="line">                        mComponentName.c_str());</span><br><span class="line">                CHECK(storingMetadataInDecodedBuffers());</span><br><span class="line">                mLegacyAdaptiveExperiment = ADebug::isExperimentEnabled(</span><br><span class="line">                        <span class="string">&quot;legacy-adaptive&quot;</span>, !<span class="function"><span class="title">msg</span>-&gt;</span><span class="built_in">contains</span>(<span class="string">&quot;no-experiments&quot;</span>));</span><br><span class="line"></span><br><span class="line">                <span class="function"><span class="title">inputFormat</span>-&gt;</span>setInt32(<span class="string">&quot;adaptive-playback&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            int32_t push;</span><br><span class="line">            <span class="function"><span class="title">if</span> (msg-&gt;</span>findInt32(<span class="string">&quot;push-blank-buffers-on-shutdown&quot;</span>, &amp;push)</span><br><span class="line">                    &amp;&amp; push != <span class="number">0</span>) &#123;</span><br><span class="line">                mFlags |= kFlagPushBlankBuffersToNativeWindowOnShutdown;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int32_t rotationDegrees;</span><br><span class="line">        <span class="function"><span class="title">if</span> (msg-&gt;</span>findInt32(<span class="string">&quot;rotation-degrees&quot;</span>, &amp;rotationDegrees)) &#123;</span><br><span class="line">            mRotationDegrees = rotationDegrees;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mRotationDegrees = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (video) &#123;</span><br><span class="line">        <span class="comment">// determine need for software renderer</span></span><br><span class="line">        bool usingSwRenderer = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (haveNativeWindow &amp;&amp; mComponentName.startsWith(<span class="string">&quot;OMX.google.&quot;</span>)) &#123;</span><br><span class="line">            usingSwRenderer = <span class="literal">true</span>;</span><br><span class="line">            haveNativeWindow = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (encoder) &#123;</span><br><span class="line">            err = setupVideoEncoder(mime, msg);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            err = setupVideoDecoder(mime, msg, haveNativeWindow);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (err != OK) &#123;</span><br><span class="line">            return err;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (haveNativeWindow) &#123;</span><br><span class="line">            mNativeWindow = static_cast&lt;Surface *&gt;(obj.get());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// initialize native window now to get actual output format</span></span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> this is needed for some encoders even though they don&#x27;t use native window</span></span><br><span class="line">        err = initNativeWindow();</span><br><span class="line">        <span class="keyword">if</span> (err != OK) &#123;</span><br><span class="line">            return err;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// fallback for devices that do not handle flex-YUV for native buffers</span></span><br><span class="line">        <span class="keyword">if</span> (haveNativeWindow) &#123;</span><br><span class="line">            int32_t requestedColorFormat = OMX_COLOR_FormatUnused;</span><br><span class="line">            <span class="function"><span class="title">if</span> (msg-&gt;</span>findInt32(<span class="string">&quot;color-format&quot;</span>, &amp;requestedColorFormat) &amp;&amp;</span><br><span class="line">                    requestedColorFormat == OMX_COLOR_FormatYUV420Flexible) &#123;</span><br><span class="line">                status_t err = getPortFormat(kPortIndexOutput, outputFormat);</span><br><span class="line">                <span class="keyword">if</span> (err != OK) &#123;</span><br><span class="line">                    return err;</span><br><span class="line">                &#125;</span><br><span class="line">                int32_t colorFormat = OMX_COLOR_FormatUnused;</span><br><span class="line">                OMX_U32 flexibleEquivalent = OMX_COLOR_FormatUnused;</span><br><span class="line">                <span class="function"><span class="title">if</span> (!outputFormat-&gt;</span>findInt32(<span class="string">&quot;color-format&quot;</span>, &amp;colorFormat)) &#123;</span><br><span class="line">                    ALOGE(<span class="string">&quot;ouptut port did not have a color format (wrong domain?)&quot;</span>);</span><br><span class="line">                    return BAD_VALUE;</span><br><span class="line">                &#125;</span><br><span class="line">                ALOGD(<span class="string">&quot;[%s] Requested output format %#x and got %#x.&quot;</span>,</span><br><span class="line">                        mComponentName.c_str(), requestedColorFormat, colorFormat);</span><br><span class="line">                <span class="keyword">if</span> (!isFlexibleColorFormat(</span><br><span class="line">                                mOMX, mNode, colorFormat, haveNativeWindow, &amp;flexibleEquivalent)</span><br><span class="line">                        || flexibleEquivalent != (OMX_U32)requestedColorFormat) &#123;</span><br><span class="line">                    <span class="comment">// device did not handle flex-YUV request for native window, fall back</span></span><br><span class="line">                    <span class="comment">// to SW renderer</span></span><br><span class="line">                    ALOGI(<span class="string">&quot;[%s] Falling back to software renderer&quot;</span>, mComponentName.c_str());</span><br><span class="line">                    mNativeWindow.clear();</span><br><span class="line">                    mNativeWindowUsageBits = <span class="number">0</span>;</span><br><span class="line">                    haveNativeWindow = <span class="literal">false</span>;</span><br><span class="line">                    usingSwRenderer = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">if</span> (storingMetadataInDecodedBuffers()) &#123;</span><br><span class="line">                        <span class="function"><span class="title">err</span> = mOMX-&gt;</span>storeMetaDataInBuffers(</span><br><span class="line">                                mNode, kPortIndexOutput, OMX_FALSE, &amp;mOutputMetadataType);</span><br><span class="line">                        mOutputMetadataType = kMetadataBufferTypeInvalid; <span class="comment">// just in case</span></span><br><span class="line">                        <span class="comment">// <span class="doctag">TODO:</span> implement adaptive-playback support for bytebuffer mode.</span></span><br><span class="line">                        <span class="comment">// This is done by SW codecs, but most HW codecs don&#x27;t support it.</span></span><br><span class="line">                        <span class="function"><span class="title">inputFormat</span>-&gt;</span>setInt32(<span class="string">&quot;adaptive-playback&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (err == OK) &#123;</span><br><span class="line">                        <span class="function"><span class="title">err</span> = mOMX-&gt;</span>enableGraphicBuffers(mNode, kPortIndexOutput, OMX_FALSE);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (mFlags &amp; kFlagIsGrallocUsageProtected) &#123;</span><br><span class="line">                        <span class="comment">// fallback is not supported for protected playback</span></span><br><span class="line">                        err = PERMISSION_DENIED;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (err == OK) &#123;</span><br><span class="line">                        err = setupVideoDecoder(mime, msg, <span class="literal">false</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (usingSwRenderer) &#123;</span><br><span class="line">            <span class="function"><span class="title">outputFormat</span>-&gt;</span>setInt32(<span class="string">&quot;using-sw-renderer&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_MPEG)) &#123;</span><br><span class="line">        int32_t numChannels, sampleRate;</span><br><span class="line">        <span class="function"><span class="title">if</span> (!msg-&gt;</span>findInt32(<span class="string">&quot;channel-count&quot;</span>, &amp;numChannels)</span><br><span class="line">                || !<span class="function"><span class="title">msg</span>-&gt;</span>findInt32(<span class="string">&quot;sample-rate&quot;</span>, &amp;sampleRate)) &#123;</span><br><span class="line">            <span class="comment">// Since we did not always check for these, leave them optional</span></span><br><span class="line">            <span class="comment">// and have the decoder figure it all out.</span></span><br><span class="line">            err = OK;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            err = setupRawAudioFormat(</span><br><span class="line">                    encoder ? kPortIndexInput : kPortIndexOutput,</span><br><span class="line">                    sampleRate,</span><br><span class="line">                    numChannels);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_AAC)) &#123;</span><br><span class="line">        int32_t numChannels, sampleRate;</span><br><span class="line">        <span class="function"><span class="title">if</span> (!msg-&gt;</span>findInt32(<span class="string">&quot;channel-count&quot;</span>, &amp;numChannels)</span><br><span class="line">                || !<span class="function"><span class="title">msg</span>-&gt;</span>findInt32(<span class="string">&quot;sample-rate&quot;</span>, &amp;sampleRate)) &#123;</span><br><span class="line">            err = INVALID_OPERATION;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            int32_t isADTS, aacProfile;</span><br><span class="line">            int32_t sbrMode;</span><br><span class="line">            int32_t maxOutputChannelCount;</span><br><span class="line">            int32_t pcmLimiterEnable;</span><br><span class="line">            drcParams_t drc;</span><br><span class="line">            <span class="function"><span class="title">if</span> (!msg-&gt;</span>findInt32(<span class="string">&quot;is-adts&quot;</span>, &amp;isADTS)) &#123;</span><br><span class="line">                isADTS = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="title">if</span> (!msg-&gt;</span>findInt32(<span class="string">&quot;aac-profile&quot;</span>, &amp;aacProfile)) &#123;</span><br><span class="line">                aacProfile = OMX_AUDIO_AACObjectNull;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="title">if</span> (!msg-&gt;</span>findInt32(<span class="string">&quot;aac-sbr-mode&quot;</span>, &amp;sbrMode)) &#123;</span><br><span class="line">                sbrMode = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="title">if</span> (!msg-&gt;</span>findInt32(<span class="string">&quot;aac-max-output-channel_count&quot;</span>, &amp;maxOutputChannelCount)) &#123;</span><br><span class="line">                maxOutputChannelCount = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="title">if</span> (!msg-&gt;</span>findInt32(<span class="string">&quot;aac-pcm-limiter-enable&quot;</span>, &amp;pcmLimiterEnable)) &#123;</span><br><span class="line">                <span class="comment">// value is unknown</span></span><br><span class="line">                pcmLimiterEnable = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="title">if</span> (!msg-&gt;</span>findInt32(<span class="string">&quot;aac-encoded-target-level&quot;</span>, &amp;drc.encodedTargetLevel)) &#123;</span><br><span class="line">                <span class="comment">// value is unknown</span></span><br><span class="line">                drc.encodedTargetLevel = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="title">if</span> (!msg-&gt;</span>findInt32(<span class="string">&quot;aac-drc-cut-level&quot;</span>, &amp;drc.drcCut)) &#123;</span><br><span class="line">                <span class="comment">// value is unknown</span></span><br><span class="line">                drc.drcCut = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="title">if</span> (!msg-&gt;</span>findInt32(<span class="string">&quot;aac-drc-boost-level&quot;</span>, &amp;drc.drcBoost)) &#123;</span><br><span class="line">                <span class="comment">// value is unknown</span></span><br><span class="line">                drc.drcBoost = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="title">if</span> (!msg-&gt;</span>findInt32(<span class="string">&quot;aac-drc-heavy-compression&quot;</span>, &amp;drc.heavyCompression)) &#123;</span><br><span class="line">                <span class="comment">// value is unknown</span></span><br><span class="line">                drc.heavyCompression = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="title">if</span> (!msg-&gt;</span>findInt32(<span class="string">&quot;aac-target-ref-level&quot;</span>, &amp;drc.targetRefLevel)) &#123;</span><br><span class="line">                <span class="comment">// value is unknown</span></span><br><span class="line">                drc.targetRefLevel = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            err = setupAACCodec(</span><br><span class="line">                    encoder, numChannels, sampleRate, bitRate, aacProfile,</span><br><span class="line">                    isADTS != <span class="number">0</span>, sbrMode, maxOutputChannelCount, drc,</span><br><span class="line">                    pcmLimiterEnable);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_AMR_NB)) &#123;</span><br><span class="line">        err = setupAMRCodec(encoder, <span class="literal">false</span> <span class="comment">/* isWAMR */</span>, bitRate);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_AMR_WB)) &#123;</span><br><span class="line">        err = setupAMRCodec(encoder, <span class="literal">true</span> <span class="comment">/* isWAMR */</span>, bitRate);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_G711_ALAW)</span><br><span class="line">            || !strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_G711_MLAW)) &#123;</span><br><span class="line">        <span class="comment">// These are PCM-like formats with a fixed sample rate but</span></span><br><span class="line">        <span class="comment">// a variable number of channels.</span></span><br><span class="line"></span><br><span class="line">        int32_t numChannels;</span><br><span class="line">        <span class="function"><span class="title">if</span> (!msg-&gt;</span>findInt32(<span class="string">&quot;channel-count&quot;</span>, &amp;numChannels)) &#123;</span><br><span class="line">            err = INVALID_OPERATION;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            int32_t sampleRate;</span><br><span class="line">            <span class="function"><span class="title">if</span> (!msg-&gt;</span>findInt32(<span class="string">&quot;sample-rate&quot;</span>, &amp;sampleRate)) &#123;</span><br><span class="line">                sampleRate = <span class="number">8000</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            err = setupG711Codec(encoder, sampleRate, numChannels);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_FLAC)) &#123;</span><br><span class="line">        int32_t numChannels = <span class="number">0</span>, sampleRate = <span class="number">0</span>, compressionLevel = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (encoder &amp;&amp;</span><br><span class="line">                (!<span class="function"><span class="title">msg</span>-&gt;</span>findInt32(<span class="string">&quot;channel-count&quot;</span>, &amp;numChannels)</span><br><span class="line">                        || !<span class="function"><span class="title">msg</span>-&gt;</span>findInt32(<span class="string">&quot;sample-rate&quot;</span>, &amp;sampleRate))) &#123;</span><br><span class="line">            ALOGE(<span class="string">&quot;missing channel count or sample rate for FLAC encoder&quot;</span>);</span><br><span class="line">            err = INVALID_OPERATION;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (encoder) &#123;</span><br><span class="line">                <span class="function"><span class="title">if</span> (!msg-&gt;</span>findInt32(</span><br><span class="line">                            <span class="string">&quot;complexity&quot;</span>, &amp;compressionLevel) &amp;&amp;</span><br><span class="line">                    !<span class="function"><span class="title">msg</span>-&gt;</span>findInt32(</span><br><span class="line">                            <span class="string">&quot;flac-compression-level&quot;</span>, &amp;compressionLevel)) &#123;</span><br><span class="line">                    compressionLevel = <span class="number">5</span>; <span class="comment">// default FLAC compression level</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (compressionLevel &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    ALOGW(<span class="string">&quot;compression level %d outside [0..8] range, &quot;</span></span><br><span class="line">                          <span class="string">&quot;using 0&quot;</span>,</span><br><span class="line">                          compressionLevel);</span><br><span class="line">                    compressionLevel = <span class="number">0</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (compressionLevel &gt; <span class="number">8</span>) &#123;</span><br><span class="line">                    ALOGW(<span class="string">&quot;compression level %d outside [0..8] range, &quot;</span></span><br><span class="line">                          <span class="string">&quot;using 8&quot;</span>,</span><br><span class="line">                          compressionLevel);</span><br><span class="line">                    compressionLevel = <span class="number">8</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            err = setupFlacCodec(</span><br><span class="line">                    encoder, numChannels, sampleRate, compressionLevel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_RAW)) &#123;</span><br><span class="line">        int32_t numChannels, sampleRate;</span><br><span class="line">        <span class="keyword">if</span> (encoder</span><br><span class="line">                || !<span class="function"><span class="title">msg</span>-&gt;</span>findInt32(<span class="string">&quot;channel-count&quot;</span>, &amp;numChannels)</span><br><span class="line">                || !<span class="function"><span class="title">msg</span>-&gt;</span>findInt32(<span class="string">&quot;sample-rate&quot;</span>, &amp;sampleRate)) &#123;</span><br><span class="line">            err = INVALID_OPERATION;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            err = setupRawAudioFormat(kPortIndexInput, sampleRate, numChannels);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_AC3)) &#123;</span><br><span class="line">        int32_t numChannels;</span><br><span class="line">        int32_t sampleRate;</span><br><span class="line">        <span class="function"><span class="title">if</span> (!msg-&gt;</span>findInt32(<span class="string">&quot;channel-count&quot;</span>, &amp;numChannels)</span><br><span class="line">                || !<span class="function"><span class="title">msg</span>-&gt;</span>findInt32(<span class="string">&quot;sample-rate&quot;</span>, &amp;sampleRate)) &#123;</span><br><span class="line">            err = INVALID_OPERATION;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            err = setupAC3Codec(encoder, numChannels, sampleRate);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_EAC3)) &#123;</span><br><span class="line">        int32_t numChannels;</span><br><span class="line">        int32_t sampleRate;</span><br><span class="line">        <span class="function"><span class="title">if</span> (!msg-&gt;</span>findInt32(<span class="string">&quot;channel-count&quot;</span>, &amp;numChannels)</span><br><span class="line">                || !<span class="function"><span class="title">msg</span>-&gt;</span>findInt32(<span class="string">&quot;sample-rate&quot;</span>, &amp;sampleRate)) &#123;</span><br><span class="line">            err = INVALID_OPERATION;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            err = setupEAC3Codec(encoder, numChannels, sampleRate);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err != OK) &#123;</span><br><span class="line">        return err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">if</span> (!msg-&gt;</span>findInt32(<span class="string">&quot;encoder-delay&quot;</span>, &amp;mEncoderDelay)) &#123;</span><br><span class="line">        mEncoderDelay = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">if</span> (!msg-&gt;</span>findInt32(<span class="string">&quot;encoder-padding&quot;</span>, &amp;mEncoderPadding)) &#123;</span><br><span class="line">        mEncoderPadding = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">if</span> (msg-&gt;</span>findInt32(<span class="string">&quot;channel-mask&quot;</span>, &amp;mChannelMask)) &#123;</span><br><span class="line">        mChannelMaskPresent = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mChannelMaskPresent = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int32_t maxInputSize;</span><br><span class="line">    <span class="function"><span class="title">if</span> (msg-&gt;</span>findInt32(<span class="string">&quot;max-input-size&quot;</span>, &amp;maxInputSize)) &#123;</span><br><span class="line">        err = setMinBufferSize(kPortIndexInput, (size_t)maxInputSize);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcmp(<span class="string">&quot;OMX.Nvidia.aac.decoder&quot;</span>, mComponentName.c_str())) &#123;</span><br><span class="line">        err = setMinBufferSize(kPortIndexInput, <span class="number">8192</span>);  <span class="comment">// XXX</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int32_t priority;</span><br><span class="line">    <span class="function"><span class="title">if</span> (msg-&gt;</span>findInt32(<span class="string">&quot;priority&quot;</span>, &amp;priority)) &#123;</span><br><span class="line">        err = setPriority(priority);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int32_t rateInt = -<span class="number">1</span>;</span><br><span class="line">    float rateFloat = -<span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="title">if</span> (!msg-&gt;</span>findFloat(<span class="string">&quot;operating-rate&quot;</span>, &amp;rateFloat)) &#123;</span><br><span class="line">        <span class="function"><span class="title">msg</span>-&gt;</span>findInt32(<span class="string">&quot;operating-rate&quot;</span>, &amp;rateInt);</span><br><span class="line">        rateFloat = (float)rateInt;  <span class="comment">// 16MHz (FLINTMAX) is OK for upper bound.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rateFloat &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        err = setOperatingRate(rateFloat, video);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mBaseOutputFormat = outputFormat;</span><br><span class="line"></span><br><span class="line">    err = getPortFormat(kPortIndexInput, inputFormat);</span><br><span class="line">    <span class="keyword">if</span> (err == OK) &#123;</span><br><span class="line">        err = getPortFormat(kPortIndexOutput, outputFormat);</span><br><span class="line">        <span class="keyword">if</span> (err == OK) &#123;</span><br><span class="line">            mInputFormat = inputFormat;</span><br><span class="line">            mOutputFormat = outputFormat;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>到了这里整个解码器的初始化和配置已经结束了，我们看下解码器的start阶段：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">status_t MediaCodec::start<span class="literal">()</span> &#123;</span><br><span class="line">    sp&lt;AMessage&gt; msg = <span class="keyword">new</span> <span class="constructor">AMessage(<span class="params">kWhatStart</span>, <span class="params">this</span>)</span>;</span><br><span class="line"></span><br><span class="line">    status_t err;</span><br><span class="line">    Vector&lt;MediaResource&gt; resources;</span><br><span class="line">    const <span class="built_in">char</span> *<span class="keyword">type</span> = (mFlags &amp; kFlagIsSecure) ?</span><br><span class="line">            kResourceSecureCodec : kResourceNonSecureCodec;</span><br><span class="line">    const <span class="built_in">char</span> *subtype = mIsVideo ? kResourceVideoCodec : kResourceAudioCodec;</span><br><span class="line">    resources.push<span class="constructor">_back(MediaResource(String8(<span class="params">type</span>)</span>, <span class="constructor">String8(<span class="params">subtype</span>)</span>, <span class="number">1</span>));</span><br><span class="line">    <span class="comment">// Don&#x27;t know the buffer size at this point, but it&#x27;s fine to use 1 because</span></span><br><span class="line">    <span class="comment">// the reclaimResource call doesn&#x27;t consider the requester&#x27;s buffer size for now.</span></span><br><span class="line">    resources.push<span class="constructor">_back(MediaResource(String8(<span class="params">kResourceGraphicMemory</span>)</span>, <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt;= kMaxRetry; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// Don&#x27;t try to reclaim resource for the first time.</span></span><br><span class="line">            <span class="keyword">if</span> (!mResourceManagerService-&gt;reclaim<span class="constructor">Resource(<span class="params">resources</span>)</span>) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Recover codec from previous error before retry start.</span></span><br><span class="line">            err = reset<span class="literal">()</span>;</span><br><span class="line">            <span class="keyword">if</span> (err != OK) &#123;</span><br><span class="line">                <span class="constructor">ALOGE(<span class="string">&quot;retrying start: failed to reset codec&quot;</span>)</span>;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            sp&lt;AMessage&gt; response;</span><br><span class="line">            err = <span class="constructor">PostAndAwaitResponse(<span class="params">mConfigureMsg</span>, &amp;<span class="params">response</span>)</span>;</span><br><span class="line">            <span class="keyword">if</span> (err != OK) &#123;</span><br><span class="line">                <span class="constructor">ALOGE(<span class="string">&quot;retrying start: failed to configure codec&quot;</span>)</span>;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sp&lt;AMessage&gt; response;</span><br><span class="line">        err = <span class="constructor">PostAndAwaitResponse(<span class="params">msg</span>, &amp;<span class="params">response</span>)</span>;</span><br><span class="line">        <span class="keyword">if</span> (!is<span class="constructor">ResourceError(<span class="params">err</span>)</span>) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">case kWhatStart:</span><br><span class="line">&#123;</span><br><span class="line">    sp&lt;AReplyToken&gt; replyID;</span><br><span class="line">    <span class="constructor">CHECK(<span class="params">msg</span>-&gt;<span class="params">senderAwaitsResponse</span>(&amp;<span class="params">replyID</span>)</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mState<span class="operator"> == </span>FLUSHED) &#123;</span><br><span class="line">        set<span class="constructor">State(STARTED)</span>;</span><br><span class="line">        <span class="keyword">if</span> (mHavePendingInputBuffers) &#123;</span><br><span class="line">            on<span class="constructor">InputBufferAvailable()</span>;</span><br><span class="line">            mHavePendingInputBuffers = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//我们重点看这里</span></span><br><span class="line">        mCodec-&gt;signal<span class="constructor">Resume()</span>;</span><br><span class="line">        <span class="comment">//..................</span></span><br><span class="line">        <span class="constructor">PostReplyWithError(<span class="params">replyID</span>, OK)</span>;</span><br><span class="line">        break;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mState != CONFIGURED) &#123;</span><br><span class="line">        <span class="constructor">PostReplyWithError(<span class="params">replyID</span>, INVALID_OPERATION)</span>;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mReplyID = replyID;</span><br><span class="line">    set<span class="constructor">State(STARTING)</span>;</span><br><span class="line"></span><br><span class="line">    mCodec-&gt;initiate<span class="constructor">Start()</span>;</span><br><span class="line">    break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先調用initiateStart初始化解码器状态</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line"><span class="literal">void</span> ACodec::initiateStart() &#123;</span><br><span class="line">    <span class="function"><span class="params">(<span class="keyword">new</span> AMessage(kWhatStart, this))</span>-&gt;</span>post();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> ACodec::kWhatStart:</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">onStart</span>();</span><br><span class="line">    handled = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">void ACodec::LoadedState::onStart() &#123;</span><br><span class="line">    ALOGV(<span class="string">&quot;onStart&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">status_t</span> err = mCodec-&gt;</span><span class="function"><span class="title">mOMX</span>-&gt;</span><span class="function"><span class="title">sendCommand</span>(mCodec-&gt;</span>mNode, OMX_CommandStateSet, OMX_StateIdle);</span><br><span class="line">    <span class="keyword">if</span> (err != OK) &#123;</span><br><span class="line">        <span class="function"><span class="title">mCodec</span>-&gt;</span>signalError(OMX_ErrorUndefined, makeNoSideEffectStatus(err));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="function"><span class="title">mCodec</span>-&gt;</span><span class="function"><span class="title">changeState</span>(mCodec-&gt;</span>mLoadedToIdleState);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着开始获取数据进行解码</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line"><span class="literal">void</span> ACodec::signalResume() &#123;</span><br><span class="line">    <span class="function"><span class="params">(<span class="keyword">new</span> AMessage(kWhatResume, this))</span>-&gt;</span>post();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> kWhatResume:</span><br><span class="line">&#123;</span><br><span class="line">    resume();</span><br><span class="line">    handled = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">void ACodec::ExecutingState::resume() &#123;</span><br><span class="line"></span><br><span class="line">    submitOutputBuffers();</span><br><span class="line">    <span class="comment">// Post all available input buffers</span></span><br><span class="line">    <span class="function"><span class="title">if</span> (mCodec-&gt;</span>mBuffers[kPortIndexInput].size() == <span class="number">0</span>u) &#123;</span><br><span class="line">        ALOGW(<span class="string">&quot;[%s] we don&#x27;t have any input buffers to resume&quot;</span>, <span class="function"><span class="title">mCodec</span>-&gt;</span>mComponentName.c_str());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">for</span> (size_t i = 0; i &lt; mCodec-&gt;</span>mBuffers[kPortIndexInput].size(); i++) &#123;</span><br><span class="line">        B<span class="function"><span class="title">ufferInfo</span> *info = &amp;mCodec-&gt;</span>mBuffers[kPortIndexInput].editItemAt(i);</span><br><span class="line">        <span class="function"><span class="title">if</span> (info-&gt;</span>mStatus == BufferInfo::OWNED_BY_US) &#123;</span><br><span class="line">            postFillThisBuffer(info);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mActive = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">void ACodec::BaseState::postFillThisBuffer(BufferInfo *info) &#123;</span><br><span class="line">    <span class="function"><span class="title">if</span> (mCodec-&gt;</span>mPortEOS[kPortIndexInput]) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CHECK_EQ((<span class="function"><span class="title">int</span>)info-&gt;</span>mStatus, (int)BufferInfo::OWNED_BY_US);</span><br><span class="line">    <span class="function"><span class="title">sp</span>&lt;AMessage&gt; notify = mCodec-&gt;</span><span class="function"><span class="title">mNotify</span>-&gt;</span>dup();</span><br><span class="line">    <span class="function"><span class="title">notify</span>-&gt;</span>setInt32(<span class="string">&quot;what&quot;</span>, CodecBase::kWhatFillThisBuffer);</span><br><span class="line">    <span class="function"><span class="title">notify</span>-&gt;</span><span class="function"><span class="title">setInt32</span>(&quot;buffer-id&quot;, info-&gt;</span>mBufferID);</span><br><span class="line">    <span class="function"><span class="title">info</span>-&gt;</span><span class="function"><span class="title">mData</span>-&gt;</span><span class="function"><span class="title">meta</span>()-&gt;</span>clear();</span><br><span class="line">    <span class="function"><span class="title">notify</span>-&gt;</span><span class="function"><span class="title">setBuffer</span>(&quot;buffer&quot;, info-&gt;</span>mData);</span><br><span class="line">    sp&lt;AMessage&gt; reply = new AMessage(kWhatInputBufferFilled, mCodec);</span><br><span class="line">    <span class="function"><span class="title">reply</span>-&gt;</span><span class="function"><span class="title">setInt32</span>(&quot;buffer-id&quot;, info-&gt;</span>mBufferID);</span><br><span class="line">    <span class="function"><span class="title">notify</span>-&gt;</span>setMessage(<span class="string">&quot;reply&quot;</span>, reply);</span><br><span class="line">    <span class="function"><span class="title">notify</span>-&gt;</span>post();</span><br><span class="line">    <span class="function"><span class="title">info</span>-&gt;</span>mStatus = BufferInfo::OWNED_BY_UPSTREAM;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">case CodecBase::kWhatFillThisBuffer:</span><br><span class="line">&#123;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//..........</span></span><br><span class="line">    <span class="keyword">if</span> (mFlags &amp; kFlagIsAsync) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mHaveInputSurface) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mState<span class="operator"> == </span>FLUSHED) &#123;</span><br><span class="line">                mHavePendingInputBuffers = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                on<span class="constructor">InputBufferAvailable()</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mFlags &amp; kFlagDequeueInputPending) &#123;</span><br><span class="line">        <span class="constructor">CHECK(<span class="params">handleDequeueInputBuffer</span>(<span class="params">mDequeueInputReplyID</span>)</span>);</span><br><span class="line">        ++mDequeueInputTimeoutGeneration;</span><br><span class="line">        mFlags &amp;= ~kFlagDequeueInputPending;</span><br><span class="line">        mDequeueInputReplyID = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        post<span class="constructor">ActivityNotificationIfPossible()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">void MediaCodec::onInputBufferAvailable() &#123;</span><br><span class="line">    int32_t index;</span><br><span class="line">    <span class="keyword">while</span> ((index = dequeuePortBuffer(kPortIndexInput)) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="function"><span class="title">sp</span>&lt;AMessage&gt; msg = mCallback-&gt;</span>dup();</span><br><span class="line">        <span class="function"><span class="title">msg</span>-&gt;</span>setInt32(<span class="string">&quot;callbackID&quot;</span>, CB_INPUT_AVAILABLE);</span><br><span class="line">        <span class="function"><span class="title">msg</span>-&gt;</span>setInt32(<span class="string">&quot;index&quot;</span>, index);</span><br><span class="line">        <span class="function"><span class="title">msg</span>-&gt;</span>post();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还记得这个mCallback怎么来的吗？</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void NuPlayer::Decoder::on<span class="constructor">Configure(<span class="params">const</span> <span class="params">sp</span>&lt;AMessage&gt; &amp;<span class="params">format</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//.................</span></span><br><span class="line">    sp&lt;AMessage&gt; reply = <span class="keyword">new</span> <span class="constructor">AMessage(<span class="params">kWhatCodecNotify</span>, <span class="params">this</span>)</span>;</span><br><span class="line">    mCodec-&gt;set<span class="constructor">Callback(<span class="params">reply</span>)</span>;</span><br><span class="line">	<span class="comment">//..................</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">status_t MediaCodec::set<span class="constructor">Callback(<span class="params">const</span> <span class="params">sp</span>&lt;AMessage&gt; &amp;<span class="params">callback</span>)</span> &#123;</span><br><span class="line">    sp&lt;AMessage&gt; msg = <span class="keyword">new</span> <span class="constructor">AMessage(<span class="params">kWhatSetCallback</span>, <span class="params">this</span>)</span>;</span><br><span class="line">    msg-&gt;set<span class="constructor">Message(<span class="string">&quot;callback&quot;</span>, <span class="params">callback</span>)</span>;</span><br><span class="line"></span><br><span class="line">    sp&lt;AMessage&gt; response;</span><br><span class="line">    return <span class="constructor">PostAndAwaitResponse(<span class="params">msg</span>, &amp;<span class="params">response</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">case kWhatSetCallback:</span><br><span class="line">&#123;</span><br><span class="line">    sp&lt;AReplyToken&gt; replyID;</span><br><span class="line">    <span class="constructor">CHECK(<span class="params">msg</span>-&gt;<span class="params">senderAwaitsResponse</span>(&amp;<span class="params">replyID</span>)</span>);</span><br><span class="line">    sp&lt;AMessage&gt; callback;</span><br><span class="line">    <span class="constructor">CHECK(<span class="params">msg</span>-&gt;<span class="params">findMessage</span>(<span class="string">&quot;callback&quot;</span>, &amp;<span class="params">callback</span>)</span>);</span><br><span class="line"></span><br><span class="line">    mCallback = callback;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mCallback != NULL) &#123;</span><br><span class="line">        mFlags <span class="pattern-match">|= k<span class="constructor">FlagIsAsync</span>;</span></span><br><span class="line"><span class="pattern-match">    &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="pattern-match">        m<span class="constructor">Flags</span> &amp;= ~k<span class="constructor">FlagIsAsync</span>;</span></span><br><span class="line"><span class="pattern-match">    &#125;</span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match">    sp&lt;<span class="constructor">AMessage</span>&gt; response = <span class="keyword">new</span> <span class="constructor">AMessage</span>;</span></span><br><span class="line"><span class="pattern-match">    response-&gt;post<span class="constructor">Reply(<span class="params">replyID</span>)</span>;</span></span><br><span class="line"><span class="pattern-match">    break;</span></span><br><span class="line"><span class="pattern-match">&#125;</span></span><br></pre></td></tr></table></figure>
<p>所以根据上面我们可以知道接下来i调用的是kWhatCodecNotify 下的 CB_INPUT_AVAILABLE</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">case MediaCodec::CB_INPUT_AVAILABLE:</span><br><span class="line">&#123;</span><br><span class="line">    int32_t index;</span><br><span class="line">    <span class="constructor">CHECK(<span class="params">msg</span>-&gt;<span class="params">findInt32</span>(<span class="string">&quot;index&quot;</span>, &amp;<span class="params">index</span>)</span>);</span><br><span class="line"></span><br><span class="line">    handle<span class="constructor">AnInputBuffer(<span class="params">index</span>)</span>;</span><br><span class="line">    break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="built_in">bool</span> NuPlayer::Decoder::handle<span class="constructor">AnInputBuffer(<span class="params">size_t</span> <span class="params">index</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (is<span class="constructor">DiscontinuityPending()</span>) &#123;</span><br><span class="line">        return <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sp&lt;ABuffer&gt; buffer;</span><br><span class="line">    mCodec-&gt;get<span class="constructor">InputBuffer(<span class="params">index</span>, &amp;<span class="params">buffer</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (buffer<span class="operator"> == </span>NULL) &#123;</span><br><span class="line">        handle<span class="constructor">Error(UNKNOWN_ERROR)</span>;</span><br><span class="line">        return <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index &gt;= mInputBuffers.size<span class="literal">()</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (size_t i = mInputBuffers.size<span class="literal">()</span>; i &lt;= index; ++i) &#123;</span><br><span class="line">            mInputBuffers.add<span class="literal">()</span>;</span><br><span class="line">            mMediaBuffers.add<span class="literal">()</span>;</span><br><span class="line">            mInputBufferIsDequeued.add<span class="literal">()</span>;</span><br><span class="line">            mMediaBuffers.edit<span class="constructor">ItemAt(<span class="params">i</span>)</span> = NULL;</span><br><span class="line">            mInputBufferIsDequeued.edit<span class="constructor">ItemAt(<span class="params">i</span>)</span> = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mInputBuffers.edit<span class="constructor">ItemAt(<span class="params">index</span>)</span> = buffer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//CHECK_LT(bufferIx, mInputBuffers.size());</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mMediaBuffers<span class="literal">[<span class="identifier">index</span>]</span> != NULL) &#123;</span><br><span class="line">        mMediaBuffers<span class="literal">[<span class="identifier">index</span>]</span>-&gt;release<span class="literal">()</span>;</span><br><span class="line">        mMediaBuffers.edit<span class="constructor">ItemAt(<span class="params">index</span>)</span> = NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    mInputBufferIsDequeued.edit<span class="constructor">ItemAt(<span class="params">index</span>)</span> = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mCSDsToSubmit.is<span class="constructor">Empty()</span>) &#123;</span><br><span class="line">        sp&lt;AMessage&gt; msg = <span class="keyword">new</span> <span class="constructor">AMessage()</span>;</span><br><span class="line">        msg-&gt;set<span class="constructor">Size(<span class="string">&quot;buffer-ix&quot;</span>, <span class="params">index</span>)</span>;</span><br><span class="line"></span><br><span class="line">        sp&lt;ABuffer&gt; buffer = mCSDsToSubmit.item<span class="constructor">At(0)</span>;</span><br><span class="line">        <span class="constructor">ALOGI(<span class="string">&quot;[%s] resubmitting CSD&quot;</span>, <span class="params">mComponentName</span>.<span class="params">c_str</span>()</span>);</span><br><span class="line">        msg-&gt;set<span class="constructor">Buffer(<span class="string">&quot;buffer&quot;</span>, <span class="params">buffer</span>)</span>;</span><br><span class="line">        mCSDsToSubmit.remove<span class="constructor">At(0)</span>;</span><br><span class="line">        <span class="constructor">CHECK(<span class="params">onInputBufferFetched</span>(<span class="params">msg</span>)</span>);</span><br><span class="line">        return <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!mPendingInputMessages.empty<span class="literal">()</span>) &#123;</span><br><span class="line">        sp&lt;AMessage&gt; msg = *mPendingInputMessages.<span class="keyword">begin</span><span class="literal">()</span>;</span><br><span class="line">        <span class="keyword">if</span> (!on<span class="constructor">InputBufferFetched(<span class="params">msg</span>)</span>) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        mPendingInputMessages.erase(mPendingInputMessages.<span class="keyword">begin</span><span class="literal">()</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mInputBufferIsDequeued.edit<span class="constructor">ItemAt(<span class="params">index</span>)</span>) &#123;</span><br><span class="line">        return <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mDequeuedInputBuffers.push<span class="constructor">_back(<span class="params">index</span>)</span>;</span><br><span class="line"></span><br><span class="line">    on<span class="constructor">RequestInputBuffers()</span>;</span><br><span class="line">    return <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void NuPlayer::DecoderBase::on<span class="constructor">RequestInputBuffers()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mRequestInputBuffersPending) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// doRequestBuffers() return true if we should request more data</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">do</span><span class="constructor">RequestBuffers()</span>) &#123;</span><br><span class="line">        mRequestInputBuffersPending = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        sp&lt;AMessage&gt; msg = <span class="keyword">new</span> <span class="constructor">AMessage(<span class="params">kWhatRequestInputBuffers</span>, <span class="params">this</span>)</span>;</span><br><span class="line">        msg-&gt;post(<span class="number">10</span><span class="operator"> * </span><span class="number">1000l</span>l);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="built_in">bool</span> NuPlayer::Decoder::<span class="keyword">do</span><span class="constructor">RequestBuffers()</span> &#123;</span><br><span class="line">    <span class="comment">// mRenderer is only NULL if we have a legacy widevine source that</span></span><br><span class="line">    <span class="comment">// is not yet ready. In this case we must not fetch input.</span></span><br><span class="line">    <span class="keyword">if</span> (is<span class="constructor">DiscontinuityPending()</span><span class="operator"> || </span>mRenderer<span class="operator"> == </span>NULL) &#123;</span><br><span class="line">        return <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    status_t err = OK;</span><br><span class="line">    <span class="keyword">while</span> (err<span class="operator"> == </span>OK<span class="operator"> &amp;&amp; </span>!mDequeuedInputBuffers.empty<span class="literal">()</span>) &#123;</span><br><span class="line">        size_t bufferIx = *mDequeuedInputBuffers.<span class="keyword">begin</span><span class="literal">()</span>;</span><br><span class="line">        sp&lt;AMessage&gt; msg = <span class="keyword">new</span> <span class="constructor">AMessage()</span>;</span><br><span class="line">        msg-&gt;set<span class="constructor">Size(<span class="string">&quot;buffer-ix&quot;</span>, <span class="params">bufferIx</span>)</span>;</span><br><span class="line">        err = fetch<span class="constructor">InputData(<span class="params">msg</span>)</span>;</span><br><span class="line">        <span class="keyword">if</span> (err != OK<span class="operator"> &amp;&amp; </span>err != ERROR_END_OF_STREAM) &#123;</span><br><span class="line">            <span class="comment">// if EOS, need to queue EOS buffer</span></span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        mDequeuedInputBuffers.erase(mDequeuedInputBuffers.<span class="keyword">begin</span><span class="literal">()</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!mPendingInputMessages.empty<span class="literal">()</span><span class="operator"></span></span><br><span class="line"><span class="operator">                || </span>!on<span class="constructor">InputBufferFetched(<span class="params">msg</span>)</span>) &#123;</span><br><span class="line">            mPendingInputMessages.push<span class="constructor">_back(<span class="params">msg</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return err<span class="operator"> == </span>-EWOULDBLOCK<span class="operator"></span></span><br><span class="line"><span class="operator">            &amp;&amp; </span>mSource-&gt;feed<span class="constructor">MoreTSData()</span><span class="operator"> == </span>OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">status_t NuPlayer::Decoder::<span class="title function_ invoke__">fetchInputData</span>(sp&lt;AMessage&gt; &amp;reply) &#123;</span><br><span class="line">    sp&lt;ABuffer&gt; accessUnit;</span><br><span class="line">    <span class="type">bool</span> dropAccessUnit;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        status_t err = mSource<span class="punctuation">-&gt;</span><span class="title function_ invoke__">dequeueAccessUnit</span>(mIsAudio, &amp;accessUnit);</span><br><span class="line"></span><br><span class="line">        <span class="title function_ invoke__">if</span> (err == -EWOULDBLOCK) &#123;</span><br><span class="line">            <span class="keyword">return</span> err;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="title function_ invoke__">if</span> (err != OK) &#123;</span><br><span class="line">            <span class="title function_ invoke__">if</span> (err == INFO_DISCONTINUITY) &#123;</span><br><span class="line">                int32_t <span class="keyword">type</span>;</span><br><span class="line">                <span class="title function_ invoke__">CHECK</span>(accessUnit<span class="punctuation">-&gt;</span><span class="title function_ invoke__">meta</span>()<span class="punctuation">-&gt;</span><span class="title function_ invoke__">findInt32</span>(<span class="string">&quot;discontinuity&quot;</span>, &amp;<span class="keyword">type</span>));</span><br><span class="line"></span><br><span class="line">                <span class="type">bool</span> formatChange =</span><br><span class="line">                    (mIsAudio &amp;&amp;</span><br><span class="line">                     (<span class="keyword">type</span> &amp; ATSParser::DISCONTINUITY_AUDIO_FORMAT))</span><br><span class="line">                    || (!mIsAudio &amp;&amp;</span><br><span class="line">                            (<span class="keyword">type</span> &amp; ATSParser::DISCONTINUITY_VIDEO_FORMAT));</span><br><span class="line"></span><br><span class="line">                <span class="type">bool</span> timeChange = (<span class="keyword">type</span> &amp; ATSParser::DISCONTINUITY_TIME) != <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                <span class="title function_ invoke__">ALOGI</span>(<span class="string">&quot;%s discontinuity (format=%d, time=%d)&quot;</span>,</span><br><span class="line">                        mIsAudio ? <span class="string">&quot;audio&quot;</span> : <span class="string">&quot;video&quot;</span>, formatChange, timeChange);</span><br><span class="line"></span><br><span class="line">                <span class="type">bool</span> seamlessFormatChange = <span class="literal">false</span>;</span><br><span class="line">                sp&lt;AMessage&gt; newFormat = mSource<span class="punctuation">-&gt;</span><span class="title function_ invoke__">getFormat</span>(mIsAudio);</span><br><span class="line">                <span class="title function_ invoke__">if</span> (formatChange) &#123;</span><br><span class="line">                    seamlessFormatChange =</span><br><span class="line">                        <span class="title function_ invoke__">supportsSeamlessFormatChange</span>(newFormat);</span><br><span class="line">                    <span class="comment">// treat seamless format change separately</span></span><br><span class="line">                    formatChange = !seamlessFormatChange;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// For format or time change, return EOS to queue EOS input,</span></span><br><span class="line">                <span class="comment">// then wait for EOS on output.</span></span><br><span class="line">                <span class="title function_ invoke__">if</span> (formatChange <span class="comment">/* not seamless */</span>) &#123;</span><br><span class="line">                    mFormatChangePending = <span class="literal">true</span>;</span><br><span class="line">                    err = ERROR_END_OF_STREAM;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="title function_ invoke__">if</span> (timeChange) &#123;</span><br><span class="line">                    <span class="title function_ invoke__">rememberCodecSpecificData</span>(newFormat);</span><br><span class="line">                    mTimeChangePending = <span class="literal">true</span>;</span><br><span class="line">                    err = ERROR_END_OF_STREAM;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="title function_ invoke__">if</span> (seamlessFormatChange) &#123;</span><br><span class="line">                    <span class="comment">// reuse existing decoder and don&#x27;t flush</span></span><br><span class="line">                    <span class="title function_ invoke__">rememberCodecSpecificData</span>(newFormat);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// This stream is unaffected by the discontinuity</span></span><br><span class="line">                    <span class="keyword">return</span> -EWOULDBLOCK;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// reply should only be returned without a buffer set</span></span><br><span class="line">            <span class="comment">// when there is an error (including EOS)</span></span><br><span class="line">            <span class="title function_ invoke__">CHECK</span>(err != OK);</span><br><span class="line"></span><br><span class="line">            reply<span class="punctuation">-&gt;</span><span class="title function_ invoke__">setInt32</span>(<span class="string">&quot;err&quot;</span>, err);</span><br><span class="line">            <span class="keyword">return</span> ERROR_END_OF_STREAM;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dropAccessUnit = <span class="literal">false</span>;</span><br><span class="line">        <span class="title function_ invoke__">if</span> (!mIsAudio</span><br><span class="line">                &amp;&amp; !mIsSecure</span><br><span class="line">                &amp;&amp; mRenderer<span class="punctuation">-&gt;</span><span class="title function_ invoke__">getVideoLateByUs</span>() &gt; <span class="number">100000</span>ll</span><br><span class="line">                &amp;&amp; mIsVideoAVC</span><br><span class="line">                &amp;&amp; !<span class="title function_ invoke__">IsAVCReferenceFrame</span>(accessUnit)) &#123;</span><br><span class="line">            dropAccessUnit = <span class="literal">true</span>;</span><br><span class="line">            ++mNumInputFramesDropped;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="title function_ invoke__">while</span> (dropAccessUnit);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ALOGV(&quot;returned a valid buffer of %s data&quot;, mIsAudio ? &quot;mIsAudio&quot; : &quot;video&quot;);</span></span><br><span class="line">#<span class="keyword">if</span> <span class="number">0</span></span><br><span class="line">    int64_t mediaTimeUs;</span><br><span class="line">    <span class="title function_ invoke__">CHECK</span>(accessUnit<span class="punctuation">-&gt;</span><span class="title function_ invoke__">meta</span>()<span class="punctuation">-&gt;</span><span class="title function_ invoke__">findInt64</span>(<span class="string">&quot;timeUs&quot;</span>, &amp;mediaTimeUs));</span><br><span class="line">    <span class="title function_ invoke__">ALOGV</span>(<span class="string">&quot;[%s] feeding input buffer at media time %.3f&quot;</span>,</span><br><span class="line">         mIsAudio ? <span class="string">&quot;audio&quot;</span> : <span class="string">&quot;video&quot;</span>,</span><br><span class="line">         mediaTimeUs / <span class="number">1E6</span>);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">if</span> (mCCDecoder != NULL) &#123;</span><br><span class="line">        mCCDecoder<span class="punctuation">-&gt;</span><span class="title function_ invoke__">decode</span>(accessUnit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    reply<span class="punctuation">-&gt;</span><span class="title function_ invoke__">setBuffer</span>(<span class="string">&quot;buffer&quot;</span>, accessUnit);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Android-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">Android 源码分析</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/AOSP-源码/">AOSP 源码</a>
  </div>

</div>



<div class="comments-count">
	
	  	<span></span>
		<a href="/2016/08/02/Android-进阶之源码分析基于NuPlayer的RTSP流媒体协议/#comments" class="ds-thread-count comments-count-link" data-thread-key="2016/08/02/Android-进阶之源码分析基于NuPlayer的RTSP流媒体协议/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/08/02/Android-进阶之源码分析基于NuPlayer的HLS流媒体协议/" title="Android 源码分析之基于NuPlayer的HLS流媒体协议" itemprop="url">Android 源码分析之基于NuPlayer的HLS流媒体协议</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Edgar" target="_blank" itemprop="author">Edgar</a>
		
  <p class="article-time">
    <time datetime="2016-08-02T14:58:01.000Z" itemprop="datePublished"> Published 2016-08-02</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h4 id="HLS-概述"><a href="#HLS-概述" class="headerlink" title="HLS 概述"></a>HLS 概述</h4><p>HTTP Live Streaming（HLS）是苹果公司实现的基于HTTP的流媒体直播和点播协议，主要应用在iOS系统。相对于普通的流媒体，例如RTMP协议、RTSP协议、MMS协议等，HLS最大的优点是可以根据网络状况自动切换到不同码率的视频，如果网络状况较好，则会切换到高码率的视频，若发现网络状况不佳，则会逐渐过渡到低码率的视频，这个我们下面将会结合代码对其进行说明。</p>
<h4 id="HLS框架介绍"><a href="#HLS框架介绍" class="headerlink" title="HLS框架介绍"></a>HLS框架介绍</h4><p>我们接下来看下HLS系统的整体结构图：</p>
<p><img src="/2016/08/02/Android-%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E5%9F%BA%E4%BA%8ENuPlayer%E7%9A%84HLS%E6%B5%81%E5%AA%92%E4%BD%93%E5%8D%8F%E8%AE%AE/0.png"></p>
<p>我们首先将要直播的视频送到编码器中，编码器分别对视频和音频进行编码，然后输出到一个MPEG-2格式的传输流中，再由分段器将MPEG-2传输流进行分段，产生一系列等间隔的媒体片段，这些媒体片段一般很小并且保存成后缀为.ts的文件，同时生成一个指向这些媒体文件的索引文件，也就是我们很经常听到的.M3U8文件。完成分段之后将这些索引文件以及媒体文件上传到Web服务器上。客户端读取索引文件，然后按顺序请求下载索引文件中列出的媒体文件。下载后是一个ts文件。需要进行解压获得对应的媒体数据并解码后进行播放。由于在直播过程中服务器端会不断地将最新的直播数据生成新的小文件，并上传所以只要客户端不断地按顺序下载并播放从服务器获取到的文件，从整个过程上看就相当于实现了直播。而且由于分段文件的很短，客户端可以根据实际的带宽情况切换到不同码率的直播源，从而实现多码率的适配的目的。</p>
<h4 id="M3U8-标签介绍："><a href="#M3U8-标签介绍：" class="headerlink" title="M3U8 标签介绍："></a>M3U8 标签介绍：</h4><p>这部分可以看下下面这篇博客：<br><a target="_blank" rel="noopener" href="http://blog.csdn.net/jwzhangjie/article/details/9744027">http://blog.csdn.net/jwzhangjie/article/details/9744027</a></p>
<h4 id="HLS播放流程"><a href="#HLS播放流程" class="headerlink" title="HLS播放流程"></a>HLS播放流程</h4><ol>
<li>获取不同带宽下对应的网络资源URI及音视频编解码，视频分辨率等信息的文件<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="comment">#EXT-X-STREAM-INF:PROGRAM-ID=1,BANDWIDTH=899152,RESOLUTION=480x270,CODECS=&quot;avc1.4d4015,mp4a.40.5&quot;</span></span><br><span class="line">http:<span class="regexp">//</span>hls.ftdp.com<span class="regexp">/video1_widld/m</span>3u8/<span class="number">01</span>.m3u8</span><br></pre></td></tr></table></figure></li>
<li>根据上述获取的信息初始化对应的编解码器</li>
<li>获取第一个网络资源对应的分段索引列表（index文件）<figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line">#EXTM3U</span><br><span class="line">#EXT-X-VERSION:<span class="number">3</span></span><br><span class="line">#EXT-X-TARGETDURATION:<span class="number">10</span></span><br><span class="line">#EXT-X-MEDIA-<span class="keyword">SEQUENCE</span>:<span class="number">6532</span></span><br><span class="line">#EXT-X-KEY:<span class="keyword">METHOD</span>=<span class="title function_">AES</span>-128,<span class="title function_">URI</span>=&quot;18319965201.<span class="title function_">key</span>&quot;</span><br><span class="line">#<span class="title function_">EXTINF</span>:<span class="number">10</span>,</span><br><span class="line"><span class="number">20125484</span>T125708-<span class="number">01</span>-<span class="number">6533</span>.ts</span><br><span class="line">#EXT-X-KEY:<span class="keyword">METHOD</span>=<span class="title function_">AES</span>-128,<span class="title function_">URI</span>=&quot;14319965205.<span class="title function_">key</span>&quot;</span><br><span class="line">#<span class="title function_">EXTINF</span>:<span class="number">10</span>,</span><br><span class="line"><span class="number">20125484</span>T125708-<span class="number">01</span>-<span class="number">6534</span>.ts</span><br><span class="line">....</span><br><span class="line">#EXTINF:<span class="number">8</span>,</span><br><span class="line"><span class="number">20140804</span>T125708-<span class="number">01</span>-<span class="number">6593</span>.ts</span><br></pre></td></tr></table></figure></li>
<li>获取某一个分片的Key</li>
<li>请求下载某一个分片</li>
<li>根据当前的带宽决定是否切换视频资源</li>
<li>将下载的分片资源解密后送到解码器进行解码</li>
</ol>
<p><img src="/2016/08/02/Android-%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E5%9F%BA%E4%BA%8ENuPlayer%E7%9A%84HLS%E6%B5%81%E5%AA%92%E4%BD%93%E5%8D%8F%E8%AE%AE/4.png"></p>
<p>关于NuPlayerDrvier的创建以及SetDataSource的流程和Stagefight Player大体一致，区别在于setDataSource的时候是根据url的不同会创建三种不同的DataSource：HttpLiveSource，RTSPSource，以及GenericSource。这里就不做大篇幅的介绍了，就直接上图吧：<br><img src="/2016/08/02/Android-%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E5%9F%BA%E4%BA%8ENuPlayer%E7%9A%84HLS%E6%B5%81%E5%AA%92%E4%BD%93%E5%8D%8F%E8%AE%AE/1.png"><br><img src="/2016/08/02/Android-%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E5%9F%BA%E4%BA%8ENuPlayer%E7%9A%84HLS%E6%B5%81%E5%AA%92%E4%BD%93%E5%8D%8F%E8%AE%AE/2.png"><br><img src="/2016/08/02/Android-%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E5%9F%BA%E4%BA%8ENuPlayer%E7%9A%84HLS%E6%B5%81%E5%AA%92%E4%BD%93%E5%8D%8F%E8%AE%AE/3.png"></p>
<p>我们直接从prepare结合HLS原理开始分析：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">NuPlayerDriver::prepare</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">ALOGV</span>(<span class="string">&quot;prepare(%p)&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">    <span class="function">Mutex::Autolock <span class="title">autoLock</span><span class="params">(mLock)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">prepare_l</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">NuPlayerDriver::prepare_l</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (mState) &#123;</span><br><span class="line">        <span class="keyword">case</span> STATE_UNPREPARED:</span><br><span class="line">            mState = STATE_PREPARING;</span><br><span class="line">            <span class="comment">// Make sure we&#x27;re not posting any notifications, success or</span></span><br><span class="line">            <span class="comment">// failure information is only communicated through our result</span></span><br><span class="line">            <span class="comment">// code.</span></span><br><span class="line">            mIsAsyncPrepare = <span class="literal">false</span>;</span><br><span class="line">            mPlayer-&gt;<span class="built_in">prepareAsync</span>();</span><br><span class="line">            <span class="keyword">while</span> (mState == STATE_PREPARING) &#123;</span><br><span class="line">                mCondition.<span class="built_in">wait</span>(mLock);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> (mState == STATE_PREPARED) ? OK : UNKNOWN_ERROR;</span><br><span class="line">        <span class="keyword">case</span> STATE_STOPPED:</span><br><span class="line">            <span class="comment">//......</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> INVALID_OPERATION;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先我们在经过setDataSource阶段会将状态变量mState设置为STATE_UNPREPARED，那么在NuPlayerDriver::prepare_l()中我们实际上调用的是mPlayer-&gt;prepareAsync()，也就是Nuplayer的prepareAsync方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title class_">NuPlayer</span>::<span class="title function_">prepareAsync</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//发送一个kWhatPrepare消息</span></span><br><span class="line">    (<span class="keyword">new</span> <span class="title class_">AMessage</span>(kWhatPrepare, <span class="variable language_">this</span>))-&gt;<span class="title function_">post</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在NuPlayer::prepareAsync中只是发送了一个kWhatPrepare的消息。找到对应的Handler查看处理流程如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title class_">NuPlayer</span>::<span class="title function_">onMessageReceived</span>(<span class="params"><span class="keyword">const</span> sp&lt;AMessage&gt; &amp;msg</span>) &#123;</span><br><span class="line">	<span class="comment">//ignore other fuck source</span></span><br><span class="line">    <span class="keyword">case</span> <span class="attr">kWhatPrepare</span>:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//调用Source的prepareAsync 我们这里看下HttpliveSource</span></span><br><span class="line">        mSource-&gt;<span class="title function_">prepareAsync</span>();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//ignore other fuck source</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里直接调用的是Source的prepareAsync，这个mSource是在setDataSource阶段设置的，我们这里只分析HLS的情形所以需要查看HttpliveSource的prepareAsync。</p>
<figure class="highlight zephir"><table><tr><td class="code"><pre><span class="line">void NuPlayer::HTTPLiveSource::prepareAsync() &#123;</span><br><span class="line">    <span class="comment">//创建并启动一个Looper</span></span><br><span class="line">    <span class="keyword">if</span> (mLiveLooper == NULL) &#123;</span><br><span class="line">        mLiveLooper = <span class="keyword">new</span> ALooper;</span><br><span class="line">        mLiveLooper-&gt;setName(<span class="string">&quot;http live&quot;</span>);</span><br><span class="line">        mLiveLooper-&gt;start();</span><br><span class="line">        mLiveLooper-&gt;registerHandler(this);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建一个kWhatSessionNotify赋值给LiveSession用于通知</span></span><br><span class="line">    sp&lt;AMessage&gt; notify = <span class="keyword">new</span> AMessage(kWhatSessionNotify, this);</span><br><span class="line">    <span class="comment">//创建一个LiveSession</span></span><br><span class="line">    mLiveSession = <span class="keyword">new</span> LiveSession(</span><br><span class="line">            notify,</span><br><span class="line">            (mFlags &amp; kFlagIncognito) ? LiveSession::kFlagIncognito : <span class="number">0</span>,</span><br><span class="line">            mHTTPService);</span><br><span class="line">    mLiveLooper-&gt;registerHandler(mLiveSession);</span><br><span class="line">    <span class="comment">//使用LiveSession进行异步连接</span></span><br><span class="line">    mLiveSession-&gt;connectAsync(mURL.c_str(), mExtraHeaders.isEmpty() ? NULL : &amp;mExtraHeaders);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void LiveSession::connect<span class="constructor">Async(<span class="params">const</span> <span class="params">char</span> <span class="operator">*</span><span class="params">url</span>, <span class="params">const</span> KeyedVector&lt;String8, String8&gt; <span class="operator">*</span><span class="params">headers</span>)</span> &#123;</span><br><span class="line">    <span class="comment">//创建一个kWhatConnect并传入url</span></span><br><span class="line">    sp&lt;AMessage&gt; msg = <span class="keyword">new</span> <span class="constructor">AMessage(<span class="params">kWhatConnect</span>, <span class="params">this</span>)</span>;</span><br><span class="line">    msg-&gt;set<span class="constructor">String(<span class="string">&quot;url&quot;</span>, <span class="params">url</span>)</span>;</span><br><span class="line">    <span class="keyword">if</span> (headers != NULL) &#123;</span><br><span class="line">        msg-&gt;set<span class="constructor">Pointer(<span class="string">&quot;headers&quot;</span>,<span class="params">new</span> KeyedVector&lt;String8, String8&gt;(<span class="operator">*</span><span class="params">headers</span>)</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    msg-&gt;post<span class="literal">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title class_">LiveSession</span>::<span class="title function_">onMessageReceived</span>(<span class="params"><span class="keyword">const</span> sp&lt;AMessage&gt; &amp;msg</span>) &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="attr">kWhatConnect</span>:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//调用onConnect</span></span><br><span class="line">        <span class="title function_">onConnect</span>(msg);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void LiveSession::on<span class="constructor">Connect(<span class="params">const</span> <span class="params">sp</span>&lt;AMessage&gt; &amp;<span class="params">msg</span>)</span> &#123;</span><br><span class="line">    <span class="comment">//获取传过来的Uri</span></span><br><span class="line">    <span class="constructor">CHECK(<span class="params">msg</span>-&gt;<span class="params">findString</span>(<span class="string">&quot;url&quot;</span>, &amp;<span class="params">mMasterURL</span>)</span>);</span><br><span class="line">    KeyedVector&lt;String8, String8&gt; *headers = NULL;</span><br><span class="line">    <span class="keyword">if</span> (!msg-&gt;find<span class="constructor">Pointer(<span class="string">&quot;headers&quot;</span>, (<span class="params">void</span> <span class="operator">**</span>)</span>&amp;headers)) &#123;</span><br><span class="line">        mExtraHeaders.clear<span class="literal">()</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mExtraHeaders = *headers;</span><br><span class="line">        delete headers;</span><br><span class="line">        headers = NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建一个mFetcherLooper</span></span><br><span class="line">    <span class="keyword">if</span> (mFetcherLooper<span class="operator"> == </span>NULL) &#123;</span><br><span class="line">        mFetcherLooper = <span class="keyword">new</span> <span class="constructor">ALooper()</span>;</span><br><span class="line">        mFetcherLooper-&gt;set<span class="constructor">Name(<span class="string">&quot;Fetcher&quot;</span>)</span>;</span><br><span class="line">        mFetcherLooper-&gt;start(<span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取不同带宽下对应的网络资源URI及音视频编解码信息</span></span><br><span class="line">    add<span class="constructor">Fetcher(<span class="params">mMasterURL</span>.<span class="params">c_str</span>()</span>)-&gt;fetch<span class="constructor">PlaylistAsync()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里就开始获取不同带宽下对应的网络资源URI及音视频编解码信息了</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">sp&lt;PlaylistFetcher&gt; LiveSession::add<span class="constructor">Fetcher(<span class="params">const</span> <span class="params">char</span> <span class="operator">*</span><span class="params">uri</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">    ssize_t index = mFetcherInfos.index<span class="constructor">OfKey(<span class="params">uri</span>)</span>;</span><br><span class="line">    sp&lt;AMessage&gt; notify = <span class="keyword">new</span> <span class="constructor">AMessage(<span class="params">kWhatFetcherNotify</span>, <span class="params">this</span>)</span>;</span><br><span class="line">    notify-&gt;set<span class="constructor">String(<span class="string">&quot;uri&quot;</span>, <span class="params">uri</span>)</span>;</span><br><span class="line">    notify-&gt;set<span class="constructor">Int32(<span class="string">&quot;switchGeneration&quot;</span>, <span class="params">mSwitchGeneration</span>)</span>;</span><br><span class="line">    FetcherInfo info;</span><br><span class="line">    <span class="comment">//创建一个PlaylistFetcher并返回</span></span><br><span class="line">    info.mFetcher = <span class="keyword">new</span> <span class="constructor">PlaylistFetcher(<span class="params">notify</span>, <span class="params">this</span>, <span class="params">uri</span>, <span class="params">mCurBandwidthIndex</span>, <span class="params">mSubtitleGeneration</span>)</span>;</span><br><span class="line">    info.mDurationUs = -<span class="number">1l</span>l;</span><br><span class="line">    info.mToBeRemoved = <span class="literal">false</span>;</span><br><span class="line">    info.mToBeResumed = <span class="literal">false</span>;</span><br><span class="line">    mFetcherLooper-&gt;register<span class="constructor">Handler(<span class="params">info</span>.<span class="params">mFetcher</span>)</span>;</span><br><span class="line">    mFetcherInfos.add(uri, info);</span><br><span class="line">    <span class="comment">//这里的info.mFetcher是上面new 出来的PlaylistFetcher</span></span><br><span class="line">    return info.mFetcher;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们通过这里返回的PlaylistFetcher调用fetchPlaylistAsync来获取playlists</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void PlaylistFetcher::fetch<span class="constructor">PlaylistAsync()</span> &#123;</span><br><span class="line">    (<span class="keyword">new</span> <span class="constructor">AMessage(<span class="params">kWhatFetchPlaylist</span>, <span class="params">this</span>)</span>)-&gt;post<span class="literal">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void PlaylistFetcher::on<span class="constructor">MessageReceived(<span class="params">const</span> <span class="params">sp</span>&lt;AMessage&gt; &amp;<span class="params">msg</span>)</span> &#123;</span><br><span class="line">    case kWhatFetchPlaylist:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">bool</span> unchanged;</span><br><span class="line">        <span class="comment">//获取一个M3U8Parser</span></span><br><span class="line">        sp&lt;M3UParser&gt; playlist = mHTTPDownloader-&gt;fetch<span class="constructor">Playlist(<span class="params">mURI</span>.<span class="params">c_str</span>()</span>, NULL <span class="comment">/* curPlaylistHash */</span>, &amp;unchanged);</span><br><span class="line">        sp&lt;AMessage&gt; notify = mNotify-&gt;dup<span class="literal">()</span>;</span><br><span class="line">        notify-&gt;set<span class="constructor">Int32(<span class="string">&quot;what&quot;</span>, <span class="params">kWhatPlaylistFetched</span>)</span>;</span><br><span class="line">        <span class="comment">//将playlist返回</span></span><br><span class="line">        notify-&gt;set<span class="constructor">Object(<span class="string">&quot;playlist&quot;</span>, <span class="params">playlist</span>)</span>;</span><br><span class="line">        notify-&gt;post<span class="literal">()</span>;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们接下来看下fetchFile过程：首先会通过fetchFile从服务器端获取到m3u8 playlist内容存放到buffer缓存区，然后将获取到的缓存数据包装成M3UParser</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function">sp&lt;M3UParser&gt; <span class="title">HTTPDownloader::fetchPlaylist</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> <span class="type">char</span> *url, <span class="type">uint8_t</span> *curPlaylistHash, <span class="type">bool</span> *unchanged)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    *unchanged = <span class="literal">false</span>;</span><br><span class="line">    sp&lt;ABuffer&gt; buffer;</span><br><span class="line">    String8 actualUrl;</span><br><span class="line">    <span class="comment">//调用fetchFile</span></span><br><span class="line">    <span class="type">ssize_t</span> err = <span class="built_in">fetchFile</span>(url, &amp;buffer, &amp;actualUrl);</span><br><span class="line">	<span class="comment">//断开连接</span></span><br><span class="line">    mHTTPDataSource-&gt;<span class="built_in">disconnect</span>();</span><br><span class="line"> 	<span class="comment">//将获取到的缓存数据包装成M3UParser</span></span><br><span class="line">    sp&lt;M3UParser&gt; playlist = <span class="keyword">new</span> <span class="built_in">M3UParser</span>(actualUrl.<span class="built_in">string</span>(), buffer-&gt;<span class="built_in">data</span>(), buffer-&gt;<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">return</span> playlist;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">HTTPDownloader::fetchFile</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> <span class="type">char</span> *url, sp&lt;ABuffer&gt; *out, String8 *actualUrl)</span> </span>&#123;</span><br><span class="line">    <span class="type">ssize_t</span> err = <span class="built_in">fetchBlock</span>(url, out, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, actualUrl, <span class="literal">true</span> <span class="comment">/* reconnect */</span>);</span><br><span class="line">    <span class="comment">// close off the connection after use</span></span><br><span class="line">    mHTTPDataSource-&gt;<span class="built_in">disconnect</span>();</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>我们这里看下M3UParser构造方法：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">M3UParser::<span class="built_in">M3UParser</span>(</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *baseURI, <span class="type">const</span> <span class="type">void</span> *data, <span class="type">size_t</span> size)</span><br><span class="line">    : <span class="built_in">mInitCheck</span>(NO_INIT),</span><br><span class="line">      <span class="built_in">mBaseURI</span>(baseURI),</span><br><span class="line">      <span class="built_in">mIsExtM3U</span>(<span class="literal">false</span>),</span><br><span class="line">      <span class="built_in">mIsVariantPlaylist</span>(<span class="literal">false</span>),</span><br><span class="line">      <span class="built_in">mIsComplete</span>(<span class="literal">false</span>),</span><br><span class="line">      <span class="built_in">mIsEvent</span>(<span class="literal">false</span>),</span><br><span class="line">      <span class="built_in">mFirstSeqNumber</span>(<span class="number">-1</span>),</span><br><span class="line">      <span class="built_in">mLastSeqNumber</span>(<span class="number">-1</span>),</span><br><span class="line">      <span class="built_in">mTargetDurationUs</span>(<span class="number">-1ll</span>),</span><br><span class="line">      <span class="built_in">mDiscontinuitySeq</span>(<span class="number">0</span>),</span><br><span class="line">      <span class="built_in">mDiscontinuityCount</span>(<span class="number">0</span>),</span><br><span class="line">      <span class="built_in">mSelectedIndex</span>(<span class="number">-1</span>) &#123;</span><br><span class="line">    mInitCheck = <span class="built_in">parse</span>(data, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在最后的时候会调用parse对缓存数据进行解析：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">status_t M3UParser::parse(const <span class="type">void</span> *_data, size_t size) &#123;</span><br><span class="line">    int32_t lineNo = <span class="number">0</span>;</span><br><span class="line">    sp&lt;AMessage&gt; itemMeta;</span><br><span class="line">    const <span class="type">char</span> *data = (const <span class="type">char</span> *)_data;</span><br><span class="line">    size_t <span class="keyword">offset</span> = <span class="number">0</span>;</span><br><span class="line">    uint64_t segmentRangeOffset = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">offset</span> &lt; size) &#123;</span><br><span class="line">        size_t offsetLF = <span class="keyword">offset</span>;</span><br><span class="line">        <span class="keyword">while</span> (offsetLF &lt; size &amp;&amp; data[offsetLF] != <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">            ++offsetLF;</span><br><span class="line">        &#125;</span><br><span class="line">        AString <span class="type">line</span>;</span><br><span class="line">        <span class="keyword">if</span> (offsetLF &gt; <span class="keyword">offset</span> &amp;&amp; data[offsetLF - <span class="number">1</span>] == <span class="string">&#x27;\r&#x27;</span>) &#123;</span><br><span class="line">            <span class="type">line</span>.setTo(&amp;data[<span class="keyword">offset</span>], offsetLF - <span class="keyword">offset</span> - <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">line</span>.setTo(&amp;data[<span class="keyword">offset</span>], offsetLF - <span class="keyword">offset</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="type">line</span>.empty()) &#123;</span><br><span class="line">            <span class="keyword">offset</span> = offsetLF + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (lineNo == <span class="number">0</span> &amp;&amp; <span class="type">line</span> == &quot;#EXTM3U&quot;) &#123;</span><br><span class="line">            mIsExtM3U = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mIsExtM3U) &#123;</span><br><span class="line">            status_t err = OK;</span><br><span class="line">            <span class="keyword">if</span> (<span class="type">line</span>.startsWith(&quot;#EXT-X-TARGETDURATION&quot;)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mIsVariantPlaylist) &#123;</span><br><span class="line">                    <span class="keyword">return</span> ERROR_MALFORMED;</span><br><span class="line">                &#125;</span><br><span class="line">                err = parseMetaData(<span class="type">line</span>, &amp;mMeta, &quot;target-duration&quot;);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="type">line</span>.startsWith(&quot;#EXT-X-MEDIA-SEQUENCE&quot;)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mIsVariantPlaylist) &#123;</span><br><span class="line">                    <span class="keyword">return</span> ERROR_MALFORMED;</span><br><span class="line">                &#125;</span><br><span class="line">                err = parseMetaData(<span class="type">line</span>, &amp;mMeta, &quot;media-sequence&quot;);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="type">line</span>.startsWith(&quot;#EXT-X-KEY&quot;)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mIsVariantPlaylist) &#123;</span><br><span class="line">                    <span class="keyword">return</span> ERROR_MALFORMED;</span><br><span class="line">                &#125;</span><br><span class="line">                err = parseCipherInfo(<span class="type">line</span>, &amp;itemMeta, mBaseURI);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="type">line</span>.startsWith(&quot;#EXT-X-ENDLIST&quot;)) &#123;</span><br><span class="line">                mIsComplete = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="type">line</span>.startsWith(&quot;#EXT-X-PLAYLIST-TYPE:EVENT&quot;)) &#123;</span><br><span class="line">                mIsEvent = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="type">line</span>.startsWith(&quot;#EXTINF&quot;)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mIsVariantPlaylist) &#123;</span><br><span class="line">                    <span class="keyword">return</span> ERROR_MALFORMED;</span><br><span class="line">                &#125;</span><br><span class="line">                err = parseMetaDataDuration(<span class="type">line</span>, &amp;itemMeta, &quot;durationUs&quot;);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="type">line</span>.startsWith(&quot;#EXT-X-DISCONTINUITY&quot;)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mIsVariantPlaylist) &#123;</span><br><span class="line">                    <span class="keyword">return</span> ERROR_MALFORMED;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (itemMeta == <span class="keyword">NULL</span>) &#123;</span><br><span class="line">                    itemMeta = <span class="built_in">new</span> AMessage;</span><br><span class="line">                &#125;</span><br><span class="line">                itemMeta-&gt;setInt32(&quot;discontinuity&quot;, <span class="keyword">true</span>);</span><br><span class="line">                ++mDiscontinuityCount;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="type">line</span>.startsWith(&quot;#EXT-X-STREAM-INF&quot;)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mMeta != <span class="keyword">NULL</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> ERROR_MALFORMED;</span><br><span class="line">                &#125;</span><br><span class="line">                mIsVariantPlaylist = <span class="keyword">true</span>;</span><br><span class="line">                err = parseStreamInf(<span class="type">line</span>, &amp;itemMeta);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="type">line</span>.startsWith(&quot;#EXT-X-BYTERANGE&quot;)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mIsVariantPlaylist) &#123;</span><br><span class="line">                    <span class="keyword">return</span> ERROR_MALFORMED;</span><br><span class="line">                &#125;</span><br><span class="line">                uint64_t length, <span class="keyword">offset</span>;</span><br><span class="line">                err = parseByteRange(<span class="type">line</span>, segmentRangeOffset, &amp;length, &amp;<span class="keyword">offset</span>);</span><br><span class="line">                <span class="keyword">if</span> (err == OK) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (itemMeta == <span class="keyword">NULL</span>) &#123;</span><br><span class="line">                        itemMeta = <span class="built_in">new</span> AMessage;</span><br><span class="line">                    &#125;</span><br><span class="line">                    itemMeta-&gt;setInt64(&quot;range-offset&quot;, <span class="keyword">offset</span>);</span><br><span class="line">                    itemMeta-&gt;setInt64(&quot;range-length&quot;, length);</span><br><span class="line">                    segmentRangeOffset = <span class="keyword">offset</span> + length;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="type">line</span>.startsWith(&quot;#EXT-X-MEDIA&quot;)) &#123;</span><br><span class="line">                err = parseMedia(<span class="type">line</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="type">line</span>.startsWith(&quot;#EXT-X-DISCONTINUITY-SEQUENCE&quot;)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mIsVariantPlaylist) &#123;</span><br><span class="line">                    <span class="keyword">return</span> ERROR_MALFORMED;</span><br><span class="line">                &#125;</span><br><span class="line">                size_t seq;</span><br><span class="line">                err = parseDiscontinuitySequence(<span class="type">line</span>, &amp;seq);</span><br><span class="line">                <span class="keyword">if</span> (err == OK) &#123;</span><br><span class="line">                    mDiscontinuitySeq = seq;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (err != OK) &#123;</span><br><span class="line">                <span class="keyword">return</span> err;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="type">line</span>.startsWith(&quot;#&quot;)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!mIsVariantPlaylist) &#123;</span><br><span class="line">                int64_t durationUs;</span><br><span class="line">                <span class="keyword">if</span> (itemMeta == <span class="keyword">NULL</span></span><br><span class="line">                        || !itemMeta-&gt;findInt64(&quot;durationUs&quot;, &amp;durationUs)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> ERROR_MALFORMED;</span><br><span class="line">                &#125;</span><br><span class="line">                itemMeta-&gt;setInt32(&quot;discontinuity-sequence&quot;,</span><br><span class="line">                        mDiscontinuitySeq + mDiscontinuityCount);</span><br><span class="line">            &#125;</span><br><span class="line">            mItems.push();</span><br><span class="line">            Item *item = &amp;mItems.editItemAt(mItems.size() - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">CHECK</span>(MakeURL(mBaseURI.c_str(), <span class="type">line</span>.c_str(), &amp;item-&gt;mURI));</span><br><span class="line">            item-&gt;mMeta = itemMeta;</span><br><span class="line">            itemMeta.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">offset</span> = offsetLF + <span class="number">1</span>;</span><br><span class="line">        ++lineNo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mIsVariantPlaylist) &#123;</span><br><span class="line">        int32_t targetDurationSecs;</span><br><span class="line">        <span class="keyword">if</span> (mMeta == <span class="keyword">NULL</span> || !mMeta-&gt;findInt32(</span><br><span class="line">                &quot;target-duration&quot;, &amp;targetDurationSecs)) &#123;</span><br><span class="line">            ALOGE(&quot;Media playlist missing #EXT-X-TARGETDURATION&quot;);</span><br><span class="line">            <span class="keyword">return</span> ERROR_MALFORMED;</span><br><span class="line">        &#125;</span><br><span class="line">        mTargetDurationUs = targetDurationSecs * <span class="number">1000000</span>ll;</span><br><span class="line">        mFirstSeqNumber = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (mMeta != <span class="keyword">NULL</span>) &#123;</span><br><span class="line">            mMeta-&gt;findInt32(&quot;media-sequence&quot;, &amp;mFirstSeqNumber);</span><br><span class="line">        &#125;</span><br><span class="line">        mLastSeqNumber = mFirstSeqNumber + mItems.size() - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>好了我们现在已经获取到了类型为M3UParser的播放列表文件了，这时候会发送一个kWhatPlaylistFetched，这个在哪里被处理呢？当然是LiveSession啊。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> PlaylistFetcher::kWhatPlaylistFetched:</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">onMasterPlaylistFetched</span>(msg);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获取到播放列表后要干啥呢？我们接下来看：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void LiveSession::on<span class="constructor">MasterPlaylistFetched(<span class="params">const</span> <span class="params">sp</span>&lt;AMessage&gt; &amp;<span class="params">msg</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">    AString uri;</span><br><span class="line">    <span class="constructor">CHECK(<span class="params">msg</span>-&gt;<span class="params">findString</span>(<span class="string">&quot;uri&quot;</span>, &amp;<span class="params">uri</span>)</span>);</span><br><span class="line">    ssize_t index = mFetcherInfos.index<span class="constructor">OfKey(<span class="params">uri</span>)</span>;</span><br><span class="line">    <span class="comment">// no longer useful, remove</span></span><br><span class="line">    mFetcherLooper-&gt;unregister<span class="constructor">Handler(<span class="params">mFetcherInfos</span>[<span class="params">index</span>].<span class="params">mFetcher</span>-&gt;<span class="params">id</span>()</span>);</span><br><span class="line">    mFetcherInfos.remove<span class="constructor">ItemsAt(<span class="params">index</span>)</span>;</span><br><span class="line">    <span class="comment">//取走获取到的playlist</span></span><br><span class="line">    <span class="constructor">CHECK(<span class="params">msg</span>-&gt;<span class="params">findObject</span>(<span class="string">&quot;playlist&quot;</span>, (<span class="params">sp</span>&lt;RefBase&gt; <span class="operator">*</span>)</span>&amp;mPlaylist));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We trust the content provider to make a reasonable choice of preferred</span></span><br><span class="line">    <span class="comment">// initial bandwidth by listing it first in the variant playlist.</span></span><br><span class="line">    <span class="comment">// At startup we really don&#x27;t have a good estimate on the available</span></span><br><span class="line">    <span class="comment">// network bandwidth since we haven&#x27;t tranferred any data yet. Once</span></span><br><span class="line">    <span class="comment">// we have we can make a better informed choice.</span></span><br><span class="line">    size_t initialBandwidth = <span class="number">0</span>;</span><br><span class="line">    size_t initialBandwidthIndex = <span class="number">0</span>;</span><br><span class="line">    int32_t maxWidth = <span class="number">0</span>;</span><br><span class="line">    int32_t maxHeight = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//判断获取到的playlist是否有效，无效就没啥用了，我们这里假设有效</span></span><br><span class="line">    <span class="keyword">if</span> (mPlaylist-&gt;is<span class="constructor">VariantPlaylist()</span>) &#123;</span><br><span class="line">        Vector&lt;BandwidthItem&gt; itemsWithVideo;</span><br><span class="line">        <span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; mPlaylist-&gt;size<span class="literal">()</span>; ++i) &#123;</span><br><span class="line">            BandwidthItem item;</span><br><span class="line">            item.mPlaylistIndex = i;</span><br><span class="line">            item.mLastFailureUs = -<span class="number">1l</span>l;</span><br><span class="line">            sp&lt;AMessage&gt; meta;</span><br><span class="line">            AString uri;</span><br><span class="line">            mPlaylist-&gt;item<span class="constructor">At(<span class="params">i</span>, &amp;<span class="params">uri</span>, &amp;<span class="params">meta</span>)</span>;</span><br><span class="line">            <span class="comment">//获取带宽</span></span><br><span class="line">            <span class="constructor">CHECK(<span class="params">meta</span>-&gt;<span class="params">findInt32</span>(<span class="string">&quot;bandwidth&quot;</span>, (<span class="params">int32_t</span> <span class="operator">*</span>)</span>&amp;item.mBandwidth));</span><br><span class="line">            <span class="comment">//获取最大分辨率</span></span><br><span class="line">            int32_t width, height;</span><br><span class="line">            <span class="keyword">if</span> (meta-&gt;find<span class="constructor">Int32(<span class="string">&quot;width&quot;</span>, &amp;<span class="params">width</span>)</span>) &#123;</span><br><span class="line">                maxWidth = max(maxWidth, width);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (meta-&gt;find<span class="constructor">Int32(<span class="string">&quot;height&quot;</span>, &amp;<span class="params">height</span>)</span>) &#123;</span><br><span class="line">                maxHeight = max(maxHeight, height);</span><br><span class="line">            &#125;</span><br><span class="line">            mBandwidthItems.push(item);</span><br><span class="line">            <span class="keyword">if</span> (mPlaylist-&gt;has<span class="constructor">Type(<span class="params">i</span>, <span class="string">&quot;video&quot;</span>)</span>) &#123;</span><br><span class="line">                itemsWithVideo.push(item);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//移除只有声音的信息</span></span><br><span class="line">        <span class="keyword">if</span> (!itemsWithVideo.empty<span class="literal">()</span>&amp;&amp; itemsWithVideo.size<span class="literal">()</span> &lt; mBandwidthItems.size<span class="literal">()</span>) &#123;</span><br><span class="line">            mBandwidthItems.clear<span class="literal">()</span>;</span><br><span class="line">            <span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; itemsWithVideo.size<span class="literal">()</span>; ++i) &#123;</span><br><span class="line">                mBandwidthItems.push(itemsWithVideo<span class="literal">[<span class="identifier">i</span>]</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="constructor">CHECK_GT(<span class="params">mBandwidthItems</span>.<span class="params">size</span>()</span>, <span class="number">0</span>u);</span><br><span class="line">        initialBandwidth = mBandwidthItems<span class="literal">[<span class="number">0</span>]</span>.mBandwidth;</span><br><span class="line">        <span class="comment">//按照带宽进行排序</span></span><br><span class="line">        mBandwidthItems.sort(SortByBandwidth);</span><br><span class="line">        <span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; mBandwidthItems.size<span class="literal">()</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mBandwidthItems.item<span class="constructor">At(<span class="params">i</span>)</span>.mBandwidth<span class="operator"> == </span>initialBandwidth) &#123;</span><br><span class="line">                initialBandwidthIndex = i;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">//......</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//获取到最大的分辨率</span></span><br><span class="line">    mMaxWidth = maxWidth &gt; <span class="number">0</span> ? maxWidth : mMaxWidth;</span><br><span class="line">    mMaxHeight = maxHeight &gt; <span class="number">0</span> ? maxHeight : mMaxHeight;</span><br><span class="line">    mPlaylist-&gt;pick<span class="constructor">RandomMediaItems()</span>;</span><br><span class="line">    change<span class="constructor">Configuration(0ll <span class="operator">/</span><span class="operator">*</span> <span class="params">timeUs</span> <span class="operator">*</span><span class="operator">/</span>, <span class="params">initialBandwidthIndex</span>, <span class="params">false</span> <span class="operator">/</span><span class="operator">*</span> <span class="params">pickTrack</span> <span class="operator">*</span><span class="operator">/</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void LiveSession::change<span class="constructor">Configuration(<span class="params">int64_t</span> <span class="params">timeUs</span>, <span class="params">ssize_t</span> <span class="params">bandwidthIndex</span>, <span class="params">bool</span> <span class="params">pickTrack</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取消带宽切换</span></span><br><span class="line">    cancel<span class="constructor">BandwidthSwitch()</span>;</span><br><span class="line">    mReconfigurationInProgress = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//由mOrigBandwidthIndex切换到mCurBandwidthIndex</span></span><br><span class="line">    <span class="keyword">if</span> (bandwidthIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//将当前的带宽设置为当前带宽</span></span><br><span class="line">        mOrigBandwidthIndex = mCurBandwidthIndex;</span><br><span class="line">        mCurBandwidthIndex = bandwidthIndex;</span><br><span class="line">        <span class="keyword">if</span> (mOrigBandwidthIndex != mCurBandwidthIndex) &#123;</span><br><span class="line">            <span class="comment">//开始切换带宽</span></span><br><span class="line">            <span class="constructor">ALOGI(<span class="string">&quot;#### Starting Bandwidth Switch: %zd =&gt; %zd&quot;</span>,<span class="params">mOrigBandwidthIndex</span>, <span class="params">mCurBandwidthIndex</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="constructor">CHECK_LT(<span class="params">mCurBandwidthIndex</span>, <span class="params">mBandwidthItems</span>.<span class="params">size</span>()</span>);</span><br><span class="line">    <span class="comment">//获取当前的BandwidthItem</span></span><br><span class="line">    const BandwidthItem &amp;item = mBandwidthItems.item<span class="constructor">At(<span class="params">mCurBandwidthIndex</span>)</span>;</span><br><span class="line">    uint32_t streamMask = <span class="number">0</span>; <span class="comment">// streams that should be fetched by the new fetcher</span></span><br><span class="line">    uint32_t resumeMask = <span class="number">0</span>; <span class="comment">// streams that should be fetched by the original fetcher</span></span><br><span class="line">    AString URIs<span class="literal">[<span class="identifier">kMaxStreams</span>]</span>;</span><br><span class="line">    <span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; kMaxStreams; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mPlaylist-&gt;get<span class="constructor">TypeURI(<span class="params">item</span>.<span class="params">mPlaylistIndex</span>, <span class="params">mStreams</span>[<span class="params">i</span>].<span class="params">mType</span>, &amp;URIs[<span class="params">i</span>])</span>) &#123;</span><br><span class="line">            streamMask <span class="pattern-match">|= index<span class="constructor">ToType(<span class="params">i</span>)</span>;</span></span><br><span class="line"><span class="pattern-match">        &#125;</span></span><br><span class="line"><span class="pattern-match">    &#125;</span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match">    <span class="operator">/</span><span class="operator">/</span> 停止我们不需要的，暂停我们将要复用的，第一次的时候这里是没有的所以跳过</span></span><br><span class="line"><span class="pattern-match">    <span class="keyword">for</span> (size<span class="constructor">_t</span> i = 0; i &lt; m<span class="constructor">FetcherInfos</span>.size(); <span class="operator">++</span>i) &#123;</span></span><br><span class="line"><span class="pattern-match">        <span class="operator">/</span><span class="operator">/</span><span class="operator">...</span><span class="operator">...</span><span class="operator">...</span><span class="operator">...</span><span class="operator">...</span><span class="operator">...</span><span class="operator">...</span><span class="operator">...</span>.</span></span><br><span class="line"><span class="pattern-match">    &#125;</span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match">    sp&lt;<span class="constructor">AMessage</span>&gt; msg;</span></span><br><span class="line"><span class="pattern-match">    <span class="keyword">if</span> (time<span class="constructor">Us</span> &lt; 0ll) &#123;</span></span><br><span class="line"><span class="pattern-match">        <span class="operator">/</span><span class="operator">/</span> skip on<span class="constructor">ChangeConfiguration2</span> (decoder destruction) <span class="keyword">if</span> not seeking.</span></span><br><span class="line"><span class="pattern-match">        msg = <span class="keyword">new</span> <span class="constructor">AMessage(<span class="params">kWhatChangeConfiguration3</span>, <span class="params">this</span>)</span>;</span></span><br><span class="line"><span class="pattern-match">    &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="pattern-match">        msg = <span class="keyword">new</span> <span class="constructor">AMessage(<span class="params">kWhatChangeConfiguration2</span>, <span class="params">this</span>)</span>;</span></span><br><span class="line"><span class="pattern-match">    &#125;</span></span><br><span class="line"><span class="pattern-match">    msg-&gt;set<span class="constructor">Int32(<span class="string">&quot;streamMask&quot;</span>, <span class="params">streamMask</span>)</span>;</span></span><br><span class="line"><span class="pattern-match">    msg-&gt;set<span class="constructor">Int32(<span class="string">&quot;resumeMask&quot;</span>, <span class="params">resumeMask</span>)</span>;</span></span><br><span class="line"><span class="pattern-match">    msg-&gt;set<span class="constructor">Int32(<span class="string">&quot;pickTrack&quot;</span>, <span class="params">pickTrack</span>)</span>;</span></span><br><span class="line"><span class="pattern-match">    msg-&gt;set<span class="constructor">Int64(<span class="string">&quot;timeUs&quot;</span>, <span class="params">timeUs</span>)</span>;</span></span><br><span class="line"><span class="pattern-match">    <span class="keyword">for</span> (size<span class="constructor">_t</span> i = 0; i &lt; k<span class="constructor">MaxStreams</span>; <span class="operator">++</span>i) &#123;</span></span><br><span class="line"><span class="pattern-match">        <span class="keyword">if</span> ((stream<span class="constructor">Mask</span> | resume<span class="constructor">Mask</span>) &amp; index<span class="constructor">ToType(<span class="params">i</span>)</span>) &#123;</span></span><br><span class="line"><span class="pattern-match">            msg-&gt;set<span class="constructor">String(<span class="params">mStreams</span>[<span class="params">i</span>].<span class="params">uriKey</span>()</span>.c<span class="constructor">_str()</span>, <span class="constructor">URIs</span>[i].c<span class="constructor">_str()</span>);</span></span><br><span class="line"><span class="pattern-match">        &#125;</span></span><br><span class="line"><span class="pattern-match">    &#125;</span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match">    <span class="operator">/</span><span class="operator">/</span> <span class="constructor">Every</span> time a fetcher acknowledges the stop<span class="constructor">Async</span> <span class="keyword">or</span> pause<span class="constructor">Async</span> request</span></span><br><span class="line"><span class="pattern-match">    <span class="operator">/</span><span class="operator">/</span> we&#x27;ll decrement m<span class="constructor">ContinuationCounter</span>, once it reaches zero, i.e. all</span></span><br><span class="line"><span class="pattern-match">    <span class="operator">/</span><span class="operator">/</span> fetchers have completed their asynchronous operation, we&#x27;ll post</span></span><br><span class="line"><span class="pattern-match">    <span class="operator">/</span><span class="operator">/</span> m<span class="constructor">Continuation</span>, which <span class="keyword">then</span> is handled below <span class="keyword">in</span> on<span class="constructor">ChangeConfiguration2</span>.</span></span><br><span class="line"><span class="pattern-match">  	<span class="operator">/</span><span class="operator">/</span>每次fetcher 调用了stop<span class="constructor">Async</span>和pause<span class="constructor">Async</span> m<span class="constructor">ContinuationCounter</span> 数值都会减去1,一旦减到0 那么将会在on<span class="constructor">ChangeConfiguration2</span>处理</span></span><br><span class="line"><span class="pattern-match">    m<span class="constructor">ContinuationCounter</span> = m<span class="constructor">FetcherInfos</span>.size();</span></span><br><span class="line"><span class="pattern-match">    m<span class="constructor">Continuation</span> = msg;</span></span><br><span class="line"><span class="pattern-match">    <span class="keyword">if</span> (m<span class="constructor">ContinuationCounter</span> <span class="operator">==</span> 0) &#123;</span></span><br><span class="line"><span class="pattern-match">        msg-&gt;post();</span></span><br><span class="line"><span class="pattern-match">    &#125;</span></span><br><span class="line"><span class="pattern-match">&#125;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">void LiveSession::onChangeConfiguration2(const sp&lt;AMessage&gt; &amp;msg) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    int64_t timeUs;</span><br><span class="line">    CHECK(<span class="function"><span class="title">msg</span>-&gt;</span>findInt64(<span class="string">&quot;timeUs&quot;</span>, &amp;timeUs));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (timeUs &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        mLastSeekTimeUs = timeUs;</span><br><span class="line">        mLastDequeuedTimeUs = timeUs;</span><br><span class="line">        <span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; mPacketSources.size(); i++) &#123;</span><br><span class="line">            sp&lt;AnotherPacketSource&gt; packetSource = mPacketSources.editValueAt(i);</span><br><span class="line">            <span class="function"><span class="title">sp</span>&lt;MetaData&gt; format = packetSource-&gt;</span>getFormat();</span><br><span class="line">            <span class="function"><span class="title">packetSource</span>-&gt;</span>clear();</span><br><span class="line">            <span class="function"><span class="title">packetSource</span>-&gt;</span>setFormat(format);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; kMaxStreams; ++i) &#123;</span><br><span class="line">            mStreams[i].reset();</span><br><span class="line">        &#125;</span><br><span class="line">        mDiscontinuityOffsetTimesUs.clear();</span><br><span class="line">        mDiscontinuityAbsStartTimesUs.clear();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mSeekReplyID != NULL) &#123;</span><br><span class="line">            CHECK(mSeekReply != NULL);</span><br><span class="line">            <span class="function"><span class="title">mSeekReply</span>-&gt;</span>setInt32(<span class="string">&quot;err&quot;</span>, OK);</span><br><span class="line">            <span class="function"><span class="title">mSeekReply</span>-&gt;</span>postReply(mSeekReplyID);</span><br><span class="line">            mSeekReplyID.clear();</span><br><span class="line">            mSeekReply.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        restartPollBuffering();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    uint32_t streamMask, resumeMask;</span><br><span class="line">    CHECK(<span class="function"><span class="title">msg</span>-&gt;</span>findInt32(<span class="string">&quot;streamMask&quot;</span>, (int32_t *)&amp;streamMask));</span><br><span class="line">    CHECK(<span class="function"><span class="title">msg</span>-&gt;</span>findInt32(<span class="string">&quot;resumeMask&quot;</span>, (int32_t *)&amp;resumeMask));</span><br><span class="line"></span><br><span class="line">    streamMask |= resumeMask;</span><br><span class="line"></span><br><span class="line">    AString URIs[kMaxStreams];</span><br><span class="line">    <span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; kMaxStreams; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (streamMask &amp; indexToType(i)) &#123;</span><br><span class="line">            const AString &amp;uriKey = mStreams[i].uriKey();</span><br><span class="line">            CHECK(<span class="function"><span class="title">msg</span>-&gt;</span>findString(uriKey.c_str(), &amp;URIs[i]));</span><br><span class="line">            ALOGV(<span class="string">&quot;%s = &#x27;%s&#x27;&quot;</span>, uriKey.c_str(), URIs[i].c_str());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    uint32_t changedMask = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; kMaxStreams &amp;&amp; i != kSubtitleIndex; ++i) &#123;</span><br><span class="line">        <span class="comment">// stream URI could change even if onChangeConfiguration2 is only</span></span><br><span class="line">        <span class="comment">// used for seek. Seek could happen during a bw switch, in this</span></span><br><span class="line">        <span class="comment">// case bw switch will be cancelled, but the seekTo position will</span></span><br><span class="line">        <span class="comment">// fetch from the new URI.</span></span><br><span class="line">        <span class="keyword">if</span> ((mStreamMask &amp; streamMask &amp; indexToType(i))</span><br><span class="line">                &amp;&amp; !mStreams[i].mUri.empty()</span><br><span class="line">                &amp;&amp; !(URIs[i] == mStreams[i].mUri)) &#123;</span><br><span class="line">            ALOGV(<span class="string">&quot;stream %zu changed: oldURI %s, newURI %s&quot;</span>, i,</span><br><span class="line">                    mStreams[i].mUri.c_str(), URIs[i].c_str());</span><br><span class="line">            sp&lt;AnotherPacketSource&gt; source = mPacketSources.valueFor(indexToType(i));</span><br><span class="line">            <span class="function"><span class="title">if</span> (source-&gt;</span>getLatestDequeuedMeta() != NULL) &#123;</span><br><span class="line">                <span class="function"><span class="title">source</span>-&gt;</span>queueDiscontinuity(ATSParser::DISCONTINUITY_FORMATCHANGE, NULL, <span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Determine which decoders to shutdown on the player side,</span></span><br><span class="line">        <span class="comment">// a decoder has to be shutdown if its streamtype was active</span></span><br><span class="line">        <span class="comment">// before but now longer isn&#x27;t.</span></span><br><span class="line">        <span class="keyword">if</span> ((mStreamMask &amp; ~streamMask &amp; indexToType(i))) &#123;</span><br><span class="line">            changedMask |= indexToType(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//这里会触发kWhatStreamsChanged</span></span><br><span class="line">    <span class="function"><span class="title">sp</span>&lt;AMessage&gt; notify = mNotify-&gt;</span>dup();</span><br><span class="line">    <span class="function"><span class="title">notify</span>-&gt;</span>setInt32(<span class="string">&quot;what&quot;</span>, kWhatStreamsChanged);</span><br><span class="line">    <span class="function"><span class="title">notify</span>-&gt;</span>setInt32(<span class="string">&quot;changedMask&quot;</span>, changedMask);</span><br><span class="line">	<span class="comment">//将kWhatChangeConfiguration3作为回复消息</span></span><br><span class="line">    <span class="function"><span class="title">msg</span>-&gt;</span>setWhat(kWhatChangeConfiguration3);</span><br><span class="line">    <span class="function"><span class="title">msg</span>-&gt;</span>setTarget(this);</span><br><span class="line">    <span class="function"><span class="title">notify</span>-&gt;</span>setMessage(<span class="string">&quot;reply&quot;</span>, msg);</span><br><span class="line">    <span class="function"><span class="title">notify</span>-&gt;</span>post();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">case LiveSession::kWhatStreamsChanged:</span><br><span class="line">&#123;</span><br><span class="line">    uint32_t changedMask;</span><br><span class="line">    <span class="constructor">CHECK(<span class="params">msg</span>-&gt;<span class="params">findInt32</span>(<span class="string">&quot;changedMask&quot;</span>, (<span class="params">int32_t</span> <span class="operator">*</span>)</span>&amp;changedMask));</span><br><span class="line">    <span class="comment">//判断什么流改变</span></span><br><span class="line">    <span class="built_in">bool</span> audio = changedMask &amp; LiveSession::STREAMTYPE_AUDIO;</span><br><span class="line">    <span class="built_in">bool</span> video = changedMask &amp; LiveSession::STREAMTYPE_VIDEO;</span><br><span class="line">    sp&lt;AMessage&gt; reply;</span><br><span class="line">    <span class="constructor">CHECK(<span class="params">msg</span>-&gt;<span class="params">findMessage</span>(<span class="string">&quot;reply&quot;</span>, &amp;<span class="params">reply</span>)</span>);</span><br><span class="line">    sp&lt;AMessage&gt; notify = dup<span class="constructor">Notify()</span>;</span><br><span class="line">    notify-&gt;set<span class="constructor">Int32(<span class="string">&quot;what&quot;</span>, <span class="params">kWhatQueueDecoderShutdown</span>)</span>;</span><br><span class="line">    notify-&gt;set<span class="constructor">Int32(<span class="string">&quot;audio&quot;</span>, <span class="params">audio</span>)</span>;</span><br><span class="line">    notify-&gt;set<span class="constructor">Int32(<span class="string">&quot;video&quot;</span>, <span class="params">video</span>)</span>;</span><br><span class="line">    notify-&gt;set<span class="constructor">Message(<span class="string">&quot;reply&quot;</span>, <span class="params">reply</span>)</span>;</span><br><span class="line">    notify-&gt;post<span class="literal">()</span>;</span><br><span class="line">    break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">case Source::kWhatQueueDecoderShutdown:</span><br><span class="line">&#123;</span><br><span class="line">    int32_t audio, video;</span><br><span class="line">    <span class="constructor">CHECK(<span class="params">msg</span>-&gt;<span class="params">findInt32</span>(<span class="string">&quot;audio&quot;</span>, &amp;<span class="params">audio</span>)</span>);</span><br><span class="line">    <span class="constructor">CHECK(<span class="params">msg</span>-&gt;<span class="params">findInt32</span>(<span class="string">&quot;video&quot;</span>, &amp;<span class="params">video</span>)</span>);</span><br><span class="line">    sp&lt;AMessage&gt; reply;</span><br><span class="line">    <span class="constructor">CHECK(<span class="params">msg</span>-&gt;<span class="params">findMessage</span>(<span class="string">&quot;reply&quot;</span>, &amp;<span class="params">reply</span>)</span>);</span><br><span class="line">    queue<span class="constructor">DecoderShutdown(<span class="params">audio</span>, <span class="params">video</span>, <span class="params">reply</span>)</span>;</span><br><span class="line">    break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title class_">NuPlayer</span>::<span class="title function_ invoke__">queueDecoderShutdown</span>(</span><br><span class="line">        <span class="keyword">bool</span> audio, <span class="keyword">bool</span> video, <span class="keyword">const</span> sp&lt;AMessage&gt; &amp;reply) &#123;</span><br><span class="line">    <span class="title function_ invoke__">ALOGI</span>(<span class="string">&quot;queueDecoderShutdown audio=%d, video=%d&quot;</span>, audio, video);</span><br><span class="line">    mDeferredActions.<span class="title function_ invoke__">push_back</span>(<span class="keyword">new</span> <span class="title class_">FlushDecoderAction</span>(audio ? FLUSH_CMD_SHUTDOWN : FLUSH_CMD_NONE,video ? FLUSH_CMD_SHUTDOWN : FLUSH_CMD_NONE));</span><br><span class="line">    mDeferredActions.<span class="title function_ invoke__">push_back</span>(<span class="keyword">new</span> <span class="title class_">SimpleAction</span>(&amp;<span class="title class_">NuPlayer</span>::<span class="variable constant_">performScanSources</span>));</span><br><span class="line">    mDeferredActions.<span class="title function_ invoke__">push_back</span>(<span class="keyword">new</span> <span class="title class_">PostMessageAction</span>(reply));</span><br><span class="line">    <span class="title function_ invoke__">processDeferredActions</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用performDecoderFlush</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> NuPlayer::FlushDecoderAction : public Action &#123;</span><br><span class="line">    <span class="constructor">FlushDecoderAction(FlushCommand <span class="params">audio</span>, FlushCommand <span class="params">video</span>)</span></span><br><span class="line">        : m<span class="constructor">Audio(<span class="params">audio</span>)</span>,</span><br><span class="line">          m<span class="constructor">Video(<span class="params">video</span>)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> void execute(NuPlayer *player) &#123;</span><br><span class="line">        player-&gt;perform<span class="constructor">DecoderFlush(<span class="params">mAudio</span>, <span class="params">mVideo</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    FlushCommand mAudio;</span><br><span class="line">    FlushCommand mVideo;</span><br><span class="line">    <span class="constructor">DISALLOW_EVIL_CONSTRUCTORS(FlushDecoderAction)</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void NuPlayer::perform<span class="constructor">DecoderFlush(FlushCommand <span class="params">audio</span>, FlushCommand <span class="params">video</span>)</span> &#123;</span><br><span class="line">    <span class="constructor">ALOGV(<span class="string">&quot;performDecoderFlush audio=%d, video=%d&quot;</span>, <span class="params">audio</span>, <span class="params">video</span>)</span>;</span><br><span class="line">    <span class="keyword">if</span> ((audio<span class="operator"> == </span>FLUSH_CMD_NONE<span class="operator"> || </span>mAudioDecoder<span class="operator"> == </span>NULL)&amp;&amp; (video<span class="operator"> == </span>FLUSH_CMD_NONE<span class="operator"> || </span>mVideoDecoder<span class="operator"> == </span>NULL)) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (audio != FLUSH_CMD_NONE<span class="operator"> &amp;&amp; </span>mAudioDecoder != NULL) &#123;</span><br><span class="line">        flush<span class="constructor">Decoder(<span class="params">true</span> <span class="operator">/</span><span class="operator">*</span> <span class="params">audio</span> <span class="operator">*</span><span class="operator">/</span>, (<span class="params">audio</span> <span class="operator">==</span> FLUSH_CMD_SHUTDOWN)</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (video != FLUSH_CMD_NONE<span class="operator"> &amp;&amp; </span>mVideoDecoder != NULL) &#123;</span><br><span class="line">        flush<span class="constructor">Decoder(<span class="params">false</span> <span class="operator">/</span><span class="operator">*</span> <span class="params">audio</span> <span class="operator">*</span><span class="operator">/</span>, (<span class="params">video</span> <span class="operator">==</span> FLUSH_CMD_SHUTDOWN)</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">NuPlayer::flushDecoder</span><span class="params">(<span class="type">bool</span> audio, <span class="type">bool</span> needShutdown)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">ALOGV</span>(<span class="string">&quot;[%s] flushDecoder needShutdown=%d&quot;</span>,</span><br><span class="line">          audio ? <span class="string">&quot;audio&quot;</span> : <span class="string">&quot;video&quot;</span>, needShutdown);</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> sp&lt;DecoderBase&gt; &amp;decoder = <span class="built_in">getDecoder</span>(audio);</span><br><span class="line">    <span class="type">const</span> sp&lt;DecoderBase&gt; &amp;decoder = <span class="built_in">getDecoder</span>(audio);</span><br><span class="line">    <span class="keyword">if</span> (decoder == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">ALOGI</span>(<span class="string">&quot;flushDecoder %s without decoder present&quot;</span>,audio ? <span class="string">&quot;audio&quot;</span> : <span class="string">&quot;video&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...........</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>紧接着我们看下初始化编码器部分：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void NuPlayer::post<span class="constructor">ScanSources()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mScanSourcesPending) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    sp&lt;AMessage&gt; msg = <span class="keyword">new</span> <span class="constructor">AMessage(<span class="params">kWhatScanSources</span>, <span class="params">this</span>)</span>;</span><br><span class="line">    msg-&gt;set<span class="constructor">Int32(<span class="string">&quot;generation&quot;</span>, <span class="params">mScanSourcesGeneration</span>)</span>;</span><br><span class="line">    msg-&gt;post<span class="literal">()</span>;</span><br><span class="line">    mScanSourcesPending = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> kWhatScanSources:</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int32_t</span> generation;</span><br><span class="line"></span><br><span class="line">    mScanSourcesPending = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> mHadAnySourcesBefore =</span><br><span class="line">        (mAudioDecoder != <span class="literal">NULL</span>) || (mVideoDecoder != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// initialize video before audio because successful initialization of</span></span><br><span class="line">    <span class="comment">// video may change deep buffer mode of audio.</span></span><br><span class="line">    <span class="keyword">if</span> (mSurface != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">instantiateDecoder</span>(<span class="literal">false</span>, &amp;mVideoDecoder);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Don&#x27;t try to re-open audio sink if there&#x27;s an existing decoder.</span></span><br><span class="line">    <span class="keyword">if</span> (mAudioSink != <span class="literal">NULL</span> &amp;&amp; mAudioDecoder == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">instantiateDecoder</span>(<span class="literal">true</span>, &amp;mAudioDecoder);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">status_t NuPlayer::instantiate<span class="constructor">Decoder(<span class="params">bool</span> <span class="params">audio</span>, <span class="params">sp</span>&lt;DecoderBase&gt; <span class="operator">*</span><span class="params">decoder</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取格式</span></span><br><span class="line">    sp&lt;AMessage&gt; format = mSource-&gt;get<span class="constructor">Format(<span class="params">audio</span>)</span>;</span><br><span class="line">    format-&gt;set<span class="constructor">Int32(<span class="string">&quot;priority&quot;</span>, 0 <span class="operator">/</span><span class="operator">*</span> <span class="params">realtime</span> <span class="operator">*</span><span class="operator">/</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (audio) &#123;</span><br><span class="line">        sp&lt;AMessage&gt; notify = <span class="keyword">new</span> <span class="constructor">AMessage(<span class="params">kWhatAudioNotify</span>, <span class="params">this</span>)</span>;</span><br><span class="line">        ++mAudioDecoderGeneration;</span><br><span class="line">        notify-&gt;set<span class="constructor">Int32(<span class="string">&quot;generation&quot;</span>, <span class="params">mAudioDecoderGeneration</span>)</span>;</span><br><span class="line">        determine<span class="constructor">AudioModeChange()</span>;</span><br><span class="line">        <span class="keyword">if</span> (mOffloadAudio) &#123;</span><br><span class="line">          <span class="comment">//....................</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            *decoder = <span class="keyword">new</span> <span class="constructor">Decoder(<span class="params">notify</span>, <span class="params">mSource</span>, <span class="params">mPID</span>, <span class="params">mRenderer</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        sp&lt;AMessage&gt; notify = <span class="keyword">new</span> <span class="constructor">AMessage(<span class="params">kWhatVideoNotify</span>, <span class="params">this</span>)</span>;</span><br><span class="line">        ++mVideoDecoderGeneration;</span><br><span class="line">        notify-&gt;set<span class="constructor">Int32(<span class="string">&quot;generation&quot;</span>, <span class="params">mVideoDecoderGeneration</span>)</span>;</span><br><span class="line">        *decoder = <span class="keyword">new</span> <span class="constructor">Decoder(<span class="params">notify</span>, <span class="params">mSource</span>, <span class="params">mPID</span>, <span class="params">mRenderer</span>, <span class="params">mSurface</span>, <span class="params">mCCDecoder</span>)</span>;</span><br><span class="line">        <span class="comment">//...........................</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//解码器初始化</span></span><br><span class="line">    (*decoder)-&gt;init<span class="literal">()</span>;</span><br><span class="line">    <span class="comment">//配置解码器</span></span><br><span class="line">    (*decoder)-&gt;configure(format);</span><br><span class="line">    <span class="comment">//.........</span></span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里创建出解码器并初始化它。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void NuPlayer::DecoderBase::configure(const sp&lt;AMessage&gt; &amp;format) &#123;</span><br><span class="line">    sp&lt;AMessage&gt; msg = <span class="keyword">new</span> <span class="constructor">AMessage(<span class="params">kWhatConfigure</span>, <span class="params">this</span>)</span>;</span><br><span class="line">    msg-&gt;set<span class="constructor">Message(<span class="string">&quot;format&quot;</span>, <span class="params">format</span>)</span>;</span><br><span class="line">    msg-&gt;post<span class="literal">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void NuPlayer::DecoderBase::init<span class="literal">()</span> &#123;</span><br><span class="line">    mDecoderLooper-&gt;register<span class="constructor">Handler(<span class="params">this</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void NuPlayer::Decoder::on<span class="constructor">Configure(<span class="params">const</span> <span class="params">sp</span>&lt;AMessage&gt; &amp;<span class="params">format</span>)</span> &#123;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//创建MediaCodec</span></span><br><span class="line">    mCodec = MediaCodec::<span class="constructor">CreateByType(<span class="params">mCodecLooper</span>, <span class="params">mime</span>.<span class="params">c_str</span>()</span>, <span class="literal">false</span> <span class="comment">/* encoder */</span>, NULL <span class="comment">/* err */</span>, mPid);</span><br><span class="line">    <span class="comment">//配置MediaCodec</span></span><br><span class="line">    err = mCodec-&gt;configure(format, mSurface, NULL <span class="comment">/* crypto */</span>, <span class="number">0</span> <span class="comment">/* flags */</span>);</span><br><span class="line">    <span class="comment">//如果是视频文件则设置宽高</span></span><br><span class="line">    <span class="keyword">if</span> (!mIsAudio) &#123;</span><br><span class="line">        int32_t width, height;</span><br><span class="line">        <span class="keyword">if</span> (mOutputFormat-&gt;find<span class="constructor">Int32(<span class="string">&quot;width&quot;</span>, &amp;<span class="params">width</span>)</span>&amp;&amp; mOutputFormat-&gt;find<span class="constructor">Int32(<span class="string">&quot;height&quot;</span>, &amp;<span class="params">height</span>)</span>) &#123;</span><br><span class="line">            mStats-&gt;set<span class="constructor">Int32(<span class="string">&quot;width&quot;</span>, <span class="params">width</span>)</span>;</span><br><span class="line">            mStats-&gt;set<span class="constructor">Int32(<span class="string">&quot;height&quot;</span>, <span class="params">height</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//启动MediaCodec</span></span><br><span class="line">    err = mCodec-&gt;start<span class="literal">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">sp&lt;MediaCodec&gt; MediaCodec::<span class="constructor">CreateByType(<span class="params">const</span> <span class="params">sp</span>&lt;ALooper&gt; &amp;<span class="params">looper</span>, <span class="params">const</span> <span class="params">char</span> <span class="operator">*</span><span class="params">mime</span>, <span class="params">bool</span> <span class="params">encoder</span>, <span class="params">status_t</span> <span class="operator">*</span><span class="params">err</span>, <span class="params">pid_t</span> <span class="params">pid</span>)</span> &#123;</span><br><span class="line">    sp&lt;MediaCodec&gt; codec = <span class="keyword">new</span> <span class="constructor">MediaCodec(<span class="params">looper</span>, <span class="params">pid</span>)</span>;</span><br><span class="line">    const status_t ret = codec-&gt;init(mime, <span class="literal">true</span> <span class="comment">/* nameIsType */</span>, encoder);</span><br><span class="line">    return ret<span class="operator"> == </span>OK ? codec : NULL; <span class="comment">// NULL deallocates codec.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里说明mCodec是一个ACodec对象</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">status_t MediaCodec::init(const AString &amp;name, <span class="built_in">bool</span> nameIsType, <span class="built_in">bool</span> encoder) &#123;</span><br><span class="line">    mResourceManagerService-&gt;init<span class="literal">()</span>;</span><br><span class="line">    <span class="keyword">if</span> (nameIsType<span class="operator"> || </span>!strncasecmp(name.c<span class="constructor">_str()</span>, <span class="string">&quot;omx.&quot;</span>, <span class="number">4</span>)) &#123;</span><br><span class="line">        <span class="comment">//根据名称创建Codec</span></span><br><span class="line">        mCodec = <span class="keyword">new</span> ACodec;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!nameIsType&amp;&amp; !strncasecmp(name.c<span class="constructor">_str()</span>, <span class="string">&quot;android.filter.&quot;</span>, <span class="number">15</span>)) &#123;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    sp&lt;AMessage&gt; msg = <span class="keyword">new</span> <span class="constructor">AMessage(<span class="params">kWhatInit</span>, <span class="params">this</span>)</span>;</span><br><span class="line">    msg-&gt;set<span class="constructor">String(<span class="string">&quot;name&quot;</span>, <span class="params">name</span>)</span>;</span><br><span class="line">    msg-&gt;set<span class="constructor">Int32(<span class="string">&quot;nameIsType&quot;</span>, <span class="params">nameIsType</span>)</span>;</span><br><span class="line">    <span class="keyword">if</span> (nameIsType) &#123;</span><br><span class="line">        msg-&gt;set<span class="constructor">Int32(<span class="string">&quot;encoder&quot;</span>, <span class="params">encoder</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    return err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight mel"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> kWhatInit:</span><br><span class="line">&#123;</span><br><span class="line">   	<span class="comment">//....................</span></span><br><span class="line">    mCodec-&gt;initiateAllocateComponent(<span class="keyword">format</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void ACodec::initiate<span class="constructor">AllocateComponent(<span class="params">const</span> <span class="params">sp</span>&lt;AMessage&gt; &amp;<span class="params">msg</span>)</span> &#123;</span><br><span class="line">    msg-&gt;set<span class="constructor">What(<span class="params">kWhatAllocateComponent</span>)</span>;</span><br><span class="line">    msg-&gt;set<span class="constructor">Target(<span class="params">this</span>)</span>;</span><br><span class="line">    msg-&gt;post<span class="literal">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> ACodec::kWhatAllocateComponent:</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">onAllocateComponent</span>(msg);</span><br><span class="line">    handled = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里开始实例化编码器并设置状态</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">bool ACodec::UninitializedState::onAllocateComponent(const sp&lt;AMessage&gt; &amp;msg) &#123;</span><br><span class="line">    </span><br><span class="line">    Vector&lt;OMXCodec::CodecNameAndQuirks&gt; matchingCodecs;</span><br><span class="line">    AString mime;</span><br><span class="line">    AString componentName;</span><br><span class="line">    uint32_t quirks = <span class="number">0</span>;</span><br><span class="line">    int32_t encoder = <span class="literal">false</span>;</span><br><span class="line">    <span class="function"><span class="title">if</span> (msg-&gt;</span>findString(<span class="string">&quot;componentName&quot;</span>, &amp;componentName)) &#123;</span><br><span class="line">        ssize_t index = matchingCodecs.add();</span><br><span class="line">        OMXCodec::CodecNameAndQuirks *entry = &amp;matchingCodecs.editItemAt(index);</span><br><span class="line">        <span class="function"><span class="title">entry</span>-&gt;</span>mName = String8(componentName.c_str());</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">if</span> (!OMXCodec::findCodecQuirks(componentName.c_str(), &amp;entry-&gt;</span>mQuirks)) &#123;</span><br><span class="line">            <span class="function"><span class="title">entry</span>-&gt;</span>mQuirks = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        CHECK(<span class="function"><span class="title">msg</span>-&gt;</span>findString(<span class="string">&quot;mime&quot;</span>, &amp;mime));</span><br><span class="line">        <span class="function"><span class="title">if</span> (!msg-&gt;</span>findInt32(<span class="string">&quot;encoder&quot;</span>, &amp;encoder)) &#123;</span><br><span class="line">            encoder = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        OMXCodec::findMatchingCodecs(</span><br><span class="line">                mime.c_str(),</span><br><span class="line">                encoder, <span class="comment">// createEncoder</span></span><br><span class="line">                NULL,  <span class="comment">// matchComponentName</span></span><br><span class="line">                <span class="number">0</span>,     <span class="comment">// flags</span></span><br><span class="line">                &amp;matchingCodecs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sp&lt;CodecObserver&gt; observer = new CodecObserver;</span><br><span class="line">    IOMX::node_id node = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    status_t err = NAME_NOT_FOUND;</span><br><span class="line">    <span class="keyword">for</span> (size_t matchIndex = <span class="number">0</span>; matchIndex &lt; matchingCodecs.size();++matchIndex) &#123;</span><br><span class="line">        componentName = matchingCodecs.itemAt(matchIndex).mName.string();</span><br><span class="line">        quirks = matchingCodecs.itemAt(matchIndex).mQuirks;</span><br><span class="line"></span><br><span class="line">        pid_t tid = gettid();</span><br><span class="line">        int prevPriority = androidGetThreadPriority(tid);</span><br><span class="line">        androidSetThreadPriority(tid, ANDROID_PRIORITY_FOREGROUND);</span><br><span class="line">        <span class="function"><span class="title">err</span> = omx-&gt;</span>allocateNode(componentName.c_str(), observer, &amp;node);</span><br><span class="line">        androidSetThreadPriority(tid, prevPriority);</span><br><span class="line">        node = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    notify = new AMessage(kWhatOMXMessageList, mCodec);</span><br><span class="line">    <span class="function"><span class="title">observer</span>-&gt;</span>setNotificationMessage(notify);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">mCodec</span>-&gt;</span>mComponentName = componentName;</span><br><span class="line">    <span class="function"><span class="title">mCodec</span>-&gt;</span>mRenderTracker.setComponentName(componentName);</span><br><span class="line">    <span class="function"><span class="title">mCodec</span>-&gt;</span>mFlags = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="title">mCodec</span>-&gt;</span>mQuirks = quirks;</span><br><span class="line">    <span class="function"><span class="title">mCodec</span>-&gt;</span>mOMX = omx;</span><br><span class="line">    <span class="function"><span class="title">mCodec</span>-&gt;</span>mNode = node;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="title">sp</span>&lt;AMessage&gt; notify = mCodec-&gt;</span><span class="function"><span class="title">mNotify</span>-&gt;</span>dup();</span><br><span class="line">        <span class="function"><span class="title">notify</span>-&gt;</span>setInt32(<span class="string">&quot;what&quot;</span>, CodecBase::kWhatComponentAllocated);</span><br><span class="line">        <span class="function"><span class="title">notify</span>-&gt;</span><span class="function"><span class="title">setString</span>(&quot;componentName&quot;, mCodec-&gt;</span>mComponentName.c_str());</span><br><span class="line">        <span class="function"><span class="title">notify</span>-&gt;</span>post();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">mCodec</span>-&gt;</span><span class="function"><span class="title">changeState</span>(mCodec-&gt;</span>mLoadedState);</span><br><span class="line">    return <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解码器的配置</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">status_t MediaCodec::configure(</span><br><span class="line">        const sp&lt;AMessage&gt; &amp;format,</span><br><span class="line">        const sp&lt;Surface&gt; &amp;surface,</span><br><span class="line">        const sp&lt;ICrypto&gt; &amp;crypto,</span><br><span class="line">        uint32_t flags) &#123;</span><br><span class="line">    sp&lt;AMessage&gt; msg = <span class="keyword">new</span> <span class="constructor">AMessage(<span class="params">kWhatConfigure</span>, <span class="params">this</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mIsVideo) &#123;</span><br><span class="line">        format-&gt;find<span class="constructor">Int32(<span class="string">&quot;width&quot;</span>, &amp;<span class="params">mVideoWidth</span>)</span>;</span><br><span class="line">        format-&gt;find<span class="constructor">Int32(<span class="string">&quot;height&quot;</span>, &amp;<span class="params">mVideoHeight</span>)</span>;</span><br><span class="line">        <span class="keyword">if</span> (!format-&gt;find<span class="constructor">Int32(<span class="string">&quot;rotation-degrees&quot;</span>, &amp;<span class="params">mRotationDegrees</span>)</span>) &#123;</span><br><span class="line">            mRotationDegrees = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    msg-&gt;set<span class="constructor">Message(<span class="string">&quot;format&quot;</span>, <span class="params">format</span>)</span>;</span><br><span class="line">    msg-&gt;set<span class="constructor">Int32(<span class="string">&quot;flags&quot;</span>, <span class="params">flags</span>)</span>;</span><br><span class="line">    msg-&gt;set<span class="constructor">Object(<span class="string">&quot;surface&quot;</span>, <span class="params">surface</span>)</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//.....................</span></span><br><span class="line">    <span class="comment">// save msg for reset</span></span><br><span class="line">    mConfigureMsg = msg;</span><br><span class="line">	<span class="comment">//.....................</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt;= kMaxRetry; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// Don&#x27;t try to reclaim resource for the first time.</span></span><br><span class="line">            <span class="keyword">if</span> (!mResourceManagerService-&gt;reclaim<span class="constructor">Resource(<span class="params">resources</span>)</span>) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sp&lt;AMessage&gt; response;</span><br><span class="line">        err = <span class="constructor">PostAndAwaitResponse(<span class="params">msg</span>, &amp;<span class="params">response</span>)</span>;</span><br><span class="line">        <span class="comment">//.....................</span></span><br><span class="line">    &#125;</span><br><span class="line">    return err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">case kWhatConfigure:</span><br><span class="line">&#123;</span><br><span class="line">    sp&lt;AReplyToken&gt; replyID;</span><br><span class="line">    <span class="constructor">CHECK(<span class="params">msg</span>-&gt;<span class="params">senderAwaitsResponse</span>(&amp;<span class="params">replyID</span>)</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    sp&lt;RefBase&gt; obj;</span><br><span class="line">    <span class="constructor">CHECK(<span class="params">msg</span>-&gt;<span class="params">findObject</span>(<span class="string">&quot;surface&quot;</span>, &amp;<span class="params">obj</span>)</span>);</span><br><span class="line"></span><br><span class="line">    sp&lt;AMessage&gt; format;</span><br><span class="line">    <span class="constructor">CHECK(<span class="params">msg</span>-&gt;<span class="params">findMessage</span>(<span class="string">&quot;format&quot;</span>, &amp;<span class="params">format</span>)</span>);</span><br><span class="line"></span><br><span class="line">    int32_t push;</span><br><span class="line">    <span class="keyword">if</span> (msg-&gt;find<span class="constructor">Int32(<span class="string">&quot;push-blank-buffers-on-shutdown&quot;</span>, &amp;<span class="params">push</span>)</span><span class="operator"> &amp;&amp; </span>push != <span class="number">0</span>) &#123;</span><br><span class="line">        mFlags <span class="pattern-match">|= k<span class="constructor">FlagPushBlankBuffersOnShutdown</span>;</span></span><br><span class="line"><span class="pattern-match">    &#125;</span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match">    <span class="keyword">if</span> (obj != <span class="constructor">NULL</span>) &#123;</span></span><br><span class="line"><span class="pattern-match">        format-&gt;set<span class="constructor">Object(<span class="string">&quot;native-window&quot;</span>, <span class="params">obj</span>)</span>;</span></span><br><span class="line"><span class="pattern-match">        status<span class="constructor">_t</span> err = handle<span class="constructor">SetSurface(<span class="params">static_cast</span>&lt;Surface <span class="operator">*</span>&gt;(<span class="params">obj</span>.<span class="params">get</span>()</span>));</span></span><br><span class="line"><span class="pattern-match">        <span class="keyword">if</span> (err != <span class="constructor">OK</span>) &#123;</span></span><br><span class="line"><span class="pattern-match">            <span class="constructor">PostReplyWithError(<span class="params">replyID</span>, <span class="params">err</span>)</span>;</span></span><br><span class="line"><span class="pattern-match">            break;</span></span><br><span class="line"><span class="pattern-match">        &#125;</span></span><br><span class="line"><span class="pattern-match">    &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="pattern-match">        handle<span class="constructor">SetSurface(NULL)</span>;</span></span><br><span class="line"><span class="pattern-match">    &#125;</span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match">    m<span class="constructor">ReplyID</span> = reply<span class="constructor">ID</span>;</span></span><br><span class="line"><span class="pattern-match">    set<span class="constructor">State(CONFIGURING)</span>;</span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match">    void <span class="operator">*</span>crypto;</span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match">    uint32<span class="constructor">_t</span> flags;</span></span><br><span class="line"><span class="pattern-match">    <span class="constructor">CHECK(<span class="params">msg</span>-&gt;<span class="params">findInt32</span>(<span class="string">&quot;flags&quot;</span>, (<span class="params">int32_t</span> <span class="operator">*</span>)</span>&amp;flags));</span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match">    <span class="keyword">if</span> (flags &amp; <span class="constructor">CONFIGURE_FLAG_ENCODE</span>) &#123;</span></span><br><span class="line"><span class="pattern-match">        format-&gt;set<span class="constructor">Int32(<span class="string">&quot;encoder&quot;</span>, <span class="params">true</span>)</span>;</span></span><br><span class="line"><span class="pattern-match">        m<span class="constructor">Flags</span> |= k<span class="constructor">FlagIsEncoder</span>;</span></span><br><span class="line"><span class="pattern-match">    &#125;</span></span><br><span class="line"><span class="pattern-match">	<span class="operator">/</span><span class="operator">/</span>这里最重要</span></span><br><span class="line"><span class="pattern-match">    m<span class="constructor">Codec</span>-&gt;initiate<span class="constructor">ConfigureComponent(<span class="params">format</span>)</span>;</span></span><br><span class="line"><span class="pattern-match">    break;</span></span><br><span class="line"><span class="pattern-match">&#125;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void ACodec::initiate<span class="constructor">ConfigureComponent(<span class="params">const</span> <span class="params">sp</span>&lt;AMessage&gt; &amp;<span class="params">msg</span>)</span> &#123;</span><br><span class="line">    msg-&gt;set<span class="constructor">What(<span class="params">kWhatConfigureComponent</span>)</span>;</span><br><span class="line">    msg-&gt;set<span class="constructor">Target(<span class="params">this</span>)</span>;</span><br><span class="line">    msg-&gt;post<span class="literal">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> ACodec::kWhatConfigureComponent:</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">onConfigureComponent</span>(msg);</span><br><span class="line">    handled = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">bool ACodec::LoadedState::onConfigureComponent(</span><br><span class="line">        const sp&lt;AMessage&gt; &amp;msg) &#123;</span><br><span class="line">    ALOGV(<span class="string">&quot;onConfigureComponent&quot;</span>);</span><br><span class="line"></span><br><span class="line">    CHECK(<span class="function"><span class="title">mCodec</span>-&gt;</span>mNode != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    status_t err = OK;</span><br><span class="line">    AString mime;</span><br><span class="line">    <span class="function"><span class="title">if</span> (!msg-&gt;</span>findString(<span class="string">&quot;mime&quot;</span>, &amp;mime)) &#123;</span><br><span class="line">        err = BAD_VALUE;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="function"><span class="title">err</span> = mCodec-&gt;</span>configureCodec(mime.c_str(), msg);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="title">sp</span>&lt;AMessage&gt; notify = mCodec-&gt;</span><span class="function"><span class="title">mNotify</span>-&gt;</span>dup();</span><br><span class="line">        <span class="function"><span class="title">notify</span>-&gt;</span>setInt32(<span class="string">&quot;what&quot;</span>, CodecBase::kWhatComponentConfigured);</span><br><span class="line">        <span class="function"><span class="title">notify</span>-&gt;</span><span class="function"><span class="title">setMessage</span>(&quot;input-format&quot;, mCodec-&gt;</span>mInputFormat);</span><br><span class="line">        <span class="function"><span class="title">notify</span>-&gt;</span><span class="function"><span class="title">setMessage</span>(&quot;output-format&quot;, mCodec-&gt;</span>mOutputFormat);</span><br><span class="line">        <span class="function"><span class="title">notify</span>-&gt;</span>post();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">case CodecBase::kWhatComponentConfigured:</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (mState<span class="operator"> == </span>UNINITIALIZED<span class="operator"> || </span>mState<span class="operator"> == </span>INITIALIZED) &#123;</span><br><span class="line">        <span class="comment">// In case a kWhatError message came in and replied with error,</span></span><br><span class="line">        <span class="comment">// we log a warning and ignore.</span></span><br><span class="line">        <span class="constructor">ALOGW(<span class="string">&quot;configure interrupted by error, current state %d&quot;</span>, <span class="params">mState</span>)</span>;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="constructor">CHECK_EQ(<span class="params">mState</span>, CONFIGURING)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// reset input surface flag</span></span><br><span class="line">    mHaveInputSurface = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="constructor">CHECK(<span class="params">msg</span>-&gt;<span class="params">findMessage</span>(<span class="string">&quot;input-format&quot;</span>, &amp;<span class="params">mInputFormat</span>)</span>);</span><br><span class="line">    <span class="constructor">CHECK(<span class="params">msg</span>-&gt;<span class="params">findMessage</span>(<span class="string">&quot;output-format&quot;</span>, &amp;<span class="params">mOutputFormat</span>)</span>);</span><br><span class="line"></span><br><span class="line">    int32_t usingSwRenderer;</span><br><span class="line">    <span class="keyword">if</span> (mOutputFormat-&gt;find<span class="constructor">Int32(<span class="string">&quot;using-sw-renderer&quot;</span>, &amp;<span class="params">usingSwRenderer</span>)</span><span class="operator"></span></span><br><span class="line"><span class="operator">            &amp;&amp; </span>usingSwRenderer) &#123;</span><br><span class="line">        mFlags <span class="pattern-match">|= k<span class="constructor">FlagUsesSoftwareRenderer</span>;</span></span><br><span class="line"><span class="pattern-match">    &#125;</span></span><br><span class="line"><span class="pattern-match">    set<span class="constructor">State(CONFIGURED)</span>;</span></span><br><span class="line"><span class="pattern-match">    (<span class="keyword">new</span> <span class="constructor">AMessage</span>)-&gt;post<span class="constructor">Reply(<span class="params">mReplyID</span>)</span>;</span></span><br><span class="line"><span class="pattern-match">    break;</span></span><br><span class="line"><span class="pattern-match">&#125;</span></span><br></pre></td></tr></table></figure>
<p>这里才是解码器最详细的配置，有时间好好针对这个展开研究，这篇博客先针对整个流程进行分析：</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">status_t ACodec::configureCodec(</span><br><span class="line">        const char *mime, const sp&lt;AMessage&gt; &amp;msg) &#123;</span><br><span class="line">    int32_t encoder;</span><br><span class="line">    <span class="function"><span class="title">if</span> (!msg-&gt;</span>findInt32(<span class="string">&quot;encoder&quot;</span>, &amp;encoder)) &#123;</span><br><span class="line">        encoder = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sp&lt;AMessage&gt; inputFormat = new AMessage();</span><br><span class="line">    <span class="function"><span class="title">sp</span>&lt;AMessage&gt; outputFormat = mNotify-&gt;</span>dup(); <span class="comment">// will use this for kWhatOutputFormatChanged</span></span><br><span class="line"></span><br><span class="line">    mIsEncoder = encoder;</span><br><span class="line"></span><br><span class="line">    mInputMetadataType = kMetadataBufferTypeInvalid;</span><br><span class="line">    mOutputMetadataType = kMetadataBufferTypeInvalid;</span><br><span class="line"></span><br><span class="line">    status_t err = setComponentRole(encoder <span class="comment">/* isEncoder */</span>, mime);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err != OK) &#123;</span><br><span class="line">        return err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int32_t bitRate = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// FLAC encoder doesn&#x27;t need a bitrate, other encoders do</span></span><br><span class="line">    <span class="keyword">if</span> (encoder &amp;&amp; strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_FLAC)</span><br><span class="line">            &amp;&amp; !<span class="function"><span class="title">msg</span>-&gt;</span>findInt32(<span class="string">&quot;bitrate&quot;</span>, &amp;bitRate)) &#123;</span><br><span class="line">        return INVALID_OPERATION;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int32_t storeMeta;</span><br><span class="line">    <span class="keyword">if</span> (encoder</span><br><span class="line">            &amp;&amp; <span class="function"><span class="title">msg</span>-&gt;</span>findInt32(<span class="string">&quot;store-metadata-in-buffers&quot;</span>, &amp;storeMeta)</span><br><span class="line">            &amp;&amp; storeMeta != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="function"><span class="title">err</span> = mOMX-&gt;</span>storeMetaDataInBuffers(mNode, kPortIndexInput, OMX_TRUE, &amp;mInputMetadataType);</span><br><span class="line">        <span class="keyword">if</span> (err != OK) &#123;</span><br><span class="line">            ALOGE(<span class="string">&quot;[%s] storeMetaDataInBuffers (input) failed w/ err %d&quot;</span>,</span><br><span class="line">                    mComponentName.c_str(), err);</span><br><span class="line"></span><br><span class="line">            return err;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// For this specific case we could be using camera source even if storeMetaDataInBuffers</span></span><br><span class="line">        <span class="comment">// returns Gralloc source. Pretend that we are; this will force us to use nBufferSize.</span></span><br><span class="line">        <span class="keyword">if</span> (mInputMetadataType == kMetadataBufferTypeGrallocSource) &#123;</span><br><span class="line">            mInputMetadataType = kMetadataBufferTypeCameraSource;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        uint32_t usageBits;</span><br><span class="line">        <span class="function"><span class="title">if</span> (mOMX-&gt;</span>getParameter(</span><br><span class="line">                mNode, (OMX_INDEXTYPE)OMX_IndexParamConsumerUsageBits,</span><br><span class="line">                &amp;usageBits, sizeof(usageBits)) == OK) &#123;</span><br><span class="line">            <span class="function"><span class="title">inputFormat</span>-&gt;</span>setInt32(</span><br><span class="line">                    <span class="string">&quot;using-sw-read-often&quot;</span>, !!(usageBits &amp; GRALLOC_USAGE_SW_READ_OFTEN));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int32_t prependSPSPPS = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (encoder</span><br><span class="line">            &amp;&amp; <span class="function"><span class="title">msg</span>-&gt;</span>findInt32(<span class="string">&quot;prepend-sps-pps-to-idr-frames&quot;</span>, &amp;prependSPSPPS)</span><br><span class="line">            &amp;&amp; prependSPSPPS != <span class="number">0</span>) &#123;</span><br><span class="line">        OMX_INDEXTYPE index;</span><br><span class="line">        <span class="function"><span class="title">err</span> = mOMX-&gt;</span>getExtensionIndex(</span><br><span class="line">                mNode,</span><br><span class="line">                <span class="string">&quot;OMX.google.android.index.prependSPSPPSToIDRFrames&quot;</span>,</span><br><span class="line">                &amp;index);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (err == OK) &#123;</span><br><span class="line">            PrependSPSPPSToIDRFramesParams params;</span><br><span class="line">            InitOMXParams(&amp;params);</span><br><span class="line">            params.bEnable = OMX_TRUE;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="title">err</span> = mOMX-&gt;</span>setParameter(</span><br><span class="line">                    mNode, index, &amp;params, sizeof(params));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (err != OK) &#123;</span><br><span class="line">            ALOGE(<span class="string">&quot;Encoder could not be configured to emit SPS/PPS before &quot;</span></span><br><span class="line">                  <span class="string">&quot;IDR frames. (err %d)&quot;</span>, err);</span><br><span class="line"></span><br><span class="line">            return err;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Only enable metadata mode on encoder output if encoder can prepend</span></span><br><span class="line">    <span class="comment">// sps/pps to idr frames, since in metadata mode the bitstream is in an</span></span><br><span class="line">    <span class="comment">// opaque handle, to which we don&#x27;t have access.</span></span><br><span class="line">    int32_t video = !strncasecmp(mime, <span class="string">&quot;video/&quot;</span>, <span class="number">6</span>);</span><br><span class="line">    mIsVideo = video;</span><br><span class="line">    <span class="keyword">if</span> (encoder &amp;&amp; video) &#123;</span><br><span class="line">        OMX_BOOL enable = (OMX_BOOL) (prependSPSPPS</span><br><span class="line">            &amp;&amp; <span class="function"><span class="title">msg</span>-&gt;</span>findInt32(<span class="string">&quot;store-metadata-in-buffers-output&quot;</span>, &amp;storeMeta)</span><br><span class="line">            &amp;&amp; storeMeta != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">err</span> = mOMX-&gt;</span>storeMetaDataInBuffers(mNode, kPortIndexOutput, enable, &amp;mOutputMetadataType);</span><br><span class="line">        <span class="keyword">if</span> (err != OK) &#123;</span><br><span class="line">            ALOGE(<span class="string">&quot;[%s] storeMetaDataInBuffers (output) failed w/ err %d&quot;</span>,</span><br><span class="line">                mComponentName.c_str(), err);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">if</span> (!msg-&gt;</span>findInt64(</span><br><span class="line">                    <span class="string">&quot;repeat-previous-frame-after&quot;</span>,</span><br><span class="line">                    &amp;mRepeatFrameDelayUs)) &#123;</span><br><span class="line">            mRepeatFrameDelayUs = -<span class="number">1</span>ll;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">if</span> (!msg-&gt;</span>findInt64(<span class="string">&quot;max-pts-gap-to-encoder&quot;</span>, &amp;mMaxPtsGapUs)) &#123;</span><br><span class="line">            mMaxPtsGapUs = -<span class="number">1</span>ll;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">if</span> (!msg-&gt;</span>findFloat(<span class="string">&quot;max-fps-to-encoder&quot;</span>, &amp;mMaxFps)) &#123;</span><br><span class="line">            mMaxFps = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">if</span> (!msg-&gt;</span>findInt64(<span class="string">&quot;time-lapse&quot;</span>, &amp;mTimePerCaptureUs)) &#123;</span><br><span class="line">            mTimePerCaptureUs = -<span class="number">1</span>ll;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">if</span> (!msg-&gt;</span>findInt32(</span><br><span class="line">                    <span class="string">&quot;create-input-buffers-suspended&quot;</span>,</span><br><span class="line">                    (int32_t*)&amp;mCreateInputBuffersSuspended)) &#123;</span><br><span class="line">            mCreateInputBuffersSuspended = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> we only use native window for video decoders</span></span><br><span class="line">    sp&lt;RefBase&gt; obj;</span><br><span class="line">    <span class="function"><span class="title">bool</span> haveNativeWindow = msg-&gt;</span>findObject(<span class="string">&quot;native-window&quot;</span>, &amp;obj)</span><br><span class="line">            &amp;&amp; obj != NULL &amp;&amp; video &amp;&amp; !encoder;</span><br><span class="line">    mLegacyAdaptiveExperiment = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (video &amp;&amp; !encoder) &#123;</span><br><span class="line">        <span class="function"><span class="title">inputFormat</span>-&gt;</span>setInt32(<span class="string">&quot;adaptive-playback&quot;</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        int32_t usageProtected;</span><br><span class="line">        <span class="function"><span class="title">if</span> (msg-&gt;</span>findInt32(<span class="string">&quot;protected&quot;</span>, &amp;usageProtected) &amp;&amp; usageProtected) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!haveNativeWindow) &#123;</span><br><span class="line">                ALOGE(<span class="string">&quot;protected output buffers must be sent to an ANativeWindow&quot;</span>);</span><br><span class="line">                return PERMISSION_DENIED;</span><br><span class="line">            &#125;</span><br><span class="line">            mFlags |= kFlagIsGrallocUsageProtected;</span><br><span class="line">            mFlags |= kFlagPushBlankBuffersToNativeWindowOnShutdown;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (haveNativeWindow) &#123;</span><br><span class="line">        sp&lt;ANativeWindow&gt; nativeWindow =</span><br><span class="line">            static_cast&lt;ANativeWindow *&gt;(static_cast&lt;Surface *&gt;(obj.get()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// START of temporary support for automatic FRC - THIS WILL BE REMOVED</span></span><br><span class="line">        int32_t autoFrc;</span><br><span class="line">        <span class="function"><span class="title">if</span> (msg-&gt;</span>findInt32(<span class="string">&quot;auto-frc&quot;</span>, &amp;autoFrc)) &#123;</span><br><span class="line">            bool enabled = autoFrc;</span><br><span class="line">            OMX_CONFIG_BOOLEANTYPE config;</span><br><span class="line">            InitOMXParams(&amp;config);</span><br><span class="line">            config.bEnabled = (OMX_BOOL)enabled;</span><br><span class="line">            <span class="function"><span class="title">status_t</span> temp = mOMX-&gt;</span>setConfig(</span><br><span class="line">                    mNode, (OMX_INDEXTYPE)OMX_IndexConfigAutoFramerateConversion,</span><br><span class="line">                    &amp;config, sizeof(config));</span><br><span class="line">            <span class="keyword">if</span> (temp == OK) &#123;</span><br><span class="line">                <span class="function"><span class="title">outputFormat</span>-&gt;</span>setInt32(<span class="string">&quot;auto-frc&quot;</span>, enabled);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (enabled) &#123;</span><br><span class="line">                ALOGI(<span class="string">&quot;codec does not support requested auto-frc (err %d)&quot;</span>, temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// END of temporary support for automatic FRC</span></span><br><span class="line"></span><br><span class="line">        int32_t tunneled;</span><br><span class="line">        <span class="function"><span class="title">if</span> (msg-&gt;</span>findInt32(<span class="string">&quot;feature-tunneled-playback&quot;</span>, &amp;tunneled) &amp;&amp;</span><br><span class="line">            tunneled != <span class="number">0</span>) &#123;</span><br><span class="line">            ALOGI(<span class="string">&quot;Configuring TUNNELED video playback.&quot;</span>);</span><br><span class="line">            mTunneled = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            int32_t audioHwSync = <span class="number">0</span>;</span><br><span class="line">            <span class="function"><span class="title">if</span> (!msg-&gt;</span>findInt32(<span class="string">&quot;audio-hw-sync&quot;</span>, &amp;audioHwSync)) &#123;</span><br><span class="line">                ALOGW(<span class="string">&quot;No Audio HW Sync provided for video tunnel&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            err = configureTunneledVideoPlayback(audioHwSync, nativeWindow);</span><br><span class="line">            <span class="keyword">if</span> (err != OK) &#123;</span><br><span class="line">                ALOGE(<span class="string">&quot;configureTunneledVideoPlayback(%d,%p) failed!&quot;</span>,</span><br><span class="line">                        audioHwSync, nativeWindow.get());</span><br><span class="line">                return err;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            int32_t maxWidth = <span class="number">0</span>, maxHeight = <span class="number">0</span>;</span><br><span class="line">            <span class="function"><span class="title">if</span> (msg-&gt;</span>findInt32(<span class="string">&quot;max-width&quot;</span>, &amp;maxWidth) &amp;&amp;</span><br><span class="line">                    <span class="function"><span class="title">msg</span>-&gt;</span>findInt32(<span class="string">&quot;max-height&quot;</span>, &amp;maxHeight)) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="function"><span class="title">err</span> = mOMX-&gt;</span>prepareForAdaptivePlayback(</span><br><span class="line">                        mNode, kPortIndexOutput, OMX_TRUE, maxWidth, maxHeight);</span><br><span class="line">                <span class="keyword">if</span> (err != OK) &#123;</span><br><span class="line">                    ALOGW(<span class="string">&quot;[%s] prepareForAdaptivePlayback failed w/ err %d&quot;</span>,</span><br><span class="line">                            mComponentName.c_str(), err);</span><br><span class="line">                    <span class="comment">// allow failure</span></span><br><span class="line">                    err = OK;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="function"><span class="title">inputFormat</span>-&gt;</span>setInt32(<span class="string">&quot;max-width&quot;</span>, maxWidth);</span><br><span class="line">                    <span class="function"><span class="title">inputFormat</span>-&gt;</span>setInt32(<span class="string">&quot;max-height&quot;</span>, maxHeight);</span><br><span class="line">                    <span class="function"><span class="title">inputFormat</span>-&gt;</span>setInt32(<span class="string">&quot;adaptive-playback&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ALOGV(<span class="string">&quot;Configuring CPU controlled video playback.&quot;</span>);</span><br><span class="line">            mTunneled = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Explicity reset the sideband handle of the window for</span></span><br><span class="line">            <span class="comment">// non-tunneled video in case the window was previously used</span></span><br><span class="line">            <span class="comment">// for a tunneled video playback.</span></span><br><span class="line">            err = native_window_set_sideband_stream(nativeWindow.get(), NULL);</span><br><span class="line">            <span class="keyword">if</span> (err != OK) &#123;</span><br><span class="line">                ALOGE(<span class="string">&quot;set_sideband_stream(NULL) failed! (err %d).&quot;</span>, err);</span><br><span class="line">                return err;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Always try to enable dynamic output buffers on native surface</span></span><br><span class="line">            <span class="function"><span class="title">err</span> = mOMX-&gt;</span>storeMetaDataInBuffers(</span><br><span class="line">                    mNode, kPortIndexOutput, OMX_TRUE, &amp;mOutputMetadataType);</span><br><span class="line">            <span class="keyword">if</span> (err != OK) &#123;</span><br><span class="line">                ALOGE(<span class="string">&quot;[%s] storeMetaDataInBuffers failed w/ err %d&quot;</span>,</span><br><span class="line">                        mComponentName.c_str(), err);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// if adaptive playback has been requested, try JB fallback</span></span><br><span class="line">                <span class="comment">// <span class="doctag">NOTE:</span> THIS FALLBACK MECHANISM WILL BE REMOVED DUE TO ITS</span></span><br><span class="line">                <span class="comment">// LARGE MEMORY REQUIREMENT</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// we will not do adaptive playback on software accessed</span></span><br><span class="line">                <span class="comment">// surfaces as they never had to respond to changes in the</span></span><br><span class="line">                <span class="comment">// crop window, and we don&#x27;t trust that they will be able to.</span></span><br><span class="line">                int usageBits = <span class="number">0</span>;</span><br><span class="line">                bool canDoAdaptivePlayback;</span><br><span class="line"></span><br><span class="line">                <span class="function"><span class="title">if</span> (nativeWindow-&gt;</span>query(</span><br><span class="line">                        nativeWindow.get(),</span><br><span class="line">                        NATIVE_WINDOW_CONSUMER_USAGE_BITS,</span><br><span class="line">                        &amp;usageBits) != OK) &#123;</span><br><span class="line">                    canDoAdaptivePlayback = <span class="literal">false</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    canDoAdaptivePlayback =</span><br><span class="line">                        (usageBits &amp;</span><br><span class="line">                                (GRALLOC_USAGE_SW_READ_MASK |</span><br><span class="line">                                 GRALLOC_USAGE_SW_WRITE_MASK)) == <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                int32_t maxWidth = <span class="number">0</span>, maxHeight = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (canDoAdaptivePlayback &amp;&amp;</span><br><span class="line">                        <span class="function"><span class="title">msg</span>-&gt;</span>findInt32(<span class="string">&quot;max-width&quot;</span>, &amp;maxWidth) &amp;&amp;</span><br><span class="line">                        <span class="function"><span class="title">msg</span>-&gt;</span>findInt32(<span class="string">&quot;max-height&quot;</span>, &amp;maxHeight)) &#123;</span><br><span class="line">                    ALOGV(<span class="string">&quot;[%s] prepareForAdaptivePlayback(%dx%d)&quot;</span>,</span><br><span class="line">                            mComponentName.c_str(), maxWidth, maxHeight);</span><br><span class="line"></span><br><span class="line">                    <span class="function"><span class="title">err</span> = mOMX-&gt;</span>prepareForAdaptivePlayback(</span><br><span class="line">                            mNode, kPortIndexOutput, OMX_TRUE, maxWidth,</span><br><span class="line">                            maxHeight);</span><br><span class="line">                    ALOGW_IF(err != OK,</span><br><span class="line">                            <span class="string">&quot;[%s] prepareForAdaptivePlayback failed w/ err %d&quot;</span>,</span><br><span class="line">                            mComponentName.c_str(), err);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (err == OK) &#123;</span><br><span class="line">                        <span class="function"><span class="title">inputFormat</span>-&gt;</span>setInt32(<span class="string">&quot;max-width&quot;</span>, maxWidth);</span><br><span class="line">                        <span class="function"><span class="title">inputFormat</span>-&gt;</span>setInt32(<span class="string">&quot;max-height&quot;</span>, maxHeight);</span><br><span class="line">                        <span class="function"><span class="title">inputFormat</span>-&gt;</span>setInt32(<span class="string">&quot;adaptive-playback&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// allow failure</span></span><br><span class="line">                err = OK;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ALOGV(<span class="string">&quot;[%s] storeMetaDataInBuffers succeeded&quot;</span>,</span><br><span class="line">                        mComponentName.c_str());</span><br><span class="line">                CHECK(storingMetadataInDecodedBuffers());</span><br><span class="line">                mLegacyAdaptiveExperiment = ADebug::isExperimentEnabled(</span><br><span class="line">                        <span class="string">&quot;legacy-adaptive&quot;</span>, !<span class="function"><span class="title">msg</span>-&gt;</span><span class="built_in">contains</span>(<span class="string">&quot;no-experiments&quot;</span>));</span><br><span class="line"></span><br><span class="line">                <span class="function"><span class="title">inputFormat</span>-&gt;</span>setInt32(<span class="string">&quot;adaptive-playback&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            int32_t push;</span><br><span class="line">            <span class="function"><span class="title">if</span> (msg-&gt;</span>findInt32(<span class="string">&quot;push-blank-buffers-on-shutdown&quot;</span>, &amp;push)</span><br><span class="line">                    &amp;&amp; push != <span class="number">0</span>) &#123;</span><br><span class="line">                mFlags |= kFlagPushBlankBuffersToNativeWindowOnShutdown;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int32_t rotationDegrees;</span><br><span class="line">        <span class="function"><span class="title">if</span> (msg-&gt;</span>findInt32(<span class="string">&quot;rotation-degrees&quot;</span>, &amp;rotationDegrees)) &#123;</span><br><span class="line">            mRotationDegrees = rotationDegrees;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mRotationDegrees = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (video) &#123;</span><br><span class="line">        <span class="comment">// determine need for software renderer</span></span><br><span class="line">        bool usingSwRenderer = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (haveNativeWindow &amp;&amp; mComponentName.startsWith(<span class="string">&quot;OMX.google.&quot;</span>)) &#123;</span><br><span class="line">            usingSwRenderer = <span class="literal">true</span>;</span><br><span class="line">            haveNativeWindow = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (encoder) &#123;</span><br><span class="line">            err = setupVideoEncoder(mime, msg);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            err = setupVideoDecoder(mime, msg, haveNativeWindow);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (err != OK) &#123;</span><br><span class="line">            return err;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (haveNativeWindow) &#123;</span><br><span class="line">            mNativeWindow = static_cast&lt;Surface *&gt;(obj.get());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// initialize native window now to get actual output format</span></span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> this is needed for some encoders even though they don&#x27;t use native window</span></span><br><span class="line">        err = initNativeWindow();</span><br><span class="line">        <span class="keyword">if</span> (err != OK) &#123;</span><br><span class="line">            return err;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// fallback for devices that do not handle flex-YUV for native buffers</span></span><br><span class="line">        <span class="keyword">if</span> (haveNativeWindow) &#123;</span><br><span class="line">            int32_t requestedColorFormat = OMX_COLOR_FormatUnused;</span><br><span class="line">            <span class="function"><span class="title">if</span> (msg-&gt;</span>findInt32(<span class="string">&quot;color-format&quot;</span>, &amp;requestedColorFormat) &amp;&amp;</span><br><span class="line">                    requestedColorFormat == OMX_COLOR_FormatYUV420Flexible) &#123;</span><br><span class="line">                status_t err = getPortFormat(kPortIndexOutput, outputFormat);</span><br><span class="line">                <span class="keyword">if</span> (err != OK) &#123;</span><br><span class="line">                    return err;</span><br><span class="line">                &#125;</span><br><span class="line">                int32_t colorFormat = OMX_COLOR_FormatUnused;</span><br><span class="line">                OMX_U32 flexibleEquivalent = OMX_COLOR_FormatUnused;</span><br><span class="line">                <span class="function"><span class="title">if</span> (!outputFormat-&gt;</span>findInt32(<span class="string">&quot;color-format&quot;</span>, &amp;colorFormat)) &#123;</span><br><span class="line">                    ALOGE(<span class="string">&quot;ouptut port did not have a color format (wrong domain?)&quot;</span>);</span><br><span class="line">                    return BAD_VALUE;</span><br><span class="line">                &#125;</span><br><span class="line">                ALOGD(<span class="string">&quot;[%s] Requested output format %#x and got %#x.&quot;</span>,</span><br><span class="line">                        mComponentName.c_str(), requestedColorFormat, colorFormat);</span><br><span class="line">                <span class="keyword">if</span> (!isFlexibleColorFormat(</span><br><span class="line">                                mOMX, mNode, colorFormat, haveNativeWindow, &amp;flexibleEquivalent)</span><br><span class="line">                        || flexibleEquivalent != (OMX_U32)requestedColorFormat) &#123;</span><br><span class="line">                    <span class="comment">// device did not handle flex-YUV request for native window, fall back</span></span><br><span class="line">                    <span class="comment">// to SW renderer</span></span><br><span class="line">                    ALOGI(<span class="string">&quot;[%s] Falling back to software renderer&quot;</span>, mComponentName.c_str());</span><br><span class="line">                    mNativeWindow.clear();</span><br><span class="line">                    mNativeWindowUsageBits = <span class="number">0</span>;</span><br><span class="line">                    haveNativeWindow = <span class="literal">false</span>;</span><br><span class="line">                    usingSwRenderer = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">if</span> (storingMetadataInDecodedBuffers()) &#123;</span><br><span class="line">                        <span class="function"><span class="title">err</span> = mOMX-&gt;</span>storeMetaDataInBuffers(</span><br><span class="line">                                mNode, kPortIndexOutput, OMX_FALSE, &amp;mOutputMetadataType);</span><br><span class="line">                        mOutputMetadataType = kMetadataBufferTypeInvalid; <span class="comment">// just in case</span></span><br><span class="line">                        <span class="comment">// <span class="doctag">TODO:</span> implement adaptive-playback support for bytebuffer mode.</span></span><br><span class="line">                        <span class="comment">// This is done by SW codecs, but most HW codecs don&#x27;t support it.</span></span><br><span class="line">                        <span class="function"><span class="title">inputFormat</span>-&gt;</span>setInt32(<span class="string">&quot;adaptive-playback&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (err == OK) &#123;</span><br><span class="line">                        <span class="function"><span class="title">err</span> = mOMX-&gt;</span>enableGraphicBuffers(mNode, kPortIndexOutput, OMX_FALSE);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (mFlags &amp; kFlagIsGrallocUsageProtected) &#123;</span><br><span class="line">                        <span class="comment">// fallback is not supported for protected playback</span></span><br><span class="line">                        err = PERMISSION_DENIED;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (err == OK) &#123;</span><br><span class="line">                        err = setupVideoDecoder(mime, msg, <span class="literal">false</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (usingSwRenderer) &#123;</span><br><span class="line">            <span class="function"><span class="title">outputFormat</span>-&gt;</span>setInt32(<span class="string">&quot;using-sw-renderer&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_MPEG)) &#123;</span><br><span class="line">        int32_t numChannels, sampleRate;</span><br><span class="line">        <span class="function"><span class="title">if</span> (!msg-&gt;</span>findInt32(<span class="string">&quot;channel-count&quot;</span>, &amp;numChannels)</span><br><span class="line">                || !<span class="function"><span class="title">msg</span>-&gt;</span>findInt32(<span class="string">&quot;sample-rate&quot;</span>, &amp;sampleRate)) &#123;</span><br><span class="line">            <span class="comment">// Since we did not always check for these, leave them optional</span></span><br><span class="line">            <span class="comment">// and have the decoder figure it all out.</span></span><br><span class="line">            err = OK;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            err = setupRawAudioFormat(</span><br><span class="line">                    encoder ? kPortIndexInput : kPortIndexOutput,</span><br><span class="line">                    sampleRate,</span><br><span class="line">                    numChannels);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_AAC)) &#123;</span><br><span class="line">        int32_t numChannels, sampleRate;</span><br><span class="line">        <span class="function"><span class="title">if</span> (!msg-&gt;</span>findInt32(<span class="string">&quot;channel-count&quot;</span>, &amp;numChannels)</span><br><span class="line">                || !<span class="function"><span class="title">msg</span>-&gt;</span>findInt32(<span class="string">&quot;sample-rate&quot;</span>, &amp;sampleRate)) &#123;</span><br><span class="line">            err = INVALID_OPERATION;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            int32_t isADTS, aacProfile;</span><br><span class="line">            int32_t sbrMode;</span><br><span class="line">            int32_t maxOutputChannelCount;</span><br><span class="line">            int32_t pcmLimiterEnable;</span><br><span class="line">            drcParams_t drc;</span><br><span class="line">            <span class="function"><span class="title">if</span> (!msg-&gt;</span>findInt32(<span class="string">&quot;is-adts&quot;</span>, &amp;isADTS)) &#123;</span><br><span class="line">                isADTS = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="title">if</span> (!msg-&gt;</span>findInt32(<span class="string">&quot;aac-profile&quot;</span>, &amp;aacProfile)) &#123;</span><br><span class="line">                aacProfile = OMX_AUDIO_AACObjectNull;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="title">if</span> (!msg-&gt;</span>findInt32(<span class="string">&quot;aac-sbr-mode&quot;</span>, &amp;sbrMode)) &#123;</span><br><span class="line">                sbrMode = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="title">if</span> (!msg-&gt;</span>findInt32(<span class="string">&quot;aac-max-output-channel_count&quot;</span>, &amp;maxOutputChannelCount)) &#123;</span><br><span class="line">                maxOutputChannelCount = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="title">if</span> (!msg-&gt;</span>findInt32(<span class="string">&quot;aac-pcm-limiter-enable&quot;</span>, &amp;pcmLimiterEnable)) &#123;</span><br><span class="line">                <span class="comment">// value is unknown</span></span><br><span class="line">                pcmLimiterEnable = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="title">if</span> (!msg-&gt;</span>findInt32(<span class="string">&quot;aac-encoded-target-level&quot;</span>, &amp;drc.encodedTargetLevel)) &#123;</span><br><span class="line">                <span class="comment">// value is unknown</span></span><br><span class="line">                drc.encodedTargetLevel = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="title">if</span> (!msg-&gt;</span>findInt32(<span class="string">&quot;aac-drc-cut-level&quot;</span>, &amp;drc.drcCut)) &#123;</span><br><span class="line">                <span class="comment">// value is unknown</span></span><br><span class="line">                drc.drcCut = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="title">if</span> (!msg-&gt;</span>findInt32(<span class="string">&quot;aac-drc-boost-level&quot;</span>, &amp;drc.drcBoost)) &#123;</span><br><span class="line">                <span class="comment">// value is unknown</span></span><br><span class="line">                drc.drcBoost = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="title">if</span> (!msg-&gt;</span>findInt32(<span class="string">&quot;aac-drc-heavy-compression&quot;</span>, &amp;drc.heavyCompression)) &#123;</span><br><span class="line">                <span class="comment">// value is unknown</span></span><br><span class="line">                drc.heavyCompression = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="title">if</span> (!msg-&gt;</span>findInt32(<span class="string">&quot;aac-target-ref-level&quot;</span>, &amp;drc.targetRefLevel)) &#123;</span><br><span class="line">                <span class="comment">// value is unknown</span></span><br><span class="line">                drc.targetRefLevel = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            err = setupAACCodec(</span><br><span class="line">                    encoder, numChannels, sampleRate, bitRate, aacProfile,</span><br><span class="line">                    isADTS != <span class="number">0</span>, sbrMode, maxOutputChannelCount, drc,</span><br><span class="line">                    pcmLimiterEnable);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_AMR_NB)) &#123;</span><br><span class="line">        err = setupAMRCodec(encoder, <span class="literal">false</span> <span class="comment">/* isWAMR */</span>, bitRate);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_AMR_WB)) &#123;</span><br><span class="line">        err = setupAMRCodec(encoder, <span class="literal">true</span> <span class="comment">/* isWAMR */</span>, bitRate);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_G711_ALAW)</span><br><span class="line">            || !strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_G711_MLAW)) &#123;</span><br><span class="line">        <span class="comment">// These are PCM-like formats with a fixed sample rate but</span></span><br><span class="line">        <span class="comment">// a variable number of channels.</span></span><br><span class="line"></span><br><span class="line">        int32_t numChannels;</span><br><span class="line">        <span class="function"><span class="title">if</span> (!msg-&gt;</span>findInt32(<span class="string">&quot;channel-count&quot;</span>, &amp;numChannels)) &#123;</span><br><span class="line">            err = INVALID_OPERATION;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            int32_t sampleRate;</span><br><span class="line">            <span class="function"><span class="title">if</span> (!msg-&gt;</span>findInt32(<span class="string">&quot;sample-rate&quot;</span>, &amp;sampleRate)) &#123;</span><br><span class="line">                sampleRate = <span class="number">8000</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            err = setupG711Codec(encoder, sampleRate, numChannels);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_FLAC)) &#123;</span><br><span class="line">        int32_t numChannels = <span class="number">0</span>, sampleRate = <span class="number">0</span>, compressionLevel = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (encoder &amp;&amp;</span><br><span class="line">                (!<span class="function"><span class="title">msg</span>-&gt;</span>findInt32(<span class="string">&quot;channel-count&quot;</span>, &amp;numChannels)</span><br><span class="line">                        || !<span class="function"><span class="title">msg</span>-&gt;</span>findInt32(<span class="string">&quot;sample-rate&quot;</span>, &amp;sampleRate))) &#123;</span><br><span class="line">            ALOGE(<span class="string">&quot;missing channel count or sample rate for FLAC encoder&quot;</span>);</span><br><span class="line">            err = INVALID_OPERATION;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (encoder) &#123;</span><br><span class="line">                <span class="function"><span class="title">if</span> (!msg-&gt;</span>findInt32(</span><br><span class="line">                            <span class="string">&quot;complexity&quot;</span>, &amp;compressionLevel) &amp;&amp;</span><br><span class="line">                    !<span class="function"><span class="title">msg</span>-&gt;</span>findInt32(</span><br><span class="line">                            <span class="string">&quot;flac-compression-level&quot;</span>, &amp;compressionLevel)) &#123;</span><br><span class="line">                    compressionLevel = <span class="number">5</span>; <span class="comment">// default FLAC compression level</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (compressionLevel &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    ALOGW(<span class="string">&quot;compression level %d outside [0..8] range, &quot;</span></span><br><span class="line">                          <span class="string">&quot;using 0&quot;</span>,</span><br><span class="line">                          compressionLevel);</span><br><span class="line">                    compressionLevel = <span class="number">0</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (compressionLevel &gt; <span class="number">8</span>) &#123;</span><br><span class="line">                    ALOGW(<span class="string">&quot;compression level %d outside [0..8] range, &quot;</span></span><br><span class="line">                          <span class="string">&quot;using 8&quot;</span>,</span><br><span class="line">                          compressionLevel);</span><br><span class="line">                    compressionLevel = <span class="number">8</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            err = setupFlacCodec(</span><br><span class="line">                    encoder, numChannels, sampleRate, compressionLevel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_RAW)) &#123;</span><br><span class="line">        int32_t numChannels, sampleRate;</span><br><span class="line">        <span class="keyword">if</span> (encoder</span><br><span class="line">                || !<span class="function"><span class="title">msg</span>-&gt;</span>findInt32(<span class="string">&quot;channel-count&quot;</span>, &amp;numChannels)</span><br><span class="line">                || !<span class="function"><span class="title">msg</span>-&gt;</span>findInt32(<span class="string">&quot;sample-rate&quot;</span>, &amp;sampleRate)) &#123;</span><br><span class="line">            err = INVALID_OPERATION;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            err = setupRawAudioFormat(kPortIndexInput, sampleRate, numChannels);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_AC3)) &#123;</span><br><span class="line">        int32_t numChannels;</span><br><span class="line">        int32_t sampleRate;</span><br><span class="line">        <span class="function"><span class="title">if</span> (!msg-&gt;</span>findInt32(<span class="string">&quot;channel-count&quot;</span>, &amp;numChannels)</span><br><span class="line">                || !<span class="function"><span class="title">msg</span>-&gt;</span>findInt32(<span class="string">&quot;sample-rate&quot;</span>, &amp;sampleRate)) &#123;</span><br><span class="line">            err = INVALID_OPERATION;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            err = setupAC3Codec(encoder, numChannels, sampleRate);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_EAC3)) &#123;</span><br><span class="line">        int32_t numChannels;</span><br><span class="line">        int32_t sampleRate;</span><br><span class="line">        <span class="function"><span class="title">if</span> (!msg-&gt;</span>findInt32(<span class="string">&quot;channel-count&quot;</span>, &amp;numChannels)</span><br><span class="line">                || !<span class="function"><span class="title">msg</span>-&gt;</span>findInt32(<span class="string">&quot;sample-rate&quot;</span>, &amp;sampleRate)) &#123;</span><br><span class="line">            err = INVALID_OPERATION;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            err = setupEAC3Codec(encoder, numChannels, sampleRate);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err != OK) &#123;</span><br><span class="line">        return err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">if</span> (!msg-&gt;</span>findInt32(<span class="string">&quot;encoder-delay&quot;</span>, &amp;mEncoderDelay)) &#123;</span><br><span class="line">        mEncoderDelay = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">if</span> (!msg-&gt;</span>findInt32(<span class="string">&quot;encoder-padding&quot;</span>, &amp;mEncoderPadding)) &#123;</span><br><span class="line">        mEncoderPadding = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">if</span> (msg-&gt;</span>findInt32(<span class="string">&quot;channel-mask&quot;</span>, &amp;mChannelMask)) &#123;</span><br><span class="line">        mChannelMaskPresent = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mChannelMaskPresent = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int32_t maxInputSize;</span><br><span class="line">    <span class="function"><span class="title">if</span> (msg-&gt;</span>findInt32(<span class="string">&quot;max-input-size&quot;</span>, &amp;maxInputSize)) &#123;</span><br><span class="line">        err = setMinBufferSize(kPortIndexInput, (size_t)maxInputSize);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcmp(<span class="string">&quot;OMX.Nvidia.aac.decoder&quot;</span>, mComponentName.c_str())) &#123;</span><br><span class="line">        err = setMinBufferSize(kPortIndexInput, <span class="number">8192</span>);  <span class="comment">// XXX</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int32_t priority;</span><br><span class="line">    <span class="function"><span class="title">if</span> (msg-&gt;</span>findInt32(<span class="string">&quot;priority&quot;</span>, &amp;priority)) &#123;</span><br><span class="line">        err = setPriority(priority);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int32_t rateInt = -<span class="number">1</span>;</span><br><span class="line">    float rateFloat = -<span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="title">if</span> (!msg-&gt;</span>findFloat(<span class="string">&quot;operating-rate&quot;</span>, &amp;rateFloat)) &#123;</span><br><span class="line">        <span class="function"><span class="title">msg</span>-&gt;</span>findInt32(<span class="string">&quot;operating-rate&quot;</span>, &amp;rateInt);</span><br><span class="line">        rateFloat = (float)rateInt;  <span class="comment">// 16MHz (FLINTMAX) is OK for upper bound.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rateFloat &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        err = setOperatingRate(rateFloat, video);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mBaseOutputFormat = outputFormat;</span><br><span class="line"></span><br><span class="line">    err = getPortFormat(kPortIndexInput, inputFormat);</span><br><span class="line">    <span class="keyword">if</span> (err == OK) &#123;</span><br><span class="line">        err = getPortFormat(kPortIndexOutput, outputFormat);</span><br><span class="line">        <span class="keyword">if</span> (err == OK) &#123;</span><br><span class="line">            mInputFormat = inputFormat;</span><br><span class="line">            mOutputFormat = outputFormat;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>到了这里整个解码器的初始化和配置已经结束了，我们看下解码器的start阶段：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">status_t MediaCodec::start<span class="literal">()</span> &#123;</span><br><span class="line">    sp&lt;AMessage&gt; msg = <span class="keyword">new</span> <span class="constructor">AMessage(<span class="params">kWhatStart</span>, <span class="params">this</span>)</span>;</span><br><span class="line"></span><br><span class="line">    status_t err;</span><br><span class="line">    Vector&lt;MediaResource&gt; resources;</span><br><span class="line">    const <span class="built_in">char</span> *<span class="keyword">type</span> = (mFlags &amp; kFlagIsSecure) ?</span><br><span class="line">            kResourceSecureCodec : kResourceNonSecureCodec;</span><br><span class="line">    const <span class="built_in">char</span> *subtype = mIsVideo ? kResourceVideoCodec : kResourceAudioCodec;</span><br><span class="line">    resources.push<span class="constructor">_back(MediaResource(String8(<span class="params">type</span>)</span>, <span class="constructor">String8(<span class="params">subtype</span>)</span>, <span class="number">1</span>));</span><br><span class="line">    <span class="comment">// Don&#x27;t know the buffer size at this point, but it&#x27;s fine to use 1 because</span></span><br><span class="line">    <span class="comment">// the reclaimResource call doesn&#x27;t consider the requester&#x27;s buffer size for now.</span></span><br><span class="line">    resources.push<span class="constructor">_back(MediaResource(String8(<span class="params">kResourceGraphicMemory</span>)</span>, <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt;= kMaxRetry; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// Don&#x27;t try to reclaim resource for the first time.</span></span><br><span class="line">            <span class="keyword">if</span> (!mResourceManagerService-&gt;reclaim<span class="constructor">Resource(<span class="params">resources</span>)</span>) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Recover codec from previous error before retry start.</span></span><br><span class="line">            err = reset<span class="literal">()</span>;</span><br><span class="line">            <span class="keyword">if</span> (err != OK) &#123;</span><br><span class="line">                <span class="constructor">ALOGE(<span class="string">&quot;retrying start: failed to reset codec&quot;</span>)</span>;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            sp&lt;AMessage&gt; response;</span><br><span class="line">            err = <span class="constructor">PostAndAwaitResponse(<span class="params">mConfigureMsg</span>, &amp;<span class="params">response</span>)</span>;</span><br><span class="line">            <span class="keyword">if</span> (err != OK) &#123;</span><br><span class="line">                <span class="constructor">ALOGE(<span class="string">&quot;retrying start: failed to configure codec&quot;</span>)</span>;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sp&lt;AMessage&gt; response;</span><br><span class="line">        err = <span class="constructor">PostAndAwaitResponse(<span class="params">msg</span>, &amp;<span class="params">response</span>)</span>;</span><br><span class="line">        <span class="keyword">if</span> (!is<span class="constructor">ResourceError(<span class="params">err</span>)</span>) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">case kWhatStart:</span><br><span class="line">&#123;</span><br><span class="line">    sp&lt;AReplyToken&gt; replyID;</span><br><span class="line">    <span class="constructor">CHECK(<span class="params">msg</span>-&gt;<span class="params">senderAwaitsResponse</span>(&amp;<span class="params">replyID</span>)</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mState<span class="operator"> == </span>FLUSHED) &#123;</span><br><span class="line">        set<span class="constructor">State(STARTED)</span>;</span><br><span class="line">        <span class="keyword">if</span> (mHavePendingInputBuffers) &#123;</span><br><span class="line">            on<span class="constructor">InputBufferAvailable()</span>;</span><br><span class="line">            mHavePendingInputBuffers = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//我们重点看这里</span></span><br><span class="line">        mCodec-&gt;signal<span class="constructor">Resume()</span>;</span><br><span class="line">        <span class="comment">//..................</span></span><br><span class="line">        <span class="constructor">PostReplyWithError(<span class="params">replyID</span>, OK)</span>;</span><br><span class="line">        break;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mState != CONFIGURED) &#123;</span><br><span class="line">        <span class="constructor">PostReplyWithError(<span class="params">replyID</span>, INVALID_OPERATION)</span>;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mReplyID = replyID;</span><br><span class="line">    set<span class="constructor">State(STARTING)</span>;</span><br><span class="line"></span><br><span class="line">    mCodec-&gt;initiate<span class="constructor">Start()</span>;</span><br><span class="line">    break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先調用initiateStart初始化解码器状态</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line"><span class="literal">void</span> ACodec::initiateStart() &#123;</span><br><span class="line">    <span class="function"><span class="params">(<span class="keyword">new</span> AMessage(kWhatStart, this))</span>-&gt;</span>post();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> ACodec::kWhatStart:</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">onStart</span>();</span><br><span class="line">    handled = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">void ACodec::LoadedState::onStart() &#123;</span><br><span class="line">    ALOGV(<span class="string">&quot;onStart&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">status_t</span> err = mCodec-&gt;</span><span class="function"><span class="title">mOMX</span>-&gt;</span><span class="function"><span class="title">sendCommand</span>(mCodec-&gt;</span>mNode, OMX_CommandStateSet, OMX_StateIdle);</span><br><span class="line">    <span class="keyword">if</span> (err != OK) &#123;</span><br><span class="line">        <span class="function"><span class="title">mCodec</span>-&gt;</span>signalError(OMX_ErrorUndefined, makeNoSideEffectStatus(err));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="function"><span class="title">mCodec</span>-&gt;</span><span class="function"><span class="title">changeState</span>(mCodec-&gt;</span>mLoadedToIdleState);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着开始获取数据进行解码</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line"><span class="literal">void</span> ACodec::signalResume() &#123;</span><br><span class="line">    <span class="function"><span class="params">(<span class="keyword">new</span> AMessage(kWhatResume, this))</span>-&gt;</span>post();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> kWhatResume:</span><br><span class="line">&#123;</span><br><span class="line">    resume();</span><br><span class="line">    handled = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">void ACodec::ExecutingState::resume() &#123;</span><br><span class="line"></span><br><span class="line">    submitOutputBuffers();</span><br><span class="line">    <span class="comment">// Post all available input buffers</span></span><br><span class="line">    <span class="function"><span class="title">if</span> (mCodec-&gt;</span>mBuffers[kPortIndexInput].size() == <span class="number">0</span>u) &#123;</span><br><span class="line">        ALOGW(<span class="string">&quot;[%s] we don&#x27;t have any input buffers to resume&quot;</span>, <span class="function"><span class="title">mCodec</span>-&gt;</span>mComponentName.c_str());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">for</span> (size_t i = 0; i &lt; mCodec-&gt;</span>mBuffers[kPortIndexInput].size(); i++) &#123;</span><br><span class="line">        B<span class="function"><span class="title">ufferInfo</span> *info = &amp;mCodec-&gt;</span>mBuffers[kPortIndexInput].editItemAt(i);</span><br><span class="line">        <span class="function"><span class="title">if</span> (info-&gt;</span>mStatus == BufferInfo::OWNED_BY_US) &#123;</span><br><span class="line">            postFillThisBuffer(info);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mActive = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">void ACodec::BaseState::postFillThisBuffer(BufferInfo *info) &#123;</span><br><span class="line">    <span class="function"><span class="title">if</span> (mCodec-&gt;</span>mPortEOS[kPortIndexInput]) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CHECK_EQ((<span class="function"><span class="title">int</span>)info-&gt;</span>mStatus, (int)BufferInfo::OWNED_BY_US);</span><br><span class="line">    <span class="function"><span class="title">sp</span>&lt;AMessage&gt; notify = mCodec-&gt;</span><span class="function"><span class="title">mNotify</span>-&gt;</span>dup();</span><br><span class="line">    <span class="function"><span class="title">notify</span>-&gt;</span>setInt32(<span class="string">&quot;what&quot;</span>, CodecBase::kWhatFillThisBuffer);</span><br><span class="line">    <span class="function"><span class="title">notify</span>-&gt;</span><span class="function"><span class="title">setInt32</span>(&quot;buffer-id&quot;, info-&gt;</span>mBufferID);</span><br><span class="line">    <span class="function"><span class="title">info</span>-&gt;</span><span class="function"><span class="title">mData</span>-&gt;</span><span class="function"><span class="title">meta</span>()-&gt;</span>clear();</span><br><span class="line">    <span class="function"><span class="title">notify</span>-&gt;</span><span class="function"><span class="title">setBuffer</span>(&quot;buffer&quot;, info-&gt;</span>mData);</span><br><span class="line">    sp&lt;AMessage&gt; reply = new AMessage(kWhatInputBufferFilled, mCodec);</span><br><span class="line">    <span class="function"><span class="title">reply</span>-&gt;</span><span class="function"><span class="title">setInt32</span>(&quot;buffer-id&quot;, info-&gt;</span>mBufferID);</span><br><span class="line">    <span class="function"><span class="title">notify</span>-&gt;</span>setMessage(<span class="string">&quot;reply&quot;</span>, reply);</span><br><span class="line">    <span class="function"><span class="title">notify</span>-&gt;</span>post();</span><br><span class="line">    <span class="function"><span class="title">info</span>-&gt;</span>mStatus = BufferInfo::OWNED_BY_UPSTREAM;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">case CodecBase::kWhatFillThisBuffer:</span><br><span class="line">&#123;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//..........</span></span><br><span class="line">    <span class="keyword">if</span> (mFlags &amp; kFlagIsAsync) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mHaveInputSurface) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mState<span class="operator"> == </span>FLUSHED) &#123;</span><br><span class="line">                mHavePendingInputBuffers = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                on<span class="constructor">InputBufferAvailable()</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mFlags &amp; kFlagDequeueInputPending) &#123;</span><br><span class="line">        <span class="constructor">CHECK(<span class="params">handleDequeueInputBuffer</span>(<span class="params">mDequeueInputReplyID</span>)</span>);</span><br><span class="line">        ++mDequeueInputTimeoutGeneration;</span><br><span class="line">        mFlags &amp;= ~kFlagDequeueInputPending;</span><br><span class="line">        mDequeueInputReplyID = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        post<span class="constructor">ActivityNotificationIfPossible()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">void MediaCodec::onInputBufferAvailable() &#123;</span><br><span class="line">    int32_t index;</span><br><span class="line">    <span class="keyword">while</span> ((index = dequeuePortBuffer(kPortIndexInput)) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="function"><span class="title">sp</span>&lt;AMessage&gt; msg = mCallback-&gt;</span>dup();</span><br><span class="line">        <span class="function"><span class="title">msg</span>-&gt;</span>setInt32(<span class="string">&quot;callbackID&quot;</span>, CB_INPUT_AVAILABLE);</span><br><span class="line">        <span class="function"><span class="title">msg</span>-&gt;</span>setInt32(<span class="string">&quot;index&quot;</span>, index);</span><br><span class="line">        <span class="function"><span class="title">msg</span>-&gt;</span>post();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还记得这个mCallback怎么来的吗？</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void NuPlayer::Decoder::on<span class="constructor">Configure(<span class="params">const</span> <span class="params">sp</span>&lt;AMessage&gt; &amp;<span class="params">format</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//.................</span></span><br><span class="line">    sp&lt;AMessage&gt; reply = <span class="keyword">new</span> <span class="constructor">AMessage(<span class="params">kWhatCodecNotify</span>, <span class="params">this</span>)</span>;</span><br><span class="line">    mCodec-&gt;set<span class="constructor">Callback(<span class="params">reply</span>)</span>;</span><br><span class="line">	<span class="comment">//..................</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">status_t MediaCodec::set<span class="constructor">Callback(<span class="params">const</span> <span class="params">sp</span>&lt;AMessage&gt; &amp;<span class="params">callback</span>)</span> &#123;</span><br><span class="line">    sp&lt;AMessage&gt; msg = <span class="keyword">new</span> <span class="constructor">AMessage(<span class="params">kWhatSetCallback</span>, <span class="params">this</span>)</span>;</span><br><span class="line">    msg-&gt;set<span class="constructor">Message(<span class="string">&quot;callback&quot;</span>, <span class="params">callback</span>)</span>;</span><br><span class="line"></span><br><span class="line">    sp&lt;AMessage&gt; response;</span><br><span class="line">    return <span class="constructor">PostAndAwaitResponse(<span class="params">msg</span>, &amp;<span class="params">response</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">case kWhatSetCallback:</span><br><span class="line">&#123;</span><br><span class="line">    sp&lt;AReplyToken&gt; replyID;</span><br><span class="line">    <span class="constructor">CHECK(<span class="params">msg</span>-&gt;<span class="params">senderAwaitsResponse</span>(&amp;<span class="params">replyID</span>)</span>);</span><br><span class="line">    sp&lt;AMessage&gt; callback;</span><br><span class="line">    <span class="constructor">CHECK(<span class="params">msg</span>-&gt;<span class="params">findMessage</span>(<span class="string">&quot;callback&quot;</span>, &amp;<span class="params">callback</span>)</span>);</span><br><span class="line"></span><br><span class="line">    mCallback = callback;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mCallback != NULL) &#123;</span><br><span class="line">        mFlags <span class="pattern-match">|= k<span class="constructor">FlagIsAsync</span>;</span></span><br><span class="line"><span class="pattern-match">    &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="pattern-match">        m<span class="constructor">Flags</span> &amp;= ~k<span class="constructor">FlagIsAsync</span>;</span></span><br><span class="line"><span class="pattern-match">    &#125;</span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match">    sp&lt;<span class="constructor">AMessage</span>&gt; response = <span class="keyword">new</span> <span class="constructor">AMessage</span>;</span></span><br><span class="line"><span class="pattern-match">    response-&gt;post<span class="constructor">Reply(<span class="params">replyID</span>)</span>;</span></span><br><span class="line"><span class="pattern-match">    break;</span></span><br><span class="line"><span class="pattern-match">&#125;</span></span><br></pre></td></tr></table></figure>
<p>所以根据上面我们可以知道接下来i调用的是kWhatCodecNotify 下的 CB_INPUT_AVAILABLE</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">case MediaCodec::CB_INPUT_AVAILABLE:</span><br><span class="line">&#123;</span><br><span class="line">    int32_t index;</span><br><span class="line">    <span class="constructor">CHECK(<span class="params">msg</span>-&gt;<span class="params">findInt32</span>(<span class="string">&quot;index&quot;</span>, &amp;<span class="params">index</span>)</span>);</span><br><span class="line"></span><br><span class="line">    handle<span class="constructor">AnInputBuffer(<span class="params">index</span>)</span>;</span><br><span class="line">    break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="built_in">bool</span> NuPlayer::Decoder::handle<span class="constructor">AnInputBuffer(<span class="params">size_t</span> <span class="params">index</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (is<span class="constructor">DiscontinuityPending()</span>) &#123;</span><br><span class="line">        return <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sp&lt;ABuffer&gt; buffer;</span><br><span class="line">    mCodec-&gt;get<span class="constructor">InputBuffer(<span class="params">index</span>, &amp;<span class="params">buffer</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (buffer<span class="operator"> == </span>NULL) &#123;</span><br><span class="line">        handle<span class="constructor">Error(UNKNOWN_ERROR)</span>;</span><br><span class="line">        return <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index &gt;= mInputBuffers.size<span class="literal">()</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (size_t i = mInputBuffers.size<span class="literal">()</span>; i &lt;= index; ++i) &#123;</span><br><span class="line">            mInputBuffers.add<span class="literal">()</span>;</span><br><span class="line">            mMediaBuffers.add<span class="literal">()</span>;</span><br><span class="line">            mInputBufferIsDequeued.add<span class="literal">()</span>;</span><br><span class="line">            mMediaBuffers.edit<span class="constructor">ItemAt(<span class="params">i</span>)</span> = NULL;</span><br><span class="line">            mInputBufferIsDequeued.edit<span class="constructor">ItemAt(<span class="params">i</span>)</span> = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mInputBuffers.edit<span class="constructor">ItemAt(<span class="params">index</span>)</span> = buffer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//CHECK_LT(bufferIx, mInputBuffers.size());</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mMediaBuffers<span class="literal">[<span class="identifier">index</span>]</span> != NULL) &#123;</span><br><span class="line">        mMediaBuffers<span class="literal">[<span class="identifier">index</span>]</span>-&gt;release<span class="literal">()</span>;</span><br><span class="line">        mMediaBuffers.edit<span class="constructor">ItemAt(<span class="params">index</span>)</span> = NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    mInputBufferIsDequeued.edit<span class="constructor">ItemAt(<span class="params">index</span>)</span> = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mCSDsToSubmit.is<span class="constructor">Empty()</span>) &#123;</span><br><span class="line">        sp&lt;AMessage&gt; msg = <span class="keyword">new</span> <span class="constructor">AMessage()</span>;</span><br><span class="line">        msg-&gt;set<span class="constructor">Size(<span class="string">&quot;buffer-ix&quot;</span>, <span class="params">index</span>)</span>;</span><br><span class="line"></span><br><span class="line">        sp&lt;ABuffer&gt; buffer = mCSDsToSubmit.item<span class="constructor">At(0)</span>;</span><br><span class="line">        <span class="constructor">ALOGI(<span class="string">&quot;[%s] resubmitting CSD&quot;</span>, <span class="params">mComponentName</span>.<span class="params">c_str</span>()</span>);</span><br><span class="line">        msg-&gt;set<span class="constructor">Buffer(<span class="string">&quot;buffer&quot;</span>, <span class="params">buffer</span>)</span>;</span><br><span class="line">        mCSDsToSubmit.remove<span class="constructor">At(0)</span>;</span><br><span class="line">        <span class="constructor">CHECK(<span class="params">onInputBufferFetched</span>(<span class="params">msg</span>)</span>);</span><br><span class="line">        return <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!mPendingInputMessages.empty<span class="literal">()</span>) &#123;</span><br><span class="line">        sp&lt;AMessage&gt; msg = *mPendingInputMessages.<span class="keyword">begin</span><span class="literal">()</span>;</span><br><span class="line">        <span class="keyword">if</span> (!on<span class="constructor">InputBufferFetched(<span class="params">msg</span>)</span>) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        mPendingInputMessages.erase(mPendingInputMessages.<span class="keyword">begin</span><span class="literal">()</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mInputBufferIsDequeued.edit<span class="constructor">ItemAt(<span class="params">index</span>)</span>) &#123;</span><br><span class="line">        return <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mDequeuedInputBuffers.push<span class="constructor">_back(<span class="params">index</span>)</span>;</span><br><span class="line"></span><br><span class="line">    on<span class="constructor">RequestInputBuffers()</span>;</span><br><span class="line">    return <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void NuPlayer::DecoderBase::on<span class="constructor">RequestInputBuffers()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mRequestInputBuffersPending) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// doRequestBuffers() return true if we should request more data</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">do</span><span class="constructor">RequestBuffers()</span>) &#123;</span><br><span class="line">        mRequestInputBuffersPending = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        sp&lt;AMessage&gt; msg = <span class="keyword">new</span> <span class="constructor">AMessage(<span class="params">kWhatRequestInputBuffers</span>, <span class="params">this</span>)</span>;</span><br><span class="line">        msg-&gt;post(<span class="number">10</span><span class="operator"> * </span><span class="number">1000l</span>l);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="built_in">bool</span> NuPlayer::Decoder::<span class="keyword">do</span><span class="constructor">RequestBuffers()</span> &#123;</span><br><span class="line">    <span class="comment">// mRenderer is only NULL if we have a legacy widevine source that</span></span><br><span class="line">    <span class="comment">// is not yet ready. In this case we must not fetch input.</span></span><br><span class="line">    <span class="keyword">if</span> (is<span class="constructor">DiscontinuityPending()</span><span class="operator"> || </span>mRenderer<span class="operator"> == </span>NULL) &#123;</span><br><span class="line">        return <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    status_t err = OK;</span><br><span class="line">    <span class="keyword">while</span> (err<span class="operator"> == </span>OK<span class="operator"> &amp;&amp; </span>!mDequeuedInputBuffers.empty<span class="literal">()</span>) &#123;</span><br><span class="line">        size_t bufferIx = *mDequeuedInputBuffers.<span class="keyword">begin</span><span class="literal">()</span>;</span><br><span class="line">        sp&lt;AMessage&gt; msg = <span class="keyword">new</span> <span class="constructor">AMessage()</span>;</span><br><span class="line">        msg-&gt;set<span class="constructor">Size(<span class="string">&quot;buffer-ix&quot;</span>, <span class="params">bufferIx</span>)</span>;</span><br><span class="line">        err = fetch<span class="constructor">InputData(<span class="params">msg</span>)</span>;</span><br><span class="line">        <span class="keyword">if</span> (err != OK<span class="operator"> &amp;&amp; </span>err != ERROR_END_OF_STREAM) &#123;</span><br><span class="line">            <span class="comment">// if EOS, need to queue EOS buffer</span></span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        mDequeuedInputBuffers.erase(mDequeuedInputBuffers.<span class="keyword">begin</span><span class="literal">()</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!mPendingInputMessages.empty<span class="literal">()</span><span class="operator"></span></span><br><span class="line"><span class="operator">                || </span>!on<span class="constructor">InputBufferFetched(<span class="params">msg</span>)</span>) &#123;</span><br><span class="line">            mPendingInputMessages.push<span class="constructor">_back(<span class="params">msg</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return err<span class="operator"> == </span>-EWOULDBLOCK<span class="operator"></span></span><br><span class="line"><span class="operator">            &amp;&amp; </span>mSource-&gt;feed<span class="constructor">MoreTSData()</span><span class="operator"> == </span>OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">status_t NuPlayer::Decoder::<span class="title function_ invoke__">fetchInputData</span>(sp&lt;AMessage&gt; &amp;reply) &#123;</span><br><span class="line">    sp&lt;ABuffer&gt; accessUnit;</span><br><span class="line">    <span class="type">bool</span> dropAccessUnit;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        status_t err = mSource<span class="punctuation">-&gt;</span><span class="title function_ invoke__">dequeueAccessUnit</span>(mIsAudio, &amp;accessUnit);</span><br><span class="line"></span><br><span class="line">        <span class="title function_ invoke__">if</span> (err == -EWOULDBLOCK) &#123;</span><br><span class="line">            <span class="keyword">return</span> err;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="title function_ invoke__">if</span> (err != OK) &#123;</span><br><span class="line">            <span class="title function_ invoke__">if</span> (err == INFO_DISCONTINUITY) &#123;</span><br><span class="line">                int32_t <span class="keyword">type</span>;</span><br><span class="line">                <span class="title function_ invoke__">CHECK</span>(accessUnit<span class="punctuation">-&gt;</span><span class="title function_ invoke__">meta</span>()<span class="punctuation">-&gt;</span><span class="title function_ invoke__">findInt32</span>(<span class="string">&quot;discontinuity&quot;</span>, &amp;<span class="keyword">type</span>));</span><br><span class="line"></span><br><span class="line">                <span class="type">bool</span> formatChange =</span><br><span class="line">                    (mIsAudio &amp;&amp;</span><br><span class="line">                     (<span class="keyword">type</span> &amp; ATSParser::DISCONTINUITY_AUDIO_FORMAT))</span><br><span class="line">                    || (!mIsAudio &amp;&amp;</span><br><span class="line">                            (<span class="keyword">type</span> &amp; ATSParser::DISCONTINUITY_VIDEO_FORMAT));</span><br><span class="line"></span><br><span class="line">                <span class="type">bool</span> timeChange = (<span class="keyword">type</span> &amp; ATSParser::DISCONTINUITY_TIME) != <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                <span class="title function_ invoke__">ALOGI</span>(<span class="string">&quot;%s discontinuity (format=%d, time=%d)&quot;</span>,</span><br><span class="line">                        mIsAudio ? <span class="string">&quot;audio&quot;</span> : <span class="string">&quot;video&quot;</span>, formatChange, timeChange);</span><br><span class="line"></span><br><span class="line">                <span class="type">bool</span> seamlessFormatChange = <span class="literal">false</span>;</span><br><span class="line">                sp&lt;AMessage&gt; newFormat = mSource<span class="punctuation">-&gt;</span><span class="title function_ invoke__">getFormat</span>(mIsAudio);</span><br><span class="line">                <span class="title function_ invoke__">if</span> (formatChange) &#123;</span><br><span class="line">                    seamlessFormatChange =</span><br><span class="line">                        <span class="title function_ invoke__">supportsSeamlessFormatChange</span>(newFormat);</span><br><span class="line">                    <span class="comment">// treat seamless format change separately</span></span><br><span class="line">                    formatChange = !seamlessFormatChange;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// For format or time change, return EOS to queue EOS input,</span></span><br><span class="line">                <span class="comment">// then wait for EOS on output.</span></span><br><span class="line">                <span class="title function_ invoke__">if</span> (formatChange <span class="comment">/* not seamless */</span>) &#123;</span><br><span class="line">                    mFormatChangePending = <span class="literal">true</span>;</span><br><span class="line">                    err = ERROR_END_OF_STREAM;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="title function_ invoke__">if</span> (timeChange) &#123;</span><br><span class="line">                    <span class="title function_ invoke__">rememberCodecSpecificData</span>(newFormat);</span><br><span class="line">                    mTimeChangePending = <span class="literal">true</span>;</span><br><span class="line">                    err = ERROR_END_OF_STREAM;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="title function_ invoke__">if</span> (seamlessFormatChange) &#123;</span><br><span class="line">                    <span class="comment">// reuse existing decoder and don&#x27;t flush</span></span><br><span class="line">                    <span class="title function_ invoke__">rememberCodecSpecificData</span>(newFormat);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// This stream is unaffected by the discontinuity</span></span><br><span class="line">                    <span class="keyword">return</span> -EWOULDBLOCK;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// reply should only be returned without a buffer set</span></span><br><span class="line">            <span class="comment">// when there is an error (including EOS)</span></span><br><span class="line">            <span class="title function_ invoke__">CHECK</span>(err != OK);</span><br><span class="line"></span><br><span class="line">            reply<span class="punctuation">-&gt;</span><span class="title function_ invoke__">setInt32</span>(<span class="string">&quot;err&quot;</span>, err);</span><br><span class="line">            <span class="keyword">return</span> ERROR_END_OF_STREAM;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dropAccessUnit = <span class="literal">false</span>;</span><br><span class="line">        <span class="title function_ invoke__">if</span> (!mIsAudio</span><br><span class="line">                &amp;&amp; !mIsSecure</span><br><span class="line">                &amp;&amp; mRenderer<span class="punctuation">-&gt;</span><span class="title function_ invoke__">getVideoLateByUs</span>() &gt; <span class="number">100000</span>ll</span><br><span class="line">                &amp;&amp; mIsVideoAVC</span><br><span class="line">                &amp;&amp; !<span class="title function_ invoke__">IsAVCReferenceFrame</span>(accessUnit)) &#123;</span><br><span class="line">            dropAccessUnit = <span class="literal">true</span>;</span><br><span class="line">            ++mNumInputFramesDropped;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="title function_ invoke__">while</span> (dropAccessUnit);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ALOGV(&quot;returned a valid buffer of %s data&quot;, mIsAudio ? &quot;mIsAudio&quot; : &quot;video&quot;);</span></span><br><span class="line">#<span class="keyword">if</span> <span class="number">0</span></span><br><span class="line">    int64_t mediaTimeUs;</span><br><span class="line">    <span class="title function_ invoke__">CHECK</span>(accessUnit<span class="punctuation">-&gt;</span><span class="title function_ invoke__">meta</span>()<span class="punctuation">-&gt;</span><span class="title function_ invoke__">findInt64</span>(<span class="string">&quot;timeUs&quot;</span>, &amp;mediaTimeUs));</span><br><span class="line">    <span class="title function_ invoke__">ALOGV</span>(<span class="string">&quot;[%s] feeding input buffer at media time %.3f&quot;</span>,</span><br><span class="line">         mIsAudio ? <span class="string">&quot;audio&quot;</span> : <span class="string">&quot;video&quot;</span>,</span><br><span class="line">         mediaTimeUs / <span class="number">1E6</span>);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">if</span> (mCCDecoder != NULL) &#123;</span><br><span class="line">        mCCDecoder<span class="punctuation">-&gt;</span><span class="title function_ invoke__">decode</span>(accessUnit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    reply<span class="punctuation">-&gt;</span><span class="title function_ invoke__">setBuffer</span>(<span class="string">&quot;buffer&quot;</span>, accessUnit);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们接着看下如何获取索引列表,首先看下onChangeConfiguration3，在这部分代码很长，大家有兴趣可以看下这里面的代码，它的任务主要有如下几点</p>
<ol>
<li>判断audio及Video是否发送变化</li>
<li>根据当前的mFetcherInfos更新resumeMask</li>
<li>如果是有新的Fetcher那么需要新建FetcherInfo</li>
<li>启动对应的Fetcher</li>
<li>检查当前带宽根据带宽切换资源<br>但是最关键的代码在于fetcher-&gt;startAsync,<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">void LiveSession::<span class="built_in">onChangeConfiguration3</span>(const sp&lt;AMessage&gt; &amp;msg) &#123;</span><br><span class="line">    //........</span><br><span class="line">    fetcher-&gt;startAsync(</span><br><span class="line">            sources<span class="selector-attr">[kAudioIndex]</span>,</span><br><span class="line">            sources<span class="selector-attr">[kVideoIndex]</span>,</span><br><span class="line">            sources<span class="selector-attr">[kSubtitleIndex]</span>,</span><br><span class="line">            getMetadataSource(sources, mNewStreamMask, switching),</span><br><span class="line">            startTime<span class="selector-class">.mTimeUs</span> &lt; <span class="number">0</span> ? mLastSeekTimeUs : startTime.mTimeUs,</span><br><span class="line">            startTime.<span class="built_in">getSegmentTimeUs</span>(),</span><br><span class="line">            startTime.mSeq,</span><br><span class="line">            seekMode);</span><br><span class="line">    //.......</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PlaylistFetcher::startAsync</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> sp&lt;AnotherPacketSource&gt; &amp;audioSource,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> sp&lt;AnotherPacketSource&gt; &amp;videoSource,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> sp&lt;AnotherPacketSource&gt; &amp;subtitleSource,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> sp&lt;AnotherPacketSource&gt; &amp;metadataSource,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">int64_t</span> startTimeUs,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">int64_t</span> segmentStartTimeUs,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">int32_t</span> startDiscontinuitySeq,</span></span></span><br><span class="line"><span class="params"><span class="function">        LiveSession::SeekMode seekMode)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    sp&lt;AMessage&gt; msg = <span class="keyword">new</span> <span class="built_in">AMessage</span>(kWhatStart, <span class="keyword">this</span>);</span><br><span class="line">	<span class="comment">//.................</span></span><br><span class="line">    msg-&gt;<span class="built_in">post</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">case kWhatStart:</span><br><span class="line">&#123;</span><br><span class="line">    status_t err = onStart(msg);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">sp</span>&lt;AMessage&gt; notify = mNotify-&gt;</span>dup();</span><br><span class="line">    <span class="function"><span class="title">notify</span>-&gt;</span>setInt32(<span class="string">&quot;what&quot;</span>, kWhatStarted);</span><br><span class="line">    <span class="function"><span class="title">notify</span>-&gt;</span>setInt32(<span class="string">&quot;err&quot;</span>, err);</span><br><span class="line">    <span class="function"><span class="title">notify</span>-&gt;</span>post();</span><br><span class="line">    break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">status_t PlaylistFetcher::on<span class="constructor">Start(<span class="params">const</span> <span class="params">sp</span>&lt;AMessage&gt; &amp;<span class="params">msg</span>)</span> &#123;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//..........</span></span><br><span class="line">    <span class="keyword">if</span> (streamTypeMask &amp; LiveSession::STREAMTYPE_AUDIO) &#123;</span><br><span class="line">        void *ptr;</span><br><span class="line">        <span class="constructor">CHECK(<span class="params">msg</span>-&gt;<span class="params">findPointer</span>(<span class="string">&quot;audioSource&quot;</span>, &amp;<span class="params">ptr</span>)</span>);</span><br><span class="line">        mPacketSources.add(LiveSession::STREAMTYPE_AUDIO,static_cast&lt;AnotherPacketSource *&gt;(ptr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (streamTypeMask &amp; LiveSession::STREAMTYPE_VIDEO) &#123;</span><br><span class="line">        void *ptr;</span><br><span class="line">        <span class="constructor">CHECK(<span class="params">msg</span>-&gt;<span class="params">findPointer</span>(<span class="string">&quot;videoSource&quot;</span>, &amp;<span class="params">ptr</span>)</span>);</span><br><span class="line"></span><br><span class="line">        mPacketSources.add(LiveSession::STREAMTYPE_VIDEO,static_cast&lt;AnotherPacketSource *&gt;(ptr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (streamTypeMask &amp; LiveSession::STREAMTYPE_SUBTITLES) &#123;</span><br><span class="line">        void *ptr;</span><br><span class="line">        <span class="constructor">CHECK(<span class="params">msg</span>-&gt;<span class="params">findPointer</span>(<span class="string">&quot;subtitleSource&quot;</span>, &amp;<span class="params">ptr</span>)</span>);</span><br><span class="line">        mPacketSources.add(LiveSession::STREAMTYPE_SUBTITLES,static_cast&lt;AnotherPacketSource *&gt;(ptr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void *ptr;</span><br><span class="line">    <span class="comment">// metadataSource is not part of streamTypeMask</span></span><br><span class="line">    <span class="keyword">if</span> ((streamTypeMask &amp; (LiveSession::STREAMTYPE_AUDIO <span class="pattern-match">| <span class="constructor">LiveSession</span>::<span class="constructor">STREAMTYPE_VIDEO</span>))</span></span><br><span class="line"><span class="pattern-match">            <span class="operator">&amp;&amp;</span> msg-&gt;find<span class="constructor">Pointer(<span class="string">&quot;metadataSource&quot;</span>, &amp;<span class="params">ptr</span>)</span>) &#123;</span></span><br><span class="line"><span class="pattern-match">        m<span class="constructor">PacketSources</span>.add(<span class="constructor">LiveSession</span>::<span class="constructor">STREAMTYPE_METADATA</span>,static<span class="constructor">_cast</span>&lt;<span class="constructor">AnotherPacketSource</span> <span class="operator">*</span>&gt;(ptr));</span></span><br><span class="line"><span class="pattern-match">    &#125;</span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match">  	<span class="operator">/</span><span class="operator">/</span><span class="operator">...</span><span class="operator">...</span><span class="operator">...</span><span class="operator">...</span><span class="operator">...</span></span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match">    post<span class="constructor">MonitorQueue()</span>;</span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match">    return <span class="constructor">OK</span>;</span></span><br><span class="line"><span class="pattern-match">&#125;</span></span><br><span class="line"><span class="pattern-match"></span></span><br></pre></td></tr></table></figure>

<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void PlaylistFetcher::post<span class="constructor">MonitorQueue(<span class="params">int64_t</span> <span class="params">delayUs</span>, <span class="params">int64_t</span> <span class="params">minDelayUs</span>)</span> &#123;</span><br><span class="line">    int64_t maxDelayUs = delay<span class="constructor">UsToRefreshPlaylist()</span>;</span><br><span class="line">    <span class="keyword">if</span> (maxDelayUs &lt; minDelayUs) &#123;</span><br><span class="line">        maxDelayUs = minDelayUs;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (delayUs &gt; maxDelayUs) &#123;</span><br><span class="line">        <span class="constructor">FLOGV(<span class="string">&quot;Need to refresh playlist in %lld&quot;</span>, (<span class="params">long</span> <span class="params">long</span>)</span>maxDelayUs);</span><br><span class="line">        delayUs = maxDelayUs;</span><br><span class="line">    &#125;</span><br><span class="line">    sp&lt;AMessage&gt; msg = <span class="keyword">new</span> <span class="constructor">AMessage(<span class="params">kWhatMonitorQueue</span>, <span class="params">this</span>)</span>;</span><br><span class="line">    msg-&gt;set<span class="constructor">Int32(<span class="string">&quot;generation&quot;</span>, <span class="params">mMonitorQueueGeneration</span>)</span>;</span><br><span class="line">    msg-&gt;post(delayUs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">case kWhatMonitorQueue:</span><br><span class="line">case kWhatDownloadNext:</span><br><span class="line">&#123;</span><br><span class="line">    int32_t generation;</span><br><span class="line">    <span class="constructor">CHECK(<span class="params">msg</span>-&gt;<span class="params">findInt32</span>(<span class="string">&quot;generation&quot;</span>, &amp;<span class="params">generation</span>)</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (generation != mMonitorQueueGeneration) &#123;</span><br><span class="line">        <span class="comment">// Stale event</span></span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (msg-&gt;what<span class="literal">()</span><span class="operator"> == </span>kWhatMonitorQueue) &#123;</span><br><span class="line">        on<span class="constructor">MonitorQueue()</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        on<span class="constructor">DownloadNext()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PlaylistFetcher::onMonitorQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//.......................</span></span><br><span class="line">    <span class="keyword">if</span> (finalResult == OK &amp;&amp; bufferedDurationUs &lt; kMinBufferedDurationUs) &#123;</span><br><span class="line">        <span class="built_in">FLOGV</span>(<span class="string">&quot;monitoring, buffered=%lld &lt; %lld&quot;</span>,</span><br><span class="line">                (<span class="type">long</span> <span class="type">long</span>)bufferedDurationUs, (<span class="type">long</span> <span class="type">long</span>)kMinBufferedDurationUs);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// delay the next download slightly; hopefully this gives other concurrent fetchers</span></span><br><span class="line">        <span class="comment">// a better chance to run.</span></span><br><span class="line">        <span class="comment">// onDownloadNext();</span></span><br><span class="line">        sp&lt;AMessage&gt; msg = <span class="keyword">new</span> <span class="built_in">AMessage</span>(kWhatDownloadNext, <span class="keyword">this</span>);</span><br><span class="line">        msg-&gt;<span class="built_in">setInt32</span>(<span class="string">&quot;generation&quot;</span>, mMonitorQueueGeneration);</span><br><span class="line">        msg-&gt;<span class="built_in">post</span>(<span class="number">1000l</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// We&#x27;d like to maintain buffering above durationToBufferUs, so try</span></span><br><span class="line">        <span class="comment">// again when buffer just about to go below durationToBufferUs</span></span><br><span class="line">        <span class="comment">// (or after targetDurationUs / 2, whichever is smaller).</span></span><br><span class="line">        <span class="type">int64_t</span> delayUs = bufferedDurationUs - kMinBufferedDurationUs + <span class="number">1000000ll</span>;</span><br><span class="line">        <span class="keyword">if</span> (delayUs &gt; targetDurationUs / <span class="number">2</span>) &#123;</span><br><span class="line">            delayUs = targetDurationUs / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">FLOGV</span>(<span class="string">&quot;pausing for %lld, buffered=%lld &gt; %lld&quot;</span>,</span><br><span class="line">                (<span class="type">long</span> <span class="type">long</span>)delayUs,</span><br><span class="line">                (<span class="type">long</span> <span class="type">long</span>)bufferedDurationUs,</span><br><span class="line">                (<span class="type">long</span> <span class="type">long</span>)kMinBufferedDurationUs);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">postMonitorQueue</span>(delayUs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>initDownloadState 用于在获取TS包之前获取对应的Uri</p>
<figure class="highlight zephir"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> PlaylistFetcher::initDownloadState(</span><br><span class="line">        AString &amp;uri,</span><br><span class="line">        sp&lt;AMessage&gt; &amp;itemMeta,</span><br><span class="line">        int32_t &amp;firstSeqNumberInPlaylist,</span><br><span class="line">        int32_t &amp;lastSeqNumberInPlaylist) &#123;</span><br><span class="line">    status_t err = refreshPlaylist();</span><br><span class="line">    firstSeqNumberInPlaylist = <span class="number">0</span>;</span><br><span class="line">    lastSeqNumberInPlaylist = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> discontinuity = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mPlaylist != NULL) &#123;</span><br><span class="line">        mPlaylist-&gt;getSeqNumberRange(</span><br><span class="line">                &amp;firstSeqNumberInPlaylist, &amp;lastSeqNumberInPlaylist);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mDiscontinuitySeq &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            mDiscontinuitySeq = mPlaylist-&gt;getDiscontinuitySeq();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mSegmentFirstPTS = <span class="number">-1</span>ll;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mPlaylist != NULL &amp;&amp; mSeqNumber &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        CHECK_GE(mStartTimeUs, <span class="number">0</span>ll);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mSegmentStartTimeUs &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!mPlaylist-&gt;isComplete() &amp;&amp; !mPlaylist-&gt;isEvent()) &#123;</span><br><span class="line">                <span class="comment">// If this is a live session, start 3 segments from the end on connect</span></span><br><span class="line">                mSeqNumber = lastSeqNumberInPlaylist - <span class="number">3</span>;</span><br><span class="line">                <span class="keyword">if</span> (mSeqNumber &lt; firstSeqNumberInPlaylist) &#123;</span><br><span class="line">                    mSeqNumber = firstSeqNumberInPlaylist;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// When seeking mSegmentStartTimeUs is unavailable (&lt; 0), we</span></span><br><span class="line">                <span class="comment">// use mStartTimeUs (client supplied timestamp) to determine both start segment</span></span><br><span class="line">                <span class="comment">// and relative position inside a segment</span></span><br><span class="line">                mSeqNumber = getSeqNumberForTime(mStartTimeUs);</span><br><span class="line">                mStartTimeUs -= getSegmentStartTimeUs(mSeqNumber);</span><br><span class="line">            &#125;</span><br><span class="line">            mStartTimeUsRelative = <span class="keyword">true</span>;</span><br><span class="line">            FLOGV(<span class="string">&quot;Initial sequence number for time %lld is %d from (%d .. %d)&quot;</span>,</span><br><span class="line">                    (<span class="keyword">long</span> <span class="keyword">long</span>)mStartTimeUs, mSeqNumber, firstSeqNumberInPlaylist,</span><br><span class="line">                    lastSeqNumberInPlaylist);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// When adapting or track switching, mSegmentStartTimeUs (relative</span></span><br><span class="line">            <span class="comment">// to media time 0) is used to determine the start segment; mStartTimeUs (absolute</span></span><br><span class="line">            <span class="comment">// timestamps coming from the media container) is used to determine the position</span></span><br><span class="line">            <span class="comment">// inside a segments.</span></span><br><span class="line">            <span class="keyword">if</span> (mStreamTypeMask != LiveSession::STREAMTYPE_SUBTITLES</span><br><span class="line">                    &amp;&amp; mSeekMode != LiveSession::kSeekModeNextSample) &#123;</span><br><span class="line">                <span class="comment">// avoid double fetch/decode</span></span><br><span class="line">                <span class="comment">// Use (mSegmentStartTimeUs + 1/2 * targetDurationUs) to search</span></span><br><span class="line">                <span class="comment">// for the starting segment in new variant.</span></span><br><span class="line">                <span class="comment">// If the two variants&#x27; segments are aligned, this gives the</span></span><br><span class="line">                <span class="comment">// next segment. If they&#x27;re not aligned, this gives the segment</span></span><br><span class="line">                <span class="comment">// that overlaps no more than 1/2 * targetDurationUs.</span></span><br><span class="line">                mSeqNumber = getSeqNumberForTime(mSegmentStartTimeUs</span><br><span class="line">                        + mPlaylist-&gt;getTargetDuration() / <span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mSeqNumber = getSeqNumberForTime(mSegmentStartTimeUs);</span><br><span class="line">            &#125;</span><br><span class="line">            ssize_t minSeq = getSeqNumberForDiscontinuity(mDiscontinuitySeq);</span><br><span class="line">            <span class="keyword">if</span> (mSeqNumber &lt; minSeq) &#123;</span><br><span class="line">                mSeqNumber = minSeq;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mSeqNumber &lt; firstSeqNumberInPlaylist) &#123;</span><br><span class="line">                mSeqNumber = firstSeqNumberInPlaylist;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mSeqNumber &gt; lastSeqNumberInPlaylist) &#123;</span><br><span class="line">                mSeqNumber = lastSeqNumberInPlaylist;</span><br><span class="line">            &#125;</span><br><span class="line">            FLOGV(<span class="string">&quot;Initial sequence number is %d from (%d .. %d)&quot;</span>,</span><br><span class="line">                    mSeqNumber, firstSeqNumberInPlaylist,</span><br><span class="line">                    lastSeqNumberInPlaylist);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if mPlaylist is NULL then err must be non-OK; but the other way around might not be true</span></span><br><span class="line">    <span class="keyword">if</span> (mSeqNumber &lt; firstSeqNumberInPlaylist</span><br><span class="line">            || mSeqNumber &gt; lastSeqNumberInPlaylist</span><br><span class="line">            || err != OK) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((err != OK || !mPlaylist-&gt;isComplete()) &amp;&amp; mNumRetries &lt; kMaxNumRetries) &#123;</span><br><span class="line">            ++mNumRetries;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mSeqNumber &gt; lastSeqNumberInPlaylist || err != OK) &#123;</span><br><span class="line">                <span class="comment">// make sure we reach this retry logic on refresh failures</span></span><br><span class="line">                <span class="comment">// by adding an err != OK clause to all enclosing if&#x27;s.</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// refresh in increasing fraction (1/2, 1/3, ...) of the</span></span><br><span class="line">                <span class="comment">// playlist&#x27;s target duration or 3 seconds, whichever is less</span></span><br><span class="line">                int64_t delayUs = kMaxMonitorDelayUs;</span><br><span class="line">                <span class="keyword">if</span> (mPlaylist != NULL) &#123;</span><br><span class="line">                    delayUs = mPlaylist-&gt;size() * mPlaylist-&gt;getTargetDuration()</span><br><span class="line">                            / (<span class="number">1</span> + mNumRetries);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (delayUs &gt; kMaxMonitorDelayUs) &#123;</span><br><span class="line">                    delayUs = kMaxMonitorDelayUs;</span><br><span class="line">                &#125;</span><br><span class="line">                FLOGV(<span class="string">&quot;sequence number high: %d from (%d .. %d), &quot;</span></span><br><span class="line">                      <span class="string">&quot;monitor in %lld (retry=%d)&quot;</span>,</span><br><span class="line">                        mSeqNumber, firstSeqNumberInPlaylist,</span><br><span class="line">                        lastSeqNumberInPlaylist, (<span class="keyword">long</span> <span class="keyword">long</span>)delayUs, mNumRetries);</span><br><span class="line">                postMonitorQueue(delayUs);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (err != OK) &#123;</span><br><span class="line">                notifyError(err);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// we&#x27;ve missed the boat, let&#x27;s start 3 segments prior to the latest sequence</span></span><br><span class="line">            <span class="comment">// number available and signal a discontinuity.</span></span><br><span class="line"></span><br><span class="line">            ALOGI(<span class="string">&quot;We&#x27;ve missed the boat, restarting playback.&quot;</span></span><br><span class="line">                  <span class="string">&quot;  mStartup=%d, was  looking for %d in %d-%d&quot;</span>,</span><br><span class="line">                    mStartup, mSeqNumber, firstSeqNumberInPlaylist,</span><br><span class="line">                    lastSeqNumberInPlaylist);</span><br><span class="line">            <span class="keyword">if</span> (mStopParams != NULL) &#123;</span><br><span class="line">                <span class="comment">// we should have kept on fetching until we hit the boundaries in mStopParams,</span></span><br><span class="line">                <span class="comment">// but since the segments we are supposed to fetch have already rolled off</span></span><br><span class="line">                <span class="comment">// the playlist, i.e. we have already missed the boat, we inevitably have to</span></span><br><span class="line">                <span class="comment">// skip.</span></span><br><span class="line">                notifyStopReached();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mSeqNumber = lastSeqNumberInPlaylist - <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">if</span> (mSeqNumber &lt; firstSeqNumberInPlaylist) &#123;</span><br><span class="line">                mSeqNumber = firstSeqNumberInPlaylist;</span><br><span class="line">            &#125;</span><br><span class="line">            discontinuity = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// fall through</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (mPlaylist != NULL) &#123;</span><br><span class="line">                ALOGE(<span class="string">&quot;Cannot find sequence number %d in playlist &quot;</span></span><br><span class="line">                     <span class="string">&quot;(contains %d - %d)&quot;</span>,</span><br><span class="line">                     mSeqNumber, firstSeqNumberInPlaylist,</span><br><span class="line">                      firstSeqNumberInPlaylist + (int32_t)mPlaylist-&gt;size() - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (mTSParser != NULL) &#123;</span><br><span class="line">                    mTSParser-&gt;signalEOS(ERROR_END_OF_STREAM);</span><br><span class="line">                    <span class="comment">// Use an empty buffer; we don&#x27;t have any new data, just want to extract</span></span><br><span class="line">                    <span class="comment">// potential new access units after flush.  Reset mSeqNumber to</span></span><br><span class="line">                    <span class="comment">// lastSeqNumberInPlaylist such that we set the correct access unit</span></span><br><span class="line">                    <span class="comment">// properties in extractAndQueueAccessUnitsFromTs.</span></span><br><span class="line">                    sp&lt;ABuffer&gt; buffer = <span class="keyword">new</span> ABuffer(<span class="number">0</span>);</span><br><span class="line">                    mSeqNumber = lastSeqNumberInPlaylist;</span><br><span class="line">                    extractAndQueueAccessUnitsFromTs(buffer);</span><br><span class="line">                &#125;</span><br><span class="line">                notifyError(ERROR_END_OF_STREAM);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// It&#x27;s possible that we were never able to download the playlist.</span></span><br><span class="line">                <span class="comment">// In this case we should notify error, instead of EOS, as EOS during</span></span><br><span class="line">                <span class="comment">// prepare means we succeeded in downloading everything.</span></span><br><span class="line">                ALOGE(<span class="string">&quot;Failed to download playlist!&quot;</span>);</span><br><span class="line">                notifyError(ERROR_IO);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mNumRetries = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    CHECK(mPlaylist-&gt;itemAt(</span><br><span class="line">                mSeqNumber - firstSeqNumberInPlaylist,</span><br><span class="line">                &amp;uri,</span><br><span class="line">                &amp;itemMeta));</span><br><span class="line"></span><br><span class="line">    CHECK(itemMeta-&gt;findInt32(<span class="string">&quot;discontinuity-sequence&quot;</span>, &amp;mDiscontinuitySeq));</span><br><span class="line"></span><br><span class="line">    int32_t val;</span><br><span class="line">    <span class="keyword">if</span> (itemMeta-&gt;findInt32(<span class="string">&quot;discontinuity&quot;</span>, &amp;val) &amp;&amp; val != <span class="number">0</span>) &#123;</span><br><span class="line">        discontinuity = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mLastDiscontinuitySeq &gt;= <span class="number">0</span></span><br><span class="line">            &amp;&amp; mDiscontinuitySeq != mLastDiscontinuitySeq) &#123;</span><br><span class="line">        <span class="comment">// Seek jumped to a new discontinuity sequence. We need to signal</span></span><br><span class="line">        <span class="comment">// a format change to decoder. Decoder needs to shutdown and be</span></span><br><span class="line">        <span class="comment">// created again if seamless format change is unsupported.</span></span><br><span class="line">        FLOGV(<span class="string">&quot;saw discontinuity: mStartup %d, mLastDiscontinuitySeq %d, &quot;</span></span><br><span class="line">                <span class="string">&quot;mDiscontinuitySeq %d, mStartTimeUs %lld&quot;</span>,</span><br><span class="line">                mStartup, mLastDiscontinuitySeq, mDiscontinuitySeq, (<span class="keyword">long</span> <span class="keyword">long</span>)mStartTimeUs);</span><br><span class="line">        discontinuity = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mLastDiscontinuitySeq = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// decrypt a junk buffer to prefetch key; since a session uses only one http connection,</span></span><br><span class="line">    <span class="comment">// this avoids interleaved connections to the key and segment file.</span></span><br><span class="line">    &#123;</span><br><span class="line">        sp&lt;ABuffer&gt; junk = <span class="keyword">new</span> ABuffer(<span class="number">16</span>);</span><br><span class="line">        junk-&gt;setRange(<span class="number">0</span>, <span class="number">16</span>);</span><br><span class="line">        status_t err = decryptBuffer(mSeqNumber - firstSeqNumberInPlaylist, junk,</span><br><span class="line">                <span class="keyword">true</span> <span class="comment">/* first */</span>);</span><br><span class="line">        <span class="keyword">if</span> (err == ERROR_NOT_CONNECTED) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (err != OK) &#123;</span><br><span class="line">            notifyError(err);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((mStartup &amp;&amp; !mTimeChangeSignaled) || discontinuity) &#123;</span><br><span class="line">        <span class="comment">// We need to signal a time discontinuity to ATSParser on the</span></span><br><span class="line">        <span class="comment">// first segment after start, or on a discontinuity segment.</span></span><br><span class="line">        <span class="comment">// Setting mNextPTSTimeUs informs extractAndQueueAccessUnitsXX()</span></span><br><span class="line">        <span class="comment">// to send the time discontinuity.</span></span><br><span class="line">        <span class="keyword">if</span> (mPlaylist-&gt;isComplete() || mPlaylist-&gt;isEvent()) &#123;</span><br><span class="line">            <span class="comment">// If this was a live event this made no sense since</span></span><br><span class="line">            <span class="comment">// we don&#x27;t have access to all the segment before the current</span></span><br><span class="line">            <span class="comment">// one.</span></span><br><span class="line">            mNextPTSTimeUs = getSegmentStartTimeUs(mSeqNumber);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Setting mTimeChangeSignaled to true, so that if start time</span></span><br><span class="line">        <span class="comment">// searching goes into 2nd segment (without a discontinuity),</span></span><br><span class="line">        <span class="comment">// we don&#x27;t reset time again. It causes corruption when pending</span></span><br><span class="line">        <span class="comment">// data in ATSParser is cleared.</span></span><br><span class="line">        mTimeChangeSignaled = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (discontinuity) &#123;</span><br><span class="line">        ALOGI(<span class="string">&quot;queueing discontinuity (explicit=%d)&quot;</span>, discontinuity);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Signal a format discontinuity to ATSParser to clear partial data</span></span><br><span class="line">        <span class="comment">// from previous streams. Not doing this causes bitstream corruption.</span></span><br><span class="line">        <span class="keyword">if</span> (mTSParser != NULL) &#123;</span><br><span class="line">            mTSParser-&gt;signalDiscontinuity(</span><br><span class="line">                    ATSParser::DISCONTINUITY_FORMATCHANGE, NULL <span class="comment">/* extra */</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        queueDiscontinuity(</span><br><span class="line">                ATSParser::DISCONTINUITY_FORMAT_ONLY,</span><br><span class="line">                NULL <span class="comment">/* extra */</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mStartup &amp;&amp; mStartTimeUsRelative &amp;&amp; mFirstPTSValid) &#123;</span><br><span class="line">            <span class="comment">// This means we guessed mStartTimeUs to be in the previous</span></span><br><span class="line">            <span class="comment">// segment (likely very close to the end), but either video or</span></span><br><span class="line">            <span class="comment">// audio has not found start by the end of that segment.</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">// If this new segment is not a discontinuity, keep searching.</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">// If this new segment even got a discontinuity marker, just</span></span><br><span class="line">            <span class="comment">// set mStartTimeUs=0, and take all samples from now on.</span></span><br><span class="line">            mStartTimeUs = <span class="number">0</span>;</span><br><span class="line">            mFirstPTSValid = <span class="keyword">false</span>;</span><br><span class="line">            mIDRFound = <span class="keyword">false</span>;</span><br><span class="line">            mVideoBuffer-&gt;clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    FLOGV(<span class="string">&quot;fetching segment %d from (%d .. %d)&quot;</span>,</span><br><span class="line">            mSeqNumber, firstSeqNumberInPlaylist, lastSeqNumberInPlaylist);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">void PlaylistFetcher::onDownloadNext() &#123;</span><br><span class="line">    AString uri;</span><br><span class="line">    sp&lt;AMessage&gt; itemMeta;</span><br><span class="line">    sp&lt;ABuffer&gt; buffer;</span><br><span class="line">    sp&lt;ABuffer&gt; tsBuffer;</span><br><span class="line">    int32_t firstSeqNumberInPlaylist = <span class="number">0</span>;</span><br><span class="line">    int32_t lastSeqNumberInPlaylist = <span class="number">0</span>;</span><br><span class="line">    bool connectHTTP = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">if</span> (mDownloadState-&gt;</span>hasSavedState()) &#123;</span><br><span class="line">        <span class="function"><span class="title">mDownloadState</span>-&gt;</span>restoreState(</span><br><span class="line">                uri,</span><br><span class="line">                itemMeta,</span><br><span class="line">                buffer,</span><br><span class="line">                tsBuffer,</span><br><span class="line">                firstSeqNumberInPlaylist,</span><br><span class="line">                lastSeqNumberInPlaylist);</span><br><span class="line">        connectHTTP = <span class="literal">false</span>;</span><br><span class="line">        FLOGV(<span class="string">&quot;resuming: &#x27;%s&#x27;&quot;</span>, uri.c_str());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!initDownloadState(</span><br><span class="line">                uri,</span><br><span class="line">                itemMeta,</span><br><span class="line">                firstSeqNumberInPlaylist,</span><br><span class="line">                lastSeqNumberInPlaylist)) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        FLOGV(<span class="string">&quot;fetching: &#x27;%s&#x27;&quot;</span>, uri.c_str());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int64_t range_offset, range_length;</span><br><span class="line">    <span class="function"><span class="title">if</span> (!itemMeta-&gt;</span>findInt64(<span class="string">&quot;range-offset&quot;</span>, &amp;range_offset)</span><br><span class="line">            || !<span class="function"><span class="title">itemMeta</span>-&gt;</span>findInt64(<span class="string">&quot;range-length&quot;</span>, &amp;range_length)) &#123;</span><br><span class="line">        range_offset = <span class="number">0</span>;</span><br><span class="line">        range_length = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// block-wise download</span></span><br><span class="line">    bool shouldPause = <span class="literal">false</span>;</span><br><span class="line">    ssize_t bytesRead;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        int64_t startUs = ALooper::GetNowUs();</span><br><span class="line">        <span class="comment">//下载</span></span><br><span class="line">        <span class="function"><span class="title">bytesRead</span> = mHTTPDownloader-&gt;</span>fetchBlock(</span><br><span class="line">                uri.c_str(), &amp;buffer, range_offset, range_length, kDownloadBlockSize,</span><br><span class="line">                NULL <span class="comment">/* actualURL */</span>, connectHTTP);</span><br><span class="line">        int64_t delayUs = ALooper::GetNowUs() - startUs;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (bytesRead == ERROR_NOT_CONNECTED) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (bytesRead &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            status_t err = bytesRead;</span><br><span class="line">            ALOGE(<span class="string">&quot;failed to fetch .ts segment at url &#x27;%s&#x27;&quot;</span>, uri.c_str());</span><br><span class="line">            notifyError(err);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// add sample for bandwidth estimation, excluding samples from subtitles (as</span></span><br><span class="line">        <span class="comment">// its too small), or during startup/resumeUntil (when we could have more than</span></span><br><span class="line">        <span class="comment">// one connection open which affects bandwidth)</span></span><br><span class="line">        <span class="keyword">if</span> (!mStartup &amp;&amp; mStopParams == NULL &amp;&amp; bytesRead &gt; <span class="number">0</span></span><br><span class="line">                &amp;&amp; (mStreamTypeMask</span><br><span class="line">                        &amp; (LiveSession::STREAMTYPE_AUDIO</span><br><span class="line">                        | LiveSession::STREAMTYPE_VIDEO))) &#123;</span><br><span class="line">            <span class="function"><span class="title">mSession</span>-&gt;</span>addBandwidthMeasurement(bytesRead, delayUs);</span><br><span class="line">            <span class="keyword">if</span> (delayUs &gt; <span class="number">2000000</span>ll) &#123;</span><br><span class="line">                FLOGV(<span class="string">&quot;bytesRead %zd took %.2f seconds - abnormal bandwidth dip&quot;</span>,</span><br><span class="line">                        bytesRead, (double)delayUs / <span class="number">1.0</span>e6);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        connectHTTP = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        CHECK(buffer != NULL);</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">size_t</span> size = buffer-&gt;</span>size();</span><br><span class="line">        <span class="comment">// Set decryption range.</span></span><br><span class="line">        <span class="function"><span class="title">buffer</span>-&gt;</span>setRange(size - bytesRead, bytesRead);</span><br><span class="line">        <span class="comment">//通过获取的key解密buffer</span></span><br><span class="line">        status_t err = decryptBuffer(mSeqNumber - firstSeqNumberInPlaylist, buffer,</span><br><span class="line">                <span class="function"><span class="title">buffer</span>-&gt;</span>offset() == <span class="number">0</span> <span class="comment">/* first */</span>);</span><br><span class="line">        <span class="comment">// Unset decryption range.</span></span><br><span class="line">        <span class="function"><span class="title">buffer</span>-&gt;</span>setRange(<span class="number">0</span>, size);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (err != OK) &#123;</span><br><span class="line">            ALOGE(<span class="string">&quot;decryptBuffer failed w/ error %d&quot;</span>, err);</span><br><span class="line"></span><br><span class="line">            notifyError(err);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        bool startUp = mStartup; <span class="comment">// save current start up state</span></span><br><span class="line"></span><br><span class="line">        err = OK;</span><br><span class="line">        <span class="keyword">if</span> (bufferStartsWithTsSyncByte(buffer)) &#123;</span><br><span class="line">            <span class="comment">// Incremental extraction is only supported for MPEG2 transport streams.</span></span><br><span class="line">            <span class="keyword">if</span> (tsBuffer == NULL) &#123;</span><br><span class="line">                <span class="function"><span class="title">tsBuffer</span> = new ABuffer(buffer-&gt;</span><span class="function"><span class="title">data</span>(), buffer-&gt;</span>capacity());</span><br><span class="line">                <span class="function"><span class="title">tsBuffer</span>-&gt;</span>setRange(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            &#125; <span class="function"><span class="title">else</span> <span class="keyword">if</span> (tsBuffer-&gt;</span><span class="function"><span class="title">capacity</span>() != buffer-&gt;</span>capacity()) &#123;</span><br><span class="line">                <span class="function"><span class="title">size_t</span> tsOff = tsBuffer-&gt;</span><span class="function"><span class="title">offset</span>(), tsSize = tsBuffer-&gt;</span>size();</span><br><span class="line">                <span class="function"><span class="title">tsBuffer</span> = new ABuffer(buffer-&gt;</span><span class="function"><span class="title">data</span>(), buffer-&gt;</span>capacity());</span><br><span class="line">                <span class="function"><span class="title">tsBuffer</span>-&gt;</span>setRange(tsOff, tsSize);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="title">tsBuffer</span>-&gt;</span><span class="function"><span class="title">setRange</span>(tsBuffer-&gt;</span><span class="function"><span class="title">offset</span>(), tsBuffer-&gt;</span>size() + bytesRead);</span><br><span class="line">            <span class="comment">//将解密后的buffer递给解码器</span></span><br><span class="line">            err = extractAndQueueAccessUnitsFromTs(tsBuffer);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (err == -EAGAIN) &#123;</span><br><span class="line">            <span class="comment">// starting sequence number too low/high</span></span><br><span class="line">            mTSParser.clear();</span><br><span class="line">            <span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; mPacketSources.size(); i++) &#123;</span><br><span class="line">                sp&lt;AnotherPacketSource&gt; packetSource = mPacketSources.valueAt(i);</span><br><span class="line">                <span class="function"><span class="title">packetSource</span>-&gt;</span>clear();</span><br><span class="line">            &#125;</span><br><span class="line">            postMonitorQueue();</span><br><span class="line">            return;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (err == ERROR_OUT_OF_RANGE) &#123;</span><br><span class="line">            <span class="comment">// reached stopping point</span></span><br><span class="line">            notifyStopReached();</span><br><span class="line">            return;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (err != OK) &#123;</span><br><span class="line">            notifyError(err);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// If we&#x27;re switching, post start notification</span></span><br><span class="line">        <span class="comment">// this should only be posted when the last chunk is full processed by TSParser</span></span><br><span class="line">        <span class="keyword">if</span> (mSeekMode != LiveSession::kSeekModeExactPosition &amp;&amp; startUp != mStartup) &#123;</span><br><span class="line">            CHECK(mStartTimeUsNotify != NULL);</span><br><span class="line">            <span class="function"><span class="title">mStartTimeUsNotify</span>-&gt;</span>post();</span><br><span class="line">            mStartTimeUsNotify.clear();</span><br><span class="line">            shouldPause = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (shouldPause || shouldPauseDownload()) &#123;</span><br><span class="line">            <span class="comment">// save state and return if this is not the last chunk,</span></span><br><span class="line">            <span class="comment">// leaving the fetcher in paused state.</span></span><br><span class="line">            <span class="keyword">if</span> (bytesRead != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="function"><span class="title">mDownloadState</span>-&gt;</span>saveState(</span><br><span class="line">                        uri,</span><br><span class="line">                        itemMeta,</span><br><span class="line">                        buffer,</span><br><span class="line">                        tsBuffer,</span><br><span class="line">                        firstSeqNumberInPlaylist,</span><br><span class="line">                        lastSeqNumberInPlaylist);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            shouldPause = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (bytesRead != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bufferStartsWithTsSyncByte(buffer)) &#123;</span><br><span class="line">        <span class="comment">// If we don&#x27;t see a stream in the program table after fetching a full ts segment</span></span><br><span class="line">        <span class="comment">// mark it as nonexistent.</span></span><br><span class="line">        ATSParser::SourceType srcTypes[] =</span><br><span class="line">                &#123; ATSParser::VIDEO, ATSParser::AUDIO &#125;;</span><br><span class="line">        LiveSession::StreamType streamTypes[] =</span><br><span class="line">                &#123; LiveSession::STREAMTYPE_VIDEO, LiveSession::STREAMTYPE_AUDIO &#125;;</span><br><span class="line">        const size_t kNumTypes = NELEM(srcTypes);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; kNumTypes; i++) &#123;</span><br><span class="line">            ATSParser::SourceType srcType = srcTypes[i];</span><br><span class="line">            LiveSession::StreamType streamType = streamTypes[i];</span><br><span class="line"></span><br><span class="line">            sp&lt;AnotherPacketSource&gt; source =</span><br><span class="line">                static_cast&lt;AnotherPacketSource *&gt;(</span><br><span class="line">                    <span class="function"><span class="title">mTSParser</span>-&gt;</span>getSource(srcType).get());</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="title">if</span> (!mTSParser-&gt;</span>hasSource(srcType)) &#123;</span><br><span class="line">                ALOGW(<span class="string">&quot;MPEG2 Transport stream does not contain %s data.&quot;</span>,</span><br><span class="line">                      srcType == ATSParser::VIDEO ? <span class="string">&quot;video&quot;</span> : <span class="string">&quot;audio&quot;</span>);</span><br><span class="line"></span><br><span class="line">                mStreamTypeMask &amp;= ~streamType;</span><br><span class="line">                mPacketSources.removeItem(streamType);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (checkDecryptPadding(buffer) != OK) &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;Incorrect padding bytes after decryption.&quot;</span>);</span><br><span class="line">        notifyError(ERROR_MALFORMED);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tsBuffer != NULL) &#123;</span><br><span class="line">        AString method;</span><br><span class="line">        CHECK(<span class="function"><span class="title">buffer</span>-&gt;</span><span class="function"><span class="title">meta</span>()-&gt;</span>findString(<span class="string">&quot;cipher-method&quot;</span>, &amp;method));</span><br><span class="line">        <span class="function"><span class="title">if</span> ((tsBuffer-&gt;</span>size() &gt; <span class="number">0</span> &amp;&amp; method == <span class="string">&quot;NONE&quot;</span>)</span><br><span class="line">                || <span class="function"><span class="title">tsBuffer</span>-&gt;</span>size() &gt; <span class="number">16</span>) &#123;</span><br><span class="line">            ALOGE(<span class="string">&quot;MPEG2 transport stream is not an even multiple of 188 &quot;</span></span><br><span class="line">                    <span class="string">&quot;bytes in length.&quot;</span>);</span><br><span class="line">            notifyError(ERROR_MALFORMED);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// bulk extract non-ts files</span></span><br><span class="line">    bool startUp = mStartup;</span><br><span class="line">    <span class="keyword">if</span> (tsBuffer == NULL) &#123;</span><br><span class="line">        status_t err = extractAndQueueAccessUnits(buffer, itemMeta);</span><br><span class="line">        <span class="keyword">if</span> (err == -EAGAIN) &#123;</span><br><span class="line">            <span class="comment">// starting sequence number too low/high</span></span><br><span class="line">            postMonitorQueue();</span><br><span class="line">            return;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (err == ERROR_OUT_OF_RANGE) &#123;</span><br><span class="line">            <span class="comment">// reached stopping point</span></span><br><span class="line">            notifyStopReached();</span><br><span class="line">            return;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (err != OK) &#123;</span><br><span class="line">            notifyError(err);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ++mSeqNumber;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if adapting, pause after found the next starting point</span></span><br><span class="line">    <span class="keyword">if</span> (mSeekMode != LiveSession::kSeekModeExactPosition &amp;&amp; startUp != mStartup) &#123;</span><br><span class="line">        CHECK(mStartTimeUsNotify != NULL);</span><br><span class="line">        <span class="function"><span class="title">mStartTimeUsNotify</span>-&gt;</span>post();</span><br><span class="line">        mStartTimeUsNotify.clear();</span><br><span class="line">        shouldPause = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!shouldPause) &#123;</span><br><span class="line">        postMonitorQueue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>判断是否需要切换带宽</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="built_in">bool</span> LiveSession::switch<span class="constructor">BandwidthIfNeeded(<span class="params">bool</span> <span class="params">bufferHigh</span>, <span class="params">bool</span> <span class="params">bufferLow</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// no need to check bandwidth if we only have 1 bandwidth settings</span></span><br><span class="line"></span><br><span class="line">    int32_t bandwidthBps, shortTermBps;</span><br><span class="line">    <span class="built_in">bool</span> isStable;</span><br><span class="line">    <span class="comment">//调用estimateBandwidth预测带宽</span></span><br><span class="line">    <span class="keyword">if</span> (mBandwidthEstimator-&gt;estimate<span class="constructor">Bandwidth(&amp;<span class="params">bandwidthBps</span>, &amp;<span class="params">isStable</span>, &amp;<span class="params">shortTermBps</span>)</span>) &#123;</span><br><span class="line">        <span class="constructor">ALOGV(<span class="string">&quot;bandwidth estimated at %.2f kbps, &quot;</span><span class="string">&quot;stable %d, shortTermBps %.2f kbps&quot;</span>,<span class="params">bandwidthBps</span> <span class="operator">/</span> 1024.0f, <span class="params">isStable</span>, <span class="params">shortTermBps</span> <span class="operator">/</span> 1024.0f)</span>;</span><br><span class="line">        mLastBandwidthBps = bandwidthBps;</span><br><span class="line">        mLastBandwidthStable = isStable;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="constructor">ALOGV(<span class="string">&quot;no bandwidth estimate.&quot;</span>)</span>;</span><br><span class="line">        return <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int32_t curBandwidth = mBandwidthItems.item<span class="constructor">At(<span class="params">mCurBandwidthIndex</span>)</span>.mBandwidth;</span><br><span class="line">    <span class="comment">// canSwithDown and canSwitchUp can&#x27;t both be true.</span></span><br><span class="line">    <span class="comment">// we only want to switch up when measured bw is 120% higher than current variant,</span></span><br><span class="line">    <span class="comment">// and we only want to switch down when measured bw is below current variant.</span></span><br><span class="line">    <span class="built_in">bool</span> canSwitchDown = bufferLow<span class="operator"> &amp;&amp; </span>(bandwidthBps &lt; (int32_t)curBandwidth);</span><br><span class="line">    <span class="built_in">bool</span> canSwitchUp = bufferHigh<span class="operator"> &amp;&amp; </span>(bandwidthBps &gt; (int32_t)curBandwidth<span class="operator"> * </span><span class="number">12</span><span class="operator"> / </span><span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (canSwitchDown<span class="operator"> || </span>canSwitchUp) &#123;</span><br><span class="line">        <span class="comment">// bandwidth estimating has some delay, if we have to downswitch when</span></span><br><span class="line">        <span class="comment">// it hasn&#x27;t stabilized, use the short term to guess real bandwidth,</span></span><br><span class="line">        <span class="comment">// since it may be dropping too fast.</span></span><br><span class="line">        <span class="comment">// (note this doesn&#x27;t apply to upswitch, always use longer average there)</span></span><br><span class="line">        <span class="keyword">if</span> (!isStable<span class="operator"> &amp;&amp; </span>canSwitchDown) &#123;</span><br><span class="line">            <span class="keyword">if</span> (shortTermBps &lt; bandwidthBps) &#123;</span><br><span class="line">                bandwidthBps = shortTermBps;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//获取要修改带宽数值index</span></span><br><span class="line">        ssize_t bandwidthIndex = get<span class="constructor">BandwidthIndex(<span class="params">bandwidthBps</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// it&#x27;s possible that we&#x27;re checking for canSwitchUp case, but the returned</span></span><br><span class="line">        <span class="comment">// bandwidthIndex is &lt; mCurBandwidthIndex, as getBandwidthIndex() only uses 70%</span></span><br><span class="line">        <span class="comment">// of measured bw. In that case we don&#x27;t want to do anything, since we have</span></span><br><span class="line">        <span class="comment">// both enough buffer and enough bw.</span></span><br><span class="line">        <span class="keyword">if</span> ((canSwitchUp<span class="operator"> &amp;&amp; </span>bandwidthIndex &gt; mCurBandwidthIndex)<span class="operator"></span></span><br><span class="line"><span class="operator">         || </span>(canSwitchDown<span class="operator"> &amp;&amp; </span>bandwidthIndex &lt; mCurBandwidthIndex)) &#123;</span><br><span class="line">            <span class="comment">// if not yet prepared, just restart again with new bw index.</span></span><br><span class="line">            <span class="comment">// this is faster and playback experience is cleaner.</span></span><br><span class="line">            <span class="comment">//修改配置，包括重启各种资源</span></span><br><span class="line">            change<span class="constructor">Configuration(<span class="params">mInPreparationPhase</span> ? 0 : -1ll, <span class="params">bandwidthIndex</span>)</span>;</span><br><span class="line">            return <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">LiveSession::getBandwidthIndex</span><span class="params">(<span class="type">int32_t</span> bandwidthBps)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mBandwidthItems.<span class="built_in">size</span>() &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// shouldn&#x27;t be here if we only have 1 bandwidth, check</span></span><br><span class="line">        <span class="comment">// logic to get rid of redundant bandwidth polling</span></span><br><span class="line">        <span class="built_in">ALOGW</span>(<span class="string">&quot;getBandwidthIndex() called for single bandwidth playlist!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 1</span></span><br><span class="line">    <span class="type">char</span> value[PROPERTY_VALUE_MAX];</span><br><span class="line">    <span class="type">ssize_t</span> index = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">property_get</span>(<span class="string">&quot;media.httplive.bw-index&quot;</span>, value, <span class="literal">NULL</span>)) &#123;</span><br><span class="line">        <span class="type">char</span> *end;</span><br><span class="line">        index = <span class="built_in">strtol</span>(value, &amp;end, <span class="number">10</span>);</span><br><span class="line">        <span class="built_in">CHECK</span>(end &gt; value &amp;&amp; *end == <span class="string">&#x27;\0&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (index &gt;= <span class="number">0</span> &amp;&amp; (<span class="type">size_t</span>)index &gt;= mBandwidthItems.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            index = mBandwidthItems.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">char</span> value[PROPERTY_VALUE_MAX];</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">property_get</span>(<span class="string">&quot;media.httplive.max-bw&quot;</span>, value, <span class="literal">NULL</span>)) &#123;</span><br><span class="line">            <span class="type">char</span> *end;</span><br><span class="line">            <span class="type">long</span> maxBw = <span class="built_in">strtoul</span>(value, &amp;end, <span class="number">10</span>);</span><br><span class="line">            <span class="keyword">if</span> (end &gt; value &amp;&amp; *end == <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (maxBw &gt; <span class="number">0</span> &amp;&amp; bandwidthBps &gt; maxBw) &#123;</span><br><span class="line">                    <span class="built_in">ALOGV</span>(<span class="string">&quot;bandwidth capped to %ld bps&quot;</span>, maxBw);</span><br><span class="line">                    bandwidthBps = maxBw;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Pick the highest bandwidth stream that&#x27;s not currently blacklisted</span></span><br><span class="line">        <span class="comment">// below or equal to estimated bandwidth.</span></span><br><span class="line"></span><br><span class="line">        index = mBandwidthItems.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">ssize_t</span> lowestBandwidth = <span class="built_in">getLowestValidBandwidthIndex</span>();</span><br><span class="line">        <span class="keyword">while</span> (index &gt; lowestBandwidth) &#123;</span><br><span class="line">            <span class="comment">// be conservative (70%) to avoid overestimating and immediately</span></span><br><span class="line">            <span class="comment">// switching down again.</span></span><br><span class="line">            <span class="type">size_t</span> adjustedBandwidthBps = bandwidthBps * <span class="number">7</span> / <span class="number">10</span>;</span><br><span class="line">            <span class="type">const</span> BandwidthItem &amp;item = mBandwidthItems[index];</span><br><span class="line">            <span class="keyword">if</span> (item.mBandwidth &lt;= adjustedBandwidthBps</span><br><span class="line">                    &amp;&amp; <span class="built_in">isBandwidthValid</span>(item)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            --index;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> 0</span></span><br><span class="line">    <span class="comment">// Change bandwidth at random()</span></span><br><span class="line">    <span class="type">size_t</span> index = <span class="built_in">uniformRand</span>() * mBandwidthItems.<span class="built_in">size</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> 0</span></span><br><span class="line">    <span class="comment">// There&#x27;s a 50% chance to stay on the current bandwidth and</span></span><br><span class="line">    <span class="comment">// a 50% chance to switch to the next higher bandwidth (wrapping around</span></span><br><span class="line">    <span class="comment">// to lowest)</span></span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> kMinIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">ssize_t</span> mCurBandwidthIndex = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> index;</span><br><span class="line">    <span class="keyword">if</span> (mCurBandwidthIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        index = kMinIndex;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">uniformRand</span>() &lt; <span class="number">0.5</span>) &#123;</span><br><span class="line">        index = (<span class="type">size_t</span>)mCurBandwidthIndex;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        index = mCurBandwidthIndex + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (index == mBandwidthItems.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            index = kMinIndex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mCurBandwidthIndex = index;</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> 0</span></span><br><span class="line">    <span class="comment">// Pick the highest bandwidth stream below or equal to 1.2 Mbit/sec</span></span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> index = mBandwidthItems.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (index &gt; <span class="number">0</span> &amp;&amp; mBandwidthItems.<span class="built_in">itemAt</span>(index).mBandwidth &gt; <span class="number">1200000</span>) &#123;</span><br><span class="line">        --index;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> 1</span></span><br><span class="line">    <span class="type">char</span> value[PROPERTY_VALUE_MAX];</span><br><span class="line">    <span class="type">size_t</span> index;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">property_get</span>(<span class="string">&quot;media.httplive.bw-index&quot;</span>, value, <span class="literal">NULL</span>)) &#123;</span><br><span class="line">        <span class="type">char</span> *end;</span><br><span class="line">        index = <span class="built_in">strtoul</span>(value, &amp;end, <span class="number">10</span>);</span><br><span class="line">        <span class="built_in">CHECK</span>(end &gt; value &amp;&amp; *end == <span class="string">&#x27;\0&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (index &gt;= mBandwidthItems.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            index = mBandwidthItems.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="type">size_t</span> index = mBandwidthItems.<span class="built_in">size</span>() - <span class="number">1</span>;  <span class="comment">// Highest bandwidth stream</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">CHECK_GE</span>(index, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Android-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">Android 源码分析</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/AOSP-源码/">AOSP 源码</a>
  </div>

</div>



<div class="comments-count">
	
	  	<span></span>
		<a href="/2016/08/02/Android-进阶之源码分析基于NuPlayer的HLS流媒体协议/#comments" class="ds-thread-count comments-count-link" data-thread-key="2016/08/02/Android-进阶之源码分析基于NuPlayer的HLS流媒体协议/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/08/01/Android-源码分析基于Stagefright的MediaPlayer播放框架-3/" title="Android 源码分析之基于Stagefright的MediaPlayer播放框架[4]" itemprop="url">Android 源码分析之基于Stagefright的MediaPlayer播放框架[4]</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Edgar" target="_blank" itemprop="author">Edgar</a>
		
  <p class="article-time">
    <time datetime="2016-08-01T03:20:27.000Z" itemprop="datePublished"> Published 2016-08-01</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>先上图，以免一大堆的代码引来大家的不适。</p>
<p><img src="/2016/08/01/Android-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E5%9F%BA%E4%BA%8EStagefright%E7%9A%84MediaPlayer%E6%92%AD%E6%94%BE%E6%A1%86%E6%9E%B6-3/1.png"><br>在prepare结束后，就可以调用start方法开始播放了。为了简单起见，我们对start之前的调用关系不做分析，仅仅列出这些方法的实现。</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">public void <span class="built_in">start</span>() throws IllegalStateException &#123;</span><br><span class="line">    if (isRestricted()) &#123;</span><br><span class="line">        <span class="built_in">_setVolume</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">stayAwake</span>(true);</span><br><span class="line">    <span class="built_in">_start</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">static void</span><br><span class="line">android<span class="constructor">_media_MediaPlayer_start(JNIEnv <span class="operator">*</span><span class="params">env</span>, <span class="params">jobject</span> <span class="params">thiz</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="constructor">ALOGV(<span class="string">&quot;start&quot;</span>)</span>;</span><br><span class="line">    sp&lt;MediaPlayer&gt; mp = get<span class="constructor">MediaPlayer(<span class="params">env</span>, <span class="params">thiz</span>)</span>;</span><br><span class="line">    process<span class="constructor">_media_player_call( <span class="params">env</span>, <span class="params">thiz</span>, <span class="params">mp</span>-&gt;<span class="params">start</span>()</span>, NULL, NULL );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">status_t MediaPlayer::start<span class="literal">()</span></span><br><span class="line">&#123;</span><br><span class="line">    status_t ret = NO_ERROR;</span><br><span class="line">    Mutex::Autolock <span class="constructor">_l(<span class="params">mLock</span>)</span>;</span><br><span class="line">    mLockThreadId = get<span class="constructor">ThreadId()</span>;</span><br><span class="line">    <span class="keyword">if</span> (mCurrentState &amp; MEDIA_PLAYER_STARTED) &#123;</span><br><span class="line">        ret = NO_ERROR;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( (mPlayer != <span class="number">0</span>)<span class="operator"> &amp;&amp; </span>( mCurrentState &amp; ( MEDIA_PLAYER_PREPARED <span class="pattern-match">|</span></span><br><span class="line"><span class="pattern-match">                    <span class="constructor">MEDIA_PLAYER_PLAYBACK_COMPLETE</span> | <span class="constructor">MEDIA_PLAYER_PAUSED</span> ) ) ) &#123;</span></span><br><span class="line"><span class="pattern-match">        m<span class="constructor">Player</span>-&gt;set<span class="constructor">Looping(<span class="params">mLoop</span>)</span>;</span></span><br><span class="line"><span class="pattern-match">        m<span class="constructor">Player</span>-&gt;set<span class="constructor">Volume(<span class="params">mLeftVolume</span>, <span class="params">mRightVolume</span>)</span>;</span></span><br><span class="line"><span class="pattern-match">        m<span class="constructor">Player</span>-&gt;set<span class="constructor">AuxEffectSendLevel(<span class="params">mSendLevel</span>)</span>;</span></span><br><span class="line"><span class="pattern-match">        m<span class="constructor">CurrentState</span> = <span class="constructor">MEDIA_PLAYER_STARTED</span>;</span></span><br><span class="line"><span class="pattern-match">        ret = m<span class="constructor">Player</span>-&gt;start();</span></span><br><span class="line"><span class="pattern-match">        <span class="keyword">if</span> (ret != <span class="constructor">NO_ERROR</span>) &#123;</span></span><br><span class="line"><span class="pattern-match">            m<span class="constructor">CurrentState</span> = <span class="constructor">MEDIA_PLAYER_STATE_ERROR</span>;</span></span><br><span class="line"><span class="pattern-match">        &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="pattern-match">            <span class="keyword">if</span> (m<span class="constructor">CurrentState</span> <span class="operator">==</span> <span class="constructor">MEDIA_PLAYER_PLAYBACK_COMPLETE</span>) &#123;</span></span><br><span class="line"><span class="pattern-match">                <span class="constructor">ALOGV(<span class="string">&quot;playback completed immediately following start()&quot;</span>)</span>;</span></span><br><span class="line"><span class="pattern-match">            &#125;</span></span><br><span class="line"><span class="pattern-match">        &#125;</span></span><br><span class="line"><span class="pattern-match">    &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="pattern-match">        <span class="constructor">ALOGE(<span class="string">&quot;start called in state %d&quot;</span>, <span class="params">mCurrentState</span>)</span>;</span></span><br><span class="line"><span class="pattern-match">        ret = <span class="constructor">INVALID_OPERATION</span>;</span></span><br><span class="line"><span class="pattern-match">    &#125;</span></span><br><span class="line"><span class="pattern-match">    m<span class="constructor">LockThreadId</span> = 0;</span></span><br><span class="line"><span class="pattern-match">    return ret;</span></span><br><span class="line"><span class="pattern-match">&#125;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">StagefrightPlayer::start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mPlayer-&gt;<span class="built_in">play</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">status_t AwesomePlayer::play() &#123;</span><br><span class="line">    <span class="built_in">ATRACE_CALL</span>();</span><br><span class="line">    Mutex::Autolock autoLock(mLock);</span><br><span class="line">    <span class="built_in">modifyFlags</span>(CACHE_UNDERRUN, CLEAR);</span><br><span class="line">    return <span class="built_in">play_l</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Start的真正工作是从AwesomePlayer::play_l开始的，在AwesomePlayer::play_l中通过createAudioPlayer_l创建出音频播放器，然后再通过startAudioPlayer_l开始音频播放器的播放。下面将针对这两个方法进行分析：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">AwesomePlayer::play_l</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">modifyFlags</span>(SEEK_PREVIEW, CLEAR);</span><br><span class="line">    mMediaRenderingStartGeneration = ++mStartGeneration;</span><br><span class="line">    <span class="keyword">if</span> (!(mFlags &amp; PREPARED)) &#123;</span><br><span class="line">        <span class="type">status_t</span> err = <span class="built_in">prepare_l</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">modifyFlags</span>(PLAYING, SET);</span><br><span class="line">    <span class="built_in">modifyFlags</span>(FIRST_FRAME, SET);</span><br><span class="line">    <span class="keyword">if</span> (mAudioSource != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mAudioPlayer == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">createAudioPlayer_l</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">CHECK</span>(!(mFlags &amp; AUDIO_RUNNING));</span><br><span class="line">        <span class="keyword">if</span> (mVideoSource == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// We don&#x27;t want to post an error notification at this point,</span></span><br><span class="line">            <span class="comment">// the error returned from MediaPlayer::start() will suffice.</span></span><br><span class="line">            <span class="type">status_t</span> err = <span class="built_in">startAudioPlayer_l</span>(</span><br><span class="line">                    <span class="literal">false</span> <span class="comment">/* sendErrorNotification */</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mFlags &amp; AT_EOS) &#123;</span><br><span class="line">        <span class="comment">// Legacy behaviour, if a stream finishes playing and then</span></span><br><span class="line">        <span class="comment">// is started again, we play from the start...</span></span><br><span class="line">        <span class="built_in">seekTo_l</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>createAudioPlayer_l方法相对简单，它通过AudioPlayer构造方法创建出一个AudioPlayer，然后将mAudioSource赋给它，mAudioPlayer的输入为mAudioSource，也就是解码器对应的OMXCodec。在构造AudioPlayer对象时会存放在其成员mSource中。<br>这里还需要注意的是mAudioSink，这个大家还有印象吧，就是我们之前提到的在setDataSource阶段创建的AudioOutPut，也就说这里做了两个重要的事情，一个是将输入mAudioSource赋给AudioPlayer，另一个是将mAudioSink这个与硬件相关的赋给AudioPlayer</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void AwesomePlayer::create<span class="constructor">AudioPlayer_l()</span></span><br><span class="line">&#123;</span><br><span class="line">    mAudioPlayer = <span class="keyword">new</span> <span class="constructor">AudioPlayer(<span class="params">mAudioSink</span>, <span class="params">flags</span>, <span class="params">this</span>)</span>;</span><br><span class="line">    mAudioPlayer-&gt;set<span class="constructor">Source(<span class="params">mAudioSource</span>)</span>;</span><br><span class="line">    <span class="comment">// If there was a seek request before we ever started,</span></span><br><span class="line">    <span class="comment">// honor the request now.</span></span><br><span class="line">    <span class="comment">// Make sure to do this before starting the audio player</span></span><br><span class="line">    <span class="comment">// to avoid a race condition.</span></span><br><span class="line">    <span class="comment">//如果在开始播放之前有一个seek的请求那么需要在启动audio player之前进行seek</span></span><br><span class="line">    seek<span class="constructor">AudioIfNecessary_l()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">AudioPlayer::<span class="built_in">AudioPlayer</span>(</span><br><span class="line">        const sp&lt;MediaPlayerBase::AudioSink&gt; &amp;audioSink,</span><br><span class="line">        uint32_t flags,</span><br><span class="line">        AwesomePlayer *observer)</span><br><span class="line">    : <span class="built_in">mInputBuffer</span>(NULL),</span><br><span class="line">      <span class="built_in">mSampleRate</span>(<span class="number">0</span>),</span><br><span class="line">      <span class="built_in">mLatencyUs</span>(<span class="number">0</span>),</span><br><span class="line">      <span class="built_in">mFrameSize</span>(<span class="number">0</span>),</span><br><span class="line">      <span class="built_in">mNumFramesPlayed</span>(<span class="number">0</span>),</span><br><span class="line">      <span class="built_in">mNumFramesPlayedSysTimeUs</span>(ALooper::<span class="built_in">GetNowUs</span>()),</span><br><span class="line">      <span class="built_in">mPositionTimeMediaUs</span>(-<span class="number">1</span>),</span><br><span class="line">      <span class="built_in">mPositionTimeRealUs</span>(-<span class="number">1</span>),</span><br><span class="line">      <span class="built_in">mSeeking</span>(false),</span><br><span class="line">      <span class="built_in">mReachedEOS</span>(false),</span><br><span class="line">      <span class="built_in">mFinalStatus</span>(OK),</span><br><span class="line">      <span class="built_in">mSeekTimeUs</span>(<span class="number">0</span>),</span><br><span class="line">      <span class="built_in">mStarted</span>(false),</span><br><span class="line">      <span class="built_in">mIsFirstBuffer</span>(false),</span><br><span class="line">      <span class="built_in">mFirstBufferResult</span>(OK),</span><br><span class="line">      <span class="built_in">mFirstBuffer</span>(NULL),</span><br><span class="line">      <span class="built_in">mAudioSink</span>(audioSink),</span><br><span class="line">      <span class="built_in">mObserver</span>(observer),</span><br><span class="line">      <span class="built_in">mPinnedTimeUs</span>(-<span class="number">1</span>ll),</span><br><span class="line">      <span class="built_in">mPlaying</span>(false),</span><br><span class="line">      <span class="built_in">mStartPosUs</span>(<span class="number">0</span>),</span><br><span class="line">      <span class="built_in">mCreateFlags</span>(flags) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void AudioPlayer::set<span class="constructor">Source(<span class="params">const</span> <span class="params">sp</span>&lt;MediaSource&gt; &amp;<span class="params">source</span>)</span> &#123;</span><br><span class="line">    <span class="constructor">CHECK(<span class="params">mSource</span> <span class="operator">==</span> NULL)</span>;</span><br><span class="line">    mSource = source;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在audio Player创建结束后就可以在startAudioPlayer_l中调用它的start方法进行播放了。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">status_t AwesomePlayer::start<span class="constructor">AudioPlayer_l(<span class="params">bool</span> <span class="params">sendErrorNotification</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(mFlags &amp; AUDIOPLAYER_STARTED)) &#123;</span><br><span class="line">    <span class="built_in">bool</span> wasSeeking = mAudioPlayer-&gt;is<span class="constructor">Seeking()</span>;</span><br><span class="line">    <span class="comment">// We&#x27;ve already started the MediaSource in order to enable</span></span><br><span class="line">    <span class="comment">// the prefetcher to read its data.</span></span><br><span class="line">    err = mAudioPlayer-&gt;start(<span class="literal">true</span> <span class="comment">/* sourceAlreadyStarted */</span>);</span><br><span class="line">        return err;</span><br><span class="line">    &#125;</span><br><span class="line">    modify<span class="constructor">Flags(AUDIOPLAYER_STARTED, SET)</span>;</span><br><span class="line">    <span class="keyword">if</span> (wasSeeking) &#123;</span><br><span class="line">        <span class="constructor">CHECK(!<span class="params">mAudioPlayer</span>-&gt;<span class="params">isSeeking</span>()</span>);</span><br><span class="line">        <span class="comment">// We will have finished the seek while starting the audio player.</span></span><br><span class="line">        post<span class="constructor">AudioSeekComplete()</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        notify<span class="constructor">IfMediaStarted_l()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line">    return err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AudioPlayer::start首先通过mSource-&gt;read(&amp;mFirstBuffer, &amp;options); 读取第一段解码后的数据，解码第一帧相当于启动了解码循环。然后再通过mAudioSink-&gt;open， mAudioSink-&gt;start();进行播放</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">AudioPlayer::start</span><span class="params">(<span class="type">bool</span> sourceAlreadyStarted)</span> </span>&#123;</span><br><span class="line">    mFirstBufferResult = mSource-&gt;<span class="built_in">read</span>(&amp;mFirstBuffer, &amp;options);</span><br><span class="line">    <span class="keyword">if</span> (mFirstBufferResult == INFO_FORMAT_CHANGED) &#123;</span><br><span class="line">        mFirstBufferResult = OK;</span><br><span class="line">        mIsFirstBuffer = <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mIsFirstBuffer = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">audio_format_t</span> audioFormat = AUDIO_FORMAT_PCM_16_BIT;</span><br><span class="line">    <span class="keyword">if</span> (mAudioSink.<span class="built_in">get</span>() != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="type">status_t</span> err = mAudioSink-&gt;<span class="built_in">open</span>(</span><br><span class="line">                mSampleRate, numChannels, channelMask, audioFormat,</span><br><span class="line">                DEFAULT_AUDIOSINK_BUFFERCOUNT,</span><br><span class="line">                &amp;AudioPlayer::AudioSinkCallback,</span><br><span class="line">                <span class="keyword">this</span>,</span><br><span class="line">                (<span class="type">audio_output_flags_t</span>)flags,</span><br><span class="line">                <span class="built_in">useOffload</span>() ? &amp;offloadInfo : <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (err == OK) &#123;</span><br><span class="line">            mLatencyUs = (<span class="type">int64_t</span>)mAudioSink-&gt;<span class="built_in">latency</span>() * <span class="number">1000</span>;</span><br><span class="line">            mFrameSize = mAudioSink-&gt;<span class="built_in">frameSize</span>();</span><br><span class="line">            err = mAudioSink-&gt;<span class="built_in">start</span>();</span><br><span class="line">            <span class="comment">// do not alter behavior for non offloaded tracks: ignore start status.</span></span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">useOffload</span>()) &#123;</span><br><span class="line">                err = OK;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是AudioSinkCallback</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">AudioPlayer::AudioSinkCallback</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        MediaPlayerBase::AudioSink * <span class="comment">/* audioSink */</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">void</span> *buffer, <span class="type">size_t</span> size, <span class="type">void</span> *cookie,</span></span></span><br><span class="line"><span class="params"><span class="function">        MediaPlayerBase::AudioSink::<span class="type">cb_event_t</span> event)</span> </span>&#123;</span><br><span class="line">    AudioPlayer *me = (AudioPlayer *)cookie;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(event) &#123;</span><br><span class="line">    <span class="keyword">case</span> MediaPlayerBase::AudioSink::CB_EVENT_FILL_BUFFER:</span><br><span class="line">        <span class="keyword">return</span> me-&gt;<span class="built_in">fillBuffer</span>(buffer, size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> MediaPlayerBase::AudioSink::CB_EVENT_STREAM_END:</span><br><span class="line">        <span class="built_in">ALOGV</span>(<span class="string">&quot;AudioSinkCallback: stream end&quot;</span>);</span><br><span class="line">        me-&gt;mReachedEOS = <span class="literal">true</span>;</span><br><span class="line">        me-&gt;<span class="built_in">notifyAudioEOS</span>();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> MediaPlayerBase::AudioSink::CB_EVENT_TEAR_DOWN:</span><br><span class="line">        <span class="built_in">ALOGV</span>(<span class="string">&quot;AudioSinkCallback: Tear down event&quot;</span>);</span><br><span class="line">        me-&gt;mObserver-&gt;<span class="built_in">postAudioTearDown</span>();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight zephir"><table><tr><td class="code"><pre><span class="line">status_t OMXCodec::read(MediaBuffer **buffer, <span class="keyword">const</span> ReadOptions *options) &#123;</span><br><span class="line">    <span class="keyword">if</span> (mInitialBufferSubmit) &#123;</span><br><span class="line">        mInitialBufferSubmit = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//===========================</span></span><br><span class="line">        drainInputBuffers();</span><br><span class="line">        <span class="keyword">if</span> (mState == EXECUTING) &#123;</span><br><span class="line">            <span class="comment">// Otherwise mState == RECONFIGURING and this code will trigger</span></span><br><span class="line">            <span class="comment">// after the output port is reenabled.</span></span><br><span class="line">            <span class="comment">//===========================</span></span><br><span class="line">            fillOutputBuffers();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//等待缓存被填满</span></span><br><span class="line">    <span class="keyword">while</span> (mState != ERROR &amp;&amp; !mNoMoreOutputData &amp;&amp; mFilledBuffers.<span class="keyword">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((err = waitForBufferFilled_l()) != OK) &#123;</span><br><span class="line">            <span class="keyword">return</span> err;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果到这里缓存还是空的则表示已经结束解码</span></span><br><span class="line">    <span class="keyword">if</span> (mFilledBuffers.<span class="keyword">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> mSignalledEOS ? mFinalStatus : ERROR_END_OF_STREAM;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取缓存的开始位置</span></span><br><span class="line">    size_t index = *mFilledBuffers.begin();</span><br><span class="line">    mFilledBuffers.erase(mFilledBuffers.begin());</span><br><span class="line"></span><br><span class="line">    BufferInfo *info = &amp;mPortBuffers[kPortIndexOutput].editItemAt(index);</span><br><span class="line">    CHECK_EQ((<span class="keyword">int</span>)info-&gt;mStatus, (<span class="keyword">int</span>)OWNED_BY_US);</span><br><span class="line">    info-&gt;mStatus = OWNED_BY_CLIENT;</span><br><span class="line"></span><br><span class="line">    info-&gt;mMediaBuffer-&gt;add_ref();</span><br><span class="line">    <span class="keyword">if</span> (mSkipCutBuffer != NULL) &#123;</span><br><span class="line">        mSkipCutBuffer-&gt;submit(info-&gt;mMediaBuffer);</span><br><span class="line">    &#125;</span><br><span class="line">    *buffer = info-&gt;mMediaBuffer;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> OMXCodec::drainInputBuffers() &#123;</span><br><span class="line">    <span class="keyword">CHECK</span>(mState == EXECUTING || mState == RECONFIGURING);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mFlags &amp; kUseSecureInputBuffers) &#123;</span><br><span class="line">        Vector&lt;BufferInfo&gt; *<span class="keyword">buffers</span> = &amp;mPortBuffers[kPortIndexInput];</span><br><span class="line">        <span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; <span class="keyword">buffers</span>-&gt;size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!drainAnyInputBuffer()|| (mFlags &amp; kOnlySubmitOneInputBufferAtOneTime)) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Vector&lt;BufferInfo&gt; *<span class="keyword">buffers</span> = &amp;mPortBuffers[kPortIndexInput];</span><br><span class="line">        <span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; <span class="keyword">buffers</span>-&gt;size(); ++i) &#123;</span><br><span class="line">            BufferInfo *<span class="keyword">info</span> = &amp;<span class="keyword">buffers</span>-&gt;editItemAt(i);</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">info</span>-&gt;mStatus != OWNED_BY_US) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!drainInputBuffer(<span class="keyword">info</span>)) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (mFlags &amp; kOnlySubmitOneInputBufferAtOneTime) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">OMXCodec::drainAnyInputBuffer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">drainInputBuffer</span>((BufferInfo *)<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> OMXCodec::drainInputBuffer(BufferInfo *<span class="keyword">info</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        MediaBuffer *srcBuffer;</span><br><span class="line">        <span class="keyword">if</span> (mSeekTimeUs &gt;= <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mLeftOverBuffer) &#123;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            err = mSource-&gt;<span class="keyword">read</span>(&amp;srcBuffer);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">status_t MP3Source::read(MediaBuffer **out, const ReadOptions *options) &#123;</span><br><span class="line">    </span><br><span class="line">    MediaBuffer *buffer;</span><br><span class="line">    <span class="function"><span class="title">status_t</span> err = mGroup-&gt;</span>acquire_buffer(&amp;buffer);</span><br><span class="line">    size_t frame_size;</span><br><span class="line">    int bitrate;</span><br><span class="line">    int num_samples;</span><br><span class="line">    int sample_rate;</span><br><span class="line">    <span class="comment">//获取同步信息</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="function"><span class="title">ssize_t</span> n = mDataSource-&gt;</span><span class="function"><span class="title">readAt</span>(mCurrentPos, buffer-&gt;</span><span class="keyword">data</span>(), <span class="number">4</span>);</span><br><span class="line">        <span class="function"><span class="title">uint32_t</span> header = U32_AT((const uint8_t *)buffer-&gt;</span><span class="keyword">data</span>());</span><br><span class="line">        <span class="keyword">if</span> ((header &amp; kMask) == (mFixedHeader &amp; kMask)</span><br><span class="line">            &amp;&amp; GetMPEGAudioFrameSize(</span><br><span class="line">                header, &amp;frame_size, &amp;sample_rate, NULL,</span><br><span class="line">                &amp;bitrate, &amp;num_samples)) &#123;</span><br><span class="line">            <span class="comment">// re-calculate mCurrentTimeUs because we might have called Resync()</span></span><br><span class="line">            <span class="keyword">if</span> (seekCBR) &#123;</span><br><span class="line">                mCurrentTimeUs = (mCurrentPos - mFirstFramePos) * <span class="number">8000</span> / bitrate;</span><br><span class="line">                mBasisTimeUs = mCurrentTimeUs;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    CHECK(<span class="function"><span class="title">frame_size</span> &lt;= buffer-&gt;</span>size());</span><br><span class="line">    <span class="comment">//获取需要获取的数据</span></span><br><span class="line">    <span class="function"><span class="title">ssize_t</span> n = mDataSource-&gt;</span><span class="function"><span class="title">readAt</span>(mCurrentPos, buffer-&gt;</span><span class="keyword">data</span>(), frame_size);</span><br><span class="line">    <span class="function"><span class="title">buffer</span>-&gt;</span>set_range(<span class="number">0</span>, frame_size);</span><br><span class="line">    <span class="function"><span class="title">buffer</span>-&gt;</span><span class="function"><span class="title">meta_data</span>()-&gt;</span>setInt64(kKeyTime, mCurrentTimeUs);</span><br><span class="line">    <span class="function"><span class="title">buffer</span>-&gt;</span><span class="function"><span class="title">meta_data</span>()-&gt;</span>setInt32(kKeyIsSyncFrame, <span class="number">1</span>);</span><br><span class="line">    mCurrentPos += frame_size;</span><br><span class="line">    mSamplesRead += num_samples;</span><br><span class="line">    mCurrentTimeUs = mBasisTimeUs + ((mSamplesRead * <span class="number">1000000</span>) / sample_rate);</span><br><span class="line">    *out = buffer;</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>紧接着的工作就交给mAudioSink-&gt;open， mAudioSink-&gt;start()了，<br>我们知道这里的mAudioSink是通过MediaPlayerService::Client::setDataSource_pre方法的</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">sp&lt;MediaPlayerBase&gt; MediaPlayerService::Client::<span class="title function_ invoke__">setDataSource_pre</span>(</span><br><span class="line">        player_<span class="keyword">type</span> <span class="title class_">playerType</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//………………………………………….</span></span><br><span class="line">    <span class="title function_ invoke__">if</span> (!p<span class="punctuation">-&gt;</span><span class="title function_ invoke__">hardwareOutput</span>()) &#123;</span><br><span class="line">        Mutex::Autolock <span class="title function_ invoke__">l</span>(mLock);</span><br><span class="line">        mAudioOutput = </span><br><span class="line">        new <span class="title function_ invoke__">AudioOutput</span>(mAudioSessionId, IPCThreadState::<span class="title function_ invoke__">self</span>()<span class="punctuation">-&gt;</span><span class="title function_ invoke__">getCallingUid</span>(),</span><br><span class="line">                mPid, mAudioAttributes);</span><br><span class="line">        static_cast&lt;MediaPlayerInterface*&gt;(p.<span class="title function_ invoke__">get</span>())<span class="punctuation">-&gt;</span><span class="title function_ invoke__">setAudioSink</span>(mAudioOutput);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>知道了mAudioSink我们就可以分析open方法了。需要注意的是mAudioSink-&gt;open 中传入的参数中有个函数指针 AudioPlayer::AudioSinkCallback ，其主要作用就是audioout播放pcm的时候会定期调用此回调函数填充数据，回调函数保存在 mCallback中。这里还有个重要的细节要注意，在构造AudioTrack对象的时候，传入了CallbackWrapper作为audiotrack的callback当audiotrack需要数据的时候，就会调用此函数： </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">status_t</span> MediaPlayerService::AudioOutput::<span class="built_in">open</span>(</span><br><span class="line">        <span class="type">uint32_t</span> sampleRate, <span class="type">int</span> channelCount, <span class="type">audio_channel_mask_t</span> channelMask,</span><br><span class="line">        <span class="type">audio_format_t</span> format, <span class="type">int</span> bufferCount,</span><br><span class="line">        AudioCallback cb, <span class="type">void</span> *cookie,</span><br><span class="line">        <span class="type">audio_output_flags_t</span> flags,</span><br><span class="line">        <span class="type">const</span> <span class="type">audio_offload_info_t</span> *offloadInfo,</span><br><span class="line">        <span class="type">bool</span> doNotReconnect,</span><br><span class="line">        <span class="type">uint32_t</span> suggestedFrameCount)</span><br><span class="line">&#123;</span><br><span class="line">    sp&lt;AudioTrack&gt; t;</span><br><span class="line">    CallbackData *newcbd = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//将回调函数保存在 mCallback</span></span><br><span class="line">    mCallback = cb;</span><br><span class="line">    mCallbackCookie = cookie;</span><br><span class="line">    <span class="comment">// We don&#x27;t attempt to create a new track if we are recycling an</span></span><br><span class="line">    <span class="comment">// offloaded track. But, if we are recycling a non-offloaded or we</span></span><br><span class="line">    <span class="comment">// are switching where one is offloaded and one isn&#x27;t then we create</span></span><br><span class="line">    <span class="comment">// the new track in advance so that we can read additional stream info</span></span><br><span class="line">    <span class="keyword">if</span> (!(reuse &amp;&amp; bothOffloaded)) &#123;</span><br><span class="line">        <span class="built_in">ALOGV</span>(<span class="string">&quot;creating new AudioTrack&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (mCallback != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            newcbd = <span class="keyword">new</span> <span class="built_in">CallbackData</span>(<span class="keyword">this</span>);</span><br><span class="line">            <span class="comment">//new 一个AudioTrack</span></span><br><span class="line">            t = <span class="keyword">new</span> <span class="built_in">AudioTrack</span>(</span><br><span class="line">                    mStreamType,</span><br><span class="line">                    sampleRate,</span><br><span class="line">                    format,</span><br><span class="line">                    channelMask,</span><br><span class="line">                    frameCount,</span><br><span class="line">                    flags,</span><br><span class="line">                    <span class="comment">//audiotrack需要数据的时候，就会调用此函数</span></span><br><span class="line">                    CallbackWrapper,</span><br><span class="line">                    newcbd,</span><br><span class="line">                    <span class="number">0</span>,  <span class="comment">// notification frames</span></span><br><span class="line">                    mSessionId,</span><br><span class="line">                    AudioTrack::TRANSFER_CALLBACK,</span><br><span class="line">                    offloadInfo,</span><br><span class="line">                    mUid,</span><br><span class="line">                    mPid,</span><br><span class="line">                    mAttributes,</span><br><span class="line">                    doNotReconnect);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">//………………………………………</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mCallbackData = newcbd;</span><br><span class="line">    <span class="comment">//将 new出来的AudioTrack保存到mTrack中</span></span><br><span class="line">    mTrack = t;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面有介绍到AudioOut播放pcm的时候会定期调用AudioPlayer::AudioSinkCallback此回调函数填充数据,但是在代码中如果跟踪mCallback你会发现并没有直接对其进行调用，其实对这个方法的相关调用在AudioOutput::CallbackWrapper中完成的。<br>接下来我们就从CallbackWrapper的注册以及如何调用AudioPlayer::AudioSinkCallback进行对缓存进行操作进行较为细致的分析：</p>
<p>首先我们看下AudioTrack构造方法：<br>在构造方法中调用了set方法，CallbackWrapper是它的第7个参数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">AudioTrack::<span class="built_in">AudioTrack</span>(</span><br><span class="line">        <span class="type">audio_stream_type_t</span> streamType,</span><br><span class="line">        <span class="type">uint32_t</span> sampleRate,</span><br><span class="line">        <span class="type">audio_format_t</span> format,</span><br><span class="line">        <span class="type">audio_channel_mask_t</span> channelMask,</span><br><span class="line">        <span class="type">size_t</span> frameCount,</span><br><span class="line">        <span class="type">audio_output_flags_t</span> flags,</span><br><span class="line">        <span class="type">callback_t</span> cbf,</span><br><span class="line">        <span class="type">void</span>* user,</span><br><span class="line">        <span class="type">uint32_t</span> notificationFrames,</span><br><span class="line">        <span class="type">int</span> sessionId,</span><br><span class="line">        transfer_type transferType,</span><br><span class="line">        <span class="type">const</span> <span class="type">audio_offload_info_t</span> *offloadInfo,</span><br><span class="line">        <span class="type">int</span> uid,</span><br><span class="line">        <span class="type">pid_t</span> pid,</span><br><span class="line">        <span class="type">const</span> <span class="type">audio_attributes_t</span>* pAttributes,</span><br><span class="line">        <span class="type">bool</span> doNotReconnect)</span><br><span class="line">    : <span class="built_in">mStatus</span>(NO_INIT),</span><br><span class="line">      <span class="built_in">mIsTimed</span>(<span class="literal">false</span>),</span><br><span class="line">      <span class="built_in">mPreviousPriority</span>(ANDROID_PRIORITY_NORMAL),</span><br><span class="line">      <span class="built_in">mPreviousSchedulingGroup</span>(SP_DEFAULT),</span><br><span class="line">      <span class="built_in">mPausedPosition</span>(<span class="number">0</span>),</span><br><span class="line">      <span class="built_in">mSelectedDeviceId</span>(AUDIO_PORT_HANDLE_NONE)</span><br><span class="line">&#123;</span><br><span class="line">    mStatus = <span class="built_in">set</span>(streamType, sampleRate, format, channelMask,</span><br><span class="line">            frameCount, flags, cbf, user, notificationFrames,</span><br><span class="line">            <span class="number">0</span> <span class="comment">/*sharedBuffer*/</span>, <span class="literal">false</span> <span class="comment">/*threadCanCallJava*/</span>, sessionId, transferType,</span><br><span class="line">            offloadInfo, uid, pid, pAttributes, doNotReconnect);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看到set方法中CallbackWrapper最终被赋给mCbf，同时在其中开启了AudioTrackThread线程。并调用createTrack_l创建IAudioTrack。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">AudioTrack::set</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">audio_stream_type_t</span> streamType,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">uint32_t</span> sampleRate,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">audio_format_t</span> format,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">audio_channel_mask_t</span> channelMask,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">size_t</span> frameCount,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">audio_output_flags_t</span> flags,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">callback_t</span> cbf,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">void</span>* user,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">uint32_t</span> notificationFrames,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> sp&lt;IMemory&gt;&amp; sharedBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">bool</span> threadCanCallJava,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">int</span> sessionId,</span></span></span><br><span class="line"><span class="params"><span class="function">        transfer_type transferType,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> <span class="type">audio_offload_info_t</span> *offloadInfo,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">int</span> uid,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">pid_t</span> pid,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> <span class="type">audio_attributes_t</span>* pAttributes,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">bool</span> doNotReconnect)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (transferType) &#123;</span><br><span class="line">    <span class="keyword">case</span> TRANSFER_DEFAULT:</span><br><span class="line">         <span class="comment">//........................</span></span><br><span class="line">    <span class="keyword">case</span> TRANSFER_CALLBACK:</span><br><span class="line">        <span class="keyword">if</span> (cbf == <span class="literal">NULL</span> || sharedBuffer != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> BAD_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">//........................</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> BAD_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line">    mCbf = cbf;</span><br><span class="line">    <span class="keyword">if</span> (cbf != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        mAudioTrackThread = <span class="keyword">new</span> <span class="built_in">AudioTrackThread</span>(*<span class="keyword">this</span>, threadCanCallJava);</span><br><span class="line">        mAudioTrackThread-&gt;<span class="built_in">run</span>(<span class="string">&quot;AudioTrack&quot;</span>, ANDROID_PRIORITY_AUDIO, <span class="number">0</span> <span class="comment">/*stack*/</span>);</span><br><span class="line">        <span class="comment">// thread begins in paused state, and will not reference us until start()</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// create the IAudioTrack</span></span><br><span class="line">    <span class="type">status_t</span> status = <span class="built_in">createTrack_l</span>();</span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AudioTrack::AudioTrackThread::<span class="built_in">AudioTrackThread</span>(AudioTrack&amp; receiver, <span class="type">bool</span> bCanCallJava)</span><br><span class="line">    : <span class="built_in">Thread</span>(bCanCallJava), <span class="built_in">mReceiver</span>(receiver), <span class="built_in">mPaused</span>(<span class="literal">true</span>), <span class="built_in">mPausedInt</span>(<span class="literal">false</span>), <span class="built_in">mPausedNs</span>(<span class="number">0LL</span>),</span><br><span class="line">      <span class="built_in">mIgnoreNextPausedInt</span>(<span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> AudioTrack::AudioTrackThread::<span class="built_in">threadLoop</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//…………………………………………..</span></span><br><span class="line">    <span class="type">nsecs_t</span> ns = mReceiver.<span class="built_in">processAudioBuffer</span>();</span><br><span class="line">    <span class="keyword">switch</span> (ns) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">case</span> NS_INACTIVE:</span><br><span class="line">        <span class="built_in">pauseInternal</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">case</span> NS_NEVER:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">case</span> NS_WHENEVER:</span><br><span class="line">        <span class="comment">// Event driven: call wake() when callback notifications conditions change.</span></span><br><span class="line">        ns = INT64_MAX;</span><br><span class="line">        <span class="comment">// fall through</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">LOG_ALWAYS_FATAL_IF</span>(ns &lt; <span class="number">0</span>, <span class="string">&quot;processAudioBuffer() returned %&quot;</span> PRId64, ns);</span><br><span class="line">        <span class="built_in">pauseInternal</span>(ns);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们接下来看下processAudioBuffer，这是一个十分关键的方法，但是这里我们仅仅关注与mCbf相关的部分。如红色标注的代码段所示：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">nsecs_t</span> <span class="title">AudioTrack::processAudioBuffer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (waitStreamEnd) &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">FIXME:</span>  Instead of blocking in proxy-&gt;waitStreamEndDone(), Callback thread</span></span><br><span class="line">        <span class="comment">// should wait on proxy futex and handle CBLK_STREAM_END_DONE within this function</span></span><br><span class="line">        <span class="comment">// (and make sure we don&#x27;t callback for more data while we&#x27;re stopping).</span></span><br><span class="line">        <span class="comment">// This helps with position, marker notifications, and track invalidation.</span></span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">timespec</span> timeout;</span><br><span class="line">        timeout.tv_sec = WAIT_STREAM_END_TIMEOUT_SEC;</span><br><span class="line">        timeout.tv_nsec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">status_t</span> status = proxy-&gt;<span class="built_in">waitStreamEndDone</span>(&amp;timeout);</span><br><span class="line">        <span class="keyword">switch</span> (status) &#123;</span><br><span class="line">        <span class="keyword">case</span> NO_ERROR:</span><br><span class="line">        <span class="keyword">case</span> DEAD_OBJECT:</span><br><span class="line">        <span class="keyword">case</span> TIMED_OUT:</span><br><span class="line">            <span class="built_in">mCbf</span>(EVENT_STREAM_END, mUserData, <span class="literal">NULL</span>);</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="function">AutoMutex <span class="title">lock</span><span class="params">(mLock)</span></span>;</span><br><span class="line">                <span class="comment">// The previously assigned value of waitStreamEnd is no longer valid,</span></span><br><span class="line">                <span class="comment">// since the mutex has been unlocked and either the callback handler</span></span><br><span class="line">                <span class="comment">// or another thread could have re-started the AudioTrack during that time.</span></span><br><span class="line">                waitStreamEnd = mState == STATE_STOPPING;</span><br><span class="line">                <span class="keyword">if</span> (waitStreamEnd) &#123;</span><br><span class="line">                    mState = STATE_STOPPED;</span><br><span class="line">                    mReleased = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newUnderrun) &#123;</span><br><span class="line">        <span class="built_in">mCbf</span>(EVENT_UNDERRUN, mUserData, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (loopCountNotifications &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">mCbf</span>(EVENT_LOOP_END, mUserData, <span class="literal">NULL</span>);</span><br><span class="line">        --loopCountNotifications;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flags &amp; CBLK_BUFFER_END) &#123;</span><br><span class="line">        <span class="built_in">mCbf</span>(EVENT_BUFFER_END, mUserData, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (markerReached) &#123;</span><br><span class="line">        <span class="built_in">mCbf</span>(EVENT_MARKER, mUserData, &amp;markerPosition);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (newPosCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">size_t</span> temp = newPosition;</span><br><span class="line">        <span class="built_in">mCbf</span>(EVENT_NEW_POS, mUserData, &amp;temp);</span><br><span class="line">        newPosition += updatePeriod;</span><br><span class="line">        newPosCount--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mObservedSequence != sequence) &#123;</span><br><span class="line">        mObservedSequence = sequence;</span><br><span class="line">        <span class="built_in">mCbf</span>(EVENT_NEW_IAUDIOTRACK, mUserData, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">// for offloaded tracks, just wait for the upper layers to recreate the track</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isOffloadedOrDirect</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> NS_INACTIVE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> reqSize = audioBuffer.size;</span><br><span class="line">    <span class="built_in">mCbf</span>(EVENT_MORE_DATA, mUserData, &amp;audioBuffer);</span><br><span class="line">    <span class="type">size_t</span> writtenSize = audioBuffer.size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// A lot has transpired since ns was calculated, so run again immediately and re-calculate</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面代码可以看出在new AudioTrack的时候会启动AudioTrackThread，在AudioTrackThread中的threadLoop会调用mCbf(EVENT_MORE_DATA, mUserData, &amp;audioBuffer);等回调方法，从而调用AudioOutput::CallbackWrapper方法，在AudioOutput::CallbackWrapper方法，接下来我们看下AudioOutput::CallbackWrapper方法，在该方法中通过data-&gt;getOutput();获得AudioOutput，再通过*me-&gt;mCallback来调用AudioPlayer::AudioSinkCallback中对应的回调函数。</p>
<figure class="highlight zephir"><table><tr><td class="code"><pre><span class="line">void MediaPlayerService::AudioOutput::CallbackWrapper(</span><br><span class="line">        <span class="keyword">int</span> event, void *cookie, void *info) &#123;</span><br><span class="line">    <span class="comment">//ALOGV(&quot;callbackwrapper&quot;);</span></span><br><span class="line">    CallbackData *data = (CallbackData*)cookie;</span><br><span class="line">    <span class="comment">// lock to ensure we aren&#x27;t caught in the middle of a track switch.</span></span><br><span class="line">    data-&gt;lock();</span><br><span class="line">    AudioOutput *me = data-&gt;getOutput();</span><br><span class="line">    AudioTrack::Buffer *buffer = (AudioTrack::Buffer *)info;</span><br><span class="line">    <span class="keyword">switch</span>(event) &#123;</span><br><span class="line">    <span class="keyword">case</span> AudioTrack::EVENT_MORE_DATA: &#123;</span><br><span class="line">        size_t actualSize = (*me-&gt;mCallback)(</span><br><span class="line">                me, buffer-&gt;raw, buffer-&gt;size, me-&gt;mCallbackCookie,</span><br><span class="line">                CB_EVENT_FILL_BUFFER);</span><br><span class="line">        <span class="comment">// Log when no data is returned from the callback.</span></span><br><span class="line">        <span class="comment">// (1) We may have no data (especially with network streaming sources).</span></span><br><span class="line">        <span class="comment">// (2) We may have reached the EOS and the audio track is not stopped yet.</span></span><br><span class="line">        <span class="comment">// Note that AwesomePlayer/AudioPlayer will only return zero size when it reaches the EOS.</span></span><br><span class="line">        <span class="comment">// NuPlayerRenderer will return zero when it doesn&#x27;t have data (it doesn&#x27;t block to fill).</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// This is a benign busy-wait, with the next data request generated 10 ms or more later;</span></span><br><span class="line">        <span class="comment">// nevertheless for power reasons, we don&#x27;t want to see too many of these.</span></span><br><span class="line">        me-&gt;mBytesWritten += actualSize;  <span class="comment">// benign race with reader.</span></span><br><span class="line">        buffer-&gt;size = actualSize;</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> AudioTrack::EVENT_STREAM_END:</span><br><span class="line">        <span class="comment">// currently only occurs for offloaded callbacks</span></span><br><span class="line">        ALOGV(<span class="string">&quot;callbackwrapper: deliver EVENT_STREAM_END&quot;</span>);</span><br><span class="line">        (*me-&gt;mCallback)(me, NULL <span class="comment">/* buffer */</span>, <span class="number">0</span> <span class="comment">/* size */</span>,</span><br><span class="line">                me-&gt;mCallbackCookie, CB_EVENT_STREAM_END);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> AudioTrack::EVENT_NEW_IAUDIOTRACK :</span><br><span class="line">        ALOGV(<span class="string">&quot;callbackwrapper: deliver EVENT_TEAR_DOWN&quot;</span>);</span><br><span class="line">        (*me-&gt;mCallback)(me,  NULL <span class="comment">/* buffer */</span>, <span class="number">0</span> <span class="comment">/* size */</span>,</span><br><span class="line">                me-&gt;mCallbackCookie, CB_EVENT_TEAR_DOWN);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> AudioTrack::EVENT_UNDERRUN:</span><br><span class="line">        <span class="comment">// This occurs when there is no data available, typically</span></span><br><span class="line">        <span class="comment">// when there is a failure to supply data to the AudioTrack.  It can also</span></span><br><span class="line">        <span class="comment">// occur in non-offloaded mode when the audio device comes out of standby.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// If an AudioTrack underruns it outputs silence. Since this happens suddenly</span></span><br><span class="line">        <span class="comment">// it may sound like an audible pop or glitch.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// The underrun event is sent once per track underrun; the condition is reset</span></span><br><span class="line">        <span class="comment">// when more data is sent to the AudioTrack.</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        ALOGE(<span class="string">&quot;received unknown event type: %d inside CallbackWrapper !&quot;</span>, event);</span><br><span class="line">    &#125;</span><br><span class="line">    data-&gt;unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是AudioPlayer::AudioSinkCallback的实现部分，我们假设当前传递的事件为CB_EVENT_FILL_BUFFER，这时候将会调用AudioPlayer::fillBuffer来填充缓冲区的数据。<br>在AudioPlayer::fillBuffer中直接调用err &#x3D; mSource-&gt;read(&amp;mInputBuffer, &amp;options);即调用解码器的mediabuffer来填充数据，这部分代码就不列出了。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="comment">// static</span></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">AudioPlayer::AudioSinkCallback</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        MediaPlayerBase::AudioSink * <span class="comment">/* audioSink */</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">void</span> *buffer, <span class="type">size_t</span> size, <span class="type">void</span> *cookie,</span></span></span><br><span class="line"><span class="params"><span class="function">        MediaPlayerBase::AudioSink::<span class="type">cb_event_t</span> event)</span> </span>&#123;</span><br><span class="line">    AudioPlayer *me = (AudioPlayer *)cookie;</span><br><span class="line">    <span class="keyword">switch</span>(event) &#123;</span><br><span class="line">    <span class="keyword">case</span> MediaPlayerBase::AudioSink::CB_EVENT_FILL_BUFFER:</span><br><span class="line">        <span class="keyword">return</span> me-&gt;<span class="built_in">fillBuffer</span>(buffer, size);</span><br><span class="line">    <span class="keyword">case</span> MediaPlayerBase::AudioSink::CB_EVENT_STREAM_END:</span><br><span class="line">        <span class="built_in">ALOGV</span>(<span class="string">&quot;AudioSinkCallback: stream end&quot;</span>);</span><br><span class="line">        me-&gt;mReachedEOS = <span class="literal">true</span>;</span><br><span class="line">        me-&gt;<span class="built_in">notifyAudioEOS</span>();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> MediaPlayerBase::AudioSink::CB_EVENT_TEAR_DOWN:</span><br><span class="line">        <span class="built_in">ALOGV</span>(<span class="string">&quot;AudioSinkCallback: Tear down event&quot;</span>);</span><br><span class="line">        me-&gt;mObserver-&gt;<span class="built_in">postAudioTearDown</span>();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看完open方法的流程，接下来看下start方法：该方法比较简单就只掉调用mTrack-&gt;start.</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">status_t MediaPlayerService::AudioOutput::start()</span><br><span class="line">&#123;</span><br><span class="line">    if (mTrack != <span class="number">0</span>) &#123;</span><br><span class="line">        mTrack-&gt;<span class="built_in">setVolume</span>(mLeftVolume, mRightVolume);</span><br><span class="line">        mTrack-&gt;<span class="built_in">setAuxEffectSendLevel</span>(mSendLevel);</span><br><span class="line">        return mTrack-&gt;<span class="built_in">start</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    return NO_INIT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看下AudioTrack::start在该方法内部调用了 mAudioTrack-&gt;start();</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">status_t AudioTrack::start()</span><br><span class="line">&#123;</span><br><span class="line">    State previousState = mState;</span><br><span class="line">    <span class="keyword">if</span> (previousState == STATE_PAUSED_STOPPING) &#123;</span><br><span class="line">        mState = STATE_STOPPING;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mState = STATE_ACTIVE;</span><br><span class="line">    &#125;</span><br><span class="line">    (void) updateAndGetPosition_l();</span><br><span class="line">    sp&lt;AudioTrackThread&gt; t = mAudioTrackThread;</span><br><span class="line">    <span class="keyword">if</span> (t != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (previousState == STATE_STOPPING) &#123;</span><br><span class="line">            mProxy-&gt;interrupt();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            t-&gt;<span class="built_in">resume</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mPreviousPriority = getpriority(PRIO_PROCESS, <span class="number">0</span>);</span><br><span class="line">        get_sched_policy(<span class="number">0</span>, &amp;mPreviousSchedulingGroup);</span><br><span class="line">        androidSetThreadPriority(<span class="number">0</span>, ANDROID_PRIORITY_AUDIO);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    status_t <span class="built_in">status</span> = NO_ERROR;</span><br><span class="line">    <span class="keyword">if</span> (!(flags &amp; CBLK_INVALID)) &#123;</span><br><span class="line">        <span class="built_in">status</span> = mAudioTrack-&gt;start();</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">status</span> == DEAD_OBJECT) &#123;</span><br><span class="line">            flags |= CBLK_INVALID;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">status</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>跟踪源码我们可以看出mAudioTrack是在createTrack_l()中创建的对应代码如下,它是调用audioFlinger-&gt;createTrack创建的，通过上述流程Audiotrack启动后就会周期性的调用回调函数从解码器获取数据进行输出。</p>
<figure class="highlight autohotkey"><table><tr><td class="code"><pre><span class="line">// must be called with mLock held</span><br><span class="line"><span class="title">status_t AudioTrack::</span>createTrack_l()</span><br><span class="line">&#123;</span><br><span class="line">   //……………………………………….</span><br><span class="line">    sp&lt;IAudioTrack&gt; track = audioFlinger-&gt;createTrack(streamType,</span><br><span class="line"><span class="built_in">                                                      mSampleRate,</span></span><br><span class="line"><span class="built_in">                                                      mFormat,</span></span><br><span class="line"><span class="built_in">                                                      mChannelMask,</span></span><br><span class="line">                                                      &amp;temp,</span><br><span class="line">                                                      &amp;trackFlags,</span><br><span class="line"><span class="built_in">                                                      mSharedBuffer,</span></span><br><span class="line"><span class="built_in">                                                      output,</span></span><br><span class="line"><span class="built_in">                                                      tid,</span></span><br><span class="line">                                                      &amp;mSessionId,</span><br><span class="line"><span class="built_in">                                                      mClientUid,</span></span><br><span class="line">                                                      &amp;status)<span class="comment">;</span></span><br><span class="line">  </span><br><span class="line">   //……………………………………….</span><br><span class="line">    mAudioTrack = track<span class="comment">;</span></span><br><span class="line">    <span class="keyword">return</span> status<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>无图无真相，直接上图！再看这个图应该更清晰了吧，要是还有疑问可以给我发邮件。<br><img src="/2016/08/01/Android-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E5%9F%BA%E4%BA%8EStagefright%E7%9A%84MediaPlayer%E6%92%AD%E6%94%BE%E6%A1%86%E6%9E%B6-3/1.png"></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Android-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">Android 源码分析</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/AOSP-源码/">AOSP 源码</a>
  </div>

</div>



<div class="comments-count">
	
	  	<span></span>
		<a href="/2016/08/01/Android-源码分析基于Stagefright的MediaPlayer播放框架-3/#comments" class="ds-thread-count comments-count-link" data-thread-key="2016/08/01/Android-源码分析基于Stagefright的MediaPlayer播放框架-3/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/07/31/Android-源码分析基于Stagefright的MediaPlayer播放框架-2/" title="Android 源码分析之基于Stagefright的MediaPlayer播放框架[3]" itemprop="url">Android 源码分析之基于Stagefright的MediaPlayer播放框架[3]</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Edgar" target="_blank" itemprop="author">Edgar</a>
		
  <p class="article-time">
    <time datetime="2016-07-31T13:54:41.000Z" itemprop="datePublished"> Published 2016-07-31</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h5 id="MediaPlayer播放框架源代码解析："><a href="#MediaPlayer播放框架源代码解析：" class="headerlink" title="MediaPlayer播放框架源代码解析："></a>MediaPlayer播放框架源代码解析：</h5><h6 id="Prepare–加载解码器，数据缓存的初始化"><a href="#Prepare–加载解码器，数据缓存的初始化" class="headerlink" title="Prepare–加载解码器，数据缓存的初始化"></a>Prepare–加载解码器，数据缓存的初始化</h6><p>通过setDataSource设置播放资源后。就可以调用Prepare方法为播放做准备了。Prepare的整个流程是最为复杂的一个阶段，从整体上可以分成两大部分，第一部分是解码器的加载，第二部分是数据缓存的设置，Prepare之前的调用流程和setDataSource一样都是通过Java层到jni层再到native层，这部分就不做过多的介绍了，这部分的代码如下。</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">public void <span class="built_in">prepare</span>() throws IOException, IllegalStateException &#123;</span><br><span class="line">    <span class="built_in">_prepare</span>();</span><br><span class="line">    <span class="built_in">scanInternalSubtitleTracks</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="function"><span class="keyword">void</span> <span class="title">_prepare</span><span class="params">()</span> <span class="keyword">throws</span> IOException, IllegalStateException</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">static void</span><br><span class="line">android<span class="constructor">_media_MediaPlayer_prepare(JNIEnv <span class="operator">*</span><span class="params">env</span>, <span class="params">jobject</span> <span class="params">thiz</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    sp&lt;MediaPlayer&gt; mp = get<span class="constructor">MediaPlayer(<span class="params">env</span>, <span class="params">thiz</span>)</span>;</span><br><span class="line">    <span class="keyword">if</span> (mp<span class="operator"> == </span>NULL ) &#123;</span><br><span class="line">        jni<span class="constructor">ThrowException(<span class="params">env</span>, <span class="string">&quot;java/lang/IllegalStateException&quot;</span>, NULL)</span>;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Handle the case where the display surface was set before the mp was</span></span><br><span class="line">    <span class="comment">// initialized. We try again to make it stick.</span></span><br><span class="line">    sp&lt;IGraphicBufferProducer&gt; st = get<span class="constructor">VideoSurfaceTexture(<span class="params">env</span>, <span class="params">thiz</span>)</span>;</span><br><span class="line">    mp-&gt;set<span class="constructor">VideoSurfaceTexture(<span class="params">st</span>)</span>;</span><br><span class="line">    process<span class="constructor">_media_player_call( <span class="params">env</span>, <span class="params">thiz</span>, <span class="params">mp</span>-&gt;<span class="params">prepare</span>()</span>, <span class="string">&quot;java/io/IOException&quot;</span>, <span class="string">&quot;Prepare failed.&quot;</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">MediaPlayer::prepare</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Mutex::Autolock _l(mLock);</span><br><span class="line">    mLockThreadId = <span class="built_in">getThreadId</span>();</span><br><span class="line">    <span class="keyword">if</span> (mPrepareSync) &#123;</span><br><span class="line">        mLockThreadId = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> -EALREADY;</span><br><span class="line">    &#125;</span><br><span class="line">    mPrepareSync = <span class="literal">true</span>;</span><br><span class="line">    <span class="type">status_t</span> ret = <span class="built_in">prepareAsync_l</span>()；</span><br><span class="line">    <span class="keyword">if</span> (mPrepareSync) &#123;</span><br><span class="line">        mSignal.<span class="built_in">wait</span>(mLock);  <span class="comment">// wait for prepare done</span></span><br><span class="line">        mPrepareSync = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mLockThreadId = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> mPrepareStatus;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们从这里开始：<br>MediaPlayer 中调用了mPlayer-&gt;prepareAsync()方法，这里的mPlayer表示的是Stagefright Player，我们继续往下看：</p>
<figure class="highlight coq"><table><tr><td class="code"><pre><span class="line">status_t MediaPlayer::prepareAsync_l()&#123;</span><br><span class="line">    <span class="keyword">if</span> ( (mPlayer != <span class="number">0</span>) &amp;&amp; ( mCurrentState &amp; (MEDIA_PLAYER_INITIALIZED | <span class="type">MEDIA_PLAYER_STOPPED</span>) ) ) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mAudioAttributesParcel != NULL) &#123;</span><br><span class="line">            mPlayer-&gt;setParameter(KEY_PARAMETER_AUDIO_ATTRIBUTES, </span><br><span class="line">            *mAudioAttributesParcel);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mPlayer-&gt;setAudioStreamType(mStreamType);</span><br><span class="line">        &#125;</span><br><span class="line">        mCurrentState = MEDIA_PLAYER_PREPARING;</span><br><span class="line">        <span class="keyword">return</span> mPlayer-&gt;prepareAsync();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> INVALID_OPERATION;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在StagefrightPlayer中只是简单地调用AwesomePlayer的prepareAsync</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">StagefrightPlayer::prepareAsync</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mPlayer-&gt;<span class="built_in">prepareAsync</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">AwesomePlayer::prepareAsync</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">ATRACE_CALL</span>();</span><br><span class="line">    <span class="function">Mutex::Autolock <span class="title">autoLock</span><span class="params">(mLock)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (mFlags &amp; PREPARING) &#123;</span><br><span class="line">        <span class="keyword">return</span> UNKNOWN_ERROR;  <span class="comment">// async prepare already pending</span></span><br><span class="line">    &#125;</span><br><span class="line">    mIsAsyncPrepare = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">prepareAsync_l</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在AwesomePlayer类的prepareAsync_l方法中将会创建一个AwesomeEvent，启动Queue，将创建的mAsyncPrepareEvent post到Queue中。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">status_t AwesomePlayer::prepare<span class="constructor">Async_l()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mFlags &amp; PREPARING) &#123;</span><br><span class="line">        return UNKNOWN_ERROR;  <span class="comment">// async prepare already pending</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!mQueueStarted) &#123;</span><br><span class="line">        mQueue.start<span class="literal">()</span>;</span><br><span class="line">        mQueueStarted = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    modify<span class="constructor">Flags(PREPARING, SET)</span>;</span><br><span class="line">    mAsyncPrepareEvent = <span class="keyword">new</span> <span class="constructor">AwesomeEvent(<span class="params">this</span>, &amp;AwesomePlayer::<span class="params">onPrepareAsyncEvent</span>)</span>;</span><br><span class="line">    mQueue.post<span class="constructor">Event(<span class="params">mAsyncPrepareEvent</span>)</span>;</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在继续介绍prepare流程之前我们先来看下TimedEventQueue这个类。从名称上看它是一个事件队列。先来看下它的构造方法，这里很简单只是给它的成员变量初始化，并绑定一个DeathRecipient.</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">TimedEventQueue::<span class="constructor">TimedEventQueue()</span></span><br><span class="line">    : m<span class="constructor">NextEventID(1)</span>,</span><br><span class="line">      m<span class="constructor">Running(<span class="params">false</span>)</span>,</span><br><span class="line">      m<span class="constructor">Stopped(<span class="params">false</span>)</span>,</span><br><span class="line">      m<span class="constructor">DeathRecipient(<span class="params">new</span> PMDeathRecipient(<span class="params">this</span>)</span>),</span><br><span class="line">      m<span class="constructor">WakeLockCount(0)</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在start方法中创建一个ThreadWrapper线程。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void TimedEventQueue::start<span class="literal">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mRunning) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    mStopped = <span class="literal">false</span>;</span><br><span class="line">    pthread_attr_t attr;</span><br><span class="line">    pthread<span class="constructor">_attr_init(&amp;<span class="params">attr</span>)</span>;</span><br><span class="line">    pthread<span class="constructor">_attr_setdetachstate(&amp;<span class="params">attr</span>, PTHREAD_CREATE_JOINABLE)</span>;</span><br><span class="line">    pthread<span class="constructor">_create(&amp;<span class="params">mThread</span>, &amp;<span class="params">attr</span>, ThreadWrapper, <span class="params">this</span>)</span>;</span><br><span class="line">    pthread<span class="constructor">_attr_destroy(&amp;<span class="params">attr</span>)</span>;</span><br><span class="line">    mRunning = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="comment">// static</span></span><br><span class="line">void *TimedEventQueue::ThreadWrapper(void *me) &#123;</span><br><span class="line">    <span class="built_in">androidSetThreadPriority</span>(<span class="number">0</span>, ANDROID_PRIORITY_FOREGROUND);</span><br><span class="line">    static_cast&lt;TimedEventQueue *&gt;(me)-&gt;<span class="built_in">threadEntry</span>();</span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在ThreadWrapper线程中将会不断循环查看消息队列中的每个Event，看下是否达到执行的时间，如果消息队列为空则将会等待，如果达到超时时间10秒则会退出线程，如果在超时时间之前达到它的执行时间则调用该Event的fire方法。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TimedEventQueue::threadEntry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">prctl</span>(PR_SET_NAME, (<span class="type">unsigned</span> <span class="type">long</span>)<span class="string">&quot;TimedEventQueue&quot;</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">int64_t</span> now_us = <span class="number">0</span>;</span><br><span class="line">        sp&lt;Event&gt; event;</span><br><span class="line">        <span class="type">bool</span> wakeLocked = <span class="literal">false</span>;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">Mutex::Autolock <span class="title">autoLock</span><span class="params">(mLock)</span></span>;</span><br><span class="line">            <span class="keyword">if</span> (mStopped) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (mQueue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                mQueueNotEmptyCondition.<span class="built_in">wait</span>(mLock);</span><br><span class="line">            &#125;</span><br><span class="line">            event_id eventID = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mQueue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                    <span class="comment">// The only event in the queue could have been cancelled</span></span><br><span class="line">                    <span class="comment">// while we were waiting for its scheduled time.</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                List&lt;QueueItem&gt;::iterator it = mQueue.<span class="built_in">begin</span>();</span><br><span class="line">                eventID = (*it).event-&gt;<span class="built_in">eventID</span>();</span><br><span class="line"></span><br><span class="line">                now_us = ALooper::<span class="built_in">GetNowUs</span>();</span><br><span class="line">                <span class="type">int64_t</span> when_us = (*it).realtime_us;</span><br><span class="line">                <span class="type">int64_t</span> delay_us;</span><br><span class="line">                <span class="keyword">if</span> (when_us &lt; <span class="number">0</span> || when_us == INT64_MAX) &#123;</span><br><span class="line">                    delay_us = <span class="number">0</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    delay_us = when_us - now_us;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (delay_us &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">static</span> <span class="type">int64_t</span> kMaxTimeoutUs = <span class="number">10000000ll</span>;  <span class="comment">// 10 secs</span></span><br><span class="line">                <span class="type">bool</span> timeoutCapped = <span class="literal">false</span>;</span><br><span class="line">                    delay_us = kMaxTimeoutUs;</span><br><span class="line">                    timeoutCapped = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">status_t</span> err = mQueueHeadChangedCondition.<span class="built_in">waitRelative</span>(</span><br><span class="line">                        mLock, delay_us * <span class="number">1000ll</span>);</span><br><span class="line">                <span class="keyword">if</span> (!timeoutCapped &amp;&amp; err == -ETIMEDOUT) &#123;</span><br><span class="line">                    <span class="comment">// We finally hit the time this event is supposed to</span></span><br><span class="line">                    <span class="comment">// trigger.</span></span><br><span class="line">                    now_us = ALooper::<span class="built_in">GetNowUs</span>();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// The event w/ this id may have been cancelled while we&#x27;re</span></span><br><span class="line">            <span class="comment">// waiting for its trigger-time, in that case</span></span><br><span class="line">            <span class="comment">// removeEventFromQueue_l will return NULL.</span></span><br><span class="line">            <span class="comment">// Otherwise, the QueueItem will be removed</span></span><br><span class="line">            <span class="comment">// from the queue and the referenced event returned.</span></span><br><span class="line">            event = <span class="built_in">removeEventFromQueue_l</span>(eventID, &amp;wakeLocked);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (event != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// Fire event with the lock NOT held.</span></span><br><span class="line">            event-&gt;<span class="built_in">fire</span>(<span class="keyword">this</span>, now_us);</span><br><span class="line">            <span class="keyword">if</span> (wakeLocked) &#123;</span><br><span class="line">                <span class="function">Mutex::Autolock <span class="title">autoLock</span><span class="params">(mLock)</span></span>;</span><br><span class="line">                <span class="built_in">releaseWakeLock_l</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>fire 方法里面直接调用AwesomeEvent中mPlayer的mMethod方法，这个mMethod也就是我们在new AwesomeEvent时候传递进去的onPrepareAsyncEvent。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> AwesomeEvent : public TimedEventQueue::Event &#123;</span><br><span class="line"><span class="constructor">AwesomeEvent(AwesomePlayer <span class="operator">*</span><span class="params">player</span>,<span class="params">void</span> (AwesomePlayer::<span class="operator">*</span><span class="params">method</span>)</span><span class="literal">()</span>)</span><br><span class="line">    : m<span class="constructor">Player(<span class="params">player</span>)</span>,</span><br><span class="line">        m<span class="constructor">Method(<span class="params">method</span>)</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line">protected:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="constructor">AwesomeEvent()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> void fire(TimedEventQueue<span class="operator"> * </span><span class="comment">/* queue */</span>, int64_t <span class="comment">/* now_us */</span>) &#123;</span><br><span class="line">        (mPlayer-&gt;*mMethod)<span class="literal">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    AwesomePlayer *mPlayer;</span><br><span class="line">    void (AwesomePlayer::*mMethod)<span class="literal">()</span>;</span><br><span class="line">    <span class="constructor">AwesomeEvent(<span class="params">const</span> AwesomeEvent &amp;)</span>;</span><br><span class="line">    AwesomeEvent &amp;operator=(const AwesomeEvent &amp;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>所以我们需要看下AwesomePlayer 下的onPrepareAsyncEvent方法。在onPrepareAsyncEvent<br>方法中调用了beginPrepareAsync_l。在该方法中调用initAudioDecoder()对解码器进行了初始化。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void AwesomePlayer::on<span class="constructor">PrepareAsyncEvent()</span> &#123;</span><br><span class="line">    Mutex::Autolock auto<span class="constructor">Lock(<span class="params">mLock</span>)</span>;</span><br><span class="line">    <span class="keyword">begin</span><span class="constructor">PrepareAsync_l()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void AwesomePlayer::<span class="keyword">begin</span><span class="constructor">PrepareAsync_l()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mFlags &amp; PREPARE_CANCELLED) &#123;</span><br><span class="line">        <span class="constructor">ALOGI(<span class="string">&quot;prepare was cancelled before doing anything&quot;</span>)</span>;</span><br><span class="line">        abort<span class="constructor">Prepare(UNKNOWN_ERROR)</span>;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mUri.size<span class="literal">()</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        status_t err = finish<span class="constructor">SetDataSource_l()</span>;</span><br><span class="line">        <span class="keyword">if</span> (err != OK) &#123;</span><br><span class="line">            abort<span class="constructor">Prepare(<span class="params">err</span>)</span>;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mVideoTrack != NULL<span class="operator"> &amp;&amp; </span>mVideoSource<span class="operator"> == </span>NULL) &#123;</span><br><span class="line">        status_t err = init<span class="constructor">VideoDecoder()</span>;</span><br><span class="line">        <span class="keyword">if</span> (err != OK) &#123;</span><br><span class="line">            abort<span class="constructor">Prepare(<span class="params">err</span>)</span>;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mAudioTrack != NULL<span class="operator"> &amp;&amp; </span>mAudioSource<span class="operator"> == </span>NULL) &#123;</span><br><span class="line">        status_t err = init<span class="constructor">AudioDecoder()</span>;</span><br><span class="line">        <span class="keyword">if</span> (err != OK) &#123;</span><br><span class="line">            abort<span class="constructor">Prepare(<span class="params">err</span>)</span>;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    modify<span class="constructor">Flags(PREPARING_CONNECTED, SET)</span>;</span><br><span class="line">    <span class="keyword">if</span> (is<span class="constructor">StreamingHTTP()</span>) &#123;</span><br><span class="line">        post<span class="constructor">BufferingEvent_l()</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        finish<span class="constructor">AsyncPrepare_l()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整个过程如下图所示：<br><img src="/2016/07/31/Android-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E5%9F%BA%E4%BA%8EStagefright%E7%9A%84MediaPlayer%E6%92%AD%E6%94%BE%E6%A1%86%E6%9E%B6-2/1.png"></p>
<p>接下来我们重点看下解码器是怎样创建出来的，首先将会调用OMXCodec::Create来创建解码器。</p>
<figure class="highlight zephir"><table><tr><td class="code"><pre><span class="line">status_t AwesomePlayer::initAudioDecoder() &#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    sp&lt;MetaData&gt; meta = mAudioTrack-&gt;getFormat();</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *mime;</span><br><span class="line">    CHECK(meta-&gt;findCString(kKeyMIMEType, &amp;mime));</span><br><span class="line">    audio_stream_type_t streamType = AUDIO_STREAM_MUSIC;</span><br><span class="line">    <span class="keyword">if</span> (mAudioSink != NULL) &#123;</span><br><span class="line">        streamType = mAudioSink-&gt;getAudioStreamType();</span><br><span class="line">    &#125;</span><br><span class="line">    mOffloadAudio = canOffloadStream(meta, (mVideoSource != NULL),</span><br><span class="line">                                     isStreamingHTTP(), streamType);</span><br><span class="line">    <span class="keyword">if</span> (!strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_RAW)) &#123;</span><br><span class="line">        mAudioSource = mAudioTrack;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mOmxSource = OMXCodec::Create(</span><br><span class="line">                mClient.<span class="keyword">interface</span>(), mAudioTrack-&gt;getFormat(),</span><br><span class="line">                <span class="keyword">false</span>, <span class="comment">// createEncoder</span></span><br><span class="line">                mAudioTrack);</span><br><span class="line">        <span class="keyword">if</span> (mOffloadAudio) &#123;</span><br><span class="line">            mAudioSource = mAudioTrack;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mAudioSource = mOmxSource;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mAudioSource != NULL) &#123;</span><br><span class="line">        int64_t durationUs;</span><br><span class="line">        <span class="keyword">if</span> (mAudioTrack-&gt;getFormat()-&gt;findInt64(kKeyDuration, &amp;durationUs)) &#123;</span><br><span class="line">            Mutex::Autolock autoLock(mMiscStateLock);</span><br><span class="line">            <span class="keyword">if</span> (mDurationUs &lt; <span class="number">0</span> || durationUs &gt; mDurationUs) &#123;</span><br><span class="line">                mDurationUs = durationUs;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        status_t err = mAudioSource-&gt;start();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_QCELP)) &#123;</span><br><span class="line">        <span class="comment">// For legacy reasons we&#x27;re simply going to ignore the absence</span></span><br><span class="line">        <span class="comment">// of an audio decoder for QCELP instead of aborting playback</span></span><br><span class="line">        <span class="comment">// altogether.</span></span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mAudioSource != NULL) &#123;</span><br><span class="line">        Mutex::Autolock autoLock(mStatsLock);</span><br><span class="line">        TrackStat *stat = &amp;mStats.mTracks.editItemAt(mStats.mAudioTrackIndex);</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *component;</span><br><span class="line">        <span class="keyword">if</span> (!mAudioSource-&gt;getFormat()</span><br><span class="line">                -&gt;findCString(kKeyDecoderComponent, &amp;component)) &#123;</span><br><span class="line">            component = <span class="string">&quot;none&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        stat-&gt;mDecoderName = component;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mAudioSource != NULL ? OK : UNKNOWN_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建解码器之前我们需要获取当前播放文件的mimeType，然后根据这个mimeType查找对应的解码器，然后创建OMXCodecObserver，并将其赋给每个由allocateNode创建的解码器，并返回。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// static</span></span><br><span class="line"><span class="function">sp&lt;MediaSource&gt; <span class="title">OMXCodec::Create</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> sp&lt;IOMX&gt; &amp;omx,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> sp&lt;MetaData&gt; &amp;meta, <span class="type">bool</span> createEncoder,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> sp&lt;MediaSource&gt; &amp;source,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> <span class="type">char</span> *matchComponentName,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">uint32_t</span> flags,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> sp&lt;ANativeWindow&gt; &amp;nativeWindow)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取MimeType</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *mime;</span><br><span class="line">    <span class="type">bool</span> success = meta-&gt;<span class="built_in">findCString</span>(kKeyMIMEType, &amp;mime);</span><br><span class="line">    Vector&lt;CodecNameAndQuirks&gt; matchingCodecs;</span><br><span class="line">    <span class="comment">//查找匹配的解码器，这里主要从/etc/media_codecs.xml  /etc/media_codecs_performence.xml 中加载匹配对应mimetype的解码器。</span></span><br><span class="line">    <span class="built_in">findMatchingCodecs</span>(mime, createEncoder, matchComponentName, flags, &amp;matchingCodecs);</span><br><span class="line">    <span class="comment">//这里找到之后将放在matchingCodecs中，主要的存放形式为MediaCodecInfo的列表</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建OMXCodecObserver</span></span><br><span class="line">    sp&lt;OMXCodecObserver&gt; observer = <span class="keyword">new</span> OMXCodecObserver;</span><br><span class="line">    IOMX::node_id node = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; matchingCodecs.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *componentNameBase = matchingCodecs[i].mName.<span class="built_in">string</span>();</span><br><span class="line">        <span class="type">uint32_t</span> quirks = matchingCodecs[i].mQuirks;</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *componentName = componentNameBase;</span><br><span class="line">        <span class="comment">//通过从上面获取</span></span><br><span class="line">        <span class="type">status_t</span> err = omx-&gt;<span class="built_in">allocateNode</span>(componentName, observer, &amp;node);</span><br><span class="line">        <span class="keyword">if</span> (err == OK) &#123;</span><br><span class="line">            sp&lt;OMXCodec&gt; codec = <span class="keyword">new</span> <span class="built_in">OMXCodec</span>(</span><br><span class="line">                    omx, node, quirks, flags,</span><br><span class="line">                    createEncoder, mime, componentName,</span><br><span class="line">                    source, nativeWindow);</span><br><span class="line">            observer-&gt;<span class="built_in">setCodec</span>(codec);</span><br><span class="line">            err = codec-&gt;<span class="built_in">configureCodec</span>(meta);</span><br><span class="line">            <span class="keyword">if</span> (err == OK) &#123;</span><br><span class="line">                <span class="keyword">return</span> codec;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解码器的匹配是调用findMatchingCodecs来实现的，在开始之前首先获取当前所拥有的编码器的列表，它主要是通过解析&#x2F;etc&#x2F;media_codecs.xml这个文件来获取的，然后调用findCodecByType来判断能够处理当前播放文件类型的解码器，并将这些解码器添加到matchingCodecs中，这样返回的就是支持当前播放文件类型的解码器。</p>
<figure class="highlight zephir"><table><tr><td class="code"><pre><span class="line"><span class="comment">// static</span></span><br><span class="line">void OMXCodec::findMatchingCodecs(</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *mime,</span><br><span class="line">        <span class="keyword">bool</span> createEncoder, <span class="keyword">const</span> <span class="keyword">char</span> *matchComponentName,</span><br><span class="line">        uint32_t flags,</span><br><span class="line">        Vector&lt;CodecNameAndQuirks&gt; *matchingCodecs) &#123;</span><br><span class="line">    matchingCodecs-&gt;clear();</span><br><span class="line">    <span class="comment">//获取当前所拥有的编码器的列表</span></span><br><span class="line">    <span class="keyword">const</span> sp&lt;IMediaCodecList&gt; list = MediaCodecList::getInstance();</span><br><span class="line">    size_t index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="comment">//通过调用findCodecByType来判断的是否存在能够处理当前播放类型的解码器</span></span><br><span class="line">        ssize_t matchIndex =</span><br><span class="line">            list-&gt;findCodecByType(mime, createEncoder, index);</span><br><span class="line">        <span class="keyword">if</span> (matchIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        index = matchIndex + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">const</span> sp&lt;MediaCodecInfo&gt; info = list-&gt;getCodecInfo(matchIndex);</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *componentName = info-&gt;getCodecName();</span><br><span class="line">        <span class="keyword">if</span> (matchComponentName &amp;&amp; strcmp(componentName, matchComponentName)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// When requesting software-only codecs, only push software codecs</span></span><br><span class="line">        <span class="comment">// When requesting hardware-only codecs, only push hardware codecs</span></span><br><span class="line">        <span class="comment">// When there is request neither for software-only nor for</span></span><br><span class="line">        <span class="comment">// hardware-only codecs, push all codecs</span></span><br><span class="line">        <span class="keyword">if</span> (((flags &amp; kSoftwareCodecsOnly) &amp;&amp;   IsSoftwareCodec(componentName)) ||</span><br><span class="line">            ((flags &amp; kHardwareCodecsOnly) &amp;&amp;  !IsSoftwareCodec(componentName)) ||</span><br><span class="line">            (!(flags &amp; (kSoftwareCodecsOnly | kHardwareCodecsOnly)))) &#123;</span><br><span class="line">            <span class="comment">//将匹配的解码器添加到matchingCodecs</span></span><br><span class="line">            ssize_t index = matchingCodecs-&gt;add();</span><br><span class="line">            CodecNameAndQuirks *entry = &amp;matchingCodecs-&gt;editItemAt(index);</span><br><span class="line">            entry-&gt;mName = String8(componentName);</span><br><span class="line">            entry-&gt;mQuirks = getComponentQuirks(info);</span><br><span class="line"></span><br><span class="line">            ALOGV(<span class="string">&quot;matching &#x27;%s&#x27; quirks 0x%08x&quot;</span>,</span><br><span class="line">                  entry-&gt;mName.<span class="keyword">string</span>(), entry-&gt;mQuirks);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对解码器进行排序</span></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; kPreferSoftwareCodecs) &#123;</span><br><span class="line">        matchingCodecs-&gt;sort(CompareSoftwareCodecsFirst);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight isbl"><table><tr><td class="code"><pre><span class="line"><span class="comment">// static</span></span><br><span class="line"><span class="variable">sp</span>&lt;<span class="variable">IMediaCodecList</span>&gt; <span class="variable">MediaCodecList</span>::<span class="function"><span class="title">getInstance</span>() &#123;</span></span><br><span class="line"><span class="function">    <span class="variable">Mutex</span>::<span class="variable">Autolock</span> <span class="title">_l</span>(<span class="variable">sRemoteInitMutex</span>);</span></span><br><span class="line"><span class="function">    <span class="variable"><span class="keyword">if</span></span> (<span class="variable">sRemoteList</span> == <span class="variable"><span class="literal">NULL</span></span>) &#123;</span></span><br><span class="line"><span class="function">        <span class="variable">sp</span>&lt;<span class="variable">IBinder</span>&gt; <span class="variable">binder</span> =</span></span><br><span class="line"><span class="function">            <span class="title">defaultServiceManager</span>()-&gt;<span class="title">getService</span>(<span class="title">String16</span>(<span class="string">&quot;media.player&quot;</span>));</span></span><br><span class="line"><span class="function">        <span class="variable">sp</span>&lt;<span class="variable">IMediaPlayerService</span>&gt; <span class="variable">service</span> =</span></span><br><span class="line"><span class="function">            <span class="variable">interface_cast</span>&lt;<span class="variable">IMediaPlayerService</span>&gt;(<span class="variable">binder</span>);</span></span><br><span class="line"><span class="function">        <span class="variable"><span class="keyword">if</span></span> (<span class="variable">service.get</span>() <span class="variable">!</span>= <span class="variable"><span class="literal">NULL</span></span>) &#123;</span></span><br><span class="line"><span class="function">            <span class="variable">sRemoteList</span> = <span class="variable">service</span>-&gt;<span class="title">getCodecList</span>();</span></span><br><span class="line"><span class="function">        &#125;</span></span><br><span class="line"><span class="function">        <span class="variable"><span class="keyword">if</span></span> (<span class="variable">sRemoteList</span> == <span class="variable"><span class="literal">NULL</span></span>) &#123;</span></span><br><span class="line"><span class="function">            <span class="comment">// if failed to get remote list, create local list</span></span></span><br><span class="line"><span class="function">            <span class="variable">sRemoteList</span> = <span class="title">getLocalInstance</span>();</span></span><br><span class="line"><span class="function">        &#125;</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function">    <span class="variable">return</span> <span class="variable">sRemoteList</span>;</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">sp&lt;IMediaCodecList&gt; MediaPlayerService::<span class="built_in">getCodecList</span>() const &#123;</span><br><span class="line">    return MediaCodecList::<span class="built_in">getLocalInstance</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// static</span></span><br><span class="line"><span class="function">sp&lt;IMediaCodecList&gt; <span class="title">MediaCodecList::getLocalInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Mutex::Autolock <span class="title">autoLock</span><span class="params">(sInitMutex)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (sCodecList == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        MediaCodecList *codecList = <span class="keyword">new</span> MediaCodecList;</span><br><span class="line">        <span class="keyword">if</span> (codecList-&gt;<span class="built_in">initCheck</span>() == OK) &#123;</span><br><span class="line">            sCodecList = codecList;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">delete</span> codecList;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sCodecList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">MediaCodecList::<span class="constructor">MediaCodecList()</span></span><br><span class="line">    : m<span class="constructor">InitCheck(NO_INIT)</span>,</span><br><span class="line">      m<span class="constructor">Update(<span class="params">false</span>)</span>,</span><br><span class="line">      m<span class="constructor">GlobalSettings(<span class="params">new</span> AMessage()</span>) &#123;</span><br><span class="line">    parse<span class="constructor">TopLevelXMLFile(<span class="string">&quot;/etc/media_codecs.xml&quot;</span>)</span>;</span><br><span class="line">    parse<span class="constructor">TopLevelXMLFile(<span class="string">&quot;/etc/media_codecs_performance.xml&quot;</span>, <span class="params">true</span>)</span>;</span><br><span class="line">    parse<span class="constructor">TopLevelXMLFile(<span class="params">kProfilingResults</span>, <span class="params">true</span><span class="operator">/</span><span class="operator">*</span> <span class="params">ignore_errors</span> <span class="operator">*</span><span class="operator">/</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">MediaCodecList::findCodecByType</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> <span class="type">char</span> *type, <span class="type">bool</span> encoder, <span class="type">size_t</span> startIndex)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">char</span> *advancedFeatures[] = &#123;</span><br><span class="line">        <span class="string">&quot;feature-secure-playback&quot;</span>,</span><br><span class="line">        <span class="string">&quot;feature-tunneled-playback&quot;</span>,</span><br><span class="line">    &#125;;  </span><br><span class="line">    <span class="type">size_t</span> numCodecs = mCodecInfos.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">//遍历编解码器列表中的每个项。</span></span><br><span class="line">    <span class="keyword">for</span> (; startIndex &lt; numCodecs; ++startIndex) &#123;</span><br><span class="line">        <span class="type">const</span> MediaCodecInfo &amp;info = *mCodecInfos.<span class="built_in">itemAt</span>(startIndex).<span class="built_in">get</span>();</span><br><span class="line">        <span class="comment">//判断是否是解码器，如果不是则接着加载下一个进行判断</span></span><br><span class="line">        <span class="keyword">if</span> (info.<span class="built_in">isEncoder</span>() != encoder) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断是否能够支持当前的MimeType</span></span><br><span class="line">        sp&lt;MediaCodecInfo::Capabilities&gt; capabilities = info.<span class="built_in">getCapabilitiesFor</span>(type);</span><br><span class="line">        <span class="keyword">if</span> (capabilities == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">const</span> sp&lt;AMessage&gt; &amp;details = capabilities-&gt;<span class="built_in">getDetails</span>();</span><br><span class="line">        <span class="type">int32_t</span> required;</span><br><span class="line">        <span class="type">bool</span> isAdvanced = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> ix = <span class="number">0</span>; ix &lt; <span class="built_in">ARRAY_SIZE</span>(advancedFeatures); ix++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (details-&gt;<span class="built_in">findInt32</span>(advancedFeatures[ix], &amp;required) &amp;&amp;</span><br><span class="line">                    required != <span class="number">0</span>) &#123;</span><br><span class="line">                isAdvanced = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!isAdvanced) &#123;</span><br><span class="line">            <span class="keyword">return</span> startIndex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -ENOENT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2016/07/31/Android-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E5%9F%BA%E4%BA%8EStagefright%E7%9A%84MediaPlayer%E6%92%AD%E6%94%BE%E6%A1%86%E6%9E%B6-2/22.png"></p>
<p>通过上述步骤只是过滤出能够支持当前播放文件类型的解码器信息，但是并没有对这些解码器进行实例化。解码器的实例化是通过如下代码片来完成的。</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line"><span class="comment">//分配节点</span></span><br><span class="line"><span class="function"><span class="title">status_t</span> err = omx-&gt;</span>allocateNode(componentName, observer, &amp;node);</span><br><span class="line"><span class="comment">//创建解码器的实例</span></span><br><span class="line">sp&lt;OMXCodec&gt; codec = new OMXCodec(omx, node, quirks, flags,</span><br><span class="line">                    createEncoder, mime, componentName,</span><br><span class="line">                    source, nativeWindow);</span><br><span class="line"><span class="comment">//将实例赋给observer</span></span><br><span class="line"><span class="function"><span class="title">observer</span>-&gt;</span>setCodec(codec);</span><br><span class="line"><span class="comment">//并用meta来配置创建出来的解码器实例</span></span><br><span class="line"><span class="function"><span class="title">err</span> = codec-&gt;</span>configureCodec(meta);</span><br></pre></td></tr></table></figure>
<p>在allocateNode开始的时候首先创建OMXNodeInstance对象，然后调用<br>makeComponentInstance创建实例。</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">status_t OMX::allocateNode(</span><br><span class="line">        const char *name, const sp<span class="tag">&lt;IOMXObserver&gt;</span> &amp;observer, node_id *<span class="keyword">node</span><span class="title">) &#123;</span></span><br><span class="line"><span class="title">    Mutex</span>::Autolock autoLock(mLock);</span><br><span class="line">    *<span class="keyword">node</span> <span class="title">= 0</span>;</span><br><span class="line">    OMXNodeInstance *instance = new OMXNodeInstance(this, observer, name);</span><br><span class="line">    OMX_COMPONENTTYPE *handle;</span><br><span class="line">    OMX_ERRORTYPE err = mMaster-&gt;makeComponentInstance(name, &amp;OMXNodeInstance::kCallbacks,instance, &amp;handle);</span><br><span class="line">    *<span class="keyword">node</span> <span class="title">= makeNodeID</span>(instance);</span><br><span class="line">    mDispatchers.add(*<span class="keyword">node</span><span class="title">, new</span> CallbackDispatcher(instance));</span><br><span class="line">    instance-&gt;setHandle(*<span class="keyword">node</span><span class="title">, handle</span>);</span><br><span class="line">    mLiveNodes.add(IInterface::asBinder(observer), instance);</span><br><span class="line">    IInterface::asBinder(observer)-&gt;linkToDeath(this);</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>OMXNodeInstance构造方法比较简单这里就不详细介绍了。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">OMXNodeInstance::OMXNodeInstance(</span><br><span class="line">        OMX *<span class="keyword">owner</span>, const sp&lt;IOMXObserver&gt; &amp;observer, const <span class="type">char</span> *<span class="type">name</span>)</span><br><span class="line">    : mOwner(<span class="keyword">owner</span>),</span><br><span class="line">      mNodeID(<span class="number">0</span>),</span><br><span class="line">      mHandle(<span class="keyword">NULL</span>),</span><br><span class="line">      mObserver(observer),</span><br><span class="line">      mDying(<span class="keyword">false</span>),</span><br><span class="line">      mBufferIDCount(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    mName = ADebug::GetDebugName(<span class="type">name</span>);</span><br><span class="line">    <span class="keyword">DEBUG</span> = ADebug::GetDebugLevelFromProperty(<span class="type">name</span>, &quot;debug.stagefright.omx-debug&quot;);</span><br><span class="line">    ALOGV(&quot;debug level for %s is %d&quot;, <span class="type">name</span>, <span class="keyword">DEBUG</span>);</span><br><span class="line">    DEBUG_BUMP = <span class="keyword">DEBUG</span>;</span><br><span class="line">    mNumPortBuffers[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    mNumPortBuffers[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    mDebugLevelBumpPendingBuffers[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    mDebugLevelBumpPendingBuffers[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    mMetadataType[<span class="number">0</span>] = kMetadataBufferTypeInvalid;</span><br><span class="line">    mMetadataType[<span class="number">1</span>] = kMetadataBufferTypeInvalid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>makeComponentInstance方法首先通过调用mPluginByComponentName.indexOfKey(String8(name))找到指定名字解码器的索引,然后调用mPluginByComponentName.valueAt(index);返回解码器实例。这个mPluginByComponentName是在创建AwesomePlayer的时候创建的。里面存放的是所支持的VentorPlugin以及SoftPlugin<br>ssize_t index &#x3D; mPluginByComponentName.indexOfKey(String8(name));<br>OMXPluginBase *plugin &#x3D; mPluginByComponentName.valueAt(index);然后调用对应plugin的makeComponentInstance创建出实例，然后将其添加到mPluginByInstance中</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">OMX_ERRORTYPE OMXMaster::makeComponentInstance(</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *name,</span><br><span class="line">        <span class="keyword">const</span> OMX_CALLBACKTYPE *callbacks,</span><br><span class="line">        OMX_PTR appData,</span><br><span class="line">        OMX_COMPONENTTYPE **component) &#123;</span><br><span class="line">    Mutex::Autolock autoLock(mLock);</span><br><span class="line"><span class="comment">*component = NULL;</span></span><br><span class="line"><span class="comment">//首先通过调用mPluginByComponentName.indexOfKey(String8(name))找到指定名字解码器的索引,然后调用mPluginByComponentName.valueAt(index);返回解码器实例。</span></span><br><span class="line"><span class="comment">//这个mPluginByComponentName是在创建AwesomePlayer的时候创建的。里面存放的  </span></span><br><span class="line"><span class="comment">//是所支持的VentorPlugin以及SoftPlugin</span></span><br><span class="line">    ssize_t index = mPluginByComponentName.indexOfKey(String8(name));</span><br><span class="line">OMXPluginBase *<span class="keyword">plugin</span> = mPluginByComponentName.valueAt(index);</span><br><span class="line"><span class="comment">//然后调用对应plugin的makeComponentInstance创建出实例，然后将其添加到  </span></span><br><span class="line"><span class="comment">//mPluginByInstance中</span></span><br><span class="line">    OMX_ERRORTYPE <span class="keyword">err</span> =</span><br><span class="line">        <span class="keyword">plugin</span>-&gt;makeComponentInstance(name, callbacks, appData, component);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">err</span> != OMX_ErrorNone) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">err</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mPluginByInstance.add(*component, <span class="keyword">plugin</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">err</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们以软解码器为例子来分析makeComponentInstance过程：<br>首先SoftOMXPlugin::makeComponentInstance会从kComponents数组中找到对应的解码器信息，kComponents是一个结构体数组，存放着编码器名，动态链接库后缀，以及是编码器还是解码器信息。然后根据动态链接库的后缀构建出对应解码器的库文件名，接着打开该库文件，调用其中的createSoftOMXComponent方法，创建出对应的软解码器。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">OMX_ERRORTYPE <span class="title">SoftOMXPlugin::makeComponentInstance</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> <span class="type">char</span> *name,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> OMX_CALLBACKTYPE *callbacks,</span></span></span><br><span class="line"><span class="params"><span class="function">        OMX_PTR appData,</span></span></span><br><span class="line"><span class="params"><span class="function">        OMX_COMPONENTTYPE **component)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; kNumComponents; ++i) &#123;</span><br><span class="line">        <span class="comment">// 在kComponents数组中找到对应的解码器信息，</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(name, kComponents[i].mName)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//构建出对应解码器的库文件名，我们以MP3为例返回的库文件名为：</span></span><br><span class="line">        <span class="comment">// libstagefright_soft_mp3dec.so</span></span><br><span class="line">        AString libName = <span class="string">&quot;libstagefright_soft_&quot;</span>;</span><br><span class="line">        libName.<span class="built_in">append</span>(kComponents[i].mLibNameSuffix);</span><br><span class="line">        libName.<span class="built_in">append</span>(<span class="string">&quot;.so&quot;</span>);</span><br><span class="line">        <span class="comment">//打开该库文件，调用其中的createSoftOMXComponent方法</span></span><br><span class="line">       <span class="comment">//创建对应的解码器</span></span><br><span class="line">        <span class="type">void</span> *libHandle = <span class="built_in">dlopen</span>(libName.<span class="built_in">c_str</span>(), RTLD_NOW);</span><br><span class="line">        <span class="keyword">typedef</span> SoftOMXComponent *(*CreateSoftOMXComponentFunc)(</span><br><span class="line">                <span class="type">const</span> <span class="type">char</span> *, <span class="type">const</span> OMX_CALLBACKTYPE *,</span><br><span class="line">                OMX_PTR, OMX_COMPONENTTYPE **);</span><br><span class="line">        CreateSoftOMXComponentFunc createSoftOMXComponent =</span><br><span class="line">            (CreateSoftOMXComponentFunc)<span class="built_in">dlsym</span>(</span><br><span class="line">                    libHandle,</span><br><span class="line">                    <span class="string">&quot;_Z22createSoftOMXComponentPKcPK16OMX_CALLBACKTYPE&quot;</span></span><br><span class="line">                    <span class="string">&quot;PvPP17OMX_COMPONENTTYPE&quot;</span>);</span><br><span class="line">        sp&lt;SoftOMXComponent&gt; codec =</span><br><span class="line">            (*createSoftOMXComponent)(name, callbacks, appData, component);</span><br><span class="line">        OMX_ERRORTYPE err = codec-&gt;<span class="built_in">initCheck</span>();</span><br><span class="line">        codec-&gt;<span class="built_in">incStrong</span>(<span class="keyword">this</span>);</span><br><span class="line">        codec-&gt;<span class="built_in">setLibHandle</span>(libHandle);</span><br><span class="line">        <span class="keyword">return</span> OMX_ErrorNone;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OMX_ErrorInvalidComponentName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *mName;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *mLibNameSuffix;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *mRole;</span><br><span class="line">&#125; kComponents[] = &#123;</span><br><span class="line">    &#123; <span class="string">&quot;OMX.google.aac.decoder&quot;</span>, <span class="string">&quot;aacdec&quot;</span>, <span class="string">&quot;audio_decoder.aac&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;OMX.google.aac.encoder&quot;</span>, <span class="string">&quot;aacenc&quot;</span>, <span class="string">&quot;audio_encoder.aac&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;OMX.google.amrnb.decoder&quot;</span>, <span class="string">&quot;amrdec&quot;</span>, <span class="string">&quot;audio_decoder.amrnb&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;OMX.google.amrnb.encoder&quot;</span>, <span class="string">&quot;amrnbenc&quot;</span>, <span class="string">&quot;audio_encoder.amrnb&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;OMX.google.amrwb.decoder&quot;</span>, <span class="string">&quot;amrdec&quot;</span>, <span class="string">&quot;audio_decoder.amrwb&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;OMX.google.amrwb.encoder&quot;</span>, <span class="string">&quot;amrwbenc&quot;</span>, <span class="string">&quot;audio_encoder.amrwb&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;OMX.google.h264.decoder&quot;</span>, <span class="string">&quot;avcdec&quot;</span>, <span class="string">&quot;video_decoder.avc&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;OMX.google.h264.encoder&quot;</span>, <span class="string">&quot;avcenc&quot;</span>, <span class="string">&quot;video_encoder.avc&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;OMX.google.hevc.decoder&quot;</span>, <span class="string">&quot;hevcdec&quot;</span>, <span class="string">&quot;video_decoder.hevc&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;OMX.google.g711.alaw.decoder&quot;</span>, <span class="string">&quot;g711dec&quot;</span>, <span class="string">&quot;audio_decoder.g711alaw&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;OMX.google.g711.mlaw.decoder&quot;</span>, <span class="string">&quot;g711dec&quot;</span>, <span class="string">&quot;audio_decoder.g711mlaw&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;OMX.google.mpeg2.decoder&quot;</span>, <span class="string">&quot;mpeg2dec&quot;</span>, <span class="string">&quot;video_decoder.mpeg2&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;OMX.google.h263.decoder&quot;</span>, <span class="string">&quot;mpeg4dec&quot;</span>, <span class="string">&quot;video_decoder.h263&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;OMX.google.h263.encoder&quot;</span>, <span class="string">&quot;mpeg4enc&quot;</span>, <span class="string">&quot;video_encoder.h263&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;OMX.google.mpeg4.decoder&quot;</span>, <span class="string">&quot;mpeg4dec&quot;</span>, <span class="string">&quot;video_decoder.mpeg4&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;OMX.google.mpeg4.encoder&quot;</span>, <span class="string">&quot;mpeg4enc&quot;</span>, <span class="string">&quot;video_encoder.mpeg4&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;OMX.google.mp3.decoder&quot;</span>, <span class="string">&quot;mp3dec&quot;</span>, <span class="string">&quot;audio_decoder.mp3&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;OMX.google.vorbis.decoder&quot;</span>, <span class="string">&quot;vorbisdec&quot;</span>, <span class="string">&quot;audio_decoder.vorbis&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;OMX.google.opus.decoder&quot;</span>, <span class="string">&quot;opusdec&quot;</span>, <span class="string">&quot;audio_decoder.opus&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;OMX.google.vp8.decoder&quot;</span>, <span class="string">&quot;vpxdec&quot;</span>, <span class="string">&quot;video_decoder.vp8&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;OMX.google.vp9.decoder&quot;</span>, <span class="string">&quot;vpxdec&quot;</span>, <span class="string">&quot;video_decoder.vp9&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;OMX.google.vp8.encoder&quot;</span>, <span class="string">&quot;vpxenc&quot;</span>, <span class="string">&quot;video_encoder.vp8&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;OMX.google.raw.decoder&quot;</span>, <span class="string">&quot;rawdec&quot;</span>, <span class="string">&quot;audio_decoder.raw&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;OMX.google.flac.encoder&quot;</span>, <span class="string">&quot;flacenc&quot;</span>, <span class="string">&quot;audio_encoder.flac&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;OMX.google.gsm.decoder&quot;</span>, <span class="string">&quot;gsmdec&quot;</span>, <span class="string">&quot;audio_decoder.gsm&quot;</span> &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>每个软解码器都有一个createSoftOMXComponent方法。我们以MP3软解码器为例，在它内部通过 android::SoftMP3构造方法创建出MP3软解码器。</p>
<figure class="highlight zephir"><table><tr><td class="code"><pre><span class="line">android::SoftOMXComponent *createSoftOMXComponent(</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> OMX_CALLBACKTYPE *callbacks,</span><br><span class="line">        OMX_PTR appData, OMX_COMPONENTTYPE **component) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> android::SoftMP3(name, callbacks, appData, component);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里估计大家会有点晕了吧，如果有点晕我这里再上个图做个小总结：<br><img src="/2016/07/31/Android-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E5%9F%BA%E4%BA%8EStagefright%E7%9A%84MediaPlayer%E6%92%AD%E6%94%BE%E6%A1%86%E6%9E%B6-2/23.png"><br>我们在创建解码器实例的时候传入的是媒体文件的mimeType，拿着这个mimetype我们去匹配可以处理这个格式的解码器，和什么匹配？就是从&#x2F;etc&#x2F;media_codecs.xml.&#x2F;etc&#x2F;media_codec_performance.xml这两个xml文件中解析出来的数据中匹配，这里记录了平台所支持的每个编解码器的信息，每个信息封装在一个MediaCodecInfo对象中。<br>匹配后的所有MediaCodecInfo存放在matchingCodecs列表中，然后再拿着这个列表中的每个解码器的ComponentName到mPluginByComponentName中查找对应的plugin。比如MP3那么我们会找到SoftOMXPlugin，然后再从对应的库中调用库内部的createSoftOMXComponent方法创建出SoftMp3这个component，初始化后加入到mPluginByInstance</p>
<p>在MP3软编码器构造方法中最重要的有三个步骤</p>
<ol>
<li>SimpleSoftOMXComponent的创建</li>
<li>initPorts();</li>
<li>initDecoder();<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">SoftMP3::<span class="built_in">SoftMP3</span>(</span><br><span class="line">        const char *name,</span><br><span class="line">        const OMX_CALLBACKTYPE *callbacks,</span><br><span class="line">        OMX_PTR appData,</span><br><span class="line">        OMX_COMPONENTTYPE **component)</span><br><span class="line">    : <span class="built_in">SimpleSoftOMXComponent</span>(name, callbacks, appData, component),</span><br><span class="line">      <span class="built_in">mConfig</span>(new tPVMP3DecoderExternal),</span><br><span class="line">      <span class="built_in">mDecoderBuf</span>(NULL),</span><br><span class="line">      <span class="built_in">mAnchorTimeUs</span>(<span class="number">0</span>),</span><br><span class="line">      <span class="built_in">mNumFramesOutput</span>(<span class="number">0</span>),</span><br><span class="line">      <span class="built_in">mNumChannels</span>(<span class="number">2</span>),</span><br><span class="line">      <span class="built_in">mSamplingRate</span>(<span class="number">44100</span>),</span><br><span class="line">      <span class="built_in">mSignalledError</span>(false),</span><br><span class="line">      <span class="built_in">mSawInputEos</span>(false),</span><br><span class="line">      <span class="built_in">mSignalledOutputEos</span>(false),</span><br><span class="line">      <span class="built_in">mOutputPortSettingsChange</span>(NONE) &#123;</span><br><span class="line">    initPorts();</span><br><span class="line">    initDecoder();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
在SimpleSoftOMXComponent构造方法中主要是创建了SoftOMXComponent，并初始化了一个mHandler以及一个mLooper，并将mHandler注册到对应的mLooper，然后启动mLooper。<br>在mHandler中能够处理kWhatEmptyThisBuffer，kWhatFillThisBuffer，kWhatSendCommand这些事件，当这些事件触发后将会被发送到SimpleSoftOMXComponent::onMessageReceived中进行处理。<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">SimpleSoftOMXComponent::SimpleSoftOMXComponent(</span><br><span class="line">        const char *<span class="keyword">name</span>,</span><br><span class="line">        const OMX_CALLBACKTYPE *callbacks,</span><br><span class="line">        OMX_PTR appData,</span><br><span class="line">        OMX_COMPONENTTYPE **component)</span><br><span class="line">    : SoftOMXComponent(<span class="keyword">name</span>, callbacks, appData, component),</span><br><span class="line">      mLooper(new ALooper),</span><br><span class="line">      mHandler(new AHandlerReflector&lt;SimpleSoftOMXComponent&gt;(this)),</span><br><span class="line">      mState(OMX_StateLoaded),</span><br><span class="line">      mTargetState(OMX_StateLoaded) &#123;</span><br><span class="line">    <span class="function"><span class="title">mLooper</span>-&gt;</span>setName(<span class="keyword">name</span>);</span><br><span class="line">    <span class="function"><span class="title">mLooper</span>-&gt;</span>registerHandler(mHandler);</span><br><span class="line">    <span class="function"><span class="title">mLooper</span>-&gt;</span>start(</span><br><span class="line">            <span class="literal">false</span>, <span class="comment">// runOnCallingThread</span></span><br><span class="line">            <span class="literal">false</span>, <span class="comment">// canCallJava</span></span><br><span class="line">            ANDROID_PRIORITY_FOREGROUND);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
我们看下SoftOMXComponent::SoftOMXComponent，这部分主要是new出一个OMX_COMPONENTTYPE，它是一个结构体对象，在<br>frameworks&#x2F;native&#x2F;include&#x2F;media&#x2F;openmax&#x2F;OMX_Component.h文件中对其定义。<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">SoftOMXComponent::SoftOMXComponent(</span><br><span class="line">        const char *<span class="keyword">name</span>,</span><br><span class="line">        const OMX_CALLBACKTYPE *callbacks,</span><br><span class="line">        OMX_PTR appData,</span><br><span class="line">        OMX_COMPONENTTYPE **component)</span><br><span class="line">    : mName(<span class="keyword">name</span>),</span><br><span class="line">      mCallbacks(callbacks),</span><br><span class="line">      mComponent(new OMX_COMPONENTTYPE),</span><br><span class="line">      mLibHandle(NULL) &#123;</span><br><span class="line">    <span class="function"><span class="title">mComponent</span>-&gt;</span>nSize = sizeof(*mComponent);</span><br><span class="line">    <span class="function"><span class="title">mComponent</span>-&gt;</span>nVersion.s.nVersionMajor = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="title">mComponent</span>-&gt;</span>nVersion.s.nVersionMinor = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="title">mComponent</span>-&gt;</span>nVersion.s.nRevision = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="title">mComponent</span>-&gt;</span>nVersion.s.nStep = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="title">mComponent</span>-&gt;</span>pComponentPrivate = this;</span><br><span class="line">    <span class="function"><span class="title">mComponent</span>-&gt;</span>pApplicationPrivate = appData;</span><br><span class="line">    <span class="function"><span class="title">mComponent</span>-&gt;</span>GetComponentVersion = NULL;</span><br><span class="line">    <span class="function"><span class="title">mComponent</span>-&gt;</span>SendCommand = SendCommandWrapper;</span><br><span class="line">    <span class="function"><span class="title">mComponent</span>-&gt;</span>GetParameter = GetParameterWrapper;</span><br><span class="line">    <span class="function"><span class="title">mComponent</span>-&gt;</span>SetParameter = SetParameterWrapper;</span><br><span class="line">    <span class="function"><span class="title">mComponent</span>-&gt;</span>GetConfig = GetConfigWrapper;</span><br><span class="line">    <span class="function"><span class="title">mComponent</span>-&gt;</span>SetConfig = SetConfigWrapper;</span><br><span class="line">    <span class="function"><span class="title">mComponent</span>-&gt;</span>GetExtensionIndex = GetExtensionIndexWrapper;</span><br><span class="line">    <span class="function"><span class="title">mComponent</span>-&gt;</span>GetState = GetStateWrapper;</span><br><span class="line">    <span class="function"><span class="title">mComponent</span>-&gt;</span>ComponentTunnelRequest = NULL;</span><br><span class="line">    <span class="function"><span class="title">mComponent</span>-&gt;</span>UseBuffer = UseBufferWrapper;</span><br><span class="line">    <span class="function"><span class="title">mComponent</span>-&gt;</span>AllocateBuffer = AllocateBufferWrapper;</span><br><span class="line">    <span class="function"><span class="title">mComponent</span>-&gt;</span>FreeBuffer = FreeBufferWrapper;</span><br><span class="line">    <span class="function"><span class="title">mComponent</span>-&gt;</span>EmptyThisBuffer = EmptyThisBufferWrapper;</span><br><span class="line">    <span class="function"><span class="title">mComponent</span>-&gt;</span>FillThisBuffer = FillThisBufferWrapper;</span><br><span class="line">    <span class="function"><span class="title">mComponent</span>-&gt;</span>SetCallbacks = NULL;</span><br><span class="line">    <span class="function"><span class="title">mComponent</span>-&gt;</span>ComponentDeInit = NULL;</span><br><span class="line">    <span class="function"><span class="title">mComponent</span>-&gt;</span>UseEGLImage = NULL;</span><br><span class="line">    <span class="function"><span class="title">mComponent</span>-&gt;</span>ComponentRoleEnum = NULL;</span><br><span class="line">    *component = mComponent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
上面构造方法中的callback的定义如下：<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// static</span></span><br><span class="line">OMX_CALLBACKTYPE OMXNodeInstance::kC<span class="attr">allbacks</span> <span class="operator">=</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="variable">&amp;</span>OnEvent, <span class="variable">&amp;</span>OnEmptyBufferDone, <span class="variable">&amp;</span>OnFillBufferDone</span><br><span class="line"><span class="punctuation">&#125;;</span></span><br></pre></td></tr></table></figure>
在initPorts方法中创建了两个端口，一个为输入端口，一个为输出端口，其中输入端口的index为0，输出端口的index为1.<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">void SoftMP3::initPorts() &#123;</span><br><span class="line">    OMX_PARAM_PORTDEFINITIONTYPE <span class="keyword">def</span>;</span><br><span class="line">    InitOMXParams(&amp;<span class="keyword">def</span>);</span><br><span class="line">    <span class="keyword">def</span>.nPortIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">def</span>.eDir = OMX_DirInput;</span><br><span class="line">    <span class="keyword">def</span>.nBufferCountMin = kNumBuffers;</span><br><span class="line">    <span class="keyword">def</span>.nBufferCountActual = <span class="keyword">def</span>.nBufferCountMin;</span><br><span class="line">    <span class="keyword">def</span>.nBufferSize = <span class="number">8192</span>;</span><br><span class="line">    <span class="keyword">def</span>.bEnabled = OMX_TRUE;</span><br><span class="line">    <span class="keyword">def</span>.bPopulated = OMX_FALSE;</span><br><span class="line">    <span class="keyword">def</span>.eDomain = OMX_PortDomainAudio;</span><br><span class="line">    <span class="keyword">def</span>.bBuffersContiguous = OMX_FALSE;</span><br><span class="line">    <span class="keyword">def</span>.nBufferAlignment = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">def</span>.<span class="built_in">format</span>.audio.cMIMEType = const_cast&lt;char *&gt;(MEDIA_MIMETYPE_AUDIO_MPEG);</span><br><span class="line">    <span class="keyword">def</span>.<span class="built_in">format</span>.audio.pNativeRender = NULL;</span><br><span class="line">    <span class="keyword">def</span>.<span class="built_in">format</span>.audio.bFlagErrorConcealment = OMX_FALSE;</span><br><span class="line">    <span class="keyword">def</span>.<span class="built_in">format</span>.audio.eEncoding = OMX_AUDIO_CodingMP3;</span><br><span class="line">    addPort(<span class="keyword">def</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span>.nPortIndex = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">def</span>.eDir = OMX_DirOutput;</span><br><span class="line">    <span class="keyword">def</span>.nBufferCountMin = kNumBuffers;</span><br><span class="line">    <span class="keyword">def</span>.nBufferCountActual = <span class="keyword">def</span>.nBufferCountMin;</span><br><span class="line">    <span class="keyword">def</span>.nBufferSize = kOutputBufferSize;</span><br><span class="line">    <span class="keyword">def</span>.bEnabled = OMX_TRUE;</span><br><span class="line">    <span class="keyword">def</span>.bPopulated = OMX_FALSE;</span><br><span class="line">    <span class="keyword">def</span>.eDomain = OMX_PortDomainAudio;</span><br><span class="line">    <span class="keyword">def</span>.bBuffersContiguous = OMX_FALSE;</span><br><span class="line">    <span class="keyword">def</span>.nBufferAlignment = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">def</span>.<span class="built_in">format</span>.audio.cMIMEType = const_cast&lt;char *&gt;(<span class="string">&quot;audio/raw&quot;</span>);</span><br><span class="line">    <span class="keyword">def</span>.<span class="built_in">format</span>.audio.pNativeRender = NULL;</span><br><span class="line">    <span class="keyword">def</span>.<span class="built_in">format</span>.audio.bFlagErrorConcealment = OMX_FALSE;</span><br><span class="line">    <span class="keyword">def</span>.<span class="built_in">format</span>.audio.eEncoding = OMX_AUDIO_CodingPCM;</span><br><span class="line">    addPort(<span class="keyword">def</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
紧接着调用initDecoder来初始化解码器。<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void SoftMP3::init<span class="constructor">Decoder()</span> &#123;</span><br><span class="line">    mConfig-&gt;equalizerType = flat;</span><br><span class="line">    mConfig-&gt;crcEnabled = <span class="literal">false</span>;</span><br><span class="line">    uint32_t memRequirements = pvmp3<span class="constructor">_decoderMemRequirements()</span>;</span><br><span class="line">    mDecoderBuf = malloc(memRequirements);</span><br><span class="line">    pvmp3<span class="constructor">_InitDecoder(<span class="params">mConfig</span>, <span class="params">mDecoderBuf</span>)</span>;</span><br><span class="line">    mIsFirst = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
到这里我们再回头总结下，我们之前介绍过如何从传入的mimetype到创建出component。这里component个人认为是一个解码组件，它有一个核心的解码器以及一个输入端口，一个输出端口，上面所作的工作就是初始化这个核心解码器，以及解码器的输入端口和输出端口的配置。<br>这里还需要注意的是OMX_CALLBACKTYPE，OMX_COMPONENTTYPE这两个对象以及mHandler。还是上个图吧，无图无真相！</li>
</ol>
<p><img src="/2016/07/31/Android-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E5%9F%BA%E4%BA%8EStagefright%E7%9A%84MediaPlayer%E6%92%AD%E6%94%BE%E6%A1%86%E6%9E%B6-2/24.png"></p>
<p>我们回过头来看下allocateNode，在对应的解码器创建结束后调用makeNodeID为对应的node创建ID并添加到mNodeIDToInstance中。这里每个实例对应一个id</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">OMX::node_id OMX::makeNodeID(OMXNodeInstance *instance) &#123;</span><br><span class="line">    // mLock is already held.</span><br><span class="line">    node_id <span class="keyword">node</span> <span class="title">= (node_id</span>)++mNodeCounter;</span><br><span class="line">    mNodeIDToInstance.add(<span class="keyword">node</span><span class="title">, instance</span>);</span><br><span class="line">    return <span class="keyword">node</span><span class="title">;</span></span><br><span class="line"><span class="title">&#125;</span></span><br></pre></td></tr></table></figure>
<p>紧接着就是创建OMXCodec，在OMXCodec构造方法中调用setComponentRole，根据对应的mimeType，以及isEncoder来获取对应的Role Name，并对其进行初始化。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">OMXCodec::<span class="built_in">OMXCodec</span>(</span><br><span class="line">        <span class="type">const</span> sp&lt;IOMX&gt; &amp;omx, IOMX::node_id node,</span><br><span class="line">        <span class="type">uint32_t</span> quirks, <span class="type">uint32_t</span> flags,</span><br><span class="line">        <span class="type">bool</span> isEncoder,</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *mime,</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *componentName,</span><br><span class="line">        <span class="type">const</span> sp&lt;MediaSource&gt; &amp;source,</span><br><span class="line">        <span class="type">const</span> sp&lt;ANativeWindow&gt; &amp;nativeWindow)</span><br><span class="line">    : <span class="built_in">mOMX</span>(omx),</span><br><span class="line">    <span class="comment">//……………………………………….</span></span><br><span class="line">    mPortStatus[kPortIndexInput] = ENABLED;</span><br><span class="line">    mPortStatus[kPortIndexOutput] = ENABLED;</span><br><span class="line">    <span class="built_in">setComponentRole</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">OMXCodec::setComponentRole</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> sp&lt;IOMX&gt; &amp;omx, IOMX::node_id node, <span class="type">bool</span> isEncoder,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> <span class="type">char</span> *mime)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">MimeToRole</span> &#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *mime;</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *decoderRole;</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *encoderRole;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> MimeToRole kMimeToRole[] = &#123;</span><br><span class="line">        &#123; MEDIA_MIMETYPE_AUDIO_MPEG,</span><br><span class="line">            <span class="string">&quot;audio_decoder.mp3&quot;</span>, <span class="string">&quot;audio_encoder.mp3&quot;</span> &#125;,</span><br><span class="line">        &#123; MEDIA_MIMETYPE_AUDIO_MPEG_LAYER_I,</span><br><span class="line">            <span class="string">&quot;audio_decoder.mp1&quot;</span>, <span class="string">&quot;audio_encoder.mp1&quot;</span> &#125;,</span><br><span class="line">        &#123; MEDIA_MIMETYPE_AUDIO_MPEG_LAYER_II,</span><br><span class="line">            <span class="string">&quot;audio_decoder.mp2&quot;</span>, <span class="string">&quot;audio_encoder.mp2&quot;</span> &#125;,</span><br><span class="line">        &#123; MEDIA_MIMETYPE_AUDIO_AMR_NB,</span><br><span class="line">            <span class="string">&quot;audio_decoder.amrnb&quot;</span>, <span class="string">&quot;audio_encoder.amrnb&quot;</span> &#125;,</span><br><span class="line">        &#123; MEDIA_MIMETYPE_AUDIO_AMR_WB,</span><br><span class="line">            <span class="string">&quot;audio_decoder.amrwb&quot;</span>, <span class="string">&quot;audio_encoder.amrwb&quot;</span> &#125;,</span><br><span class="line">        &#123; MEDIA_MIMETYPE_AUDIO_AAC,</span><br><span class="line">            <span class="string">&quot;audio_decoder.aac&quot;</span>, <span class="string">&quot;audio_encoder.aac&quot;</span> &#125;,</span><br><span class="line">        &#123; MEDIA_MIMETYPE_AUDIO_VORBIS,</span><br><span class="line">            <span class="string">&quot;audio_decoder.vorbis&quot;</span>, <span class="string">&quot;audio_encoder.vorbis&quot;</span> &#125;,</span><br><span class="line">        &#123; MEDIA_MIMETYPE_AUDIO_OPUS,</span><br><span class="line">            <span class="string">&quot;audio_decoder.opus&quot;</span>, <span class="string">&quot;audio_encoder.opus&quot;</span> &#125;,</span><br><span class="line">        &#123; MEDIA_MIMETYPE_AUDIO_G711_MLAW,</span><br><span class="line">            <span class="string">&quot;audio_decoder.g711mlaw&quot;</span>, <span class="string">&quot;audio_encoder.g711mlaw&quot;</span> &#125;,</span><br><span class="line">        &#123; MEDIA_MIMETYPE_AUDIO_G711_ALAW,</span><br><span class="line">            <span class="string">&quot;audio_decoder.g711alaw&quot;</span>, <span class="string">&quot;audio_encoder.g711alaw&quot;</span> &#125;,</span><br><span class="line">        &#123; MEDIA_MIMETYPE_VIDEO_AVC,</span><br><span class="line">            <span class="string">&quot;video_decoder.avc&quot;</span>, <span class="string">&quot;video_encoder.avc&quot;</span> &#125;,</span><br><span class="line">        &#123; MEDIA_MIMETYPE_VIDEO_HEVC,</span><br><span class="line">            <span class="string">&quot;video_decoder.hevc&quot;</span>, <span class="string">&quot;video_encoder.hevc&quot;</span> &#125;,</span><br><span class="line">        &#123; MEDIA_MIMETYPE_VIDEO_MPEG4,</span><br><span class="line">            <span class="string">&quot;video_decoder.mpeg4&quot;</span>, <span class="string">&quot;video_encoder.mpeg4&quot;</span> &#125;,</span><br><span class="line">        &#123; MEDIA_MIMETYPE_VIDEO_H263,</span><br><span class="line">            <span class="string">&quot;video_decoder.h263&quot;</span>, <span class="string">&quot;video_encoder.h263&quot;</span> &#125;,</span><br><span class="line">        &#123; MEDIA_MIMETYPE_VIDEO_VP8,</span><br><span class="line">            <span class="string">&quot;video_decoder.vp8&quot;</span>, <span class="string">&quot;video_encoder.vp8&quot;</span> &#125;,</span><br><span class="line">        &#123; MEDIA_MIMETYPE_VIDEO_VP9,</span><br><span class="line">            <span class="string">&quot;video_decoder.vp9&quot;</span>, <span class="string">&quot;video_encoder.vp9&quot;</span> &#125;,</span><br><span class="line">        &#123; MEDIA_MIMETYPE_AUDIO_RAW,</span><br><span class="line">            <span class="string">&quot;audio_decoder.raw&quot;</span>, <span class="string">&quot;audio_encoder.raw&quot;</span> &#125;,</span><br><span class="line">        &#123; MEDIA_MIMETYPE_AUDIO_FLAC,</span><br><span class="line">            <span class="string">&quot;audio_decoder.flac&quot;</span>, <span class="string">&quot;audio_encoder.flac&quot;</span> &#125;,</span><br><span class="line">        &#123; MEDIA_MIMETYPE_AUDIO_MSGSM,</span><br><span class="line">            <span class="string">&quot;audio_decoder.gsm&quot;</span>, <span class="string">&quot;audio_encoder.gsm&quot;</span> &#125;,</span><br><span class="line">        &#123; MEDIA_MIMETYPE_VIDEO_MPEG2,</span><br><span class="line">            <span class="string">&quot;video_decoder.mpeg2&quot;</span>, <span class="string">&quot;video_encoder.mpeg2&quot;</span> &#125;,</span><br><span class="line">        &#123; MEDIA_MIMETYPE_AUDIO_AC3,</span><br><span class="line">            <span class="string">&quot;audio_decoder.ac3&quot;</span>, <span class="string">&quot;audio_encoder.ac3&quot;</span> &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">size_t</span> kNumMimeToRole =</span><br><span class="line">        <span class="built_in">sizeof</span>(kMimeToRole) / <span class="built_in">sizeof</span>(kMimeToRole[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; kNumMimeToRole; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcasecmp</span>(mime, kMimeToRole[i].mime)) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i == kNumMimeToRole) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *role =</span><br><span class="line">        isEncoder ? kMimeToRole[i].encoderRole</span><br><span class="line">                  : kMimeToRole[i].decoderRole;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (role != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        OMX_PARAM_COMPONENTROLETYPE roleParams;</span><br><span class="line">        <span class="built_in">InitOMXParams</span>(&amp;roleParams);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">strncpy</span>((<span class="type">char</span> *)roleParams.cRole,</span><br><span class="line">                role, OMX_MAX_STRINGNAME_SIZE - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        roleParams.cRole[OMX_MAX_STRINGNAME_SIZE - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">status_t</span> err = omx-&gt;<span class="built_in">setParameter</span>(</span><br><span class="line">                node, OMX_IndexParamStandardComponentRole,</span><br><span class="line">                &amp;roleParams, <span class="built_in">sizeof</span>(roleParams));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (err != OK) &#123;</span><br><span class="line">            <span class="built_in">ALOGW</span>(<span class="string">&quot;Failed to set standard component role &#x27;%s&#x27;.&quot;</span>, role);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看完了解码器的创建过程，我们继续看下initAudioDecoder中的</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">status_t</span> err = mAudioSource-&gt;</span>start()，首先我们需要明确mAudioSource是怎么来的，</span><br><span class="line">status_t AwesomePlayer::initAudioDecoder() &#123;</span><br><span class="line">    <span class="keyword">if</span> (!strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_RAW)) &#123;</span><br><span class="line">        mAudioSource = mAudioTrack;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mOmxSource = OMXCodec::Create(</span><br><span class="line">                <span class="function"><span class="title">mClient</span>.interface(), mAudioTrack-&gt;</span>getFormat(),</span><br><span class="line">                <span class="literal">false</span>, <span class="comment">// createEncoder</span></span><br><span class="line">                mAudioTrack);</span><br><span class="line">        <span class="keyword">if</span> (mOffloadAudio) &#123;</span><br><span class="line">            mAudioSource = mAudioTrack;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mAudioSource = mOmxSource;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;        </span><br><span class="line"><span class="function"><span class="title">status_t</span> err = mAudioSource-&gt;</span>start();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>从上面可以看出mAudioSource指的是mOmxSource，是创建出来的OMXCodec。而OMXCodec::Create返回值是一个OMXCodec对象。所以我们接下来看下OMXCodec的start方法.</p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line">status_t OMXCodec<span class="type">::start</span>(MetaData *meta) &#123;</span><br><span class="line">    Mutex<span class="type">::Autolock</span> autoLock(mLock);</span><br><span class="line">    sp&lt;MetaData&gt; <span class="keyword">params</span> = <span class="literal">new</span> MetaData;</span><br><span class="line">    <span class="comment">//………………………………………………..</span></span><br><span class="line">    <span class="comment">// Decoder case</span></span><br><span class="line">    <span class="keyword">if</span> ((err = mSource-&gt;start(<span class="keyword">params</span>.get())) != OK) &#123;</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在该方法中调用了mSource的start方法，以及init()方法，我们在该段代码中主要针对这两部分进行分析。同样我们在分析具体流程之前需要明确mSource到底指的是什么，这就需要从它的根源找起.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">OMXCodec::<span class="built_in">OMXCodec</span>(</span><br><span class="line">        <span class="type">const</span> sp&lt;IOMX&gt; &amp;omx, IOMX::node_id node,</span><br><span class="line">        <span class="type">uint32_t</span> quirks, <span class="type">uint32_t</span> flags,</span><br><span class="line">        <span class="type">bool</span> isEncoder,</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *mime,</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *componentName,</span><br><span class="line">        <span class="type">const</span> sp&lt;MediaSource&gt; &amp;source,</span><br><span class="line">        <span class="type">const</span> sp&lt;ANativeWindow&gt; &amp;nativeWindow)</span><br><span class="line">    : <span class="built_in">mOMX</span>(omx),</span><br><span class="line">      <span class="comment">//……………………………….</span></span><br><span class="line">      <span class="built_in">mSource</span>(source),</span><br><span class="line">      <span class="comment">//……………………………..&#123;</span></span><br><span class="line">    mPortStatus[kPortIndexInput] = ENABLED;</span><br><span class="line">    mPortStatus[kPortIndexOutput] = ENABLED;</span><br><span class="line">    <span class="built_in">setComponentRole</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">sp<span class="variable">&lt;MediaSource&gt;</span> OMXCodec::Create(</span><br><span class="line">        <span class="keyword">const</span> sp<span class="variable">&lt;IOMX&gt;</span> &amp;omx,</span><br><span class="line">        <span class="keyword">const</span> sp<span class="variable">&lt;MetaData&gt;</span> &amp;meta, bool createEncoder,</span><br><span class="line">        <span class="keyword">const</span> sp<span class="variable">&lt;MediaSource&gt;</span> &amp;source,</span><br><span class="line">        <span class="keyword">const</span> char *<span class="built_in">match</span>ComponentName,</span><br><span class="line">        uint32_t <span class="keyword">flags</span>,</span><br><span class="line">        <span class="keyword">const</span> sp<span class="variable">&lt;ANativeWindow&gt;</span> &amp;nativeWindow) &#123;</span><br><span class="line">            sp<span class="variable">&lt;OMXCodec&gt;</span> codec = new OMXCodec(</span><br><span class="line">                    omx, node, quirks, <span class="keyword">flags</span>,</span><br><span class="line">                    createEncoder, mime, componentName,</span><br><span class="line">                    source, nativeWindow);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight zephir"><table><tr><td class="code"><pre><span class="line">status_t AwesomePlayer::initAudioDecoder() &#123;</span><br><span class="line">        mOmxSource = OMXCodec::Create(</span><br><span class="line">                mClient.<span class="keyword">interface</span>(), mAudioTrack-&gt;getFormat(),</span><br><span class="line">                <span class="keyword">false</span>, <span class="comment">// createEncoder</span></span><br><span class="line">                mAudioTrack);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> AwesomePlayer::setAudioSource(sp&lt;MediaSource&gt; <span class="keyword">source</span>) &#123;</span><br><span class="line">    CHECK(<span class="keyword">source</span> != <span class="keyword">NULL</span>);</span><br><span class="line">    mAudioTrack = <span class="keyword">source</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里使用MediaExtractor对视频文件做A&#x2F;V的分离</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">status_t AwesomePlayer::set<span class="constructor">DataSource_l(<span class="params">const</span> <span class="params">sp</span>&lt;MediaExtractor&gt; &amp;<span class="params">extractor</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; extractor-&gt;count<span class="constructor">Tracks()</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!haveVideo<span class="operator"> &amp;&amp; </span>!strncasecmp(mime.<span class="built_in">string</span><span class="literal">()</span>, <span class="string">&quot;video/&quot;</span>, <span class="number">6</span>)) &#123;</span><br><span class="line">           set<span class="constructor">VideoSource(<span class="params">extractor</span>-&gt;<span class="params">getTrack</span>(<span class="params">i</span>)</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!haveAudio<span class="operator"> &amp;&amp; </span>!strncasecmp(mime.<span class="built_in">string</span><span class="literal">()</span>, <span class="string">&quot;audio/&quot;</span>, <span class="number">6</span>)) &#123;</span><br><span class="line">            set<span class="constructor">AudioSource(<span class="params">extractor</span>-&gt;<span class="params">getTrack</span>(<span class="params">i</span>)</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面是整个调用的过程，从上面可以看出最终的调用根源来自extractor-&gt;getTrack，假设当前播放歌曲的格式为MP3格式，那么extractor就是MP3Extractor,则mAudioTrack就是MP3Extractor::getTrack的返回值，也就是MP3Source，知道了这点我们就可以继续对prepare流程进行分析了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">sp&lt;MediaSource&gt; <span class="title">MP3Extractor::getTrack</span><span class="params">(<span class="type">size_t</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mInitCheck != OK || index != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">MP3Source</span>(</span><br><span class="line">            mMeta, mDataSource, mFirstFramePos, mFixedHeader,</span><br><span class="line">            mSeeker);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MP3Source::start中主要创建出一个MediaBuffer然后调用MediaBufferGroup的add_buffer方法将其添加到MediaBufferGroup中。并且将一些相关的标志位置为初始状态。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">status_t MP3Source::start(MetaData *) &#123;</span><br><span class="line">    <span class="constructor">CHECK(!<span class="params">mStarted</span>)</span>;</span><br><span class="line">    mGroup = <span class="keyword">new</span> MediaBufferGroup;</span><br><span class="line">    mGroup-&gt;add<span class="constructor">_buffer(<span class="params">new</span> MediaBuffer(<span class="params">kMaxFrameSize</span>)</span>);</span><br><span class="line">    mCurrentPos = mFirstFramePos;</span><br><span class="line">    mCurrentTimeUs = <span class="number">0</span>;</span><br><span class="line">    mBasisTimeUs = mCurrentTimeUs;</span><br><span class="line">    mSamplesRead = <span class="number">0</span>;</span><br><span class="line">    mStarted = <span class="literal">true</span>;</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来我们看下init方法。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">status_t OMXCodec::init<span class="literal">()</span> &#123;</span><br><span class="line">    <span class="comment">// mLock is held.</span></span><br><span class="line">    status_t err;</span><br><span class="line">    <span class="keyword">if</span> (!(mQuirks &amp; kRequiresLoadedToIdleAfterAllocation)) &#123;</span><br><span class="line">        err = mOMX-&gt;send<span class="constructor">Command(<span class="params">mNode</span>, OMX_CommandStateSet, OMX_StateIdle)</span>;</span><br><span class="line">        set<span class="constructor">State(LOADED_TO_IDLE)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    err = allocate<span class="constructor">Buffers()</span>;</span><br><span class="line">    <span class="keyword">if</span> (mQuirks &amp; kRequiresLoadedToIdleAfterAllocation) &#123;</span><br><span class="line">        err = mOMX-&gt;send<span class="constructor">Command(<span class="params">mNode</span>, OMX_CommandStateSet, OMX_StateIdle)</span>;</span><br><span class="line">        set<span class="constructor">State(LOADED_TO_IDLE)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (mState != EXECUTING<span class="operator"> &amp;&amp; </span>mState != ERROR) &#123;</span><br><span class="line">        mAsyncCompletion.wait(mLock);</span><br><span class="line">    &#125;</span><br><span class="line">    return mState<span class="operator"> == </span>ERROR ? UNKNOWN_ERROR : OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在init方法中主要是通过调用allocateBuffers来为输入输出端口分配缓存，紧接着调用mOMX-&gt;sendCommand将状态设置到底层。首先我们看下allocateBuffers方法：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">status_t OMXCodec::allocate<span class="constructor">Buffers()</span> &#123;</span><br><span class="line">    status_t err = allocate<span class="constructor">BuffersOnPort(<span class="params">kPortIndexInput</span>)</span>;</span><br><span class="line">    return allocate<span class="constructor">BuffersOnPort(<span class="params">kPortIndexOutput</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在allocateBuffersOnPort中分别为输入输出端口分配指定大小的缓存空间并对其统一管理。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">OMXCodec::allocateBuffersOnPort</span><span class="params">(OMX_U32 portIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mNativeWindow != <span class="literal">NULL</span> &amp;&amp; portIndex == kPortIndexOutput) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">allocateOutputBuffersFromNativeWindow</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">status_t</span> err = OK;</span><br><span class="line">    <span class="keyword">if</span> ((mFlags &amp; kStoreMetaDataInVideoBuffers)</span><br><span class="line">            &amp;&amp; portIndex == kPortIndexInput) &#123;</span><br><span class="line">        err = mOMX-&gt;<span class="built_in">storeMetaDataInBuffers</span>(mNode, kPortIndexInput, OMX_TRUE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    OMX_PARAM_PORTDEFINITIONTYPE def;</span><br><span class="line">    <span class="comment">//在获取参数def之前先初始下</span></span><br><span class="line">    <span class="built_in">InitOMXParams</span>(&amp;def);</span><br><span class="line">    def.nPortIndex = portIndex;</span><br><span class="line">    <span class="comment">//获取指定端口的def参数</span></span><br><span class="line">    err = mOMX-&gt;<span class="built_in">getParameter</span>(mNode, OMX_IndexParamPortDefinition, &amp;def, <span class="built_in">sizeof</span>(def));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CODEC_LOGV</span>(<span class="string">&quot;allocating %u buffers of size %u on %s port&quot;</span>,</span><br><span class="line">            def.nBufferCountActual, def.nBufferSize,</span><br><span class="line">            portIndex == kPortIndexInput ? <span class="string">&quot;input&quot;</span> : <span class="string">&quot;output&quot;</span>);</span><br><span class="line">    <span class="comment">//开始为指定端口分配大小为def.nBufferSize 个数为def.nBufferCountActual的缓存</span></span><br><span class="line">    <span class="comment">//在分配参数之前先检查def.nBufferSize ，def.nBufferCountActual 是否合理</span></span><br><span class="line">    <span class="keyword">if</span> (def.nBufferSize != <span class="number">0</span> &amp;&amp; def.nBufferCountActual &gt; SIZE_MAX / def.nBufferSize) &#123;</span><br><span class="line">        <span class="keyword">return</span> BAD_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//开始分配大小为totalSize的总空间</span></span><br><span class="line">    <span class="type">size_t</span> totalSize = def.nBufferCountActual * def.nBufferSize;</span><br><span class="line">    mDealer[portIndex] = <span class="keyword">new</span> <span class="built_in">MemoryDealer</span>(totalSize, <span class="string">&quot;OMXCodec&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (OMX_U32 i = <span class="number">0</span>; i &lt; def.nBufferCountActual; ++i) &#123;</span><br><span class="line">    <span class="comment">//从总缓存空间中划分出一个大小为 def.nBufferSize的空间</span></span><br><span class="line">        sp&lt;IMemory&gt; mem = mDealer[portIndex]-&gt;<span class="built_in">allocate</span>(def.nBufferSize);</span><br><span class="line">        BufferInfo info;</span><br><span class="line">        info.mData = <span class="literal">NULL</span>;</span><br><span class="line">        info.mSize = def.nBufferSize;</span><br><span class="line">        IOMX::buffer_id buffer;</span><br><span class="line">        <span class="keyword">if</span> (portIndex == kPortIndexInput</span><br><span class="line">                &amp;&amp; ((mQuirks &amp; kRequiresAllocateBufferOnInputPorts)</span><br><span class="line">                    || (mFlags &amp; kUseSecureInputBuffers))) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mOMXLivesLocally) &#123;</span><br><span class="line">               <span class="comment">//在使用前将存储空间进行清除</span></span><br><span class="line">                mem.<span class="built_in">clear</span>();</span><br><span class="line">               <span class="comment">//为该解码器输入端口分配空间</span></span><br><span class="line">                err = mOMX-&gt;<span class="built_in">allocateBuffer</span>(</span><br><span class="line">                        mNode, portIndex, def.nBufferSize, &amp;buffer,</span><br><span class="line">                        &amp;info.mData);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                err = mOMX-&gt;<span class="built_in">allocateBufferWithBackup</span>(</span><br><span class="line">                        mNode, portIndex, mem, &amp;buffer, mem-&gt;<span class="built_in">size</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (portIndex == kPortIndexOutput</span><br><span class="line">                &amp;&amp; (mQuirks &amp; kRequiresAllocateBufferOnOutputPorts)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mOMXLivesLocally) &#123;</span><br><span class="line">               <span class="comment">//在使用前将存储空间进行清除</span></span><br><span class="line">                mem.<span class="built_in">clear</span>();</span><br><span class="line">               <span class="comment">//为该解码器输入端口分配空间</span></span><br><span class="line">                err = mOMX-&gt;<span class="built_in">allocateBuffer</span>(</span><br><span class="line">                        mNode, portIndex, def.nBufferSize, &amp;buffer,</span><br><span class="line">                        &amp;info.mData);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                err = mOMX-&gt;<span class="built_in">allocateBufferWithBackup</span>(</span><br><span class="line">                        mNode, portIndex, mem, &amp;buffer, mem-&gt;<span class="built_in">size</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            err = mOMX-&gt;<span class="built_in">useBuffer</span>(mNode, portIndex, mem, &amp;buffer, mem-&gt;<span class="built_in">size</span>());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mem != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            info.mData = mem-&gt;<span class="built_in">pointer</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        info.mBuffer = buffer;</span><br><span class="line">        info.mStatus = OWNED_BY_US;</span><br><span class="line">        info.mMem = mem;</span><br><span class="line">        info.mMediaBuffer = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">//将分配的缓存信息添加到端口缓存表中进行统一管理</span></span><br><span class="line">        mPortBuffers[portIndex].<span class="built_in">push</span>(info);</span><br><span class="line">        <span class="built_in">CODEC_LOGV</span>(<span class="string">&quot;allocated buffer %u on %s port&quot;</span>, buffer,</span><br><span class="line">             portIndex == kPortIndexInput ? <span class="string">&quot;input&quot;</span> : <span class="string">&quot;output&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (portIndex == kPortIndexOutput) &#123;</span><br><span class="line">        sp&lt;MetaData&gt; meta = mSource-&gt;<span class="built_in">getFormat</span>();</span><br><span class="line">        <span class="type">int32_t</span> delay = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (!meta-&gt;<span class="built_in">findInt32</span>(kKeyEncoderDelay, &amp;delay)) &#123;</span><br><span class="line">            delay = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int32_t</span> padding = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (!meta-&gt;<span class="built_in">findInt32</span>(kKeyEncoderPadding, &amp;padding)) &#123;</span><br><span class="line">            padding = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int32_t</span> numchannels = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (delay + padding) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mOutputFormat-&gt;<span class="built_in">findInt32</span>(kKeyChannelCount, &amp;numchannels)) &#123;</span><br><span class="line">                <span class="type">size_t</span> frameSize = numchannels * <span class="built_in">sizeof</span>(<span class="type">int16_t</span>);</span><br><span class="line">                <span class="keyword">if</span> (mSkipCutBuffer != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                    <span class="type">size_t</span> prevbuffersize = mSkipCutBuffer-&gt;<span class="built_in">size</span>();</span><br><span class="line">                    <span class="keyword">if</span> (prevbuffersize != <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="built_in">ALOGW</span>(<span class="string">&quot;Replacing SkipCutBuffer holding %zu bytes&quot;</span>,</span><br><span class="line">                        prevbuffersize);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                mSkipCutBuffer = <span class="keyword">new</span> <span class="built_in">SkipCutBuffer</span>(delay * frameSize, padding * frameSize);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (portIndex == kPortIndexInput &amp;&amp; (mFlags &amp; kUseSecureInputBuffers)) &#123;</span><br><span class="line">        Vector&lt;MediaBuffer *&gt; buffers;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; def.nBufferCountActual; ++i) &#123;</span><br><span class="line">            <span class="type">const</span> BufferInfo &amp;info = mPortBuffers[kPortIndexInput].<span class="built_in">itemAt</span>(i);</span><br><span class="line"></span><br><span class="line">            MediaBuffer *mbuf = <span class="keyword">new</span> <span class="built_in">MediaBuffer</span>(info.mData, info.mSize);</span><br><span class="line">            buffers.<span class="built_in">push</span>(mbuf);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">status_t</span> err = mSource-&gt;<span class="built_in">setBuffers</span>(buffers);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">OMX::allocateBuffer</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        node_id node, OMX_U32 port_index, <span class="type">size_t</span> size,</span></span></span><br><span class="line"><span class="params"><span class="function">        buffer_id *buffer, <span class="type">void</span> **buffer_data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">findInstance</span>(node)-&gt;<span class="built_in">allocateBuffer</span>(port_index, size, buffer, buffer_data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">status_t OMXNodeInstance::allocateBuffer(</span><br><span class="line">        OMX_U32 portIndex, size_t size, OMX::<span class="keyword">buffer_id </span>*<span class="keyword">buffer,</span></span><br><span class="line"><span class="keyword"></span>        void **<span class="keyword">buffer_data) </span>&#123;</span><br><span class="line"><span class="symbol">    Mutex:</span>:Autolock autoLock(mLock);</span><br><span class="line">    <span class="keyword">BufferMeta </span>*<span class="keyword">buffer_meta </span>= new <span class="keyword">BufferMeta(size);</span></span><br><span class="line"><span class="keyword"></span>    OMX_BUFFERHEADERTYPE *header;</span><br><span class="line">    OMX_ERRORTYPE err = OMX_AllocateBuffer(mHandle, &amp;header, portIndex, <span class="keyword">buffer_meta, </span>size);</span><br><span class="line">    if (err != OMX_ErrorNone) &#123;</span><br><span class="line">        <span class="keyword">CLOG_ERROR(allocateBuffer, </span>err, <span class="keyword">BUFFER_FMT(portIndex, </span><span class="string">&quot;%zu@&quot;</span>, size));</span><br><span class="line">        delete <span class="keyword">buffer_meta;</span></span><br><span class="line"><span class="keyword"></span>        <span class="keyword">buffer_meta </span>= NULL;</span><br><span class="line">        *<span class="keyword">buffer </span>= <span class="number">0</span>;</span><br><span class="line">        return StatusFromOMXError(err);</span><br><span class="line">    &#125;</span><br><span class="line">    CHECK_EQ(header-&gt;pAppPrivate, <span class="keyword">buffer_meta);</span></span><br><span class="line"><span class="keyword"></span>    *<span class="keyword">buffer </span>= makeBufferID(header);</span><br><span class="line">    *<span class="keyword">buffer_data </span>= header-&gt;pBuffer;</span><br><span class="line">    <span class="keyword">addActiveBuffer(portIndex, </span>*<span class="keyword">buffer);</span></span><br><span class="line"><span class="keyword"></span>    <span class="built_in">sp</span>&lt;GraphicBufferSource&gt; <span class="keyword">bufferSource(getGraphicBufferSource());</span></span><br><span class="line"><span class="keyword"></span>    if (<span class="keyword">bufferSource </span>!= NULL &amp;&amp; portIndex == kPortIndexInput) &#123;</span><br><span class="line">        <span class="keyword">bufferSource-&gt;addCodecBuffer(header);</span></span><br><span class="line"><span class="keyword"></span>    &#125;</span><br><span class="line">    <span class="keyword">CLOG_BUFFER(allocateBuffer, </span>NEW_BUFFER_FMT(*<span class="keyword">buffer, </span>portIndex, <span class="string">&quot;%zu@%p&quot;</span>, size, *<span class="keyword">buffer_data));</span></span><br><span class="line"><span class="keyword"></span>    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之前我们提到过我们创建一个Component的时候会调用initPort初始化端口参数，但是那时候还没为端口分配内存，仅仅只是参数设置而已，这里的init就开始为每个端口分配内存空间了，在空间分配的时候会先从内存中划分出一整块所需的总空间，然后再细分后调用addActiveBuffer将其分配给某个端口：<br>老办法上图来说明内存分配这部分的原理：<br><img src="/2016/07/31/Android-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E5%9F%BA%E4%BA%8EStagefright%E7%9A%84MediaPlayer%E6%92%AD%E6%94%BE%E6%A1%86%E6%9E%B6-2/25.png"></p>
<p>接下来我们看下sendCommand部分：</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">status_t OMX::sendCommand(</span><br><span class="line">        node_id <span class="keyword">node</span><span class="title">, OMX_COMMANDTYPE</span> cmd, OMX_S32 param) &#123;</span><br><span class="line">    return findInstance(<span class="keyword">node</span><span class="title">)-&gt;sendCommand</span>(cmd, param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">OMXNodeInstance *OMX::find<span class="constructor">Instance(<span class="params">node_id</span> <span class="params">node</span>)</span> &#123;</span><br><span class="line">    Mutex::Autolock auto<span class="constructor">Lock(<span class="params">mLock</span>)</span>;</span><br><span class="line">    ssize_t index = mNodeIDToInstance.index<span class="constructor">OfKey(<span class="params">node</span>)</span>;</span><br><span class="line">    return index &lt; <span class="number">0</span> ? NULL : mNodeIDToInstance.value<span class="constructor">At(<span class="params">index</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">OMXNodeInstance::sendCommand</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        OMX_COMMANDTYPE cmd, OMX_S32 param)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="type">const</span> sp&lt;GraphicBufferSource&gt;&amp; <span class="title">bufferSource</span><span class="params">(getGraphicBufferSource())</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (bufferSource != <span class="literal">NULL</span> &amp;&amp; cmd == OMX_CommandStateSet) &#123;</span><br><span class="line">        <span class="keyword">if</span> (param == OMX_StateIdle) &#123;</span><br><span class="line">          <span class="comment">//将状态从Executing到Idle，ACodec等待所有的缓存返回，并且不再向解码器缓存中发送数据。</span></span><br><span class="line">            bufferSource-&gt;<span class="built_in">omxIdle</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (param == OMX_StateLoaded) &#123;</span><br><span class="line">            <span class="comment">// Initiating transition from Idle/Executing -&gt; Loaded</span></span><br><span class="line">            <span class="comment">// Buffers are about to be freed.</span></span><br><span class="line">            bufferSource-&gt;<span class="built_in">omxLoaded</span>();</span><br><span class="line">            <span class="built_in">setGraphicBufferSource</span>(<span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// fall through</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//………………………………………………..</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *paramString =</span><br><span class="line">    cmd == OMX_CommandStateSet ? <span class="built_in">asString</span>((OMX_STATETYPE)param) : <span class="built_in">portString</span>(param);</span><br><span class="line">    <span class="built_in">CLOG_STATE</span>(sendCommand, <span class="string">&quot;%s(%d), %s(%d)&quot;</span>, <span class="built_in">asString</span>(cmd), cmd, paramString, param);</span><br><span class="line">    OMX_ERRORTYPE err = <span class="built_in">OMX_SendCommand</span>(mHandle, cmd, param, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">CLOG_IF_ERROR</span>(sendCommand, err, <span class="string">&quot;%s(%d), %s(%d)&quot;</span>, <span class="built_in">asString</span>(cmd), cmd, paramString, param);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">StatusFromOMXError</span>(err);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看到上述的OMXNodeInstance::sendCommand主要有两项工作：</p>
<ol>
<li>调用 bufferSource-&gt;omxIdle();将状态从Executing到Idle，等待原先的解码结束，并不再发送数据到解码器中进行解码。</li>
<li>调用OMX_SendCommand继续后续的处理。<br>我们可以在hardware&#x2F;qcom&#x2F;media&#x2F;mm-core&#x2F;inc&#x2F;OMX_Core.h中找到OMX_SendCommand宏方法的定义，它调用hComponent中的SendCommand方法，将处理流程转给它来处理。<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">#define OMX_SendCommand(                                    \</span></span><br><span class="line">         hComponent,                                        <span class="string">\</span></span><br><span class="line">         Cmd,                                               <span class="string">\</span></span><br><span class="line">         nParam,                                            <span class="string">\</span></span><br><span class="line">         pCmdData)                                          <span class="string">\</span></span><br><span class="line">     <span class="function"><span class="params">((OMX_COMPONENTTYPE*)hComponent)</span>-&gt;</span>SendCommand(         <span class="string">\</span></span><br><span class="line">         hComponent,                                        <span class="string">\</span></span><br><span class="line">         Cmd,                                               <span class="string">\</span></span><br><span class="line">         nParam,                                            <span class="string">\</span></span><br><span class="line">         pCmdData)                          <span class="comment">/* Macro End */</span></span><br></pre></td></tr></table></figure>
OMX_SendCommand(mHandle, cmd, param, NULL)进行宏展开之后就变成将cmd这个命令传递给mHandle，让它来处理。所以我们必须明确到底mHandle指的是什么，我们在OMXNodeInstance中看到，mHandle是通过setHandle进行赋值的。<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void OMXNodeInstance::set<span class="constructor">Handle(OMX::<span class="params">node_id</span> <span class="params">node_id</span>, OMX_HANDLETYPE <span class="params">handle</span>)</span> &#123;</span><br><span class="line">    mNodeID = node_id;</span><br><span class="line">    <span class="constructor">CLOG_LIFE(<span class="params">allocateNode</span>, <span class="string">&quot;handle=%p&quot;</span>, <span class="params">handle</span>)</span>;</span><br><span class="line">    <span class="constructor">CHECK(<span class="params">mHandle</span> <span class="operator">==</span> NULL)</span>;</span><br><span class="line">    mHandle = handle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
而OMXNodeInstance::setHandle方法是在OMX::allocateNode中被调用的，而这个handle是通过mMaster-&gt;makeComponentInstance中传递出来的。<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">status_t OMX::<span class="title function_ invoke__">allocateNode</span>(</span><br><span class="line">        <span class="keyword">const</span> <span class="type">char</span> *name, <span class="keyword">const</span> sp&lt;IOMXObserver&gt; &amp;observer, node_id *node) &#123;</span><br><span class="line">   <span class="comment">//………………………………………… </span></span><br><span class="line">    OMX_ERRORTYPE err = mMaster<span class="punctuation">-&gt;</span><span class="title function_ invoke__">makeComponentInstance</span>(</span><br><span class="line">            name, &amp;OMXNodeInstance::kCallbacks,</span><br><span class="line">            instance, &amp;handle);</span><br><span class="line">    <span class="comment">//…………………………….</span></span><br><span class="line">    instance<span class="punctuation">-&gt;</span><span class="title function_ invoke__">setHandle</span>(*node, handle);</span><br><span class="line">    <span class="comment">//……………………………..</span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">OMX_ERRORTYPE OMXMaster::makeComponentInstance(</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *name,</span><br><span class="line">        <span class="keyword">const</span> OMX_CALLBACKTYPE *callbacks,</span><br><span class="line">        OMX_PTR appData,</span><br><span class="line">        OMX_COMPONENTTYPE **component) &#123;</span><br><span class="line">    <span class="comment">//……………………………………………….</span></span><br><span class="line">    OMX_ERRORTYPE <span class="keyword">err</span> =</span><br><span class="line">        <span class="keyword">plugin</span>-&gt;makeComponentInstance(name, callbacks, appData, component);</span><br><span class="line">    mPluginByInstance.add(*component, <span class="keyword">plugin</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">err</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">OMX_ERRORTYPE <span class="title">SoftOMXPlugin::makeComponentInstance</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> <span class="type">char</span> *name,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> OMX_CALLBACKTYPE *callbacks,</span></span></span><br><span class="line"><span class="params"><span class="function">        OMX_PTR appData,</span></span></span><br><span class="line"><span class="params"><span class="function">        OMX_COMPONENTTYPE **component)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//………………………………………</span></span><br><span class="line">        sp&lt;SoftOMXComponent&gt; codec =</span><br><span class="line">            (*createSoftOMXComponent)(name, callbacks, appData, component);</span><br><span class="line">        <span class="comment">//………………………………………</span></span><br><span class="line">    <span class="keyword">return</span> OMX_ErrorInvalidComponentName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight zephir"><table><tr><td class="code"><pre><span class="line">android::SoftOMXComponent *createSoftOMXComponent(</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> OMX_CALLBACKTYPE *callbacks,</span><br><span class="line">        OMX_PTR appData, OMX_COMPONENTTYPE **component) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> android::SoftMP3(name, callbacks, appData, component);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">SoftMP3::<span class="built_in">SoftMP3</span>(</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *name,</span><br><span class="line">        <span class="type">const</span> OMX_CALLBACKTYPE *callbacks,</span><br><span class="line">        OMX_PTR appData,</span><br><span class="line">        OMX_COMPONENTTYPE **component)</span><br><span class="line">    : <span class="built_in">SimpleSoftOMXComponent</span>(name, callbacks, appData, component),</span><br><span class="line">    <span class="comment">//……………………………………………………..</span></span><br><span class="line">      <span class="built_in">mOutputPortSettingsChange</span>(NONE) &#123;</span><br><span class="line">    <span class="built_in">initPorts</span>();</span><br><span class="line">    <span class="built_in">initDecoder</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">SimpleSoftOMXComponent::SimpleSoftOMXComponent(</span><br><span class="line">        const char *<span class="keyword">name</span>,</span><br><span class="line">        const OMX_CALLBACKTYPE *callbacks,</span><br><span class="line">        OMX_PTR appData,</span><br><span class="line">        OMX_COMPONENTTYPE **component)</span><br><span class="line">    : SoftOMXComponent(<span class="keyword">name</span>, callbacks, appData, component),</span><br><span class="line">      mLooper(new ALooper),</span><br><span class="line">      mHandler(new AHandlerReflector&lt;SimpleSoftOMXComponent&gt;(this)),</span><br><span class="line">      mState(OMX_StateLoaded),</span><br><span class="line">      mTargetState(OMX_StateLoaded) &#123;</span><br><span class="line">    <span class="function"><span class="title">mLooper</span>-&gt;</span>setName(<span class="keyword">name</span>);</span><br><span class="line">    <span class="function"><span class="title">mLooper</span>-&gt;</span>registerHandler(mHandler);</span><br><span class="line">    <span class="function"><span class="title">mLooper</span>-&gt;</span>start(</span><br><span class="line">            <span class="literal">false</span>, <span class="comment">// runOnCallingThread</span></span><br><span class="line">            <span class="literal">false</span>, <span class="comment">// canCallJava</span></span><br><span class="line">            ANDROID_PRIORITY_FOREGROUND);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
从上面可以看出mHandler实际上是在SimpleSoftOMXComponent构造方法中被创建的。<br>所以我们可以在SimpleSoftOMXComponent中找到它的SendCommand方法。<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">OMX_ERRORTYPE SimpleSoftOMXComponent::sendCommand(</span><br><span class="line">        OMX_COMMANDTYPE cmd, OMX_U32 param, OMX_PTR <span class="keyword">data</span>) &#123;</span><br><span class="line">    CHECK(<span class="keyword">data</span> == NULL);</span><br><span class="line">    sp&lt;AMessage&gt; msg = new AMessage(kWhatSendCommand, mHandler);</span><br><span class="line">    <span class="function"><span class="title">msg</span>-&gt;</span>setInt32(<span class="string">&quot;cmd&quot;</span>, cmd);</span><br><span class="line">    <span class="function"><span class="title">msg</span>-&gt;</span>setInt32(<span class="string">&quot;param&quot;</span>, param);</span><br><span class="line">    <span class="function"><span class="title">msg</span>-&gt;</span>post();</span><br><span class="line">    return OMX_ErrorNone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void SimpleSoftOMXComponent::on<span class="constructor">MessageReceived(<span class="params">const</span> <span class="params">sp</span>&lt;AMessage&gt; &amp;<span class="params">msg</span>)</span> &#123;</span><br><span class="line">    Mutex::Autolock auto<span class="constructor">Lock(<span class="params">mLock</span>)</span>;</span><br><span class="line">    uint32_t msgType = msg-&gt;what<span class="literal">()</span>;</span><br><span class="line">    <span class="constructor">ALOGV(<span class="string">&quot;msgType = %d&quot;</span>, <span class="params">msgType</span>)</span>;</span><br><span class="line">    switch (msgType) &#123;</span><br><span class="line">        case kWhatSendCommand:</span><br><span class="line">        &#123;</span><br><span class="line">            int32_t cmd, param;</span><br><span class="line">            <span class="constructor">CHECK(<span class="params">msg</span>-&gt;<span class="params">findInt32</span>(<span class="string">&quot;cmd&quot;</span>, &amp;<span class="params">cmd</span>)</span>);</span><br><span class="line">            <span class="constructor">CHECK(<span class="params">msg</span>-&gt;<span class="params">findInt32</span>(<span class="string">&quot;param&quot;</span>, &amp;<span class="params">param</span>)</span>);</span><br><span class="line">            on<span class="constructor">SendCommand((OMX_COMMANDTYPE)</span>cmd, (OMX_U32)param);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//………………………………………………</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line">void SimpleSoftOMXComponent::onSendCommand(</span><br><span class="line">        OMX_COMMANDTYPE cmd, OMX_U32 <span class="built_in">param</span>) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">        <span class="keyword">case</span> OMX_CommandStateSet:</span><br><span class="line">        &#123;</span><br><span class="line">            onChangeState((OMX_STATETYPE)<span class="built_in">param</span>);</span><br><span class="line">            <span class="built_in">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> OMX_CommandPortEnable:</span><br><span class="line">        <span class="keyword">case</span> OMX_CommandPortDisable:</span><br><span class="line">        &#123;</span><br><span class="line">            onPortEnable(<span class="built_in">param</span>, cmd == OMX_CommandPortEnable);</span><br><span class="line">            <span class="built_in">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> OMX_CommandFlush:</span><br><span class="line">        &#123;</span><br><span class="line">            onPortFlush(<span class="built_in">param</span>, <span class="literal">true</span> <span class="comment">/* sendFlushComplete */</span>);</span><br><span class="line">            <span class="built_in">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            TRESPASS();</span><br><span class="line">            <span class="built_in">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">void SimpleSoftOMXComponent::<span class="keyword">on</span>ChangeState(OMX_STATETYPE <span class="keyword">state</span>) &#123;</span><br><span class="line">    // We shouldn&#x27;t be <span class="keyword">in</span> a <span class="keyword">state</span> transition already.</span><br><span class="line">    CHECK_EQ((int)mState, (int)mTargetState);</span><br><span class="line">    switch (mState) &#123;</span><br><span class="line">        case OMX_StateLoaded:</span><br><span class="line">            CHECK_EQ((int)<span class="keyword">state</span>, (int)OMX_StateIdle);</span><br><span class="line">            break;</span><br><span class="line">        case OMX_StateIdle:</span><br><span class="line">            CHECK(<span class="keyword">state</span> == OMX_StateLoaded || <span class="keyword">state</span> == OMX_StateExecuting);</span><br><span class="line">            break;</span><br><span class="line">        case OMX_StateExecuting:</span><br><span class="line">        &#123;</span><br><span class="line">            CHECK_EQ((int)<span class="keyword">state</span>, (int)OMX_StateIdle);</span><br><span class="line">            <span class="keyword">for</span> (size_t i = <span class="number">0</span>; i <span class="variable">&lt; mPorts.size(); ++i) &#123;</span></span><br><span class="line"><span class="variable">                onPortFlush(i, false /* sendFlushComplete */);</span></span><br><span class="line"><span class="variable">            &#125;</span></span><br><span class="line"><span class="variable">            mState = OMX_StateIdle;</span></span><br><span class="line"><span class="variable">            notify(OMX_EventCmdComplete, OMX_CommandStateSet, state, NULL);</span></span><br><span class="line"><span class="variable">            break;</span></span><br><span class="line"><span class="variable">        &#125;</span></span><br><span class="line"><span class="variable">        default:</span></span><br><span class="line"><span class="variable">            TRESPASS();</span></span><br><span class="line"><span class="variable">    &#125;</span></span><br><span class="line"><span class="variable">    mTargetState = state;</span></span><br><span class="line"><span class="variable">    checkTransitions();</span></span><br><span class="line"><span class="variable">&#125;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight zephir"><table><tr><td class="code"><pre><span class="line">void SimpleSoftOMXComponent::checkTransitions() &#123;</span><br><span class="line">    <span class="keyword">if</span> (mState != mTargetState) &#123;</span><br><span class="line">        <span class="keyword">bool</span> transitionComplete = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (mState == OMX_StateLoaded) &#123;</span><br><span class="line">            CHECK_EQ((<span class="keyword">int</span>)mTargetState, (<span class="keyword">int</span>)OMX_StateIdle);</span><br><span class="line">            <span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; mPorts.size(); ++i) &#123;</span><br><span class="line">                <span class="keyword">const</span> PortInfo &amp;port = mPorts.itemAt(i);</span><br><span class="line">                <span class="keyword">if</span> (port.mDef.bEnabled == OMX_FALSE) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (port.mDef.bPopulated == OMX_FALSE) &#123;</span><br><span class="line">                    transitionComplete = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mTargetState == OMX_StateLoaded) &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (transitionComplete) &#123;</span><br><span class="line">            mState = mTargetState;</span><br><span class="line">            <span class="keyword">if</span> (mState == OMX_StateLoaded) &#123;</span><br><span class="line">                onReset();</span><br><span class="line">            &#125;</span><br><span class="line">            notify(OMX_EventCmdComplete, OMX_CommandStateSet, mState, NULL);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; mPorts.size(); ++i) &#123;</span><br><span class="line">        PortInfo *port = &amp;mPorts.editItemAt(i);</span><br><span class="line">        <span class="keyword">if</span> (port-&gt;mTransition == PortInfo::DISABLING) &#123;</span><br><span class="line">            <span class="keyword">if</span> (port-&gt;mBuffers.<span class="keyword">empty</span>()) &#123;</span><br><span class="line">                ALOGV(<span class="string">&quot;Port %zu now disabled.&quot;</span>, i);</span><br><span class="line">                port-&gt;mTransition = PortInfo::NONE;</span><br><span class="line">                notify(OMX_EventCmdComplete, OMX_CommandPortDisable, i, NULL);</span><br><span class="line">                onPortEnableCompleted(i, <span class="keyword">false</span> <span class="comment">/* enabled */</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (port-&gt;mTransition == PortInfo::ENABLING) &#123;</span><br><span class="line">            <span class="keyword">if</span> (port-&gt;mDef.bPopulated == OMX_TRUE) &#123;</span><br><span class="line">                ALOGV(<span class="string">&quot;Port %zu now enabled.&quot;</span>, i);</span><br><span class="line">                port-&gt;mTransition = PortInfo::NONE;</span><br><span class="line">                port-&gt;mDef.bEnabled = OMX_TRUE;</span><br><span class="line">                notify(OMX_EventCmdComplete, OMX_CommandPortEnable, i, NULL);</span><br><span class="line">                onPortEnableCompleted(i, <span class="keyword">true</span> <span class="comment">/* enabled */</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
经过上述的层层跟踪，我们看到OMX_SendCommand(mHandle, cmd, param, NULL)实际上是完成了将idle状态设置到底层并禁止往解码器中输入解码数据。至此prepare流程分析结束，从整个大的角度来看在Prepare阶段主要做的是根据待播放的类型创建对应的解码器，并为每个解码器输入输出端口创建缓存。并且将解码器的状态设置为idle状态。<br>老样子上图作为结尾。<br><img src="/2016/07/31/Android-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E5%9F%BA%E4%BA%8EStagefright%E7%9A%84MediaPlayer%E6%92%AD%E6%94%BE%E6%A1%86%E6%9E%B6-2/26.png"></li>
</ol>
<p>这样就结束了吗？还没呢，我们上面看到的只是beginAsyncPrepare_l最后还有finishAsyncPrepare_l，这里主要完成通知上层prepare结束：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void AwesomePlayer::finish<span class="constructor">AsyncPrepare_l()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mIsAsyncPrepare) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mVideoSource<span class="operator"> == </span>NULL) &#123;</span><br><span class="line">            notify<span class="constructor">Listener_l(MEDIA_SET_VIDEO_SIZE, 0, 0)</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            notify<span class="constructor">VideoSize_l()</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        notify<span class="constructor">Listener_l(MEDIA_PREPARED)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mPrepareResult = OK;</span><br><span class="line">    modify<span class="constructor">Flags((PREPARING|PREPARE_CANCELLED|PREPARING_CONNECTED)</span>, CLEAR);</span><br><span class="line">    modify<span class="constructor">Flags(PREPARED, SET)</span>;</span><br><span class="line">    mAsyncPrepareEvent = NULL;</span><br><span class="line">    mPreparedCondition.broadcast<span class="literal">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mAudioTearDown) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mPrepareResult<span class="operator"> == </span>OK) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mExtractorFlags &amp; MediaExtractor::CAN_SEEK) &#123;</span><br><span class="line">                seek<span class="constructor">To_l(<span class="params">mAudioTearDownPosition</span>)</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mAudioTearDownWasPlaying) &#123;</span><br><span class="line">                modify<span class="constructor">Flags(CACHE_UNDERRUN, CLEAR)</span>;</span><br><span class="line">                play<span class="constructor">_l()</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mAudioTearDown = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们重点看下notifyListener_l(MEDIA_PREPARED);</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void AwesomePlayer::notify<span class="constructor">Listener_l(<span class="params">int</span> <span class="params">msg</span>, <span class="params">int</span> <span class="params">ext1</span>, <span class="params">int</span> <span class="params">ext2</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ((mListener != NULL)<span class="operator"> &amp;&amp; </span>!mAudioTearDown) &#123;</span><br><span class="line">        sp&lt;MediaPlayerBase&gt; listener = mListener.promote<span class="literal">()</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (listener != NULL) &#123;</span><br><span class="line">            listener-&gt;send<span class="constructor">Event(<span class="params">msg</span>, <span class="params">ext1</span>, <span class="params">ext2</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大家还记得下面这张图吧，我们从这张图上可以很明显看出整个调用的结束点为EventHandler<br><img src="/2016/07/31/Android-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E5%9F%BA%E4%BA%8EStagefright%E7%9A%84MediaPlayer%E6%92%AD%E6%94%BE%E6%A1%86%E6%9E%B6-2/27.png"><br>整个上层的处理很简单就是先判断下是否有注册mOnPreparedListener如果有则调用onPrepared方法，将后续工作交给开发者处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> MEDIA_PREPARED:</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        scanInternalSubtitleTracks();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">        <span class="comment">// send error message instead of crashing;</span></span><br><span class="line">        <span class="comment">// send error message instead of inlining a call to onError</span></span><br><span class="line">        <span class="comment">// to avoid code duplication.</span></span><br><span class="line">        <span class="type">Message</span> <span class="variable">msg2</span> <span class="operator">=</span> obtainMessage(</span><br><span class="line">                MEDIA_ERROR, MEDIA_ERROR_UNKNOWN, MEDIA_ERROR_UNSUPPORTED, <span class="literal">null</span>);</span><br><span class="line">        sendMessage(msg2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mOnPreparedListener != <span class="literal">null</span>)</span><br><span class="line">        mOnPreparedListener.onPrepared(mMediaPlayer);</span><br><span class="line">    <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure>




        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Android-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">Android 源码分析</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/AOSP-源码/">AOSP 源码</a>
  </div>

</div>



<div class="comments-count">
	
	  	<span></span>
		<a href="/2016/07/31/Android-源码分析基于Stagefright的MediaPlayer播放框架-2/#comments" class="ds-thread-count comments-count-link" data-thread-key="2016/07/31/Android-源码分析基于Stagefright的MediaPlayer播放框架-2/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/07/31/Android-源码分析之基于Stagefright的MediaPlayer播放框架-1/" title="Android 源码分析之基于Stagefright的MediaPlayer播放框架[2]" itemprop="url">Android 源码分析之基于Stagefright的MediaPlayer播放框架[2]</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Edgar" target="_blank" itemprop="author">Edgar</a>
		
  <p class="article-time">
    <time datetime="2016-07-31T09:59:18.000Z" itemprop="datePublished"> Published 2016-07-31</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h5 id="MediaPlayer播放框架源代码解析："><a href="#MediaPlayer播放框架源代码解析：" class="headerlink" title="MediaPlayer播放框架源代码解析："></a>MediaPlayer播放框架源代码解析：</h5><h6 id="setDataSource–创建播放引擎，设置数据源"><a href="#setDataSource–创建播放引擎，设置数据源" class="headerlink" title="setDataSource–创建播放引擎，设置数据源"></a>setDataSource–创建播放引擎，设置数据源</h6><p>setDataSource可以使用文件路径，Url，以及Content Provider作为获取资源的标识，为了将流程简单化我们以文件的Uri作为参数进行传递。分析整个流程。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public void set<span class="constructor">DataSource(Context <span class="params">context</span>, Uri <span class="params">uri</span>)</span></span><br><span class="line">    throws IOException, IllegalArgumentException, SecurityException, IllegalStateException &#123;</span><br><span class="line">    set<span class="constructor">DataSource(<span class="params">context</span>, <span class="params">uri</span>, <span class="params">null</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们这里假设走的是文件类型的分支：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDataSource</span><span class="params">(Context context, Uri uri, Map&lt;String, String&gt; headers)</span></span><br><span class="line">        <span class="keyword">throws</span> IOException, IllegalArgumentException, SecurityException,</span><br><span class="line">        IllegalStateException &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">scheme</span> <span class="operator">=</span> uri.getScheme();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (ContentResolver.SCHEME_FILE.equals(scheme)) &#123;</span><br><span class="line">        <span class="comment">//1. 当uri为file时候走这个分支</span></span><br><span class="line">        setDataSource(uri.getPath());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ContentResolver.SCHEME_CONTENT.equals(scheme)</span><br><span class="line">            &amp;&amp; Settings.AUTHORITY.equals(uri.getAuthority())) &#123;</span><br><span class="line">        <span class="comment">//2. 当uri为铃声类型的时候走这里</span></span><br><span class="line">        <span class="comment">// Redirect ringtones to go directly to underlying provider</span></span><br><span class="line">        uri = RingtoneManager.getActualDefaultRingtoneUri(context,</span><br><span class="line">                RingtoneManager.getDefaultType(uri));</span><br><span class="line">        <span class="keyword">if</span> (uri == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FileNotFoundException</span>(<span class="string">&quot;Failed to resolve default ringtone&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">AssetFileDescriptor</span> <span class="variable">fd</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//3. 如果content为文件类型的时候走这个分支</span></span><br><span class="line">        <span class="type">ContentResolver</span> <span class="variable">resolver</span> <span class="operator">=</span> context.getContentResolver();</span><br><span class="line">        fd = resolver.openAssetFileDescriptor(uri, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (fd == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (fd.getDeclaredLength() &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            setDataSource(fd.getFileDescriptor());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            setDataSource(fd.getFileDescriptor(), fd.getStartOffset(), fd.getDeclaredLength());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SecurityException | IOException ex) &#123;</span><br><span class="line">        Log.w(TAG, <span class="string">&quot;Couldn&#x27;t open file on client side; trying server side: &quot;</span> + ex);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (fd != <span class="literal">null</span>) &#123;</span><br><span class="line">            fd.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//否则走这个流程</span></span><br><span class="line">    setDataSource(uri.toString(), headers);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">setDataSource</span><span class="params">(String path)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException, IllegalArgumentException, SecurityException, IllegalStateException </span>&#123;</span><br><span class="line">    setDataSource(path, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">private <span class="keyword">void</span> setDataSource(<span class="built_in">String</span> path, <span class="built_in">String</span>[] keys, <span class="built_in">String</span>[] values)</span><br><span class="line">        throws IOException, IllegalArgumentException, SecurityException, IllegalStateException &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">Uri</span> uri = <span class="built_in">Uri</span>.parse(path);</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">String</span> scheme = uri.getScheme();</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;file&quot;</span>.equals(scheme)) &#123;</span><br><span class="line">        path = uri.getPath();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (scheme != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// handle non-file sources</span></span><br><span class="line">        nativeSetDataSource(</span><br><span class="line">            MediaHTTPService.createHttpServiceBinderIfNecessary(path),</span><br><span class="line">            path,</span><br><span class="line">            keys,</span><br><span class="line">            values);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> File file = <span class="keyword">new</span> File(path);</span><br><span class="line">    <span class="keyword">if</span> (file.exists()) &#123;</span><br><span class="line">        FileInputStream <span class="keyword">is</span> = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">        FileDescriptor fd = <span class="keyword">is</span>.getFD();</span><br><span class="line">        setDataSource(fd);</span><br><span class="line">        <span class="keyword">is</span>.close();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">&quot;setDataSource failed.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">setDataSource</span><span class="params">(FileDescriptor fd)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException, IllegalArgumentException, IllegalStateException </span>&#123;</span><br><span class="line">    <span class="comment">// intentionally less than LONG_MAX</span></span><br><span class="line">    setDataSource(fd, <span class="number">0</span>, <span class="number">0x7ffffffffffffff</span>L);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public void set<span class="constructor">DataSource(FileDescriptor <span class="params">fd</span>, <span class="params">long</span> <span class="params">offset</span>, <span class="params">long</span> <span class="params">length</span>)</span></span><br><span class="line">        throws IOException, IllegalArgumentException, IllegalStateException &#123;</span><br><span class="line">    <span class="constructor">_setDataSource(<span class="params">fd</span>, <span class="params">offset</span>, <span class="params">length</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="function"><span class="keyword">void</span> <span class="title">_setDataSource</span><span class="params">(FileDescriptor fd, <span class="keyword">long</span> offset, <span class="keyword">long</span> length)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException, IllegalArgumentException, IllegalStateException</span>;</span><br></pre></td></tr></table></figure>
<p>下面是整个setDataSource的大致路径图，如果看不清楚可以点击下面的图片再看，或者将图片保存在本地后放大看，因为内容太多所以画的时候容纳不下只能将其缩小：<br><img src="/2016/07/31/Android-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E5%9F%BA%E4%BA%8EStagefright%E7%9A%84MediaPlayer%E6%92%AD%E6%94%BE%E6%A1%86%E6%9E%B6-1/1.png"></p>
<p>到这里我们已经准备进入JNI层了，在JNI部分调用的是<br>android_media_MediaPlayer_setDataSourceFD方法。在这里通过调用getMediaPlayer方法获取开始的时候存储在fields.context上的native MediaPlayer，所以mp-&gt;setDataSource(fd, offset, length)中的mp指的是native的MediaPlayer。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">static void</span><br><span class="line">android<span class="constructor">_media_MediaPlayer_setDataSourceFD(JNIEnv <span class="operator">*</span><span class="params">env</span>, <span class="params">jobject</span> <span class="params">thiz</span>, <span class="params">jobject</span> <span class="params">fileDescriptor</span>, <span class="params">jlong</span> <span class="params">offset</span>, <span class="params">jlong</span> <span class="params">length</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    sp&lt;MediaPlayer&gt; mp = get<span class="constructor">MediaPlayer(<span class="params">env</span>, <span class="params">thiz</span>)</span>;</span><br><span class="line">    <span class="built_in">int</span> fd = jni<span class="constructor">GetFDFromFileDescriptor(<span class="params">env</span>, <span class="params">fileDescriptor</span>)</span>;</span><br><span class="line">    <span class="constructor">ALOGV(<span class="string">&quot;setDataSourceFD: fd %d&quot;</span>, <span class="params">fd</span>)</span>;</span><br><span class="line">    process<span class="constructor">_media_player_call( <span class="params">env</span>, <span class="params">thiz</span>, <span class="params">mp</span>-&gt;<span class="params">setDataSource</span>(<span class="params">fd</span>, <span class="params">offset</span>, <span class="params">length</span>)</span>,<span class="string">&quot;java/io/IOException&quot;</span>, <span class="string">&quot;setDataSourceFD failed.&quot;</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="创建并加载播放引擎"><a href="#创建并加载播放引擎" class="headerlink" title="创建并加载播放引擎"></a>创建并加载播放引擎</h6><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">static sp&lt;MediaPlayer&gt; get<span class="constructor">MediaPlayer(JNIEnv<span class="operator">*</span> <span class="params">env</span>, <span class="params">jobject</span> <span class="params">thiz</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Mutex::Autolock l(sLock);</span><br><span class="line">    MediaPlayer* const p = (MediaPlayer*)env-&gt;<span class="constructor">GetLongField(<span class="params">thiz</span>, <span class="params">fields</span>.<span class="params">context</span>)</span>;</span><br><span class="line">    return sp&lt;MediaPlayer&gt;(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在native mediaplayer中首先获取MediaPlayerService，调用它的create方法通过MediaPlayerService::Client::Client方法创建出MediaPlayerService的客户端返回，赋给player。 因此player-&gt;setDataSource(httpService, url, headers)))中的player实际上是<br>MediaPlayerService::Client。<br>@frameworks&#x2F;av&#x2F;media&#x2F;libmedia&#x2F;mediaplayer.cpp</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">MediaPlayer::setDataSource</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> sp&lt;IMediaHTTPService&gt; &amp;httpService,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> <span class="type">char</span> *url, <span class="type">const</span> KeyedVector&lt;String8, String8&gt; *headers)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">status_t</span> err = BAD_VALUE;</span><br><span class="line">    <span class="keyword">if</span> (url != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="function"><span class="type">const</span> sp&lt;IMediaPlayerService&gt;&amp; <span class="title">service</span><span class="params">(getMediaPlayerService())</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (service != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="function">sp&lt;IMediaPlayer&gt; <span class="title">player</span><span class="params">(service-&gt;create(<span class="keyword">this</span>, mAudioSessionId))</span></span>;</span><br><span class="line">            <span class="keyword">if</span> ((NO_ERROR != <span class="built_in">doSetRetransmitEndpoint</span>(player)) ||</span><br><span class="line">                (NO_ERROR != player-&gt;<span class="built_in">setDataSource</span>(httpService, url, headers))) &#123;</span><br><span class="line">                player.<span class="built_in">clear</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            err = <span class="built_in">attachNewPlayer</span>(player);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们先看下这个Client是如何创建的：<br>@ frameworks&#x2F;av&#x2F;media&#x2F;libmedia&#x2F;IMediaDeathNotifier.cpp</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*static*/</span>const sp&lt;IMediaPlayerService&gt;&amp;</span><br><span class="line">IMediaDeathNotifier::get<span class="constructor">MediaPlayerService()</span></span><br><span class="line">&#123;</span><br><span class="line">    Mutex::Autolock <span class="constructor">_l(<span class="params">sServiceLock</span>)</span>;</span><br><span class="line"><span class="keyword">if</span> (sMediaPlayerService<span class="operator"> == </span><span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">//获取ServiceManger</span></span><br><span class="line">        sp&lt;IServiceManager&gt; sm = default<span class="constructor">ServiceManager()</span>;</span><br><span class="line">        sp&lt;IBinder&gt; binder;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">//获取MediaPlayerService</span></span><br><span class="line">            binder = sm-&gt;get<span class="constructor">Service(String16(<span class="string">&quot;media.player&quot;</span>)</span>);</span><br><span class="line">            <span class="keyword">if</span> (binder != <span class="number">0</span>) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            usleep(<span class="number">500000</span>); <span class="comment">// 0.5 s</span></span><br><span class="line">        &#125; <span class="keyword">while</span> (<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sDeathNotifier<span class="operator"> == </span>NULL) &#123;</span><br><span class="line">            sDeathNotifier = <span class="keyword">new</span> <span class="constructor">DeathNotifier()</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//绑定死亡通知</span></span><br><span class="line">        binder-&gt;link<span class="constructor">ToDeath(<span class="params">sDeathNotifier</span>)</span>;</span><br><span class="line">        sMediaPlayerService = interface_cast&lt;IMediaPlayerService&gt;(binder);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="constructor">ALOGE_IF(<span class="params">sMediaPlayerService</span> <span class="operator">==</span> 0, <span class="string">&quot;no media player service!?&quot;</span>)</span>;</span><br><span class="line">    return sMediaPlayerService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先是获取MediaPlayerService，它是在mediaserver的main方法中创建的这个会在后面进行介绍：<br>@frameworks&#x2F;av&#x2F;media&#x2F;libmediaplayerservice&#x2F;MediaPlayerService.cpp</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function">sp&lt;IMediaPlayer&gt; <span class="title">MediaPlayerService::create</span><span class="params">(<span class="type">const</span> sp&lt;IMediaPlayerClient&gt;&amp; client,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">int</span> audioSessionId)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid = IPCThreadState::<span class="built_in">self</span>()-&gt;<span class="built_in">getCallingPid</span>();</span><br><span class="line">    <span class="type">int32_t</span> connId = <span class="built_in">android_atomic_inc</span>(&amp;mNextConnId);</span><br><span class="line">    sp&lt;<span class="built_in">Client</span>&gt; c = <span class="keyword">new</span> <span class="built_in">Client</span>(</span><br><span class="line">            <span class="keyword">this</span>, pid, connId, client, audioSessionId,</span><br><span class="line">            IPCThreadState::<span class="built_in">self</span>()-&gt;<span class="built_in">getCallingUid</span>());</span><br><span class="line">    wp&lt;<span class="built_in">Client</span>&gt; w = c;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mLock)</span></span>;</span><br><span class="line">        mClients.<span class="built_in">add</span>(w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面代码中new了一个Client对象并添加到mClients中。下面是Client的构造方法，这里没啥可以介绍的：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">MediaPlayerService::<span class="built_in">Client</span>::<span class="built_in">Client</span>(</span><br><span class="line">        <span class="type">const</span> sp&lt;MediaPlayerService&gt;&amp; service, <span class="type">pid_t</span> pid,</span><br><span class="line">        <span class="type">int32_t</span> connId, <span class="type">const</span> sp&lt;IMediaPlayerClient&gt;&amp; client,</span><br><span class="line">        <span class="type">int</span> audioSessionId, <span class="type">uid_t</span> uid)</span><br><span class="line">&#123;</span><br><span class="line">    mPid = pid;</span><br><span class="line">    mConnId = connId;</span><br><span class="line">    mService = service;</span><br><span class="line">    mClient = client;</span><br><span class="line">    mLoop = <span class="literal">false</span>;</span><br><span class="line">    mStatus = NO_INIT;</span><br><span class="line">    mAudioSessionId = audioSessionId;</span><br><span class="line">    mUID = uid;</span><br><span class="line">    mRetransmitEndpointValid = <span class="literal">false</span>;</span><br><span class="line">    mAudioAttributes = <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> CALLBACK_ANTAGONIZER</span></span><br><span class="line">    <span class="built_in">ALOGD</span>(<span class="string">&quot;create Antagonizer&quot;</span>);</span><br><span class="line">    mAntagonizer = <span class="keyword">new</span> <span class="built_in">Antagonizer</span>(notify, <span class="keyword">this</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在MediaPlayerService::Client::setDataSource方法中首先通过<br>MediaPlayerFactory::getPlayerType获取最匹配的player的类型。然后通过<br>setDataSource_pre(playerType)创建出getPlayerType方法返回类型的player。最后再调用所创建出来的player的setDataSource。下面我们就这个部分一步一步进行深入分析。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">status_t MediaPlayerService::Client::set<span class="constructor">DataSource(<span class="params">int</span> <span class="params">fd</span>, <span class="params">int64_t</span> <span class="params">offset</span>, <span class="params">int64_t</span> <span class="params">length</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> stat sb;</span><br><span class="line">    <span class="built_in">int</span> ret = fstat(fd, &amp;sb);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="constructor">ALOGE(<span class="string">&quot;fstat(%d) failed: %d, %s&quot;</span>, <span class="params">fd</span>, <span class="params">ret</span>, <span class="params">strerror</span>(<span class="params">errno</span>)</span>);</span><br><span class="line">        return UNKNOWN_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果偏移量大于文件大小则表示偏移量设置得不对</span></span><br><span class="line">    <span class="keyword">if</span> (offset &gt;= sb.st_size) &#123;</span><br><span class="line">        <span class="constructor">ALOGE(<span class="string">&quot;offset error&quot;</span>)</span>;</span><br><span class="line">        ::close(fd);</span><br><span class="line">        return UNKNOWN_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果偏移量加上长度大于整个文件的长度则输出错误信息，并调整length值</span></span><br><span class="line">    <span class="keyword">if</span> (offset + length &gt; sb.st_size) &#123;</span><br><span class="line">        length = sb.st_size - offset;</span><br><span class="line">        <span class="constructor">ALOGV(<span class="string">&quot;calculated length = %lld&quot;</span>, <span class="params">length</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//get the file type of current play file</span></span><br><span class="line">    <span class="comment">//there will create StagefrightPlayer</span></span><br><span class="line">    player_type playerType = MediaPlayerFactory::get<span class="constructor">PlayerType(<span class="params">this</span>,<span class="params">fd</span>,<span class="params">offset</span>,<span class="params">length</span>)</span>;</span><br><span class="line">    sp&lt;MediaPlayerBase&gt; p = set<span class="constructor">DataSource_pre(<span class="params">playerType</span>)</span>;</span><br><span class="line">    <span class="keyword">if</span> (p<span class="operator"> == </span>NULL) &#123;</span><br><span class="line">        return NO_INIT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// now set data source</span></span><br><span class="line">    set<span class="constructor">DataSource_post(<span class="params">p</span>, <span class="params">p</span>-&gt;<span class="params">setDataSource</span>(<span class="params">fd</span>, <span class="params">offset</span>, <span class="params">length</span>)</span>);</span><br><span class="line">    return mStatus;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先我们看下getPlayerType，它传入的参数为IMediaPlayer类型的client参数以及一个url参数。而获得player类型是通过GET_PLAYER_TYPE_IMPL宏来实现的。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">player_type MediaPlayerFactory::get<span class="constructor">PlayerType(<span class="params">const</span> <span class="params">sp</span>&lt;IMediaPlayer&gt;&amp; <span class="params">client</span>,<span class="params">const</span> <span class="params">char</span><span class="operator">*</span> <span class="params">url</span>)</span> &#123;</span><br><span class="line">    <span class="constructor">GET_PLAYER_TYPE_IMPL(<span class="params">client</span>, <span class="params">url</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>sFactoryMap是包含每种类型Player的工厂类的数组，在GET_PLAYER_TYPE_IMPL中首先会遍历sFactoryMap并调用每个IFactory的scoreFactory方法对其进行评估找出最匹配的Player类型并返回。</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">#define GET_PLAYER_TYPE_IMPL(a...)                      \</span></span><br><span class="line">    Mutex::Autolock lock_(&amp;sLock);                      <span class="string">\</span></span><br><span class="line">                                                     <span class="string">\</span></span><br><span class="line">    player_type ret = STAGEFRIGHT_PLAYER;               <span class="string">\</span></span><br><span class="line">    float bestScore = <span class="number">0.0</span>;                              <span class="string">\</span></span><br><span class="line">                                                     <span class="string">\</span></span><br><span class="line">    <span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; sFactoryMap.size(); ++i) &#123;   <span class="string">\</span></span><br><span class="line">                                                        <span class="string">\</span></span><br><span class="line">        IFactory* v = sFactoryMap.valueAt(i);           <span class="string">\</span></span><br><span class="line">        float thisScore;                                <span class="string">\</span></span><br><span class="line">        CHECK(v != NULL);                               <span class="string">\</span></span><br><span class="line">        thisScore = v-&gt;scoreFactory(a, bestScore);      <span class="string">\</span></span><br><span class="line">        <span class="keyword">if</span> (thisScore &gt; bestScore) &#123;                    <span class="string">\</span></span><br><span class="line">            ret = sFactoryMap.keyAt(i);                 <span class="string">\</span></span><br><span class="line">            bestScore = thisScore;                      <span class="string">\</span></span><br><span class="line">        &#125;                                           <span class="string">\</span></span><br><span class="line">    &#125;                                                                                              </span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0.0</span> == bestScore) &#123;                             <span class="string">\</span></span><br><span class="line">        ret = getDefaultPlayerType();                   <span class="string">\</span></span><br><span class="line">    &#125;                                                                        <span class="string">\</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br></pre></td></tr></table></figure>
<p>在获得播放器类型后在setDataSource_pre中调用createPlayer方法创建对应类型的player</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">sp&lt;MediaPlayerBase&gt; MediaPlayerService::Client::<span class="title function_ invoke__">setDataSource_pre</span>(</span><br><span class="line">        player_<span class="keyword">type</span> <span class="title class_">playerType</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="title function_ invoke__">ALOGV</span>(<span class="string">&quot;player type = %d&quot;</span>, playerType);</span><br><span class="line">    <span class="comment">// create the right type of player</span></span><br><span class="line">    sp&lt;MediaPlayerBase&gt; p = <span class="title function_ invoke__">createPlayer</span>(playerType);</span><br><span class="line">    <span class="title function_ invoke__">if</span> (p == NULL) &#123;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">if</span> (!p<span class="punctuation">-&gt;</span><span class="title function_ invoke__">hardwareOutput</span>()) &#123;</span><br><span class="line">        Mutex::Autolock <span class="title function_ invoke__">l</span>(mLock);</span><br><span class="line">        mAudioOutput = </span><br><span class="line">        new <span class="title function_ invoke__">AudioOutput</span>(mAudioSessionId, IPCThreadState::<span class="title function_ invoke__">self</span>()<span class="punctuation">-&gt;</span><span class="title function_ invoke__">getCallingUid</span>(),</span><br><span class="line">                mPid, mAudioAttributes);</span><br><span class="line">        static_cast&lt;MediaPlayerInterface*&gt;(p.<span class="title function_ invoke__">get</span>())<span class="punctuation">-&gt;</span><span class="title function_ invoke__">setAudioSink</span>(mAudioOutput);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面代码中会创建一个音频播放硬件的抽象–AudioOutput，它负责将Buffer输出到硬件的接口，这个将会在介绍start方法的时候进行介绍：</p>
<p>在MediaPlayerService::Client::createPlayer中调用的是MediaPlayerFactory这个工厂类，根据传进去的playerType来创建对应的Player，</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">sp&lt;MediaPlayerBase&gt; MediaPlayerService::Client::create<span class="constructor">Player(<span class="params">player_type</span> <span class="params">playerType</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// determine if we have the right player type</span></span><br><span class="line">    sp&lt;MediaPlayerBase&gt; p = mPlayer;</span><br><span class="line">    <span class="keyword">if</span> ((p != NULL)<span class="operator"> &amp;&amp; </span>(p-&gt;player<span class="constructor">Type()</span> != playerType)) &#123;</span><br><span class="line">        p.clear<span class="literal">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p<span class="operator"> == </span>NULL) &#123;</span><br><span class="line">        p = MediaPlayerFactory::create<span class="constructor">Player(<span class="params">playerType</span>, <span class="params">this</span>, <span class="params">notify</span>, <span class="params">mPid</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p != NULL) &#123;</span><br><span class="line">        p-&gt;set<span class="constructor">UID(<span class="params">mUID</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例如我们传入的是STAGEFRIGHT_PLAYER，那么将new出一个StagefrightPlayer.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> sp&lt;MediaPlayerBase&gt; <span class="title">createPlayer</span><span class="params">(<span class="type">pid_t</span> <span class="comment">/* pid */</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">StagefrightPlayer</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在StagefrightPlayer构造方法中 new 出了AwesomePlayer。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">StagefrightPlayer::<span class="constructor">StagefrightPlayer()</span></span><br><span class="line">    : m<span class="constructor">Player(<span class="params">new</span> AwesomePlayer)</span> &#123;</span><br><span class="line">    <span class="constructor">ALOGV(<span class="string">&quot;StagefrightPlayer&quot;</span>)</span>;</span><br><span class="line">    mPlayer-&gt;set<span class="constructor">Listener(<span class="params">this</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面这个图当时是连同NuPlayer一起画的，因为这部分逻辑两者还是一致的，如果大家暂时不想了解Nuplayer可以只看一边<br><img src="/2016/07/31/Android-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E5%9F%BA%E4%BA%8EStagefright%E7%9A%84MediaPlayer%E6%92%AD%E6%94%BE%E6%A1%86%E6%9E%B6-1/2.png"></p>
<p>在AwesomePlayer构造方法中通过RegisterDefaultSniffers注册了格式sniffer，创建出一系列AwesomeEvent，并通过mClient.connect()加载一系列编码器插件。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">AwesomePlayer::<span class="built_in">AwesomePlayer</span>()</span><br><span class="line">    : <span class="built_in">mQueueStarted</span>(<span class="literal">false</span>),</span><br><span class="line">      <span class="built_in">mUIDValid</span>(<span class="literal">false</span>),</span><br><span class="line">      <span class="built_in">mTimeSource</span>(<span class="literal">NULL</span>),</span><br><span class="line">      <span class="built_in">mVideoRenderingStarted</span>(<span class="literal">false</span>),</span><br><span class="line">      <span class="built_in">mVideoRendererIsPreview</span>(<span class="literal">false</span>),</span><br><span class="line">      <span class="built_in">mMediaRenderingStartGeneration</span>(<span class="number">0</span>),</span><br><span class="line">      <span class="built_in">mStartGeneration</span>(<span class="number">0</span>),</span><br><span class="line">      <span class="built_in">mAudioPlayer</span>(<span class="literal">NULL</span>),</span><br><span class="line">      <span class="built_in">mDisplayWidth</span>(<span class="number">0</span>),</span><br><span class="line">      <span class="built_in">mDisplayHeight</span>(<span class="number">0</span>),</span><br><span class="line">      <span class="built_in">mVideoScalingMode</span>(NATIVE_WINDOW_SCALING_MODE_SCALE_TO_WINDOW),</span><br><span class="line">      <span class="built_in">mFlags</span>(<span class="number">0</span>),</span><br><span class="line">      <span class="built_in">mExtractorFlags</span>(<span class="number">0</span>),</span><br><span class="line">      <span class="built_in">mVideoBuffer</span>(<span class="literal">NULL</span>),</span><br><span class="line">      <span class="built_in">mDecryptHandle</span>(<span class="literal">NULL</span>),</span><br><span class="line">      <span class="built_in">mLastVideoTimeUs</span>(<span class="number">-1</span>),</span><br><span class="line">      <span class="built_in">mTextDriver</span>(<span class="literal">NULL</span>),</span><br><span class="line">      <span class="built_in">mOffloadAudio</span>(<span class="literal">false</span>),</span><br><span class="line">      <span class="built_in">mAudioTearDown</span>(<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="built_in">CHECK_EQ</span>(mClient.<span class="built_in">connect</span>(), (<span class="type">status_t</span>)OK);</span><br><span class="line">    DataSource::<span class="built_in">RegisterDefaultSniffers</span>();</span><br><span class="line">    mVideoEvent = <span class="keyword">new</span> <span class="built_in">AwesomeEvent</span>(<span class="keyword">this</span>, &amp;AwesomePlayer::onVideoEvent);</span><br><span class="line">    mVideoEventPending = <span class="literal">false</span>;</span><br><span class="line">    mStreamDoneEvent = <span class="keyword">new</span> <span class="built_in">AwesomeEvent</span>(<span class="keyword">this</span>, &amp;AwesomePlayer::onStreamDone);</span><br><span class="line">    mStreamDoneEventPending = <span class="literal">false</span>;</span><br><span class="line">    mBufferingEvent = <span class="keyword">new</span> <span class="built_in">AwesomeEvent</span>(<span class="keyword">this</span>, &amp;AwesomePlayer::onBufferingUpdate);</span><br><span class="line">    mBufferingEventPending = <span class="literal">false</span>;</span><br><span class="line">    mVideoLagEvent = <span class="keyword">new</span> <span class="built_in">AwesomeEvent</span>(<span class="keyword">this</span>, &amp;AwesomePlayer::onVideoLagUpdate);</span><br><span class="line">    mVideoLagEventPending = <span class="literal">false</span>;</span><br><span class="line">    mCheckAudioStatusEvent = <span class="keyword">new</span> <span class="built_in">AwesomeEvent</span>(</span><br><span class="line">            <span class="keyword">this</span>, &amp;AwesomePlayer::onCheckAudioStatus);</span><br><span class="line"></span><br><span class="line">    mAudioStatusEventPending = <span class="literal">false</span>;</span><br><span class="line">    mAudioTearDownEvent = <span class="keyword">new</span> <span class="built_in">AwesomeEvent</span>(<span class="keyword">this</span>,</span><br><span class="line">                              &amp;AwesomePlayer::onAudioTearDownEvent);</span><br><span class="line">    mAudioTearDownEventPending = <span class="literal">false</span>;</span><br><span class="line">    mClockEstimator = <span class="keyword">new</span> <span class="built_in">WindowedLinearFitEstimator</span>();</span><br><span class="line">    mPlaybackSettings = AUDIO_PLAYBACK_RATE_DEFAULT;</span><br><span class="line">    <span class="built_in">reset</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">// static</span></span><br><span class="line">void DataSource::<span class="constructor">RegisterDefaultSniffers()</span> &#123;</span><br><span class="line">    Mutex::Autolock auto<span class="constructor">Lock(<span class="params">gSnifferMutex</span>)</span>;</span><br><span class="line">    <span class="keyword">if</span> (gSniffersRegistered) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="constructor">RegisterSniffer_l(SniffMPEG4)</span>;</span><br><span class="line">    <span class="constructor">RegisterSniffer_l(SniffMatroska)</span>;</span><br><span class="line">    <span class="constructor">RegisterSniffer_l(SniffOgg)</span>;</span><br><span class="line">    <span class="constructor">RegisterSniffer_l(SniffWAV)</span>;</span><br><span class="line">    <span class="constructor">RegisterSniffer_l(SniffFLAC)</span>;</span><br><span class="line">    <span class="constructor">RegisterSniffer_l(SniffAMR)</span>;</span><br><span class="line">    <span class="constructor">RegisterSniffer_l(SniffMPEG2TS)</span>;</span><br><span class="line">    <span class="constructor">RegisterSniffer_l(SniffMP3)</span>;</span><br><span class="line">    <span class="constructor">RegisterSniffer_l(SniffAAC)</span>;</span><br><span class="line">    <span class="constructor">RegisterSniffer_l(SniffMPEG2PS)</span>;</span><br><span class="line">    <span class="constructor">RegisterSniffer_l(SniffWVM)</span>;</span><br><span class="line">    <span class="constructor">RegisterSniffer_l(SniffMidi)</span>;</span><br><span class="line">    <span class="built_in">char</span> value<span class="literal">[PROPERTY<span class="identifier">_VALUE_MAX</span>]</span>;</span><br><span class="line">    <span class="keyword">if</span> (property<span class="constructor">_get(<span class="string">&quot;drm.service.enabled&quot;</span>, <span class="params">value</span>, NULL)</span><span class="operator"></span></span><br><span class="line"><span class="operator">            &amp;&amp; </span>(!strcmp(value, <span class="string">&quot;1&quot;</span>)<span class="operator"> || </span>!strcasecmp(value, <span class="string">&quot;true&quot;</span>))) &#123;</span><br><span class="line">        <span class="constructor">RegisterSniffer_l(SniffDRM)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    gSniffersRegistered = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们接下来看下OMXClient::connect方法。它是通过MediaPlayerService方法中的getOMX获取new 出来的OMX对象。在OMX对象中有个mMaster的成员变量，在创建它的时候调用addVendorPlugin以及addPlugin来加载软件以及硬件的解码器插件。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">status_t OMXClient::connect<span class="literal">()</span> &#123;</span><br><span class="line">    sp&lt;IServiceManager&gt; sm = default<span class="constructor">ServiceManager()</span>;</span><br><span class="line">    sp&lt;IBinder&gt; binder = sm-&gt;get<span class="constructor">Service(String16(<span class="string">&quot;media.player&quot;</span>)</span>);</span><br><span class="line">    sp&lt;IMediaPlayerService&gt; service = interface_cast&lt;IMediaPlayerService&gt;(binder);</span><br><span class="line">    mOMX = service-&gt;get<span class="constructor">OMX()</span>;</span><br><span class="line">    <span class="keyword">if</span> (!mOMX-&gt;lives<span class="constructor">Locally(0 <span class="operator">/</span><span class="operator">*</span> <span class="params">node</span> <span class="operator">*</span><span class="operator">/</span>, <span class="params">getpid</span>()</span>)) &#123;</span><br><span class="line">        <span class="constructor">ALOGI(<span class="string">&quot;Using client-side OMX mux.&quot;</span>)</span>;</span><br><span class="line">        mOMX = <span class="keyword">new</span> <span class="constructor">MuxOMX(<span class="params">mOMX</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">sp&lt;IOMX&gt; <span class="title">MediaPlayerService::getOMX</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Mutex::Autolock <span class="title">autoLock</span><span class="params">(mLock)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (mOMX.<span class="built_in">get</span>() == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        mOMX = <span class="keyword">new</span> OMX;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mOMX;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">OMX::<span class="built_in">OMX</span>()</span><br><span class="line">    : <span class="built_in">mMaster</span>(new OMXMaster),</span><br><span class="line">      <span class="built_in">mNodeCounter</span>(<span class="number">0</span>) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight isbl"><table><tr><td class="code"><pre><span class="line"><span class="variable">OMXMaster</span>::<span class="function"><span class="title">OMXMaster</span>()</span></span><br><span class="line">    : <span class="function"><span class="title">mVendorLibHandle</span>(<span class="variable"><span class="literal">NULL</span></span>) &#123;</span></span><br><span class="line"><span class="function">    <span class="title">addVendorPlugin</span>();</span></span><br><span class="line"><span class="function">    <span class="title">addPlugin</span>(<span class="variable">new</span> <span class="variable">SoftOMXPlugin</span>);</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>
<p>我们看下VendorPlugin的创建过程，首先它会调用dlopen打开libstagefrighthw.so动态库，然后调用里面的createOMXPlugin方法，创建出OMXPluginBase类型的对象，然后通过OMXMaster::addPlugin(OMXPluginBase *plugin)方法将其添加到mPluginByComponentName中。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title class_">OMXMaster</span>::<span class="title function_">addVendorPlugin</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">addPlugin</span>(<span class="string">&quot;libstagefrighthw.so&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void OMXMaster::add<span class="constructor">Plugin(<span class="params">const</span> <span class="params">char</span> <span class="operator">*</span><span class="params">libname</span>)</span> &#123;</span><br><span class="line">    mVendorLibHandle = dlopen(libname, RTLD_NOW);</span><br><span class="line">    typedef OMXPluginBase *(*CreateOMXPluginFunc)<span class="literal">()</span>;</span><br><span class="line">    CreateOMXPluginFunc createOMXPlugin =</span><br><span class="line">        (CreateOMXPluginFunc)dlsym(mVendorLibHandle, <span class="string">&quot;createOMXPlugin&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!createOMXPlugin)</span><br><span class="line">        createOMXPlugin = (CreateOMXPluginFunc)dlsym(</span><br><span class="line">                mVendorLibHandle, <span class="string">&quot;_ZN7android15createOMXPluginEv&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (createOMXPlugin) &#123;</span><br><span class="line">        add<span class="constructor">Plugin((<span class="operator">*</span><span class="params">createOMXPlugin</span>)</span><span class="literal">()</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在OMXMaster::addPlugin(OMXPluginBase *plugin)方法中将会调用enumerateComponents方法列出VentorPlugin或者SoftPlugin中的所有Components，添加到mPluginByComponentName</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> OMXMaster::addPlugin(OMXPluginBase *plugin) &#123;</span><br><span class="line">    Mutex::Autolock autoLock(mLock);</span><br><span class="line">    mPlugins.push_back(plugin);</span><br><span class="line">    OMX_U32 <span class="keyword">index</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> <span class="type">name</span>[<span class="number">128</span>];</span><br><span class="line">    OMX_ERRORTYPE err;</span><br><span class="line">    <span class="keyword">while</span> ((err = plugin-&gt;enumerateComponents(</span><br><span class="line">                    <span class="type">name</span>, sizeof(<span class="type">name</span>), <span class="keyword">index</span>++)) == OMX_ErrorNone) &#123;</span><br><span class="line">        String8 name8(<span class="type">name</span>);</span><br><span class="line">        <span class="keyword">if</span> (mPluginByComponentName.indexOfKey(name8) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            ALOGE(&quot;A component of name &#x27;%s&#x27; already exists, ignoring this one.&quot;,</span><br><span class="line">                 name8.string());</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mPluginByComponentName.<span class="keyword">add</span>(name8, plugin);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2016/07/31/Android-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E5%9F%BA%E4%BA%8EStagefright%E7%9A%84MediaPlayer%E6%92%AD%E6%94%BE%E6%A1%86%E6%9E%B6-1/11.png"><br><img src="/2016/07/31/Android-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E5%9F%BA%E4%BA%8EStagefright%E7%9A%84MediaPlayer%E6%92%AD%E6%94%BE%E6%A1%86%E6%9E%B6-1/6.png"></p>
<p>到目前为止我们在Client部分根据Uri类型找到匹配的player类型，并根据这个类型调用对应的工厂类，创建出对应的player，这里以MP3格式为例，那么创建出的将是StagefrightPlayer类型的播放器，在创建过程中new出了带有AwesomeEvent的AwesomePlayer，并注册了格式sniffer以及完成了VentorPlugin以及SoftPlugin名的加载。</p>
<h6 id="加载数据源"><a href="#加载数据源" class="headerlink" title="加载数据源"></a>加载数据源</h6><p>播放引擎加载结束后就需要为播放引擎添加数据源了。<br>再回到SetDataSource的流程上来，创建完StagefrightPlayer后将会调用它的SetDataSource方法。在该方法中将会调用mPlayer的SetDataSource。在介绍StagefrightPlayer创建流程的时候我们已经知道mPlayer是AwesomePlayer对象，所以我们需要看下AwesomePlayer类中的setDataSource方法。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">StagefrightPlayer::setDataSource</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> sp&lt;IMediaHTTPService&gt; &amp;httpService,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> <span class="type">char</span> *url,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> KeyedVector&lt;String8, String8&gt; *headers)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mPlayer-&gt;<span class="built_in">setDataSource</span>(httpService, url, headers);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是AwesomePlayer类中setDataSource，它经过层层调用最终new出一个FileSource 对象赋给mFileSource。并通过MediaExtractor::Create创建出一个Extractor从FileSource中抽取出如，比特率等参数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">AwesomePlayer::setDataSource</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> sp&lt;IMediaHTTPService&gt; &amp;httpService,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> <span class="type">char</span> *uri,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> KeyedVector&lt;String8, String8&gt; *headers)</span> </span>&#123;</span><br><span class="line">    <span class="function">Mutex::Autolock <span class="title">autoLock</span><span class="params">(mLock)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">setDataSource_l</span>(httpService, uri, headers);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">AwesomePlayer::setDataSource</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">int</span> fd, <span class="type">int64_t</span> offset, <span class="type">int64_t</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="function">Mutex::Autolock <span class="title">autoLock</span><span class="params">(mLock)</span></span>;</span><br><span class="line">    <span class="built_in">reset_l</span>();</span><br><span class="line">    sp&lt;DataSource&gt; dataSource = <span class="keyword">new</span> <span class="built_in">FileSource</span>(fd, offset, length);</span><br><span class="line">    <span class="type">status_t</span> err = dataSource-&gt;<span class="built_in">initCheck</span>();</span><br><span class="line">    mFileSource = dataSource;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">Mutex::Autolock <span class="title">autoLock</span><span class="params">(mStatsLock)</span></span>;</span><br><span class="line">        mStats.mFd = fd;</span><br><span class="line">        mStats.mURI = <span class="built_in">String8</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">setDataSource_l</span>(dataSource);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight isbl"><table><tr><td class="code"><pre><span class="line"><span class="variable">status_t</span> <span class="variable">AwesomePlayer</span>::<span class="function"><span class="title">setDataSource_l</span>(</span></span><br><span class="line"><span class="function">        <span class="variable">const</span> <span class="variable">sp</span>&lt;<span class="variable">DataSource</span>&gt; &amp;<span class="variable">dataSource</span>) &#123;</span></span><br><span class="line"><span class="function">    <span class="variable">sp</span>&lt;<span class="variable">MediaExtractor</span>&gt; <span class="variable">extractor</span> = <span class="variable">MediaExtractor</span>::<span class="title">Create</span>(<span class="variable">dataSource</span>);</span></span><br><span class="line"><span class="function">    <span class="variable"><span class="keyword">if</span></span> (<span class="variable">extractor</span>-&gt;<span class="title">getDrmFlag</span>()) &#123;</span></span><br><span class="line"><span class="function">        <span class="title">checkDrmStatus</span>(<span class="variable">dataSource</span>);</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function">    <span class="variable">return</span> <span class="title">setDataSource_l</span>(<span class="variable">extractor</span>);</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>
<p>创建MediaExtractor需要调用各个sniff方法判断出当前数据源的类型，然后根据mime创建对应的MediaExtractor，比如我们当前的数据源为MP3类型那么返回的将是MP3Extractor</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// static</span></span><br><span class="line">sp&lt;MediaExtractor&gt; <span class="title class_">MediaExtractor</span>::<span class="title function_ invoke__">Create</span>(</span><br><span class="line">        <span class="keyword">const</span> sp&lt;DataSource&gt; &amp;source, <span class="keyword">const</span> char *mime) &#123;</span><br><span class="line">    sp&lt;AMessage&gt; meta;</span><br><span class="line">    String8 tmp;</span><br><span class="line">    <span class="keyword">if</span> (mime == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> confidence;</span><br><span class="line">        <span class="keyword">if</span> (!source-&gt;<span class="title function_ invoke__">sniff</span>(&amp;tmp, &amp;confidence, &amp;meta)) &#123;</span><br><span class="line">            <span class="title function_ invoke__">ALOGV</span>(<span class="string">&quot;FAILED to autodetect media content.&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mime = tmp.<span class="keyword">string</span>();</span><br><span class="line">        <span class="title function_ invoke__">ALOGV</span>(<span class="string">&quot;Autodetected media content as &#x27;%s&#x27; with confidence %.2f&quot;</span>,</span><br><span class="line">             mime, confidence);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> isDrm = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// DRM MIME type syntax is &quot;drm+type+original&quot; where</span></span><br><span class="line">    <span class="comment">// type is &quot;es_based&quot; or &quot;container_based&quot; and</span></span><br><span class="line">    <span class="comment">// original is the content&#x27;s cleartext MIME type</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="title function_ invoke__">strncmp</span>(mime, <span class="string">&quot;drm+&quot;</span>, <span class="number">4</span>)) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="variable constant_">char</span> *originalMime = <span class="title function_ invoke__">strchr</span>(mime+<span class="number">4</span>, <span class="string">&#x27;+&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (originalMime == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// second + not found</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ++originalMime;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="title function_ invoke__">strncmp</span>(mime, <span class="string">&quot;drm+es_based+&quot;</span>, <span class="number">13</span>)) &#123;</span><br><span class="line">            <span class="comment">// DRMExtractor sets container metadata kKeyIsDRM to 1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DRMExtractor</span>(source, originalMime);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="title function_ invoke__">strncmp</span>(mime, <span class="string">&quot;drm+container_based+&quot;</span>, <span class="number">20</span>)) &#123;</span><br><span class="line">            mime = originalMime;</span><br><span class="line">            isDrm = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    MediaExtractor *ret = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="title function_ invoke__">strcasecmp</span>(mime, MEDIA_MIMETYPE_CONTAINER_MPEG4)</span><br><span class="line">            || !<span class="title function_ invoke__">strcasecmp</span>(mime, <span class="string">&quot;audio/mp4&quot;</span>)) &#123;</span><br><span class="line">        ret = <span class="keyword">new</span> <span class="title class_">MPEG4Extractor</span>(source);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="title function_ invoke__">strcasecmp</span>(mime, MEDIA_MIMETYPE_AUDIO_MPEG)) &#123;</span><br><span class="line">        ret = <span class="keyword">new</span> <span class="title class_">MP3Extractor</span>(source, meta);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="title function_ invoke__">strcasecmp</span>(mime, MEDIA_MIMETYPE_AUDIO_AMR_NB)</span><br><span class="line">            || !<span class="title function_ invoke__">strcasecmp</span>(mime, MEDIA_MIMETYPE_AUDIO_AMR_WB)) &#123;</span><br><span class="line">        ret = <span class="keyword">new</span> <span class="title class_">AMRExtractor</span>(source);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="title function_ invoke__">strcasecmp</span>(mime, MEDIA_MIMETYPE_AUDIO_FLAC)) &#123;</span><br><span class="line">        ret = <span class="keyword">new</span> <span class="title class_">FLACExtractor</span>(source);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="title function_ invoke__">strcasecmp</span>(mime, MEDIA_MIMETYPE_CONTAINER_WAV)) &#123;</span><br><span class="line">        ret = <span class="keyword">new</span> <span class="title class_">WAVExtractor</span>(source);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="title function_ invoke__">strcasecmp</span>(mime, MEDIA_MIMETYPE_CONTAINER_OGG)) &#123;</span><br><span class="line">        ret = <span class="keyword">new</span> <span class="title class_">OggExtractor</span>(source);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="title function_ invoke__">strcasecmp</span>(mime, MEDIA_MIMETYPE_CONTAINER_MATROSKA)) &#123;</span><br><span class="line">        ret = <span class="keyword">new</span> <span class="title class_">MatroskaExtractor</span>(source);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="title function_ invoke__">strcasecmp</span>(mime, MEDIA_MIMETYPE_CONTAINER_MPEG2TS)) &#123;</span><br><span class="line">        ret = <span class="keyword">new</span> <span class="title class_">MPEG2TSExtractor</span>(source);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="title function_ invoke__">strcasecmp</span>(mime, MEDIA_MIMETYPE_CONTAINER_WVM)) &#123;</span><br><span class="line">        <span class="comment">// Return now.  WVExtractor should not have the DrmFlag set in the block below.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WVMExtractor</span>(source);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="title function_ invoke__">strcasecmp</span>(mime, MEDIA_MIMETYPE_AUDIO_AAC_ADTS)) &#123;</span><br><span class="line">        ret = <span class="keyword">new</span> <span class="title class_">AACExtractor</span>(source, meta);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="title function_ invoke__">strcasecmp</span>(mime, MEDIA_MIMETYPE_CONTAINER_MPEG2PS)) &#123;</span><br><span class="line">        ret = <span class="keyword">new</span> <span class="title class_">MPEG2PSExtractor</span>(source);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="title function_ invoke__">strcasecmp</span>(mime, MEDIA_MIMETYPE_AUDIO_MIDI)) &#123;</span><br><span class="line">        ret = <span class="keyword">new</span> <span class="title class_">MidiExtractor</span>(source);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="literal">NULL</span>) &#123;</span><br><span class="line">       <span class="keyword">if</span> (isDrm) &#123;</span><br><span class="line">           ret-&gt;<span class="title function_ invoke__">setDrmFlag</span>(<span class="literal">true</span>);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           ret-&gt;<span class="title function_ invoke__">setDrmFlag</span>(<span class="literal">false</span>);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有了MP3Extractor之后我们就可以从Media文件中抽取文件关键信息了，这里最关键的是extractor-&gt;getTrack(i)这个会返回对应的歌曲内容，通过setAudioSource以及setVideoSource赋值给播放引擎，播放引擎后续将会将这个数据源作为解码器的输入。进行解码</p>
<figure class="highlight zephir"><table><tr><td class="code"><pre><span class="line">status_t AwesomePlayer::setDataSource_l(<span class="keyword">const</span> sp&lt;MediaExtractor&gt; &amp;extractor) &#123;</span><br><span class="line">    <span class="comment">// Attempt to approximate overall stream bitrate by summing all</span></span><br><span class="line">    <span class="comment">// tracks&#x27; individual bitrates, if not all of them advertise bitrate,</span></span><br><span class="line">    <span class="comment">// we have to fail.</span></span><br><span class="line">    int64_t totalBitRate = <span class="number">0</span>;</span><br><span class="line">    mExtractor = extractor;</span><br><span class="line">    <span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; extractor-&gt;countTracks(); ++i) &#123;</span><br><span class="line">        sp&lt;MetaData&gt; meta = extractor-&gt;getTrackMetaData(i);</span><br><span class="line">        int32_t bitrate;</span><br><span class="line">        <span class="keyword">if</span> (!meta-&gt;findInt32(kKeyBitRate, &amp;bitrate)) &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">char</span> *mime;</span><br><span class="line">            CHECK(meta-&gt;findCString(kKeyMIMEType, &amp;mime));</span><br><span class="line">            totalBitRate = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        totalBitRate += bitrate;</span><br><span class="line">    &#125;</span><br><span class="line">    sp&lt;MetaData&gt; fileMeta = mExtractor-&gt;getMetaData();</span><br><span class="line">    <span class="keyword">if</span> (fileMeta != NULL) &#123;</span><br><span class="line">        int64_t duration;</span><br><span class="line">        <span class="keyword">if</span> (fileMeta-&gt;findInt64(kKeyDuration, &amp;duration)) &#123;</span><br><span class="line">            mDurationUs = duration;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mBitrate = totalBitRate;</span><br><span class="line">    ALOGV(<span class="string">&quot;mBitrate = %lld bits/sec&quot;</span>, (<span class="keyword">long</span> <span class="keyword">long</span>)mBitrate);</span><br><span class="line">    &#123;</span><br><span class="line">        Mutex::Autolock autoLock(mStatsLock);</span><br><span class="line">        mStats.mBitrate = mBitrate;</span><br><span class="line">        mStats.mTracks.clear();</span><br><span class="line">        mStats.mAudioTrackIndex = <span class="number">-1</span>;</span><br><span class="line">        mStats.mVideoTrackIndex = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> haveAudio = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">bool</span> haveVideo = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; extractor-&gt;countTracks(); ++i) &#123;</span><br><span class="line">        sp&lt;MetaData&gt; meta = extractor-&gt;getTrackMetaData(i);</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *_mime;</span><br><span class="line">        CHECK(meta-&gt;findCString(kKeyMIMEType, &amp;_mime));</span><br><span class="line"></span><br><span class="line">        String8 mime = String8(_mime);</span><br><span class="line">        <span class="keyword">if</span> (!haveVideo &amp;&amp; !strncasecmp(mime.<span class="keyword">string</span>(), <span class="string">&quot;video/&quot;</span>, <span class="number">6</span>)) &#123;</span><br><span class="line">            setVideoSource(extractor-&gt;getTrack(i));</span><br><span class="line">            haveVideo = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">// Set the presentation/display size</span></span><br><span class="line">            int32_t displayWidth, displayHeight;</span><br><span class="line">            <span class="keyword">bool</span> success = meta-&gt;findInt32(kKeyDisplayWidth, &amp;displayWidth);</span><br><span class="line">            <span class="keyword">if</span> (success) &#123;</span><br><span class="line">                success = meta-&gt;findInt32(kKeyDisplayHeight, &amp;displayHeight);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (success) &#123;</span><br><span class="line">                mDisplayWidth = displayWidth;</span><br><span class="line">                mDisplayHeight = displayHeight;</span><br><span class="line">            &#125;</span><br><span class="line">            &#123;</span><br><span class="line">                Mutex::Autolock autoLock(mStatsLock);</span><br><span class="line">                mStats.mVideoTrackIndex = mStats.mTracks.size();</span><br><span class="line">                mStats.mTracks.push();</span><br><span class="line">                TrackStat *stat =</span><br><span class="line">                    &amp;mStats.mTracks.editItemAt(mStats.mVideoTrackIndex);</span><br><span class="line">                stat-&gt;mMIME = mime.<span class="keyword">string</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!haveAudio &amp;&amp; !strncasecmp(mime.<span class="keyword">string</span>(), <span class="string">&quot;audio/&quot;</span>, <span class="number">6</span>)) &#123;</span><br><span class="line">            setAudioSource(extractor-&gt;getTrack(i));</span><br><span class="line">            haveAudio = <span class="keyword">true</span>;</span><br><span class="line">            mActiveAudioTrackIndex = i;</span><br><span class="line">            &#123;</span><br><span class="line">                Mutex::Autolock autoLock(mStatsLock);</span><br><span class="line">                mStats.mAudioTrackIndex = mStats.mTracks.size();</span><br><span class="line">                mStats.mTracks.push();</span><br><span class="line">                TrackStat *stat =</span><br><span class="line">                    &amp;mStats.mTracks.editItemAt(mStats.mAudioTrackIndex);</span><br><span class="line">                stat-&gt;mMIME = mime.<span class="keyword">string</span>();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!strcasecmp(mime.<span class="keyword">string</span>(), MEDIA_MIMETYPE_AUDIO_VORBIS)) &#123;</span><br><span class="line">                sp&lt;MetaData&gt; fileMeta = extractor-&gt;getMetaData();</span><br><span class="line">                int32_t <span class="keyword">loop</span>;</span><br><span class="line">                <span class="keyword">if</span> (fileMeta != NULL</span><br><span class="line">                        &amp;&amp; fileMeta-&gt;findInt32(kKeyAutoLoop, &amp;<span class="keyword">loop</span>) &amp;&amp; <span class="keyword">loop</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                    modifyFlags(AUTO_LOOPING, SET);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(mime.<span class="keyword">string</span>(), MEDIA_MIMETYPE_TEXT_3GPP)) &#123;</span><br><span class="line">            addTextSource_l(i, extractor-&gt;getTrack(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!haveAudio &amp;&amp; !haveVideo) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mWVMExtractor != NULL) &#123;</span><br><span class="line">            <span class="keyword">return</span> mWVMExtractor-&gt;getError();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> UNKNOWN_ERROR;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mExtractorFlags = extractor-&gt;flags();</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> AwesomePlayer::setAudioSource(sp&lt;MediaSource&gt; <span class="keyword">source</span>) &#123;</span><br><span class="line">    CHECK(<span class="keyword">source</span> != <span class="keyword">NULL</span>);</span><br><span class="line">    mAudioTrack = <span class="keyword">source</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> MediaPlayerService::<span class="built_in">Client</span>::<span class="built_in">setDataSource_post</span>(</span><br><span class="line">        <span class="type">const</span> sp&lt;MediaPlayerBase&gt;&amp; p,</span><br><span class="line">        <span class="type">status_t</span> status)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">ALOGV</span>(<span class="string">&quot; setDataSource&quot;</span>);</span><br><span class="line">    mStatus = status;</span><br><span class="line">    <span class="keyword">if</span> (mStatus != OK) &#123;</span><br><span class="line">        <span class="built_in">ALOGE</span>(<span class="string">&quot;  error: %d&quot;</span>, mStatus);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set the re-transmission endpoint if one was chosen.</span></span><br><span class="line">    <span class="keyword">if</span> (mRetransmitEndpointValid) &#123;</span><br><span class="line">        mStatus = p-&gt;<span class="built_in">setRetransmitEndpoint</span>(&amp;mRetransmitEndpoint);</span><br><span class="line">        <span class="keyword">if</span> (mStatus != NO_ERROR) &#123;</span><br><span class="line">            <span class="built_in">ALOGE</span>(<span class="string">&quot;setRetransmitEndpoint error: %d&quot;</span>, mStatus);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mStatus == OK) &#123;</span><br><span class="line">        mPlayer = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2016/07/31/Android-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E5%9F%BA%E4%BA%8EStagefright%E7%9A%84MediaPlayer%E6%92%AD%E6%94%BE%E6%A1%86%E6%9E%B6-1/4.png"><br><img src="/2016/07/31/Android-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E5%9F%BA%E4%BA%8EStagefright%E7%9A%84MediaPlayer%E6%92%AD%E6%94%BE%E6%A1%86%E6%9E%B6-1/5.png"></p>
<p>最后贴个setDataSource整个过程的结构图：<br><img src="/2016/07/31/Android-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E5%9F%BA%E4%BA%8EStagefright%E7%9A%84MediaPlayer%E6%92%AD%E6%94%BE%E6%A1%86%E6%9E%B6-1/12.png"></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Android-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">Android 源码分析</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/AOSP-源码/">AOSP 源码</a>
  </div>

</div>



<div class="comments-count">
	
	  	<span></span>
		<a href="/2016/07/31/Android-源码分析之基于Stagefright的MediaPlayer播放框架-1/#comments" class="ds-thread-count comments-count-link" data-thread-key="2016/07/31/Android-源码分析之基于Stagefright的MediaPlayer播放框架-1/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/07/31/Android-源码分析之基于Stagefright的MediaPlayer播放框架/" title="Android-源码分析之基于Stagefright的MediaPlayer播放框架[1]" itemprop="url">Android-源码分析之基于Stagefright的MediaPlayer播放框架[1]</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Edgar" target="_blank" itemprop="author">Edgar</a>
		
  <p class="article-time">
    <time datetime="2016-07-31T02:32:34.000Z" itemprop="datePublished"> Published 2016-07-31</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>再前一个博客中大家已经对整个播放框架有了一个整体的了解接下来的这篇博客将针对每个具体细节进行介绍：<br>再进行介绍之前我们看下使用MediaPlayer进行播放本地音频视频文件时的一般调用步骤，以及每个步骤所处理的任务：</p>
<h5 id="每个阶段的任务"><a href="#每个阶段的任务" class="headerlink" title="每个阶段的任务"></a>每个阶段的任务</h5><p>我们先来看下一个播放过程上层的调用情况：</p>
<ul>
<li><p>创建MediaPlayer对象<br>在这部分中主要完成如下任务：</p>
<ol>
<li>从JNI层获取应用层MediaPlayer相关域和方法的引用，这是由于MediaPlayer对象在上层创建会比在下层创建来得容易些。</li>
<li>创建EventHandler，用于处理底层播放引擎向应用层传递的事件。</li>
</ol>
</li>
<li><p>setDataSource() 创建播放引擎并为其设置数据源<br>在这部分中主要完成如下任务：</p>
<ol>
<li>根据本地音视频文件的mimetype对其进行匹配，选择适当的播放引擎并实例化</li>
<li>创建AudioOutput，将其设置到步骤1中创建的播放引擎，后续解码后的音频数据就可以通过它输出到硬件设备上。</li>
<li>实例化数据源FileSource。根据文件的Mimetype创建相应的Extractor，根据文件类型创建相应的数据容器，并将设置到播放引擎中作为解码器的输入数据来源</li>
</ol>
</li>
<li><p>setDisplay()</p>
<ol>
<li>在这部分中主要为视频设置渲染画板，视频流就是通过这个接口显示到显示屏上的。</li>
</ol>
</li>
<li><p>prepare()</p>
<ol>
<li>根据上面MediaExtractor从文件中抽取出的mimetype类型搜寻并加载匹配的解码器。</li>
<li>配置解码器设置解码器的监听器</li>
<li>设置解码器Buffer的尺寸大小数据</li>
</ol>
</li>
<li><p>start()</p>
<ol>
<li>创建AudioPlayer并设置对应的参数，从音视频文件的数据容器中读取数据，将数据传送给解码器进行解码，最后将解码后的数据返回给播放引擎</li>
<li>通过AudioPlayer向硬件输出音频数据。</li>
<li>创建视频Render来渲染解码好的视频数据</li>
</ol>
</li>
</ul>
<h5 id="MediaPlayer播放框架源代码解析："><a href="#MediaPlayer播放框架源代码解析：" class="headerlink" title="MediaPlayer播放框架源代码解析："></a>MediaPlayer播放框架源代码解析：</h5><h6 id="创建MediaPlayer对象"><a href="#创建MediaPlayer对象" class="headerlink" title="创建MediaPlayer对象"></a>创建MediaPlayer对象</h6><h6 id="建立底层MediaPlayer与Java层MediaPlayer事件传递的通道"><a href="#建立底层MediaPlayer与Java层MediaPlayer事件传递的通道" class="headerlink" title="建立底层MediaPlayer与Java层MediaPlayer事件传递的通道"></a>建立底层MediaPlayer与Java层MediaPlayer事件传递的通道</h6><p>在MediaPlayer加载后它会先执行如下代码，由于这个是静态代码块只有在类第一次加载的时候会被调用，因此在这个地方加载动态库libmedia_jni.so是最为合适的。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">static &#123;</span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>load<span class="constructor">Library(<span class="string">&quot;media_jni&quot;</span>)</span>;</span><br><span class="line">    native<span class="constructor">_init()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在native_init方法中获取一些属性的id为后续的初始化做准备，由于这些field id是比较常用的，所以在类加载的时候直接获取可以避免后续操作的时候每次都要获取降低了执行效率。</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">static void</span><br><span class="line">android_media_MediaPlayer_native_init(JNIEnv *env)</span><br><span class="line">&#123;</span><br><span class="line">    jclass clazz;</span><br><span class="line">    <span class="comment">//从上层获取Context</span></span><br><span class="line">    <span class="function"><span class="title">clazz</span> = env-&gt;</span>FindClass(<span class="string">&quot;android/media/MediaPlayer&quot;</span>);</span><br><span class="line">	<span class="function"><span class="title">fields</span>.context = env-&gt;</span>GetFieldID(clazz, <span class="string">&quot;mNativeContext&quot;</span>, <span class="string">&quot;J&quot;</span>);</span><br><span class="line">	<span class="comment">//在介绍native_setup的时候会介绍这个值域，用于将native层的事件传递到Java层</span></span><br><span class="line">    <span class="function"><span class="title">fields</span>.post_event = env-&gt;</span>GetStaticMethodID(clazz, <span class="string">&quot;postEventFromNative&quot;</span>,</span><br><span class="line">    <span class="string">&quot;(Ljava/lang/Object;IIILjava/lang/Object;)V&quot;</span>);</span><br><span class="line">    <span class="function"><span class="title">fields</span>.surface_texture = env-&gt;</span>GetFieldID(clazz, <span class="string">&quot;mNativeSurfaceTexture&quot;</span>, <span class="string">&quot;J&quot;</span>);</span><br><span class="line">    <span class="function"><span class="title">env</span>-&gt;</span>DeleteLocalRef(clazz);</span><br><span class="line">    <span class="function"><span class="title">clazz</span> = env-&gt;</span>FindClass(<span class="string">&quot;android/net/ProxyInfo&quot;</span>);</span><br><span class="line">    fields.proxyConfigGetHost =</span><br><span class="line">        <span class="function"><span class="title">env</span>-&gt;</span>GetMethodID(clazz, <span class="string">&quot;getHost&quot;</span>, <span class="string">&quot;()Ljava/lang/String;&quot;</span>);</span><br><span class="line">    fields.proxyConfigGetPort =</span><br><span class="line">        <span class="function"><span class="title">env</span>-&gt;</span>GetMethodID(clazz, <span class="string">&quot;getPort&quot;</span>, <span class="string">&quot;()I&quot;</span>);</span><br><span class="line">    fields.proxyConfigGetExclusionList =</span><br><span class="line">        <span class="function"><span class="title">env</span>-&gt;</span>GetMethodID(clazz, <span class="string">&quot;getExclusionListAsString&quot;</span>, <span class="string">&quot;()Ljava/lang/String;&quot;</span>);</span><br><span class="line">    <span class="function"><span class="title">env</span>-&gt;</span>DeleteLocalRef(clazz);</span><br><span class="line">    gPlaybackParamsFields.init(env);</span><br><span class="line">    gSyncParamsFields.init(env);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>紧接着我们就需要调用MediaPlayer类的构造方法创建MediaPlayer对象：<br>在这部分我们就来详细看下上层和native层是如何进行消息传递的：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public <span class="constructor">MediaPlayer()</span> &#123;</span><br><span class="line">    Looper looper;</span><br><span class="line">    <span class="comment">//创建了EventHandler用于处理从native层传递过来的消息</span></span><br><span class="line">    <span class="keyword">if</span> ((looper = <span class="module-access"><span class="module"><span class="identifier">Looper</span>.</span></span>my<span class="constructor">Looper()</span>) != null) &#123;</span><br><span class="line">        mEventHandler = <span class="keyword">new</span> <span class="constructor">EventHandler(<span class="params">this</span>, <span class="params">looper</span>)</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((looper = <span class="module-access"><span class="module"><span class="identifier">Looper</span>.</span></span>get<span class="constructor">MainLooper()</span>) != null) &#123;</span><br><span class="line">        mEventHandler = <span class="keyword">new</span> <span class="constructor">EventHandler(<span class="params">this</span>, <span class="params">looper</span>)</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mEventHandler = null;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line">    <span class="comment">//创建一个MediaPlayer的软引用传递给native_setup方法</span></span><br><span class="line">    native<span class="constructor">_setup(<span class="params">new</span> WeakReference&lt;MediaPlayer&gt;(<span class="params">this</span>)</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先这里创建了一个EventHandler，上面提到过这个Handler用于处理从native层传递过来的消息，然后调用native_setup</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">static void</span><br><span class="line">android<span class="constructor">_media_MediaPlayer_native_setup(JNIEnv <span class="operator">*</span><span class="params">env</span>, <span class="params">jobject</span> <span class="params">thiz</span>, <span class="params">jobject</span> <span class="params">weak_this</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    sp&lt;MediaPlayer&gt; mp = <span class="keyword">new</span> <span class="constructor">MediaPlayer()</span>;</span><br><span class="line">    <span class="comment">// 创建一个JNIMediaPlayerListener 并将其设置到上面new出来的MediaPlayer</span></span><br><span class="line">    <span class="comment">// JNIMediaPlayerListener 实际上是将native层的通知，通过调用Java层的postEventFromNative方法传递上去,这个工作是在frameworks/base/media/jni/android_media_MediaPlayer.cpp:JNIMediaPlayerListener::notify方法中完成的。这个方法中的fields.post_event正是在上面介绍的android_media_MediaPlayer_native_init中从Java层中获取到的</span></span><br><span class="line">    sp&lt;JNIMediaPlayerListener&gt; listener = <span class="keyword">new</span> <span class="constructor">JNIMediaPlayerListener(<span class="params">env</span>, <span class="params">thiz</span>, <span class="params">weak_this</span>)</span>;</span><br><span class="line">    <span class="comment">//将上述创建的JNIMediaPlayerListener赋给MediaPlayer本地类的mListener成员变量</span></span><br><span class="line">    mp-&gt;set<span class="constructor">Listener(<span class="params">listener</span>)</span>;</span><br><span class="line">    <span class="comment">// Stow our new C++ MediaPlayer in an opaque field in the Java object.</span></span><br><span class="line">    set<span class="constructor">MediaPlayer(<span class="params">env</span>, <span class="params">thiz</span>, <span class="params">mp</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在native_setup中我们创建一个上层的MediaPlayer对象以及JNIMediaPlayerListener对象，JNIMediaPlayerListener 实际上是将native层的通知通过调用Java层的postEventFromNative方法传递上去,这个工作是在frameworks&#x2F;base&#x2F;media&#x2F;jni&#x2F;android_media_MediaPlayer.cpp:JNIMediaPlayerListener::notify方法中完成的。这个方法中的fields.post_event正是在上面介绍的android_media_MediaPlayer_native_init中从Java层中获取到的。</p>
<p>下面是MediaPlayer native的构造方法，这里比较简单只是对一些成员变量的初始化。</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">MediaPlayer::MediaPlayer()</span><br><span class="line">&#123;</span><br><span class="line">    mListener = NULL;                       <span class="regexp">//</span>用于与Java层通信的Listener JNIMediaPlayerListener</span><br><span class="line">    mCookie = NULL;</span><br><span class="line">    mStreamType = AUDIO_STREAM_MUSIC;       <span class="regexp">//</span>Stream 类型</span><br><span class="line">    mAudioAttributesParcel = NULL;</span><br><span class="line">    mCurrentPosition = -<span class="number">1</span>;                      <span class="regexp">//</span>当前位置</span><br><span class="line">    mSeekPosition = -<span class="number">1</span>;                        <span class="regexp">//</span>Seek位置</span><br><span class="line">    mCurrentState = MEDIA_PLAYER_IDLE;     <span class="regexp">//</span>当前MediaPlayer的状态</span><br><span class="line">    mPrepareSync = false;                      <span class="regexp">//</span>是否同步Prepare</span><br><span class="line">    mPrepareStatus = NO_ERROR;               <span class="regexp">//</span>Prepare状态</span><br><span class="line">    mLoop = false;                            <span class="regexp">//</span>是否循环播放</span><br><span class="line">    mLeftVolume = mRightVolume = <span class="number">1.0</span>;          <span class="regexp">//</span>左右音量</span><br><span class="line">    mVideoWidth = mVideoHeight = <span class="number">0</span>;            <span class="regexp">//</span>视频的宽度和高度值</span><br><span class="line">    mLockThreadId = <span class="number">0</span>;                               </span><br><span class="line">    mAudioSessionId = AudioSystem::newAudioUniqueId();  <span class="regexp">//</span>AudioSession Id</span><br><span class="line">    AudioSystem::acquireAudioSessionId(mAudioSessionId, -<span class="number">1</span>); <span class="regexp">//</span>获取AudioSessionId</span><br><span class="line">    mSendLevel = <span class="number">0</span>;</span><br><span class="line">    mRetransmitEndpointValid = false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当native MediaPlayer创建后通过调用setMediaPlayer将创建的MediaPlayer native层对象赋给Java层的Context。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">static sp&lt;MediaPlayer&gt; set<span class="constructor">MediaPlayer(JNIEnv<span class="operator">*</span> <span class="params">env</span>, <span class="params">jobject</span> <span class="params">thiz</span>, <span class="params">const</span> <span class="params">sp</span>&lt;MediaPlayer&gt;&amp; <span class="params">player</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    sp&lt;MediaPlayer&gt; old = (MediaPlayer*)env-&gt;<span class="constructor">GetLongField(<span class="params">thiz</span>, <span class="params">fields</span>.<span class="params">context</span>)</span>;</span><br><span class="line">    <span class="keyword">if</span> (player.get<span class="literal">()</span>) &#123;</span><br><span class="line">        player-&gt;inc<span class="constructor">Strong((<span class="params">void</span><span class="operator">*</span>)</span>setMediaPlayer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (old != <span class="number">0</span>) &#123;</span><br><span class="line">        old-&gt;dec<span class="constructor">Strong((<span class="params">void</span><span class="operator">*</span>)</span>setMediaPlayer);</span><br><span class="line">    &#125;</span><br><span class="line">    env-&gt;<span class="constructor">SetLongField(<span class="params">thiz</span>, <span class="params">fields</span>.<span class="params">context</span>, (<span class="params">jlong</span>)</span>player.get<span class="literal">()</span>);</span><br><span class="line">    return old;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要了解native层是怎样将事件传递到上层就先要了解JNIMediaPlayerListener</p>
<p>JNIMediaPlayerListener是连接native层的MediaPlayer与Java层MediaPlayer的重要监听器。它通过JNI调用Java层的postEventFromNative方法将事件传递到Java层。最终传递给Java层MediaPlayer中的EventHandler进行处理。</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">class JNIMediaPlayerListener: public MediaPlayerListener&#123;</span><br><span class="line">public:</span><br><span class="line">    JNIMediaPlayerListener(JNIEnv* env, jobject thiz, jobject weak_thiz);</span><br><span class="line">    ~JNIMediaPlayerListener();</span><br><span class="line">    virtual void notify(int msg, int ext1, int ext2, const Parcel *obj = NULL);</span><br><span class="line">private:</span><br><span class="line">    JNIMediaPlayerListener();</span><br><span class="line">    jclass      mClass;     <span class="comment">// 指向native层 MediaPlayer的引用</span></span><br><span class="line">    jobject     mObject;   <span class="comment">// Java层MediaPlayer的弱引用</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">JNIMediaPlayerListener::JNIMediaPlayerListener(JNIEnv* env, jobject thiz, jobject weak_thiz)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="title">jclass</span> clazz = env-&gt;</span>GetObjectClass(thiz);</span><br><span class="line">    <span class="keyword">if</span> (clazz == NULL) &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;Can&#x27;t find android/media/MediaPlayer&quot;</span>);</span><br><span class="line">        jniThrowException(env, <span class="string">&quot;java/lang/Exception&quot;</span>, NULL);</span><br><span class="line">        return;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//初始化mClass和mObject  成员变量</span></span><br><span class="line">    <span class="function"><span class="title">mClass</span> = (jclass)env-&gt;</span>NewGlobalRef(clazz);</span><br><span class="line">    <span class="function"><span class="title">mObject</span>  = env-&gt;</span>NewGlobalRef(weak_thiz);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">JNIMediaPlayerListener::~JNIMediaPlayerListener()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//析构掉mClass和mObject  成员变量</span></span><br><span class="line">    JNIEnv *env = AndroidRuntime::getJNIEnv();</span><br><span class="line">    <span class="function"><span class="title">env</span>-&gt;</span>DeleteGlobalRef(mObject);</span><br><span class="line">    <span class="function"><span class="title">env</span>-&gt;</span>DeleteGlobalRef(mClass);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void JNIMediaPlayerListener::notify(int msg, int ext1, int ext2, const Parcel *obj)</span><br><span class="line">&#123;</span><br><span class="line">    JNIEnv *env = AndroidRuntime::getJNIEnv();</span><br><span class="line">    <span class="function"><span class="title">if</span> (obj &amp;&amp; obj-&gt;</span>dataSize() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//创建要传递的ParcelObject对象</span></span><br><span class="line">        jobject jParcel = createJavaParcelObject(env);</span><br><span class="line">        <span class="keyword">if</span> (jParcel != NULL) &#123;</span><br><span class="line">            Parcel* nativeParcel = parcelForJavaObject(env, jParcel);</span><br><span class="line">            <span class="comment">//设置要发送的数据</span></span><br><span class="line">            <span class="function"><span class="title">nativeParcel</span>-&gt;</span><span class="function"><span class="title">setData</span>(obj-&gt;</span><span class="function"><span class="title">data</span>(), obj-&gt;</span>dataSize());</span><br><span class="line">            <span class="comment">//调用Java层的postEventFromNative方法</span></span><br><span class="line">            <span class="function"><span class="title">env</span>-&gt;</span>CallStaticVoidMethod(mClass, fields.post_event, mObject,msg, ext1, ext2, jParcel);</span><br><span class="line">            <span class="function"><span class="title">env</span>-&gt;</span>DeleteLocalRef(jParcel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="function"><span class="title">env</span>-&gt;</span>CallStaticVoidMethod(mClass, fields.post_event, mObject,</span><br><span class="line">                msg, ext1, ext2, NULL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">if</span> (env-&gt;</span>ExceptionCheck()) &#123;</span><br><span class="line">        ALOGW(<span class="string">&quot;An exception occurred while notifying an event.&quot;</span>);</span><br><span class="line">        LOGW_EX(env);</span><br><span class="line">        <span class="function"><span class="title">env</span>-&gt;</span>ExceptionClear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>整个JNIMediaPlayerListener中最主要的就是notify方法，它将数据封装完后通过JNI接口调用Java层的postEventFromNative方法。</p>
<p>总结：<br>至此MediaPlayer初始化完成，Native层的MediaPlayer完成初始化后通过setMediaPlayer将其赋给Java层的mNativeContext，Java层的MediaPlayer在构造方法中调用native_setup将其引用设置到native层，并传递给JNIMediaPlayerListener。JNIMediaPlayerListener负责将native层的事件通知到Java层的MediaPlayer上。并交给EventHandler处理。整个结构大致如下：</p>
<p><img src="/2016/07/31/Android-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E5%9F%BA%E4%BA%8EStagefright%E7%9A%84MediaPlayer%E6%92%AD%E6%94%BE%E6%A1%86%E6%9E%B6/1.png"></p>
<p>整个调用过程如下：</p>
<p><img src="/2016/07/31/Android-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E5%9F%BA%E4%BA%8EStagefright%E7%9A%84MediaPlayer%E6%92%AD%E6%94%BE%E6%A1%86%E6%9E%B6/3.png"></p>
<p>为了避免整个博客的篇幅太长我将一个阶段对应一篇博客，下个博客将向大家介绍setDataSource–创建播放引擎，设置数据源，关于今天的这篇博客如果大家有什么疑问，或者发现有错误的地方欢迎大家留言或者发邮件告诉我。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Android-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">Android 源码分析</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/AOSP-源码/">AOSP 源码</a>
  </div>

</div>



<div class="comments-count">
	
	  	<span></span>
		<a href="/2016/07/31/Android-源码分析之基于Stagefright的MediaPlayer播放框架/#comments" class="ds-thread-count comments-count-link" data-thread-key="2016/07/31/Android-源码分析之基于Stagefright的MediaPlayer播放框架/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>







  <nav id="page-nav" class="clearfix">
    <a class="extend prev" rel="prev" href="/page/12/">&lt;span&gt;&lt;&#x2F;span&gt;Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="page-number" href="/page/12/">12</a><span class="page-number current">13</span><a class="page-number" href="/page/14/">14</a><a class="page-number" href="/page/15/">15</a><span class="space">&hellip;</span><a class="page-number" href="/page/30/">30</a><a class="extend next" rel="next" href="/page/14/">Next&lt;span&gt;&lt;&#x2F;span&gt;</a>
  </nav>

</div>
      <div class="openaside"><a class="navbutton" href="#" title="Show Sidebar"></a></div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="Hide Sidebar"></a></div>
<aside class="clearfix">
<div id="authorInfo">
	
		<div class="author-img"></div>		
	
	<div class="social-info" class="clearfix">
		
		
		<a href="https://github.com/tbfungeek" target="_blank" class="icon-github" title="github"></a>
		
		
		
		
		
		
		
		
		
		
		<a href="mailto:tbfungeek@163.com" target="_blank" class="icon-email" title="Email Me"></a>
		

	</div>
</div>

  
<div class="categorieslist">
	<p class="asidetitle">Categories</p>
		<ul>
		
		  
			<li><a href="/categories/Android-小经验/" title="Android 小经验">Android 小经验<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Android-源码分析/" title="Android 源码分析">Android 源码分析<sup>21</sup></a></li>
		  
		
		  
			<li><a href="/categories/Android其他/" title="Android其他">Android其他<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Android初步/" title="Android初步">Android初步<sup>21</sup></a></li>
		  
		
		  
			<li><a href="/categories/Android进阶/" title="Android进阶">Android进阶<sup>100</sup></a></li>
		  
		
		  
			<li><a href="/categories/Hexo-使用/" title="Hexo 使用">Hexo 使用<sup>10</sup></a></li>
		  
		
		  
			<li><a href="/categories/JavaScript理论/" title="JavaScript理论">JavaScript理论<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Objective-C-相关/" title="Objective C 相关">Objective C 相关<sup>24</sup></a></li>
		  
		
		  
			<li><a href="/categories/OpenCV/" title="OpenCV">OpenCV<sup>6</sup></a></li>
		  
		
		  
			<li><a href="/categories/ROS/" title="ROS">ROS<sup>9</sup></a></li>
		  
		
		  
			<li><a href="/categories/iOS-工具使用/" title="iOS 工具使用">iOS 工具使用<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/iOS-开源库分析/" title="iOS 开源库分析">iOS 开源库分析<sup>36</sup></a></li>
		  
		
		  
			<li><a href="/categories/iOS-理论基础/" title="iOS 理论基础">iOS 理论基础<sup>14</sup></a></li>
		  
		
		  
			<li><a href="/categories/iOS-进阶/" title="iOS 进阶">iOS 进阶<sup>4</sup></a></li>
		  
		
		  
			<li><a href="/categories/个人收藏/" title="个人收藏">个人收藏<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/代码规范/" title="代码规范">代码规范<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/其他/" title="其他">其他<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/博客分类目录/" title="博客分类目录">博客分类目录<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/叨叨系列/" title="叨叨系列">叨叨系列<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/开源代码分析/" title="开源代码分析">开源代码分析<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/开源库分析/" title="开源库分析">开源库分析<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/树莓派/" title="树莓派">树莓派<sup>4</sup></a></li>
		  
		
		  
			<li><a href="/categories/版本控制/" title="版本控制">版本控制<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/直播/" title="直播">直播<sup>6</sup></a></li>
		  
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">Tags</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/iOS-开源库分析/" title="iOS 开源库分析">iOS 开源库分析<sup>36</sup></a></li>
			
		
			
				<li><a href="/tags/Android-设计模式/" title="Android 设计模式">Android 设计模式<sup>29</sup></a></li>
			
		
			
				<li><a href="/tags/Objective-C-相关/" title="Objective C 相关">Objective C 相关<sup>24</sup></a></li>
			
		
			
				<li><a href="/tags/Android基础/" title="Android基础">Android基础<sup>21</sup></a></li>
			
		
			
				<li><a href="/tags/AOSP-源码/" title="AOSP 源码">AOSP 源码<sup>17</sup></a></li>
			
		
			
				<li><a href="/tags/Android-常用第三方库/" title="Android 常用第三方库">Android 常用第三方库<sup>15</sup></a></li>
			
		
			
				<li><a href="/tags/iOS-理论基础/" title="iOS 理论基础">iOS 理论基础<sup>14</sup></a></li>
			
		
			
				<li><a href="/tags/Hexo-使用/" title="Hexo 使用">Hexo 使用<sup>10</sup></a></li>
			
		
			
				<li><a href="/tags/ROS/" title="ROS">ROS<sup>9</sup></a></li>
			
		
			
				<li><a href="/tags/Android-动画进阶/" title="Android 动画进阶">Android 动画进阶<sup>8</sup></a></li>
			
		
			
				<li><a href="/tags/Android-JNI/" title="Android JNI">Android JNI<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/Android-绘图进阶/" title="Android 绘图进阶">Android 绘图进阶<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/Android性能优化/" title="Android性能优化">Android性能优化<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/Android-自动化测试/" title="Android 自动化测试">Android 自动化测试<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/OpenCV/" title="OpenCV">OpenCV<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/直播/" title="直播">直播<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/Android-开源源码/" title="Android 开源源码">Android 开源源码<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/Android-自定义View进阶/" title="Android 自定义View进阶">Android 自定义View进阶<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/树莓派/" title="树莓派">树莓派<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/iOS-进阶/" title="iOS 进阶">iOS 进阶<sup>4</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">Links</p>
    <ul>
        
          <li>
            
            	<a href="https://hexo.io" target="_blank" title="Hexo">Hexo</a>
            
          </li>
        
          <li>
            
            	<a href="https://pages.github.com/" target="_blank" title="GitHub">GitHub</a>
            
          </li>
        
          <li>
            
            	<a href="http://pf18.github.io/" target="_blank" title="PF18">PF18</a>
            
          </li>
        
          <li>
            
            	<a href="http://toutiao.io/" target="_blank" title="开发者头条">开发者头条</a>
            
          </li>
        
          <li>
            
            	<a href="http://www.jcodecraeer.com/" target="_blank" title="泡在网上的日子">泡在网上的日子</a>
            
          </li>
        
    </ul>
</div>

  


  <div class="rsspart">
	<a href="atom.xml" target="_blank" title="rss">RSS</a>
</div>

  
  <div class="tagcloudlist">
    <p class="asidetitle">Tag Cloud</p>
    <div class="tagcloudlist clearfix">
       <a href="/tags/AOSP-%E6%BA%90%E7%A0%81/" style="font-size: 17.14px;">AOSP 源码</a> <a href="/tags/Android-APK-%E7%AD%BE%E5%90%8D/" style="font-size: 10px;">Android APK 签名</a> <a href="/tags/Android-JNI/" style="font-size: 12.86px;">Android JNI</a> <a href="/tags/Android-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E8%BF%9B%E9%98%B6/" style="font-size: 10.71px;">Android 事件处理进阶</a> <a href="/tags/Android-%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6/" style="font-size: 13.57px;">Android 动画进阶</a> <a href="/tags/Android-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%80%E5%8F%91/" style="font-size: 10px;">Android 多线程开发</a> <a href="/tags/Android-%E5%B0%8F%E7%BB%8F%E9%AA%8C/" style="font-size: 10px;">Android 小经验</a> <a href="/tags/Android-%E5%B8%B8%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/" style="font-size: 16.43px;">Android 常用第三方库</a> <a href="/tags/Android-%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/" style="font-size: 10px;">Android 开发流程</a> <a href="/tags/Android-%E5%BC%80%E6%BA%90%E6%BA%90%E7%A0%81/" style="font-size: 12.14px;">Android 开源源码</a> <a href="/tags/Android-%E7%BB%98%E5%9B%BE%E8%BF%9B%E9%98%B6/" style="font-size: 12.86px;">Android 绘图进阶</a> <a href="/tags/Android-%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/" style="font-size: 12.86px;">Android 自动化测试</a> <a href="/tags/Android-%E8%87%AA%E5%AE%9A%E4%B9%89View%E8%BF%9B%E9%98%B6/" style="font-size: 12.14px;">Android 自定义View进阶</a> <a href="/tags/Android-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 19.29px;">Android 设计模式</a> <a href="/tags/Android%E5%85%B6%E4%BB%96/" style="font-size: 10px;">Android其他</a> <a href="/tags/Android%E5%9F%BA%E7%A1%80/" style="font-size: 17.86px;">Android基础</a> <a href="/tags/Android%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/" style="font-size: 10px;">Android开发流程</a> <a href="/tags/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" style="font-size: 12.86px;">Android性能优化</a> <a href="/tags/Android%E6%B7%B7%E6%B7%86%E6%8A%80%E6%9C%AF/" style="font-size: 10px;">Android混淆技术</a> <a href="/tags/Android%E8%B4%A8%E9%87%8F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/" style="font-size: 11.43px;">Android质量管理工具</a> <a href="/tags/Android%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/" style="font-size: 10px;">Android逆向工程</a> <a href="/tags/Git-github/" style="font-size: 10px;">Git && github</a> <a href="/tags/Hexo-%E4%BD%BF%E7%94%A8/" style="font-size: 15px;">Hexo 使用</a> <a href="/tags/JavaScript/" style="font-size: 10px;">JavaScript</a> <a href="/tags/Linux-%E4%BD%BF%E7%94%A8/" style="font-size: 10px;">Linux 使用</a> <a href="/tags/Objective-C-%E7%9B%B8%E5%85%B3/" style="font-size: 18.57px;">Objective C 相关</a> <a href="/tags/OpenCV/" style="font-size: 12.86px;">OpenCV</a> <a href="/tags/ROS/" style="font-size: 14.29px;">ROS</a> <a href="/tags/iOS-%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/" style="font-size: 10.71px;">iOS 工具使用</a> <a href="/tags/iOS-%E5%BC%80%E6%BA%90%E5%BA%93%E5%88%86%E6%9E%90/" style="font-size: 20px;">iOS 开源库分析</a> <a href="/tags/iOS-%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/" style="font-size: 15.71px;">iOS 理论基础</a> <a href="/tags/iOS-%E8%BF%9B%E9%98%B6/" style="font-size: 12.14px;">iOS 进阶</a> <a href="/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/" style="font-size: 10px;">代码规范</a> <a href="/tags/%E5%8D%9A%E5%AE%A2%E5%88%86%E7%B1%BB%E7%9B%AE%E5%BD%95/" style="font-size: 10.71px;">博客分类目录</a> <a href="/tags/%E5%8F%A8%E5%8F%A8%E7%B3%BB%E5%88%97/" style="font-size: 10px;">叨叨系列</a> <a href="/tags/%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/" style="font-size: 11.43px;">工具的使用</a> <a href="/tags/%E5%BC%80%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/" style="font-size: 10.71px;">开源代码分析</a> <a href="/tags/%E5%BC%80%E6%BA%90%E5%BA%93%E5%88%86%E6%9E%90/" style="font-size: 10px;">开源库分析</a> <a href="/tags/%E6%9D%82%E7%B1%BB/" style="font-size: 10px;">杂类</a> <a href="/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/" style="font-size: 12.14px;">树莓派</a> <a href="/tags/%E7%9B%B4%E6%92%AD/" style="font-size: 12.86px;">直播</a> <a href="/tags/%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/" style="font-size: 10.71px;">编程技巧</a> <a href="/tags/%E7%BD%91%E7%AB%99%E6%94%B6%E8%97%8F/" style="font-size: 10px;">网站收藏</a> <a href="/tags/%E9%87%8D%E8%A6%81%E6%8E%A7%E4%BB%B6/" style="font-size: 11.43px;">重要控件</a>
    </div>
  </div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
		
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/hsihohuang/kiddochan" target="_blank" title="Kiddochan">Kiddochan</a> © 2022 
		
		<a href="/about" target="_blank" title="Edgar">Edgar</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
        
    }
  });
});
</script>










<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?7c9443b0374f1cf6b1dbb5ab84d939cb";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="Back to Top"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
 </html>
