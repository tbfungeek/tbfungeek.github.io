
 <!DOCTYPE HTML>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
  
    <title>Edgar&#39;s Blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="Edgar">
    

    
    <meta name="description" content="Android | 全栈工程师">
<meta property="og:type" content="website">
<meta property="og:title" content="Edgar&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/page/4/index.html">
<meta property="og:site_name" content="Edgar&#39;s Blog">
<meta property="og:description" content="Android | 全栈工程师">
<meta property="og:locale">
<meta property="article:author" content="Edgar">
<meta name="twitter:card" content="summary">

    
    <link rel="alternative" href="atom.xml" title="Edgar&#39;s Blog" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/unnamed4_n_mSY_icon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/profile.png">
    <link rel="apple-touch-icon-precomposed" href="/img/profile.png">
    
    
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 6.2.0"></head>

  <body>
    <header>
      
<div>
		
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="Edgar&#39;s Blog">Edgar&#39;s Blog</a></h1>
				<h2 class="blog-motto"></h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="Menu">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
					<li>
 					
					<form class="search" action="/search/index.html" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" autocomplete="off" name="q" maxlength="20" placeholder="Search" />
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main">

   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/11/30/SDWebImage-源码解析/" title="SDWebImage 源码解析" itemprop="url">SDWebImage 源码解析</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Edgar" target="_blank" itemprop="author">Edgar</a>
		
  <p class="article-time">
    <time datetime="2019-11-29T18:09:33.000Z" itemprop="datePublished"> Published 2019-11-30</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h5 id="1-开源代码信息"><a href="#1-开源代码信息" class="headerlink" title="1. 开源代码信息"></a>1. 开源代码信息</h5><p><img src="/2019/11/30/SDWebImage-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/00001.png"></p>
<p><a target="_blank" rel="noopener" href="https://github.com/SDWebImage/SDWebImage">SDWebImage Github 库</a><br><a target="_blank" rel="noopener" href="https://github.com/SDWebImage">SDWebImage Main Repo</a><br><a target="_blank" rel="noopener" href="https://github.com/SDWebImage/SDWebImage/wiki/Coder-Plugin-List">SDWebImage 图片Coder插件列表</a></p>
<p>想必每个接触过iOS开发的开发者都接触过<strong><strong>SDWebImage</strong></strong>吧，它是一个带有缓存支持的异步图片下载工具。我们常用的<strong><strong>UIImageView</strong></strong>, *<strong><strong>UIButton</strong></strong>, <strong><strong>MKAnnotationView</strong></strong>，这些UI元素都有它为我们提供的专门分类用于异步图片的加载。</p>
<p><strong><strong>特性</strong></strong></p>
<ul>
<li>为UIImageView, UIButton, MKAnnotationView这些类提供了用于图片加载以及缓存管理的分类。</li>
<li>带有一个异步的图片下载器以及一个缓存过期自动处理的异步内存图片缓存管理。</li>
<li>支持后台图片解压</li>
<li>支持渐进式图片加载功能</li>
<li>可扩展的图像编码器以支持大图片格式，例如WebP</li>
<li>动画图像的全栈解决方案能够做到在CPU和内存之间保持性能平衡</li>
<li>能够支持对下载后图片进行自定义且可组合的转换</li>
<li>可定制的多缓存系统</li>
<li>支持图片加载指示器</li>
<li>支持图片加载过渡动画</li>
<li>同一个URL不会下载多次，虚假的URL不会一直重试</li>
<li>保证主线程不会被阻塞</li>
<li>支持Objective-C 以及 Swift</li>
<li>高性能</li>
<li>支持JPEG, PNG, HEIC图片格式，包含GIF&#x2F;APNG&#x2F;HEIC动画格式</li>
<li>支持WebP，以及动画WebP格式</li>
<li>支持可扩张的图片编码器插件，可以通过它来添加更多新的格式。</li>
</ul>
<h5 id="2-源码解析"><a href="#2-源码解析" class="headerlink" title="2. 源码解析"></a>2. 源码解析</h5><h6 id="2-1-总入口"><a href="#2-1-总入口" class="headerlink" title="2.1 总入口"></a>2.1 总入口</h6><p>我们先来看下给UIImageView设置网络图片的流程的代码，这是我们最常用的一个功能，这部分代码位于：<br><strong><strong>UIView+WebCache.h</strong></strong>其他部分涉及到图片加载的最终都是调用这个方法：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)sd_internalSetImageWithURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url</span><br><span class="line">                  placeholderImage:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)placeholder</span><br><span class="line">                           options:(SDWebImageOptions)options</span><br><span class="line">                           context:(<span class="keyword">nullable</span> SDWebImageContext *)context</span><br><span class="line">                     setImageBlock:(<span class="keyword">nullable</span> SDSetImageBlock)setImageBlock</span><br><span class="line">                          progress:(<span class="keyword">nullable</span> SDImageLoaderProgressBlock)progressBlock</span><br><span class="line">                         completed:(<span class="keyword">nullable</span> SDInternalCompletionBlock)completedBlock &#123;</span><br><span class="line">    </span><br><span class="line">    context = [context <span class="keyword">copy</span>]; <span class="comment">// copy to avoid mutable object</span></span><br><span class="line">    <span class="built_in">NSString</span> *validOperationKey = context[SDWebImageContextSetImageOperationKey];</span><br><span class="line">    <span class="keyword">if</span> (!validOperationKey) &#123;</span><br><span class="line">        validOperationKey = <span class="built_in">NSStringFromClass</span>([<span class="keyword">self</span> <span class="keyword">class</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">self</span>.sd_latestOperationKey = validOperationKey;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//取消当前运行的同样请求</span></span><br><span class="line">    [<span class="keyword">self</span> sd_cancelImageLoadOperationWithKey:validOperationKey];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置本次加载的URL</span></span><br><span class="line">    <span class="keyword">self</span>.sd_imageURL = url;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//立刻设置占位图</span></span><br><span class="line">    <span class="keyword">if</span> (!(options &amp; SDWebImageDelayPlaceholder)) &#123;</span><br><span class="line">        dispatch_main_async_safe(^&#123;</span><br><span class="line">            <span class="comment">//设置占位图</span></span><br><span class="line">            [<span class="keyword">self</span> sd_setImage:placeholder imageData:<span class="literal">nil</span> basedOnClassOrViaCustomSetImageBlock:setImageBlock cacheType:SDImageCacheTypeNone imageURL:url];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (url) &#123;</span><br><span class="line">        <span class="comment">// 重置进度状态</span></span><br><span class="line">        <span class="built_in">NSProgress</span> *imageProgress = objc_getAssociatedObject(<span class="keyword">self</span>, <span class="keyword">@selector</span>(sd_imageProgress));</span><br><span class="line">        <span class="keyword">if</span> (imageProgress) &#123;</span><br><span class="line">            imageProgress.totalUnitCount = <span class="number">0</span>;</span><br><span class="line">            imageProgress.completedUnitCount = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 开始图片加载指示器</span></span><br><span class="line">        [<span class="keyword">self</span> sd_startImageIndicator];</span><br><span class="line">        <span class="comment">// 图片指示器</span></span><br><span class="line">        <span class="type">id</span>&lt;SDWebImageIndicator&gt; imageIndicator = <span class="keyword">self</span>.sd_imageIndicator;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//图片管理器</span></span><br><span class="line">        SDWebImageManager *manager = context[SDWebImageContextCustomManager];</span><br><span class="line">        <span class="keyword">if</span> (!manager) &#123;</span><br><span class="line">            manager = [SDWebImageManager sharedManager];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//更新进度</span></span><br><span class="line">        SDImageLoaderProgressBlock combinedProgressBlock = ^(<span class="built_in">NSInteger</span> receivedSize, <span class="built_in">NSInteger</span> expectedSize, <span class="built_in">NSURL</span> * _Nullable targetURL) &#123;</span><br><span class="line">            <span class="keyword">if</span> (imageProgress) &#123;</span><br><span class="line">                imageProgress.totalUnitCount = expectedSize;</span><br><span class="line">                imageProgress.completedUnitCount = receivedSize;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ([imageIndicator respondsToSelector:<span class="keyword">@selector</span>(updateIndicatorProgress:)]) &#123;</span><br><span class="line">                <span class="type">double</span> progress = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (expectedSize != <span class="number">0</span>) &#123;</span><br><span class="line">                    progress = (<span class="type">double</span>)receivedSize / expectedSize;</span><br><span class="line">                &#125;</span><br><span class="line">                progress = MAX(MIN(progress, <span class="number">1</span>), <span class="number">0</span>); <span class="comment">// 0.0 - 1.0</span></span><br><span class="line">                <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                    [imageIndicator updateIndicatorProgress:progress];</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (progressBlock) &#123;</span><br><span class="line">                progressBlock(receivedSize, expectedSize, targetURL);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//加载图片</span></span><br><span class="line">        @weakify(<span class="keyword">self</span>);</span><br><span class="line">        <span class="type">id</span> &lt;SDWebImageOperation&gt; operation = [manager loadImageWithURL:url</span><br><span class="line">                                                               options:options</span><br><span class="line">                                                               context:context</span><br><span class="line">                                                              progress:combinedProgressBlock</span><br><span class="line">                                                             completed:^(<span class="built_in">UIImage</span> *image, <span class="built_in">NSData</span> *data, <span class="built_in">NSError</span> *error, SDImageCacheType cacheType, <span class="type">BOOL</span> finished, <span class="built_in">NSURL</span> *imageURL) &#123;</span><br><span class="line">            @strongify(<span class="keyword">self</span>);</span><br><span class="line">            <span class="keyword">if</span> (!<span class="keyword">self</span>) &#123; <span class="keyword">return</span>; &#125;</span><br><span class="line">            <span class="comment">// if the progress not been updated, mark it to complete state</span></span><br><span class="line">            <span class="keyword">if</span> (imageProgress &amp;&amp; finished &amp;&amp; !error &amp;&amp; imageProgress.totalUnitCount == <span class="number">0</span> &amp;&amp; imageProgress.completedUnitCount == <span class="number">0</span>) &#123;</span><br><span class="line">                imageProgress.totalUnitCount = SDWebImageProgressUnitCountUnknown;</span><br><span class="line">                imageProgress.completedUnitCount = SDWebImageProgressUnitCountUnknown;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 加载结束后停止图片指示器</span></span><br><span class="line">            <span class="keyword">if</span> (finished) &#123;</span><br><span class="line">                [<span class="keyword">self</span> sd_stopImageIndicator];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 是否自动调用complete Block</span></span><br><span class="line">            <span class="type">BOOL</span> shouldCallCompletedBlock = finished || (options &amp; SDWebImageAvoidAutoSetImage);</span><br><span class="line">            <span class="comment">// 是否不设置Image</span></span><br><span class="line">            <span class="type">BOOL</span> shouldNotSetImage = ((image &amp;&amp; (options &amp; SDWebImageAvoidAutoSetImage)) ||</span><br><span class="line">                                      (!image &amp;&amp; !(options &amp; SDWebImageDelayPlaceholder)));</span><br><span class="line">            </span><br><span class="line">            SDWebImageNoParamsBlock callCompletedBlockClojure = ^&#123;</span><br><span class="line">                <span class="keyword">if</span> (!<span class="keyword">self</span>) &#123; <span class="keyword">return</span>; &#125;</span><br><span class="line">                <span class="keyword">if</span> (!shouldNotSetImage) &#123;</span><br><span class="line">                    [<span class="keyword">self</span> sd_setNeedsLayout];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 是否调用completeBlock</span></span><br><span class="line">                <span class="keyword">if</span> (completedBlock &amp;&amp; shouldCallCompletedBlock) &#123;</span><br><span class="line">                    completedBlock(image, data, error, cacheType, finished, url);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 到这里有两种可能，一种是我们获得到了图片，但是SDWebImageAvoidAutoSetImage = 1 或者 我们没拿到图片，并且SDWebImageDelayPlaceholder = 0</span></span><br><span class="line">            <span class="keyword">if</span> (shouldNotSetImage) &#123;</span><br><span class="line">                dispatch_main_async_safe(callCompletedBlockClojure);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">UIImage</span> *targetImage = <span class="literal">nil</span>;</span><br><span class="line">            <span class="built_in">NSData</span> *targetData = <span class="literal">nil</span>;</span><br><span class="line">            <span class="keyword">if</span> (image) &#123;</span><br><span class="line">                <span class="comment">// 获得到额了图片，SDWebImageAvoidAutoSetImage = 0，这是正常流程。</span></span><br><span class="line">                targetImage = image;</span><br><span class="line">                targetData = data;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (options &amp; SDWebImageDelayPlaceholder) &#123;</span><br><span class="line">                <span class="comment">// 没得到图片，但是设置了SDWebImageDelayPlaceholder</span></span><br><span class="line">                targetImage = placeholder;</span><br><span class="line">                targetData = <span class="literal">nil</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 检查是否使用图片transition</span></span><br><span class="line">            SDWebImageTransition *transition = <span class="literal">nil</span>;</span><br><span class="line">            <span class="keyword">if</span> (finished &amp;&amp; (options &amp; SDWebImageForceTransition || cacheType == SDImageCacheTypeNone)) &#123;</span><br><span class="line">                transition = <span class="keyword">self</span>.sd_imageTransition;</span><br><span class="line">            &#125;</span><br><span class="line">            dispatch_main_async_safe(^&#123;</span><br><span class="line">                [<span class="keyword">self</span> sd_setImage:targetImage</span><br><span class="line">                        imageData:targetData</span><br><span class="line">basedOnClassOrViaCustomSetImageBlock:setImageBlock</span><br><span class="line">                       transition:transition</span><br><span class="line">                        cacheType:cacheType</span><br><span class="line">                         imageURL:imageURL];</span><br><span class="line">                callCompletedBlockClojure();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;];</span><br><span class="line">        <span class="comment">//设置当前的operation</span></span><br><span class="line">        [<span class="keyword">self</span> sd_setImageLoadOperation:operation forKey:validOperationKey];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果url为空则停止加载指示器，并抛出异常。</span></span><br><span class="line">        [<span class="keyword">self</span> sd_stopImageIndicator];</span><br><span class="line">        dispatch_main_async_safe(^&#123;</span><br><span class="line">            <span class="keyword">if</span> (completedBlock) &#123;</span><br><span class="line">                <span class="built_in">NSError</span> *error = [<span class="built_in">NSError</span> errorWithDomain:SDWebImageErrorDomain code:SDWebImageErrorInvalidURL userInfo:@&#123;<span class="built_in">NSLocalizedDescriptionKey</span> : <span class="string">@&quot;Image url is nil&quot;</span>&#125;];</span><br><span class="line">                completedBlock(<span class="literal">nil</span>, <span class="literal">nil</span>, error, SDImageCacheTypeNone, <span class="literal">YES</span>, url);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法主要完成了三大块任务：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1.</span> 图片指示器控制</span><br><span class="line"><span class="bullet">2.</span> 通过图片加载器加载图片</span><br><span class="line"><span class="bullet">3.</span> 下载完成后给控件设置图片</span><br></pre></td></tr></table></figure>

<p>其他包括缓存，后期图片转换的都在第二部分中处理。这里有些需要注意的细节简单过一下，都是一些option：</p>
<p><strong><strong>SDWebImageDelayPlaceholder</strong></strong> :<br>是否延迟加载占位图，默认一旦开始加载就会显示占位图，如果设置成延迟占位图，那么只有在图片没下载成功的时候设置。<br><strong><strong>SDWebImageContextCustomManager</strong></strong>:<br>可以外部注入图片管理器，负责图片的缓存控制和图片的下载。默认是没有注入的。<br><strong><strong>SDWebImageAvoidAutoSetImage</strong></strong>：<br>图片下载成功后是否不自动设置图片</p>
<h6 id="2-2-图片加载"><a href="#2-2-图片加载" class="headerlink" title="2.2 图片加载"></a>2.2 图片加载</h6><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (SDWebImageCombinedOperation *)loadImageWithURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url</span><br><span class="line">                                          options:(SDWebImageOptions)options</span><br><span class="line">                                          context:(<span class="keyword">nullable</span> SDWebImageContext *)context</span><br><span class="line">                                         progress:(<span class="keyword">nullable</span> SDImageLoaderProgressBlock)progressBlock</span><br><span class="line">                                        completed:(<span class="keyword">nonnull</span> SDInternalCompletionBlock)completedBlock &#123;</span><br><span class="line">    <span class="comment">// Invoking this method without a completedBlock is pointless</span></span><br><span class="line">    <span class="built_in">NSAssert</span>(completedBlock != <span class="literal">nil</span>, <span class="string">@&quot;If you mean to prefetch the image, use -[SDWebImagePrefetcher prefetchURLs] instead&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果传入的URL是字符串则将其转换为NSURL</span></span><br><span class="line">    <span class="keyword">if</span> ([url isKindOfClass:<span class="built_in">NSString</span>.class]) &#123;</span><br><span class="line">        url = [<span class="built_in">NSURL</span> URLWithString:(<span class="built_in">NSString</span> *)url];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果不是NSURL则设置url为空，避免崩溃</span></span><br><span class="line">    <span class="keyword">if</span> (![url isKindOfClass:<span class="built_in">NSURL</span>.class]) &#123;</span><br><span class="line">        url = <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SDWebImageCombinedOperation *operation = [SDWebImageCombinedOperation new];</span><br><span class="line">    operation.manager = <span class="keyword">self</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否是失败的URL</span></span><br><span class="line">    <span class="type">BOOL</span> isFailedUrl = <span class="literal">NO</span>;</span><br><span class="line">    <span class="keyword">if</span> (url) &#123;</span><br><span class="line">        SD_LOCK(<span class="keyword">self</span>.failedURLsLock);</span><br><span class="line">        isFailedUrl = [<span class="keyword">self</span>.failedURLs containsObject:url];</span><br><span class="line">        SD_UNLOCK(<span class="keyword">self</span>.failedURLsLock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果地址为空，或者是失败的url则取消请求</span></span><br><span class="line">    <span class="keyword">if</span> (url.absoluteString.length == <span class="number">0</span> || (!(options &amp; SDWebImageRetryFailed) &amp;&amp; isFailedUrl)) &#123;</span><br><span class="line">        [<span class="keyword">self</span> callCompletionBlockForOperation:operation completion:completedBlock error:[<span class="built_in">NSError</span> errorWithDomain:SDWebImageErrorDomain code:SDWebImageErrorInvalidURL userInfo:@&#123;<span class="built_in">NSLocalizedDescriptionKey</span> : <span class="string">@&quot;Image url is nil&quot;</span>&#125;] url:url];</span><br><span class="line">        <span class="keyword">return</span> operation;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将当前的operation添加到self.runningOperations 中表示该请求已经发起</span></span><br><span class="line">    SD_LOCK(<span class="keyword">self</span>.runningOperationsLock);</span><br><span class="line">    [<span class="keyword">self</span>.runningOperations addObject:operation];</span><br><span class="line">    SD_UNLOCK(<span class="keyword">self</span>.runningOperationsLock);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对options和context参数进行预先处理，这些会影响manager加载的最后处理结果</span></span><br><span class="line">    SDWebImageOptionsResult *result = [<span class="keyword">self</span> processedResultForURL:url options:options context:context];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 启动图片加载</span></span><br><span class="line">    [<span class="keyword">self</span> callCacheProcessForOperation:operation url:url options:result.options context:result.context progress:progressBlock completed:completedBlock];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> operation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在图片加载开始的时候会先对传入的url类型进行判断，这里的url可能会有两种类型一种是NSString,一种是NSURL这个阶段会分别对它做一个判断，并最终转换为NSURL,然后判断当前的url是否在failedURLs中，如果在的话会根据<strong><strong>SDWebImageRetryFailed</strong></strong>的配置来进行选择接下来的处理，如果SDWebImageRetryFailed &#x3D; 0的话 就表示不对失败的url进行重新尝试，所以这种情况会取消请求，failedURLs会在每次加载失败的时候添加。</p>
<p>紧接着会调用<strong><strong>processedResultForURL</strong></strong>对options和context参数进行预先处理，这些会影响manager加载的最后处理结果：</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">- (SDWebImageOptionsResult *)processedResultForURL:(NSURL *)url <span class="keyword">options</span>:(SDWebImageOptions)<span class="keyword">options</span> context:(SDWebImageContext *)context &#123;</span><br><span class="line">    SDWebImageOptionsResult *result;</span><br><span class="line">    SDWebImageMutableContext *mutableContext = [SDWebImageMutableContext dictionary];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 用于对下载后的图片进行转换后存储到缓存中</span></span><br><span class="line">    <span class="keyword">if</span> (!context[SDWebImageContextImageTransformer]) &#123;</span><br><span class="line">        id&lt;SDImageTransformer&gt; transformer = self.transformer;</span><br><span class="line">        [mutableContext setValue:transformer forKey:SDWebImageContextImageTransformer];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 用于将URL转换为它对应的缓存key的组件</span></span><br><span class="line">    <span class="keyword">if</span> (!context[SDWebImageContextCacheKeyFilter]) &#123;</span><br><span class="line">        id&lt;SDWebImageCacheKeyFilter&gt; cacheKeyFilter = self.cacheKeyFilter;</span><br><span class="line">        [mutableContext setValue:cacheKeyFilter forKey:SDWebImageContextCacheKeyFilter];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 用于将图片缓存到disk缓存中</span></span><br><span class="line">    <span class="keyword">if</span> (!context[SDWebImageContextCacheSerializer]) &#123;</span><br><span class="line">        id&lt;SDWebImageCacheSerializer&gt; cacheSerializer = self.cacheSerializer;</span><br><span class="line">        [mutableContext setValue:cacheSerializer forKey:SDWebImageContextCacheSerializer];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (mutableContext.<span class="keyword">count</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (context) &#123;</span><br><span class="line">            [mutableContext addEntriesFromDictionary:context];</span><br><span class="line">        &#125;</span><br><span class="line">        context = [mutableContext <span class="keyword">copy</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对当前的options 以及 context 进行进一步处理</span></span><br><span class="line">    <span class="keyword">if</span> (self.optionsProcessor) &#123;</span><br><span class="line">        result = [self.optionsProcessor processedResultForURL:url <span class="keyword">options</span>:<span class="keyword">options</span> context:context];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">        <span class="comment">// 创建默认的SDWebImageOptionsResult</span></span><br><span class="line">        result = [[SDWebImageOptionsResult alloc] initWithOptions:<span class="keyword">options</span> context:context];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它实际上是在context中加入了<strong><strong>SDImageTransformer</strong></strong>，<strong><strong>SDWebImageContextCacheKeyFilter</strong></strong>，以及<strong><strong>SDWebImageContextCacheSerializer</strong></strong>，然后通过<strong><strong>optionsProcessor</strong></strong> 对当前对options 以及 context进行统一处理后返回，这些组件会在加载过程中被提取出来使用。</p>
<h6 id="2-2-1-查询缓存还是从网络下载"><a href="#2-2-1-查询缓存还是从网络下载" class="headerlink" title="2.2.1 查询缓存还是从网络下载"></a>2.2.1 查询缓存还是从网络下载</h6><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)callCacheProcessForOperation:(<span class="keyword">nonnull</span> SDWebImageCombinedOperation *)operation</span><br><span class="line">                                 url:(<span class="keyword">nonnull</span> <span class="built_in">NSURL</span> *)url</span><br><span class="line">                             options:(SDWebImageOptions)options</span><br><span class="line">                             context:(<span class="keyword">nullable</span> SDWebImageContext *)context</span><br><span class="line">                            progress:(<span class="keyword">nullable</span> SDImageLoaderProgressBlock)progressBlock</span><br><span class="line">                           completed:(<span class="keyword">nullable</span> SDInternalCompletionBlock)completedBlock &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查当前是否需要查询缓存内的图片</span></span><br><span class="line">    <span class="type">BOOL</span> shouldQueryCache = !SD_OPTIONS_CONTAINS(options, SDWebImageFromLoaderOnly);</span><br><span class="line">    <span class="keyword">if</span> (shouldQueryCache) &#123;</span><br><span class="line">        <span class="comment">//通过url转缓存key的组件，将url转换为对应的缓存key</span></span><br><span class="line">        <span class="type">id</span>&lt;SDWebImageCacheKeyFilter&gt; cacheKeyFilter = context[SDWebImageContextCacheKeyFilter];</span><br><span class="line">        <span class="built_in">NSString</span> *key = [<span class="keyword">self</span> cacheKeyForURL:url cacheKeyFilter:cacheKeyFilter];</span><br><span class="line">        @weakify(operation);</span><br><span class="line">        <span class="comment">//异步查询，缓存中与当前url对应key的缓存</span></span><br><span class="line">        operation.cacheOperation = [<span class="keyword">self</span>.imageCache queryImageForKey:key options:options context:context completion:^(<span class="built_in">UIImage</span> * _Nullable cachedImage, <span class="built_in">NSData</span> * _Nullable cachedData, SDImageCacheType cacheType) &#123;</span><br><span class="line">            @strongify(operation);</span><br><span class="line">            <span class="comment">//用户取消查找</span></span><br><span class="line">            <span class="keyword">if</span> (!operation || operation.isCancelled) &#123;</span><br><span class="line">                <span class="comment">// Image combined operation cancelled by user</span></span><br><span class="line">                [<span class="keyword">self</span> callCompletionBlockForOperation:operation completion:completedBlock error:[<span class="built_in">NSError</span> errorWithDomain:SDWebImageErrorDomain code:SDWebImageErrorCancelled userInfo:<span class="literal">nil</span>] url:url];</span><br><span class="line">                [<span class="keyword">self</span> safelyRemoveOperationFromRunning:operation];</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 继续开始下载</span></span><br><span class="line">            [<span class="keyword">self</span> callDownloadProcessForOperation:operation url:url options:options context:context cachedImage:cachedImage cachedData:cachedData cacheType:cacheType progress:progressBlock completed:completedBlock];</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 继续开始下载</span></span><br><span class="line">        [<span class="keyword">self</span> callDownloadProcessForOperation:operation url:url options:options context:context cachedImage:<span class="literal">nil</span> cachedData:<span class="literal">nil</span> cacheType:SDImageCacheTypeNone progress:progressBlock completed:completedBlock];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在将下载过程需要的重要组件放置到options和context中后就开始加载图片，这里无外乎两种方式一种是从网络上下载资源，一种是使用本地资源，具体使用哪一种，在加载之前会先根据用户的设置，判断是否只使用缓存的图片，这取决于<strong><strong>SDWebImageFromLoaderOnly</strong></strong>，如果SDWebImageFromLoaderOnly &#x3D; 1 会先将URL转换为缓存的key，再使用这个key调用<strong><strong>self.imageCache queryImageForKey</strong></strong>，异步查询是否有对应的缓存。，如果SDWebImageFromLoaderOnly &#x3D; 0 则会通过callDownloadProcessForOperation从网络上下载资源。我们接下来分别看下这两个分支的代码：</p>
<h6 id="2-2-1-1-使用缓存资源"><a href="#2-2-1-1-使用缓存资源" class="headerlink" title="2.2.1.1 使用缓存资源"></a>2.2.1.1 使用缓存资源</h6><figure class="highlight erlang"><table><tr><td class="code"><pre><span class="line">- <span class="params">(id&lt;SDWebImageOperation&gt;)</span>queryImageForKey:<span class="params">(NSString *)</span>key options:<span class="params">(SDWebImageOptions)</span>options context:<span class="params">(nullable SDWebImageContext *)</span>context completion:<span class="params">(nullable SDImageCacheQueryCompletionBlock)</span>completionBlock &#123;</span><br><span class="line">    //将配置从options搬到cacheOptions</span><br><span class="line">    SDImageCacheOptions cacheOptions = 0;</span><br><span class="line">    if <span class="params">(options &amp; SDWebImageQueryMemoryData)</span> cacheOptions |= SDImageCacheQueryMemoryData;</span><br><span class="line">    if <span class="params">(options &amp; SDWebImageQueryMemoryDataSync)</span> cacheOptions |= SDImageCacheQueryMemoryDataSync;</span><br><span class="line">    if <span class="params">(options &amp; SDWebImageQueryDiskDataSync)</span> cacheOptions |= SDImageCacheQueryDiskDataSync;</span><br><span class="line">    if <span class="params">(options &amp; SDWebImageScaleDownLargeImages)</span> cacheOptions |= SDImageCacheScaleDownLargeImages;</span><br><span class="line">    if <span class="params">(options &amp; SDWebImageAvoidDecodeImage)</span> cacheOptions |= SDImageCacheAvoidDecodeImage;</span><br><span class="line">    if <span class="params">(options &amp; SDWebImageDecodeFirstFrameOnly)</span> cacheOptions |= SDImageCacheDecodeFirstFrameOnly;</span><br><span class="line">    if <span class="params">(options &amp; SDWebImagePreloadAllFrames)</span> cacheOptions |= SDImageCachePreloadAllFrames;</span><br><span class="line">    if <span class="params">(options &amp; SDWebImageMatchAnimatedImageClass)</span> cacheOptions |= SDImageCacheMatchAnimatedImageClass;</span><br><span class="line">    </span><br><span class="line">    return [self queryCacheOperationForKey:key options:cacheOptions context:context done:completionBlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里就不多说了就是将缓存相关的配置添加到cacheOptions中调用<strong><strong>queryCacheOperationForKey</strong></strong>：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSOperation</span> *)queryCacheOperationForKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key options:(SDImageCacheOptions)options context:(<span class="keyword">nullable</span> SDWebImageContext *)context done:(<span class="keyword">nullable</span> SDImageCacheQueryCompletionBlock)doneBlock &#123;</span><br><span class="line">    <span class="comment">//如果key为空则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (!key) &#123;</span><br><span class="line">        <span class="keyword">if</span> (doneBlock) &#123;</span><br><span class="line">            doneBlock(<span class="literal">nil</span>, <span class="literal">nil</span>, SDImageCacheTypeNone);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从context取出图片转换器</span></span><br><span class="line">    <span class="type">id</span>&lt;SDImageTransformer&gt; transformer = context[SDWebImageContextImageTransformer];</span><br><span class="line">    <span class="keyword">if</span> (transformer) &#123;</span><br><span class="line">        <span class="comment">// 取出我们存储在context中的transformer的transformerKey</span></span><br><span class="line">        <span class="built_in">NSString</span> *transformerKey = [transformer transformerKey];</span><br><span class="line">        key = SDTransformedKeyForKey(key, transformerKey);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//首先从内存缓存中查找</span></span><br><span class="line">    <span class="built_in">UIImage</span> *image = [<span class="keyword">self</span> imageFromMemoryCacheForKey:key];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (image) &#123;</span><br><span class="line">        <span class="comment">// 默认情况下我们会对动画图片整个进行解码，SDImageCacheDecodeFirstFrameOnly表示强迫只解码第一帧图片形成一个静态图</span></span><br><span class="line">        <span class="keyword">if</span> (options &amp; SDImageCacheDecodeFirstFrameOnly) &#123;</span><br><span class="line">            <span class="comment">// Ensure static image</span></span><br><span class="line">            Class animatedImageClass = image.class;</span><br><span class="line">            <span class="keyword">if</span> (image.sd_isAnimated || ([animatedImageClass isSubclassOfClass:[<span class="built_in">UIImage</span> <span class="keyword">class</span>]] &amp;&amp; [animatedImageClass conformsToProtocol:<span class="class"><span class="keyword">@protocol</span>(<span class="title">SDAnimatedImage</span>)])) </span>&#123;</span><br><span class="line">                image = [[<span class="built_in">UIImage</span> alloc] initWithCGImage:image.CGImage scale:image.scale orientation:image.imageOrientation];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (options &amp; SDImageCacheMatchAnimatedImageClass) &#123;</span><br><span class="line">            <span class="comment">// Check image class matching</span></span><br><span class="line">            Class animatedImageClass = image.class;</span><br><span class="line">            Class desiredImageClass = context[SDWebImageContextAnimatedImageClass];</span><br><span class="line">            <span class="keyword">if</span> (desiredImageClass &amp;&amp; ![animatedImageClass isSubclassOfClass:desiredImageClass]) &#123;</span><br><span class="line">                image = <span class="literal">nil</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//是否只使用内存缓存的图片</span></span><br><span class="line">    <span class="type">BOOL</span> shouldQueryMemoryOnly = (image &amp;&amp; !(options &amp; SDImageCacheQueryMemoryData));</span><br><span class="line">    <span class="keyword">if</span> (shouldQueryMemoryOnly) &#123;</span><br><span class="line">        <span class="keyword">if</span> (doneBlock) &#123;</span><br><span class="line">            doneBlock(image, <span class="literal">nil</span>, SDImageCacheTypeMemory);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查磁盘缓存中的资源</span></span><br><span class="line">    <span class="built_in">NSOperation</span> *operation = [<span class="built_in">NSOperation</span> new];</span><br><span class="line">    <span class="comment">// Check whether we need to synchronously query disk</span></span><br><span class="line">    <span class="comment">// 1. in-memory cache hit &amp; memoryDataSync</span></span><br><span class="line">    <span class="comment">// 2. in-memory cache miss &amp; diskDataSync</span></span><br><span class="line">    <span class="type">BOOL</span> shouldQueryDiskSync = ((image &amp;&amp; options &amp; SDImageCacheQueryMemoryDataSync) ||</span><br><span class="line">                                (!image &amp;&amp; options &amp; SDImageCacheQueryDiskDataSync));</span><br><span class="line">    </span><br><span class="line">    <span class="type">void</span>(^queryDiskBlock)(<span class="type">void</span>) =  ^&#123;</span><br><span class="line">        <span class="keyword">if</span> (operation.isCancelled) &#123;</span><br><span class="line">            <span class="keyword">if</span> (doneBlock) &#123;</span><br><span class="line">                doneBlock(<span class="literal">nil</span>, <span class="literal">nil</span>, SDImageCacheTypeNone);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">            <span class="comment">//从磁盘中查找对应的缓存图片</span></span><br><span class="line">            <span class="built_in">NSData</span> *diskData = [<span class="keyword">self</span> diskImageDataBySearchingAllPathsForKey:key];</span><br><span class="line">            <span class="built_in">UIImage</span> *diskImage;</span><br><span class="line">            SDImageCacheType cacheType = SDImageCacheTypeNone;</span><br><span class="line">            <span class="keyword">if</span> (image) &#123;</span><br><span class="line">                <span class="comment">// 使用内存缓存中的图片</span></span><br><span class="line">                <span class="comment">// the image is from in-memory cache, but need image data</span></span><br><span class="line">                diskImage = image;</span><br><span class="line">                cacheType = SDImageCacheTypeMemory;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (diskData) &#123;</span><br><span class="line">                <span class="comment">//使用磁盘缓存中的图片</span></span><br><span class="line">                cacheType = SDImageCacheTypeDisk;</span><br><span class="line">                <span class="comment">// decode image data only if in-memory cache missed</span></span><br><span class="line">                <span class="comment">// 在内存缓存没有命中的时候解压从磁盘中获取到的文件</span></span><br><span class="line">                diskImage = [<span class="keyword">self</span> diskImageForKey:key data:diskData options:options context:context];</span><br><span class="line">                <span class="keyword">if</span> (diskImage &amp;&amp; <span class="keyword">self</span>.config.shouldCacheImagesInMemory) &#123;</span><br><span class="line">                    <span class="comment">//是否需要存储到内存缓存中</span></span><br><span class="line">                    <span class="built_in">NSUInteger</span> cost = diskImage.sd_memoryCost;</span><br><span class="line">                    [<span class="keyword">self</span>.memoryCache setObject:diskImage forKey:key cost:cost];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//交付数据</span></span><br><span class="line">            <span class="keyword">if</span> (doneBlock) &#123;</span><br><span class="line">                <span class="keyword">if</span> (shouldQueryDiskSync) &#123;</span><br><span class="line">                    doneBlock(diskImage, diskData, cacheType);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                        doneBlock(diskImage, diskData, cacheType);</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Query in ioQueue to keep IO-safe</span></span><br><span class="line">    <span class="comment">// 开始查询，这里分同步和异步查询两种</span></span><br><span class="line">    <span class="keyword">if</span> (shouldQueryDiskSync) &#123;</span><br><span class="line">        <span class="built_in">dispatch_sync</span>(<span class="keyword">self</span>.ioQueue, queryDiskBlock);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">dispatch_async</span>(<span class="keyword">self</span>.ioQueue, queryDiskBlock);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> operation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<strong><strong>queryCacheOperationForKey</strong></strong>中做的工作和其他图片加载库类似，只不过在细节会有点差异：</p>
<ol>
<li>按照key的规则构建出缓存key</li>
<li>优先从缓存中查找缓存，如果只使用内存缓存的则在这个步骤不论是否能够在内存中找到缓存，都通过block返回结果。</li>
<li>如果在内存缓存中没有找到对应的图片缓存，则继续查找磁盘缓存，如果在磁盘中找到了，再看是否需要同步到内存缓存。</li>
<li>最后交付数据到应用层</li>
</ol>
<p>下面将针对上面几点展开介绍：</p>
<ul>
<li>按照key的规则构建出缓存key</li>
</ul>
<p>SDWebImage中的缓存key和转换器是有关联，所以我们在构建key的时候需要将转换器从context中取出。</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">id&lt;SDImageTransformer&gt; transformer = <span class="built_in">context</span>[SDWebImageContextImageTransformer];</span><br><span class="line"><span class="keyword">if</span> (transformer) &#123;</span><br><span class="line">    // 取出我们存储在<span class="built_in">context</span>中的transformer的transformerKey</span><br><span class="line">    NSString *transformerKey = [transformer transformerKey];</span><br><span class="line">    <span class="built_in">key</span> = SDTransformedKeyForKey(<span class="built_in">key</span>, transformerKey);</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

<p>缓存key的具体构建过程在<strong><strong>SDTransformedKeyForKey</strong></strong>方法中，这里会在原先的缓存key后面添加不同的转换器信息，用于区分同一个url 对应不同转换器的情况，比如我们有一个图片为<strong><strong>image.png</strong></strong>，它经过<strong><strong>flip(YES,NO)</strong></strong> 也就是水平翻转，再经过旋转45度处理，这样最终生成的key就是<strong><strong>image-SDImageFlippingTransformer(1,0)-SDImageRotationTransformer(0.78539816339,1).png</strong></strong>:</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">NSString * _Nullable SDTransformedKeyForKey(NSString * _Nullable key, NSString * _Nonnull transformerKey) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!key || !transformerKey) &#123;</span><br><span class="line">        <span class="keyword">return</span> nil;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Find the file extension</span></span><br><span class="line">    NSURL *keyURL = [NSURL URLWithString:key];</span><br><span class="line">    NSString *ext = keyURL ? keyURL.pathExtension : key.pathExtension;</span><br><span class="line">    <span class="keyword">if</span> (ext.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// For non-file URL</span></span><br><span class="line">        <span class="keyword">if</span> (keyURL &amp;&amp; !keyURL.isFileURL) &#123;</span><br><span class="line">            <span class="comment">// keep anything except path (like URL query)</span></span><br><span class="line">            NSURLComponents *component = [NSURLComponents componentsWithURL:keyURL resolvingAgainstBaseURL:NO];</span><br><span class="line">            component.path = [[[component.path.<span class="built_in">string</span>ByDeletingPathExtension <span class="built_in">string</span>ByAppendingString:SDImageTransformerKeySeparator] <span class="built_in">string</span>ByAppendingString:transformerKey] <span class="built_in">string</span>ByAppendingPathExtension:ext];</span><br><span class="line">            <span class="keyword">return</span> component.URL.absoluteString;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// file URL</span></span><br><span class="line">            <span class="keyword">return</span> [[[key.<span class="built_in">string</span>ByDeletingPathExtension <span class="built_in">string</span>ByAppendingString:SDImageTransformerKeySeparator] <span class="built_in">string</span>ByAppendingString:transformerKey] <span class="built_in">string</span>ByAppendingPathExtension:ext];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> [[key <span class="built_in">string</span>ByAppendingString:SDImageTransformerKeySeparator] <span class="built_in">string</span>ByAppendingString:O];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在拿到key后key后我们会先从内存图片缓存中去查找对与当前key匹配的图片。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">//首先从内存缓存中查找</span></span><br><span class="line"><span class="built_in">UIImage</span> *image = [<span class="keyword">self</span> imageFromMemoryCacheForKey:key];</span><br><span class="line"></span><br><span class="line">---&gt; </span><br><span class="line"></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)imageFromMemoryCacheForKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span>.memoryCache objectForKey:key];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果指定只使用内存中的缓存图片并且内存中有找到对应的图片就直接返回:</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">//是否只使用内存缓存的图片</span></span><br><span class="line"><span class="type">BOOL</span> shouldQueryMemoryOnly = (image &amp;&amp; !(options &amp; SDImageCacheQueryMemoryData));</span><br><span class="line"><span class="keyword">if</span> (shouldQueryMemoryOnly) &#123;</span><br><span class="line">    <span class="keyword">if</span> (doneBlock) &#123;</span><br><span class="line">        doneBlock(image, <span class="literal">nil</span>, SDImageCacheTypeMemory);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果shouldQueryMemoryOnly &#x3D; NO,也就是不单单使用内存的图片缓存，就会调用<strong><strong>diskImageDataBySearchingAllPathsForKey</strong></strong>在磁盘中查找对应的缓存图片，如同内存中有则优先使用内存的，其实这里有个需要优化的地方，如果image不为空的情况下就不需要调用<strong><strong>diskImageDataBySearchingAllPathsForKey</strong></strong>，如果内存没有，那么会将从磁盘缓存中获取到的缓存数据，经过解码后存放到内存缓存，供下次使用。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">BOOL shouldQueryDiskSync = ((image<span class="operator"> &amp;&amp; </span>options &amp; SDImageCacheQueryMemoryDataSync)<span class="operator"> ||</span></span><br><span class="line"><span class="operator">                            </span>(!image<span class="operator"> &amp;&amp; </span>options &amp; SDImageCacheQueryDiskDataSync));</span><br><span class="line"></span><br><span class="line">void(^queryDiskBlock)(void) =  ^&#123;</span><br><span class="line">    <span class="keyword">if</span> (operation.isCancelled) &#123;</span><br><span class="line">        <span class="keyword">if</span> (doneBlock) &#123;</span><br><span class="line">            <span class="keyword">done</span><span class="constructor">Block(<span class="params">nil</span>, <span class="params">nil</span>, SDImageCacheTypeNone)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        <span class="comment">//从磁盘中查找对应的缓存图片</span></span><br><span class="line">        NSData *diskData = <span class="literal">[<span class="identifier">self</span> <span class="identifier">diskImageDataBySearchingAllPathsForKey</span>:<span class="identifier">key</span>]</span>;</span><br><span class="line">        UIImage *diskImage;</span><br><span class="line">        SDImageCacheType cacheType = SDImageCacheTypeNone;</span><br><span class="line">        <span class="keyword">if</span> (image) &#123;</span><br><span class="line">            <span class="comment">// 使用内存缓存中的图片</span></span><br><span class="line">            diskImage = image;</span><br><span class="line">            cacheType = SDImageCacheTypeMemory;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (diskData) &#123;</span><br><span class="line">            <span class="comment">//使用磁盘缓存中的图片</span></span><br><span class="line">            cacheType = SDImageCacheTypeDisk;</span><br><span class="line">            <span class="comment">// 在内存缓存没有命中的时候解压从磁盘中获取到的文件</span></span><br><span class="line">            diskImage = <span class="literal">[<span class="identifier">self</span> <span class="identifier">diskImageForKey</span>:<span class="identifier">key</span> <span class="identifier">data</span>:<span class="identifier">diskData</span> <span class="identifier">options</span>:<span class="identifier">options</span> <span class="identifier">context</span>:<span class="identifier">context</span>]</span>;</span><br><span class="line">            <span class="keyword">if</span> (diskImage<span class="operator"> &amp;&amp; </span>self.config.shouldCacheImagesInMemory) &#123;</span><br><span class="line">                <span class="comment">//是否需要存储到内存缓存中</span></span><br><span class="line">                NSUInteger cost = diskImage.sd_memoryCost;</span><br><span class="line">                <span class="literal">[<span class="identifier">self</span>.<span class="identifier">memoryCache</span> <span class="identifier">setObject</span>:<span class="identifier">diskImage</span> <span class="identifier">forKey</span>:<span class="identifier">key</span> <span class="identifier">cost</span>:<span class="identifier">cost</span>]</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//交付数据</span></span><br><span class="line">        <span class="keyword">if</span> (doneBlock) &#123;</span><br><span class="line">            <span class="keyword">if</span> (shouldQueryDiskSync) &#123;</span><br><span class="line">                <span class="keyword">done</span><span class="constructor">Block(<span class="params">diskImage</span>, <span class="params">diskData</span>, <span class="params">cacheType</span>)</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dispatch<span class="constructor">_async(<span class="params">dispatch_get_main_queue</span>()</span>, ^&#123;</span><br><span class="line">                    <span class="keyword">done</span><span class="constructor">Block(<span class="params">diskImage</span>, <span class="params">diskData</span>, <span class="params">cacheType</span>)</span>;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 开始查询，这里分同步和异步查询两种</span></span><br><span class="line"><span class="keyword">if</span> (shouldQueryDiskSync) &#123;</span><br><span class="line">    dispatch<span class="constructor">_sync(<span class="params">self</span>.<span class="params">ioQueue</span>, <span class="params">queryDiskBlock</span>)</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    dispatch<span class="constructor">_async(<span class="params">self</span>.<span class="params">ioQueue</span>, <span class="params">queryDiskBlock</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="2-2-1-2-使用网络资源"><a href="#2-2-1-2-使用网络资源" class="headerlink" title="2.2.1.2 使用网络资源"></a>2.2.1.2 使用网络资源</h6><p>上面小节我们了解了从缓存中加载图片的流程，接下来我们看下从网络上对图片进行加载的流程:</p>
<p>在SDWebImage默认情况下使用<strong><strong>SDWebImageDownloader</strong></strong>来完成下载任务，我们在分析下载流程之前我们先看下SDWebImageDownloader数据流是怎样的：</p>
<ul>
<li><strong><strong>SDWebImageDownloader初始化阶段</strong></strong></li>
</ul>
<p>在SDWebImageDownloader 第一次调用的时候会调用initialize方法</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">+ (<span class="type">void</span>)initialize &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">NSClassFromString</span>(<span class="string">@&quot;SDNetworkActivityIndicator&quot;</span>)) &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> clang diagnostic push</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> clang diagnostic ignored <span class="string">&quot;-Warc-performSelector-leaks&quot;</span></span></span><br><span class="line">        <span class="type">id</span> activityIndicator = [<span class="built_in">NSClassFromString</span>(<span class="string">@&quot;SDNetworkActivityIndicator&quot;</span>) performSelector:<span class="built_in">NSSelectorFromString</span>(<span class="string">@&quot;sharedActivityIndicator&quot;</span>)];</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> clang diagnostic pop</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Remove observer in case it was previously added.</span></span><br><span class="line">        [[<span class="built_in">NSNotificationCenter</span> defaultCenter] removeObserver:activityIndicator name:SDWebImageDownloadStartNotification object:<span class="literal">nil</span>];</span><br><span class="line">        [[<span class="built_in">NSNotificationCenter</span> defaultCenter] removeObserver:activityIndicator name:SDWebImageDownloadStopNotification object:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line">        [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:activityIndicator</span><br><span class="line">                                                 selector:<span class="built_in">NSSelectorFromString</span>(<span class="string">@&quot;startActivity&quot;</span>)</span><br><span class="line">                                                     name:SDWebImageDownloadStartNotification object:<span class="literal">nil</span>];</span><br><span class="line">        [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:activityIndicator</span><br><span class="line">                                                 selector:<span class="built_in">NSSelectorFromString</span>(<span class="string">@&quot;stopActivity&quot;</span>)</span><br><span class="line">                                                     name:SDWebImageDownloadStopNotification object:<span class="literal">nil</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里主要是对网络状态指示器通知进行监听。</p>
<figure class="highlight elm"><table><tr><td class="code"><pre><span class="line">- (nonnull instance<span class="keyword">type</span>)init &#123;</span><br><span class="line">    return [self initWithConfig:<span class="type">SDWebImageDownloaderConfig</span>.defaultDownloaderConfig];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)initWithConfig:(SDWebImageDownloaderConfig *)config &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="variable language_">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!config) &#123;</span><br><span class="line">            config = SDWebImageDownloaderConfig.defaultDownloaderConfig;</span><br><span class="line">        &#125;</span><br><span class="line">        _config = [config <span class="keyword">copy</span>];</span><br><span class="line">        <span class="comment">//指定并行下载数目</span></span><br><span class="line">        [_config addObserver:<span class="keyword">self</span> forKeyPath:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(maxConcurrentDownloads)) options:<span class="number">0</span> context:SDWebImageDownloaderContext];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//创建下载队列_downloadQueue</span></span><br><span class="line">        _downloadQueue = [<span class="built_in">NSOperationQueue</span> new];</span><br><span class="line">        _downloadQueue.maxConcurrentOperationCount = _config.maxConcurrentDownloads;</span><br><span class="line">        _downloadQueue.name = <span class="string">@&quot;com.hackemist.SDWebImageDownloader&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//创建用于管理NSOperation的字典，key为url，value为对应的NSOperation</span></span><br><span class="line">        _URLOperations = [<span class="built_in">NSMutableDictionary</span> new];</span><br><span class="line">        <span class="built_in">NSMutableDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="built_in">NSString</span> *&gt; *headerDictionary = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">        <span class="built_in">NSString</span> *userAgent = <span class="literal">nil</span>;</span><br><span class="line">        <span class="comment">// User-Agent Header; see http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.43</span></span><br><span class="line">        userAgent = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;%@/%@ (%@; iOS %@; Scale/%0.2f)&quot;</span>, [[<span class="built_in">NSBundle</span> mainBundle] infoDictionary][(__bridge <span class="built_in">NSString</span> *)kCFBundleExecutableKey] ?: [[<span class="built_in">NSBundle</span> mainBundle] infoDictionary][(__bridge <span class="built_in">NSString</span> *)kCFBundleIdentifierKey], [[<span class="built_in">NSBundle</span> mainBundle] infoDictionary][<span class="string">@&quot;CFBundleShortVersionString&quot;</span>] ?: [[<span class="built_in">NSBundle</span> mainBundle] infoDictionary][(__bridge <span class="built_in">NSString</span> *)kCFBundleVersionKey], [[<span class="built_in">UIDevice</span> currentDevice] model], [[<span class="built_in">UIDevice</span> currentDevice] systemVersion], [[<span class="built_in">UIScreen</span> mainScreen] scale]];</span><br><span class="line">        <span class="comment">//UA设置</span></span><br><span class="line">        <span class="keyword">if</span> (userAgent) &#123;</span><br><span class="line">            <span class="keyword">if</span> (![userAgent canBeConvertedToEncoding:<span class="built_in">NSASCIIStringEncoding</span>]) &#123;</span><br><span class="line">                <span class="built_in">NSMutableString</span> *mutableUserAgent = [userAgent mutableCopy];</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">CFStringTransform</span>((__bridge <span class="built_in">CFMutableStringRef</span>)(mutableUserAgent), <span class="literal">NULL</span>, (__bridge <span class="built_in">CFStringRef</span>)<span class="string">@&quot;Any-Latin; Latin-ASCII; [:^ASCII:] Remove&quot;</span>, <span class="literal">false</span>)) &#123;</span><br><span class="line">                    userAgent = mutableUserAgent;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            headerDictionary[<span class="string">@&quot;User-Agent&quot;</span>] = userAgent;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//Accept context设置</span></span><br><span class="line">        headerDictionary[<span class="string">@&quot;Accept&quot;</span>] = <span class="string">@&quot;image/*,*/*;q=0.8&quot;</span>;</span><br><span class="line">        _HTTPHeaders = headerDictionary;</span><br><span class="line">        _HTTPHeadersLock = dispatch_semaphore_create(<span class="number">1</span>);</span><br><span class="line">        _operationsLock = dispatch_semaphore_create(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">NSURLSessionConfiguration</span> *sessionConfiguration = _config.sessionConfiguration;</span><br><span class="line">        <span class="keyword">if</span> (!sessionConfiguration) &#123;</span><br><span class="line">            sessionConfiguration = [<span class="built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *  Create the session for this task</span></span><br><span class="line"><span class="comment">         *  We send nil as delegate queue so that the session creates a serial operation queue for performing all delegate</span></span><br><span class="line"><span class="comment">         *  method calls and completion handler calls.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//创建NSURLSession</span></span><br><span class="line">        _session = [<span class="built_in">NSURLSession</span> sessionWithConfiguration:sessionConfiguration</span><br><span class="line">                                                 delegate:<span class="keyword">self</span></span><br><span class="line">                                            delegateQueue:<span class="literal">nil</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在初始化方法中主要负责重要组件的创建****_downloadQueue<strong><strong>，</strong></strong>_URLOperations<strong><strong>，</strong></strong>_session****。</p>
<ul>
<li><strong><strong>SDWebImageDownloader下载流程</strong></strong></li>
</ul>
<p>SDWebImage的下载是从callDownloadProcessForOperation开始的：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="operator">-</span> (void)callDownloadProcessForOperation:(nonnull <span class="type">SDWebImageCombinedOperation</span> <span class="operator">*</span>)operation</span><br><span class="line">                                    url:(nonnull <span class="type">NSURL</span> <span class="operator">*</span>)url</span><br><span class="line">                                options:(<span class="type">SDWebImageOptions</span>)options</span><br><span class="line">                                context:(<span class="type">SDWebImageContext</span> <span class="operator">*</span>)context</span><br><span class="line">                            cachedImage:(nullable <span class="type">UIImage</span> <span class="operator">*</span>)cachedImage</span><br><span class="line">                             cachedData:(nullable <span class="type">NSData</span> <span class="operator">*</span>)cachedData</span><br><span class="line">                              cacheType:(<span class="type">SDImageCacheType</span>)cacheType</span><br><span class="line">                               progress:(nullable <span class="type">SDImageLoaderProgressBlock</span>)progressBlock</span><br><span class="line">                              completed:(nullable <span class="type">SDInternalCompletionBlock</span>)completedBlock &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">BOOL</span> shouldDownload <span class="operator">=</span> <span class="operator">!</span><span class="type">SD_OPTIONS_CONTAINS</span>(options, <span class="type">SDWebImageFromCacheOnly</span>);</span><br><span class="line">    shouldDownload <span class="operator">&amp;=</span> (<span class="operator">!</span>cachedImage <span class="operator">||</span> options <span class="operator">&amp;</span> <span class="type">SDWebImageRefreshCached</span>);</span><br><span class="line">    shouldDownload <span class="operator">&amp;=</span> (<span class="operator">!</span>[<span class="keyword">self</span>.delegate respondsToSelector:<span class="meta">@selector</span>(imageManager:shouldDownloadImageForURL:)] <span class="operator">||</span> [<span class="keyword">self</span>.delegate imageManager:<span class="keyword">self</span> shouldDownloadImageForURL:url]);</span><br><span class="line">    shouldDownload <span class="operator">&amp;=</span> [<span class="keyword">self</span>.imageLoader canRequestImageForURL:url];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (shouldDownload) &#123;</span><br><span class="line">        <span class="comment">//在需要强制刷新缓存的情况下先调用callCompletionBlockForOperation将缓存图片交给上层，然后继续开始下载</span></span><br><span class="line">        <span class="keyword">if</span> (cachedImage <span class="operator">&amp;&amp;</span> options <span class="operator">&amp;</span> <span class="type">SDWebImageRefreshCached</span>) &#123;</span><br><span class="line">            <span class="comment">// If image was found in the cache but SDWebImageRefreshCached is provided, notify about the cached image</span></span><br><span class="line">            <span class="comment">// AND try to re-download it in order to let a chance to NSURLCache to refresh it from server.</span></span><br><span class="line">            [<span class="keyword">self</span> callCompletionBlockForOperation:operation completion:completedBlock image:cachedImage data:cachedData error:<span class="literal">nil</span> cacheType:cacheType finished:<span class="type">YES</span> url:url];</span><br><span class="line">            <span class="comment">// Pass the cached image to the image loader. The image loader should check whether the remote image is equal to the cached image.</span></span><br><span class="line">            <span class="type">SDWebImageMutableContext</span> <span class="operator">*</span>mutableContext;</span><br><span class="line">            <span class="keyword">if</span> (context) &#123;</span><br><span class="line">                mutableContext <span class="operator">=</span> [context mutableCopy];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mutableContext <span class="operator">=</span> [<span class="type">NSMutableDictionary</span> dictionary];</span><br><span class="line">            &#125;</span><br><span class="line">            mutableContext[<span class="type">SDWebImageContextLoaderCachedImage</span>] <span class="operator">=</span> cachedImage;</span><br><span class="line">            context <span class="operator">=</span> [mutableContext copy];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="meta">@weakify</span>(operation);</span><br><span class="line">        <span class="comment">// 开始发起图片加载的请求</span></span><br><span class="line">        operation.loaderOperation <span class="operator">=</span> [<span class="keyword">self</span>.imageLoader requestImageWithURL:url options:options context:context progress:progressBlock completed:<span class="operator">^</span>(<span class="type">UIImage</span> <span class="operator">*</span>downloadedImage, <span class="type">NSData</span> <span class="operator">*</span>downloadedData, <span class="type">NSError</span> <span class="operator">*</span>error, <span class="type">BOOL</span> finished) &#123;</span><br><span class="line">            <span class="meta">@strongify</span>(operation);</span><br><span class="line">            <span class="comment">//用户取消请求</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="operator">!</span>operation <span class="operator">||</span> operation.isCancelled) &#123;</span><br><span class="line">                [<span class="keyword">self</span> callCompletionBlockForOperation:operation completion:completedBlock error:[<span class="type">NSError</span> errorWithDomain:<span class="type">SDWebImageErrorDomain</span> code:<span class="type">SDWebImageErrorCancelled</span> userInfo:<span class="literal">nil</span>] url:url];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cachedImage <span class="operator">&amp;&amp;</span> options <span class="operator">&amp;</span> <span class="type">SDWebImageRefreshCached</span> <span class="operator">&amp;&amp;</span> [error.domain isEqualToString:<span class="type">SDWebImageErrorDomain</span>] <span class="operator">&amp;&amp;</span> error.code <span class="operator">==</span> <span class="type">SDWebImageErrorCacheNotModified</span>) &#123;</span><br><span class="line">                <span class="comment">// 强制刷新缓存的时候，在前面先将缓存图片通过completeBlock 将数据传递给上层，到这里将数据加载完毕后，不做任何操作</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([error.domain isEqualToString:<span class="type">SDWebImageErrorDomain</span>] <span class="operator">&amp;&amp;</span> error.code <span class="operator">==</span> <span class="type">SDWebImageErrorCancelled</span>) &#123;</span><br><span class="line">                <span class="comment">// 将错误交给上层</span></span><br><span class="line">                [<span class="keyword">self</span> callCompletionBlockForOperation:operation completion:completedBlock error:error url:url];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (error) &#123;</span><br><span class="line">                [<span class="keyword">self</span> callCompletionBlockForOperation:operation completion:completedBlock error:error url:url];</span><br><span class="line">                <span class="comment">//是否需要将错误的URL添加到failedURLs</span></span><br><span class="line">                <span class="type">BOOL</span> shouldBlockFailedURL <span class="operator">=</span> [<span class="keyword">self</span> shouldBlockFailedURLWithURL:url error:error];</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (shouldBlockFailedURL) &#123;</span><br><span class="line">                    <span class="type">SD_LOCK</span>(<span class="keyword">self</span>.failedURLsLock);</span><br><span class="line">                    [<span class="keyword">self</span>.failedURLs addObject:url];</span><br><span class="line">                    <span class="type">SD_UNLOCK</span>(<span class="keyword">self</span>.failedURLsLock);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 成功</span></span><br><span class="line">                <span class="comment">//如果SDWebImageRetryFailed = 1 表示错误的url需要重试，这时候就要将当前的url从failedURLs移除</span></span><br><span class="line">                <span class="keyword">if</span> ((options <span class="operator">&amp;</span> <span class="type">SDWebImageRetryFailed</span>)) &#123;</span><br><span class="line">                    <span class="type">SD_LOCK</span>(<span class="keyword">self</span>.failedURLsLock);</span><br><span class="line">                    [<span class="keyword">self</span>.failedURLs removeObject:url];</span><br><span class="line">                    <span class="type">SD_UNLOCK</span>(<span class="keyword">self</span>.failedURLsLock);</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                [<span class="keyword">self</span> callStoreCacheProcessForOperation:operation url:url options:options context:context downloadedImage:downloadedImage downloadedData:downloadedData finished:finished progress:progressBlock completed:completedBlock];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (finished) &#123;</span><br><span class="line">                <span class="comment">//加载成功后将操作从Running队列中移除</span></span><br><span class="line">                [<span class="keyword">self</span> safelyRemoveOperationFromRunning:operation];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cachedImage) &#123;</span><br><span class="line">        <span class="comment">//使用缓存的情况下将缓存数据传递到上层，并将请求从Running队列中移除</span></span><br><span class="line">        [<span class="keyword">self</span> callCompletionBlockForOperation:operation completion:completedBlock image:cachedImage data:cachedData error:<span class="literal">nil</span> cacheType:cacheType finished:<span class="type">YES</span> url:url];</span><br><span class="line">        [<span class="keyword">self</span> safelyRemoveOperationFromRunning:operation];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//缓存没有图片，并且不允许下载</span></span><br><span class="line">        [<span class="keyword">self</span> callCompletionBlockForOperation:operation completion:completedBlock image:<span class="literal">nil</span> data:<span class="literal">nil</span> error:<span class="literal">nil</span> cacheType:<span class="type">SDImageCacheTypeNone</span> finished:<span class="type">YES</span> url:url];</span><br><span class="line">        [<span class="keyword">self</span> safelyRemoveOperationFromRunning:operation];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>是否需要从网络上下载图片需要根据如下条件进行判断：</p>
<ol>
<li>SDWebImageFromCacheOnly &#x3D; 0，表示不单单只允许使用缓存的数据</li>
<li>上一步没有找到缓存cachedImage </li>
<li>SDWebImageRefreshCached &#x3D; 1 强制刷新缓存</li>
<li>imageManager:shouldDownloadImageForURL:决定当图片在缓存内没有找到的时候是否需要下载</li>
<li>[self.imageLoader canRequestImageForURL:url] 决定是否能够下载,它会在每次imageloader请求到来的时候，对URL进行检查，<br> 如果返回YES,则会开始调用requestImageWithURL发起请求，否则将会将当前的图片加载标记为加载失败。</li>
</ol>
<p>这里需要强调的是如果是需要强制刷新的时候会先将缓存图片通过block上传给业务层，但是会继续下载任务。</p>
<p>下载是调用****self.imageLoader requestImageWithURL:****来执行的，我们来看下：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">- (id&lt;SDWebImageOperation&gt;)requestImageWithURL:(NSURL *)url options:(SDWebImageOptions)options context:(SDWebImageContext *)context progress:(SDImageLoaderProgressBlock)progressBlock completed:(SDImageLoaderCompletedBlock)completedBlock &#123;</span><br><span class="line">    <span class="keyword">if</span> (!url) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    NSArray&lt;id&lt;SDImageLoader&gt;&gt; *<span class="built_in">loaders</span> = <span class="built_in">self</span>.<span class="built_in">loaders</span>;</span><br><span class="line">    <span class="keyword">for</span> (id&lt;SDImageLoader&gt; loader <span class="keyword">in</span> <span class="built_in">loaders</span>.reverseObjectEnumerator) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([loader canRequestImageForURL:url]) &#123;</span><br><span class="line">            <span class="keyword">return</span> [loader requestImageWithURL:url options:options context:context progress:progressBlock completed:completedBlock];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里会遍历每个注册的SDImageLoader，对每个loader调用<strong><strong>canRequestImageForURL</strong></strong> 来判断当前loader能否对当前url请求做处理，如果能就进行请求，这种插件化处理是很多通用库采用的套路。我们看下<strong><strong>SDImageLoadersManager</strong></strong></p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">- (id&lt;SDWebImageOperation&gt;)requestImageWithURL:(NSURL *)url options:(SDWebImageOptions)options context:(SDWebImageContext *)context progress:(SDImageLoaderProgressBlock)progressBlock completed:(SDImageLoaderCompletedBlock)completedBlock &#123;</span><br><span class="line">    UIImage *cachedImage = context[SDWebImageContextLoaderCachedImage];</span><br><span class="line">    </span><br><span class="line">    SDWebImageDownloaderOptions downloaderOptions = <span class="number">0</span>;</span><br><span class="line">    if (options <span class="meta">&amp; SDWebImageLowPriority) downloaderOptions |= SDWebImageDownloaderLowPriority;</span></span><br><span class="line">    if (options <span class="meta">&amp; SDWebImageProgressiveLoad) downloaderOptions |= SDWebImageDownloaderProgressiveLoad;</span></span><br><span class="line">    if (options <span class="meta">&amp; SDWebImageRefreshCached) downloaderOptions |= SDWebImageDownloaderUseNSURLCache;</span></span><br><span class="line">    if (options <span class="meta">&amp; SDWebImageContinueInBackground) downloaderOptions |= SDWebImageDownloaderContinueInBackground;</span></span><br><span class="line">    if (options <span class="meta">&amp; SDWebImageHandleCookies) downloaderOptions |= SDWebImageDownloaderHandleCookies;</span></span><br><span class="line">    if (options <span class="meta">&amp; SDWebImageAllowInvalidSSLCertificates) downloaderOptions |= SDWebImageDownloaderAllowInvalidSSLCertificates;</span></span><br><span class="line">    if (options <span class="meta">&amp; SDWebImageHighPriority) downloaderOptions |= SDWebImageDownloaderHighPriority;</span></span><br><span class="line">    if (options <span class="meta">&amp; SDWebImageScaleDownLargeImages) downloaderOptions |= SDWebImageDownloaderScaleDownLargeImages;</span></span><br><span class="line">    if (options <span class="meta">&amp; SDWebImageAvoidDecodeImage) downloaderOptions |= SDWebImageDownloaderAvoidDecodeImage;</span></span><br><span class="line">    if (options <span class="meta">&amp; SDWebImageDecodeFirstFrameOnly) downloaderOptions |= SDWebImageDownloaderDecodeFirstFrameOnly;</span></span><br><span class="line">    if (options <span class="meta">&amp; SDWebImagePreloadAllFrames) downloaderOptions |= SDWebImageDownloaderPreloadAllFrames;</span></span><br><span class="line">    if (options <span class="meta">&amp; SDWebImageMatchAnimatedImageClass) downloaderOptions |= SDWebImageDownloaderMatchAnimatedImageClass;</span></span><br><span class="line">    </span><br><span class="line">    if (cachedImage <span class="meta">&amp;&amp; options &amp; SDWebImageRefreshCached) &#123;</span></span><br><span class="line">        <span class="comment">// force progressive off if image already cached but forced refreshing</span></span><br><span class="line">        downloaderOptions <span class="meta">&amp;= ~SDWebImageDownloaderProgressiveLoad;</span></span><br><span class="line">        <span class="comment">// ignore image read from NSURLCache if image if cached but force refreshing</span></span><br><span class="line">        downloaderOptions <span class="string">|= SDWebImageDownloaderIgnoreCachedResponse;</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return [self downloadImageWithURL:url options:downloaderOptions context:context progress:progressBlock completed:completedBlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和查找缓存一样在执行真正的下载任务之前，会先重建一份options，然后再开始真正的请求：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="operator">-</span> (nullable <span class="type">SDWebImageDownloadToken</span> <span class="operator">*</span>)downloadImageWithURL:(nullable <span class="type">NSURL</span> <span class="operator">*</span>)url</span><br><span class="line">                                                   options:(<span class="type">SDWebImageDownloaderOptions</span>)options</span><br><span class="line">                                                   context:(nullable <span class="type">SDWebImageContext</span> <span class="operator">*</span>)context</span><br><span class="line">                                                  progress:(nullable <span class="type">SDWebImageDownloaderProgressBlock</span>)progressBlock</span><br><span class="line">                                                 completed:(nullable <span class="type">SDWebImageDownloaderCompletedBlock</span>)completedBlock &#123;</span><br><span class="line">    <span class="comment">//..........</span></span><br><span class="line">    <span class="type">SD_LOCK</span>(<span class="keyword">self</span>.operationsLock);</span><br><span class="line">    id downloadOperationCancelToken;</span><br><span class="line">    <span class="comment">// 通过当前的url去self.URLOperations 中去取NSOperation</span></span><br><span class="line">    <span class="type">NSOperation</span>&lt;<span class="type">SDWebImageDownloaderOperation</span>&gt; <span class="operator">*</span>operation <span class="operator">=</span> [<span class="keyword">self</span>.<span class="type">URLOperations</span> objectForKey:url];</span><br><span class="line">    <span class="comment">// 如果当前url对应的operation为空，并且operation.isFinished = YES 或者 operation.isCancelled = YES,就调用createDownloaderOperationWithUrl新建一个NSOperation。</span></span><br><span class="line">    <span class="comment">// operation.isFinished = YES 或者 operation.isCancelled = YES 会发生在operation被取消或者被标记为结束，但是并没有将它从self.URLOperations移除</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="operator">!</span>operation <span class="operator">||</span> operation.isFinished <span class="operator">||</span> operation.isCancelled) &#123;</span><br><span class="line">        operation <span class="operator">=</span> [<span class="keyword">self</span> createDownloaderOperationWithUrl:url options:options context:context];</span><br><span class="line">        <span class="comment">// .......</span></span><br><span class="line">        <span class="comment">//operation 执行结束后会将当前url对应的operation从URLOperations中移除</span></span><br><span class="line">        <span class="meta">@weakify</span>(<span class="keyword">self</span>);</span><br><span class="line">        operation.completionBlock <span class="operator">=</span> <span class="operator">^</span>&#123;</span><br><span class="line">            <span class="meta">@strongify</span>(<span class="keyword">self</span>);</span><br><span class="line">            <span class="comment">//......</span></span><br><span class="line">            <span class="type">SD_LOCK</span>(<span class="keyword">self</span>.operationsLock);</span><br><span class="line">            [<span class="keyword">self</span>.<span class="type">URLOperations</span> removeObjectForKey:url];</span><br><span class="line">            <span class="type">SD_UNLOCK</span>(<span class="keyword">self</span>.operationsLock);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//添加到self.URLOperations中</span></span><br><span class="line">        <span class="keyword">self</span>.<span class="type">URLOperations</span>[url] <span class="operator">=</span> operation;</span><br><span class="line">        <span class="comment">// 将operation 添加到下载队列</span></span><br><span class="line">        [<span class="keyword">self</span>.downloadQueue addOperation:operation];</span><br><span class="line">        <span class="comment">//为当前的operation添加下载进度block以及下载完成的block</span></span><br><span class="line">        downloadOperationCancelToken <span class="operator">=</span> [operation addHandlersForProgress:progressBlock completed:completedBlock];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// So we lock the operation here, and in `SDWebImageDownloaderOperation`, we use `@synchonzied (self)`, to ensure the thread safe between these two classes.</span></span><br><span class="line">        <span class="comment">// 走到这里表示之前有对应的下载了，我们可以复用已经存在的下载，并添加progressBlock 以及completedBlock，这样在原先的下载任务完成后也会通知到当前的请求</span></span><br><span class="line">        <span class="meta">@synchronized</span> (operation) &#123;</span><br><span class="line">            downloadOperationCancelToken <span class="operator">=</span> [operation addHandlersForProgress:progressBlock completed:completedBlock];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="operator">!</span>operation.isExecuting) &#123;</span><br><span class="line">            <span class="keyword">if</span> (options <span class="operator">&amp;</span> <span class="type">SDWebImageDownloaderHighPriority</span>) &#123;</span><br><span class="line">                operation.queuePriority <span class="operator">=</span> <span class="type">NSOperationQueuePriorityHigh</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (options <span class="operator">&amp;</span> <span class="type">SDWebImageDownloaderLowPriority</span>) &#123;</span><br><span class="line">                operation.queuePriority <span class="operator">=</span> <span class="type">NSOperationQueuePriorityLow</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                operation.queuePriority <span class="operator">=</span> <span class="type">NSOperationQueuePriorityNormal</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">SD_UNLOCK</span>(<span class="keyword">self</span>.operationsLock);</span><br><span class="line">    <span class="comment">//这里返回的是一个SDWebImageDownloadToken，后面可以通过它来取消这个下载任务</span></span><br><span class="line">    <span class="type">SDWebImageDownloadToken</span> <span class="operator">*</span>token <span class="operator">=</span> [[<span class="type">SDWebImageDownloadToken</span> alloc] initWithDownloadOperation:operation];</span><br><span class="line">    token.url <span class="operator">=</span> url;</span><br><span class="line">    token.request <span class="operator">=</span> operation.request;</span><br><span class="line">    token.downloadOperationCancelToken <span class="operator">=</span> downloadOperationCancelToken;</span><br><span class="line">    <span class="keyword">return</span> token;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下载请求是基于NSOperation的，每个url对应一个NSOperation，这些NSOperation放在self.URLOperations 中统一管理，每次发起一个未存在的图片请求的时候就会新建一个NSOperation并添加到self.URLOperations，一旦完成下载这个url对应的NSOperation就会从self.URLOperations中移除。如果发起一个已经存在的url请求，那么就会复用当前已经开始的NSOperation，将当前的<strong><strong>progressBlock</strong></strong>，<strong><strong>completedBlock</strong></strong> 添加到 已经存在的NSOperation中，这样在原先的下载任务完成后也会通知到当前的请求响应的对应block。</p>
<p>我们接下来看下NSOperation的创建方法<strong><strong>createDownloaderOperationWithUrl</strong></strong>，这里主要是构建出NSRequest并通过请求修改器，对请求进行拦截修改，然后将返回体修改器，解密器以及Request 添加到NSOperation中。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSOperation</span>&lt;SDWebImageDownloaderOperation&gt; *)createDownloaderOperationWithUrl:(<span class="keyword">nonnull</span> <span class="built_in">NSURL</span> *)url</span><br><span class="line">                                                                                  options:(SDWebImageDownloaderOptions)options</span><br><span class="line">                                                                                  context:(<span class="keyword">nullable</span> SDWebImageContext *)context &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//配置网络超时时间，缓存策略等</span></span><br><span class="line">    <span class="built_in">NSTimeInterval</span> timeoutInterval = <span class="keyword">self</span>.config.downloadTimeout;</span><br><span class="line">    <span class="keyword">if</span> (timeoutInterval == <span class="number">0.0</span>) &#123;</span><br><span class="line">        timeoutInterval = <span class="number">15.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// In order to prevent from potential duplicate caching (NSURLCache + SDImageCache) we disable the cache for image requests if told otherwise</span></span><br><span class="line">    <span class="built_in">NSURLRequestCachePolicy</span> cachePolicy = options &amp; SDWebImageDownloaderUseNSURLCache ? <span class="built_in">NSURLRequestUseProtocolCachePolicy</span> : <span class="built_in">NSURLRequestReloadIgnoringLocalCacheData</span>;</span><br><span class="line">    <span class="built_in">NSMutableURLRequest</span> *mutableRequest = [[<span class="built_in">NSMutableURLRequest</span> alloc] initWithURL:url cachePolicy:cachePolicy timeoutInterval:timeoutInterval];</span><br><span class="line">    mutableRequest.HTTPShouldHandleCookies = SD_OPTIONS_CONTAINS(options, SDWebImageDownloaderHandleCookies);</span><br><span class="line">    mutableRequest.HTTPShouldUsePipelining = <span class="literal">YES</span>;</span><br><span class="line">    SD_LOCK(<span class="keyword">self</span>.HTTPHeadersLock);</span><br><span class="line">    mutableRequest.allHTTPHeaderFields = <span class="keyword">self</span>.HTTPHeaders;</span><br><span class="line">    SD_UNLOCK(<span class="keyword">self</span>.HTTPHeadersLock);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 取出context</span></span><br><span class="line">    SDWebImageMutableContext *mutableContext;</span><br><span class="line">    <span class="keyword">if</span> (context) &#123;</span><br><span class="line">        mutableContext = [context mutableCopy];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mutableContext = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从context中取出requestModifier，它会对当前的URL进行修改。</span></span><br><span class="line">    <span class="type">id</span>&lt;SDWebImageDownloaderRequestModifier&gt; requestModifier;</span><br><span class="line">    <span class="keyword">if</span> ([context valueForKey:SDWebImageContextDownloadRequestModifier]) &#123;</span><br><span class="line">        requestModifier = [context valueForKey:SDWebImageContextDownloadRequestModifier];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        requestModifier = <span class="keyword">self</span>.requestModifier;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSURLRequest</span> *request;</span><br><span class="line">    <span class="keyword">if</span> (requestModifier) &#123;</span><br><span class="line">        <span class="built_in">NSURLRequest</span> *modifiedRequest = [requestModifier modifiedRequestWithRequest:[mutableRequest <span class="keyword">copy</span>]];</span><br><span class="line">        <span class="comment">// If modified request is nil, early return</span></span><br><span class="line">        <span class="keyword">if</span> (!modifiedRequest) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            request = [modifiedRequest <span class="keyword">copy</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        request = [mutableRequest <span class="keyword">copy</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Response 修改器件</span></span><br><span class="line">    <span class="type">id</span>&lt;SDWebImageDownloaderResponseModifier&gt; responseModifier;</span><br><span class="line">    <span class="keyword">if</span> ([context valueForKey:SDWebImageContextDownloadResponseModifier]) &#123;</span><br><span class="line">        responseModifier = [context valueForKey:SDWebImageContextDownloadResponseModifier];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        responseModifier = <span class="keyword">self</span>.responseModifier;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (responseModifier) &#123;</span><br><span class="line">        mutableContext[SDWebImageContextDownloadResponseModifier] = responseModifier;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 解密器</span></span><br><span class="line">    <span class="type">id</span>&lt;SDWebImageDownloaderDecryptor&gt; decryptor;</span><br><span class="line">    <span class="keyword">if</span> ([context valueForKey:SDWebImageContextDownloadDecryptor]) &#123;</span><br><span class="line">        decryptor = [context valueForKey:SDWebImageContextDownloadDecryptor];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        decryptor = <span class="keyword">self</span>.decryptor;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (decryptor) &#123;</span><br><span class="line">        mutableContext[SDWebImageContextDownloadDecryptor] = decryptor;</span><br><span class="line">    &#125;</span><br><span class="line">    context = [mutableContext <span class="keyword">copy</span>];</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 取出指定的NSOperation class</span></span><br><span class="line">    Class operationClass = <span class="keyword">self</span>.config.operationClass;</span><br><span class="line">    <span class="keyword">if</span> (operationClass &amp;&amp; [operationClass isSubclassOfClass:[<span class="built_in">NSOperation</span> <span class="keyword">class</span>]] &amp;&amp; [operationClass conformsToProtocol:<span class="class"><span class="keyword">@protocol</span>(<span class="title">SDWebImageDownloaderOperation</span>)]) </span>&#123;</span><br><span class="line">        <span class="comment">// Custom operation class</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        operationClass = [SDWebImageDownloaderOperation <span class="keyword">class</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将处理过的request，以及 Response 修改器件，解密器放置到NSOperation</span></span><br><span class="line">    <span class="built_in">NSOperation</span>&lt;SDWebImageDownloaderOperation&gt; *operation = [[operationClass alloc] initWithRequest:request inSession:<span class="keyword">self</span>.session options:options context:context];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置认证信息</span></span><br><span class="line">    <span class="keyword">if</span> ([operation respondsToSelector:<span class="keyword">@selector</span>(setCredential:)]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.config.urlCredential) &#123;</span><br><span class="line">            operation.credential = <span class="keyword">self</span>.config.urlCredential;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">self</span>.config.username &amp;&amp; <span class="keyword">self</span>.config.password) &#123;</span><br><span class="line">            operation.credential = [<span class="built_in">NSURLCredential</span> credentialWithUser:<span class="keyword">self</span>.config.username password:<span class="keyword">self</span>.config.password persistence:<span class="built_in">NSURLCredentialPersistenceForSession</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//设置最小的进度</span></span><br><span class="line">    <span class="keyword">if</span> ([operation respondsToSelector:<span class="keyword">@selector</span>(setMinimumProgressInterval:)]) &#123;</span><br><span class="line">        operation.minimumProgressInterval = MIN(MAX(<span class="keyword">self</span>.config.minimumProgressInterval, <span class="number">0</span>), <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置优先级</span></span><br><span class="line">    <span class="keyword">if</span> (options &amp; SDWebImageDownloaderHighPriority) &#123;</span><br><span class="line">        operation.queuePriority = <span class="built_in">NSOperationQueuePriorityHigh</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (options &amp; SDWebImageDownloaderLowPriority) &#123;</span><br><span class="line">        operation.queuePriority = <span class="built_in">NSOperationQueuePriorityLow</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.config.executionOrder == SDWebImageDownloaderLIFOExecutionOrder) &#123;</span><br><span class="line">        <span class="comment">// Emulate LIFO execution order by systematically, each previous adding operation can dependency the new operation</span></span><br><span class="line">        <span class="comment">// This can gurantee the new operation to be execulated firstly, even if when some operations finished, meanwhile you appending new operations</span></span><br><span class="line">        <span class="comment">// Just make last added operation dependents new operation can not solve this problem. See test case #test15DownloaderLIFOExecutionOrder</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSOperation</span> *pendingOperation <span class="keyword">in</span> <span class="keyword">self</span>.downloadQueue.operations) &#123;</span><br><span class="line">            [pendingOperation addDependency:operation];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> operation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看到这里大家可能会有疑问，上面只是构建NSOperation然后添加到downloadQueue中，那么什么时候开始呢？我们看到了NSOperation创建过程如下：</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">NSOperation&lt;SDWebImageDownloaderOperation&gt; *operation = [[operationClass alloc] initWithRequest:request <span class="keyword">inSession:self.session </span>options:options <span class="built_in">context</span>:<span class="built_in">context</span>];</span><br></pre></td></tr></table></figure>
<p>这里持有了NSSession,我们知道网络数据的下载都是依靠NSSession的，所以下载的触发应该也是在NSOperation中。所以我们带着这个问题来看下<strong><strong>SDWebImageDownloaderOperation</strong></strong>从初始化方法中我们可以看到它包含很多重要的组件，具体的见下面注释。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">nonnull</span> <span class="keyword">instancetype</span>)initWithRequest:(<span class="keyword">nullable</span> <span class="built_in">NSURLRequest</span> *)request</span><br><span class="line">                              inSession:(<span class="keyword">nullable</span> <span class="built_in">NSURLSession</span> *)session</span><br><span class="line">                                options:(SDWebImageDownloaderOptions)options</span><br><span class="line">                                context:(<span class="keyword">nullable</span> SDWebImageContext *)context &#123;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">self</span> = [<span class="variable language_">super</span> init])) &#123;</span><br><span class="line">        _request = [request <span class="keyword">copy</span>]; <span class="comment">//当前下载请求NSURLRequest</span></span><br><span class="line">        _options = options;        <span class="comment">//下载选项</span></span><br><span class="line">        _context = [context <span class="keyword">copy</span>]; <span class="comment">//包含一系列组件的上下文</span></span><br><span class="line">        _callbackBlocks = [<span class="built_in">NSMutableArray</span> new];<span class="comment">//进度通知block和下载完成处理block</span></span><br><span class="line">        _responseModifier = context[SDWebImageContextDownloadResponseModifier];<span class="comment">//返回内容修改器</span></span><br><span class="line">        _decryptor = context[SDWebImageContextDownloadDecryptor];<span class="comment">//解码器</span></span><br><span class="line">        _executing = <span class="literal">NO</span>; <span class="comment">//当前状态</span></span><br><span class="line">        _finished = <span class="literal">NO</span>;   <span class="comment">//当前状态</span></span><br><span class="line">        _expectedSize = <span class="number">0</span>;</span><br><span class="line">        _unownedSession = session; <span class="comment">//NSSession</span></span><br><span class="line">        _coderQueue = dispatch_queue_create(<span class="string">&quot;com.hackemist.SDWebImageDownloaderOperationCoderQueue&quot;</span>, DISPATCH_QUEUE_SERIAL);<span class="comment">//解码队列</span></span><br><span class="line">        _backgroundTaskId = <span class="built_in">UIBackgroundTaskInvalid</span>;<span class="comment">//后台id</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们带着大家来解决如下几个问题：</p>
<ol>
<li>SDWebImageDownloaderOperation是如何使用NSSession发起下载请求的？</li>
<li>请求后通过代理返回的数据怎么传到SDWebImageDownloaderOperation中？在SDWebImageDownloaderOperation又是怎么做处理的。</li>
<li>图片下载后是怎么通知给上层的，下载进度又是如何传递的？</li>
</ol>
<p>我们先来看下第一个问题：</p>
<ul>
<li><strong><strong>SDWebImageDownloaderOperation是如何使用NSSession发起下载请求的？</strong></strong></li>
</ul>
<p>这个比较好回答，我们知道NSOperation运行会调用它的start方法，所以我们要回答这个问题也应该从这个方法入手：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="operator">-</span> (void)start &#123;</span><br><span class="line">    <span class="meta">@synchronized</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//开始之前就已经被取消了</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.isCancelled) &#123;</span><br><span class="line">            <span class="keyword">self</span>.finished <span class="operator">=</span> <span class="type">YES</span>;</span><br><span class="line">            <span class="comment">// Operation cancelled by user before sending the request</span></span><br><span class="line">            [<span class="keyword">self</span> callCompletionBlocksWithError:[<span class="type">NSError</span> errorWithDomain:<span class="type">SDWebImageErrorDomain</span> code:<span class="type">SDWebImageErrorCancelled</span> userInfo:<span class="literal">nil</span>]];</span><br><span class="line">            [<span class="keyword">self</span> reset];</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//退出后台后会停止该下载任务</span></span><br><span class="line">        <span class="type">Class</span> <span class="type">UIApplicationClass</span> <span class="operator">=</span> <span class="type">NSClassFromString</span>(@<span class="string">&quot;UIApplication&quot;</span>);</span><br><span class="line">        <span class="type">BOOL</span> hasApplication <span class="operator">=</span> <span class="type">UIApplicationClass</span> <span class="operator">&amp;&amp;</span> [<span class="type">UIApplicationClass</span> respondsToSelector:<span class="meta">@selector</span>(sharedApplication)];</span><br><span class="line">        <span class="keyword">if</span> (hasApplication <span class="operator">&amp;&amp;</span> [<span class="keyword">self</span> shouldContinueWhenAppEntersBackground]) &#123;</span><br><span class="line">            __weak typeof(<span class="keyword">self</span>) wself <span class="operator">=</span> <span class="keyword">self</span>;</span><br><span class="line">            <span class="type">UIApplication</span> <span class="operator">*</span> app <span class="operator">=</span> [<span class="type">UIApplicationClass</span> performSelector:<span class="meta">@selector</span>(sharedApplication)];</span><br><span class="line">            <span class="keyword">self</span>.backgroundTaskId <span class="operator">=</span> [app beginBackgroundTaskWithExpirationHandler:<span class="operator">^</span>&#123;</span><br><span class="line">                [wself cancel];</span><br><span class="line">            &#125;];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//构建session</span></span><br><span class="line">        <span class="type">NSURLSession</span> <span class="operator">*</span>session <span class="operator">=</span> <span class="keyword">self</span>.unownedSession;</span><br><span class="line">        <span class="comment">//......</span></span><br><span class="line">        <span class="comment">//通过session 以及request 创建出一个 dataTask</span></span><br><span class="line">        <span class="keyword">self</span>.dataTask <span class="operator">=</span> [session dataTaskWithRequest:<span class="keyword">self</span>.request];</span><br><span class="line">        <span class="keyword">self</span>.executing <span class="operator">=</span> <span class="type">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.dataTask) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.options <span class="operator">&amp;</span> <span class="type">SDWebImageDownloaderHighPriority</span>) &#123;</span><br><span class="line">            <span class="keyword">self</span>.dataTask.priority <span class="operator">=</span> <span class="type">NSURLSessionTaskPriorityHigh</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">self</span>.options <span class="operator">&amp;</span> <span class="type">SDWebImageDownloaderLowPriority</span>) &#123;</span><br><span class="line">            <span class="keyword">self</span>.dataTask.priority <span class="operator">=</span> <span class="type">NSURLSessionTaskPriorityLow</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//启动下载任务</span></span><br><span class="line">        [<span class="keyword">self</span>.dataTask resume];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">SDWebImageDownloaderProgressBlock</span> progressBlock <span class="keyword">in</span> [<span class="keyword">self</span> callbacksForKey:kProgressCallbackKey]) &#123;</span><br><span class="line">            progressBlock(<span class="number">0</span>, <span class="type">NSURLResponseUnknownLength</span>, <span class="keyword">self</span>.request.<span class="type">URL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//发出启动下载通知</span></span><br><span class="line">        __block typeof(<span class="keyword">self</span>) strongSelf <span class="operator">=</span> <span class="keyword">self</span>;</span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), <span class="operator">^</span>&#123;</span><br><span class="line">            [[<span class="type">NSNotificationCenter</span> defaultCenter] postNotificationName:<span class="type">SDWebImageDownloadStartNotification</span> object:strongSelf];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//.....</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整个过程还是拿传入的request使用NSSession创建出dataTask，然后调用dataTask的resume方法启动下载。下载后数据会从相应的代理方法中获得，但是代理是SDWebImageDownloader，如何将它传给SDWebImageDownloaderOperation呢？我们接下来就来回答这第二个问题，如果看过AFNetWorking源码的对这个流程会比较熟悉，大致相同。</p>
<ul>
<li>*<strong><strong>请求后通过代理返回的数据怎么传到SDWebImageDownloaderOperation中？在SDWebImageDownloaderOperation又是怎么做处理的</strong></strong></li>
</ul>
<p>我们在delegate中拿到的是task，所以我们要通过task找到它所属的NSOperation:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="operator">-</span> (<span class="type">NSOperation</span>&lt;<span class="type">SDWebImageDownloaderOperation</span>&gt; <span class="operator">*</span>)operationWithTask:(<span class="type">NSURLSessionTask</span> <span class="operator">*</span>)task &#123;</span><br><span class="line">    <span class="type">NSOperation</span>&lt;<span class="type">SDWebImageDownloaderOperation</span>&gt; <span class="operator">*</span>returnOperation <span class="operator">=</span> <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">NSOperation</span>&lt;<span class="type">SDWebImageDownloaderOperation</span>&gt; <span class="operator">*</span>operation <span class="keyword">in</span> <span class="keyword">self</span>.downloadQueue.operations) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([operation respondsToSelector:<span class="meta">@selector</span>(dataTask)]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (operation.dataTask.taskIdentifier <span class="operator">==</span> task.taskIdentifier) &#123;</span><br><span class="line">                returnOperation <span class="operator">=</span> operation;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> returnOperation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>嗯，就是通过遍历NSOperation拿当前的task的taskIdentifier与self.downloadQueue.operations中task的taskIdentifier进行匹配，找到所属的NSOperation。</p>
<p>我们下下面的一个代理方法,它就是通过operationWithTask找到对应的NSOperation，然后再调用NSOperation中相对应的方法处理：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session dataTask:(<span class="built_in">NSURLSessionDataTask</span> *)dataTask didReceiveData:(<span class="built_in">NSData</span> *)data &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Identify the operation that runs this task and pass it the delegate method</span></span><br><span class="line">    <span class="built_in">NSOperation</span>&lt;SDWebImageDownloaderOperation&gt; *dataOperation = [<span class="keyword">self</span> operationWithTask:dataTask];</span><br><span class="line">    <span class="keyword">if</span> ([dataOperation respondsToSelector:<span class="keyword">@selector</span>(URLSession:dataTask:didReceiveData:)]) &#123;</span><br><span class="line">        [dataOperation URLSession:session dataTask:dataTask didReceiveData:data];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们接下来看下具体代理的处理：</p>
<p>收到服务端回复的时候会调用didReceiveResponse代理方法，这里主要是通过使用返回体修改器对返回的请求进行处理，然后再进行状态码进行校验。具体见如下代码注释：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</span><br><span class="line">          dataTask:(<span class="built_in">NSURLSessionDataTask</span> *)dataTask</span><br><span class="line">didReceiveResponse:(<span class="built_in">NSURLResponse</span> *)response</span><br><span class="line"> completionHandler:(<span class="type">void</span> (^)(<span class="built_in">NSURLSessionResponseDisposition</span> disposition))completionHandler &#123;</span><br><span class="line">    <span class="built_in">NSURLSessionResponseDisposition</span> disposition = <span class="built_in">NSURLSessionResponseAllow</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Check response modifier, if return nil, will marked as cancelled.</span></span><br><span class="line">    <span class="type">BOOL</span> valid = <span class="literal">YES</span>;</span><br><span class="line">    <span class="comment">// 使用返回体修改器对返回的请求进行处理</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.responseModifier &amp;&amp; response) &#123;</span><br><span class="line">        response = [<span class="keyword">self</span>.responseModifier modifiedResponseWithResponse:response];</span><br><span class="line">        <span class="keyword">if</span> (!response) &#123;</span><br><span class="line">            valid = <span class="literal">NO</span>;</span><br><span class="line">            <span class="keyword">self</span>.responseError = [<span class="built_in">NSError</span> errorWithDomain:SDWebImageErrorDomain code:SDWebImageErrorInvalidDownloadResponse userInfo:<span class="literal">nil</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSInteger</span> expected = (<span class="built_in">NSInteger</span>)response.expectedContentLength;</span><br><span class="line">    expected = expected &gt; <span class="number">0</span> ? expected : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">self</span>.expectedSize = expected;</span><br><span class="line">    <span class="keyword">self</span>.response = response;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//状态码检查</span></span><br><span class="line">    <span class="built_in">NSInteger</span> statusCode = [response respondsToSelector:<span class="keyword">@selector</span>(statusCode)] ? ((<span class="built_in">NSHTTPURLResponse</span> *)response).statusCode : <span class="number">200</span>;</span><br><span class="line">    <span class="comment">// Status code should between [200,400)</span></span><br><span class="line">    <span class="type">BOOL</span> statusCodeValid = statusCode &gt;= <span class="number">200</span> &amp;&amp; statusCode &lt; <span class="number">400</span>;</span><br><span class="line">    <span class="keyword">if</span> (!statusCodeValid) &#123;</span><br><span class="line">        valid = <span class="literal">NO</span>;</span><br><span class="line">        <span class="keyword">self</span>.responseError = [<span class="built_in">NSError</span> errorWithDomain:SDWebImageErrorDomain code:SDWebImageErrorInvalidDownloadStatusCode userInfo:@&#123;SDWebImageErrorDownloadStatusCodeKey : @(statusCode)&#125;];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="comment">//进度提交给应用层上层</span></span><br><span class="line">    <span class="keyword">if</span> (valid) &#123;</span><br><span class="line">        <span class="keyword">for</span> (SDWebImageDownloaderProgressBlock progressBlock <span class="keyword">in</span> [<span class="keyword">self</span> callbacksForKey:kProgressCallbackKey]) &#123;</span><br><span class="line">            progressBlock(<span class="number">0</span>, expected, <span class="keyword">self</span>.request.URL);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        disposition = <span class="built_in">NSURLSessionResponseCancel</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//发出通知</span></span><br><span class="line">    __block <span class="keyword">typeof</span>(<span class="keyword">self</span>) strongSelf = <span class="keyword">self</span>;</span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:SDWebImageDownloadReceiveResponseNotification object:strongSelf];</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (completionHandler) &#123;</span><br><span class="line">        completionHandler(disposition);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在收到图像数据后会回调didReceiveData代理，在didReceiveData中回将收到的图片数据追加到imageData，这里比较关键的是渐进式图片解码，顾名思义就是拿到多少数据就立刻解码交给上层展示，最后将当前下载进度通知给业务层，对应的关键部分看下面的注解：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="operator">-</span> (void)<span class="type">URLSession</span>:(<span class="type">NSURLSession</span> <span class="operator">*</span>)session dataTask:(<span class="type">NSURLSessionDataTask</span> <span class="operator">*</span>)dataTask didReceiveData:(<span class="type">NSData</span> <span class="operator">*</span>)data &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="operator">!</span><span class="keyword">self</span>.imageData) &#123;</span><br><span class="line">        <span class="keyword">self</span>.imageData <span class="operator">=</span> [[<span class="type">NSMutableData</span> alloc] initWithCapacity:<span class="keyword">self</span>.expectedSize];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将数据追加到self.imageData</span></span><br><span class="line">    [<span class="keyword">self</span>.imageData appendData:data];</span><br><span class="line">    <span class="keyword">self</span>.receivedSize <span class="operator">=</span> <span class="keyword">self</span>.imageData.length;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.expectedSize <span class="operator">==</span> <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Unknown expectedSize, immediately call progressBlock and return</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">SDWebImageDownloaderProgressBlock</span> progressBlock <span class="keyword">in</span> [<span class="keyword">self</span> callbacksForKey:kProgressCallbackKey]) &#123;</span><br><span class="line">            progressBlock(<span class="keyword">self</span>.receivedSize, <span class="keyword">self</span>.expectedSize, <span class="keyword">self</span>.request.<span class="type">URL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取当前的下载状态，是否结束</span></span><br><span class="line">    <span class="type">BOOL</span> finished <span class="operator">=</span> (<span class="keyword">self</span>.receivedSize <span class="operator">&gt;=</span> <span class="keyword">self</span>.expectedSize);</span><br><span class="line">    <span class="comment">// 计算当前下载进度</span></span><br><span class="line">    double currentProgress <span class="operator">=</span> (double)<span class="keyword">self</span>.receivedSize <span class="operator">/</span> (double)<span class="keyword">self</span>.expectedSize;</span><br><span class="line">    double previousProgress <span class="operator">=</span> <span class="keyword">self</span>.previousProgress;</span><br><span class="line">    double progressInterval <span class="operator">=</span> currentProgress <span class="operator">-</span> previousProgress;</span><br><span class="line">    <span class="comment">// 只有在大于最小的进度间隔才会通知上层block</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="operator">!</span>finished <span class="operator">&amp;&amp;</span> (progressInterval <span class="operator">&lt;</span> <span class="keyword">self</span>.minimumProgressInterval)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">self</span>.previousProgress <span class="operator">=</span> currentProgress;</span><br><span class="line">    <span class="comment">//如果使用数据解码器将会禁止渐进式解码，</span></span><br><span class="line">    <span class="type">BOOL</span> supportProgressive <span class="operator">=</span> (<span class="keyword">self</span>.options <span class="operator">&amp;</span> <span class="type">SDWebImageDownloaderProgressiveLoad</span>) <span class="operator">&amp;&amp;</span> <span class="operator">!</span><span class="keyword">self</span>.decryptor;</span><br><span class="line">    <span class="keyword">if</span> (supportProgressive) &#123;</span><br><span class="line">        <span class="comment">//获得当前的图片数据</span></span><br><span class="line">        <span class="type">NSData</span> <span class="operator">*</span>imageData <span class="operator">=</span> [<span class="keyword">self</span>.imageData copy];</span><br><span class="line">        <span class="comment">//在解码队列进行渐进式解码</span></span><br><span class="line">        dispatch_async(<span class="keyword">self</span>.coderQueue, <span class="operator">^</span>&#123;</span><br><span class="line">            <span class="meta">@autoreleasepool</span> &#123;</span><br><span class="line">                <span class="type">UIImage</span> <span class="operator">*</span>image <span class="operator">=</span> <span class="type">SDImageLoaderDecodeProgressiveImageData</span>(imageData, <span class="keyword">self</span>.request.<span class="type">URL</span>, finished, <span class="keyword">self</span>, [[<span class="keyword">self</span> <span class="keyword">class</span>] imageOptionsFromDownloaderOptions:<span class="keyword">self</span>.options], <span class="keyword">self</span>.context);</span><br><span class="line">                <span class="keyword">if</span> (image) &#123;</span><br><span class="line">                    <span class="comment">//将数据交给业务层，注意这里的finished为NO,因为还没下载完</span></span><br><span class="line">                    [<span class="keyword">self</span> callCompletionBlocksWithImage:image imageData:<span class="literal">nil</span> error:<span class="literal">nil</span> finished:<span class="type">NO</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从callbacksForKey中取出对应的进度回调block，将进度上传给业务层</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">SDWebImageDownloaderProgressBlock</span> progressBlock <span class="keyword">in</span> [<span class="keyword">self</span> callbacksForKey:kProgressCallbackKey]) &#123;</span><br><span class="line">        progressBlock(<span class="keyword">self</span>.receivedSize, <span class="keyword">self</span>.expectedSize, <span class="keyword">self</span>.request.<span class="type">URL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们重点看下解码部分：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">UIImage<span class="operator"> * </span>_Nullable <span class="constructor">SDImageLoaderDecodeProgressiveImageData(NSData <span class="operator">*</span> <span class="params">_Nonnull</span> <span class="params">imageData</span>, NSURL <span class="operator">*</span> <span class="params">_Nonnull</span> <span class="params">imageURL</span>, BOOL <span class="params">finished</span>,  <span class="params">id</span>&lt;SDWebImageOperation&gt; <span class="params">_Nonnull</span> <span class="params">operation</span>, SDWebImageOptions <span class="params">options</span>, SDWebImageContext <span class="operator">*</span> <span class="params">_Nullable</span> <span class="params">context</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//.......</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取缓存key</span></span><br><span class="line">    UIImage *image;</span><br><span class="line">    id&lt;SDWebImageCacheKeyFilter&gt; cacheKeyFilter = context<span class="literal">[SDW<span class="identifier">ebImageContextCacheKeyFilter</span>]</span>;</span><br><span class="line">    NSString *cacheKey;</span><br><span class="line">    <span class="keyword">if</span> (cacheKeyFilter) &#123;</span><br><span class="line">        cacheKey = <span class="literal">[<span class="identifier">cacheKeyFilter</span> <span class="identifier">cacheKeyForURL</span>:<span class="identifier">imageURL</span>]</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cacheKey = imageURL.absoluteString;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取scale</span></span><br><span class="line">    BOOL decodeFirstFrame = <span class="constructor">SD_OPTIONS_CONTAINS(<span class="params">options</span>, SDWebImageDecodeFirstFrameOnly)</span>;</span><br><span class="line">    NSNumber *scaleValue = context<span class="literal">[SDW<span class="identifier">ebImageContextImageScaleFactor</span>]</span>;</span><br><span class="line">    CGFloat scale = scaleValue.doubleValue &gt;= <span class="number">1</span> ? scaleValue.doubleValue : <span class="constructor">SDImageScaleFactorForKey(<span class="params">cacheKey</span>)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//构建解码Option</span></span><br><span class="line">    SDImageCoderOptions *coderOptions = @&#123;SDImageCoderDecodeFirstFrameOnly : @(decodeFirstFrame), SDImageCoderDecodeScaleFactor : @(scale)&#125;;</span><br><span class="line">    <span class="keyword">if</span> (context) &#123;</span><br><span class="line">        SDImageCoderMutableOptions *mutableCoderOptions = <span class="literal">[<span class="identifier">coderOptions</span> <span class="identifier">mutableCopy</span>]</span>;</span><br><span class="line">        <span class="literal">[<span class="identifier">mutableCoderOptions</span> <span class="identifier">setValue</span>:<span class="identifier">context</span> <span class="identifier">forKey</span>:SDI<span class="identifier">mageCoderWebImageContext</span>]</span>;</span><br><span class="line">        coderOptions = <span class="literal">[<span class="identifier">mutableCoderOptions</span> <span class="identifier">copy</span>]</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取对应的渐进式解码器</span></span><br><span class="line">    id&lt;SDProgressiveImageCoder&gt; progressiveCoder = objc<span class="constructor">_getAssociatedObject(<span class="params">operation</span>, SDImageLoaderProgressiveCoderKey)</span>;</span><br><span class="line">    <span class="keyword">if</span> (!progressiveCoder) &#123;</span><br><span class="line">        <span class="comment">// We need to create a new instance for progressive decoding to avoid conflicts</span></span><br><span class="line">        <span class="keyword">for</span> (id&lt;SDImageCoder&gt;coder <span class="keyword">in</span> <span class="literal">[SDI<span class="identifier">mageCodersManager</span> <span class="identifier">sharedManager</span>]</span>.coders.reverseObjectEnumerator) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="literal">[<span class="identifier">coder</span> <span class="identifier">conformsToProtocol</span>:@<span class="identifier">protocol</span>(SDP<span class="identifier">rogressiveImageCoder</span>)]</span><span class="operator"> &amp;&amp;</span></span><br><span class="line"><span class="operator">                </span><span class="literal">[((<span class="identifier">id</span>&lt;SDP<span class="identifier">rogressiveImageCoder</span>&gt;)<span class="identifier">coder</span>) <span class="identifier">canIncrementalDecodeFromData</span>:<span class="identifier">imageData</span>]</span>) &#123;</span><br><span class="line">                <span class="comment">//通过Options来创建渐进式解码器</span></span><br><span class="line">                progressiveCoder = <span class="literal">[[[<span class="identifier">coder</span> <span class="identifier">class</span>]</span> alloc] initIncrementalWithOptions:coderOptions];</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        objc<span class="constructor">_setAssociatedObject(<span class="params">operation</span>, SDImageLoaderProgressiveCoderKey, <span class="params">progressiveCoder</span>, OBJC_ASSOCIATION_RETAIN_NONATOMIC)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="comment">//将图片数据更新到渐进式解码器</span></span><br><span class="line">    <span class="literal">[<span class="identifier">progressiveCoder</span> <span class="identifier">updateIncrementalData</span>:<span class="identifier">imageData</span> <span class="identifier">finished</span>:<span class="identifier">finished</span>]</span>;</span><br><span class="line">    <span class="comment">//..........</span></span><br><span class="line">    <span class="keyword">if</span> (!image) &#123;</span><br><span class="line">        <span class="comment">//进行解码</span></span><br><span class="line">        image = <span class="literal">[<span class="identifier">progressiveCoder</span> <span class="identifier">incrementalDecodedImageWithOptions</span>:<span class="identifier">coderOptions</span>]</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (image) &#123;</span><br><span class="line">        <span class="comment">//是否需要解码</span></span><br><span class="line">        BOOL shouldDecode = !<span class="constructor">SD_OPTIONS_CONTAINS(<span class="params">options</span>, SDWebImageAvoidDecodeImage)</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">[<span class="identifier">image</span>.<span class="identifier">class</span> <span class="identifier">conformsToProtocol</span>:@<span class="identifier">protocol</span>(SDA<span class="identifier">nimatedImage</span>)]</span>) &#123;</span><br><span class="line">            <span class="comment">// `SDAnimatedImage` do not decode</span></span><br><span class="line">            shouldDecode = NO;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (image.sd_isAnimated) &#123;</span><br><span class="line">            <span class="comment">// animated image do not decode</span></span><br><span class="line">            shouldDecode = NO;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果需要解码则调用decodedImageWithImage进行解码</span></span><br><span class="line">        <span class="keyword">if</span> (shouldDecode) &#123;</span><br><span class="line">            image = <span class="literal">[SDI<span class="identifier">mageCoderHelper</span> <span class="identifier">decodedImageWithImage</span>:<span class="identifier">image</span>]</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        image.sd_isIncremental = YES;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return image;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面最关键的部分在于：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">[progressiveCoder updateIncrementalData:imageData finished:finished];</span><br><span class="line">image = [progressiveCoder incrementalDecodedImageWithOptions:coderOptions];</span><br><span class="line"><span class="keyword">if</span> (image) &#123;</span><br><span class="line">    <span class="comment">//是否需要解码</span></span><br><span class="line">    BOOL shouldDecode = !<span class="built_in">SD_OPTIONS_CONTAINS</span>(options, SDWebImageAvoidDecodeImage);</span><br><span class="line">    <span class="keyword">if</span> ([image.<span class="keyword">class</span> conformsToProtocol:@<span class="built_in">protocol</span>(SDAnimatedImage)]) &#123;</span><br><span class="line">        <span class="comment">// `SDAnimatedImage` do not decode</span></span><br><span class="line">        shouldDecode = NO;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (image.sd_isAnimated) &#123;</span><br><span class="line">        <span class="comment">// animated image do not decode</span></span><br><span class="line">        shouldDecode = NO;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果需要解码则调用decodedImageWithImage进行解码</span></span><br><span class="line">    <span class="keyword">if</span> (shouldDecode) &#123;</span><br><span class="line">        image = [SDImageCoderHelper decodedImageWithImage:image];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// mark the image as progressive (completionBlock one are not mark as progressive)</span></span><br><span class="line">    image.sd_isIncremental = YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里渐进式解码器也有好多种，我们仅仅以其中的一种<strong><strong>SDImageIOAnimatedCoder</strong></strong>为例子：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)updateIncrementalData:(<span class="built_in">NSData</span> *)data finished:(<span class="type">BOOL</span>)finished &#123;</span><br><span class="line">    <span class="comment">//.......</span></span><br><span class="line">    <span class="comment">//更新数据</span></span><br><span class="line">    _imageData = data;</span><br><span class="line">    _finished = finished;</span><br><span class="line">    <span class="comment">//通过接口更新图片数据</span></span><br><span class="line">    <span class="built_in">CGImageSourceUpdateData</span>(_imageSource, (__bridge <span class="built_in">CFDataRef</span>)data, finished);</span><br><span class="line">    <span class="keyword">if</span> (_width + _height == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//读取图片属性</span></span><br><span class="line">        <span class="built_in">CFDictionaryRef</span> properties = <span class="built_in">CGImageSourceCopyPropertiesAtIndex</span>(_imageSource, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (properties) &#123;</span><br><span class="line">            <span class="comment">//获取到图片的宽高</span></span><br><span class="line">            <span class="built_in">CFTypeRef</span> val = <span class="built_in">CFDictionaryGetValue</span>(properties, kCGImagePropertyPixelHeight);</span><br><span class="line">            <span class="keyword">if</span> (val) <span class="built_in">CFNumberGetValue</span>(val, kCFNumberLongType, &amp;_height);</span><br><span class="line">            val = <span class="built_in">CFDictionaryGetValue</span>(properties, kCGImagePropertyPixelWidth);</span><br><span class="line">            <span class="keyword">if</span> (val) <span class="built_in">CFNumberGetValue</span>(val, kCFNumberLongType, &amp;_width);</span><br><span class="line">            <span class="built_in">CFRelease</span>(properties);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//检查帧的有效性</span></span><br><span class="line">    [<span class="keyword">self</span> scanAndCheckFramesValidWithImageSource:_imageSource];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">BOOL</span>)scanAndCheckFramesValidWithImageSource:(<span class="built_in">CGImageSourceRef</span>)imageSource &#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="comment">//获取图片数据的帧数</span></span><br><span class="line">    <span class="built_in">NSUInteger</span> frameCount = <span class="built_in">CGImageSourceGetCount</span>(imageSource);</span><br><span class="line">    <span class="built_in">NSUInteger</span> loopCount = [<span class="keyword">self</span>.class imageLoopCountWithSource:imageSource];</span><br><span class="line">    <span class="built_in">NSMutableArray</span>&lt;SDImageIOCoderFrame *&gt; *frames = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; frameCount; i++) &#123;</span><br><span class="line">        SDImageIOCoderFrame *frame = [[SDImageIOCoderFrame alloc] init];</span><br><span class="line">        <span class="comment">//获取帧序列</span></span><br><span class="line">        frame.index = i;</span><br><span class="line">        <span class="comment">//获取帧时长</span></span><br><span class="line">        frame.duration = [<span class="keyword">self</span>.class frameDurationAtIndex:i source:imageSource];</span><br><span class="line">        <span class="comment">//将其添加到frames</span></span><br><span class="line">        [frames addObject:frame];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    _frameCount = frameCount;</span><br><span class="line">    _loopCount = loopCount;</span><br><span class="line">    _frames = [frames <span class="keyword">copy</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">UIImage</span> *)incrementalDecodedImageWithOptions:(SDImageCoderOptions *)options &#123;</span><br><span class="line">    <span class="built_in">UIImage</span> *image;</span><br><span class="line">    <span class="keyword">if</span> (_width + _height &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 取出当前的第一帧</span></span><br><span class="line">        <span class="built_in">CGImageRef</span> partialImageRef = <span class="built_in">CGImageSourceCreateImageAtIndex</span>(_imageSource, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (partialImageRef) &#123;</span><br><span class="line">            <span class="built_in">CGFloat</span> scale = _scale;</span><br><span class="line">            <span class="built_in">NSNumber</span> *scaleFactor = options[SDImageCoderDecodeScaleFactor];</span><br><span class="line">            <span class="keyword">if</span> (scaleFactor != <span class="literal">nil</span>) &#123;</span><br><span class="line">                scale = MAX([scaleFactor doubleValue], <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            image = [[<span class="built_in">UIImage</span> alloc] initWithCGImage:partialImageRef scale:scale orientation:<span class="built_in">UIImageOrientationUp</span>];</span><br><span class="line">            <span class="built_in">CGImageRelease</span>(partialImageRef);</span><br><span class="line">            image.sd_imageFormat = <span class="keyword">self</span>.class.imageFormat;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> image;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码主要就是在数据帧来的时候更新数据源，然后解码数据，取出当前帧的第一帧构建后返回。</p>
<p>紧接着就会根据当前的情况除了动图都会对其进行解码，我们来看下解码部分的代码：</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">+ (UIImage *)decodedImageWithImage:(UIImage *)<span class="built_in">image</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (![self shouldDecodeImage:<span class="built_in">image</span>]) &#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="built_in">image</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    CGImageRef imageRef = [self CGImageCreateDecoded:<span class="built_in">image</span>.CGImage];</span><br><span class="line">    <span class="keyword">if</span> (!imageRef) &#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="built_in">image</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    UIImage *decodedImage = [[UIImage alloc] initWithCGImage:imageRef <span class="built_in">scale</span>:<span class="built_in">image</span>.<span class="built_in">scale</span> <span class="built_in">orientation</span>:<span class="built_in">image</span>.imageOrientation];</span><br><span class="line">    CGImageRelease(imageRef);</span><br><span class="line">    decodedImage.sd_isDecoded = YES;</span><br><span class="line">    decodedImage.sd_imageFormat = <span class="built_in">image</span>.sd_imageFormat;</span><br><span class="line">    <span class="built_in">return</span> decodedImage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>嗯，这块不是很难，过一下就可以了。</p>
<p>最后我们看下下载完成后的处理：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="operator">-</span> (void)<span class="type">URLSession</span>:(<span class="type">NSURLSession</span> <span class="operator">*</span>)session task:(<span class="type">NSURLSessionTask</span> <span class="operator">*</span>)task didCompleteWithError:(<span class="type">NSError</span> <span class="operator">*</span>)error &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        <span class="comment">//.........</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> ([<span class="keyword">self</span> callbacksForKey:kCompletedCallbackKey].count <span class="operator">&gt;</span> <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">NSData</span> <span class="operator">*</span>imageData <span class="operator">=</span> [<span class="keyword">self</span>.imageData copy];</span><br><span class="line">            <span class="keyword">self</span>.imageData <span class="operator">=</span> <span class="literal">nil</span>;</span><br><span class="line">            <span class="comment">// 使用数据解密器对图片数据进行解密</span></span><br><span class="line">            <span class="keyword">if</span> (imageData <span class="operator">&amp;&amp;</span> <span class="keyword">self</span>.decryptor) &#123;</span><br><span class="line">                imageData <span class="operator">=</span> [<span class="keyword">self</span>.decryptor decryptedDataWithData:imageData response:<span class="keyword">self</span>.response];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (imageData) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">self</span>.options <span class="operator">&amp;</span> <span class="type">SDWebImageDownloaderIgnoreCachedResponse</span> <span class="operator">&amp;&amp;</span> [<span class="keyword">self</span>.cachedData isEqualToData:imageData]) &#123;</span><br><span class="line">                    <span class="comment">//...........</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 对图像数据进行解码</span></span><br><span class="line">                    dispatch_async(<span class="keyword">self</span>.coderQueue, <span class="operator">^</span>&#123;</span><br><span class="line">                        <span class="meta">@autoreleasepool</span> &#123;</span><br><span class="line">                            <span class="type">UIImage</span> <span class="operator">*</span>image <span class="operator">=</span> <span class="type">SDImageLoaderDecodeImageData</span>(imageData, <span class="keyword">self</span>.request.<span class="type">URL</span>, [[<span class="keyword">self</span> <span class="keyword">class</span>] imageOptionsFromDownloaderOptions:<span class="keyword">self</span>.options], <span class="keyword">self</span>.context);</span><br><span class="line">                            <span class="type">CGSize</span> imageSize <span class="operator">=</span> image.size;</span><br><span class="line">                            <span class="keyword">if</span> (imageSize.width <span class="operator">==</span> <span class="number">0</span> <span class="operator">||</span> imageSize.height <span class="operator">==</span> <span class="number">0</span>) &#123;</span><br><span class="line">                                [<span class="keyword">self</span> callCompletionBlocksWithError:[<span class="type">NSError</span> errorWithDomain:<span class="type">SDWebImageErrorDomain</span> code:<span class="type">SDWebImageErrorBadImageData</span> userInfo:@&#123;NSLocalizedDescriptionKey : @<span class="string">&quot;Downloaded image has 0 pixels&quot;</span>&#125;]];</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                [<span class="keyword">self</span> callCompletionBlocksWithImage:image imageData:imageData error:<span class="literal">nil</span> finished:<span class="type">YES</span>];</span><br><span class="line">                            &#125;</span><br><span class="line">                            [<span class="keyword">self</span> done];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//......</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            [<span class="keyword">self</span> done];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下载完成后首先会对数据进行解密，然后再对解密后的数据进行解码，最后将数据通过block传递到业务层。<br>解密部分是通过<strong><strong>SDImageLoaderDecodeImageData</strong></strong>方法,这部分代码和上面介绍渐进式解码的类似，这里只注重流程，先不对这部分细节进行展开了。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">UIImage<span class="operator"> * </span>_Nullable <span class="constructor">SDImageLoaderDecodeImageData(NSData <span class="operator">*</span> <span class="params">_Nonnull</span> <span class="params">imageData</span>, NSURL <span class="operator">*</span> <span class="params">_Nonnull</span> <span class="params">imageURL</span>, SDWebImageOptions <span class="params">options</span>, SDWebImageContext <span class="operator">*</span> <span class="params">_Nullable</span> <span class="params">context</span>)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="comment">//调用解码器进行解码</span></span><br><span class="line">    <span class="keyword">if</span> (!image) &#123;</span><br><span class="line">        image = <span class="literal">[[SDI<span class="identifier">mageCodersManager</span> <span class="identifier">sharedManager</span>]</span> decodedImageWithData:imageData options:coderOptions];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (image) &#123;</span><br><span class="line">        BOOL shouldDecode = !<span class="constructor">SD_OPTIONS_CONTAINS(<span class="params">options</span>, SDWebImageAvoidDecodeImage)</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">[<span class="identifier">image</span>.<span class="identifier">class</span> <span class="identifier">conformsToProtocol</span>:@<span class="identifier">protocol</span>(SDA<span class="identifier">nimatedImage</span>)]</span>) &#123;</span><br><span class="line">            <span class="comment">// `SDAnimatedImage` do not decode</span></span><br><span class="line">            shouldDecode = NO;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (image.sd_isAnimated) &#123;</span><br><span class="line">            <span class="comment">// animated image do not decode</span></span><br><span class="line">            shouldDecode = NO;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (shouldDecode) &#123;</span><br><span class="line">            BOOL shouldScaleDown = <span class="constructor">SD_OPTIONS_CONTAINS(<span class="params">options</span>, SDWebImageScaleDownLargeImages)</span>;</span><br><span class="line">            <span class="keyword">if</span> (shouldScaleDown) &#123;</span><br><span class="line">                image = <span class="literal">[SDI<span class="identifier">mageCoderHelper</span> <span class="identifier">decodedAndScaledDownImageWithImage</span>:<span class="identifier">image</span> <span class="identifier">limitBytes</span>:<span class="number">0</span>]</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                image = <span class="literal">[SDI<span class="identifier">mageCoderHelper</span> <span class="identifier">decodedImageWithImage</span>:<span class="identifier">image</span>]</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return image;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到目前为止已经带大家过了一遍整个图片下载的流程，在解码结束后通过completeBlock交给上层后还没结束，我们看下completeBlock到底做了啥，让我们回到callDownloadProcessForOperation：</p>
<p>下面是completeBlock代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="meta">@strongify</span>(operation);</span><br><span class="line"><span class="comment">//用户取消请求</span></span><br><span class="line"><span class="keyword">if</span> (<span class="operator">!</span>operation <span class="operator">||</span> operation.isCancelled) &#123;</span><br><span class="line">    [<span class="keyword">self</span> callCompletionBlockForOperation:operation completion:completedBlock error:[<span class="type">NSError</span> errorWithDomain:<span class="type">SDWebImageErrorDomain</span> code:<span class="type">SDWebImageErrorCancelled</span> userInfo:<span class="literal">nil</span>] url:url];</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (cachedImage <span class="operator">&amp;&amp;</span> options <span class="operator">&amp;</span> <span class="type">SDWebImageRefreshCached</span> <span class="operator">&amp;&amp;</span> [error.domain isEqualToString:<span class="type">SDWebImageErrorDomain</span>] <span class="operator">&amp;&amp;</span> error.code <span class="operator">==</span> <span class="type">SDWebImageErrorCacheNotModified</span>) &#123;</span><br><span class="line">    <span class="comment">// 强制刷新缓存的时候，在前面先将缓存图片通过completeBlock 将数据传递给上层，到这里将数据加载完毕后，不做任何操作</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> ([error.domain isEqualToString:<span class="type">SDWebImageErrorDomain</span>] <span class="operator">&amp;&amp;</span> error.code <span class="operator">==</span> <span class="type">SDWebImageErrorCancelled</span>) &#123;</span><br><span class="line">    <span class="comment">// 将错误交给上层</span></span><br><span class="line">    [<span class="keyword">self</span> callCompletionBlockForOperation:operation completion:completedBlock error:error url:url];</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (error) &#123;</span><br><span class="line">    [<span class="keyword">self</span> callCompletionBlockForOperation:operation completion:completedBlock error:error url:url];</span><br><span class="line">    <span class="comment">//是否需要将错误的URL添加到failedURLs</span></span><br><span class="line">    <span class="type">BOOL</span> shouldBlockFailedURL <span class="operator">=</span> [<span class="keyword">self</span> shouldBlockFailedURLWithURL:url error:error];</span><br><span class="line">    <span class="keyword">if</span> (shouldBlockFailedURL) &#123;</span><br><span class="line">        <span class="type">SD_LOCK</span>(<span class="keyword">self</span>.failedURLsLock);</span><br><span class="line">        [<span class="keyword">self</span>.failedURLs addObject:url];</span><br><span class="line">        <span class="type">SD_UNLOCK</span>(<span class="keyword">self</span>.failedURLsLock);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 成功</span></span><br><span class="line">    <span class="comment">//如果SDWebImageRetryFailed = 1 表示错误的url需要重试，这时候就要将当前的url从failedURLs移除</span></span><br><span class="line">    <span class="keyword">if</span> ((options <span class="operator">&amp;</span> <span class="type">SDWebImageRetryFailed</span>)) &#123;</span><br><span class="line">        <span class="type">SD_LOCK</span>(<span class="keyword">self</span>.failedURLsLock);</span><br><span class="line">        [<span class="keyword">self</span>.failedURLs removeObject:url];</span><br><span class="line">        <span class="type">SD_UNLOCK</span>(<span class="keyword">self</span>.failedURLsLock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//成功后会对当前数据进行缓存</span></span><br><span class="line">    [<span class="keyword">self</span> callStoreCacheProcessForOperation:operation url:url options:options context:context downloadedImage:downloadedImage downloadedData:downloadedData finished:finished progress:progressBlock completed:completedBlock];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (finished) &#123;</span><br><span class="line">    <span class="comment">//加载成功后将操作从Running队列中移除</span></span><br><span class="line">    [<span class="keyword">self</span> safelyRemoveOperationFromRunning:operation];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>completeBlock里面有很多的情况会调到，比如NSOperation被取消，发生错误，成功等，下面我们只强调如下几种情况：</p>
<ul>
<li>下载失败的处理方式</li>
</ul>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">[<span class="built_in">self</span> callCompletionBlockForOperation:operation completion:completedBlock <span class="built_in">error</span>:<span class="built_in">error</span> url:url];</span><br><span class="line">//是否需要将错误的URL添加到failedURLs</span><br><span class="line">BOOL shouldBlockFailedURL = [<span class="built_in">self</span> shouldBlockFailedURLWithURL:url <span class="built_in">error</span>:<span class="built_in">error</span>];</span><br><span class="line"><span class="keyword">if</span> (shouldBlockFailedURL) &#123;</span><br><span class="line">    SD_LOCK(<span class="built_in">self</span>.failedURLsLock);</span><br><span class="line">    [<span class="built_in">self</span>.failedURLs addObject:url];</span><br><span class="line">    SD_UNLOCK(<span class="built_in">self</span>.failedURLsLock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果下载失败那么会将错误通过callCompletionBlockForOperation将错误返回给业务层，并且会将错误的url添加到failedURLs，如果我们配置不重试错误的url，那么在failedURLs数组中的url将不会发起请求。</p>
<ul>
<li>下载成功的处理方式</li>
</ul>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如果SDWebImageRetryFailed = 1 表示错误的url需要重试，这时候就要将当前的url从failedURLs移除</span></span><br><span class="line">if ((options &amp; SDWebImageRetryFailed)) &#123;</span><br><span class="line">    <span class="built_in">SD_LOCK</span>(self.failedURLsLock);</span><br><span class="line">    <span class="selector-attr">[self.failedURLs removeObject:url]</span>;</span><br><span class="line">    <span class="built_in">SD_UNLOCK</span>(self.failedURLsLock);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//成功后会对当前数据进行缓存</span></span><br><span class="line"><span class="selector-attr">[self callStoreCacheProcessForOperation:operation url:url options:options context:context downloadedImage:downloadedImage downloadedData:downloadedData finished:finished progress:progressBlock completed:completedBlock]</span>;</span><br></pre></td></tr></table></figure>

<p>和上面相反，如果下载成功后会将之前添加到failedURLs的url移除，然后调用callStoreCacheProcessForOperation将数据添加到缓存中。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)callStoreCacheProcessForOperation:(<span class="keyword">nonnull</span> SDWebImageCombinedOperation *)operation</span><br><span class="line">                                      url:(<span class="keyword">nonnull</span> <span class="built_in">NSURL</span> *)url</span><br><span class="line">                                  options:(SDWebImageOptions)options</span><br><span class="line">                                  context:(SDWebImageContext *)context</span><br><span class="line">                          downloadedImage:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)downloadedImage</span><br><span class="line">                           downloadedData:(<span class="keyword">nullable</span> <span class="built_in">NSData</span> *)downloadedData</span><br><span class="line">                                 finished:(<span class="type">BOOL</span>)finished</span><br><span class="line">                                 progress:(<span class="keyword">nullable</span> SDImageLoaderProgressBlock)progressBlock</span><br><span class="line">                                completed:(<span class="keyword">nullable</span> SDInternalCompletionBlock)completedBlock &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取缓存类型</span></span><br><span class="line">    SDImageCacheType storeCacheType = SDImageCacheTypeAll;</span><br><span class="line">    <span class="keyword">if</span> (context[SDWebImageContextStoreCacheType]) &#123;</span><br><span class="line">        storeCacheType = [context[SDWebImageContextStoreCacheType] integerValue];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    SDImageCacheType originalStoreCacheType = SDImageCacheTypeNone;</span><br><span class="line">    <span class="keyword">if</span> (context[SDWebImageContextOriginalStoreCacheType]) &#123;</span><br><span class="line">        originalStoreCacheType = [context[SDWebImageContextOriginalStoreCacheType] integerValue];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//生成缓存key</span></span><br><span class="line">    <span class="type">id</span>&lt;SDWebImageCacheKeyFilter&gt; cacheKeyFilter = context[SDWebImageContextCacheKeyFilter];</span><br><span class="line">    <span class="built_in">NSString</span> *key = [<span class="keyword">self</span> cacheKeyForURL:url cacheKeyFilter:cacheKeyFilter];</span><br><span class="line">    <span class="comment">//图片转换器</span></span><br><span class="line">    <span class="type">id</span>&lt;SDImageTransformer&gt; transformer = context[SDWebImageContextImageTransformer];</span><br><span class="line">    <span class="comment">//缓存图片处理器</span></span><br><span class="line">    <span class="type">id</span>&lt;SDWebImageCacheSerializer&gt; cacheSerializer = context[SDWebImageContextCacheSerializer];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//是否需要对图片进行处理</span></span><br><span class="line">    <span class="type">BOOL</span> shouldTransformImage = downloadedImage &amp;&amp; (!downloadedImage.sd_isAnimated || (options &amp; SDWebImageTransformAnimatedImage)) &amp;&amp; transformer;</span><br><span class="line">    <span class="comment">//是否缓存原始图片</span></span><br><span class="line">    <span class="type">BOOL</span> shouldCacheOriginal = downloadedImage &amp;&amp; finished;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//原图缓存</span></span><br><span class="line">    <span class="comment">//需要缓存原始图片的情况下</span></span><br><span class="line">    <span class="keyword">if</span> (shouldCacheOriginal) &#123;</span><br><span class="line">        <span class="comment">//正常情况下我们使用cache type，但是如果目标图片是转换过的，我们会使用original 存储缓存类型来缓存</span></span><br><span class="line">        SDImageCacheType targetStoreCacheType = shouldTransformImage ? originalStoreCacheType : storeCacheType;</span><br><span class="line">        <span class="keyword">if</span> (cacheSerializer &amp;&amp; (targetStoreCacheType == SDImageCacheTypeDisk || targetStoreCacheType == SDImageCacheTypeAll)) &#123;</span><br><span class="line">            <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, <span class="number">0</span>), ^&#123;</span><br><span class="line">                <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">                    <span class="comment">//将数据通过cacheSerializer处理后返回</span></span><br><span class="line">                    <span class="built_in">NSData</span> *cacheData = [cacheSerializer cacheDataWithImage:downloadedImage originalData:downloadedData imageURL:url];</span><br><span class="line">                    <span class="comment">//将数据添加到缓存中，具体缓存到哪里根据targetStoreCacheType类型</span></span><br><span class="line">                    [<span class="keyword">self</span>.imageCache storeImage:downloadedImage imageData:cacheData forKey:key cacheType:targetStoreCacheType completion:<span class="literal">nil</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            [<span class="keyword">self</span>.imageCache storeImage:downloadedImage imageData:downloadedData forKey:key cacheType:targetStoreCacheType completion:<span class="literal">nil</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 转换后图片缓存</span></span><br><span class="line">    <span class="keyword">if</span> (shouldTransformImage) &#123;</span><br><span class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, <span class="number">0</span>), ^&#123;</span><br><span class="line">            <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">                <span class="comment">//对数据进行转换</span></span><br><span class="line">                <span class="built_in">UIImage</span> *transformedImage = [transformer transformedImageWithImage:downloadedImage forKey:key];</span><br><span class="line">                <span class="keyword">if</span> (transformedImage &amp;&amp; finished) &#123;</span><br><span class="line">                    <span class="built_in">NSString</span> *transformerKey = [transformer transformerKey];</span><br><span class="line">                    <span class="comment">//缓存的图片带转换信息</span></span><br><span class="line">                    <span class="built_in">NSString</span> *cacheKey = SDTransformedKeyForKey(key, transformerKey);</span><br><span class="line">                    <span class="comment">//判断图片是否被转换成功</span></span><br><span class="line">                    <span class="type">BOOL</span> imageWasTransformed = ![transformedImage isEqual:downloadedImage];</span><br><span class="line">                    <span class="built_in">NSData</span> *cacheData;</span><br><span class="line">                    <span class="comment">// pass nil if the image was transformed, so we can recalculate the data from the image</span></span><br><span class="line">                    <span class="keyword">if</span> (cacheSerializer &amp;&amp; (storeCacheType == SDImageCacheTypeDisk || storeCacheType == SDImageCacheTypeAll)) &#123;</span><br><span class="line">                        <span class="comment">//将数据通过cacheSerializer处理后返回</span></span><br><span class="line">                        cacheData = [cacheSerializer cacheDataWithImage:transformedImage  originalData:(imageWasTransformed ? <span class="literal">nil</span> : downloadedData) imageURL:url];</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        cacheData = (imageWasTransformed ? <span class="literal">nil</span> : downloadedData);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//缓存图片数据</span></span><br><span class="line">                    [<span class="keyword">self</span>.imageCache storeImage:transformedImage imageData:cacheData forKey:cacheKey cacheType:storeCacheType completion:<span class="literal">nil</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//将结果传递到业务层</span></span><br><span class="line">                [<span class="keyword">self</span> callCompletionBlockForOperation:operation completion:completedBlock image:transformedImage data:downloadedData error:<span class="literal">nil</span> cacheType:SDImageCacheTypeNone finished:finished url:url];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        [<span class="keyword">self</span> callCompletionBlockForOperation:operation completion:completedBlock image:downloadedImage data:downloadedData error:<span class="literal">nil</span> cacheType:SDImageCacheTypeNone finished:finished url:url];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="2-3-设置图片"><a href="#2-3-设置图片" class="headerlink" title="2.3 设置图片"></a>2.3 设置图片</h6><p>设置图片环节比较简单就是根据view的类型来设置对应的finalSetImageBlock，然后看是否有过场动画，如果有则播放过场动画后执行finalSetImageBlock。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)sd_setImage:(<span class="built_in">UIImage</span> *)image imageData:(<span class="built_in">NSData</span> *)imageData basedOnClassOrViaCustomSetImageBlock:(SDSetImageBlock)setImageBlock transition:(SDWebImageTransition *)transition cacheType:(SDImageCacheType)cacheType imageURL:(<span class="built_in">NSURL</span> *)imageURL &#123;</span><br><span class="line">    <span class="comment">// 根据view的类型来设置对应的finalSetImageBlock</span></span><br><span class="line">    <span class="built_in">UIView</span> *view = <span class="keyword">self</span>;</span><br><span class="line">    SDSetImageBlock finalSetImageBlock;</span><br><span class="line">    <span class="keyword">if</span> (setImageBlock) &#123;</span><br><span class="line">        finalSetImageBlock = setImageBlock;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([view isKindOfClass:[<span class="built_in">UIImageView</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="built_in">UIImageView</span> *imageView = (<span class="built_in">UIImageView</span> *)view;</span><br><span class="line">        finalSetImageBlock = ^(<span class="built_in">UIImage</span> *setImage, <span class="built_in">NSData</span> *setImageData, SDImageCacheType setCacheType, <span class="built_in">NSURL</span> *setImageURL) &#123;</span><br><span class="line">            imageView.image = setImage;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ([view isKindOfClass:[<span class="built_in">UIButton</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="built_in">UIButton</span> *button = (<span class="built_in">UIButton</span> *)view;</span><br><span class="line">        finalSetImageBlock = ^(<span class="built_in">UIImage</span> *setImage, <span class="built_in">NSData</span> *setImageData, SDImageCacheType setCacheType, <span class="built_in">NSURL</span> *setImageURL) &#123;</span><br><span class="line">            [button setImage:setImage forState:<span class="built_in">UIControlStateNormal</span>];</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//播放过场动画</span></span><br><span class="line">    <span class="keyword">if</span> (transition) &#123;</span><br><span class="line">        [<span class="built_in">UIView</span> transitionWithView:view duration:<span class="number">0</span> options:<span class="number">0</span> animations:^&#123;</span><br><span class="line">            <span class="comment">// 0 duration to let UIKit render placeholder and prepares block</span></span><br><span class="line">            <span class="keyword">if</span> (transition.prepares) &#123;</span><br><span class="line">                transition.prepares(view, image, imageData, cacheType, imageURL);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; completion:^(<span class="type">BOOL</span> finished) &#123;</span><br><span class="line">            [<span class="built_in">UIView</span> transitionWithView:view duration:transition.duration options:transition.animationOptions animations:^&#123;</span><br><span class="line">                <span class="keyword">if</span> (finalSetImageBlock &amp;&amp; !transition.avoidAutoSetImage) &#123;</span><br><span class="line">                    <span class="comment">//执行finalSetImageBlock</span></span><br><span class="line">                    finalSetImageBlock(image, imageData, cacheType, imageURL);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (transition.animations) &#123;</span><br><span class="line">                    transition.animations(view, image);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; completion:transition.completion];</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果没有过场动画直接执行finalSetImageBlock</span></span><br><span class="line">        <span class="keyword">if</span> (finalSetImageBlock) &#123;</span><br><span class="line">            finalSetImageBlock(image, imageData, cacheType, imageURL);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简要流程如下图所示：<br><img src="/2019/11/30/SDWebImage-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/00006.png"></p>
<h6 id="2-4-整体架构总结"><a href="#2-4-整体架构总结" class="headerlink" title="2.4 整体架构总结"></a>2.4 整体架构总结</h6><p>上面几个章节我们将整个流程过了一遍，接下来我们将会从宏观的角度来浏览下整个架构，整个SDWebImage代码量还是蛮庞大的，所以如果没有缕清整个结构的话很容易陷入代码之中，SDWebImage之所以大主要是因为它整个架构可定制的部件多，并且每个部件都可以有不同的选择，这种框架最适合采用Core+Plugin形式，SDWebImage 有个不足的地方就是代码的目录管理做得不好，整个庞大的项目都堆到一个目录下，让刚接触SDWebImage会显得毫无头绪，下面是重新组织的目录结构：</p>
<p><img src="/2019/11/30/SDWebImage-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/00003.png"></p>
<p>下面是SDWebImage官方的架构图，以及关键的类图：</p>
<p><img src="/2019/11/30/SDWebImage-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/00002.jpeg"><br><img src="/2019/11/30/SDWebImage-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/00004.png"><br><img src="/2019/11/30/SDWebImage-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/00005.png"></p>
<p>下面我们结合上面三张图来过一遍整个项目：</p>
<p><strong><strong>1. 常用控件的分类</strong></strong><br>SDWebImage为UIImageView,NSButton,SDAnimatedImageView这些类都创建了对应都分类，方便这些类加载网络图片资源，大家可以通过搜索+WebCache或者+HightlightedWebCache可以找到这些分类。这些分类中除了提供设置网络图片的方法外，还提供了设置下载指示器，以及图片转换处理器等方法。<strong><strong>UIView+WebCache.h</strong></strong>是这些分类的基础。</p>
<p><strong><strong>2. 图片预取器</strong></strong></p>
<p><strong><strong>SDWebImagePrefetcher</strong></strong> 用于图片的预取：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">nullable</span> SDWebImagePrefetchToken *)prefetchURLs:(<span class="keyword">nullable</span> <span class="built_in">NSArray</span>&lt;<span class="built_in">NSURL</span> *&gt; *)urls;</span><br></pre></td></tr></table></figure>
<p>这个是专门供外部使用的，SDWebImageView内部并没有使用到这个类.图片预取顾名思义就是在没使用图片之前就先将图片给下载到缓存中，这样使用的时候加载速度就会块很多，这一般是针对比较常用的图片资源。<strong><strong>SDWebImagePrefetcherDelegate</strong></strong> 会在全部下载结束后，或者单个资源下载完成后进行回调。</p>
<p><strong><strong>3. 图片管理器</strong></strong></p>
<p><img src="/2019/11/30/SDWebImage-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/00007.png"></p>
<p><strong><strong>SDWebImageManager</strong></strong>是整个SDWebImage的核心它持有：</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="bullet">* </span>imageLoader（遵循SDImageLoader）用于从网络上加载图片</span><br><span class="line"><span class="bullet">* </span>mageCache（遵循SDImageCache）用于从缓存中获取图片</span><br><span class="line"><span class="bullet">* </span>cacheKeyFilter（遵循SDWebImageCacheKeyFilter）用于缓存key的生成</span><br><span class="line"><span class="bullet">* </span>cacheSerializer（遵循SDWebImageCacheSerializer）用于对解码后的图片数据进行序列化</span><br><span class="line"><span class="bullet">* </span>transformer（遵循SDImageTransformer）用于图片后期处理</span><br><span class="line"><span class="bullet">* </span>optionsProcessor（遵循SDWebImageOptionsProcessor）用于提供全局的option设置。</span><br></pre></td></tr></table></figure>

<p>它通过：</p>
<figure class="highlight erlang"><table><tr><td class="code"><pre><span class="line">- <span class="params">(nullable SDWebImageCombinedOperation *)</span>loadImageWithURL:<span class="params">(nullable NSURL *)</span>url</span><br><span class="line">                                                   options:<span class="params">(SDWebImageOptions)</span>options</span><br><span class="line">                                                   context:<span class="params">(nullable SDWebImageContext *)</span>context</span><br><span class="line">                                                  progress:<span class="params">(nullable SDImageLoaderProgressBlock)</span>progressBlock</span><br><span class="line">                                                 completed:<span class="params">(nonnull SDInternalCompletionBlock)</span>completedBlock;</span><br></pre></td></tr></table></figure>
<p>加载图片，这里面包含了全部的加载策略，是整个库的核心</p>
<p>还提供了取消下载的接口：</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">- (void)cancelAll<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>以及查询key的接口:</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)cacheKeyForURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url;</span><br></pre></td></tr></table></figure>

<p>代理<strong><strong>SDWebImageManagerDelegate</strong></strong></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">用于判断某个URL是否需要下载</span><br><span class="line">- (<span class="type">BOOL</span>)imageManager:(<span class="keyword">nonnull</span> SDWebImageManager *)imageManager shouldDownloadImageForURL:(<span class="keyword">nonnull</span> <span class="built_in">NSURL</span> *)imageURL;</span><br><span class="line">用于判断某个URL发生某个错误是否将其标记为失败的URL</span><br><span class="line">- (<span class="type">BOOL</span>)imageManager:(<span class="keyword">nonnull</span> SDWebImageManager *)imageManager shouldBlockFailedURL:(<span class="keyword">nonnull</span> <span class="built_in">NSURL</span> *)imageURL withError:(<span class="keyword">nonnull</span> <span class="built_in">NSError</span> *)error;</span><br></pre></td></tr></table></figure>

<p><strong><strong>3.1 图片转换器</strong></strong></p>
<p>图片转换器是存放在context中的，key为<strong><strong>SDWebImageContextImageTransformer</strong></strong>，与图片转换器有关的文件如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">UIImage+Transform.h/.m</span><br><span class="line">SDImageTransformer.h/.m</span><br></pre></td></tr></table></figure>

<p>UIImage+Transform主要是图片转换的实际处理分类，而SDImageTransformer则是负责上层调度的，它会调度UIImage+Transform中的方法对图片进行处理。</p>
<p>我们看下SDWebImage都提供了哪些图片转换器：</p>
<p><strong><strong>SDImagePipelineTransformer 串行流水线图片处理器</strong></strong><br>之前一直有疑问，context中只能存放一个图片处理器，如果我们需要连续应用多个处理呢？这个对图片库来说是很常见的一个功能，SDImagePipelineTransformer就是用于这种用途，我们只要将所有的处理器添加到transformers数组中就会被应用到当前图片上。<br><strong><strong>SDImageRoundCornerTransformer 图片圆角处理器</strong></strong><br>可以指定圆角半径，边界线宽，边界线颜色，圆角位置<br><strong><strong>SDImageResizingTransformer 缩放处理器</strong></strong><br><strong><strong>SDImageCroppingTransformer 裁剪处理器</strong></strong><br><strong><strong>SDImageFlippingTransformer 翻转处理器</strong></strong><br><strong><strong>SDImageRotationTransformer 旋转处理器</strong></strong><br><strong><strong>SDImageTintTransformer     颜色修改处理器</strong></strong><br><strong><strong>SDImageBlurTransformer     模糊处理器</strong></strong><br><strong><strong>SDImageFilterTransformer   滤镜处理器</strong></strong> </p>
<p><strong><strong>3.2 图片加载器</strong></strong></p>
<p>涉及到的类主要有：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">SDImageLoader.h/.m</span><br><span class="line">SDImageLoadersManager.h/.m</span><br></pre></td></tr></table></figure>

<p>SDImageLoader里面主要定义了两个解码相关的静态方法<strong><strong>SDImageLoaderDecodeImageData</strong></strong>，<strong><strong>SDImageLoaderDecodeProgressiveImageData</strong></strong>，以及SDImageLoader协议。而SDImageLoadersManager则负责管理全部的loader，每个SDWebImageManager都只有一个SDImageLoadersManager，但是SDImageLoadersManager里面却管理着一系列的SDImageLoader，所以整个SDWebImage相当于由多个loader构成。<br>我们这里看下SDImageLoader</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断当前url是否需要下载</span></span><br><span class="line">- (<span class="type">BOOL</span>)canRequestImageForURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url;</span><br><span class="line"></span><br><span class="line"><span class="comment">//请求图片下载</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="type">id</span>&lt;SDWebImageOperation&gt;)requestImageWithURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url</span><br><span class="line">                                                options:(SDWebImageOptions)options</span><br><span class="line">                                                context:(<span class="keyword">nullable</span> SDWebImageContext *)context</span><br><span class="line">                                               progress:(<span class="keyword">nullable</span> SDImageLoaderProgressBlock)progressBlock</span><br><span class="line">                                              completed:(<span class="keyword">nullable</span> SDImageLoaderCompletedBlock)completedBlock;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断某个URL发生某个错误的时候是否需要将它判定为失败的url</span></span><br><span class="line">- (<span class="type">BOOL</span>)shouldBlockFailedURLWithURL:(<span class="keyword">nonnull</span> <span class="built_in">NSURL</span> *)url</span><br><span class="line">                              error:(<span class="keyword">nonnull</span> <span class="built_in">NSError</span> *)error;</span><br></pre></td></tr></table></figure>

<p><strong><strong>3.2.1 图片下载器</strong></strong></p>
<p><img src="/2019/11/30/SDWebImage-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/00009.png"></p>
<p>我们知道iOS中图片的下载使用的还是URLSession,而这里的图片下载器就是通过URLSession进行下载的，这个在上面介绍流程源码的时候已经介绍过了，下面将从宏观的角度对这些类进行分析，整个下载器的组成，这里不追究细节。</p>
<p><strong><strong>SDWebImageDownloaderOptions</strong></strong><br>下载全局选项<br><strong><strong>SDWebImageDownloadToken</strong></strong><br>用于指示某个下载的Token,包括url，request，response，以及取消的方法，在启动下载的时候会返回一个DownloadToken，用它可以进行取消任务。<br><strong><strong>SDWebImageDownloaderConfig</strong></strong><br>下载器配置类，包括：</p>
<ul>
<li>最大并发数，默认为6</li>
<li>下载超时时间，默认为15秒</li>
<li>最小进度间隔，指的是上一次进度和本次进度的差值不能小于这个数，如果小于这个数就不通知进度更新</li>
<li>operationClass 下载指定的NSOperation具体实现类</li>
<li>executionOrder operations执行顺序，默认是先入先出</li>
<li>认证需要的username，password</li>
<li>sessionConfiguration</li>
</ul>
<p><strong><strong>SDWebImageDownloaderRequestModifier</strong></strong><br>全局请求拦截修改器，如果返回nil表示某个请求将会被取消，如果requestModifier &#x3D; nil 表示不修改原始的下载请求。<br><strong><strong>SDWebImageDownloaderResponseModifier</strong></strong><br>全局返回体拦截修改器，如果返回nil表示当前下载被取消，如果responseModifier &#x3D; nil 表示不修改原始返回体<br><strong><strong>SDWebImageDownloaderDecryptor</strong></strong><br>解密器，它会在图片解码之前对某些加密的图片进行解密，比如某些图片会进行Base64加密，这时候就需要使用解密器进行解密，如果返回nil表示下载失败<br><strong><strong>SDWebImageDownloaderOperation</strong></strong></p>
<p>除了上面的几个重要类外，还具备了下载器状态查询接口&#x2F;属性：suspended是否暂停下载，当前下载数currentDownloadCount。</p>
<p>以及下载，取消下载接口：</p>
<figure class="highlight erlang"><table><tr><td class="code"><pre><span class="line">- <span class="params">(nullable SDWebImageDownloadToken *)</span>downloadImageWithURL:<span class="params">(nullable NSURL *)</span>url</span><br><span class="line">                                                   options:<span class="params">(SDWebImageDownloaderOptions)</span>options</span><br><span class="line">                                                   context:<span class="params">(nullable SDWebImageContext *)</span>context</span><br><span class="line">                                                  progress:<span class="params">(nullable SDWebImageDownloaderProgressBlock)</span>progressBlock</span><br><span class="line">                                                 completed:<span class="params">(nullable SDWebImageDownloaderCompletedBlock)</span>completedBlock;</span><br><span class="line"></span><br><span class="line">- <span class="params">(void)</span>cancelAllDownloads;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong><strong>SDWebImageDownloaderOperation</strong></strong><br>SDWebImageDownloaderOperation是这里的重头戏，它的输入是NSURLRequest，NSURLSession，SDWebImageDownloaderOptions，SDWebImageContext。<br>NSURLRequest，NSURLSession不用多说它是用于创建NSURLSessionTask，SDWebImageDownloaderOptions是用于下载的配置选项，SDWebImageContext用于存放重要组件。</p>
<p>下面是一些比较重要的属性：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">//请求体</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">nullable</span>) <span class="built_in">NSURLRequest</span> *request; </span><br><span class="line"><span class="comment">//返回体</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">nullable</span>) <span class="built_in">NSURLResponse</span> *response;</span><br><span class="line"><span class="comment">//返回异常</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nullable</span>) <span class="built_in">NSError</span> *responseError;</span><br><span class="line"><span class="comment">//执行下载请求的dataTask</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">nullable</span>) <span class="built_in">NSURLSessionTask</span> *dataTask;</span><br><span class="line"><span class="comment">//urlsession</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nullable</span>) <span class="built_in">NSURLSession</span> *unownedSession;</span><br><span class="line"><span class="comment">//包括进度更新block以及completeblock</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nonnull</span>) <span class="built_in">NSMutableArray</span>&lt;SDCallbacksDictionary *&gt; *callbackBlocks;</span><br><span class="line"><span class="comment">//下载选项</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readwrite</span>) SDWebImageDownloaderOptions options;</span><br><span class="line"><span class="comment">//重要部件上下文</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">copy</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readwrite</span>, <span class="keyword">nullable</span>) SDWebImageContext *context;</span><br><span class="line"><span class="comment">//图片数据</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nullable</span>) <span class="built_in">NSMutableData</span> *imageData;</span><br><span class="line"><span class="comment">//收发数据大小</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSUInteger</span> expectedSize; </span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSUInteger</span> receivedSize;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="type">double</span> previousProgress;</span><br><span class="line"><span class="comment">//code队列</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nonnull</span>) <span class="built_in">dispatch_queue_t</span> coderQueue;</span><br><span class="line"><span class="comment">//当前NSOperation状态</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>, <span class="keyword">getter</span> = isExecuting) <span class="type">BOOL</span> executing;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>, <span class="keyword">getter</span> = isFinished) <span class="type">BOOL</span> finished;</span><br><span class="line"><span class="comment">//返回体修改器</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nullable</span>) <span class="type">id</span>&lt;SDWebImageDownloaderResponseModifier&gt; responseModifier; </span><br><span class="line"><span class="comment">//解密器</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nullable</span>) <span class="type">id</span>&lt;SDWebImageDownloaderDecryptor&gt; decryptor;</span><br></pre></td></tr></table></figure>

<p><strong><strong>3.3 图片下载缓存</strong></strong></p>
<p><img src="/2019/11/30/SDWebImage-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/000010.png"></p>
<p><strong><strong>SDImageCache</strong></strong><br>SDImageCache是管理图片下载缓存的类，最初的时候个人以为是SDImageCachesManager管理全部的缓存，但是实际上是这货，并且SDImageCachesManager从源码上看并没有实际的用途。我们先来看下SDImageCache，它的重要元素包含：<br>缓存配置：SDImageCacheConfig<br>内存缓存：memoryCache<br>磁盘缓存：diskCache，磁盘缓存根路径 diskCachePath</p>
<p><strong><strong>SDMemoryCache</strong></strong></p>
<p>基于NSCache的内存缓存，主要对象包括缓存配置<strong><strong>SDImageCacheConfig</strong></strong>，以及缓存对象的增删改查。</p>
<p><strong><strong>SDDiskCache</strong></strong><br>基于文件的内存缓存，主要对象包括缓存配置<strong><strong>SDImageCacheConfig</strong></strong>，以及缓存对象的增删改查。</p>
<p><strong><strong>SDWebImageCacheKeyFilter</strong></strong></p>
<p>全局根据url映射到缓存key的类。</p>
<p><strong><strong>SDWebImageCacheSerializer</strong></strong></p>
<p>在缓存之前对图像数据进行处理</p>
<p><strong><strong>SDImageCacheConfig</strong></strong><br><strong><strong>SDImageCacheOptions</strong></strong></p>
<p>缓存配置</p>
<p><strong><strong>SDImageCacheDefine</strong></strong></p>
<p>缓存模块相关的定义</p>
<p><strong><strong>SDImageCachesManager</strong></strong></p>
<p>用于管理缓存的管理器，但是目前在项目中没有使用</p>
<p><strong><strong>SDImageCachesManagerOperation</strong></strong><br>用在SDImageCachesManager也是一个NSOperation</p>
<p>同时需要强调的是SDWebImage支持以插件的形式加入YYImage以及YYCache.具体见：<a target="_blank" rel="noopener" href="https://github.com/SDWebImage/SDWebImageYYPlugin">SDWebImageYYPlugin</a><br>后面也会对这个开源库进行分析。</p>
<p><strong><strong>3.4 图片编解码器</strong></strong></p>
<p><img src="/2019/11/30/SDWebImage-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/00008.png"></p>
<p><strong><strong>SDImageCodersManager</strong></strong></p>
<p>SDImageCodersManager 顾名思义就是用于全局得管理编解码器，后面添加的编解码器有最高的优先级</p>
<p><strong><strong>SDImageCoderOption</strong></strong><br>解码器配置选项</p>
<p><strong><strong>SDImageCoder&#x2F;SDProgressiveImageCoder</strong></strong></p>
<p>SDImageCoder 是一个比较重要的协议，是所有编解码器都需要遵循的协议：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">SDImageCoder</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@required</span></span><br><span class="line"><span class="comment">//给定的数据能否被当前编解码器解码</span></span><br><span class="line">- (<span class="type">BOOL</span>)canDecodeFromData:(<span class="keyword">nullable</span> <span class="built_in">NSData</span> *)data;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用当前解码器对图像数据进行解码</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)decodedImageWithData:(<span class="keyword">nullable</span> <span class="built_in">NSData</span> *)data</span><br><span class="line">                                   options:(<span class="keyword">nullable</span> SDImageCoderOptions *)options;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> mark - Encoding</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//当前编解码器是否能够编码到指定的格式</span></span><br><span class="line">- (<span class="type">BOOL</span>)canEncodeToFormat:(SDImageFormat)format <span class="built_in">NS_SWIFT_NAME</span>(canEncode(to:));</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用当前编码器对图像数据进行编码</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSData</span> *)encodedDataWithImage:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)image</span><br><span class="line">                                   format:(SDImageFormat)format</span><br><span class="line">                                  options:(<span class="keyword">nullable</span> SDImageCoderOptions *)options;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">SDProgressiveImageCoder</span> &lt;<span class="title">SDImageCoder</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@required</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//是否能够渐进解码</span></span><br><span class="line">- (<span class="type">BOOL</span>)canIncrementalDecodeFromData:(<span class="keyword">nullable</span> <span class="built_in">NSData</span> *)data;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">nonnull</span> <span class="keyword">instancetype</span>)initIncrementalWithOptions:(<span class="keyword">nullable</span> SDImageCoderOptions *)options;</span><br><span class="line"></span><br><span class="line"><span class="comment">//更新增量图片数据</span></span><br><span class="line">- (<span class="type">void</span>)updateIncrementalData:(<span class="keyword">nullable</span> <span class="built_in">NSData</span> *)data finished:(<span class="type">BOOL</span>)finished;</span><br><span class="line"></span><br><span class="line"><span class="comment">//进行渐进式解码</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)incrementalDecodedImageWithOptions:(<span class="keyword">nullable</span> SDImageCoderOptions *)options;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><strong><strong>SDAnimatedImageProvider</strong></strong><br>用于提供基本动图所需要遵循的协议，目前SDAnimatedImage以及SDAnimatedImageCoder会遵循这个协议。</p>
<p><strong><strong>SDImageIOCoder</strong></strong></p>
<p>用于对PNG, JPEG, TIFF 这些格式进行编解码，它也支持GIF以及HEIC这些动图格式，但是GIF只支持第一帧，HEIC需要看各个系统的支持情况。对于这些动图建议使用SDAnimatedImageView</p>
<p><strong><strong>SDAnimatedImageCoder</strong></strong><br>SDAnimatedImageCoder是所有动图编解码器的基类，下面将要介绍的SDImageAPNGCoder，SDImageGIFCoder，SDImageHEICCoder都是这个类的子类。</p>
<p><strong><strong>SDImageAPNGCoder</strong></strong><br>APNG动画格式编解码器，关于APNG格式介绍，大家可以查看如下文章：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://aotu.io/notes/2016/11/07/apng/index.html">APNG 那些事</a></li>
<li><a target="_blank" rel="noopener" href="http://littlesvr.ca/apng/gif_apng_webp.html">GIF vs APNG vs WebP</a></li>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/27201109">APNG相对于GIF有哪些优势</a><br><strong><strong>SDImageGIFCoder</strong></strong><br>这个就不做介绍了GIF格式的编解码器<br><strong><strong>SDImageHEICCoder</strong></strong></li>
<li><a target="_blank" rel="noopener" href="https://www.hack520.com/788.html">HEIC格式介绍</a></li>
</ul>
<p><strong><strong>SDImageCoderHelper</strong></strong><br>SDImageCoderHelper是上层编解码器的公共方法类。</p>
<p><strong><strong>3.5 动图相关类</strong></strong></p>
<p><strong><strong>SDAnimatedImage</strong></strong><br>SDAnimatedImage 为动图数据类和UIImage对应<br><strong><strong>SDAnimatedImageView</strong></strong><br>SDAnimatedImageView 为动图显示View和UIImageView类对应，内部持有SDAnimatedImagePlayer<br><strong><strong>SDAnimatedImagePlayer</strong></strong><br>SDAnimatedImagePlayer 用于播放动画<br><strong><strong>SDWebImageTransition</strong></strong><br>SDWebImageTransition为图片加载结束后呈现图片时候使用的转场动画，目前支持fadeTransition，flipFromLeftTransition，flipFromRightTransition，flipFromTopTransition，flipFromBottomTransition，curlUpTransition，curlDownTransition几种。</p>
<p>****3.6 SDWebImageOptionsProcessor ****</p>
<p>全局Options处理器，用于针对所有的Options设置进行过滤处理。</p>
<p>****3.7 SDWebImageIndicator ****</p>
<p>进度指示器，目前主要支持两种：SDWebImageActivityIndicator和SDWebImageProgressIndicator</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/iOS-%E5%BC%80%E6%BA%90%E5%BA%93%E5%88%86%E6%9E%90/">iOS 开源库分析</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/iOS-开源库分析/">iOS 开源库分析</a>
  </div>

</div>



<div class="comments-count">
	
	  	<span></span>
		<a href="/2019/11/30/SDWebImage-源码解析/#comments" class="ds-thread-count comments-count-link" data-thread-key="2019/11/30/SDWebImage-源码解析/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/11/28/YTKNetWork源码解析/" title="YTKNetWork源码解析" itemprop="url">YTKNetWork源码解析</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Edgar" target="_blank" itemprop="author">Edgar</a>
		
  <p class="article-time">
    <time datetime="2019-11-27T18:23:58.000Z" itemprop="datePublished"> Published 2019-11-28</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h4 id="开源代码信息"><a href="#开源代码信息" class="headerlink" title="开源代码信息"></a>开源代码信息</h4><p><a target="_blank" rel="noopener" href="https://github.com/yuantiku/YTKNetwork">开源地址</a></p>
<p>YTKNetwork是基于AFNetworking封装的iOS网络库，它在AFNetworking的基础上提供了如下的功能：</p>
<blockquote>
<ul>
<li>支持按时间缓存网络请求内容</li>
<li>支持按版本号缓存网络请求内容</li>
<li>支持统一设置服务器和 CDN 的地址</li>
<li>支持检查返回 JSON 内容的合法性</li>
<li>支持文件的断点续传</li>
<li>支持 block 和 delegate 两种模式的回调方式</li>
<li>支持批量的网络请求发送，并统一设置它们的回调（实现在 YTKBatchRequest 类中）</li>
<li>支持方便地设置有相互依赖的网络请求的发送，例如：发送请求 A，根据请求 A 的结果，选择性的发送请求 B 和 C，再根据 B 和 C 的结果，选择性的发送请求 D。（实现在 YTKChainRequest 类中）</li>
<li>支持网络请求 URL 的 filter，可以统一为网络请求加上一些参数，或者修改一些路径。</li>
<li>定义了一套插件机制，可以很方便地为 YTKNetwork 增加功能。猿题库官方现在提供了一个插件，可以在某些网络请求发起时，在界面上显示“正在加载”的 HUD。</li>
</ul>
</blockquote>
<h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><p>YTKNetWork 整个代码量不是很大，整个代码结构如下所示：<br><img src="/2019/11/28/YTKNetWork%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/00001.png"></p>
<p>在整个请求过程中都是围绕着Request展开，这里需要注意的是YTKBatchRequest以及YTKChainRequest并不继承自YTKBaseRequest，它其实是通过请求数组requestArray来管理请求的形式，所以个人觉得这两个类的命名不是很合理，很容易让人以为它们和YTKRequest一样都是继承自YTKBaseRequest。另一个个人觉得不是很合理的地方是它将全部的数据都放到YTKRequest，会显得庞大且乱。</p>
<p>这篇博客将通过如下几个方面对YTKNetWork源码进行解析：</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="bullet">* </span>YTKRequest &amp;&amp; YTKBaseRequest 的组成</span><br><span class="line"><span class="bullet">* </span>基本请求过程</span><br><span class="line"><span class="bullet">* </span>批量请求</span><br><span class="line"><span class="bullet">* </span>链式请求</span><br><span class="line"><span class="bullet">* </span>缓存机制</span><br><span class="line"><span class="bullet">* </span>断点续传</span><br><span class="line"><span class="bullet">* </span>URL filter</span><br><span class="line"><span class="bullet">* </span>插件机制</span><br></pre></td></tr></table></figure>

<h5 id="1-YTKRequest-amp-amp-YTKBaseRequest-的组成"><a href="#1-YTKRequest-amp-amp-YTKBaseRequest-的组成" class="headerlink" title="1. YTKRequest &amp;&amp; YTKBaseRequest 的组成"></a>1. YTKRequest &amp;&amp; YTKBaseRequest 的组成</h5><p><strong><strong>YTKRequest</strong></strong></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YTKBaseRequest</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> mark - Request and Response Information</span></span><br><span class="line"><span class="comment">///=============================================================================</span></span><br><span class="line"><span class="comment">/// @name Request and Response Information</span></span><br><span class="line"><span class="comment">///=============================================================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">///  当前请求执行所使用的NSURLSessionTask，在请求start之前不应该调用这个值，因为这时候这个值为nil</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="built_in">NSURLSessionTask</span> *requestTask;</span><br><span class="line"><span class="comment">///  requestTask.currentRequest的快捷访问方式</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="built_in">NSURLRequest</span> *currentRequest;</span><br><span class="line"><span class="comment">///  requestTask.originalRequest的快捷访问方式</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="built_in">NSURLRequest</span> *originalRequest;</span><br><span class="line"><span class="comment">///  requestTask.response的快捷访问方式.</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="built_in">NSHTTPURLResponse</span> *response;</span><br><span class="line"><span class="comment">///  返回体状态码</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSInteger</span> responseStatusCode;</span><br><span class="line"><span class="comment">///  头信息</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>, <span class="keyword">nullable</span>) <span class="built_in">NSDictionary</span> *responseHeaders;</span><br><span class="line"><span class="comment">///  response的原始信息，在失败的时候值为nil</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>, <span class="keyword">nullable</span>) <span class="built_in">NSData</span> *responseData;</span><br><span class="line"><span class="comment">///  response的字符串形式信息，在失败的时候值为nil</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>, <span class="keyword">nullable</span>) <span class="built_in">NSString</span> *responseString;</span><br><span class="line"><span class="comment">///  序列化后的结果对象，在下载的情景下并且在使用resumableDownloadPath的时候，这个值代表文件存放的地址</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>, <span class="keyword">nullable</span>) <span class="type">id</span> responseObject;</span><br><span class="line"><span class="comment">///  JSON形式的结果</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>, <span class="keyword">nullable</span>) <span class="type">id</span> responseJSONObject;</span><br><span class="line"><span class="comment">// 错误信息</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>, <span class="keyword">nullable</span>) <span class="built_in">NSError</span> *error;</span><br><span class="line"><span class="comment">///  当前请求是否被取消</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">getter</span>=isCancelled) <span class="type">BOOL</span> cancelled;</span><br><span class="line"><span class="comment">///  当前请求是否正在执行</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">getter</span>=isExecuting) <span class="type">BOOL</span> executing;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> mark - Request Configuration</span></span><br><span class="line"><span class="comment">///=============================================================================</span></span><br><span class="line"><span class="comment">/// @name Request Configuration</span></span><br><span class="line"><span class="comment">///=============================================================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">///  用于标示一个请求的 tag</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">NSInteger</span> tag;</span><br><span class="line"><span class="comment">///  用于存储关于请求的额外信息</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">nullable</span>) <span class="built_in">NSDictionary</span> *userInfo;</span><br><span class="line"><span class="comment">/// 请求代理，如果选择用block方式来交付数据可以忽略这个值</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>, <span class="keyword">nullable</span>) <span class="type">id</span>&lt;YTKRequestDelegate&gt; delegate;</span><br><span class="line"><span class="comment">/// 请求成功后将会调用的Block,如果delegate以及block都指定都话会先调用delegate然后再调用block，并且这个block会在主线程调用</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">nullable</span>) YTKRequestCompletionBlock successCompletionBlock;</span><br><span class="line"><span class="comment">/// 请求失败都时候调用的Block，规则同successCompletionBlock</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">nullable</span>) YTKRequestCompletionBlock failureCompletionBlock;</span><br><span class="line"><span class="comment">/// 当前请求所添加的插件</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">nullable</span>) <span class="built_in">NSMutableArray</span>&lt;<span class="type">id</span>&lt;YTKRequestAccessory&gt;&gt; *requestAccessories;</span><br><span class="line"><span class="comment">///  用于POST形式下组装请求body的block</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">nullable</span>) AFConstructingBlock constructingBodyBlock;</span><br><span class="line"><span class="comment">/// 这个用于断点续传的情况，用于表示下载的临时文件的存放路径。在请求start之前将会删除这些文件，如果下载成功文件将会自动下载到这个路径，否则下载结果将会保存到</span></span><br><span class="line"><span class="comment">/// responseData，responseString。</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">nullable</span>) <span class="built_in">NSString</span> *resumableDownloadPath;</span><br><span class="line"><span class="comment">///  用于跟踪文件的下载进度</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">nullable</span>) AFURLSessionTaskProgressBlock resumableDownloadProgressBlock;</span><br><span class="line"><span class="comment">///  请求优先级</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) YTKRequestPriority requestPriority;</span><br><span class="line"><span class="comment">///  请求完成的回调block</span></span><br><span class="line">- (<span class="type">void</span>)setCompletionBlockWithSuccess:(<span class="keyword">nullable</span> YTKRequestCompletionBlock)success</span><br><span class="line">                              failure:(<span class="keyword">nullable</span> YTKRequestCompletionBlock)failure;</span><br><span class="line"><span class="comment">///  清除回调完成后结果交付block</span></span><br><span class="line">- (<span class="type">void</span>)clearCompletionBlock;</span><br><span class="line"><span class="comment">/// 添加插件</span></span><br><span class="line">- (<span class="type">void</span>)addAccessory:(<span class="type">id</span>&lt;YTKRequestAccessory&gt;)accessory;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> mark - Request Action</span></span><br><span class="line"><span class="comment">///=============================================================================</span></span><br><span class="line"><span class="comment">/// @name Request Action</span></span><br><span class="line"><span class="comment">///=============================================================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">///  开始请求</span></span><br><span class="line">- (<span class="type">void</span>)start;</span><br><span class="line"><span class="comment">///  停止请求</span></span><br><span class="line">- (<span class="type">void</span>)stop;</span><br><span class="line"><span class="comment">///  开始请求</span></span><br><span class="line">- (<span class="type">void</span>)startWithCompletionBlockWithSuccess:(<span class="keyword">nullable</span> YTKRequestCompletionBlock)success</span><br><span class="line">                                    failure:(<span class="keyword">nullable</span> YTKRequestCompletionBlock)failure;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> mark - Subclass Override</span></span><br><span class="line"><span class="comment">///=============================================================================</span></span><br><span class="line"><span class="comment">/// @name Subclass Override</span></span><br><span class="line"><span class="comment">///=============================================================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">///  在后台获得到数据但是尚未切换到主线程之前调用这个方法。</span></span><br><span class="line">- (<span class="type">void</span>)requestCompletePreprocessor;</span><br><span class="line"><span class="comment">///  在请求成功并且切换到主线程后调用这个方法</span></span><br><span class="line">- (<span class="type">void</span>)requestCompleteFilter;</span><br><span class="line"><span class="comment">///  在后台请求失败但是尚未切换到主线程之前调用这个方法。</span></span><br><span class="line">- (<span class="type">void</span>)requestFailedPreprocessor;</span><br><span class="line"><span class="comment">///  请求失败并且切换到主线程后调用这个方法</span></span><br><span class="line">- (<span class="type">void</span>)requestFailedFilter;</span><br><span class="line"><span class="comment">/// URL的host部分 比如 http://www.example.com.</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)baseUrl;</span><br><span class="line"><span class="comment">/// 它可以有两种形式，一种是全路径形式，这时候就会忽略baseUrl直接使用requestUrl，</span></span><br><span class="line"><span class="comment">/// 另一种是这个值只包含url的路径信息比如/v1/user，这时候会将requestUrl与baseUrl进行拼接</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)requestUrl;</span><br><span class="line"><span class="comment">///  cdn地址</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)cdnUrl;</span><br><span class="line"><span class="comment">///  请求的超时时间默认是60s</span></span><br><span class="line">- (<span class="built_in">NSTimeInterval</span>)requestTimeoutInterval;</span><br><span class="line"><span class="comment">///  额外的请求参数，GET的时候添加到路径上,POST的时候添加到body</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="type">id</span>)requestArgument;</span><br><span class="line"><span class="comment">///  HTTP 请求方式</span></span><br><span class="line">- (YTKRequestMethod)requestMethod;</span><br><span class="line"><span class="comment">///  请求序列化类型</span></span><br><span class="line">- (YTKRequestSerializerType)requestSerializerType;</span><br><span class="line"><span class="comment">///  结构体序列化类型</span></span><br><span class="line">- (YTKResponseSerializerType)responseSerializerType;</span><br><span class="line"><span class="comment">///  HTTP 认证参数数组</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *)requestAuthorizationHeaderFieldArray;</span><br><span class="line"><span class="comment">///  额外的请求头</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="built_in">NSString</span> *&gt; *)requestHeaderFieldValueDictionary;</span><br><span class="line"><span class="comment">/// 用于构建自定义请求，如果这个返回值为非空，那么上面所有用于构建请求的就全部被忽略，而统一使用这个请求</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSURLRequest</span> *)buildCustomUrlRequest;</span><br><span class="line"><span class="comment">///  是否使用cdn</span></span><br><span class="line">- (<span class="type">BOOL</span>)useCDN;</span><br><span class="line"><span class="comment">///  是否允许使用蜂窝网络</span></span><br><span class="line">- (<span class="type">BOOL</span>)allowsCellularAccess;</span><br><span class="line"><span class="comment">///  用于校验responseJSONObject结构</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="type">id</span>)jsonValidator;</span><br><span class="line"><span class="comment">///  用于校验responseStatusCode</span></span><br><span class="line">- (<span class="type">BOOL</span>)statusCodeValidator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong><strong>YTKRequest</strong></strong></p>
<p>YTKRequest主要是在YTKBaseRequest添加了缓存的相关管理。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YTKRequest</span> : <span class="title">YTKBaseRequest</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 是否忽略缓存结果，需要注意的是cacheTimeInSeconds默认值为-1所以如果我们没有明确给出一个cacheTimeInSeconds值的话实际上我们还是会忽略缓存</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="type">BOOL</span> ignoreCache;</span><br><span class="line"></span><br><span class="line"><span class="comment">///  判断当前返回的数据是否是从缓存中获取而来</span></span><br><span class="line">- (<span class="type">BOOL</span>)isDataFromCache;</span><br><span class="line"></span><br><span class="line"><span class="comment">///手动从存储中加载缓存</span></span><br><span class="line">- (<span class="type">BOOL</span>)loadCacheWithError:(<span class="built_in">NSError</span> * __autoreleasing *)error;</span><br><span class="line"></span><br><span class="line"><span class="comment">///以忽略缓存的形式启动请求，这个一般用于更新缓存数据</span></span><br><span class="line">- (<span class="type">void</span>)startWithoutCache;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 缓存返回数据到缓存文件</span></span><br><span class="line">- (<span class="type">void</span>)saveResponseDataToCacheFile:(<span class="built_in">NSData</span> *)data;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> mark - Subclass Override</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 缓存时间</span></span><br><span class="line">- (<span class="built_in">NSInteger</span>)cacheTimeInSeconds;</span><br><span class="line"></span><br><span class="line"><span class="comment">///  缓存版本</span></span><br><span class="line">- (<span class="type">long</span> <span class="type">long</span>)cacheVersion;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="type">id</span>)cacheSensitiveData;</span><br><span class="line"></span><br><span class="line"><span class="comment">///  是否异步写缓存</span></span><br><span class="line">- (<span class="type">BOOL</span>)writeCacheAsynchronously;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="2-基本请求过程"><a href="#2-基本请求过程" class="headerlink" title="2. 基本请求过程"></a>2. 基本请求过程</h5><p>基本请求这块代码都放在YTKBaseRequest以及YTKNetworkAgent中，YTKBaseRequest会将实际的处理封装在YTKNetworkAgent，我们就来看下这部分代码：</p>
<p><strong><strong>请求的发起</strong></strong></p>
<p>一般请求我们会通过startWithCompletionBlockWithSuccess来执行：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">- (void)startWithCompletionBlockWithSuccess:(YTKRequestCompletionBlock)success</span><br><span class="line">                                    failure:(YTKRequestCompletionBlock)failure &#123;</span><br><span class="line">    <span class="comment">//设置successBlock 以及failureBlock</span></span><br><span class="line">    <span class="selector-attr">[self setCompletionBlockWithSuccess:success failure:failure]</span>;</span><br><span class="line">    <span class="comment">//启动请求</span></span><br><span class="line">    <span class="selector-attr">[self start]</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)start &#123;</span><br><span class="line">    <span class="comment">//通知插件将要开始请求</span></span><br><span class="line">    <span class="selector-attr">[self toggleAccessoriesWillStartCallBack]</span>;</span><br><span class="line">    <span class="comment">//将请求添加到YTKNetworkAgent</span></span><br><span class="line">    <span class="selector-attr">[[YTKNetworkAgent sharedAgent]</span> addRequest:self];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请求过程中会先设置成功，失败结果返回的block，然后通知插件请求将要开始了，插件可以根据实际需求做对应处理，比如显示加载动画等，然后就将请求传递给YTKNetworkAgent。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)addRequest:(YTKBaseRequest *)request &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSError</span> * __autoreleasing requestSerializationError = <span class="literal">nil</span>;</span><br><span class="line">    <span class="comment">//如果请求中有自定义的url则使用自定义的NSURLRequest创建对应的NSURLSessionDataTask</span></span><br><span class="line">    <span class="built_in">NSURLRequest</span> *customUrlRequest= [request buildCustomUrlRequest];</span><br><span class="line">    <span class="keyword">if</span> (customUrlRequest) &#123;</span><br><span class="line">        __block <span class="built_in">NSURLSessionDataTask</span> *dataTask = <span class="literal">nil</span>;</span><br><span class="line">        dataTask = [_manager dataTaskWithRequest:customUrlRequest completionHandler:^(<span class="built_in">NSURLResponse</span> * _Nonnull response, <span class="type">id</span>  _Nullable responseObject, <span class="built_in">NSError</span> * _Nullable error) &#123;</span><br><span class="line">            [<span class="keyword">self</span> handleRequestResult:dataTask responseObject:responseObject error:error];</span><br><span class="line">        &#125;];</span><br><span class="line">        request.requestTask = dataTask;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//直接通过sessionTaskForRequest获取NSURLSessionDataTask</span></span><br><span class="line">        request.requestTask = [<span class="keyword">self</span> sessionTaskForRequest:request error:&amp;requestSerializationError];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (requestSerializationError) &#123;</span><br><span class="line">        [<span class="keyword">self</span> requestDidFailWithRequest:request error:requestSerializationError];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置请求的优先级</span></span><br><span class="line">    <span class="keyword">if</span> ([request.requestTask respondsToSelector:<span class="keyword">@selector</span>(priority)]) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (request.requestPriority) &#123;</span><br><span class="line">            <span class="keyword">case</span> YTKRequestPriorityHigh:</span><br><span class="line">                request.requestTask.priority = <span class="built_in">NSURLSessionTaskPriorityHigh</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> YTKRequestPriorityLow:</span><br><span class="line">                request.requestTask.priority = <span class="built_in">NSURLSessionTaskPriorityLow</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> YTKRequestPriorityDefault:</span><br><span class="line">                <span class="comment">/*!!fall through*/</span></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                request.requestTask.priority = <span class="built_in">NSURLSessionTaskPriorityDefault</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Retain request</span></span><br><span class="line">    [<span class="keyword">self</span> addRequestToRecord:request];</span><br><span class="line">    <span class="comment">//启动请求</span></span><br><span class="line">    [request.requestTask resume];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在YTKNetworkAgent中我们首先会看下是否开发者在对应等request中重写了<strong><strong>buildCustomUrlRequest</strong></strong>方法，如果是的话则通过这个返回的request 生成NSURLSessionDataTask,否则使用传入的request通过调用sessionTaskForRequest生成NSURLSessionDataTask,紧接着给请求设置优先级，并且保持请求引用。然后开启请求。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="operator">-</span> (<span class="type">NSURLSessionTask</span> <span class="operator">*</span>)sessionTaskForRequest:(<span class="type">YTKBaseRequest</span> <span class="operator">*</span>)request error:(<span class="type">NSError</span> <span class="operator">*</span> _Nullable __autoreleasing <span class="operator">*</span>)error &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 取出请求方法</span></span><br><span class="line">    <span class="type">YTKRequestMethod</span> method <span class="operator">=</span> [request requestMethod];</span><br><span class="line">    <span class="comment">// 构建URL</span></span><br><span class="line">    <span class="type">NSString</span> <span class="operator">*</span>url <span class="operator">=</span> [<span class="keyword">self</span> buildRequestUrl:request];</span><br><span class="line">    <span class="comment">// 准备请求参数</span></span><br><span class="line">    id param <span class="operator">=</span> request.requestArgument;</span><br><span class="line">    <span class="comment">// 构建POST请求体Block</span></span><br><span class="line">    <span class="type">AFConstructingBlock</span> constructingBlock <span class="operator">=</span> [request constructingBodyBlock];</span><br><span class="line">    <span class="comment">// 通过请求来构建请求序列化器</span></span><br><span class="line">    <span class="type">AFHTTPRequestSerializer</span> <span class="operator">*</span>requestSerializer <span class="operator">=</span> [<span class="keyword">self</span> requestSerializerForRequest:request];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过请求方法来构建出不同的NSURLSessionTask</span></span><br><span class="line">    <span class="keyword">switch</span> (method) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="type">YTKRequestMethodGET</span>:</span><br><span class="line">            <span class="keyword">if</span> (request.resumableDownloadPath) &#123;</span><br><span class="line">                <span class="keyword">return</span> [<span class="keyword">self</span> downloadTaskWithDownloadPath:request.resumableDownloadPath</span><br><span class="line">                                        requestSerializer:requestSerializer</span><br><span class="line">                                                <span class="type">URLString</span>:url </span><br><span class="line">                                                parameters:param</span><br><span class="line">                                                 progress:request.resumableDownloadProgressBlock</span><br><span class="line">                                                    error:error];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> [<span class="keyword">self</span> dataTaskWithHTTPMethod:@<span class="string">&quot;GET&quot;</span></span><br><span class="line">                                  requestSerializer:requestSerializer</span><br><span class="line">                                          <span class="type">URLString</span>:url </span><br><span class="line">                                          parameters:param </span><br><span class="line">                                          error:error];</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="type">YTKRequestMethodPOST</span>:</span><br><span class="line">            <span class="keyword">return</span> [<span class="keyword">self</span> dataTaskWithHTTPMethod:@<span class="string">&quot;POST&quot;</span> requestSerializer:requestSerializer <span class="type">URLString</span>:url parameters:param constructingBodyWithBlock:constructingBlock error:error];</span><br><span class="line">        <span class="keyword">case</span> <span class="type">YTKRequestMethodHEAD</span>:</span><br><span class="line">            <span class="keyword">return</span> [<span class="keyword">self</span> dataTaskWithHTTPMethod:@<span class="string">&quot;HEAD&quot;</span> requestSerializer:requestSerializer <span class="type">URLString</span>:url parameters:param error:error];</span><br><span class="line">        <span class="keyword">case</span> <span class="type">YTKRequestMethodPUT</span>:</span><br><span class="line">            <span class="keyword">return</span> [<span class="keyword">self</span> dataTaskWithHTTPMethod:@<span class="string">&quot;PUT&quot;</span> requestSerializer:requestSerializer <span class="type">URLString</span>:url parameters:param error:error];</span><br><span class="line">        <span class="keyword">case</span> <span class="type">YTKRequestMethodDELETE</span>:</span><br><span class="line">            <span class="keyword">return</span> [<span class="keyword">self</span> dataTaskWithHTTPMethod:@<span class="string">&quot;DELETE&quot;</span> requestSerializer:requestSerializer <span class="type">URLString</span>:url parameters:param error:error];</span><br><span class="line">        <span class="keyword">case</span> <span class="type">YTKRequestMethodPATCH</span>:</span><br><span class="line">            <span class="keyword">return</span> [<span class="keyword">self</span> dataTaskWithHTTPMethod:@<span class="string">&quot;PATCH&quot;</span> requestSerializer:requestSerializer <span class="type">URLString</span>:url parameters:param error:error];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在sessionTaskForRequest方法会将YTKBaseRequest中的一系列配置拆开，通过在YTKBaseRequest中的配置来创建不同请求方法下的dataTask。首先看下请求url的构建策略：</p>
<p>请求url的构建是通过<strong><strong>buildRequestUrl</strong></strong>来实现的</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *)buildRequestUrl:(YTKBaseRequest *)request &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取请求的requestUrl使用它来构建出一个NSURL对象</span></span><br><span class="line">    <span class="built_in">NSString</span> *detailUrl = [request requestUrl];</span><br><span class="line">    <span class="built_in">NSURL</span> *temp = [<span class="built_in">NSURL</span> URLWithString:detailUrl];</span><br><span class="line">    <span class="comment">// 检查构建出来的URL是否是完整的URL请求</span></span><br><span class="line">    <span class="keyword">if</span> (temp &amp;&amp; temp.host &amp;&amp; temp.scheme) &#123;</span><br><span class="line">        <span class="keyword">return</span> detailUrl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对构建出来的URL通过Config中预设的urlFilters 一一对它进行处理，比如添加公共字段等</span></span><br><span class="line">    <span class="built_in">NSArray</span> *filters = [_config urlFilters];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">id</span>&lt;YTKUrlFilterProtocol&gt; f <span class="keyword">in</span> filters) &#123;</span><br><span class="line">        detailUrl = [f filterUrl:detailUrl withRequest:request];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构建baseUrl 如果使用CDN，并且cdnUrl有值，则baseUrl为cdnUrl，</span></span><br><span class="line">    <span class="comment">//如果不使用CDN则优先使用当前request的baseUrl否则使用公共配置中的baseUrl</span></span><br><span class="line">    <span class="built_in">NSString</span> *baseUrl;</span><br><span class="line">    <span class="keyword">if</span> ([request useCDN]) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([request cdnUrl].length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            baseUrl = [request cdnUrl];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            baseUrl = [_config cdnUrl];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ([request baseUrl].length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            baseUrl = [request baseUrl];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            baseUrl = [_config baseUrl];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// URL slash compability</span></span><br><span class="line">    <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:baseUrl];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (baseUrl.length &gt; <span class="number">0</span> &amp;&amp; ![baseUrl hasSuffix:<span class="string">@&quot;/&quot;</span>]) &#123;</span><br><span class="line">        url = [url URLByAppendingPathComponent:<span class="string">@&quot;&quot;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将当前的baseUrl与detailUrl进行拼接</span></span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSURL</span> URLWithString:detailUrl relativeToURL:url].absoluteString;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先会先取requestUrl看下是不是一个完整的URL请求，如果是的话就直接将这个作为请求返回，紧接着会从YTKNetWorkConfig中获取预设的urlFilters，一一对它进行处理，比如添加公共字段等。最终形成一个处理后的不包括scheme，host的URL。</p>
<p>接下来就是构建baseUrl的过程，这个顺序如下：</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">request</span> --&gt;</span> <span class="function"><span class="title">cdnUrl</span>  &gt;  _config ---&gt;</span> <span class="function"><span class="title">cdnUrl</span>  &gt; request---&gt;</span> <span class="function"><span class="title">baseUrl</span> &gt; _config ---&gt;</span> baseUrl</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>总结来说就是能使用cdn的优先使用cdn的地址，不能使用的时候再选用baseUrl中的地址，能使用request的优先使用request的，没有的话使用config中的。最后将detailUrl和baseUrl进行拼接形成最终的地址。所以整个地址包含三个部分，一个是baseUrl,一个是requestUrl,然后是各个filter添加的信息。</p>
<p>接下来看下dataTask的创建这里分成三类，一个是GET方式，一个是POST方式，一个是download方式：</p>
<p><strong><strong>GET</strong></strong></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">[<span class="built_in">self</span> dataTaskWithHTTPMethod:@<span class="string">&quot;GET&quot;</span> requestSerializer:requestSerializer URLString:url parameters:param <span class="built_in">error</span>:<span class="built_in">error</span>];</span><br></pre></td></tr></table></figure>

<p><strong><strong>POST</strong></strong></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">[<span class="built_in">self</span> dataTaskWithHTTPMethod:@<span class="string">&quot;POST&quot;</span> requestSerializer:requestSerializer URLString:url parameters:param constructingBodyWithBlock:constructingBlock <span class="built_in">error</span>:<span class="built_in">error</span>];</span><br></pre></td></tr></table></figure>

<p><strong><strong>DOWNLOAD</strong></strong></p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line">[self downloadTaskWithDownloadPath:request.resumableDownloadPath</span><br><span class="line"><span class="symbol">                                        requestSerializer:</span>requestSerializer</span><br><span class="line"><span class="symbol">                                                URLString:</span>url parameters:param</span><br><span class="line"><span class="symbol">                                                 progress:</span>request.resumableDownloadProgressBlock</span><br><span class="line"><span class="symbol">                                                    error:</span>error]<span class="punctuation">;</span></span><br></pre></td></tr></table></figure>


<p>上面GET POST 最终都走到下面的方法中，无非就是constructingBodyWithBlock空与非空的区别，</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">NSURLSessionDataTask</span> *)dataTaskWithHTTPMethod:(<span class="built_in">NSString</span> *)method</span><br><span class="line">                               requestSerializer:(AFHTTPRequestSerializer *)requestSerializer</span><br><span class="line">                                       URLString:(<span class="built_in">NSString</span> *)URLString</span><br><span class="line">                                      parameters:(<span class="type">id</span>)parameters</span><br><span class="line">                       constructingBodyWithBlock:(<span class="keyword">nullable</span> <span class="type">void</span> (^)(<span class="type">id</span> &lt;AFMultipartFormData&gt; formData))block</span><br><span class="line">                                           error:(<span class="built_in">NSError</span> * _Nullable __autoreleasing *)error &#123;</span><br><span class="line">    <span class="built_in">NSMutableURLRequest</span> *request = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果constructingBodyWithBlock非空的话使用multipartFormRequestWithMethod</span></span><br><span class="line">    <span class="keyword">if</span> (block) &#123;</span><br><span class="line">        request = [requestSerializer multipartFormRequestWithMethod:method URLString:URLString parameters:parameters constructingBodyWithBlock:block error:error];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        request = [requestSerializer requestWithMethod:method URLString:URLString parameters:parameters error:error];</span><br><span class="line">    &#125;</span><br><span class="line">    __block <span class="built_in">NSURLSessionDataTask</span> *dataTask = <span class="literal">nil</span>;</span><br><span class="line">    dataTask = [_manager dataTaskWithRequest:request</span><br><span class="line">                           completionHandler:^(<span class="built_in">NSURLResponse</span> * __unused response, <span class="type">id</span> responseObject, <span class="built_in">NSError</span> *_error) &#123;</span><br><span class="line">                               [<span class="keyword">self</span> handleRequestResult:dataTask responseObject:responseObject error:_error];</span><br><span class="line">                           &#125;];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dataTask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>constructingBodyWithBlock有值的时候我们会使用请求序列化中的multipartFormRequestWithMethod进行处理，如果无值的话就会调用请求序列化器中的requestWithMethod进行处理。对请求处理后就可以使用该请求对象生成dataTask了，这部分没什么特殊的地方，我们关键来看下下载的部分：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">NSURLSessionDownloadTask</span> *)downloadTaskWithDownloadPath:(<span class="built_in">NSString</span> *)downloadPath</span><br><span class="line">                                         requestSerializer:(AFHTTPRequestSerializer *)requestSerializer</span><br><span class="line">                                                 URLString:(<span class="built_in">NSString</span> *)URLString</span><br><span class="line">                                                parameters:(<span class="type">id</span>)parameters</span><br><span class="line">                                                  progress:(<span class="keyword">nullable</span> <span class="type">void</span> (^)(<span class="built_in">NSProgress</span> *downloadProgress))downloadProgressBlock</span><br><span class="line">                                                     error:(<span class="built_in">NSError</span> * _Nullable __autoreleasing *)error &#123;</span><br><span class="line">    <span class="comment">// add parameters to URL;</span></span><br><span class="line">    <span class="built_in">NSMutableURLRequest</span> *urlRequest = [requestSerializer requestWithMethod:<span class="string">@&quot;GET&quot;</span> URLString:URLString parameters:parameters error:error];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSString</span> *downloadTargetPath;</span><br><span class="line">    <span class="type">BOOL</span> isDirectory;</span><br><span class="line">    <span class="keyword">if</span>(![[<span class="built_in">NSFileManager</span> defaultManager] fileExistsAtPath:downloadPath isDirectory:&amp;isDirectory]) &#123;</span><br><span class="line">        isDirectory = <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// If targetPath is a directory, use the file name we got from the urlRequest.</span></span><br><span class="line">    <span class="comment">// Make sure downloadTargetPath is always a file, not directory.</span></span><br><span class="line">    <span class="comment">// 构建下载路径downloadTargetPath</span></span><br><span class="line">    <span class="keyword">if</span> (isDirectory) &#123;</span><br><span class="line">        <span class="comment">//如果给定的downloadpath是目录路径，那么将会将下载url下的最后部分作为文件名添加到最后，形成最终的下载文件地址</span></span><br><span class="line">        <span class="built_in">NSString</span> *fileName = [urlRequest.URL lastPathComponent];</span><br><span class="line">        downloadTargetPath = [<span class="built_in">NSString</span> pathWithComponents:@[downloadPath, fileName]];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        downloadTargetPath = downloadPath;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在下载前如果文件存在先直接删除？ 直接删除不先下到缓存再？</span></span><br><span class="line">    <span class="keyword">if</span> ([[<span class="built_in">NSFileManager</span> defaultManager] fileExistsAtPath:downloadTargetPath]) &#123;</span><br><span class="line">        [[<span class="built_in">NSFileManager</span> defaultManager] removeItemAtPath:downloadTargetPath error:<span class="literal">nil</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">BOOL</span> resumeSucceeded = <span class="literal">NO</span>;</span><br><span class="line">    __block <span class="built_in">NSURLSessionDownloadTask</span> *downloadTask = <span class="literal">nil</span>;</span><br><span class="line">    <span class="comment">//未下载完成存储路径</span></span><br><span class="line">    <span class="built_in">NSURL</span> *localUrl = [<span class="keyword">self</span> incompleteDownloadTempPathForDownloadPath:downloadPath];</span><br><span class="line">    <span class="keyword">if</span> (localUrl != <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="comment">// 是否存在未下载完成的文件</span></span><br><span class="line">        <span class="type">BOOL</span> resumeDataFileExists = [[<span class="built_in">NSFileManager</span> defaultManager] fileExistsAtPath:localUrl.path];</span><br><span class="line">        <span class="comment">// 加载数据</span></span><br><span class="line">        <span class="built_in">NSData</span> *data = [<span class="built_in">NSData</span> dataWithContentsOfURL:localUrl];</span><br><span class="line">        <span class="comment">// 数据是否合法</span></span><br><span class="line">        <span class="type">BOOL</span> resumeDataIsValid = [YTKNetworkUtils validateResumeData:data];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//是否可以恢复</span></span><br><span class="line">        <span class="type">BOOL</span> canBeResumed = resumeDataFileExists &amp;&amp; resumeDataIsValid;</span><br><span class="line">        <span class="comment">// Try to resume with resumeData.</span></span><br><span class="line">        <span class="comment">// Even though we try to validate the resumeData, this may still fail and raise excecption.</span></span><br><span class="line">        <span class="keyword">if</span> (canBeResumed) &#123;</span><br><span class="line">            <span class="keyword">@try</span> &#123;</span><br><span class="line">                downloadTask = [_manager downloadTaskWithResumeData:data progress:downloadProgressBlock destination:^<span class="built_in">NSURL</span> * _Nonnull(<span class="built_in">NSURL</span> * _Nonnull targetPath, <span class="built_in">NSURLResponse</span> * _Nonnull response) &#123;</span><br><span class="line">                    <span class="keyword">return</span> [<span class="built_in">NSURL</span> fileURLWithPath:downloadTargetPath isDirectory:<span class="literal">NO</span>];</span><br><span class="line">                &#125; completionHandler:</span><br><span class="line">                                ^(<span class="built_in">NSURLResponse</span> * _Nonnull response, <span class="built_in">NSURL</span> * _Nullable filePath, <span class="built_in">NSError</span> * _Nullable error) &#123;</span><br><span class="line">                                    [<span class="keyword">self</span> handleRequestResult:downloadTask responseObject:filePath error:error];</span><br><span class="line">                                &#125;];</span><br><span class="line">                resumeSucceeded = <span class="literal">YES</span>;</span><br><span class="line">            &#125; <span class="keyword">@catch</span> (<span class="built_in">NSException</span> *exception) &#123;</span><br><span class="line">                YTKLog(<span class="string">@&quot;Resume download failed, reason = %@&quot;</span>, exception.reason);</span><br><span class="line">                resumeSucceeded = <span class="literal">NO</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//重新开始下载</span></span><br><span class="line">    <span class="keyword">if</span> (!resumeSucceeded) &#123;</span><br><span class="line">        downloadTask = [_manager downloadTaskWithRequest:urlRequest progress:downloadProgressBlock destination:^<span class="built_in">NSURL</span> * _Nonnull(<span class="built_in">NSURL</span> * _Nonnull targetPath, <span class="built_in">NSURLResponse</span> * _Nonnull response) &#123;</span><br><span class="line">            <span class="keyword">return</span> [<span class="built_in">NSURL</span> fileURLWithPath:downloadTargetPath isDirectory:<span class="literal">NO</span>];</span><br><span class="line">        &#125; completionHandler:</span><br><span class="line">                        ^(<span class="built_in">NSURLResponse</span> * _Nonnull response, <span class="built_in">NSURL</span> * _Nullable filePath, <span class="built_in">NSError</span> * _Nullable error) &#123;</span><br><span class="line">                            [<span class="keyword">self</span> handleRequestResult:downloadTask responseObject:filePath error:error];</span><br><span class="line">                        &#125;];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> downloadTask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>首先会先通过判断传进来的downloadPath是否是目录名称，如果是则将url最后的部分作为文件名添加到path最后，如果是文件名，则直接作为目标下载地址</li>
<li>紧接着如果要下载的文件已经存在那么在下载之前先删除这个文件</li>
<li>然后再去临时目录去看是否有之前下载一半没有下载结束的缓存文件，临时目录下的这些缓存文件命名规则大家可以看下这部分代码：</li>
</ol>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">NSURL</span> *)incompleteDownloadTempPathForDownloadPath:(<span class="built_in">NSString</span> *)downloadPath &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *tempPath = <span class="literal">nil</span>;</span><br><span class="line">    <span class="comment">//通过下载路径生成MD5字符串 最终生成 temp路径 + Incomplete + MD5[downloadPath]</span></span><br><span class="line">    <span class="built_in">NSString</span> *md5URLString = [YTKNetworkUtils md5StringFromString:downloadPath];</span><br><span class="line">    tempPath = [[<span class="keyword">self</span> incompleteDownloadTempCacheFolder] stringByAppendingPathComponent:md5URLString];</span><br><span class="line">    <span class="keyword">return</span> tempPath == <span class="literal">nil</span> ? <span class="literal">nil</span> : [<span class="built_in">NSURL</span> fileURLWithPath:tempPath];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>如果有上一次下载一半的数据，就先加载到内存，验证数据的合法性，如果数据存在，并且合法，就通过downloadTaskWithResumeData创建dataTask，否则通过downloadTaskWithRequest来创建。</li>
</ol>
<p><strong><strong>请求结束处理</strong></strong></p>
<p>请求结束统一调用handleRequestResult进行处理：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)handleRequestResult:(<span class="built_in">NSURLSessionTask</span> *)task responseObject:(<span class="type">id</span>)responseObject error:(<span class="built_in">NSError</span> *)error &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//取出请求</span></span><br><span class="line">    Lock();</span><br><span class="line">    YTKBaseRequest *request = _requestsRecord[@(task.taskIdentifier)];</span><br><span class="line">    Unlock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// When the request is cancelled and removed from records, the underlying</span></span><br><span class="line">    <span class="comment">// AFNetworking failure callback will still kicks in, resulting in a nil `request`.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Here we choose to completely ignore cancelled tasks. Neither success or failure</span></span><br><span class="line">    <span class="comment">// callback will be called.</span></span><br><span class="line">    <span class="keyword">if</span> (!request) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    YTKLog(<span class="string">@&quot;Finished Request: %@&quot;</span>, <span class="built_in">NSStringFromClass</span>([request <span class="keyword">class</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSError</span> * __autoreleasing serializationError = <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">NSError</span> * __autoreleasing validationError = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSError</span> *requestError = <span class="literal">nil</span>;</span><br><span class="line">    <span class="type">BOOL</span> succeed = <span class="literal">NO</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将结果传递给responseObject</span></span><br><span class="line">    request.responseObject = responseObject;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//通过对应的response序列化器进行处理</span></span><br><span class="line">    <span class="keyword">if</span> ([request.responseObject isKindOfClass:[<span class="built_in">NSData</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        </span><br><span class="line">        request.responseData = responseObject;</span><br><span class="line">        request.responseString = [[<span class="built_in">NSString</span> alloc] initWithData:responseObject encoding:[YTKNetworkUtils stringEncodingWithRequest:request]];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (request.responseSerializerType) &#123;</span><br><span class="line">            <span class="keyword">case</span> YTKResponseSerializerTypeHTTP:</span><br><span class="line">                <span class="comment">// Default serializer. Do nothing.</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> YTKResponseSerializerTypeJSON:</span><br><span class="line">                request.responseObject = [<span class="keyword">self</span>.jsonResponseSerializer responseObjectForResponse:task.response data:request.responseData error:&amp;serializationError];</span><br><span class="line">                request.responseJSONObject = request.responseObject;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> YTKResponseSerializerTypeXMLParser:</span><br><span class="line">                request.responseObject = [<span class="keyword">self</span>.xmlParserResponseSerialzier responseObjectForResponse:task.response data:request.responseData error:&amp;serializationError];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        succeed = <span class="literal">NO</span>;</span><br><span class="line">        requestError = error;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (serializationError) &#123;</span><br><span class="line">        succeed = <span class="literal">NO</span>;</span><br><span class="line">        requestError = serializationError;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        succeed = [<span class="keyword">self</span> validateResult:request error:&amp;validationError];</span><br><span class="line">        requestError = validationError;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//通知到外部</span></span><br><span class="line">    <span class="keyword">if</span> (succeed) &#123;</span><br><span class="line">        [<span class="keyword">self</span> requestDidSucceedWithRequest:request];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        [<span class="keyword">self</span> requestDidFailWithRequest:request error:requestError];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        <span class="comment">//清除成功失败回调</span></span><br><span class="line">        [<span class="keyword">self</span> removeRequestFromRecord:request];</span><br><span class="line">        [request clearCompletionBlock];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据上面加载的请求发起的流程来看，不难猜出下载结束后的工作应该是，将请求数据通过response 序列化器进行处理后存放到YTKBaseRequest中，然后通过对应的block以及delegte将数据交付到应用层，然后将delegate以及block清除，但是我们知道请求返回后AFNetWorking实际上返回的是task，responseOject,这时候并不知道具体是哪个<strong><strong>YTKBaseRequest</strong></strong>，这个问题是怎么解决的呢？我们知道在addRequest的时候会调用****[self addRequestToRecord:request]****</p>
<figure class="highlight erlang"><table><tr><td class="code"><pre><span class="line">- <span class="params">(void)</span>addRequestToRecord:<span class="params">(YTKBaseRequest *)</span>request &#123;</span><br><span class="line">    Lock<span class="params">()</span>;</span><br><span class="line">    _requestsRecord[@<span class="params">(request.requestTask.taskIdentifier)</span>] = request;</span><br><span class="line">    Unlock<span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它会以dataTask的taskIdentifier为key YTKBaseRequest为value建立一个映射表，当请求结束的时候我们得到的是一个dataTask,那么就可以通过它的taskIdentifier作为key，获得对应的YTKBaseRequest，然后将resonse序列化器处理后的结果塞到YTKBaseRequest中。这一切都结束后再将映射关系从映射表中删除。</p>
<p>我们再继续看下请求成功和失败后会怎么处理接下来的流程：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- (void)requestDidSucceedWithRequest:(YTKBaseRequest *)request &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="selector-attr">[request requestCompletePreprocessor]</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//通过外部的插件将要停止请求</span></span><br><span class="line">        <span class="selector-attr">[request toggleAccessoriesWillStopCallBack]</span>;</span><br><span class="line">        <span class="selector-attr">[request requestCompleteFilter]</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过代理通知请求已经结束</span></span><br><span class="line">        if (request.delegate != nil) &#123;</span><br><span class="line">            <span class="selector-attr">[request.delegate requestFinished:request]</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 通过block通知请求已经结束</span></span><br><span class="line">        if (request.successCompletionBlock) &#123;</span><br><span class="line">            request<span class="selector-class">.successCompletionBlock</span>(request);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//通知外部的插件已经结束</span></span><br><span class="line">        <span class="selector-attr">[request toggleAccessoriesDidStopCallBack]</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请求成功后在还没切回主线程之前会先调用requestCompletePreprocessor，在这里相当于埋下一个勾子，外面可以在这里实现类似统计之类的功能，紧接着切换到主线程，通知外部插件请求将要结束了，然后再调用requestCompleteFilter，这个和requestCompletePreprocessor功能类似，区别是一个在后台线程一个在主线程，紧接着就是通过代理和block将数据交付给上层，最后通知插件该请求结束。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)requestDidFailWithRequest:(YTKBaseRequest *)request error:(<span class="built_in">NSError</span> *)error &#123;</span><br><span class="line">    request.error = error;</span><br><span class="line">    YTKLog(<span class="string">@&quot;Request %@ failed, status code = %ld, error = %@&quot;</span>,</span><br><span class="line">           <span class="built_in">NSStringFromClass</span>([request <span class="keyword">class</span>]), (<span class="type">long</span>)request.responseStatusCode, error.localizedDescription);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从userInfo 中取出下载没完成的数据</span></span><br><span class="line">    <span class="built_in">NSData</span> *incompleteDownloadData = error.userInfo[<span class="built_in">NSURLSessionDownloadTaskResumeData</span>];</span><br><span class="line">    <span class="built_in">NSURL</span> *localUrl = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">if</span> (request.resumableDownloadPath) &#123;</span><br><span class="line">        localUrl = [<span class="keyword">self</span> incompleteDownloadTempPathForDownloadPath:request.resumableDownloadPath];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//存放到指定的路径</span></span><br><span class="line">    <span class="keyword">if</span> (incompleteDownloadData &amp;&amp; localUrl != <span class="literal">nil</span>) &#123;</span><br><span class="line">        [incompleteDownloadData writeToURL:localUrl atomically:<span class="literal">YES</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将文件从url中取出，如果是文件的话就删除下载失败的文件</span></span><br><span class="line">    <span class="keyword">if</span> ([request.responseObject isKindOfClass:[<span class="built_in">NSURL</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="built_in">NSURL</span> *url = request.responseObject;</span><br><span class="line">        <span class="keyword">if</span> (url.isFileURL &amp;&amp; [[<span class="built_in">NSFileManager</span> defaultManager] fileExistsAtPath:url.path]) &#123;</span><br><span class="line">            request.responseData = [<span class="built_in">NSData</span> dataWithContentsOfURL:url];</span><br><span class="line">            request.responseString = [[<span class="built_in">NSString</span> alloc] initWithData:request.responseData encoding:[YTKNetworkUtils stringEncodingWithRequest:request]];</span><br><span class="line">            [[<span class="built_in">NSFileManager</span> defaultManager] removeItemAtURL:url error:<span class="literal">nil</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        request.responseObject = <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        [request requestFailedPreprocessor];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//在主线程通过代理，block通知外部下载失败</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        [request toggleAccessoriesWillStopCallBack];</span><br><span class="line">        [request requestFailedFilter];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (request.delegate != <span class="literal">nil</span>) &#123;</span><br><span class="line">            [request.delegate requestFailed:request];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (request.failureCompletionBlock) &#123;</span><br><span class="line">            request.failureCompletionBlock(request);</span><br><span class="line">        &#125;</span><br><span class="line">        [request toggleAccessoriesDidStopCallBack];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>请求失败的话大体上和请求成功在流程上是一致的，只不过会在失败的时候通过****error.userInfo[NSURLSessionDownloadTaskResumeData]****拿到已经获取的数据，这时候就可以将这数据存储起来供下一次继续请求的时候实现断点续传。</p>
<p>最后看下取消请求的流程：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)cancelRequest:(YTKBaseRequest *)request &#123;</span><br><span class="line">    <span class="built_in">NSParameterAssert</span>(request != <span class="literal">nil</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果有指定恢复下载文件的路径则取消后将数据写到恢复下载文件的地方</span></span><br><span class="line">    <span class="keyword">if</span> (request.resumableDownloadPath &amp;&amp; [<span class="keyword">self</span> incompleteDownloadTempPathForDownloadPath:request.resumableDownloadPath] != <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="built_in">NSURLSessionDownloadTask</span> *requestTask = (<span class="built_in">NSURLSessionDownloadTask</span> *)request.requestTask;</span><br><span class="line">        [requestTask cancelByProducingResumeData:^(<span class="built_in">NSData</span> *resumeData) &#123;</span><br><span class="line">            <span class="built_in">NSURL</span> *localUrl = [<span class="keyword">self</span> incompleteDownloadTempPathForDownloadPath:request.resumableDownloadPath];</span><br><span class="line">            [resumeData writeToURL:localUrl atomically:<span class="literal">YES</span>];</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//直接调用NSURLSessionDataTask cancel</span></span><br><span class="line">        [request.requestTask cancel];</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="keyword">self</span> removeRequestFromRecord:request];</span><br><span class="line">    <span class="comment">//清除请求成功失败的block</span></span><br><span class="line">    [request clearCompletionBlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和请求失败处理一样可以做临时数据缓存，只不过需要通过<strong><strong>NSURLSessionDownloadTask 的 cancelByProducingResumeData</strong></strong>方法拿到已经获取的数据。再将数据写到临时目录下。</p>
<h5 id="3-批量请求"><a href="#3-批量请求" class="headerlink" title="3. 批量请求"></a>3. 批量请求</h5><p>批量请求没啥需要介绍的，就是用一个数组将YTKRequst存放起来，在start的时候一个个调用YTKRequest的start方法：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)start &#123;</span><br><span class="line">    <span class="keyword">if</span> (_finishedCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        YTKLog(<span class="string">@&quot;Error! Batch request has already started.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    _failedRequest = nil;</span><br><span class="line">    [[YTKBatchRequestAgent sharedAgent] addBatchRequest:self];</span><br><span class="line">    [<span class="meta">self toggleAccessoriesWillStartCallBack</span>];</span><br><span class="line">    <span class="keyword">for</span> (YTKRequest * req <span class="keyword">in</span> _requestArray) &#123;</span><br><span class="line">        req.<span class="built_in">delegate</span> = self;</span><br><span class="line">        [<span class="meta">req clearCompletionBlock</span>];</span><br><span class="line">        [<span class="meta">req start</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-链式请求"><a href="#4-链式请求" class="headerlink" title="4. 链式请求"></a>4. 链式请求</h5><p>链式请求是一系列有依赖关系的请求，它会在某个请求执行完毕后，进行下一个请求的启动。接下来我们以<strong><strong>添加请求</strong></strong>，<strong><strong>启动请求</strong></strong>，<strong><strong>请求结束后启动下一个请求</strong></strong>三个部分进行简单展开：</p>
<p><strong><strong>1. 添加请求</strong></strong></p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">- (void)addRequest:(YTKBaseRequest *)request callback:(YTKChainCallback)callback &#123;</span><br><span class="line">    <span class="selector-attr">[_requestArray addObject:request]</span>;</span><br><span class="line">    if (callback != nil) &#123;</span><br><span class="line">        <span class="selector-attr">[_requestCallbackArray addObject:callback]</span>;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        <span class="selector-attr">[_requestCallbackArray addObject:_emptyCallback]</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>添加请求是通过addRequest:callback方法来完成的，每个请求与callback是一一对应的，如果外面传进来一个nil callback，那么_requestCallbackArray就会添加一个空请求，作为占位。</p>
<p><strong><strong>2. 启动请求</strong></strong></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)start &#123;</span><br><span class="line">    <span class="keyword">if</span> (_nextRequestIndex &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        YTKLog(<span class="string">@&quot;Error! Chain request has already started.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ([_requestArray count] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        [<span class="keyword">self</span> toggleAccessoriesWillStartCallBack];</span><br><span class="line">        [<span class="keyword">self</span> startNextRequest];</span><br><span class="line">        [[YTKChainRequestAgent sharedAgent] addChainRequest:<span class="keyword">self</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        YTKLog(<span class="string">@&quot;Error! Chain request array is empty.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">BOOL</span>)startNextRequest &#123;</span><br><span class="line">    <span class="keyword">if</span> (_nextRequestIndex &lt; [_requestArray count]) &#123;</span><br><span class="line">        YTKBaseRequest *request = _requestArray[_nextRequestIndex];</span><br><span class="line">        _nextRequestIndex++;</span><br><span class="line">        request.delegate = <span class="keyword">self</span>;</span><br><span class="line">        [request clearCompletionBlock];</span><br><span class="line">        [request start];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个会按照请求数组的顺序一个一个取出来，调用start方法，这个就不做过多介绍了。</p>
<p><strong><strong>请求结束后启动下一个请求</strong></strong></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)requestFinished:(YTKBaseRequest *)request &#123;</span><br><span class="line">    <span class="built_in">NSUInteger</span> currentRequestIndex = _nextRequestIndex - <span class="number">1</span>;</span><br><span class="line">    YTKChainCallback callback = _requestCallbackArray[currentRequestIndex];</span><br><span class="line">    callback(<span class="keyword">self</span>, request);</span><br><span class="line">    <span class="keyword">if</span> (![<span class="keyword">self</span> startNextRequest]) &#123;</span><br><span class="line">        [<span class="keyword">self</span> toggleAccessoriesWillStopCallBack];</span><br><span class="line">        <span class="keyword">if</span> ([_delegate respondsToSelector:<span class="keyword">@selector</span>(chainRequestFinished:)]) &#123;</span><br><span class="line">            [_delegate chainRequestFinished:<span class="keyword">self</span>];</span><br><span class="line">            [[YTKChainRequestAgent sharedAgent] removeChainRequest:<span class="keyword">self</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        [<span class="keyword">self</span> toggleAccessoriesDidStopCallBack];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请求结束后会从_requestCallbackArray中获取对应的YTKChainCallback进行处理，然后调用startNextRequest开启下一个请求。</p>
<h5 id="5-缓存机制"><a href="#5-缓存机制" class="headerlink" title="5. 缓存机制"></a>5. 缓存机制</h5><p>前面已经提到YTKNetWork的缓存机制都保存在YTKRequest中，所以这部分我们来看下YTKReques：</p>
<p>依旧从启动请求开始：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)start &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.ignoreCache) &#123;</span><br><span class="line">        [<span class="keyword">self</span> startWithoutCache];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Do not cache download request.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.resumableDownloadPath) &#123;</span><br><span class="line">        [<span class="keyword">self</span> startWithoutCache];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (![<span class="keyword">self</span> loadCacheWithError:<span class="literal">nil</span>]) &#123;</span><br><span class="line">        [<span class="keyword">self</span> startWithoutCache];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _dataFromCache = <span class="literal">YES</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        [<span class="keyword">self</span> requestCompletePreprocessor];</span><br><span class="line">        [<span class="keyword">self</span> requestCompleteFilter];</span><br><span class="line">        YTKRequest *strongSelf = <span class="keyword">self</span>;</span><br><span class="line">        [strongSelf.delegate requestFinished:strongSelf];</span><br><span class="line">        <span class="keyword">if</span> (strongSelf.successCompletionBlock) &#123;</span><br><span class="line">            strongSelf.successCompletionBlock(strongSelf);</span><br><span class="line">        &#125;</span><br><span class="line">        [strongSelf clearCompletionBlock];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在启动的时候会首先根据当前情况选择是否使用缓存数据，如果我们在YTKRequest中配置了ignoreCache，或者在下载数据的情景中并且配置了resumableDownloadPath，再或者缓存加载失败都会启动无缓存请求模式，<br>除了上述情况会先通过*<em><strong>loadCacheWithError</strong></em>**将缓存再本地的数据加载到内存中：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">BOOL</span>)loadCacheWithError:(<span class="built_in">NSError</span> * _Nullable __autoreleasing *)error &#123;</span><br><span class="line">    <span class="comment">// 检查缓存时间</span></span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span> cacheTimeInSeconds] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (error) &#123;</span><br><span class="line">            *error = [<span class="built_in">NSError</span> errorWithDomain:YTKRequestCacheErrorDomain code:YTKRequestCacheErrorInvalidCacheTime userInfo:@&#123; <span class="built_in">NSLocalizedDescriptionKey</span>:<span class="string">@&quot;Invalid cache time&quot;</span>&#125;];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载缓存信息数据</span></span><br><span class="line">    <span class="keyword">if</span> (![<span class="keyword">self</span> loadCacheMetadata]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (error) &#123;</span><br><span class="line">            *error = [<span class="built_in">NSError</span> errorWithDomain:YTKRequestCacheErrorDomain code:YTKRequestCacheErrorInvalidMetadata userInfo:@&#123; <span class="built_in">NSLocalizedDescriptionKey</span>:<span class="string">@&quot;Invalid metadata. Cache may not exist&quot;</span>&#125;];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查缓存数据</span></span><br><span class="line">    <span class="keyword">if</span> (![<span class="keyword">self</span> validateCacheWithError:error]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载缓存</span></span><br><span class="line">    <span class="keyword">if</span> (![<span class="keyword">self</span> loadCacheData]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (error) &#123;</span><br><span class="line">            *error = [<span class="built_in">NSError</span> errorWithDomain:YTKRequestCacheErrorDomain code:YTKRequestCacheErrorInvalidCacheData userInfo:@&#123; <span class="built_in">NSLocalizedDescriptionKey</span>:<span class="string">@&quot;Invalid cache data&quot;</span>&#125;];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在加载数据之前会先检查下我们配置的缓存时间，如果cacheTimeInSeconds小于0的话就不再继续加载了，这时候会抛出错误。缓存数据加载失败走正常数据请求流程。否则再紧接着缓存加载的流程：</p>
<p>加载缓存信息数据<strong><strong>loadCacheMetadata</strong></strong>，检查缓存数据的合法性<strong><strong>validateCacheWithError</strong></strong>，加载数据<strong><strong>loadCacheData</strong></strong>，下面就针对这些环节进行介绍：</p>
<p><strong><strong>loadCacheMetadata</strong></strong></p>
<p>在加载缓存数据之前会先加载缓存的信息文件</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">BOOL</span>)loadCacheMetadata &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *path = [<span class="keyword">self</span> cacheMetadataFilePath];</span><br><span class="line">    <span class="built_in">NSFileManager</span> * fileManager = [<span class="built_in">NSFileManager</span> defaultManager];</span><br><span class="line">    <span class="keyword">if</span> ([fileManager fileExistsAtPath:path isDirectory:<span class="literal">nil</span>]) &#123;</span><br><span class="line">        <span class="keyword">@try</span> &#123;</span><br><span class="line">            _cacheMetadata = [<span class="built_in">NSKeyedUnarchiver</span> unarchiveObjectWithFile:path];</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">        &#125; <span class="keyword">@catch</span> (<span class="built_in">NSException</span> *exception) &#123;</span><br><span class="line">            YTKLog(<span class="string">@&quot;Load cache metadata failed, reason = %@&quot;</span>, exception.reason);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么缓存信息文件存在哪里呢？我们怎么拿现有的配置取到缓存的信息文件？带着这个疑问继续看下面的代码：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">NSString</span> *)cacheFileName &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *requestUrl = [<span class="keyword">self</span> requestUrl];</span><br><span class="line">    <span class="built_in">NSString</span> *baseUrl = [YTKNetworkConfig sharedConfig].baseUrl;</span><br><span class="line">    <span class="type">id</span> argument = [<span class="keyword">self</span> cacheFileNameFilterForRequestArgument:[<span class="keyword">self</span> requestArgument]];</span><br><span class="line">    <span class="built_in">NSString</span> *requestInfo = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;Method:%ld Host:%@ Url:%@ Argument:%@&quot;</span>,</span><br><span class="line">                             (<span class="type">long</span>)[<span class="keyword">self</span> requestMethod], baseUrl, requestUrl, argument];</span><br><span class="line">    <span class="built_in">NSString</span> *cacheFileName = [YTKNetworkUtils md5StringFromString:requestInfo];</span><br><span class="line">    <span class="keyword">return</span> cacheFileName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *)cacheMetadataFilePath &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *cacheMetadataFileName = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;%@.metadata&quot;</span>, [<span class="keyword">self</span> cacheFileName]];</span><br><span class="line">    <span class="built_in">NSString</span> *path = [<span class="keyword">self</span> cacheBasePath];</span><br><span class="line">    path = [path stringByAppendingPathComponent:cacheMetadataFileName];</span><br><span class="line">    <span class="keyword">return</span> path;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *)cacheBasePath &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *pathOfLibrary = [<span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSLibraryDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">YES</span>) objectAtIndex:<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">NSString</span> *path = [pathOfLibrary stringByAppendingPathComponent:<span class="string">@&quot;LazyRequestCache&quot;</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Filter cache base path</span></span><br><span class="line">    <span class="built_in">NSArray</span>&lt;<span class="type">id</span>&lt;YTKCacheDirPathFilterProtocol&gt;&gt; *filters = [[YTKNetworkConfig sharedConfig] cacheDirPathFilters];</span><br><span class="line">    <span class="keyword">if</span> (filters.count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">id</span>&lt;YTKCacheDirPathFilterProtocol&gt; f <span class="keyword">in</span> filters) &#123;</span><br><span class="line">            path = [f filterCacheDirPath:path withRequest:<span class="keyword">self</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span> createDirectoryIfNeeded:path];</span><br><span class="line">    <span class="keyword">return</span> path;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们先来看下<strong><strong>requestInfo</strong></strong>这个字符串是怎么来的：</p>
<figure class="highlight mel"><table><tr><td class="code"><pre><span class="line">[NSString stringWithFormat:@&quot;Method:%ld Host:%@ Url:%@ Argument:%@<span class="string">&quot;,(long)[self requestMethod], baseUrl, requestUrl, argument];</span></span><br></pre></td></tr></table></figure>
<p>requestInfo包含着Method,URL(Host：Url)，Argument，也就是说缓存文件信息文件名里面包含着一个请求的全部信息。在通过对这个字符串进行md5加密，生成的字符串作为缓存信息文件名。<br>最终文件存放在:</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">/[系统缓存路径]/</span>LazyRequestCache[这个名称会经过cacheDirPathFilters进行处理，默认是LazyRequestCache]/xxxxxxxxxxxx.metadata</span><br></pre></td></tr></table></figure>
<p>可以通过cacheDirPathFilters添加版本信息等公共的处理。</p>
<p>加载出来的对象结构如下：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YTKCacheMetadata</span> : <span class="title">NSObject</span>&lt;<span class="title">NSSecureCoding</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="type">long</span> <span class="type">long</span> version;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *sensitiveDataString;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSStringEncoding</span> stringEncoding;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSDate</span> *creationDate;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *appVersionString;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>包括缓存版本，关键字段，字符编码格式，创建时间，app版本信息。后面将会重点看下怎么利用这些信息来实现缓存策略。</p>
<p><strong><strong>validateCacheWithError</strong></strong></p>
<p>上面已经成功地加载了缓存信息文件，接下来就是对这些进行缓存信息进行校验了：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">BOOL</span>)validateCacheWithError:(<span class="built_in">NSError</span> * _Nullable __autoreleasing *)error &#123;</span><br><span class="line">    <span class="comment">// Date</span></span><br><span class="line">    <span class="built_in">NSDate</span> *creationDate = <span class="keyword">self</span>.cacheMetadata.creationDate;</span><br><span class="line">    <span class="built_in">NSTimeInterval</span> duration = -[creationDate timeIntervalSinceNow];</span><br><span class="line">    <span class="keyword">if</span> (duration &lt; <span class="number">0</span> || duration &gt; [<span class="keyword">self</span> cacheTimeInSeconds]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (error) &#123;</span><br><span class="line">            *error = [<span class="built_in">NSError</span> errorWithDomain:YTKRequestCacheErrorDomain code:YTKRequestCacheErrorExpired userInfo:@&#123; <span class="built_in">NSLocalizedDescriptionKey</span>:<span class="string">@&quot;Cache expired&quot;</span>&#125;];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Version</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> cacheVersionFileContent = <span class="keyword">self</span>.cacheMetadata.version;</span><br><span class="line">    <span class="keyword">if</span> (cacheVersionFileContent != [<span class="keyword">self</span> cacheVersion]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (error) &#123;</span><br><span class="line">            *error = [<span class="built_in">NSError</span> errorWithDomain:YTKRequestCacheErrorDomain code:YTKRequestCacheErrorVersionMismatch userInfo:@&#123; <span class="built_in">NSLocalizedDescriptionKey</span>:<span class="string">@&quot;Cache version mismatch&quot;</span>&#125;];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Sensitive data</span></span><br><span class="line">    <span class="built_in">NSString</span> *sensitiveDataString = <span class="keyword">self</span>.cacheMetadata.sensitiveDataString;</span><br><span class="line">    <span class="built_in">NSString</span> *currentSensitiveDataString = ((<span class="built_in">NSObject</span> *)[<span class="keyword">self</span> cacheSensitiveData]).description;</span><br><span class="line">    <span class="keyword">if</span> (sensitiveDataString || currentSensitiveDataString) &#123;</span><br><span class="line">        <span class="comment">// If one of the strings is nil, short-circuit evaluation will trigger</span></span><br><span class="line">        <span class="keyword">if</span> (sensitiveDataString.length != currentSensitiveDataString.length || ![sensitiveDataString isEqualToString:currentSensitiveDataString]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (error) &#123;</span><br><span class="line">                *error = [<span class="built_in">NSError</span> errorWithDomain:YTKRequestCacheErrorDomain code:YTKRequestCacheErrorSensitiveDataMismatch userInfo:@&#123; <span class="built_in">NSLocalizedDescriptionKey</span>:<span class="string">@&quot;Cache sensitive data mismatch&quot;</span>&#125;];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// App version</span></span><br><span class="line">    <span class="built_in">NSString</span> *appVersionString = <span class="keyword">self</span>.cacheMetadata.appVersionString;</span><br><span class="line">    <span class="built_in">NSString</span> *currentAppVersionString = [YTKNetworkUtils appVersionString];</span><br><span class="line">    <span class="keyword">if</span> (appVersionString || currentAppVersionString) &#123;</span><br><span class="line">        <span class="keyword">if</span> (appVersionString.length != currentAppVersionString.length || ![appVersionString isEqualToString:currentAppVersionString]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (error) &#123;</span><br><span class="line">                *error = [<span class="built_in">NSError</span> errorWithDomain:YTKRequestCacheErrorDomain code:YTKRequestCacheErrorAppVersionMismatch userInfo:@&#123; <span class="built_in">NSLocalizedDescriptionKey</span>:<span class="string">@&quot;App version mismatch&quot;</span>&#125;];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>首先是对缓存是否过期进行校验，这一步主要主要通过YTKCacheMetadata中的creationDate与当前时间计算差值，再与cacheTimeInSeconds对比判断缓存数据是否过期。<br>紧接着看缓存版本和我们request中的cacheVersion是否匹配。紧接着对比缓存的关键信息。然后再是应用版本的匹配，这些信息都匹配的时候才说明缓存是可用的，才会去加载缓存数据。</p>
<p><strong><strong>loadCacheData</strong></strong></p>
<p>紧接着会将本地缓存文件根据序列化形式加载到****_cacheData<strong><strong>，</strong></strong>_cacheString<strong><strong>，</strong></strong>_cacheXML****，</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">BOOL</span>)loadCacheData &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *path = [<span class="keyword">self</span> cacheFilePath];</span><br><span class="line">    <span class="built_in">NSFileManager</span> *fileManager = [<span class="built_in">NSFileManager</span> defaultManager];</span><br><span class="line">    <span class="built_in">NSError</span> *error = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ([fileManager fileExistsAtPath:path isDirectory:<span class="literal">nil</span>]) &#123;</span><br><span class="line">        <span class="built_in">NSData</span> *data = [<span class="built_in">NSData</span> dataWithContentsOfFile:path];</span><br><span class="line">        _cacheData = data;</span><br><span class="line">        _cacheString = [[<span class="built_in">NSString</span> alloc] initWithData:_cacheData encoding:<span class="keyword">self</span>.cacheMetadata.stringEncoding];</span><br><span class="line">        <span class="keyword">switch</span> (<span class="keyword">self</span>.responseSerializerType) &#123;</span><br><span class="line">            <span class="keyword">case</span> YTKResponseSerializerTypeHTTP:</span><br><span class="line">                <span class="comment">// Do nothing.</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">            <span class="keyword">case</span> YTKResponseSerializerTypeJSON:</span><br><span class="line">                _cacheJSON = [<span class="built_in">NSJSONSerialization</span> JSONObjectWithData:_cacheData options:(<span class="built_in">NSJSONReadingOptions</span>)<span class="number">0</span> error:&amp;error];</span><br><span class="line">                <span class="keyword">return</span> error == <span class="literal">nil</span>;</span><br><span class="line">            <span class="keyword">case</span> YTKResponseSerializerTypeXMLParser:</span><br><span class="line">                _cacheXML = [[<span class="built_in">NSXMLParser</span> alloc] initWithData:_cacheData];</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><strong>向应用层交付缓存数据</strong></strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line"><span class="string">    [self requestCompletePreprocessor]</span>;</span><br><span class="line"><span class="string">    [self requestCompleteFilter]</span>;</span><br><span class="line">    YTKRequest *strongSelf = self;</span><br><span class="line"><span class="string">    [strongSelf.delegate requestFinished:strongSelf]</span>;</span><br><span class="line">    <span class="keyword">if</span> (strongSelf.successCompletionBlock) &#123;</span><br><span class="line">        strongSelf.successCompletionBlock(strongSelf);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="string">    [strongSelf clearCompletionBlock]</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这里照样会通过delegate以及block进行交付，但是刚开始会感到奇怪我们刚刚加载数据的时候是加载到****_cacheString<strong><strong>这些地方，但是这里交付却是</strong></strong>strongSelf****，那么我们通过strongSelf的responseString这些对象访问的时候怎么转到_cacheString中的呢？</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">- (NSString *)responseString &#123;</span><br><span class="line">    <span class="keyword">if</span> (_cacheString) &#123;</span><br><span class="line">        <span class="keyword">return</span> _cacheString;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> responseString];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>嗯，就是在getter方法中拦截，所以及时重置_cacheString非常关键。</p>
<p><strong><strong>缓存数据</strong></strong></p>
<p>还有最后一个问题？这些缓存数据是怎么来的呢？</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- (<span class="type">void</span>)requestCompletePreprocessor &#123;</span><br><span class="line"></span><br><span class="line">    [<span class="variable language_">super</span> requestCompletePreprocessor];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.writeCacheAsynchronously) &#123;</span><br><span class="line">        <span class="built_in">dispatch_async</span>(ytkrequest_cache_writing_queue(), ^&#123;</span><br><span class="line">            [<span class="keyword">self</span> saveResponseDataToCacheFile:[<span class="variable language_">super</span> responseData]];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        [<span class="keyword">self</span> saveResponseDataToCacheFile:[<span class="variable language_">super</span> responseData]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们知道请求结束的时候会调用<strong><strong>requestCompletePreprocessor</strong></strong> 这时候会调用 *<em><strong>saveResponseDataToCacheFile</strong></em>**。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)saveResponseDataToCacheFile:(<span class="built_in">NSData</span> *)data &#123;</span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span> cacheTimeInSeconds] &gt; <span class="number">0</span> &amp;&amp; ![<span class="keyword">self</span> isDataFromCache]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (data != <span class="literal">nil</span>) &#123;</span><br><span class="line">            <span class="keyword">@try</span> &#123;</span><br><span class="line">                <span class="comment">// New data will always overwrite old data.</span></span><br><span class="line">                [data writeToFile:[<span class="keyword">self</span> cacheFilePath] atomically:<span class="literal">YES</span>];</span><br><span class="line"></span><br><span class="line">                YTKCacheMetadata *metadata = [[YTKCacheMetadata alloc] init];</span><br><span class="line">                metadata.version = [<span class="keyword">self</span> cacheVersion];</span><br><span class="line">                metadata.sensitiveDataString = ((<span class="built_in">NSObject</span> *)[<span class="keyword">self</span> cacheSensitiveData]).description;</span><br><span class="line">                metadata.stringEncoding = [YTKNetworkUtils stringEncodingWithRequest:<span class="keyword">self</span>];</span><br><span class="line">                metadata.creationDate = [<span class="built_in">NSDate</span> date];</span><br><span class="line">                metadata.appVersionString = [YTKNetworkUtils appVersionString];</span><br><span class="line">                [<span class="built_in">NSKeyedArchiver</span> archiveRootObject:metadata toFile:[<span class="keyword">self</span> cacheMetadataFilePath]];</span><br><span class="line">            &#125; <span class="keyword">@catch</span> (<span class="built_in">NSException</span> *exception) &#123;</span><br><span class="line">                YTKLog(<span class="string">@&quot;Save cache failed, reason = %@&quot;</span>, exception.reason);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在saveResponseDataToCacheFile方法中会将服务端返回的数据写到缓存目录下，然后再更新缓存信息。</p>
<h5 id="6-断点续传"><a href="#6-断点续传" class="headerlink" title="6. 断点续传"></a>6. 断点续传</h5><p>断点续传其实上面已经介绍过了，既然这里已经将它拎出来了，就做个总结把：</p>
<p>这里最关键在于两个方面：<br>请求中断的时候怎么缓存数据，请求开始的时候怎么续传：</p>
<p>YTKNetWork中会在请求失败，以及取消请求的时候对数据进行缓存：</p>
<p><strong><strong>失败时候进行缓存</strong></strong></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)requestDidFailWithRequest:(YTKBaseRequest *)request error:(<span class="built_in">NSError</span> *)error &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSData</span> *incompleteDownloadData = error.userInfo[<span class="built_in">NSURLSessionDownloadTaskResumeData</span>];</span><br><span class="line">    <span class="built_in">NSURL</span> *localUrl = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">if</span> (request.resumableDownloadPath) &#123;</span><br><span class="line">        localUrl = [<span class="keyword">self</span> incompleteDownloadTempPathForDownloadPath:request.resumableDownloadPath];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (incompleteDownloadData &amp;&amp; localUrl != <span class="literal">nil</span>) &#123;</span><br><span class="line">        [incompleteDownloadData writeToURL:localUrl atomically:<span class="literal">YES</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//........</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong><strong>取消请求后的缓存</strong></strong></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- (<span class="type">void</span>)cancelRequest:(YTKBaseRequest *)request &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果有指定恢复下载文件的路径则取消后将数据写到恢复下载文件的地方</span></span><br><span class="line">    <span class="keyword">if</span> (request.resumableDownloadPath &amp;&amp; [<span class="keyword">self</span> incompleteDownloadTempPathForDownloadPath:request.resumableDownloadPath] != <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="built_in">NSURLSessionDownloadTask</span> *requestTask = (<span class="built_in">NSURLSessionDownloadTask</span> *)request.requestTask;</span><br><span class="line">        [requestTask cancelByProducingResumeData:^(<span class="built_in">NSData</span> *resumeData) &#123;</span><br><span class="line">            <span class="built_in">NSURL</span> *localUrl = [<span class="keyword">self</span> incompleteDownloadTempPathForDownloadPath:request.resumableDownloadPath];</span><br><span class="line">            [resumeData writeToURL:localUrl atomically:<span class="literal">YES</span>];</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//直接调用NSURLSessionDataTask cancel</span></span><br><span class="line">        [request.requestTask cancel];</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="keyword">self</span> removeRequestFromRecord:request];</span><br><span class="line">    <span class="comment">//清除请求成功失败的block</span></span><br><span class="line">    [request clearCompletionBlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动请求之前会先查看下载缓存地址，如果有数据则通过<strong><strong>downloadTaskWithResumeData</strong></strong>继续:</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">NSURLSessionDownloadTask</span> *)downloadTaskWithDownloadPath:(<span class="built_in">NSString</span> *)downloadPath</span><br><span class="line">                                         requestSerializer:(AFHTTPRequestSerializer *)requestSerializer</span><br><span class="line">                                                 URLString:(<span class="built_in">NSString</span> *)URLString</span><br><span class="line">                                                parameters:(<span class="type">id</span>)parameters</span><br><span class="line">                                                  progress:(<span class="keyword">nullable</span> <span class="type">void</span> (^)(<span class="built_in">NSProgress</span> *downloadProgress))downloadProgressBlock</span><br><span class="line">                                                     error:(<span class="built_in">NSError</span> * _Nullable __autoreleasing *)error &#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="comment">// 在下载前如果文件存在先直接删除</span></span><br><span class="line">    <span class="keyword">if</span> ([[<span class="built_in">NSFileManager</span> defaultManager] fileExistsAtPath:downloadTargetPath]) &#123;</span><br><span class="line">        [[<span class="built_in">NSFileManager</span> defaultManager] removeItemAtPath:downloadTargetPath error:<span class="literal">nil</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">BOOL</span> resumeSucceeded = <span class="literal">NO</span>;</span><br><span class="line">    __block <span class="built_in">NSURLSessionDownloadTask</span> *downloadTask = <span class="literal">nil</span>;</span><br><span class="line">    <span class="comment">//未下载完成存储路径</span></span><br><span class="line">    <span class="built_in">NSURL</span> *localUrl = [<span class="keyword">self</span> incompleteDownloadTempPathForDownloadPath:downloadPath];</span><br><span class="line">    <span class="keyword">if</span> (localUrl != <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="comment">// 是否存在未下载完成的文件</span></span><br><span class="line">        <span class="type">BOOL</span> resumeDataFileExists = [[<span class="built_in">NSFileManager</span> defaultManager] fileExistsAtPath:localUrl.path];</span><br><span class="line">        <span class="comment">// 加载数据</span></span><br><span class="line">        <span class="built_in">NSData</span> *data = [<span class="built_in">NSData</span> dataWithContentsOfURL:localUrl];</span><br><span class="line">        <span class="comment">// 数据是否合法</span></span><br><span class="line">        <span class="type">BOOL</span> resumeDataIsValid = [YTKNetworkUtils validateResumeData:data];</span><br><span class="line">        <span class="comment">//是否可以恢复</span></span><br><span class="line">        <span class="type">BOOL</span> canBeResumed = resumeDataFileExists &amp;&amp; resumeDataIsValid;</span><br><span class="line">        <span class="comment">// Try to resume with resumeData.</span></span><br><span class="line">        <span class="comment">// Even though we try to validate the resumeData, this may still fail and raise excecption.</span></span><br><span class="line">        <span class="keyword">if</span> (canBeResumed) &#123;</span><br><span class="line">            <span class="keyword">@try</span> &#123;</span><br><span class="line">                downloadTask = [_manager downloadTaskWithResumeData:data progress:downloadProgressBlock destination:^<span class="built_in">NSURL</span> * _Nonnull(<span class="built_in">NSURL</span> * _Nonnull targetPath, <span class="built_in">NSURLResponse</span> * _Nonnull response) &#123;</span><br><span class="line">                    <span class="keyword">return</span> [<span class="built_in">NSURL</span> fileURLWithPath:downloadTargetPath isDirectory:<span class="literal">NO</span>];</span><br><span class="line">                &#125; completionHandler:</span><br><span class="line">                                ^(<span class="built_in">NSURLResponse</span> * _Nonnull response, <span class="built_in">NSURL</span> * _Nullable filePath, <span class="built_in">NSError</span> * _Nullable error) &#123;</span><br><span class="line">                                    [<span class="keyword">self</span> handleRequestResult:downloadTask responseObject:filePath error:error];</span><br><span class="line">                                &#125;];</span><br><span class="line">                resumeSucceeded = <span class="literal">YES</span>;</span><br><span class="line">            &#125; <span class="keyword">@catch</span> (<span class="built_in">NSException</span> *exception) &#123;</span><br><span class="line">                YTKLog(<span class="string">@&quot;Resume download failed, reason = %@&quot;</span>, exception.reason);</span><br><span class="line">                resumeSucceeded = <span class="literal">NO</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> downloadTask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="7-Filter"><a href="#7-Filter" class="headerlink" title="7. Filter"></a>7. Filter</h5><p>在YTKNetworkConfig中有两个Filter，一个是_urlFilters，一个是_cacheDirPathFilters</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="meta">@implementation</span> <span class="type">YTKNetworkConfig</span> &#123;</span><br><span class="line">    <span class="type">NSMutableArray</span>&lt;id&lt;<span class="type">YTKUrlFilterProtocol</span>&gt;<span class="operator">&gt;</span> <span class="operator">*</span>_urlFilters;</span><br><span class="line">    <span class="type">NSMutableArray</span>&lt;id&lt;<span class="type">YTKCacheDirPathFilterProtocol</span>&gt;<span class="operator">&gt;</span> <span class="operator">*</span>_cacheDirPathFilters;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>url filter它会对所有发起请求的requestUrl进行处理：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">- (NSString *)buildRequestUrl:(YTKBaseRequest *)request &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="regexp">//</span>.......</span><br><span class="line">    </span><br><span class="line">    <span class="regexp">//</span> 对构建出来的URL通过Config中预设的urlFilters 一一对它进行处理，比如添加公共字段等</span><br><span class="line">    NSArray *filters = [_config urlFilters];</span><br><span class="line">    <span class="keyword">for</span> (id&lt;YTKUrlFilterProtocol&gt; f <span class="keyword">in</span> filters) &#123;</span><br><span class="line">        detailUrl = [f filterUrl:detailUrl withRequest:request];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="regexp">//</span>......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>cacheDirPathFilters filter会在创建缓存路径的时候调用：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">NSString</span> *)cacheBasePath &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *pathOfLibrary = [<span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSLibraryDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">YES</span>) objectAtIndex:<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">NSString</span> *path = [pathOfLibrary stringByAppendingPathComponent:<span class="string">@&quot;LazyRequestCache&quot;</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Filter cache base path</span></span><br><span class="line">    <span class="built_in">NSArray</span>&lt;<span class="type">id</span>&lt;YTKCacheDirPathFilterProtocol&gt;&gt; *filters = [[YTKNetworkConfig sharedConfig] cacheDirPathFilters];</span><br><span class="line">    <span class="keyword">if</span> (filters.count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">id</span>&lt;YTKCacheDirPathFilterProtocol&gt; f <span class="keyword">in</span> filters) &#123;</span><br><span class="line">            path = [f filterCacheDirPath:path withRequest:<span class="keyword">self</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="keyword">self</span> createDirectoryIfNeeded:path];</span><br><span class="line">    <span class="keyword">return</span> path;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="8-插件机制"><a href="#8-插件机制" class="headerlink" title="8. 插件机制"></a>8. 插件机制</h5><p>插件机制，这个在很多场合都会使用，其实就是一种观察者模式，将观察者添加到要观察对象的通知列表中，一旦某个关键环节发生了，就便利这些观察者，调用他们的方法通知他们。这时候观察者就可以插入自己想要的操作：<br>YTKNetWork中目前有三个类支持插件机制，分别是<strong><strong>YTKBaseRequest</strong></strong>，<strong><strong>YTKBatchRequest</strong></strong>，<strong><strong>YTKChainRequest</strong></strong></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YTKBaseRequest</span> (<span class="title">RequestAccessory</span>)</span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)toggleAccessoriesWillStartCallBack;</span><br><span class="line">- (<span class="type">void</span>)toggleAccessoriesWillStopCallBack;</span><br><span class="line">- (<span class="type">void</span>)toggleAccessoriesDidStopCallBack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YTKBatchRequest</span> (<span class="title">RequestAccessory</span>)</span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)toggleAccessoriesWillStartCallBack;</span><br><span class="line">- (<span class="type">void</span>)toggleAccessoriesWillStopCallBack;</span><br><span class="line">- (<span class="type">void</span>)toggleAccessoriesDidStopCallBack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YTKChainRequest</span> (<span class="title">RequestAccessory</span>)</span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)toggleAccessoriesWillStartCallBack;</span><br><span class="line">- (<span class="type">void</span>)toggleAccessoriesWillStopCallBack;</span><br><span class="line">- (<span class="type">void</span>)toggleAccessoriesDidStopCallBack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>他们都持有requestAccessories:</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">nullable</span>) <span class="built_in">NSMutableArray</span>&lt;<span class="type">id</span>&lt;YTKRequestAccessory&gt;&gt; *requestAccessories;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)addAccessory:(<span class="type">id</span>&lt;YTKRequestAccessory&gt;)accessory;</span><br></pre></td></tr></table></figure>

<p>其实个人认为这里的requestAccessories权限应该限制为readonly比较合适，只是一个小建议。</p>
<p>触发时机，这里以<strong><strong>YTKBaseRequest</strong></strong>为例子，嗯，不解释看代码。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)start &#123;</span><br><span class="line">    [<span class="keyword">self</span> toggleAccessoriesWillStartCallBack];</span><br><span class="line">    [[YTKNetworkAgent sharedAgent] addRequest:<span class="keyword">self</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)stop &#123;</span><br><span class="line">    [<span class="keyword">self</span> toggleAccessoriesWillStopCallBack];</span><br><span class="line">    <span class="keyword">self</span>.delegate = <span class="literal">nil</span>;</span><br><span class="line">    [[YTKNetworkAgent sharedAgent] cancelRequest:<span class="keyword">self</span>];</span><br><span class="line">    [<span class="keyword">self</span> toggleAccessoriesDidStopCallBack];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好了 YTKNetWork的解析就到这里，今天周六，祝大家周末愉快！</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/iOS-%E5%BC%80%E6%BA%90%E5%BA%93%E5%88%86%E6%9E%90/">iOS 开源库分析</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/iOS-开源库分析/">iOS 开源库分析</a>
  </div>

</div>



<div class="comments-count">
	
	  	<span></span>
		<a href="/2019/11/28/YTKNetWork源码解析/#comments" class="ds-thread-count comments-count-link" data-thread-key="2019/11/28/YTKNetWork源码解析/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/11/28/日志库CocoaLumberjack-源码解析/" title="日志库CocoaLumberjack 源码解析" itemprop="url">日志库CocoaLumberjack 源码解析</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Edgar" target="_blank" itemprop="author">Edgar</a>
		
  <p class="article-time">
    <time datetime="2019-11-27T18:10:21.000Z" itemprop="datePublished"> Published 2019-11-28</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h5 id="开源库信息"><a href="#开源库信息" class="headerlink" title="开源库信息"></a>开源库信息</h5><p><a target="_blank" rel="noopener" href="https://github.com/CocoaLumberjack/CocoaLumberjack">CocoaLumberjack</a></p>
<p><strong><strong>架构概览</strong></strong></p>
<p><img src="/2019/11/28/%E6%97%A5%E5%BF%97%E5%BA%93CocoaLumberjack-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/00001.png"></p>
<p><strong><strong>1. DDLog</strong></strong></p>
<p>上面是CocoaLumberjack的架构图，从整体来看主要由<strong><strong>DDLog</strong></strong>这个是总的入口，用于管理DDLogger,下面是DDLog的一些关键方法与属性：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">class</span>, <span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;<span class="type">id</span>&lt;DDLogger&gt;&gt; *allLoggers;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">class</span>, <span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;DDLoggerInformation *&gt; *allLoggersWithLevel;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">class</span>, <span class="keyword">nonatomic</span>, DISPATCH_QUEUE_REFERENCE_TYPE, <span class="keyword">readonly</span>) <span class="built_in">dispatch_queue_t</span> loggingQueue;</span><br><span class="line"></span><br><span class="line">+ (<span class="type">void</span>)addLogger:(<span class="type">id</span> &lt;DDLogger&gt;)logger withLevel:(DDLogLevel)level;</span><br><span class="line">+ (<span class="type">void</span>)removeLogger:(<span class="type">id</span> &lt;DDLogger&gt;)logger;</span><br><span class="line">+ (<span class="type">void</span>)removeAllLoggers;</span><br><span class="line">+ (<span class="type">void</span>)flushLog;</span><br></pre></td></tr></table></figure>

<p><strong><strong>2. DDLogger</strong></strong></p>
<p>DDLogger是所有Logger都需要遵循的协议，我们先来看下DDLogger协议：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">DDLogger</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于格式化输出Log的格式</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="type">id</span> &lt;DDLogFormatter&gt; logFormatter;</span><br><span class="line"></span><br><span class="line"><span class="comment">//每个logger相对于其他的logger都是并行执行的，所以每个logger都有一个专门的分发队列。</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, DISPATCH_QUEUE_REFERENCE_TYPE, <span class="keyword">readonly</span>) <span class="built_in">dispatch_queue_t</span> loggerQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果logger实现方法没有提供它专有的队列，那么我们会自动为它创建一个，队列的名称将会通过这个方法获取</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSString</span> *loggerName;</span><br><span class="line"></span><br><span class="line"><span class="comment">//由于log是异步的，并且添加和删除logger也是异步的，在logger被添加到logger系统之前或者被移除之后都不会收到消息，logger可以通过这些方法做一些初始化，善后操作等</span></span><br><span class="line">- (<span class="type">void</span>)didAddLogger;</span><br><span class="line">- (<span class="type">void</span>)didAddLoggerInQueue:(<span class="built_in">dispatch_queue_t</span>)queue;</span><br><span class="line">- (<span class="type">void</span>)willRemoveLogger;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行Log输出的方法</span></span><br><span class="line">- (<span class="type">void</span>)logMessage:(DDLogMessage *)logMessage <span class="built_in">NS_SWIFT_NAME</span>(log(message:));</span><br><span class="line"></span><br><span class="line"><span class="comment">//一些logger可能为了优化性能会使用缓存，这些缓存必须在退出应用之前进行flush操作将数据写到对应的目标。</span></span><br><span class="line">- (<span class="type">void</span>)flush;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong><strong>2.1 DDAbstractLogger</strong></strong></p>
<p>DDAbstractLogger 是所有Logger 的基类，它为我们提供了默认的logger格式化方法以及默认logger队列的创建，并提供了当前logger所使用队列的情况。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">DDAbstractLogger</span> : <span class="title">NSObject</span> &lt;<span class="title">DDLogger</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">@public</span></span><br><span class="line">    <span class="type">id</span> &lt;DDLogFormatter&gt; _logFormatter;</span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> _loggerQueue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">nullable</span>) <span class="type">id</span> &lt;DDLogFormatter&gt; logFormatter;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, DISPATCH_QUEUE_REFERENCE_TYPE) <span class="built_in">dispatch_queue_t</span> loggerQueue;</span><br><span class="line"><span class="comment">//当前logger使用global queue作为logger输出队列</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">getter</span>=isOnGlobalLoggingQueue)  <span class="type">BOOL</span> onGlobalLoggingQueue;</span><br><span class="line"><span class="comment">//当前logger使用内部设计的queue作为logger输出队列</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">getter</span>=isOnInternalLoggerQueue) <span class="type">BOOL</span> onInternalLoggerQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong><strong>2.2 Loggers</strong></strong></p>
<p><strong><strong>DDASLLogger</strong></strong>:ASL是Apple System Log的缩写，它用于发送日志到苹果的日志系统，以便它们显示在Console.app上。<br><strong><strong>DDTTYLogger</strong></strong>:用于将日志发送到Xcode控制台。<br><strong><strong>DDFileLogger</strong></strong>:用于将日志写入到日志文件下。<br><strong><strong>DDOSLogger</strong></strong>：用于将日志写入到os_log<br><strong><strong>DDAbstractDatabaseLogger</strong></strong>：是数据库日志的基础类，用于方便我们进行扩展。<br>一般我们如果只需要NSLog类似的功能，只需要添加DDASLLogger和DDTTYLogger Logger,只有要生成日志文件的情况下才需要DDFileLogger</p>
<p><strong><strong>2.3 DDLogMessage</strong></strong></p>
<p>Logger消息类封装：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">@interface DDLogMessage : NSObject &lt;NSCopying&gt;</span><br><span class="line">&#123;</span><br><span class="line">    @public</span><br><span class="line">    NSString *_message;                 <span class="regexp">//</span>具体的消息</span><br><span class="line">    DDLogLevel _level;                  <span class="regexp">//</span>消息等级</span><br><span class="line">    DDLogFlag _flag;                    <span class="regexp">//</span>等级flag</span><br><span class="line">    NSInteger _context;                 <span class="regexp">//</span>上下文标记</span><br><span class="line">    NSString *_file;                    <span class="regexp">//</span>文件路径</span><br><span class="line">    NSString *_fileName;                <span class="regexp">//</span>文件名</span><br><span class="line">    NSString *_function;                <span class="regexp">//</span>方法名</span><br><span class="line">    NSUInteger _line;                   <span class="regexp">//</span>logger所在的行数</span><br><span class="line">    id _tag;                            <span class="regexp">//</span>tag标记</span><br><span class="line">    DDLogMessageOptions _options;       <span class="regexp">//</span>消息选项</span><br><span class="line">    NSDate *_timestamp;                 <span class="regexp">//</span>消息时间戳</span><br><span class="line">    NSString *_threadID;                <span class="regexp">//</span>线程id</span><br><span class="line">    NSString *_threadName;              <span class="regexp">//</span>线程名</span><br><span class="line">    NSString *_queueLabel;              <span class="regexp">//</span>队列标记</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><strong>2.4 DDLoggerInformation</strong></strong></p>
<p>DDLoggerInformation用于标示单个logger的信息，包括对应的logger以及对应的level</p>
<p><strong><strong>2.5 DDLogFormatter</strong></strong></p>
<p>DDLogFormatter用于序列化某个logger的输出格式，</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@protocol</span> DDLogFormatter &lt;NSObject&gt;</span><br><span class="line"><span class="variable">@required</span></span><br><span class="line">- (NSString * __nullable)<span class="attribute">formatLogMessage</span>:(DDLogMessage *)logMessage NS_SWIFT_NAME(format(<span class="attribute">message</span>:));</span><br><span class="line"><span class="variable">@optional</span></span><br><span class="line">- (void)<span class="attribute">didAddToLogger</span>:(id &lt;DDLogger&gt;)logger;</span><br><span class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">didAddToLogger</span>:(id &lt;DDLogger&gt;)<span class="selector-tag">logger</span> <span class="selector-tag">inQueue</span>:(dispatch_queue_t)<span class="selector-tag">queue</span>;</span><br><span class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">willRemoveFromLogger</span>:(id &lt;DDLogger&gt;)<span class="selector-tag">logger</span>;</span><br><span class="line">@<span class="selector-tag">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong><strong>DDMultiFormatter</strong></strong>: 链式log格式化器，可以添加多个格式化器，添加后每个DDLogMessage 都需要经过这个链式log格式化器的每个格式化器处理<br><strong><strong>DDContextWhitelistFilterLogFormatter</strong></strong><em>:提供黑白名单处理，只有在白名单中的logger才会被输出<br><strong><strong>DDDispatchQueueLogFormatter</strong></strong></em>:这个序列化器主要用于方便查看dispatch_queue，它会将dispatch_queue label 替代mach_thread_id作为输出。</p>
<h5 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h5><p>我们以官方的样例入手进行源码解析：</p>
<figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="symbol">DDFileLogger</span> *fileLogger = [[<span class="symbol">DDFileLogger</span> alloc] init]; </span><br><span class="line">fileLogger.logFormatter = fileFormatter</span><br><span class="line">[<span class="symbol">DDLog</span> addLogger:fileLogger];</span><br><span class="line"></span><br><span class="line"><span class="symbol">DDLogVerbose</span>(@<span class="string">&quot;Verbose&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>DDLogVerbose其实是一个宏定义，我们先来看下这个宏定义</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">#define <span class="constructor">DDLogVerbose(<span class="params">frmt</span>, <span class="operator">...</span>)</span> <span class="constructor">LOG_OBJC_MAYBE(LOG_ASYNC_VERBOSE, LOG_LEVEL_DEF, LOG_FLAG_VERBOSE, 0, <span class="params">frmt</span>, ##<span class="params">__VA_ARGS__</span>)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">#define <span class="constructor">LOG_OBJC_MAYBE(<span class="params">async</span>, <span class="params">lvl</span>, <span class="params">flg</span>, <span class="params">ctx</span>, <span class="params">frmt</span>, <span class="operator">...</span>)</span> \</span><br><span class="line">        <span class="constructor">LOG_MAYBE(<span class="params">async</span>, <span class="params">lvl</span>, <span class="params">flg</span>, <span class="params">ctx</span>, <span class="params">__PRETTY_FUNCTION__</span>, <span class="params">frmt</span>, ## <span class="params">__VA_ARGS__</span>)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#define <span class="constructor">LOG_MAYBE(<span class="params">async</span>, <span class="params">lvl</span>, <span class="params">flg</span>, <span class="params">ctx</span>, <span class="params">fnct</span>, <span class="params">frmt</span>, <span class="operator">...</span>)</span>                       \</span><br><span class="line">        <span class="keyword">do</span> &#123; <span class="keyword">if</span>(lvl &amp; flg) <span class="constructor">LOG_MACRO(<span class="params">async</span>, <span class="params">lvl</span>, <span class="params">flg</span>, <span class="params">ctx</span>, <span class="params">nil</span>, <span class="params">fnct</span>, <span class="params">frmt</span>, ##<span class="params">__VA_ARGS__</span>)</span>; &#125; <span class="keyword">while</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">#define <span class="constructor">LOG_MACRO(<span class="params">isAsynchronous</span>, <span class="params">lvl</span>, <span class="params">flg</span>, <span class="params">ctx</span>, <span class="params">atag</span>, <span class="params">fnct</span>, <span class="params">frmt</span>, <span class="operator">...</span>)</span> \</span><br><span class="line">        <span class="literal">[DDL<span class="identifier">og</span> <span class="identifier">log</span> : <span class="identifier">isAsynchronous</span>                                     \</span></span><br><span class="line"><span class="literal">             <span class="identifier">level</span> : <span class="identifier">lvl</span>                                                \</span></span><br><span class="line"><span class="literal">              <span class="identifier">flag</span> : <span class="identifier">flg</span>                                                \</span></span><br><span class="line"><span class="literal">           <span class="identifier">context</span> : <span class="identifier">ctx</span>                                                \</span></span><br><span class="line"><span class="literal">              <span class="identifier">file</span> : <span class="identifier">__FILE__</span>                                           \</span></span><br><span class="line"><span class="literal">          <span class="identifier">function</span> : <span class="identifier">fnct</span>                                               \</span></span><br><span class="line"><span class="literal">              <span class="identifier">line</span> : <span class="identifier">__LINE__</span>                                           \</span></span><br><span class="line"><span class="literal">               <span class="identifier">tag</span> : <span class="identifier">atag</span>                                               \</span></span><br><span class="line"><span class="literal">            <span class="identifier">format</span> : (<span class="identifier">frmt</span>), ## <span class="identifier">__VA_ARGS__</span>]</span></span><br></pre></td></tr></table></figure>

<p>我们开始分析上面的宏定义：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_ASYNC_ENABLED YES</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_ASYNC_VERBOSE  (YES &amp;&amp; LOG_ASYNC_ENABLED)</span></span><br></pre></td></tr></table></figure>
<p>根据LOG_ASYNC_ENABLED 以及LOG_ASYNC_VERBOSE的定义我们可以看出默认的LOG_ASYNC_VERBOSE为YES</p>
<p>我们再来看下LOG_OBJC_MAYBE的第二个参数LOG_LEVEL_DEF，我们的等级可以通过两种方式来定义，一种是定义LOG_LEVEL_DEF，这种情况下，就直接使用LOG_LEVEL_DEF的值，一种是不定义LOG_LEVEL_DEF只定义ddLogLevel，这种情况下使用ddLogLevel的值，</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> LOG_LEVEL_DEF</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> LOG_LEVEL_DEF ddLogLevel</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>接下来是第三个参数LOG_FLAG_VERBOSE，它主要用于过滤某个等级的log的消息。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_FLAG_VERBOSE  DDLogFlagVerbose</span></span><br></pre></td></tr></table></figure>

<p>在LOG_MAYBE宏中会对LOG_LEVEL_DEF和LOG_FLAG_VERBOSE进行一个并运算，判断当前的LOG_FLAG 是否在LOG_LEVEL_DEF范围内，如果是的话则调用LOG_MACRO输出log。</p>
<p>我们来看下log方法，我们这里不再去层层看消息是怎么拼接的，我们只看最终调用的那个log方法：</p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line">- (void)log:(BOOL)asynchronous          <span class="comment">//根据上面分析，默认这里为YES</span></span><br><span class="line"><span class="symbol">    message:</span>(NSString *)message         <span class="comment">//这是要输出的log消息</span></span><br><span class="line"><span class="symbol">      level:</span>(DDLogLevel)level           <span class="comment">//消息等级</span></span><br><span class="line"><span class="symbol">       flag:</span>(DDLogFlag)flag             <span class="comment">//消息flag</span></span><br><span class="line"><span class="symbol">    context:</span>(NSInteger)context          <span class="comment">//附加context 这里为0</span></span><br><span class="line"><span class="symbol">       file:</span>(const char *)file          <span class="comment">//当前文件</span></span><br><span class="line"><span class="symbol">   function:</span>(const char *)function      <span class="comment">//方法名</span></span><br><span class="line"><span class="symbol">       line:</span>(NSUInteger)line            <span class="comment">//输出log的行</span></span><br><span class="line"><span class="symbol">        tag:</span>(id)<span class="title class_">tag</span> <span class="punctuation">&#123;</span>                   <span class="comment">//tag标记</span></span><br><span class="line">    DDLogMessage *logM<span class="attr">essage</span> <span class="operator">=</span> [[DDLogMessage alloc] initWithMessage:message</span><br><span class="line"><span class="symbol">                                                               level:</span>level</span><br><span class="line"><span class="symbol">                                                                flag:</span>flag</span><br><span class="line"><span class="symbol">                                                             context:</span>context</span><br><span class="line"><span class="symbol">                                                                file:</span>[NSString stringWithFormat:@<span class="string">&quot;%s&quot;</span>, file]</span><br><span class="line"><span class="symbol">                                                            function:</span>[NSString stringWithFormat:@<span class="string">&quot;%s&quot;</span>, function]</span><br><span class="line"><span class="symbol">                                                                line:</span>line</span><br><span class="line"><span class="symbol">                                                                 tag:</span>tag</span><br><span class="line"><span class="symbol">                                                             options:</span>(DDLogMessageOptions)<span class="number">0</span></span><br><span class="line"><span class="symbol">                                                           timestamp:</span>nil]<span class="punctuation">;</span></span><br><span class="line">    [self queueLogMessage:logMessage asynchronously:asynchronous]<span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>log方法中使用调用方法的参数构建出一个DDLogMessage，然后通过queueLogMessage将消息添加到队列，这里需要注意的是：</p>
<p>在队列尺寸小于maximumQueueSize的时候，只是简单地将消息添加到队列，这时候我们不会使用任何锁来锁住操作，但是如果队列尺寸超过了maximumQueueSize那么就会锁住操作。一旦有有log出队列了，被锁住的操作将会被解锁，CocoaLumberjack,使用计数信号量来作为锁，最大的队列尺寸被定义为DDLOG_MAX_QUEUE_SIZE</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">- (void)queueLogMessage:(DDLogMessage *)logMessage asynchronously:(BOOL)asyncFlag &#123;</span><br><span class="line">  </span><br><span class="line">    dispatch_block_t logBlock = ^&#123;</span><br><span class="line">        dispatch<span class="constructor">_semaphore_wait(<span class="params">_queueSemaphore</span>, DISPATCH_TIME_FOREVER)</span>;</span><br><span class="line">        @autoreleasepool &#123;</span><br><span class="line">            <span class="literal">[<span class="identifier">self</span> <span class="identifier">lt_log</span>:<span class="identifier">logMessage</span>]</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (asyncFlag) &#123;</span><br><span class="line">        dispatch<span class="constructor">_async(<span class="params">_loggingQueue</span>, <span class="params">logBlock</span>)</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dispatch<span class="constructor">_sync(<span class="params">_loggingQueue</span>, <span class="params">logBlock</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line">- (void)lt_log:(DDLogMessage *)logMessage &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">_numProcessors</span> &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (DDLoggerNode *loggerNode <span class="built_in">in</span> self.<span class="variable">_loggers</span>) &#123;</span><br><span class="line">            <span class="comment">// skip the loggers that shouldn&#x27;t write this message based on the log level</span></span><br><span class="line">            <span class="keyword">if</span> (!(logMessage-&gt;<span class="variable">_flag</span> &amp; loggerNode-&gt;<span class="variable">_level</span>)) &#123;</span><br><span class="line">                <span class="built_in">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dispatch_group_async(<span class="variable">_loggingGroup</span>, loggerNode-&gt;<span class="variable">_loggerQueue</span>, ^&#123; @autoreleasepool &#123;</span><br><span class="line">                [loggerNode-&gt;<span class="variable">_logger</span> logMessage:logMessage];</span><br><span class="line">            &#125; &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        dispatch_group_wait(<span class="variable">_loggingGroup</span>, DISPATCH_TIME_FOREVER);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (DDLoggerNode *loggerNode <span class="built_in">in</span> self.<span class="variable">_loggers</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!(logMessage-&gt;<span class="variable">_flag</span> &amp; loggerNode-&gt;<span class="variable">_level</span>)) &#123;</span><br><span class="line">                <span class="built_in">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dispatch_sync(loggerNode-&gt;<span class="variable">_loggerQueue</span>, ^&#123; @autoreleasepool &#123;</span><br><span class="line">                [loggerNode-&gt;<span class="variable">_logger</span> logMessage:logMessage];</span><br><span class="line">            &#125; &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dispatch_semaphore_signal(<span class="variable">_queueSemaphore</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>lt_log 会首先判断当前环境是否是多核环境，如果是多核处理器环境下，每个logger的log任务都会被加到自己的队列中，并行执行，但是在多核处理器的环境下，这些任务还会被加到同一个组中，并且会等到组内所有的log都执行完毕后往下执行。如果在单核环境下每个logger只是简单地将log任务添加到自己的队列中，然后看是否超过最大队列长度，如果超过了就会等待。直到有任务完成并出队列。</p>
<p>我们先回头看下DDLog的初始化以及logger是怎么添加的。</p>
<p><strong><strong>DDLog 初始化</strong></strong></p>
<p>这部分我们先来看下DDLog长啥样：</p>
<p>DDLog有如下几个重要的变量：</p>
<p>有关DDLog所有的操作都放在_loggingQueue，以保证它的所有操作都串行化,后续所有的addLogger，removeLogger，allLoggers等等都放在这个队列中执行，这里需要注意的是这里的_loggingQueue与每个Logger自身的_loggerQueue不是一个东西。要注意区分。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">dispatch_queue_t</span> _loggingQueue;</span><br></pre></td></tr></table></figure>
<p>每个单独的logger都并行得执行在自己的队列，_loggingGroup用于这些并行队列的同步</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">dispatch_group_t</span> _loggingGroup;</span><br></pre></td></tr></table></figure>
<p>为了保证队列不会无限制地增加这里使用了一个信号量来控制队列的长度</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">dispatch_semaphore_t</span> _queueSemaphore;</span><br></pre></td></tr></table></figure>
<p>&#x2F;&#x2F; 处理器的数量</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">NSUInteger</span> _numProcessors;</span><br></pre></td></tr></table></figure>

<p>在第一次初始化DDLog的时候会调用initialize，在这里初始化了_loggingQueue，_loggingGroup，_queueSemaphore，_numProcessors。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">+ (<span class="type">void</span>)initialize &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> DDLogOnceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;DDLogOnceToken, ^&#123;</span><br><span class="line">        _loggingQueue = dispatch_queue_create(<span class="string">&quot;cocoa.lumberjack&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">        _loggingGroup = dispatch_group_create();</span><br><span class="line">        <span class="type">void</span> *nonNullValue = GlobalLoggingQueueIdentityKey; <span class="comment">// Whatever, just not null</span></span><br><span class="line">        dispatch_queue_set_specific(_loggingQueue, GlobalLoggingQueueIdentityKey, nonNullValue, <span class="literal">NULL</span>);</span><br><span class="line">        _queueSemaphore = dispatch_semaphore_create(DDLOG_MAX_QUEUE_SIZE);</span><br><span class="line">        _numProcessors = MAX([<span class="built_in">NSProcessInfo</span> processInfo].processorCount, (<span class="built_in">NSUInteger</span>) <span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每次初始化的时候都会调用init，但是由于DDLog以单例的形式存在所以init也只会调用一次。在这个方法中主要创建了self._loggers数组，后续添加的logger都存放在这个列表中。然后添加通知，监听applicationWillTerminate，也就是在应用快要退出的时候调用flushLog</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="operator">-</span> (id)<span class="keyword">init</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> <span class="operator">=</span> [<span class="keyword">super</span> <span class="keyword">init</span>]) &#123;</span><br><span class="line">        <span class="keyword">self</span>._loggers <span class="operator">=</span> [[<span class="type">NSMutableArray</span> alloc] initWithCapacity:<span class="number">4</span>];</span><br><span class="line">        <span class="type">NSString</span> <span class="operator">*</span>notificationName <span class="operator">=</span> @<span class="string">&quot;UIApplicationWillTerminateNotification&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (notificationName) &#123;</span><br><span class="line">            [[<span class="type">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span></span><br><span class="line">                                                     selector:<span class="meta">@selector</span>(applicationWillTerminate:)</span><br><span class="line">                                                         name:notificationName</span><br><span class="line">                                                       object:<span class="literal">nil</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="operator">-</span> (void)applicationWillTerminate:(<span class="type">NSNotification</span> <span class="operator">*</span> __attribute__((unused)))notification &#123;</span><br><span class="line">    [<span class="keyword">self</span> flushLog];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong><strong>DDLog 添加 Logger</strong></strong></p>
<p>addLogger也是DDLog中的方法所以它跑在_loggingQueue队列上：</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">addLogger</span>:(id &lt;DDLogger&gt;)<span class="selector-tag">logger</span> <span class="selector-tag">withLevel</span>:(DDLogLevel)<span class="selector-tag">level</span> &#123;</span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line">    <span class="selector-tag">dispatch_async</span>(_loggingQueue, ^&#123; <span class="variable">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="selector-attr">[self lt_addLogger:logger level:level]</span>;</span><br><span class="line">    &#125; &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)lt_addLogger:(<span class="type">id</span> &lt;DDLogger&gt;)logger level:(DDLogLevel)level &#123;</span><br><span class="line">    <span class="comment">// Add to loggers array.</span></span><br><span class="line">    <span class="comment">// Need to create loggerQueue if loggerNode doesn&#x27;t provide one.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断是否已经存在了</span></span><br><span class="line">    <span class="keyword">for</span> (DDLoggerNode* node <span class="keyword">in</span> <span class="keyword">self</span>._loggers) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;_logger == logger</span><br><span class="line">            &amp;&amp; node-&gt;_level == level) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSAssert</span>(dispatch_get_specific(GlobalLoggingQueueIdentityKey),</span><br><span class="line">             <span class="string">@&quot;This method should only be run on the logging thread/queue&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> loggerQueue = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断当前logger是否有自己的队列</span></span><br><span class="line">    <span class="keyword">if</span> ([logger respondsToSelector:<span class="keyword">@selector</span>(loggerQueue)]) &#123;</span><br><span class="line">        loggerQueue = [logger loggerQueue];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果没有自己的队列，则使用logger提供的loggerName方法返回的名字，创建队列</span></span><br><span class="line">    <span class="keyword">if</span> (loggerQueue == <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="type">char</span> *loggerQueueName = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span> ([logger respondsToSelector:<span class="keyword">@selector</span>(loggerName)]) &#123;</span><br><span class="line">            loggerQueueName = [[logger loggerName] UTF8String];</span><br><span class="line">        &#125;</span><br><span class="line">        loggerQueue = dispatch_queue_create(loggerQueueName, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将logger，logger队列，等级封装到DDLoggerNode后添加到_loggers</span></span><br><span class="line">    DDLoggerNode *loggerNode = [DDLoggerNode nodeWithLogger:logger loggerQueue:loggerQueue level:level];</span><br><span class="line">    [<span class="keyword">self</span>._loggers addObject:loggerNode];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通知外部当前logger已经被添加了</span></span><br><span class="line">    <span class="keyword">if</span> ([logger respondsToSelector:<span class="keyword">@selector</span>(didAddLoggerInQueue:)]) &#123;</span><br><span class="line">        <span class="built_in">dispatch_async</span>(loggerNode-&gt;_loggerQueue, ^&#123; <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">            [logger didAddLoggerInQueue:loggerNode-&gt;_loggerQueue];</span><br><span class="line">        &#125; &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([logger respondsToSelector:<span class="keyword">@selector</span>(didAddLogger)]) &#123;</span><br><span class="line">        <span class="built_in">dispatch_async</span>(loggerNode-&gt;_loggerQueue, ^&#123; <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">            [logger didAddLogger];</span><br><span class="line">        &#125; &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>lt_addLogger中将会以异步的方式将logger添加到DDLog.由于是异步方式添加，所以每个logger被添加到self._loggers中的时候每个logger的****didAddLoggerInQueue:<strong><strong>，</strong></strong>didAddLogger:****将会被调用，在这里可以做相应的处理。每个logger都拥有一个队列，可以通过两种方式指定:</p>
<p>一种是通过loggerQueue指定：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, DISPATCH_QUEUE_REFERENCE_TYPE, <span class="keyword">readonly</span>) <span class="built_in">dispatch_queue_t</span> loggerQueue;</span><br></pre></td></tr></table></figure>

<p>另一种是指定loggerName,就会将loggerName作为队列名称创建logger队列</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSString</span> *loggerName;</span><br></pre></td></tr></table></figure>

<p>后续当前logger的log都会通过这个队列来完成log的输出。</p>
<p><strong><strong>Logger 结构</strong></strong></p>
<p>我们在介绍架构的时候详细介绍过Logger的组成，这里简单重新介绍下，CocoaLumberjack 总共有 DDASLLogger，DDTTYLogger，DDFileLogger，DDOSLogger这几种Logger,并且提供了一个抽象的DDAbstractDatabaseLogger用于我们自己根据实际的业务需求进行扩展数据库Logger,这些Logger都继承自DDAbstractLogger。DDAbstractLogger比较简单主要负责每个logger Queue的创建，以及提供LoggerFormater的设置。至于log的输出形式都交给具体的Logger子类实现。</p>
<p>我们这里以比较常用的<strong><strong>DDFileLogger</strong></strong>作为重点给大家介绍下Logger的功能。</p>
<p>对于一个文件日志来说它要能够自动管理日志文件，DDFileLogger在日志超过指定时间(age)后删除，大小超过最大日志文件大小的时候将文件打包成achive文件。并且能够自定义日志文件名，以及日志文件log格式：</p>
<p>我们先来看下DDFileLogger的组成：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">DDFileLogger</span> : <span class="title">DDAbstractLogger</span> &lt;<span class="title">DDLogger</span>&gt; </span>&#123;</span><br><span class="line">	DDLogFileInfo *_currentLogFileInfo;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)init;</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithLogFileManager:(<span class="type">id</span> &lt;DDLogFileManager&gt;)logFileManager <span class="built_in">NS_DESIGNATED_INITIALIZER</span>;</span><br><span class="line"><span class="comment">//在将要写日志的时候会被调用</span></span><br><span class="line">- (<span class="type">void</span>)willLogMessage <span class="built_in">NS_REQUIRES_SUPER</span>;</span><br><span class="line"><span class="comment">//当前日志写完后会被调用</span></span><br><span class="line">- (<span class="type">void</span>)didLogMessage <span class="built_in">NS_REQUIRES_SUPER</span>;</span><br><span class="line"><span class="comment">//是否对传进来的日志文件进行打包成achive文件</span></span><br><span class="line">- (<span class="type">BOOL</span>)shouldArchiveRecentLogFileInfo:(DDLogFileInfo *)recentLogFileInfo;</span><br><span class="line"> <span class="comment">//日志文件的最大尺寸，超过这个大小将会被回滚，如果maximumFileSize设置为0则只有rollingFrequency会影响到文件的回滚</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">assign</span>) <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> maximumFileSize;</span><br><span class="line"> <span class="comment">// 回滚的频率，超过这个时间就会被回滚，maximumFileSize设置为0或者任何负数则只有maximumFileSize会影响到文件的回滚</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">assign</span>) <span class="built_in">NSTimeInterval</span> rollingFrequency;</span><br><span class="line"> <span class="comment">// 在每次启动的时候会自动创建新的日志文件，不会重用旧的</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">assign</span>, atomic) <span class="type">BOOL</span> doNotReuseLogFiles;</span><br><span class="line"> <span class="comment">// 日志文件管理类</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="type">id</span> &lt;DDLogFileManager&gt; logFileManager;</span><br><span class="line"> <span class="comment">// 会在每条日志的最后添加\n</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readwrite</span>, <span class="keyword">assign</span>) <span class="type">BOOL</span> automaticallyAppendNewlineForCustomFormatters;</span><br><span class="line"><span class="comment">// 强制roll当前日志</span></span><br><span class="line">- (<span class="type">void</span>)rollLogFileWithCompletionBlock:(<span class="type">void</span> (^)(<span class="type">void</span>))completionBlock <span class="built_in">NS_SWIFT_NAME</span>(rollLogFile(withCompletion:));</span><br><span class="line"><span class="comment">// 日志文件格式化</span></span><br><span class="line">- (<span class="type">id</span> &lt;DDLogFormatter&gt;)logFormatter;</span><br><span class="line"><span class="comment">// 当前日志文件信息</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">strong</span>) DDLogFileInfo *currentLogFileInfo;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>DDFileLogger有两个重要的对象：DDLogFileManagerDefault，以及DDLogFileFormatterDefault.前者负责日志文件的管理，后者负责日志的输出格式，这两者都可以自己实现来达到自定义的目的：</p>
<p>LogFileManager是所有日志文件都必须遵循的协议，它负责日志文件的创建，删除，日志文件命名等所有日志文件的管理,默认情况下每个日志文件的最大尺寸为1M,超过这个大小，日志文件将会被roll，默认情况下每个日志文件的有效期为24小时，超过24小时也会被roll，默认最多保存5个日志文件，整个日志磁盘配额最大为20M.</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="keyword">const</span> kDDDefaultLogMaxFileSize      = <span class="number">1024</span> * <span class="number">1024</span>;      <span class="comment">// 1 MB</span></span><br><span class="line"><span class="built_in">NSTimeInterval</span>     <span class="keyword">const</span> kDDDefaultLogRollingFrequency = <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span>;     <span class="comment">// 24 Hours</span></span><br><span class="line"><span class="built_in">NSUInteger</span>         <span class="keyword">const</span> kDDDefaultLogMaxNumLogFiles   = <span class="number">5</span>;                <span class="comment">// 5 Files</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="keyword">const</span> kDDDefaultLogFilesDiskQuota   = <span class="number">20</span> * <span class="number">1024</span> * <span class="number">1024</span>; <span class="comment">// 20 MB</span></span><br></pre></td></tr></table></figure>

<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">DDLogFileManager</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"><span class="keyword">@required</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Public properties</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 磁盘上能够存储的最多archived log文件数量，</span></span><br><span class="line"><span class="comment">// 比如我们将这个值设置为3，那么LogFileManager只会保存当前日志文件在内的3个日志文件，如果要禁止这个功能可以将这个值设置为0</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">assign</span>, atomic) <span class="built_in">NSUInteger</span> maximumNumberOfLogFiles;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 日志文件所能占用的空间大小</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">assign</span>, atomic) <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> logFilesDiskQuota;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Public methods</span></span><br><span class="line"><span class="comment">// 日志文件目录</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *logsDirectory;</span><br><span class="line"></span><br><span class="line"><span class="comment">//未排序的日志文件信息</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">strong</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *unsortedLogFilePaths;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">strong</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *unsortedLogFileNames;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">strong</span>) <span class="built_in">NSArray</span>&lt;DDLogFileInfo *&gt; *unsortedLogFileInfos;</span><br><span class="line"></span><br><span class="line"><span class="comment">//排序后的日志文件信息</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">strong</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *sortedLogFilePaths;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">strong</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *sortedLogFileNames;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">strong</span>) <span class="built_in">NSArray</span>&lt;DDLogFileInfo *&gt; *sortedLogFileInfos;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Private methods (only to be used by DDFileLogger)</span></span><br><span class="line"><span class="comment">// 创建新的Log文件</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)createNewLogFile;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@optional</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Notifications from DDFileLogger</span></span><br><span class="line"><span class="comment">// 在日志文件被archieved的时候被调用</span></span><br><span class="line">- (<span class="type">void</span>)didArchiveLogFile:(<span class="built_in">NSString</span> *)logFilePath <span class="built_in">NS_SWIFT_NAME</span>(didArchiveLogFile(atPath:));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在日志文件被roll的时候被调用</span></span><br><span class="line">- (<span class="type">void</span>)didRollAndArchiveLogFile:(<span class="built_in">NSString</span> *)logFilePath <span class="built_in">NS_SWIFT_NAME</span>(didRollAndArchiveLogFile(atPath:));</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>我们来看下默认提供的DDLogFileManagerDefault的具体实现：</p>
<p><strong><strong>初始化</strong></strong></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)initWithLogsDirectory:(<span class="built_in">NSString</span> *)aLogsDirectory &#123;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">self</span> = [<span class="variable language_">super</span> init])) &#123;</span><br><span class="line">        _maximumNumberOfLogFiles = kDDDefaultLogMaxNumLogFiles;</span><br><span class="line">        _logFilesDiskQuota = kDDDefaultLogFilesDiskQuota;</span><br><span class="line">        <span class="keyword">if</span> (aLogsDirectory) &#123;</span><br><span class="line">            _logsDirectory = [aLogsDirectory <span class="keyword">copy</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            _logsDirectory = [[<span class="keyword">self</span> defaultLogsDirectory] <span class="keyword">copy</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">NSKeyValueObservingOptions</span> kvoOptions = <span class="built_in">NSKeyValueObservingOptionOld</span> | <span class="built_in">NSKeyValueObservingOptionNew</span>;</span><br><span class="line">        [<span class="keyword">self</span> addObserver:<span class="keyword">self</span> forKeyPath:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(maximumNumberOfLogFiles)) options:kvoOptions context:<span class="literal">nil</span>];</span><br><span class="line">        [<span class="keyword">self</span> addObserver:<span class="keyword">self</span> forKeyPath:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(logFilesDiskQuota)) options:kvoOptions context:<span class="literal">nil</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化方法中会指定日志的最大文件数量以及日志文件所占用的最大空间，以及日志文件存储目录。以及使用KVO检测maximumNumberOfLogFiles，logFilesDiskQuota的设置。一旦我们对这两个值进行设置就会触发下面的方法：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath</span><br><span class="line">                      ofObject:(<span class="type">id</span>)object</span><br><span class="line">                        change:(<span class="built_in">NSDictionary</span> *)change</span><br><span class="line">                       context:(<span class="type">void</span> *)context &#123;</span><br><span class="line">    <span class="built_in">NSNumber</span> *old = change[<span class="built_in">NSKeyValueChangeOldKey</span>];</span><br><span class="line">    <span class="built_in">NSNumber</span> *new = change[<span class="built_in">NSKeyValueChangeNewKey</span>];</span><br><span class="line">    <span class="keyword">if</span> ([old isEqual:new]) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ([keyPath isEqualToString:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(maximumNumberOfLogFiles))] ||</span><br><span class="line">        [keyPath isEqualToString:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(logFilesDiskQuota))]) &#123;</span><br><span class="line">        <span class="built_in">dispatch_async</span>([DDLog loggingQueue], ^&#123; <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">                                                    [<span class="keyword">self</span> deleteOldLogFiles];</span><br><span class="line">                                                &#125; &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在设置最大磁盘空间以及最大文件数的时候会对磁盘空间情况做个扫描，将超过的部分删除。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)deleteOldLogFiles &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将缓存目录下的所有日志进行排序形成sortedLogFileInfos数组</span></span><br><span class="line">    <span class="built_in">NSArray</span> *sortedLogFileInfos = [<span class="keyword">self</span> sortedLogFileInfos];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSUInteger</span> firstIndexToDelete = <span class="built_in">NSNotFound</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> diskQuota = <span class="keyword">self</span>.logFilesDiskQuota;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">NSUInteger</span> maxNumLogFiles = <span class="keyword">self</span>.maximumNumberOfLogFiles;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//先看磁盘占用空间</span></span><br><span class="line">    <span class="keyword">if</span> (diskQuota) &#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> used = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>; i &lt; sortedLogFileInfos.count; i++) &#123;</span><br><span class="line">            DDLogFileInfo *info = sortedLogFileInfos[i];</span><br><span class="line">            used += info.fileSize;</span><br><span class="line">            <span class="keyword">if</span> (used &gt; diskQuota) &#123;</span><br><span class="line">                firstIndexToDelete = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//再看最大日志文件数</span></span><br><span class="line">    <span class="keyword">if</span> (maxNumLogFiles) &#123;</span><br><span class="line">        <span class="keyword">if</span> (firstIndexToDelete == <span class="built_in">NSNotFound</span>) &#123;</span><br><span class="line">            firstIndexToDelete = maxNumLogFiles;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            firstIndexToDelete = MIN(firstIndexToDelete, maxNumLogFiles);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//　删除超过磁盘空间和最大文件数的文件</span></span><br><span class="line">    <span class="keyword">if</span> (firstIndexToDelete != <span class="built_in">NSNotFound</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = firstIndexToDelete; i &lt; sortedLogFileInfos.count; i++) &#123;</span><br><span class="line">            DDLogFileInfo *logFileInfo = sortedLogFileInfos[i];</span><br><span class="line">            [[<span class="built_in">NSFileManager</span> defaultManager] removeItemAtPath:logFileInfo.filePath error:<span class="literal">nil</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们来看下是怎么对文件进行排序的？</p>
<figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line">- (<span class="symbol">NSArray</span> *)sortedLogFileInfos &#123;</span><br><span class="line">    return  [[self unsortedLogFileInfos] sortedArrayUsingComparator:^<span class="symbol">NSComparisonResult</span>(<span class="symbol">DDLogFileInfo</span> * <span class="symbol">_Nonnull</span> obj1, <span class="symbol">DDLogFileInfo</span>   * <span class="symbol">_Nonnull</span> obj2) &#123;</span><br><span class="line">        <span class="symbol">NSDate</span> *date1 = [<span class="symbol">NSDate</span> new];</span><br><span class="line">        <span class="symbol">NSDate</span> *date2 = [<span class="symbol">NSDate</span> new];</span><br><span class="line"></span><br><span class="line">        <span class="symbol">NSArray</span>&lt;<span class="symbol">NSString</span> *&gt; *arrayComponent = [[obj1 fileName] componentsSeparatedByString:@<span class="string">&quot; &quot;</span>];</span><br><span class="line">        if (arrayComponent.count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="symbol">NSString</span> *stringDate = arrayComponent.lastObject;</span><br><span class="line">            stringDate = [stringDate stringByReplacingOccurrencesOfString:@<span class="string">&quot;.log&quot;</span> withString:@<span class="string">&quot;&quot;</span>];</span><br><span class="line">            stringDate = [stringDate stringByReplacingOccurrencesOfString:@<span class="string">&quot;.archived&quot;</span> withString:@<span class="string">&quot;&quot;</span>];</span><br><span class="line">            date1 = [[self logFileDateFormatter] dateFromString:stringDate] ?: [obj1 creationDate];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        arrayComponent = [[obj2 fileName] componentsSeparatedByString:@<span class="string">&quot; &quot;</span>];</span><br><span class="line">        if (arrayComponent.count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="symbol">NSString</span> *stringDate = arrayComponent.lastObject;</span><br><span class="line">            stringDate = [stringDate stringByReplacingOccurrencesOfString:@<span class="string">&quot;.log&quot;</span> withString:@<span class="string">&quot;&quot;</span>];</span><br><span class="line">            stringDate = [stringDate stringByReplacingOccurrencesOfString:@<span class="string">&quot;.archived&quot;</span> withString:@<span class="string">&quot;&quot;</span>];</span><br><span class="line">            date2 = [[self logFileDateFormatter] dateFromString:stringDate] ?: [obj2 creationDate];</span><br><span class="line">        &#125;</span><br><span class="line">        return [date2 compare:date1 ?: [<span class="symbol">NSDate</span> new]];</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">NSArray</span> *)unsortedLogFileInfos &#123;</span><br><span class="line">    <span class="built_in">NSArray</span> *unsortedLogFilePaths = [<span class="keyword">self</span> unsortedLogFilePaths];</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *unsortedLogFileInfos = [<span class="built_in">NSMutableArray</span> arrayWithCapacity:[unsortedLogFilePaths count]];</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSString</span> *filePath <span class="keyword">in</span> unsortedLogFilePaths) &#123;</span><br><span class="line">        DDLogFileInfo *logFileInfo = [[DDLogFileInfo alloc] initWithFilePath:filePath];</span><br><span class="line">        [unsortedLogFileInfos addObject:logFileInfo];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> unsortedLogFileInfos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">NSArray</span> *)unsortedLogFilePaths &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *logsDirectory = [<span class="keyword">self</span> logsDirectory];</span><br><span class="line">    <span class="built_in">NSArray</span> *fileNames = [[<span class="built_in">NSFileManager</span> defaultManager] contentsOfDirectoryAtPath:logsDirectory error:<span class="literal">nil</span>];</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *unsortedLogFilePaths = [<span class="built_in">NSMutableArray</span> arrayWithCapacity:[fileNames count]];</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSString</span> *fileName <span class="keyword">in</span> fileNames) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([<span class="keyword">self</span> isLogFile:fileName]) &#123;</span><br><span class="line">            <span class="built_in">NSString</span> *filePath = [logsDirectory stringByAppendingPathComponent:fileName];</span><br><span class="line">            [unsortedLogFilePaths addObject:filePath];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> unsortedLogFilePaths;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- (<span class="type">BOOL</span>)isLogFile:(<span class="built_in">NSString</span> *)fileName &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *appName = [<span class="keyword">self</span> applicationName];</span><br><span class="line">    <span class="type">BOOL</span> hasProperPrefix = [fileName hasPrefix:[appName stringByAppendingString:<span class="string">@&quot; &quot;</span>]];</span><br><span class="line">    <span class="type">BOOL</span> hasProperSuffix = [fileName hasSuffix:<span class="string">@&quot;.log&quot;</span>];</span><br><span class="line">    <span class="keyword">return</span> (hasProperPrefix &amp;&amp; hasProperSuffix);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先会进入日志目录，对日志目录下对文件进行判断，通过isLogFile判断当前文件是否是日志文件，将日志文件添加到unsortedLogFilePaths,这里的日志文件被定义为”应用名 xxxxxxxx.log”形式的文件，这个定义是可以定制的我们在介绍日志文件的创建的时候会对这部分进行介绍。上面排序就是扫描日志文件夹下的符合日志格式的文件，将其添加到数组，再对数组的文件根据创建时间进行排序。</p>
<p>我们再来看下日志文件的创建：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">NSString</span> *)newLogFileName &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *appName = [<span class="keyword">self</span> applicationName];</span><br><span class="line">    <span class="built_in">NSDateFormatter</span> *dateFormatter = [<span class="keyword">self</span> logFileDateFormatter];</span><br><span class="line">    <span class="built_in">NSString</span> *formattedDate = [dateFormatter stringFromDate:[<span class="built_in">NSDate</span> date]];</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;%@ %@.log&quot;</span>, appName, formattedDate];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSDateFormatter</span> *)logFileDateFormatter &#123;</span><br><span class="line">    <span class="built_in">NSMutableDictionary</span> *dictionary = [[<span class="built_in">NSThread</span> currentThread]</span><br><span class="line">                                       threadDictionary];</span><br><span class="line">    <span class="built_in">NSString</span> *dateFormat = <span class="string">@&quot;yyyy&#x27;-&#x27;MM&#x27;-&#x27;dd&#x27;--&#x27;HH&#x27;-&#x27;mm&#x27;-&#x27;ss&#x27;-&#x27;SSS&#x27;&quot;</span>;</span><br><span class="line">    <span class="built_in">NSString</span> *key = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;logFileDateFormatter.%@&quot;</span>, dateFormat];</span><br><span class="line">    <span class="built_in">NSDateFormatter</span> *dateFormatter = dictionary[key];</span><br><span class="line">    <span class="keyword">if</span> (dateFormatter == <span class="literal">nil</span>) &#123;</span><br><span class="line">        dateFormatter = [[<span class="built_in">NSDateFormatter</span> alloc] init];</span><br><span class="line">        [dateFormatter setLocale:[<span class="built_in">NSLocale</span> localeWithLocaleIdentifier:<span class="string">@&quot;en_US_POSIX&quot;</span>]];</span><br><span class="line">        [dateFormatter setDateFormat:dateFormat];</span><br><span class="line">        [dateFormatter setTimeZone:[<span class="built_in">NSTimeZone</span> timeZoneForSecondsFromGMT:<span class="number">0</span>]];</span><br><span class="line">        dictionary[key] = dateFormatter;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dateFormatter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *)createNewLogFile &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *fileName = [<span class="keyword">self</span> newLogFileName];</span><br><span class="line">    <span class="built_in">NSString</span> *logsDirectory = [<span class="keyword">self</span> logsDirectory];</span><br><span class="line">    <span class="built_in">NSUInteger</span> attempt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="built_in">NSString</span> *actualFileName = fileName;</span><br><span class="line">        <span class="keyword">if</span> (attempt &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">NSString</span> *extension = [actualFileName pathExtension];</span><br><span class="line">            actualFileName = [actualFileName stringByDeletingPathExtension];</span><br><span class="line">            actualFileName = [actualFileName stringByAppendingFormat:<span class="string">@&quot; %lu&quot;</span>, (<span class="type">unsigned</span> <span class="type">long</span>)attempt];</span><br><span class="line">            <span class="keyword">if</span> (extension.length) &#123;</span><br><span class="line">                actualFileName = [actualFileName stringByAppendingPathExtension:extension];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">NSString</span> *filePath = [logsDirectory stringByAppendingPathComponent:actualFileName];</span><br><span class="line">        <span class="keyword">if</span> (![[<span class="built_in">NSFileManager</span> defaultManager] fileExistsAtPath:filePath]) &#123;</span><br><span class="line">            <span class="built_in">NSDictionary</span> *attributes = <span class="literal">nil</span>;</span><br><span class="line">            [[<span class="built_in">NSFileManager</span> defaultManager] createFileAtPath:filePath contents:<span class="literal">nil</span> attributes:attributes];</span><br><span class="line">            [<span class="keyword">self</span> deleteOldLogFiles];</span><br><span class="line">            <span class="keyword">return</span> filePath;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            attempt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="literal">YES</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面可以看出日志文件的格式为“应用名 yyyy-MM-dd–HH-mm-ss-SSS.log”存储在缓存目录下的”Log”目录，再createNewLogFile主要处理同名的情况下会追加一个数字用于避免文件名同名，比如“应用名 yyyy-MM-dd–HH-mm-ss-SSS 1.log”，“应用名 yyyy-MM-dd–HH-mm-ss-SSS 2.log”等。创建一个新的文件之后还会调用deleteOldLogFiles对当前日志文件目录下对文件进行一遍检查。</p>
<p>我们在介绍DDFileLogger之前对<strong><strong>DDLogFileManagerDefault</strong></strong>做个总结，DDLogFileManagerDefault总地来说就是负责日志文件的创建以及根据我们为日志文件设置的存储空间，以及日志文件数量进行管控，一旦超过空间大小，或者日志文件数量大于我们设定的最大数量都会删除掉最旧的那个。DDLogFileManager整体就是为了DDFileLogger服务的所以我们接下来看下DDFileLogger是怎么通过它来管理日志文件的。</p>
<p>初始化：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">    DDLogFileManagerDefault *defaultLogFileManager = [[DDLogFileManagerDefault alloc] init];</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> initWithLogFileManager:defaultLogFileManager];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithLogFileManager:(<span class="type">id</span> &lt;DDLogFileManager&gt;)aLogFileManager &#123;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">self</span> = [<span class="variable language_">super</span> init])) &#123;</span><br><span class="line">        _maximumFileSize = kDDDefaultLogMaxFileSize;</span><br><span class="line">        _rollingFrequency = kDDDefaultLogRollingFrequency;</span><br><span class="line">        _automaticallyAppendNewlineForCustomFormatters = <span class="literal">YES</span>;</span><br><span class="line">        logFileManager = aLogFileManager;</span><br><span class="line">        <span class="keyword">self</span>.logFormatter = [DDLogFileFormatterDefault new];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在初始化方法中主要初始化了logFileManager，logFormatter以及_rollingFrequency，紧接着我们从最核心的日志输出入手看下整个DDFileLogger的细节。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)logMessage:(DDLogMessage *)logMessage &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *message = logMessage-&gt;_message;</span><br><span class="line">    <span class="type">BOOL</span> isFormatted = <span class="literal">NO</span>;</span><br><span class="line">    <span class="keyword">if</span> (_logFormatter) &#123;</span><br><span class="line">        <span class="comment">//使用文件日志格式化器对传入的日志进行输出前格式化</span></span><br><span class="line">        message = [_logFormatter formatLogMessage:logMessage];</span><br><span class="line">        isFormatted = message != logMessage-&gt;_message;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (message) &#123;</span><br><span class="line">        <span class="comment">//如果_automaticallyAppendNewlineForCustomFormatters = YES,就会在格式化日志的后面追加\n</span></span><br><span class="line">        <span class="keyword">if</span> ((!isFormatted || _automaticallyAppendNewlineForCustomFormatters) &amp;&amp;</span><br><span class="line">            (![message hasSuffix:<span class="string">@&quot;\n&quot;</span>])) &#123;</span><br><span class="line">            message = [message stringByAppendingString:<span class="string">@&quot;\n&quot;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将数据转换为NSData</span></span><br><span class="line">        <span class="built_in">NSData</span> *logData = [message dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">        <span class="keyword">@try</span> &#123;</span><br><span class="line">            <span class="comment">//通知外部将要写日志了，这样可以在开始写日志前做一些处理</span></span><br><span class="line">            [<span class="keyword">self</span> willLogMessage];</span><br><span class="line">            <span class="comment">//写入日志</span></span><br><span class="line">            [[<span class="keyword">self</span> currentLogFileHandle] writeData:logData];</span><br><span class="line">            <span class="comment">//通知外部日志写入成功了</span></span><br><span class="line">            [<span class="keyword">self</span> didLogMessage];</span><br><span class="line">        &#125; <span class="keyword">@catch</span> (<span class="built_in">NSException</span> *exception) &#123;</span><br><span class="line">            <span class="comment">//如果出问题则重试10次</span></span><br><span class="line">            exception_count++;</span><br><span class="line">            <span class="keyword">if</span> (exception_count &lt;= <span class="number">10</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (exception_count == <span class="number">10</span>) &#123;</span><br><span class="line">                    <span class="built_in">NSLogError</span>(<span class="string">@&quot;DDFileLogger.logMessage: Too many exceptions -- will not log any more of them.&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们先看下默认的文件日志格式化器是怎么对消息进行格式化的：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">- (NSString *)<span class="symbol">formatLogMessage:</span>(DDLogMessage *)logMessage &#123;</span><br><span class="line">    NSString *dateAndTime = [_dateFormatter <span class="symbol">stringFromDate:</span>(logMessage-&gt;_timestamp)];</span><br><span class="line">    <span class="regexp">//</span>时间格式为yyyy/<span class="variable constant_">MM</span>/dd <span class="variable constant_">HH</span><span class="symbol">:mm</span><span class="symbol">:ss</span><span class="symbol">:SSS</span></span><br><span class="line">    <span class="keyword">return</span> [NSString <span class="symbol">stringWithFormat:</span>@<span class="string">&quot;%@  %@&quot;</span>, dateAndTime, logMessage-&gt;_message];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>formatLogMessage比较简单，就是将日志时间和日志内容进行拼接后返回。没有太大的特别处理，然后根据_automaticallyAppendNewlineForCustomFormatters的值判断是否需要在格式化后的消息尾部添加\n,在日志将要输出以及输出之后会分别调用willLogMessage，以及didLogMessage告诉外界将要开始写文件了，以及日志已经写到日志文件了。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-attr">[[self currentLogFileHandle]</span> writeData:logData];</span><br></pre></td></tr></table></figure>

<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">NSFileHandle</span> *)currentLogFileHandle &#123;</span><br><span class="line">    <span class="keyword">if</span> (_currentLogFileHandle == <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="comment">//获取到当前可用的日志文件</span></span><br><span class="line">        <span class="built_in">NSString</span> *logFilePath = [[<span class="keyword">self</span> currentLogFileInfo] filePath];</span><br><span class="line">        <span class="comment">//创建NSFileHandle</span></span><br><span class="line">        _currentLogFileHandle = [<span class="built_in">NSFileHandle</span> fileHandleForWritingAtPath:logFilePath];</span><br><span class="line">        <span class="comment">//将文件光标移到文件的最后</span></span><br><span class="line">        [_currentLogFileHandle seekToEndOfFile];</span><br><span class="line">        <span class="keyword">if</span> (_currentLogFileHandle) &#123;</span><br><span class="line">            <span class="comment">//开始定时roll</span></span><br><span class="line">            [<span class="keyword">self</span> scheduleTimerToRollLogFileDueToAge];</span><br><span class="line">            _currentLogFileVnode = dispatch_source_create(</span><br><span class="line">                    DISPATCH_SOURCE_TYPE_VNODE,</span><br><span class="line">                    [_currentLogFileHandle fileDescriptor],</span><br><span class="line">                    DISPATCH_VNODE_DELETE | DISPATCH_VNODE_RENAME,</span><br><span class="line">                    <span class="keyword">self</span>.loggerQueue</span><br><span class="line">                    );</span><br><span class="line">            dispatch_source_set_event_handler(_currentLogFileVnode, ^&#123; <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">                                                                          [<span class="keyword">self</span> rollLogFileNow];</span><br><span class="line">                                                                      &#125; &#125;);</span><br><span class="line"></span><br><span class="line">            dispatch_resume(_currentLogFileVnode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _currentLogFileHandle;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (DDLogFileInfo *)currentLogFileInfo &#123;</span><br><span class="line">    <span class="keyword">if</span> (_currentLogFileInfo == <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="comment">//拿到已经排序好的日志文件</span></span><br><span class="line">        <span class="built_in">NSArray</span> *sortedLogFileInfos = [logFileManager sortedLogFileInfos];</span><br><span class="line">        <span class="keyword">if</span> ([sortedLogFileInfos count] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//拿到排序中的第一个文件</span></span><br><span class="line">            DDLogFileInfo *mostRecentLogFileInfo = sortedLogFileInfos[<span class="number">0</span>];</span><br><span class="line">            <span class="type">BOOL</span> shouldArchiveMostRecent = <span class="literal">NO</span>;</span><br><span class="line">            <span class="comment">//如果已经archived则shouldArchiveMostRecent = NO</span></span><br><span class="line">            <span class="keyword">if</span> (mostRecentLogFileInfo.isArchived) &#123;</span><br><span class="line">                shouldArchiveMostRecent = <span class="literal">NO</span>;</span><br><span class="line">            <span class="comment">//通过外部方法拦截判断当前日志文件是否需要archive</span></span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> ([<span class="keyword">self</span> shouldArchiveRecentLogFileInfo:mostRecxentLogFileInfo]) &#123;</span><br><span class="line">				shouldArchiveMostRecent = <span class="literal">YES</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (_maximumFileSize &gt; <span class="number">0</span> &amp;&amp; mostRecentLogFileInfo.fileSize &gt;= _maximumFileSize) &#123;</span><br><span class="line">                <span class="comment">//如果当前文件尺寸大于_maximumFileSize则需要archive</span></span><br><span class="line">                shouldArchiveMostRecent = <span class="literal">YES</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_rollingFrequency &gt; <span class="number">0.0</span> &amp;&amp; mostRecentLogFileInfo.age &gt;= _rollingFrequency) &#123;</span><br><span class="line">                <span class="comment">//如果当前文件age超过了_rollingFrequency则需要archive</span></span><br><span class="line">                shouldArchiveMostRecent = <span class="literal">YES</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//.......</span></span><br><span class="line">            <span class="comment">// 如果是未achive的日志文件表示，当前可用的，将其赋给_currentLogFileInfo</span></span><br><span class="line">            <span class="keyword">if</span> (!_doNotReuseLogFiles &amp;&amp; !mostRecentLogFileInfo.isArchived &amp;&amp; !shouldArchiveMostRecent) &#123;</span><br><span class="line">                _currentLogFileInfo = mostRecentLogFileInfo;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//如果需要achive当前文件则将当前文件设置为achive并通知外部</span></span><br><span class="line">                <span class="keyword">if</span> (shouldArchiveMostRecent) &#123;</span><br><span class="line">                    mostRecentLogFileInfo.isArchived = <span class="literal">YES</span>;</span><br><span class="line">                    <span class="keyword">if</span> ([logFileManager respondsToSelector:<span class="keyword">@selector</span>(didArchiveLogFile:)]) &#123;</span><br><span class="line">                        [logFileManager didArchiveLogFile:(mostRecentLogFileInfo.filePath)];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果到这里还是空则只能新建了</span></span><br><span class="line">        <span class="keyword">if</span> (_currentLogFileInfo == <span class="literal">nil</span>) &#123;</span><br><span class="line">            <span class="built_in">NSString</span> *currentLogFilePath = [logFileManager createNewLogFile];</span><br><span class="line">            _currentLogFileInfo = [[DDLogFileInfo alloc] initWithFilePath:currentLogFilePath];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _currentLogFileInfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整个文件的创建过程都放在currentLogFileHandle中，首先会从日志文件夹中取出最新一个文件，然后判断它是否需要achive了，判断的标准先看它是否已经achive了，然后再调用外部的shouldArchiveRecentLogFileInfo来判断是否需要achive，最后再看日志文件的大小以及age是否超过限制，如果超过限制则achive。achive大家理解吗？比较难解释，就是某个日志文件不用了就要将其归档起来，上传日志的时候就上传这些归档后的日志。如果当前第一个文件不是achive文件，那么就将它赋给_currentLogFileInfo，将文件光标指向文件最后，继续往这个日志文件下写日志。这里还有一个比较重要的方法<strong><strong>scheduleTimerToRollLogFileDueToAge</strong></strong>，它用于定时扫描查看文件是否age过期了，每个日志文件都只能保留指定的时间，默认的情况下是24小时。我们来看下这个方法：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)scheduleTimerToRollLogFileDueToAge &#123;</span><br><span class="line">    <span class="keyword">if</span> (_rollingTimer) &#123;</span><br><span class="line">        dispatch_source_cancel(_rollingTimer);</span><br><span class="line">        _rollingTimer = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_currentLogFileInfo == <span class="literal">nil</span> || _rollingFrequency &lt;= <span class="number">0.0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSDate</span> *logFileCreationDate = [_currentLogFileInfo creationDate];</span><br><span class="line">    <span class="built_in">NSTimeInterval</span> ti = [logFileCreationDate timeIntervalSinceReferenceDate];</span><br><span class="line">    ti += _rollingFrequency;</span><br><span class="line">    <span class="comment">//计算下一次检查的定时时间</span></span><br><span class="line">    <span class="built_in">NSDate</span> *logFileRollingDate = [<span class="built_in">NSDate</span> dateWithTimeIntervalSinceReferenceDate:ti];</span><br><span class="line">    _rollingTimer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, <span class="number">0</span>, <span class="number">0</span>, <span class="keyword">self</span>.loggerQueue);</span><br><span class="line">    dispatch_source_set_event_handler(_rollingTimer, ^&#123; <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">                                                           [<span class="keyword">self</span> maybeRollLogFileDueToAge];</span><br><span class="line">                                                       &#125; &#125;);</span><br><span class="line">    uint64_t delay = (uint64_t)([logFileRollingDate timeIntervalSinceNow] * (<span class="built_in">NSTimeInterval</span>) <span class="built_in">NSEC_PER_SEC</span>);</span><br><span class="line">    dispatch_time_t fireTime = dispatch_time(DISPATCH_TIME_NOW, delay);</span><br><span class="line">    dispatch_source_set_timer(_rollingTimer, fireTime, DISPATCH_TIME_FOREVER, <span class="number">1</span>ull * <span class="built_in">NSEC_PER_SEC</span>);</span><br><span class="line">    dispatch_resume(_rollingTimer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line">- (void)maybeRollLogFileDueToAge &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">_rollingFrequency</span> &gt; <span class="number">0.0</span> &amp;&amp; <span class="variable">_currentLogFileInfo</span>.age &gt;= <span class="variable">_rollingFrequency</span>) &#123;</span><br><span class="line">        [self rollLogFileNow];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        [self scheduleTimerToRollLogFileDueToAge];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)rollLogFileNow &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">_currentLogFileHandle</span> == <span class="literal">nil</span>) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="variable">_currentLogFileHandle</span> synchronizeFile];</span><br><span class="line">    [<span class="variable">_currentLogFileHandle</span> closeFile];</span><br><span class="line">    <span class="variable">_currentLogFileHandle</span> = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">    <span class="variable">_currentLogFileInfo</span>.isArchived = YES;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ([logFileManager respondsToSelector:@selector(didRollAndArchiveLogFile:)]) &#123;</span><br><span class="line">        [logFileManager didRollAndArchiveLogFile:(<span class="variable">_currentLogFileInfo</span>.filePath)];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="variable">_currentLogFileInfo</span> = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">_currentLogFileVnode</span>) &#123;</span><br><span class="line">        dispatch_source_cancel(<span class="variable">_currentLogFileVnode</span>);</span><br><span class="line">        <span class="variable">_currentLogFileVnode</span> = NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">_rollingTimer</span>) &#123;</span><br><span class="line">        dispatch_source_cancel(<span class="variable">_rollingTimer</span>);</span><br><span class="line">        <span class="variable">_rollingTimer</span> = NULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>scheduleTimerToRollLogFileDueToAge会查看文件的创建时间，然后在它的基础上加上_rollingFrequency，将它作为定时器的值定时，在这之后检查当前日志文件是否过期了，如果没有过期则再次进入下一轮。rollLogFileNow就是用于将文件归档。它会关闭文件句柄，_currentLogFileInfo.isArchived其实是这里最为关键的代码。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)setIsArchived:(<span class="type">BOOL</span>)flag &#123;</span><br><span class="line">    <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">        [<span class="keyword">self</span> addExtendedAttributeWithName:kDDXAttrArchivedName];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        [<span class="keyword">self</span> removeExtendedAttributeWithName:kDDXAttrArchivedName];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)addExtensionAttributeWithName:(<span class="built_in">NSString</span> *)attrName &#123;</span><br><span class="line">    <span class="comment">// This method is only used on the iPhone simulator, where normal extended attributes are broken.</span></span><br><span class="line">    <span class="comment">// See full explanation in the header file.</span></span><br><span class="line">    <span class="keyword">if</span> ([attrName length] == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Example:</span></span><br><span class="line">    <span class="comment">// attrName = &quot;archived&quot;</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// &quot;mylog.txt&quot; -&gt; &quot;mylog.archived.txt&quot;</span></span><br><span class="line">    <span class="comment">// &quot;mylog&quot;     -&gt; &quot;mylog.archived&quot;</span></span><br><span class="line">    <span class="built_in">NSArray</span> *components = [[<span class="keyword">self</span> fileName] componentsSeparatedByString:<span class="string">@&quot;.&quot;</span>];</span><br><span class="line">    <span class="built_in">NSUInteger</span> count = [components count];</span><br><span class="line">    <span class="built_in">NSUInteger</span> estimatedNewLength = [[<span class="keyword">self</span> fileName] length] + [attrName length] + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">NSMutableString</span> *newFileName = [<span class="built_in">NSMutableString</span> stringWithCapacity:estimatedNewLength];</span><br><span class="line">    <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        [newFileName appendString:components.firstObject];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSString</span> *lastExt = <span class="string">@&quot;&quot;</span>;</span><br><span class="line">    <span class="built_in">NSUInteger</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="built_in">NSString</span> *attr = components[i];</span><br><span class="line">        <span class="keyword">if</span> ([attr length] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ([attrName isEqualToString:attr]) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ([lastExt length] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            [newFileName appendFormat:<span class="string">@&quot;.%@&quot;</span>, lastExt];</span><br><span class="line">        &#125;</span><br><span class="line">        lastExt = attr;</span><br><span class="line">    &#125;</span><br><span class="line">    [newFileName appendFormat:<span class="string">@&quot;.%@&quot;</span>, attrName];</span><br><span class="line">    <span class="keyword">if</span> ([lastExt length] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        [newFileName appendFormat:<span class="string">@&quot;.%@&quot;</span>, lastExt];</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="keyword">self</span> renameFile:newFileName];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>它就是在文件名的最末尾添加一个archived标记，下一次再次调用currentLogFileInfo的时候就会略过这个文件。</p>
<p>到此为止已经带大家过了一遍CocoaLumberjack的核心源码了，至于DDASLLogger，DDOSLogger，以及DDTTYLogger这里就不再继续展开了，代码都很简单，但是这里还是要简单提下：</p>
<p><strong><strong>DDASLLogger</strong></strong><br>DDASLLogger会在初始化后通过asl_open来建立连接，通过asl_new创建一个新的消息，然后通过asl_set来设置一系列的属性，最后通过asl_send将日志发送出去。</p>
<p><strong><strong>DDOSLogger</strong></strong><br>DDOSLogger则是通过os_log_error，os_log_info，os_log_debug将日志发送出去的。</p>
<p><strong><strong>DDTTYLogger</strong></strong><br>DDTTYLogger是通过writev(STDERR_FILENO,…,….);将日志发送到StdError终端的。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/iOS-%E5%BC%80%E6%BA%90%E5%BA%93%E5%88%86%E6%9E%90/">iOS 开源库分析</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/iOS-开源库分析/">iOS 开源库分析</a>
  </div>

</div>



<div class="comments-count">
	
	  	<span></span>
		<a href="/2019/11/28/日志库CocoaLumberjack-源码解析/#comments" class="ds-thread-count comments-count-link" data-thread-key="2019/11/28/日志库CocoaLumberjack-源码解析/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/11/26/FBRetainCycleDetector-FBAllocationTracker-FBMemoryProfiler-源码解析/" title=" FBRetainCycleDetector  FBAllocationTracker 源码解析" itemprop="url"> FBRetainCycleDetector  FBAllocationTracker 源码解析</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Edgar" target="_blank" itemprop="author">Edgar</a>
		
  <p class="article-time">
    <time datetime="2019-11-26T11:42:31.000Z" itemprop="datePublished"> Published 2019-11-26</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h5 id="开篇叨叨"><a href="#开篇叨叨" class="headerlink" title="开篇叨叨"></a>开篇叨叨</h5><p><a target="_blank" rel="noopener" href="https://github.com/facebook/FBRetainCycleDetector">FBRetainCycleDetector</a> 是FaceBook推出的用于检测对象是否有循环引用的一个开源库.下面是一个简单的用法：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&lt;FBRetainCycleDetector/FBRetainCycleDetector.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">FBRetainCycleDetector *detector = [FBRetainCycleDetector new];</span><br><span class="line">[detector addCandidate:myObject];</span><br><span class="line"><span class="built_in">NSSet</span> *retainCycles = [detector findRetainCycles];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, retainCycles);</span><br></pre></td></tr></table></figure>

<p>它先创建一个FBRetainCycleDetector循环引用检测器，然后将待检查循环引用关系的对象通过addCandidate传入，检测器通过findRetainCycles查找这个对象中的循环引用。它能通过添加Filters对某些进行过滤，并且支持检测Block,Timmer,Associations这些对象的内存泄漏。但是它不能单独在项目中使用必须借助其他工具比如FBAllocationTracker,MLeaksFinders 查找Candidates，下面这篇博客主要是对FBRetainCycleDetector源码进行分析，不对使用做过多介绍，具体使用可以在GitHub主页查看。</p>
<h4 id="FBRetainCycleDetector"><a href="#FBRetainCycleDetector" class="headerlink" title="FBRetainCycleDetector"></a>FBRetainCycleDetector</h4><h5 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h5><p>下图是FBRetainCycleDetector目录结构：</p>
<ul>
<li><img src="/2019/11/26/FBRetainCycleDetector-FBAllocationTracker-FBMemoryProfiler-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/00001.png"></li>
</ul>
<h5 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h5><p>FBRetainCycleDetector主要任务有两个：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1.</span> 找出<span class="strong">****</span>Object<span class="strong">****</span>，<span class="strong">****</span>Timer类型Object<span class="strong">****</span>，<span class="strong">****</span>Object associate类型Object<span class="strong">****</span>,<span class="strong">****</span>Block类型Object<span class="strong">****</span> 这几种类型的 Strong Reference。</span><br><span class="line"><span class="bullet">2.</span> 最开始把Self作为根节点，沿着找出的各个Reference进行深度遍历，如果形成了环，则存在循环依赖。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>OK 我们现在开始FBRetainCycleDetector的解析：</p>
<p><strong><strong>FBRetainCycleDetector 对象初始化</strong></strong></p>
<p>首先我们来看下FBRetainCycleDetector：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">FBRetainCycleDetector</span> </span>&#123;</span><br><span class="line">  <span class="built_in">NSMutableArray</span> *_candidates;</span><br><span class="line">  FBObjectGraphConfiguration *_configuration;</span><br><span class="line">  <span class="built_in">NSMutableSet</span> *_objectSet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里最重要有两个对象，_candidates是一系列待检测的对象，_configuration为配置对象，在这里可以配置需要过滤的对象，检测属性的配置等等。</p>
<p>为了简化代码的分析过程，我们以最简单的初始化形式入手看下初始化过程我们做了什么:</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">- (instancetype)init &#123;</span><br><span class="line">  <span class="keyword">return</span> [<span class="built_in">self</span> initWithConfiguration:</span><br><span class="line">          <span class="string">[[FBObjectGraphConfiguration alloc] initWithFilterBlocks:FBGetStandardGraphEdgeFilters()</span></span><br><span class="line"><span class="string">                                               shouldInspectTimers:YES]]</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)initWithConfiguration:(FBObjectGraphConfiguration *)configuration &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="variable language_">super</span> init]) &#123;</span><br><span class="line">    _configuration = configuration;</span><br><span class="line">    _candidates = [<span class="built_in">NSMutableArray</span> new];</span><br><span class="line">    _objectSet = [<span class="built_in">NSMutableSet</span> new];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在初始化过程中FBRetainCycleDetector调用了initWithConfiguration:初始化了一个标准的过滤器，过滤器过滤了引用循环中的一些类和方法，并检查NSTimer循环引用情况。</p>
<p><strong><strong>添加检测对象</strong></strong></p>
<p>待检测的对象在addCandidate方法中被封装为FBObjectiveCGraphElement对象，然后添加到_candidates中。</p>
<figure class="highlight erlang"><table><tr><td class="code"><pre><span class="line">- <span class="params">(void)</span>addCandidate:<span class="params">(id)</span>candidate &#123;</span><br><span class="line">  FBObjectiveCGraphElement *graphElement = FBWrapObjectGraphElement<span class="params">(nil, candidate, _configuration)</span>;</span><br><span class="line">  if <span class="params">(graphElement)</span> &#123;</span><br><span class="line">    [_candidates addObject:graphElement];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><strong>查找循环引用</strong></strong></p>
<p>FBRetainCycleDetector 通过调用findRetainCycles开始查找循环引用，如果某个对象比较复杂可能检测时间会比较久，所以在FBRetainCycleDetector中默认设置了一个检测深度，默认情况下为10.可以通过</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="operator">-</span> (<span class="type">NSSet</span>&lt;<span class="type">NSArray</span>&lt;<span class="type">FBObjectiveCGraphElement</span> *&gt; *&gt; <span class="operator">*</span>)findRetainCyclesWithMaxCycleLength:(<span class="type">NSUInteger</span>)length</span><br></pre></td></tr></table></figure>
<p>来指定更深的层级。我们继续看findRetainCycles，findRetainCycles内部只是简单得转调了findRetainCyclesWithMaxCycleLength方法。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="operator">-</span> (<span class="type">NSSet</span>&lt;<span class="type">NSArray</span>&lt;<span class="type">FBObjectiveCGraphElement</span> *&gt; *&gt; <span class="operator">*</span>)findRetainCycles &#123;</span><br><span class="line">  <span class="keyword">return</span> [<span class="keyword">self</span> findRetainCyclesWithMaxCycleLength:kFBRetainCycleDetectorDefaultStackDepth];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们继续跟进findRetainCyclesWithMaxCycleLength方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="operator">-</span> (<span class="type">NSSet</span>&lt;<span class="type">NSArray</span>&lt;<span class="type">FBObjectiveCGraphElement</span> *&gt; *&gt; <span class="operator">*</span>)findRetainCyclesWithMaxCycleLength:(<span class="type">NSUInteger</span>)length &#123;</span><br><span class="line">  <span class="type">NSMutableSet</span>&lt;<span class="type">NSArray</span>&lt;<span class="type">FBObjectiveCGraphElement</span> *&gt; *&gt; <span class="operator">*</span>allRetainCycles <span class="operator">=</span> [<span class="type">NSMutableSet</span> new];</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">FBObjectiveCGraphElement</span> <span class="operator">*</span>graphElement <span class="keyword">in</span> _candidates) &#123;</span><br><span class="line">    <span class="type">NSSet</span>&lt;<span class="type">NSArray</span>&lt;<span class="type">FBObjectiveCGraphElement</span> *&gt; *&gt; <span class="operator">*</span>retainCycles <span class="operator">=</span> [<span class="keyword">self</span> _findRetainCyclesInObject:graphElement</span><br><span class="line">                                                                                      stackDepth:length];</span><br><span class="line">    [allRetainCycles unionSet:retainCycles];</span><br><span class="line">  &#125;</span><br><span class="line">  [_candidates removeAllObjects];</span><br><span class="line">  [_objectSet removeAllObjects];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Filter cycles that have been broken down since we found them.</span></span><br><span class="line">  <span class="comment">// These are false-positive that were picked-up and are transient cycles.</span></span><br><span class="line">  <span class="type">NSMutableSet</span>&lt;<span class="type">NSArray</span>&lt;<span class="type">FBObjectiveCGraphElement</span> *&gt; *&gt; <span class="operator">*</span>brokenCycles <span class="operator">=</span> [<span class="type">NSMutableSet</span> <span class="keyword">set</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">NSArray</span>&lt;<span class="type">FBObjectiveCGraphElement</span> *&gt; <span class="operator">*</span>itemCycle <span class="keyword">in</span> allRetainCycles) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">FBObjectiveCGraphElement</span> <span class="operator">*</span>element <span class="keyword">in</span> itemCycle) &#123;</span><br><span class="line">      <span class="keyword">if</span> (element.object <span class="operator">==</span> <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="comment">// At least one element of the cycle has been removed, thus breaking</span></span><br><span class="line">        <span class="comment">// the cycle.</span></span><br><span class="line">        [brokenCycles addObject:itemCycle];</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  [allRetainCycles minusSet:brokenCycles];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> allRetainCycles;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>findRetainCyclesWithMaxCycleLength方法中主要可以分成两个阶段，第一个阶段通过_findRetainCyclesInObject查找被加入到_candidates中对象的循环引用放到allRetainCycles集合中 ，第二阶段是查看这些元素中哪些是已经释放了的从allRetainCycles中移除。</p>
<p>对于对象的相互引用情况可以看做一个有向图，对象之间的引用就是图的的连线，每一个对象就是有向图的顶点，查找循环引用的过程就是在整个有向图中查找闭环的过程，FBRetainCycleDetector是通过DFS深度遍历的方式遍历整个对象有向图的，整个遍历查找过程真正的实现位于<br>_findRetainCyclesInObject方法中，在分析_findRetainCyclesInObject实现之前我们先通过下面的视频看下整个算法的大概流程：</p>
 
<video width="100%" height="400" src="http://img.cdn.blogfshare.com/blogvideo_memoryleak_1.mp4" controls="controls">
</video>



<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="operator">-</span> (<span class="type">NSSet</span>&lt;<span class="type">NSArray</span>&lt;<span class="type">FBObjectiveCGraphElement</span> *&gt; *&gt; <span class="operator">*</span>)_findRetainCyclesInObject:(<span class="type">FBObjectiveCGraphElement</span> <span class="operator">*</span>)graphElement</span><br><span class="line">                                                                 stackDepth:(<span class="type">NSUInteger</span>)stackDepth &#123;</span><br><span class="line">    </span><br><span class="line">  <span class="type">NSMutableSet</span>&lt;<span class="type">NSArray</span>&lt;<span class="type">FBObjectiveCGraphElement</span> *&gt; *&gt; <span class="operator">*</span>retainCycles <span class="operator">=</span> [<span class="type">NSMutableSet</span> new];</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 查找循环引用是通过深度遍历整个对象图来实现的</span></span><br><span class="line">  <span class="comment">// 首先初始化深度搜索树中的一个节点</span></span><br><span class="line">  <span class="type">FBNodeEnumerator</span> <span class="operator">*</span>wrappedObject <span class="operator">=</span> [[<span class="type">FBNodeEnumerator</span> alloc] initWithObject:graphElement];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// stack 用于保存当前DFS搜索树中的搜索路径</span></span><br><span class="line">  <span class="type">NSMutableArray</span>&lt;<span class="type">FBNodeEnumerator</span> *&gt; <span class="operator">*</span>stack <span class="operator">=</span> [<span class="type">NSMutableArray</span> new];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// objectsOnPath 保存搜索路径中访问过的对象</span></span><br><span class="line">  <span class="type">NSMutableSet</span>&lt;<span class="type">FBNodeEnumerator</span> *&gt; <span class="operator">*</span>objectsOnPath <span class="operator">=</span> [<span class="type">NSMutableSet</span> new];</span><br><span class="line">   </span><br><span class="line">  <span class="comment">// 增加根节点，从根节点开始搜索</span></span><br><span class="line">  [stack addObject:wrappedObject];</span><br><span class="line"></span><br><span class="line">  <span class="comment">//判断是否已经搜索完毕</span></span><br><span class="line">  <span class="keyword">while</span> ([stack count] <span class="operator">&gt;</span> <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 算法会创建许多生命周期非常短的对象，这个会造成很大的内存抖动，所以这里使用了自动释放池来缓解这个问题。</span></span><br><span class="line">    <span class="meta">@autoreleasepool</span> &#123;</span><br><span class="line">      <span class="comment">// 取出stack中的最上面的节点，并标记该节点已读</span></span><br><span class="line">      <span class="type">FBNodeEnumerator</span> <span class="operator">*</span>top <span class="operator">=</span> [stack lastObject];</span><br><span class="line">       </span><br><span class="line">      <span class="comment">// 这里不重复便利同样的子树</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="operator">!</span>[objectsOnPath containsObject:top]) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([_objectSet containsObject:@([top.object objectAddress])]) &#123;</span><br><span class="line">          [stack removeLastObject];</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这里之所以只保留对象的地址是为了避免不必要的对象持有</span></span><br><span class="line">        [_objectSet addObject:@([top.object objectAddress])];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 记录已经访问过的节点</span></span><br><span class="line">      [objectsOnPath addObject:top];</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Take next adjecent node to that child. Wrapper object can</span></span><br><span class="line">      <span class="comment">// persist iteration state. If we see that node again, it will</span></span><br><span class="line">      <span class="comment">// give us new adjacent node unless it runs out of them</span></span><br><span class="line">      <span class="comment">//取top节点的next节点，也就是这个object可能持有的对象。</span></span><br><span class="line">      <span class="type">FBNodeEnumerator</span> <span class="operator">*</span>firstAdjacent <span class="operator">=</span> [top nextObject];</span><br><span class="line">      <span class="keyword">if</span> (firstAdjacent) &#123;</span><br><span class="line">        <span class="comment">//如果存在未访问到的节点</span></span><br><span class="line">        <span class="comment">// Current node still has some adjacent not-visited nodes</span></span><br><span class="line"></span><br><span class="line">        <span class="type">BOOL</span> shouldPushToStack <span class="operator">=</span> <span class="type">NO</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 检查是否已经访问过了</span></span><br><span class="line">        <span class="comment">// Check if child was already seen in that path</span></span><br><span class="line">        <span class="keyword">if</span> ([objectsOnPath containsObject:firstAdjacent]) &#123;</span><br><span class="line">          <span class="comment">// We have caught a retain cycle</span></span><br><span class="line">          <span class="comment">//如果该节点已经存在被访问过的对象中，说明构成了retain cycle</span></span><br><span class="line">          <span class="comment">// Ignore the first element which is equal to firstAdjacent, use firstAdjacent</span></span><br><span class="line">          <span class="comment">// we&#x27;re doing that because firstAdjacent has set all contexts, while its</span></span><br><span class="line">          <span class="comment">// first occurence could be a root without any context</span></span><br><span class="line">          <span class="type">NSUInteger</span> index <span class="operator">=</span> [stack indexOfObject:firstAdjacent];</span><br><span class="line">          <span class="type">NSInteger</span> length <span class="operator">=</span> [stack count] <span class="operator">-</span> index;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (index <span class="operator">==</span> <span class="type">NSNotFound</span>) &#123;</span><br><span class="line">            <span class="comment">// Object got deallocated between checking if it exists and grabbing its index</span></span><br><span class="line">            shouldPushToStack <span class="operator">=</span> <span class="type">YES</span>;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//计算出firstAdj出现的位置，同时计算出路径的长度，将这一系列的节点（object），也就是环，存放在array里面。</span></span><br><span class="line">            <span class="comment">//将这个array存放到retainCycles集合中。</span></span><br><span class="line">            <span class="type">NSRange</span> cycleRange <span class="operator">=</span> <span class="type">NSMakeRange</span>(index, length);</span><br><span class="line">            <span class="type">NSMutableArray</span>&lt;<span class="type">FBNodeEnumerator</span> *&gt; <span class="operator">*</span>cycle <span class="operator">=</span> [[stack subarrayWithRange:cycleRange] mutableCopy];</span><br><span class="line">            [cycle replaceObjectAtIndex:<span class="number">0</span> withObject:firstAdjacent];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 1. Unwrap the cycle</span></span><br><span class="line">            <span class="comment">// 2. Shift to lowest address (if we omit that, and the cycle is created by same class,</span></span><br><span class="line">            <span class="comment">//    we might have duplicates)</span></span><br><span class="line">            <span class="comment">// 3. Shift by class (lexicographically)</span></span><br><span class="line"></span><br><span class="line">            [retainCycles addObject:[<span class="keyword">self</span> _shiftToUnifiedCycle:[<span class="keyword">self</span> _unwrapCycle:cycle]]];</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// Node is clear to check, add it to stack and continue</span></span><br><span class="line">          shouldPushToStack <span class="operator">=</span> <span class="type">YES</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (shouldPushToStack) &#123;</span><br><span class="line">          <span class="keyword">if</span> ([stack count] <span class="operator">&lt;</span> stackDepth) &#123;</span><br><span class="line">            [stack addObject:firstAdjacent];</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Node has no more adjacent nodes, it itself is done, move on</span></span><br><span class="line">        [stack removeLastObject];</span><br><span class="line">        [objectsOnPath removeObject:top];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> retainCycles;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>_findRetainCyclesInObject方法中有四个比较重要的对象：</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="bullet">* </span>retainCycles用于存放循环引用环的集合；</span><br><span class="line"><span class="bullet">* </span>wrappedObject图的根起点</span><br><span class="line"><span class="bullet">* </span>stack是在图中当前的路径</span><br><span class="line"><span class="bullet">* </span>objectsOnPath用于记录以前访问过的节点。</span><br></pre></td></tr></table></figure>

<p>在遍历开始前首先用传进来的graphElement来初始化FBNodeEnumerator对象，FBNodeEnumerator 是整个遍历的关键，但是这里我们先注重整个流程，开始遍历之前会将用当前graphElement初始化的FBNodeEnumerator添加到stack，然后通过FBNodeEnumerator 的 nextObject 取出下一个节点，通过 <strong><strong>[objectsOnPath containsObject:firstAdjacent]</strong></strong> 来判断该节点是否已经被访问过了，如果该节点已经存在被访问过的对象中，说明构成了retain cycle，这时候计算出firstAdj出现的位置，同时计算出路径的长度，将这一系列的节点组成的环，存放在array里面。将这个array存放到retainCycles集合中。</p>
<p>这里还有两个比较重要的方法_unwrapCycle和_shiftToUnifiedCycle：</p>
<ul>
<li>_unwrapCycle: 的作用是将数组中的每一个 FBNodeEnumerator 实例解压成 FBObjectiveCGraphElement</li>
<li>_shiftToUnifiedCycle: 方法用于将每一个环中的元素按照地址递增以及字母顺序来排序，来避免把相同环的不同表示方式当作两个不同的环。</li>
</ul>
<p><strong><strong>获取强引用对象</strong></strong></p>
<p>我们上面介绍addCandidate方法的时候看到FBRetainCycleDetector会把所有的对象封装在FBObjectiveCGraphElement中，FBObjectiveCGraphElement类中有个十分重要的方法allRetainedObjects，它用于返回某个对象所持有的全部强引用对象数组。获取数组之后，再把其中的对象包装成新的FBNodeEnumerator实例，作为下一个有向图的顶点。</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">- (<span class="name">NSSet</span> *)allRetainedObjects &#123;</span><br><span class="line">  NSArray *retainedObjectsNotWrapped = [FBAssociationManager associationsForObject<span class="symbol">:_object</span>]<span class="comment">;</span></span><br><span class="line">  NSMutableSet *retainedObjects = [NSMutableSet new];</span><br><span class="line"></span><br><span class="line">  for (id obj in retainedObjectsNotWrapped) &#123;</span><br><span class="line">    FBObjectiveCGraphElement *element = FBWrapObjectGraphElementWithContext(<span class="name">self</span>,</span><br><span class="line">                                                                            obj,</span><br><span class="line">                                                                            _configuration,</span><br><span class="line">                                                                            @[@<span class="string">&quot;__associated_object&quot;</span>])<span class="comment">;</span></span><br><span class="line">    if (<span class="name">element</span>) &#123;</span><br><span class="line">      [retainedObjects addObject<span class="symbol">:element</span>]<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return retainedObjects<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在最开始我们会通过[FBAssociationManager associationsForObject:]获取该对象所有通过objc_setAssociatedObject关联的对象。FBAssociationManager 是 object associations的一个跟踪器，通过指定对象它能够返回该指定对象通过objc_setAssociatedObject retain策略添加的关联对象。它只有三个方法：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 开始跟踪 object associations，这里使用的是fishhook来hook objc_(set/remove)AssociatedObject 这些C方法,并插入一些跟踪代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (<span class="type">void</span>)hook;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 停止跟踪 object associations</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (<span class="type">void</span>)unhook;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 返回指定对象的 objects associated</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (<span class="keyword">nullable</span> <span class="built_in">NSArray</span> *)associationsForObject:(<span class="keyword">nullable</span> <span class="type">id</span>)object;</span><br></pre></td></tr></table></figure>
<p>要跟踪关联对象必须在main.m中调用[FBAssociationManager hook]通过fishhook Hook 对应方法。</p>
<p>我们接下来继续看下allRetainedObjects方法。allRetainedObjects方法中会遍历FBAssociationManager获取到的_object关联的对象。然后通过FBWrapObjectGraphElementWithContext创建FBObjectiveCGraphElement。并添加到retainedObjects数组返回。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">FBObjectiveCGraphElement *FBWrapObjectGraphElementWithContext(FBObjectiveCGraphElement *sourceElement,</span><br><span class="line">                                                              id <span class="keyword">object</span>,</span><br><span class="line">                                                              FBObjectGraphConfiguration *<span class="keyword">configuration</span>,</span><br><span class="line">                                                              NSArray&lt;NSString *&gt; *namePath) &#123;</span><br><span class="line">  //通过FBObjectGraphConfiguration中添加的过滤器对当前的<span class="keyword">object</span>进行一次过滤</span><br><span class="line">  <span class="keyword">if</span> (_ShouldBreakGraphEdge(<span class="keyword">configuration</span>, sourceElement, [namePath firstObject], object_getClass(<span class="keyword">object</span>))) &#123;</span><br><span class="line">    <span class="keyword">return</span> nil;</span><br><span class="line">  &#125;</span><br><span class="line">  FBObjectiveCBlock *newElement;</span><br><span class="line">  //如果是Block类型则返回FBObjectiveCBlock</span><br><span class="line">  <span class="keyword">if</span> (FBObjectIsBlock((__bridge <span class="type">void</span> *)<span class="keyword">object</span>)) &#123;</span><br><span class="line">    newElement = [[FBObjectiveCBlock alloc] initWithObject:<span class="keyword">object</span></span><br><span class="line">                                             <span class="keyword">configuration</span>:<span class="keyword">configuration</span></span><br><span class="line">                                                  namePath:namePath];</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    //如果是NSTimer的子类并且配置类中shouldInspectTimers 为 YES 返回FBObjectiveCNSCFTimer</span><br><span class="line">    <span class="keyword">if</span> ([object_getClass(<span class="keyword">object</span>) isSubclassOfClass:[NSTimer <span class="keyword">class</span>]] &amp;&amp;</span><br><span class="line">        <span class="keyword">configuration</span>.shouldInspectTimers) &#123;</span><br><span class="line">      newElement = [[FBObjectiveCNSCFTimer alloc] initWithObject:<span class="keyword">object</span></span><br><span class="line">                                                   <span class="keyword">configuration</span>:<span class="keyword">configuration</span></span><br><span class="line">                                                        namePath:namePath];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      //否则返回FBObjectiveCObject</span><br><span class="line">      newElement = [[FBObjectiveCObject alloc] initWithObject:<span class="keyword">object</span></span><br><span class="line">                                                <span class="keyword">configuration</span>:<span class="keyword">configuration</span></span><br><span class="line">                                                     namePath:namePath];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">configuration</span> &amp;&amp; <span class="keyword">configuration</span>.transformerBlock) ? <span class="keyword">configuration</span>.transformerBlock(newElement) : newElement;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>FBWrapObjectGraphElementWithContext会根据传入的object的对象判断，如果是Block类型则返回FBObjectiveCBlock，如果是NSTimer的子类并且配置类中shouldInspectTimers 为 YES 返回FBObjectiveCNSCFTimer，如果其他类型返回FBObjectiveCObject。</p>
<p>FBObjectiveCBlock，FBObjectiveCNSCFTimer，FBObjectiveCObject都是FBObjectiveCGraphElement的子类，都是一种对象图元素。</p>
<p>我们回到FBNodeEnumerator类，我们上面提到深度遍历对象树靠的就是FBNodeEnumerator的nextObject方法。我们看下nextObject方法：</p>
<figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line">- (FBNodeEnumerator *)nextObject &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="variable">_object</span>) &#123;</span><br><span class="line">    return <span class="literal">nil</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="variable">_retainedObjectsSnapshot</span>) &#123;</span><br><span class="line">    <span class="variable">_retainedObjectsSnapshot</span> = [<span class="variable">_object</span> allRetainedObjects];</span><br><span class="line">    <span class="variable">_enumerator</span> = [<span class="variable">_retainedObjectsSnapshot</span> objectEnumerator];</span><br><span class="line">  &#125;</span><br><span class="line">  FBObjectiveCGraphElement *next = [<span class="variable">_enumerator</span> nextObject];</span><br><span class="line">  <span class="keyword">if</span> (next) &#123;</span><br><span class="line">    return [[FBNodeEnumerator alloc] initWithObject:next];</span><br><span class="line">  &#125;</span><br><span class="line">  return <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里最关键的就是调用了上面提到的allRetainedObjects方法。也就是说通过allRetainedObjects可以对当前节点进行展开递归。</p>
<p>我们针对上面提到的三种对象图元素一一看下怎么获取到某个对象的全部强引用属性：</p>
<p><strong><strong>FBObjectiveCBlock</strong></strong></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="operator">-</span> (<span class="type">NSSet</span> <span class="operator">*</span>)allRetainedObjects &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ......</span></span><br><span class="line">  <span class="comment">//获取一个对象的所有强引用属性</span></span><br><span class="line">  <span class="type">NSArray</span> <span class="operator">*</span>strongIvars <span class="operator">=</span> <span class="type">FBGetObjectStrongReferences</span>(<span class="keyword">self</span>.object, <span class="keyword">self</span>.configuration.layoutCache);</span><br><span class="line">  <span class="comment">//通过super方法获取当前类的关联对象属性</span></span><br><span class="line">  <span class="type">NSMutableArray</span> <span class="operator">*</span>retainedObjects <span class="operator">=</span> [[[<span class="keyword">super</span> allRetainedObjects] allObjects] mutableCopy];</span><br><span class="line"></span><br><span class="line">  <span class="comment">//将全部的强引用对象封装成FBObjectiveCGraphElement</span></span><br><span class="line">  <span class="keyword">for</span> (id<span class="operator">&lt;</span><span class="type">FBObjectReference</span><span class="operator">&gt;</span> ref <span class="keyword">in</span> strongIvars) &#123;</span><br><span class="line">    id referencedObject <span class="operator">=</span> [ref objectReferenceFromObject:<span class="keyword">self</span>.object];</span><br><span class="line">    <span class="keyword">if</span> (referencedObject) &#123;</span><br><span class="line">      <span class="type">NSArray</span>&lt;<span class="type">NSString</span> *&gt; <span class="operator">*</span>namePath <span class="operator">=</span> [ref namePath];</span><br><span class="line">      <span class="type">FBObjectiveCGraphElement</span> <span class="operator">*</span>element <span class="operator">=</span> <span class="type">FBWrapObjectGraphElementWithContext</span>(<span class="keyword">self</span>,</span><br><span class="line">                                                                              referencedObject,</span><br><span class="line">                                                                              <span class="keyword">self</span>.configuration,</span><br><span class="line">                                                                              namePath);</span><br><span class="line">      <span class="keyword">if</span> (element) &#123;</span><br><span class="line">        [retainedObjects addObject:element];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ([<span class="type">NSStringFromClass</span>(aCls) hasPrefix:@<span class="string">&quot;__NSCF&quot;</span>]) &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     If we are dealing with toll-free bridged collections, we are not guaranteed that the collection</span></span><br><span class="line"><span class="comment">     will hold only Objective-C objects. We are not able to check in runtime what callbacks it uses to</span></span><br><span class="line"><span class="comment">     retain/release (if any) and we could easily crash here.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">return</span> [<span class="type">NSSet</span> setWithArray:retainedObjects];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (class_isMetaClass(aCls)) &#123;</span><br><span class="line">    <span class="comment">// If it&#x27;s a meta-class it can conform to following protocols,</span></span><br><span class="line">    <span class="comment">// but it would crash when trying enumerating</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//获取集合类的引用</span></span><br><span class="line">  <span class="keyword">if</span> ([aCls conformsToProtocol:<span class="meta">@protocol</span>(<span class="type">NSFastEnumeration</span>)]) &#123;</span><br><span class="line">    <span class="type">BOOL</span> retainsKeys <span class="operator">=</span> [<span class="keyword">self</span> _objectRetainsEnumerableKeys];</span><br><span class="line">    <span class="type">BOOL</span> retainsValues <span class="operator">=</span> [<span class="keyword">self</span> _objectRetainsEnumerableValues];</span><br><span class="line"></span><br><span class="line">    <span class="type">BOOL</span> isKeyValued <span class="operator">=</span> <span class="type">NO</span>;</span><br><span class="line">    <span class="keyword">if</span> ([aCls instancesRespondToSelector:<span class="meta">@selector</span>(objectForKey:)]) &#123;</span><br><span class="line">      isKeyValued <span class="operator">=</span> <span class="type">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     This codepath is prone to errors. When you enumerate a collection that can be mutated while enumeration</span></span><br><span class="line"><span class="comment">     we fall into risk of crash. To save ourselves from that we will catch such exception and try again.</span></span><br><span class="line"><span class="comment">     We should not try this endlessly, so at some point we will simply give up.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">NSInteger</span> tries <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">NSInteger</span> i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> tries; <span class="operator">++</span>i) &#123;</span><br><span class="line">      <span class="comment">// If collection is mutated we want to rollback and try again - let&#x27;s keep refs in temporary set</span></span><br><span class="line">      <span class="type">NSMutableSet</span> <span class="operator">*</span>temporaryRetainedObjects <span class="operator">=</span> [<span class="type">NSMutableSet</span> new];</span><br><span class="line">      <span class="meta">@try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (id subobject <span class="keyword">in</span> <span class="keyword">self</span>.object) &#123;</span><br><span class="line">          <span class="keyword">if</span> (retainsKeys) &#123;</span><br><span class="line">            <span class="type">FBObjectiveCGraphElement</span> <span class="operator">*</span>element <span class="operator">=</span> <span class="type">FBWrapObjectGraphElement</span>(<span class="keyword">self</span>, subobject, <span class="keyword">self</span>.configuration);</span><br><span class="line">            <span class="keyword">if</span> (element) &#123;</span><br><span class="line">              [temporaryRetainedObjects addObject:element];</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (isKeyValued <span class="operator">&amp;&amp;</span> retainsValues) &#123;</span><br><span class="line">            <span class="type">FBObjectiveCGraphElement</span> <span class="operator">*</span>element <span class="operator">=</span> <span class="type">FBWrapObjectGraphElement</span>(<span class="keyword">self</span>,</span><br><span class="line">                                                                         [<span class="keyword">self</span>.object objectForKey:subobject],</span><br><span class="line">                                                                         <span class="keyword">self</span>.configuration);</span><br><span class="line">            <span class="keyword">if</span> (element) &#123;</span><br><span class="line">              [temporaryRetainedObjects addObject:element];</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="meta">@catch</span> (<span class="type">NSException</span> <span class="operator">*</span>exception) &#123;</span><br><span class="line">        <span class="comment">// mutation happened, we want to try enumerating again</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// If we are here it means no exception happened and we want to break outer loop</span></span><br><span class="line">      [retainedObjects addObjectsFromArray:[temporaryRetainedObjects allObjects]];</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> [<span class="type">NSSet</span> setWithArray:retainedObjects];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里最关键的就是FBGetObjectStrongReferences方法：它能从类中获取它的所有引用，无论是强引用或者是弱引用。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">NSArray</span>&lt;id&lt;<span class="type">FBObjectReference</span>&gt;<span class="operator">&gt;</span> <span class="operator">*</span><span class="type">FBGetObjectStrongReferences</span>(id obj,</span><br><span class="line">                                                            <span class="type">NSMutableDictionary</span>&lt;<span class="type">Class</span>, <span class="type">NSArray</span>&lt;id&lt;<span class="type">FBObjectReference</span>&gt;&gt; <span class="operator">*&gt;</span> <span class="operator">*</span>layoutCache) &#123;</span><br><span class="line">  <span class="type">NSMutableArray</span>&lt;id&lt;<span class="type">FBObjectReference</span>&gt;<span class="operator">&gt;</span> <span class="operator">*</span>array <span class="operator">=</span> [<span class="type">NSMutableArray</span> new];</span><br><span class="line"></span><br><span class="line">  __unsafe_unretained <span class="type">Class</span> previousClass <span class="operator">=</span> <span class="literal">nil</span>;</span><br><span class="line">  __unsafe_unretained <span class="type">Class</span> currentClass <span class="operator">=</span> object_getClass(obj);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (previousClass <span class="operator">!=</span> currentClass) &#123;</span><br><span class="line">    <span class="type">NSArray</span>&lt;id&lt;<span class="type">FBObjectReference</span>&gt;<span class="operator">&gt;</span> <span class="operator">*</span>ivars;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (layoutCache <span class="operator">&amp;&amp;</span> currentClass) &#123;</span><br><span class="line">      ivars <span class="operator">=</span> layoutCache[currentClass];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="operator">!</span>ivars) &#123;</span><br><span class="line">      ivars <span class="operator">=</span> <span class="type">FBGetStrongReferencesForClass</span>(currentClass);</span><br><span class="line">      <span class="keyword">if</span> (layoutCache <span class="operator">&amp;&amp;</span> currentClass) &#123;</span><br><span class="line">        layoutCache[currentClass] <span class="operator">=</span> ivars;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    [array addObjectsFromArray:ivars];</span><br><span class="line">    previousClass <span class="operator">=</span> currentClass;</span><br><span class="line">    currentClass <span class="operator">=</span> class_getSuperclass(currentClass);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> [array copy];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在FBGetObjectStrongReferences方法中遍历本类以及所有父指针强引用，并且加入了缓存以加速查找强引用的过程，在这里会对所有遍历的类调用FBGetStrongReferencesForClass获取ivars，同时过滤弱引用。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">static NSArray&lt;id&lt;FBObjectReference&gt;&gt; *FBGetStrongReferencesForClass(<span class="keyword">Class</span> aCls) &#123;</span><br><span class="line">  NSArray&lt;id&lt;FBObjectReference&gt;&gt; *ivars = [FBGetClassReferences(aCls) filteredArrayUsingPredicate:[NSPredicate predicateWithBlock:^<span class="type">BOOL</span>(id evaluatedObject, NSDictionary *bindings) &#123;</span><br><span class="line">    <span class="keyword">if</span> ([evaluatedObject isKindOfClass:[FBIvarReference <span class="keyword">class</span>]]) &#123;</span><br><span class="line">      FBIvarReference *<span class="keyword">wrapper</span> = evaluatedObject;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">wrapper</span>.<span class="keyword">type</span> != FBUnknownType;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> YES;</span><br><span class="line">  &#125;]];</span><br><span class="line"></span><br><span class="line">  const uint8_t *fullLayout = class_getIvarLayout(aCls);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!fullLayout) &#123;</span><br><span class="line">    <span class="keyword">return</span> @[];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  NSUInteger minimumIndex = FBGetMinimumIvarIndex(aCls);</span><br><span class="line">  NSIndexSet *parsedLayout = FBGetLayoutAsIndexesForDescription(minimumIndex, fullLayout);</span><br><span class="line"></span><br><span class="line">  NSArray&lt;id&lt;FBObjectReference&gt;&gt; *filteredIvars =</span><br><span class="line">  [ivars filteredArrayUsingPredicate:[NSPredicate predicateWithBlock:^<span class="type">BOOL</span>(id&lt;FBObjectReference&gt; evaluatedObject,</span><br><span class="line">                                                                           NSDictionary *bindings) &#123;</span><br><span class="line">    <span class="keyword">return</span> [parsedLayout containsIndex:[evaluatedObject indexInIvarLayout]];</span><br><span class="line">  &#125;]];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> filteredIvars;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们来看下FBGetClassReferences方法：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">NSArray&lt;id&lt;FBObjectReference&gt;&gt; *FBGetClassReferences(<span class="keyword">Class</span> aCls) &#123;</span><br><span class="line">  NSMutableArray&lt;id&lt;FBObjectReference&gt;&gt; *result = [NSMutableArray <span class="built_in">new</span>];</span><br><span class="line"></span><br><span class="line">  unsigned <span class="type">int</span> count;</span><br><span class="line">  Ivar *ivars = class_copyIvarList(aCls, &amp;count);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (unsigned <span class="type">int</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">    Ivar ivar = ivars[i];</span><br><span class="line">    FBIvarReference *<span class="keyword">wrapper</span> = [[FBIvarReference alloc] initWithIvar:ivar];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">wrapper</span>.<span class="keyword">type</span> == FBStructType) &#123;</span><br><span class="line">      std::string encoding = std::string(ivar_getTypeEncoding(<span class="keyword">wrapper</span>.ivar));</span><br><span class="line">      NSArray&lt;FBObjectInStructReference *&gt; *<span class="keyword">references</span> = FBGetReferencesForObjectsInStructEncoding(<span class="keyword">wrapper</span>, <span class="keyword">encoding</span>);</span><br><span class="line"></span><br><span class="line">      [result addObjectsFromArray:<span class="keyword">references</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      [result addObject:<span class="keyword">wrapper</span>];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  free(ivars);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> [result <span class="keyword">copy</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里主要通过class_copyIvarList方法获取到Ivar然后将所有的Ivar封装到FBIvarReference对象。FBIvarReference对象其实是Ivar的面向对象封装，包括属性的名称、类型、偏移量以及索引。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">FBIvarReference</span> : <span class="title">NSObject</span> &lt;<span class="title">FBObjectReference</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">readonly</span>, <span class="keyword">nullable</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) FBType type;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) ptrdiff_t offset;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSUInteger</span> index;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">nonnull</span>) Ivar ivar;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">nonnull</span> <span class="keyword">instancetype</span>)initWithIvar:(<span class="keyword">nonnull</span> Ivar)ivar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>到目前为止我们直到了如何获取到某个对象的全部属性，这里包括强引用和弱引用，下面我们还要知道如何过滤弱引用。</p>
<p>为了弄明白怎么过滤弱引用，我们要先了解Ivar Layout，获取Ivar Layout 是通过 FBGetLayoutAsIndexesForDescription方法获取的。<br>Ivar Layout 是一系列的字符，每两个一组，比如\xmn，每一组 Ivar Layout 中第一位表示有m个非强属性，第二位表示接下来有n个强属性。<br>FBGetLayoutAsIndexesForDescription 返回的就是所有强引用的Ivar Layout。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">NSIndexSet</span> *FBGetLayoutAsIndexesForDescription(<span class="built_in">NSUInteger</span> minimumIndex, <span class="keyword">const</span> uint8_t *layoutDescription) &#123;</span><br><span class="line">	<span class="built_in">NSMutableIndexSet</span> *interestingIndexes = [<span class="built_in">NSMutableIndexSet</span> new];</span><br><span class="line">	<span class="built_in">NSUInteger</span> currentIndex = minimumIndex;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (*layoutDescription != <span class="string">&#x27;\x00&#x27;</span>) &#123;</span><br><span class="line">		<span class="type">int</span> upperNibble = (*layoutDescription &amp; <span class="number">0xf0</span>) &gt;&gt; <span class="number">4</span>;</span><br><span class="line">		<span class="type">int</span> lowerNibble = *layoutDescription &amp; <span class="number">0xf</span>;</span><br><span class="line"></span><br><span class="line">		currentIndex += upperNibble;</span><br><span class="line">		[interestingIndexes addIndexesInRange:<span class="built_in">NSMakeRange</span>(currentIndex, lowerNibble)];</span><br><span class="line">		currentIndex += lowerNibble;</span><br><span class="line"></span><br><span class="line">		++layoutDescription;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> interestingIndexes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来我们就可以拿着上面找到的parsedLayout对ivars进行过滤，留下所有强引用的ivars。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSArray</span>&lt;<span class="type">id</span>&lt;FBObjectReference&gt;&gt; *filteredIvars =</span><br><span class="line">[ivars filteredArrayUsingPredicate:[<span class="built_in">NSPredicate</span> predicateWithBlock:^<span class="type">BOOL</span>(<span class="type">id</span>&lt;FBObjectReference&gt; evaluatedObject,</span><br><span class="line">																		 <span class="built_in">NSDictionary</span> *bindings) &#123;</span><br><span class="line">	<span class="keyword">return</span> [parsedLayout containsIndex:[evaluatedObject indexInIvarLayout]];</span><br><span class="line">&#125;]];</span><br></pre></td></tr></table></figure>

<p><strong><strong>FBObjectiveCBlock</strong></strong></p>
<p>我们来看下Block对象对应的图节点FBObjectiveCBlock：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">NSSet</span> *)allRetainedObjects &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//获取关联对象的全部强引用</span></span><br><span class="line">  <span class="built_in">NSMutableArray</span> *results = [[[<span class="variable language_">super</span> allRetainedObjects] allObjects] mutableCopy];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Grab a strong reference to the object, otherwise it can crash while doing</span></span><br><span class="line">  <span class="comment">// nasty stuff on deallocation</span></span><br><span class="line">  __attribute__((objc_precise_lifetime)) <span class="type">id</span> anObject = <span class="keyword">self</span>.object;</span><br><span class="line"></span><br><span class="line">  <span class="type">void</span> *blockObjectReference = (__bridge <span class="type">void</span> *)anObject;</span><br><span class="line">  <span class="built_in">NSArray</span> *allRetainedReferences = FBGetBlockStrongReferences(blockObjectReference);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">id</span> object <span class="keyword">in</span> allRetainedReferences) &#123;</span><br><span class="line">    FBObjectiveCGraphElement *element = FBWrapObjectGraphElement(<span class="keyword">self</span>, object, <span class="keyword">self</span>.configuration);</span><br><span class="line">    <span class="keyword">if</span> (element) &#123;</span><br><span class="line">      [results addObject:element];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> [<span class="built_in">NSSet</span> setWithArray:results];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里最重要的是FBGetBlockStrongReferences方法：</p>
<figure class="highlight nim"><table><tr><td class="code"><pre><span class="line"><span class="type">NSArray</span> *<span class="type">FBGetBlockStrongReferences</span>(<span class="type">void</span> *<span class="keyword">block</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> (!<span class="type">FBObjectIsBlock</span>(<span class="keyword">block</span>)) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">nil</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">NSMutableArray</span> *results = [<span class="type">NSMutableArray</span> new];</span><br><span class="line">	<span class="type">void</span> **blockReference = <span class="keyword">block</span>;</span><br><span class="line">	<span class="type">NSIndexSet</span> *strongLayout = _GetBlockStrongLayout(<span class="keyword">block</span>);</span><br><span class="line">	[strongLayout enumerateIndexesUsingBlock:^(<span class="type">NSUInteger</span> idx, <span class="type">BOOL</span> *stop) &#123;</span><br><span class="line">		<span class="type">void</span> **reference = &amp;blockReference[idx];</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (reference &amp;&amp; (*reference)) &#123;</span><br><span class="line">			id <span class="keyword">object</span> = (id)(*reference);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">object</span>) &#123;</span><br><span class="line">				[results addObject:<span class="keyword">object</span>];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> [results autorelease];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在FBGetBlockStrongReferences方法中通过_GetBlockStrongLayout获得Block所持有的强引用。在理解如何Block强引用之前我们先来回顾下Block的一些基础知识：</p>
<p>struct BlockLiteral {<br>    void *isa;<br>    int flags;<br>    int reserved;<br>    void (*invoke)(void *, …);<br>    struct BlockDescriptor *descriptor;<br>    &#x2F;&#x2F; imported variables<br>};</p>
<p>首先Block对于它所捕获的Objective-C对象实例，都会在block 结构体的下面存放这些持有的对象，并且会将强引用的对象排放在弱引用对象的前面。当Block将要释放时，会调用dispose_helper函数，该函数会调用所有需要进行内存管理的所捕获的对象，如Block、<strong>block变量、__attribute</strong>((NSObject))变量或有constructor&#x2F;destructor的C++ const对象。所以我们可以创建一系列的fake对象来模拟捕获的Objective-C对象实例，然后主动调用Block的dispose_helper方法，该方法会调用对象实例的release方法，我们只需要在fake对象中实现release方法，如果release方法被调用，所以该fake对象对应的真实变量为Objective-C对象实例。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">NSIndexSet</span> *_GetBlockStrongLayout(<span class="type">void</span> *block) &#123;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">struct</span> BlockLiteral *blockLiteral = block;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   BLOCK_HAS_CTOR - Block has a C++ constructor/destructor, which gives us a good chance it retains</span></span><br><span class="line"><span class="comment">   objects that are not pointer aligned, so omit them.</span></span><br><span class="line"><span class="comment">   </span></span><br><span class="line"><span class="comment">   !BLOCK_HAS_COPY_DISPOSE - Block doesn&#x27;t have a dispose function, so it does not retain objects and</span></span><br><span class="line"><span class="comment">   we are not able to blackbox it.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span> ((blockLiteral-&gt;flags &amp; BLOCK_HAS_CTOR)</span><br><span class="line">      || !(blockLiteral-&gt;flags &amp; BLOCK_HAS_COPY_DISPOSE)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//获取当前Block的dispose_helper方法</span></span><br><span class="line">  <span class="type">void</span> (*dispose_helper)(<span class="type">void</span> *src) = blockLiteral-&gt;descriptor-&gt;dispose_helper;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//指针大小</span></span><br><span class="line">  <span class="keyword">const</span> size_t ptrSize = <span class="keyword">sizeof</span>(<span class="type">void</span> *);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//计算出需要填充的fake对象数量</span></span><br><span class="line">  <span class="comment">// Figure out the number of pointers it takes to fill out the object, rounding up.</span></span><br><span class="line">  <span class="keyword">const</span> size_t elements = (blockLiteral-&gt;descriptor-&gt;size + ptrSize - <span class="number">1</span>) / ptrSize;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建fack对象</span></span><br><span class="line">  <span class="comment">// Create a fake object of the appropriate length.</span></span><br><span class="line">  <span class="type">void</span> *obj[elements];</span><br><span class="line">  <span class="type">void</span> *detectors[elements];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; elements; ++i) &#123;</span><br><span class="line">    FBBlockStrongRelationDetector *detector = [FBBlockStrongRelationDetector new];</span><br><span class="line">    obj[i] = detectors[i] = detector;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//调用dispose_helper，这时候会调用每个FBBlockStrongRelationDetector的release方法，这时候会将strong设置为YES</span></span><br><span class="line">  <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">    dispose_helper(obj);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Run through the release detectors and add each one that got released to the object&#x27;s</span></span><br><span class="line">  <span class="comment">// strong ivar layout.</span></span><br><span class="line">  <span class="built_in">NSMutableIndexSet</span> *layout = [<span class="built_in">NSMutableIndexSet</span> indexSet];</span><br><span class="line"> <span class="comment">//判断strong是否为YES,如果为YES表示为强引用，则将其添加到layout</span></span><br><span class="line">  <span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; elements; ++i) &#123;</span><br><span class="line">    FBBlockStrongRelationDetector *detector = (FBBlockStrongRelationDetector *)(detectors[i]);</span><br><span class="line">    <span class="keyword">if</span> (detector.isStrong) &#123;</span><br><span class="line">      [layout addIndex:i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Destroy detectors</span></span><br><span class="line">    [detector trueRelease];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> layout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><strong>FBObjectiveCNSCFTimer</strong></strong>*</p>
<p>FBObjectiveCNSCFTimer比较简单它会通过runloop去获取CFRunLoopTimerGetContext，然后通过context查看是否有target或者，userInfo如果有假设它强持有这些对象的引用。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">- (NSSet *)allRetainedObjects &#123;</span><br><span class="line">  <span class="comment">// Let&#x27;s retain our timer</span></span><br><span class="line">  <span class="constructor">__attribute__((<span class="params">objc_precise_lifetime</span>)</span>) NSTimer *timer = self.<span class="keyword">object</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!timer) &#123;</span><br><span class="line">    return nil;</span><br><span class="line">  &#125;</span><br><span class="line">  NSMutableSet *retained = <span class="literal">[[<span class="identifier">super</span> <span class="identifier">allRetainedObjects</span>]</span> mutableCopy];</span><br><span class="line">  CFRunLoopTimerContext context;</span><br><span class="line">  <span class="comment">//通过runloop去获取CFRunLoopTimerGetContext</span></span><br><span class="line">  <span class="constructor">CFRunLoopTimerGetContext((CFRunLoopTimerRef)</span>timer, &amp;context);</span><br><span class="line">  <span class="comment">// If it has a retain function, let&#x27;s assume it retains strongly</span></span><br><span class="line">  <span class="keyword">if</span> (context.info<span class="operator"> &amp;&amp; </span>context.retain) &#123;</span><br><span class="line">    _FBNSCFTimerInfoStruct infoStruct = *(_FBNSCFTimerInfoStruct *)(context.info);</span><br><span class="line">    <span class="keyword">if</span> (infoStruct.target) &#123;</span><br><span class="line">      FBObjectiveCGraphElement *element = <span class="constructor">FBWrapObjectGraphElementWithContext(<span class="params">self</span>, <span class="params">infoStruct</span>.<span class="params">target</span>, <span class="params">self</span>.<span class="params">configuration</span>, @[@<span class="string">&quot;target&quot;</span>])</span>;</span><br><span class="line">      <span class="keyword">if</span> (element) &#123;</span><br><span class="line">        <span class="literal">[<span class="identifier">retained</span> <span class="identifier">addObject</span>:<span class="identifier">element</span>]</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (infoStruct.userInfo) &#123;</span><br><span class="line">      FBObjectiveCGraphElement *element = <span class="constructor">FBWrapObjectGraphElementWithContext(<span class="params">self</span>, <span class="params">infoStruct</span>.<span class="params">userInfo</span>, <span class="params">self</span>.<span class="params">configuration</span>, @[@<span class="string">&quot;userInfo&quot;</span>])</span>;</span><br><span class="line">      <span class="keyword">if</span> (element) &#123;</span><br><span class="line">        <span class="literal">[<span class="identifier">retained</span> <span class="identifier">addObject</span>:<span class="identifier">element</span>]</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return retained;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="FBAllocationTracker"><a href="#FBAllocationTracker" class="headerlink" title="FBAllocationTracker"></a>FBAllocationTracker</h4><p><a target="_blank" rel="noopener" href="https://github.com/facebook/FBAllocationTracker">FBAllocationTracker</a>我们上面给大家分析了<a href>FBRetainCycleDetector</a>，它主要的功能是查找到待检测对象的全部强引用对象，这些强引用对象便是搜索循环引用的有向图节点， FBRetainCycleDetector通过深度优先原则遍历整个对象图，如果在整个路径中发现有存在重复访问的情况，便认为是一个循环引用，FBRetainCycleDetector一般先通过MLeaksFinder或者FBAllocationTracker这些开源库找到可疑的对象，然后再通过FBRetainCycleDetector对这个对象进行检查是否存在循环引用。<br>接下来我们给大家介绍下FBAllocationTracker，下面是它的最基本用法：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&lt;FBAllocationTracker/FBAllocationTrackerManager.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> main(<span class="type">int</span> argc, <span class="type">char</span> * argv[]) &#123;</span><br><span class="line">  [[FBAllocationTrackerManager sharedManager] startTrackingAllocations];</span><br><span class="line">  [[FBAllocationTrackerManager sharedManager] enableGenerations];</span><br><span class="line">  <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">UIApplicationMain</span>(argc, argv, <span class="literal">nil</span>, <span class="built_in">NSStringFromClass</span>([AppDelegate <span class="keyword">class</span>]));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line">- (<span class="literal">void</span>)startTrackingAllocations &#123;</span><br><span class="line">  FB<span class="type">::AllocationTracker</span><span class="type">::beginTracking</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="literal">void</span>)enableGenerations &#123;</span><br><span class="line">  dispatch_sync(_queue, ^&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">self</span>-&gt;_generationsClients == <span class="number">0</span>) &#123;</span><br><span class="line">      FB<span class="type">::AllocationTracker</span><span class="type">::enableGenerations</span>();</span><br><span class="line">      FB<span class="type">::AllocationTracker</span><span class="type">::markGeneration</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">self</span>-&gt;_generationsClients += <span class="number">1</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>










        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/iOS-%E5%BC%80%E6%BA%90%E5%BA%93%E5%88%86%E6%9E%90/">iOS 开源库分析</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/iOS-开源库分析/">iOS 开源库分析</a>
  </div>

</div>



<div class="comments-count">
	
	  	<span></span>
		<a href="/2019/11/26/FBRetainCycleDetector-FBAllocationTracker-FBMemoryProfiler-源码解析/#comments" class="ds-thread-count comments-count-link" data-thread-key="2019/11/26/FBRetainCycleDetector-FBAllocationTracker-FBMemoryProfiler-源码解析/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/11/26/BlocksKit-的使用/" title="BlocksKit 的使用" itemprop="url">BlocksKit 的使用</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Edgar" target="_blank" itemprop="author">Edgar</a>
		
  <p class="article-time">
    <time datetime="2019-11-25T18:12:14.000Z" itemprop="datePublished"> Published 2019-11-26</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h4 id="不可变集合类型"><a href="#不可变集合类型" class="headerlink" title="不可变集合类型"></a>不可变集合类型</h4><p>下面的方法适用于如下类型：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSArray</span></span><br><span class="line"><span class="built_in">NSDictionary</span></span><br><span class="line"><span class="built_in">NSIndexSet</span></span><br><span class="line"><span class="built_in">NSSet</span></span><br><span class="line"><span class="built_in">NSOrderedSet</span></span><br></pre></td></tr></table></figure>

<figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line"><span class="operator">-</span> (<span class="keyword">void</span>)bk_each<span class="operator">:</span>(<span class="keyword">void</span> (<span class="operator">^</span>)(<span class="built_in">id</span> <span class="type">obj</span>))block;</span><br></pre></td></tr></table></figure>
<p>对数组内的每个元素进行block指定的处理</p>
<figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line"><span class="operator">-</span> (<span class="keyword">void</span>)bk_apply<span class="operator">:</span>(<span class="keyword">void</span> (<span class="operator">^</span>)(<span class="built_in">id</span> <span class="type">obj</span>))block;</span><br></pre></td></tr></table></figure>
<p>这个功能上和bk_each其实是一致的，但是它是异步的，速度上会比bk_each快，特别是在双核处理器上，但是必须注意线程安全，并且它不是按照顺序处理的。</p>
<figure class="highlight erlang"><table><tr><td class="code"><pre><span class="line">- <span class="params">(id)</span>bk_match:<span class="params">(BOOL (^)</span><span class="params">(id obj)</span>)block;</span><br></pre></td></tr></table></figure>
<p>会找到第一个经过block处理后返回YES的元素</p>
<figure class="highlight erlang"><table><tr><td class="code"><pre><span class="line">- <span class="params">(NSArray *)</span>bk_select:<span class="params">(BOOL (^)</span><span class="params">(id obj)</span>)block;</span><br></pre></td></tr></table></figure>
<p>对所有对元素进行block处理，将所有返回YES的元素放到一个数组中返回。</p>
<figure class="highlight erlang"><table><tr><td class="code"><pre><span class="line">- <span class="params">(NSArray *)</span>bk_reject:<span class="params">(BOOL (^)</span><span class="params">(id obj)</span>)block;</span><br></pre></td></tr></table></figure>
<p>这个会剔除掉不匹配的</p>
<figure class="highlight erlang"><table><tr><td class="code"><pre><span class="line">- <span class="params">(NSArray *)</span>bk_map:<span class="params">(id (^)</span><span class="params">(id obj)</span>)block;</span><br></pre></td></tr></table></figure>
<p>对数组进行通用block进行处理</p>
<figure class="highlight erlang"><table><tr><td class="code"><pre><span class="line">- <span class="params">(id)</span>bk_reduce:<span class="params">(id)</span>initial withBlock:<span class="params">(id (^)</span><span class="params">(id sum, id obj)</span>)block;</span><br><span class="line"></span><br><span class="line">- <span class="params">(NSInteger)</span>bk_reduceInteger:<span class="params">(NSInteger)</span>initial withBlock:<span class="params">(NSInteger(^)</span><span class="params">(NSInteger result, id obj)</span>)block;</span><br><span class="line"></span><br><span class="line">- <span class="params">(CGFloat)</span>bk_reduceFloat:<span class="params">(CGFloat)</span>inital withBlock:<span class="params">(CGFloat(^)</span><span class="params">(CGFloat result, id obj)</span>)block;</span><br></pre></td></tr></table></figure>
<p>对所有的元素进行递归处理，不断累加效果。</p>
<figure class="highlight erlang"><table><tr><td class="code"><pre><span class="line">- <span class="params">(BOOL)</span>bk_any:<span class="params">(BOOL (^)</span><span class="params">(id obj)</span>)block;</span><br></pre></td></tr></table></figure>
<p>查看数组内部是否有满足条件的元素</p>
<figure class="highlight erlang"><table><tr><td class="code"><pre><span class="line">- <span class="params">(BOOL)</span>bk_none:<span class="params">(BOOL (^)</span><span class="params">(id obj)</span>)block;</span><br></pre></td></tr></table></figure>
<p>查看数组内是否没有满足条件的元素</p>
<figure class="highlight erlang"><table><tr><td class="code"><pre><span class="line">- <span class="params">(BOOL)</span>bk_all:<span class="params">(BOOL (^)</span><span class="params">(id obj)</span>)block;</span><br></pre></td></tr></table></figure>
<p>查看数组内是否全部原始都满足</p>
<figure class="highlight erlang"><table><tr><td class="code"><pre><span class="line">- <span class="params">(BOOL)</span>bk_corresponds:<span class="params">(NSArray *)</span>list withBlock:<span class="params">(BOOL (^)</span><span class="params">(id obj1, id obj2)</span>)block;</span><br></pre></td></tr></table></figure>
<p>查看当前数组和list的对应元素是否对应“相等”。</p>
<h4 id="可变集合类型"><a href="#可变集合类型" class="headerlink" title="可变集合类型"></a>可变集合类型</h4><p>下面的方法适用于如下几种可变集合类型：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSMutableArray</span></span><br><span class="line"><span class="built_in">NSMutableDictionary</span></span><br><span class="line"><span class="built_in">NSMutableIndexSet</span></span><br><span class="line"><span class="built_in">NSMutableOrderedSet</span></span><br><span class="line"><span class="built_in">NSMutableSet</span></span><br></pre></td></tr></table></figure>

<figure class="highlight erlang"><table><tr><td class="code"><pre><span class="line">- <span class="params">(void)</span>bk_performSelect:<span class="params">(BOOL (^)</span><span class="params">(id obj)</span>)block;</span><br></pre></td></tr></table></figure>
<p>找出满足条件的</p>
<figure class="highlight erlang"><table><tr><td class="code"><pre><span class="line">- <span class="params">(void)</span>bk_performReject:<span class="params">(BOOL (^)</span><span class="params">(id obj)</span>)block;</span><br></pre></td></tr></table></figure>

<p>剔除不满足条件的</p>
<figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line"><span class="operator">-</span> (<span class="keyword">void</span>)bk_performMap<span class="operator">:</span>(<span class="built_in">id</span> (<span class="operator">^</span>)(<span class="built_in">id</span> <span class="type">obj</span>))block;</span><br></pre></td></tr></table></figure>

<p>对各个元素进行map处理</p>
<h4 id="关联对象"><a href="#关联对象" class="headerlink" title="关联对象"></a>关联对象</h4><figure class="highlight erlang"><table><tr><td class="code"><pre><span class="line">- <span class="params">(void)</span>bk_associateValue:<span class="params">(id)</span>value withKey:<span class="params">(const void *)</span>key;</span><br><span class="line">+ <span class="params">(void)</span>bk_associateValue:<span class="params">(id)</span>value withKey:<span class="params">(const void *)</span>key;</span><br><span class="line">- <span class="params">(void)</span>bk_atomicallyAssociateValue:<span class="params">(id)</span>value withKey:<span class="params">(const void *)</span>key;</span><br><span class="line">+ <span class="params">(void)</span>bk_atomicallyAssociateValue:<span class="params">(id)</span>value withKey:<span class="params">(const void *)</span>key;</span><br><span class="line">- <span class="params">(void)</span>bk_associateCopyOfValue:<span class="params">(id)</span>value withKey:<span class="params">(const void *)</span>key;</span><br><span class="line">+ <span class="params">(void)</span>bk_associateCopyOfValue:<span class="params">(id)</span>value withKey:<span class="params">(const void *)</span>key;</span><br><span class="line">- <span class="params">(void)</span>bk_atomicallyAssociateCopyOfValue:<span class="params">(id)</span>value withKey:<span class="params">(const void *)</span>key;</span><br><span class="line">+ <span class="params">(void)</span>bk_atomicallyAssociateCopyOfValue:<span class="params">(id)</span>value withKey:<span class="params">(const void *)</span>key;</span><br><span class="line">- <span class="params">(void)</span>bk_weaklyAssociateValue:<span class="params">(__autoreleasing id)</span>value withKey:<span class="params">(const void *)</span>key;</span><br><span class="line">+ <span class="params">(void)</span>bk_weaklyAssociateValue:<span class="params">(__autoreleasing id)</span>value withKey:<span class="params">(const void *)</span>key;</span><br><span class="line">- <span class="params">(id)</span>bk_associatedValueForKey:<span class="params">(const void *)</span>key;</span><br><span class="line">+ <span class="params">(id)</span>bk_associatedValueForKey:<span class="params">(const void *)</span>key;</span><br><span class="line">- <span class="params">(void)</span>bk_removeAllAssociatedObjects;</span><br><span class="line">+ <span class="params">(void)</span>bk_removeAllAssociatedObjects;</span><br></pre></td></tr></table></figure>


<h4 id="NSInvocation"><a href="#NSInvocation" class="headerlink" title="NSInvocation"></a>NSInvocation</h4><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSInvocation</span> *invocation = [<span class="built_in">NSInvocation</span> bk_invocationWithTarget:<span class="keyword">self</span> block:^(<span class="type">id</span> target) &#123;</span><br><span class="line">    [target testMethod];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[invocation invoke];</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)testMethod &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;===&gt;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个用于触发某个target的对应方法，在block中传递进来target对象，直接使用该对象调用方法。</p>
<h4 id="performSelector-的简化"><a href="#performSelector-的简化" class="headerlink" title="performSelector 的简化"></a>performSelector 的简化</h4><p>它的最大优点在于能够取消已经对应的block。</p>
<figure class="highlight erlang"><table><tr><td class="code"><pre><span class="line">- <span class="params">(id)</span>bk_performBlock:<span class="params">(void (^)</span><span class="params">(id obj)</span>)block afterDelay:<span class="params">(NSTimeInterval)</span>delay;</span><br><span class="line">+ <span class="params">(id)</span>bk_performBlock:<span class="params">(void (^)</span><span class="params">(void)</span>)block afterDelay:<span class="params">(NSTimeInterval)</span>delay;</span><br><span class="line">- <span class="params">(id)</span>bk_performBlockInBackground:<span class="params">(void (^)</span><span class="params">(id obj)</span>)block afterDelay:<span class="params">(NSTimeInterval)</span>delay;</span><br><span class="line">+ <span class="params">(id)</span>bk_performBlockInBackground:<span class="params">(void (^)</span><span class="params">(void)</span>)block afterDelay:<span class="params">(NSTimeInterval)</span>delay;</span><br><span class="line">+ <span class="params">(id)</span>bk_performBlock:<span class="params">(void (^)</span><span class="params">(void)</span>)block onQueue:<span class="params">(dispatch_queue_t)</span>queue afterDelay:<span class="params">(NSTimeInterval)</span></span><br><span class="line">delay;</span><br><span class="line">- <span class="params">(id)</span>bk_performBlock:<span class="params">(void (^)</span><span class="params">(id obj)</span>)block onQueue:<span class="params">(dispatch_queue_t)</span>queue afterDelay:<span class="params">(NSTimeInterval)</span>delay;</span><br><span class="line">+ <span class="params">(void)</span>bk_cancelBlock:<span class="params">(id)</span>block;</span><br></pre></td></tr></table></figure>
<h4 id="KVO"><a href="#KVO" class="headerlink" title="KVO"></a>KVO</h4><figure class="highlight erlang"><table><tr><td class="code"><pre><span class="line">- <span class="params">(NSString *)</span>bk_addObserverForKeyPath:<span class="params">(NSString *)</span>keyPath task:<span class="params">(void (^)</span><span class="params">(id target)</span>)task;</span><br><span class="line">- <span class="params">(NSString *)</span>bk_addObserverForKeyPaths:<span class="params">(NSArray *)</span>keyPaths task:<span class="params">(void (^)</span><span class="params">(id obj, NSString *keyPath)</span>)task;</span><br><span class="line">- <span class="params">(NSString *)</span>bk_addObserverForKeyPath:<span class="params">(NSString *)</span>keyPath options:<span class="params">(NSKeyValueObservingOptions)</span>options task:<span class="params">(void (^)</span><span class="params">(id obj, NSDictionary *change)</span>)task;</span><br><span class="line">- <span class="params">(NSString *)</span>bk_addObserverForKeyPaths:<span class="params">(NSArray *)</span>keyPaths options:<span class="params">(NSKeyValueObservingOptions)</span>options task:<span class="params">(void (^)</span><span class="params">(id obj, NSString *keyPath, NSDictionary *change)</span>)task;</span><br><span class="line">- <span class="params">(void)</span>bk_addObserverForKeyPath:<span class="params">(NSString *)</span>keyPath identifier:<span class="params">(NSString *)</span>token options:<span class="params">(NSKeyValueObservingOptions)</span>options task:<span class="params">(void (^)</span><span class="params">(id obj, NSDictionary *change)</span>)task;</span><br><span class="line">- <span class="params">(void)</span>bk_addObserverForKeyPaths:<span class="params">(NSArray *)</span>keyPaths identifier:<span class="params">(NSString *)</span>token options:<span class="params">(NSKeyValueObservingOptions)</span>options task:<span class="params">(void (^)</span><span class="params">(id obj, NSString *keyPath, NSDictionary *change)</span>)task;</span><br><span class="line">- <span class="params">(void)</span>bk_removeObserverForKeyPath:<span class="params">(NSString *)</span>keyPath identifier:<span class="params">(NSString *)</span>token;</span><br><span class="line">- <span class="params">(void)</span>bk_removeObserversWithIdentifier:<span class="params">(NSString *)</span>token;</span><br><span class="line">- <span class="params">(void)</span>bk_removeAllBlockObservers;</span><br></pre></td></tr></table></figure>

<h4 id="NSTimer"><a href="#NSTimer" class="headerlink" title="NSTimer"></a>NSTimer</h4><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">+ (<span class="built_in">NSTimer</span> *)bk_scheduledTimerWithTimeInterval:(<span class="built_in">NSTimeInterval</span>)inTimeInterval block:(<span class="type">void</span> (^)(<span class="built_in">NSTimer</span> *timer))inBlock repeats:(<span class="type">BOOL</span>)inRepeats;</span><br><span class="line">+ (<span class="built_in">NSTimer</span> *)bk_timerWithTimeInterval:(<span class="built_in">NSTimeInterval</span>)inTimeInterval block:(<span class="type">void</span> (^)(<span class="built_in">NSTimer</span> *timer))inBlock repeats:(<span class="type">BOOL</span>)inRepeats;</span><br></pre></td></tr></table></figure>

<h4 id="UIView"><a href="#UIView" class="headerlink" title="UIView"></a>UIView</h4><figure class="highlight erlang"><table><tr><td class="code"><pre><span class="line">- <span class="params">(void)</span>bk_whenTouches:<span class="params">(NSUInteger)</span>numberOfTouches tapped:<span class="params">(NSUInteger)</span>numberOfTaps handler:<span class="params">(void (^)</span><span class="params">(void)</span>)block;</span><br></pre></td></tr></table></figure>
<p>numberOfTouches 多少个手指<br>numberOfTaps 点击多少次</p>
<p>规定多少个手指，多少点击多少次才会触发该handler Block进行处理。</p>
<figure class="highlight nim"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)bk_whenTapped:(<span class="type">void</span> (^)(<span class="type">void</span>))<span class="keyword">block</span>;</span><br><span class="line">- (<span class="type">void</span>)bk_whenDoubleTapped:(<span class="type">void</span> (^)(<span class="type">void</span>))<span class="keyword">block</span>;</span><br></pre></td></tr></table></figure>
<p>单击双击UIView对象会执行指定的block</p>
<figure class="highlight erlang"><table><tr><td class="code"><pre><span class="line">- <span class="params">(void)</span>bk_eachSubview:<span class="params">(void (^)</span><span class="params">(UIView *subview)</span>)block;</span><br></pre></td></tr></table></figure>
<p>非递归方式遍历当前View的子View</p>
<h4 id="UIGestureRecognizer"><a href="#UIGestureRecognizer" class="headerlink" title="UIGestureRecognizer"></a>UIGestureRecognizer</h4><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UITapGestureRecognizer</span> *singleTap = [<span class="built_in">UITapGestureRecognizer</span> recognizerWithHandler:^(<span class="type">id</span> sender) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;Single tap.&quot;</span>);</span><br><span class="line">&#125; delay:<span class="number">0.18</span>];</span><br><span class="line">[<span class="keyword">self</span> addGestureRecognizer:singleTap];</span><br><span class="line"></span><br><span class="line"><span class="built_in">UITapGestureRecognizer</span> *doubleTap = [<span class="built_in">UITapGestureRecognizer</span> recognizerWithHandler:^(<span class="type">id</span> sender) &#123;</span><br><span class="line">[singleTap cancel];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;Double tap.&quot;</span>);</span><br><span class="line">&#125;];</span><br><span class="line">doubleTap.numberOfTapsRequired = <span class="number">2</span>;</span><br><span class="line">[<span class="keyword">self</span> addGestureRecognizer:doubleTap];</span><br></pre></td></tr></table></figure>

<h4 id="UIControl"><a href="#UIControl" class="headerlink" title="UIControl"></a>UIControl</h4><figure class="highlight erlang"><table><tr><td class="code"><pre><span class="line">- <span class="params">(void)</span>bk_addEventHandler:<span class="params">(void (^)</span><span class="params">(id sender)</span>)handler forControlEvents:<span class="params">(UIControlEvents)</span>controlEvents;</span><br><span class="line">- <span class="params">(void)</span>bk_removeEventHandlersForControlEvents:<span class="params">(UIControlEvents)</span>controlEvents;</span><br><span class="line">- <span class="params">(BOOL)</span>bk_hasEventHandlersForControlEvents:<span class="params">(UIControlEvents)</span>controlEvents;</span><br></pre></td></tr></table></figure>

<h4 id="部分源码解析："><a href="#部分源码解析：" class="headerlink" title="部分源码解析："></a>部分源码解析：</h4><h5 id="UIControl-1"><a href="#UIControl-1" class="headerlink" title="UIControl"></a>UIControl</h5><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)bk_addEventHandler:(<span class="type">void</span> (^)(<span class="type">id</span> sender))handler forControlEvents:(<span class="built_in">UIControlEvents</span>)controlEvents&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">NSParameterAssert</span>(handler);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//获取对象绑定到的事件</span></span><br><span class="line">	<span class="built_in">NSMutableDictionary</span> *events = objc_getAssociatedObject(<span class="keyword">self</span>, BKControlHandlersKey);</span><br><span class="line">	<span class="keyword">if</span> (!events) &#123;</span><br><span class="line">		events = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">        <span class="comment">//如果当前为首次给对象添加事件，则新建一个事件字典，并动态关联到对象</span></span><br><span class="line">		objc_setAssociatedObject(<span class="keyword">self</span>, BKControlHandlersKey, events, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取出该事件的处理者</span></span><br><span class="line">	<span class="built_in">NSNumber</span> *key = @(controlEvents);</span><br><span class="line">	<span class="built_in">NSMutableSet</span> *handlers = events[key];</span><br><span class="line">	<span class="keyword">if</span> (!handlers) &#123;</span><br><span class="line">		handlers = [<span class="built_in">NSMutableSet</span> set];</span><br><span class="line">		events[key] = handlers;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//将处理的Block 以及处理类型存储到BKControlWrapper对象</span></span><br><span class="line">	BKControlWrapper *target = [[BKControlWrapper alloc] initWithHandler:handler forControlEvents:controlEvents];</span><br><span class="line">	[handlers addObject:target];</span><br><span class="line">    <span class="comment">//触发BKControlWrapper的invoke方法。</span></span><br><span class="line">	[<span class="keyword">self</span> addTarget:target action:<span class="keyword">@selector</span>(invoke:) forControlEvents:controlEvents];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2019/11/26/BlocksKit-%E7%9A%84%E4%BD%BF%E7%94%A8/00001.png"></p>
<p>UIControl+BlocksKit 中是通过为每个UIControl对象添加一个以UIControlEvents为key，value为BKControlWrapper集合的字典，当我们要为某个UIControlEvents添加一个事件的时候只要找到对应的handlers集合，然后将handler和UIControlEvents封装到BKControlWrapper，然后再调用[self addTarget:target action:@selector(invoke:) forControlEvents:controlEvents];<br>这样一旦发生controlEvents事件，就会触发BKControlWrapper的invoke方法,在invoke方法中就会执行对应的block。</p>
<h5 id="UIGestureRecognizer-1"><a href="#UIGestureRecognizer-1" class="headerlink" title="UIGestureRecognizer"></a>UIGestureRecognizer</h5><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">+ (<span class="type">id</span>)bk_recognizerWithHandler:(<span class="type">void</span> (^)(<span class="built_in">UIGestureRecognizer</span> *sender, <span class="built_in">UIGestureRecognizerState</span> state, <span class="built_in">CGPoint</span> location))block delay:(<span class="built_in">NSTimeInterval</span>)delay &#123;</span><br><span class="line">	<span class="keyword">return</span> [[[<span class="keyword">self</span> <span class="keyword">class</span>] alloc] bk_initWithHandler:block delay:delay];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">id</span>)bk_initWithHandler:(<span class="type">void</span> (^)(<span class="built_in">UIGestureRecognizer</span> *sender, <span class="built_in">UIGestureRecognizerState</span> state, <span class="built_in">CGPoint</span> location))block delay:(<span class="built_in">NSTimeInterval</span>)delay &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">self</span> initWithTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(bk_handleAction:)];</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">self</span>.bk_handler = block;</span><br><span class="line">    <span class="keyword">self</span>.bk_handlerDelay = delay;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化的时候会将delay以及block保存到<strong><strong>bk_handler</strong></strong>以及<strong><strong>bk_handlerDelay</strong></strong>，并指定当前处理的Action为<strong><strong>bk_handleAction</strong></strong>。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)bk_handleAction:(<span class="built_in">UIGestureRecognizer</span> *)recognizer&#123;</span><br><span class="line">	<span class="type">void</span> (^handler)(<span class="built_in">UIGestureRecognizer</span> *sender, <span class="built_in">UIGestureRecognizerState</span> state, <span class="built_in">CGPoint</span> location) = recognizer.bk_handler;</span><br><span class="line">	<span class="keyword">if</span> (!handler) <span class="keyword">return</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">NSTimeInterval</span> delay = <span class="keyword">self</span>.bk_handlerDelay;</span><br><span class="line">	<span class="built_in">CGPoint</span> location = [<span class="keyword">self</span> locationInView:<span class="keyword">self</span>.view];</span><br><span class="line">	<span class="type">void</span> (^block)(<span class="type">void</span>) = ^&#123;</span><br><span class="line">		<span class="keyword">if</span> (!<span class="keyword">self</span>.bk_shouldHandleAction) <span class="keyword">return</span>;</span><br><span class="line">		handler(<span class="keyword">self</span>, <span class="keyword">self</span>.state, location);</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">self</span>.bk_shouldHandleAction = <span class="literal">YES</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!delay) &#123;</span><br><span class="line">		block();</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	dispatch_time_t popTime = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(delay * <span class="built_in">NSEC_PER_SEC</span>));</span><br><span class="line">	dispatch_after(popTime, dispatch_get_main_queue(), block);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在对应的手势事件触发的时候会调用bk_handleAction 这时候取出bk_handler，然后根据是否需要延迟执行来执行对应的bk_handler</p>
<p>介绍了UIGestureRecognizer+BlocksKit这里顺带介绍下UIView+BlocksKit,它实际上也是在UIView的基础上添加手势识别器来实现的：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)bk_whenTouches:(<span class="built_in">NSUInteger</span>)numberOfTouches tapped:(<span class="built_in">NSUInteger</span>)numberOfTaps handler:(<span class="type">void</span> (^)(<span class="type">void</span>))block &#123;</span><br><span class="line">	<span class="keyword">if</span> (!block) <span class="keyword">return</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">UITapGestureRecognizer</span> *gesture = [<span class="built_in">UITapGestureRecognizer</span> bk_recognizerWithHandler:^(<span class="built_in">UIGestureRecognizer</span> *sender, <span class="built_in">UIGestureRecognizerState</span> state, <span class="built_in">CGPoint</span> location) &#123;</span><br><span class="line">		<span class="keyword">if</span> (state == <span class="built_in">UIGestureRecognizerStateRecognized</span>) block();</span><br><span class="line">	&#125;];</span><br><span class="line">	</span><br><span class="line">	gesture.numberOfTouchesRequired = numberOfTouches;</span><br><span class="line">	gesture.numberOfTapsRequired = numberOfTaps;</span><br><span class="line"></span><br><span class="line">	[<span class="keyword">self</span>.gestureRecognizers enumerateObjectsUsingBlock:^(<span class="type">id</span> obj, <span class="built_in">NSUInteger</span> idx, <span class="type">BOOL</span> *stop) &#123;</span><br><span class="line">		<span class="keyword">if</span> (![obj isKindOfClass:[<span class="built_in">UITapGestureRecognizer</span> <span class="keyword">class</span>]]) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">UITapGestureRecognizer</span> *tap = obj;</span><br><span class="line">		<span class="type">BOOL</span> rightTouches = (tap.numberOfTouchesRequired == numberOfTouches);</span><br><span class="line">		<span class="type">BOOL</span> rightTaps = (tap.numberOfTapsRequired == numberOfTaps);</span><br><span class="line">		<span class="keyword">if</span> (rightTouches &amp;&amp; rightTaps) &#123;</span><br><span class="line">			[gesture requireGestureRecognizerToFail:tap];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;];</span><br><span class="line"></span><br><span class="line">	[<span class="keyword">self</span> addGestureRecognizer:gesture];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)bk_whenTapped:(<span class="type">void</span> (^)(<span class="type">void</span>))block&#123;</span><br><span class="line">	[<span class="keyword">self</span> bk_whenTouches:<span class="number">1</span> tapped:<span class="number">1</span> handler:block];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="关联对象-1"><a href="#关联对象-1" class="headerlink" title="关联对象"></a>关联对象</h5><p>这部分没太多新颖的内容，比较有意思的是实现weak方式的关联，它实际上使用了一个中间对象，来做过渡，它持有一个weak类型的属性value来存储实际所赋的值。在获取关联对象时就判断其是否为_BKWeakAssociatedObject类型的对象，如果是就返回该对象value的属性值。</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">+ (void)bk_weaklyAssociateValue:(__autoreleasing id)value withKey:(const void *)<span class="built_in">key</span> &#123;</span><br><span class="line">	_BKWeakAssociatedObject *<span class="built_in">assoc</span> = objc_getAssociatedObject(self, <span class="built_in">key</span>);</span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">assoc</span>) &#123;</span><br><span class="line">		<span class="built_in">assoc</span> = [_BKWeakAssociatedObject <span class="built_in">new</span>];</span><br><span class="line">		[self bk_associateValue:<span class="built_in">assoc</span> withKey:<span class="built_in">key</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">assoc</span>.value = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="NSObject-BKBlockExecution"><a href="#NSObject-BKBlockExecution" class="headerlink" title="NSObject+BKBlockExecution"></a>NSObject+BKBlockExecution</h5><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">- (id)bk_performBlock:(<span class="type">void</span> (^)(id obj))block onQueue:(dispatch_queue_t)queue afterDelay:(NSTimeInterval)delay &#123;</span><br><span class="line">	NSParameterAssert(block != nil);</span><br><span class="line"></span><br><span class="line">	__block <span class="type">BOOL</span> cancelled = <span class="keyword">NO</span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">void</span> (^<span class="keyword">wrapper</span>)(<span class="type">BOOL</span>) = ^(<span class="type">BOOL</span> cancel) &#123;</span><br><span class="line">		<span class="keyword">if</span> (cancel) &#123;</span><br><span class="line">			cancelled = YES;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!cancelled) block(self);</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">	dispatch_after(BKTimeDelay(delay), queue, ^&#123;</span><br><span class="line">		<span class="keyword">wrapper</span>(<span class="keyword">NO</span>);</span><br><span class="line">	&#125;);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> [<span class="keyword">wrapper</span> <span class="keyword">copy</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">+ (<span class="type">void</span>)bk_cancelBlock:(id)block &#123;</span><br><span class="line">	NSParameterAssert(block != nil);</span><br><span class="line">	<span class="type">void</span> (^<span class="keyword">wrapper</span>)(<span class="type">BOOL</span>) = block;</span><br><span class="line">	<span class="keyword">wrapper</span>(YES);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里使用了一个__block的cacelled标记，标记无效时才执行block。默认情况下就传入NO，使其能正常工作。将要取消时传入YES即可，所以在取消的时候就直接调用了wrapper(YES);</p>
<h5 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h5><p>BlocksKit的动态代理部分是整个BlocksKit的精华所在，它用于解决什么问题呢？<br>我们先来看下我们要给一个对象设置代理一般有如下步骤：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1.</span> 创建代理对象</span><br><span class="line"><span class="bullet">2.</span> 代理对象遵守协议；</span><br><span class="line"><span class="bullet">3.</span> 代理对象实现协议</span><br><span class="line"><span class="bullet">4.</span> 将代理对象赋给delegate属性</span><br></pre></td></tr></table></figure>

<p>这有个不好的地方就是代码会显得比较散乱，必须要新建一个代理类，并且代理实现方法和设置代理的方法是分开的，这种问题之前我们会采用rac_signalForSelector来将代理实现聚合在设置代理的方法地方。但是这还不算是十分优雅的方式：</p>
<p>在BlocksKit中给出下面的一个例子：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UIAlertView</span> *alertView = [[<span class="built_in">UIAlertView</span> alloc]</span><br><span class="line">							initWithTitle:<span class="string">@&quot;Hello World!&quot;</span></span><br><span class="line">							message:<span class="string">@&quot;This alert&#x27;s delegate is implemented using blocks. That&#x27;s so cool!&quot;</span></span><br><span class="line">							delegate:<span class="literal">nil</span></span><br><span class="line">							cancelButtonTitle:<span class="string">@&quot;Meh.&quot;</span></span><br><span class="line">							otherButtonTitles:<span class="string">@&quot;Woo!&quot;</span>, <span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get the dynamic delegate</span></span><br><span class="line">A2DynamicDelegate *dd = alertView.bk_dynamicDelegate;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Implement -alertViewShouldEnableFirstOtherButton:</span></span><br><span class="line">[dd implementMethod:<span class="keyword">@selector</span>(alertViewShouldEnableFirstOtherButton:) withBlock:^(<span class="built_in">UIAlertView</span> *alertView) &#123;</span><br><span class="line">	<span class="built_in">NSLog</span>(<span class="string">@&quot;Message: %@&quot;</span>, alertView.message);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Implement -alertView:willDismissWithButtonIndex:</span></span><br><span class="line">[dd implementMethod:<span class="keyword">@selector</span>(alertView:willDismissWithButtonIndex:) withBlock:^(<span class="built_in">UIAlertView</span> *alertView, <span class="built_in">NSInteger</span> buttonIndex) &#123;</span><br><span class="line">	<span class="built_in">NSLog</span>(<span class="string">@&quot;You pushed button #%d (%@)&quot;</span>, buttonIndex, [alertView buttonTitleAtIndex:buttonIndex]);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set the delegate</span></span><br><span class="line">alertView.delegate = dd;</span><br><span class="line"></span><br><span class="line">[alertView show];</span><br></pre></td></tr></table></figure>

<p>这个就是BlocksKit动态代理的使用过程：</p>
<p>首先通过bk_dynamicDelegate来获得UIAlertView的动态代理，然后通过implementMethod将代理方法selector与对应的block绑定，最后将动态代理设置给UIAlertView。<br>整个代码一气呵成。但是背后实际上还是存在代理类的创建，后面会一一向大家介绍整个流程,我们先来看下涉及到的关键类有哪些：</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">A<span class="symbol">2B</span>lockInvocation 的主要用于存储和转发<span class="keyword">block</span></span><br><span class="line"><span class="keyword"></span>A2DynamicDelegate 用来实现类的代理和数据源</span><br><span class="line">NSObject+A2DynamicDelegate 负责为返回 <span class="keyword">bk_dynamicDelegate </span>和 <span class="keyword">bk_dynamicDataSource </span>等 A2DynamicDelegate 类型的实例，</span><br><span class="line">NSObject+A<span class="symbol">2B</span>lockDelegate 提供了一系列接口将代理方法映射到 <span class="keyword">block </span>上</span><br></pre></td></tr></table></figure>

<p>我们接下来顺着上面的例子过一遍代码，看下如何实现动态代理的功能。</p>
<p>在载入UIAlertView+BlocksKit 分类的时候会调用load方法，这里主要做了两件事情，一个是通过bk_registerDynamicDelegate来注册动态代理，另一个是通过bk_linkDelegateMethods将指定的Block与对应的Delegate方法链接起来。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">+ (void)load&#123;</span><br><span class="line"><span class="meta">	@autoreleasepool &#123;</span></span><br><span class="line">		[self bk_registerDynamicDelegate];</span><br><span class="line">		[self bk_linkDelegateMethods:@&#123;</span><br><span class="line"><span class="meta">			@<span class="string">&quot;bk_willShowBlock&quot;</span>: @<span class="string">&quot;willPresentAlertView:&quot;</span>,</span></span><br><span class="line"><span class="meta">			@<span class="string">&quot;bk_didShowBlock&quot;</span>: @<span class="string">&quot;didPresentAlertView:&quot;</span>,</span></span><br><span class="line"><span class="meta">			@<span class="string">&quot;bk_willDismissBlock&quot;</span>: @<span class="string">&quot;alertView:willDismissWithButtonIndex:&quot;</span>,</span></span><br><span class="line"><span class="meta">			@<span class="string">&quot;bk_didDismissBlock&quot;</span>: @<span class="string">&quot;alertView:didDismissWithButtonIndex:&quot;</span>,</span></span><br><span class="line"><span class="meta">			@<span class="string">&quot;bk_shouldEnableFirstOtherButtonBlock&quot;</span>: @<span class="string">&quot;alertViewShouldEnableFirstOtherButton:&quot;</span></span></span><br><span class="line">		&#125;];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><strong>注册动态代理</strong></strong>：</p>
<p>注册动态代理相关代码如下：</p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line">+ (<span class="literal">void</span>)bk_registerDynamicDelegate &#123;</span><br><span class="line">	<span class="meta">[</span><span class="built_in">self</span> bk_registerDynamicDelegateNamed:@<span class="string">&quot;delegate&quot;</span> forProtocol:a2_delegateProtocol(<span class="built_in">self</span><span class="comment">/*UIAlertView*/</span>)<span class="comment">/*UIAlertViewDelegate*/</span><span class="meta">]</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">Protocol *a2<span class="constructor">_delegateProtocol(Class <span class="params">cls</span>)</span> &#123;</span><br><span class="line">    <span class="comment">/*获取到UIActionSheetDelegate协议*/</span></span><br><span class="line">	return a2<span class="constructor">_classProtocol(<span class="params">cls</span>, @<span class="string">&quot;Delegate&quot;</span>, @<span class="string">&quot;delegate&quot;</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static Protocol *a2<span class="constructor">_classProtocol(Class <span class="params">_cls</span><span class="operator">/</span><span class="operator">*</span>UIAlertView<span class="operator">*</span><span class="operator">/</span>, NSString <span class="operator">*</span><span class="params">suffix</span><span class="operator">/</span><span class="operator">*</span>Delegate<span class="operator">*</span><span class="operator">/</span>, NSString <span class="operator">*</span><span class="params">description</span><span class="operator">/</span><span class="operator">*</span><span class="params">delegate</span><span class="operator">*</span><span class="operator">/</span>)</span> &#123;</span><br><span class="line">	Class cls = _cls;</span><br><span class="line">	<span class="keyword">while</span> (cls) &#123;</span><br><span class="line">		NSString *className = <span class="constructor">NSStringFromClass(<span class="params">cls</span>)</span>;</span><br><span class="line">        <span class="comment">//UIAlertViewDelegate</span></span><br><span class="line">		NSString *protocolName = <span class="literal">[<span class="identifier">className</span> <span class="identifier">stringByAppendingString</span>:<span class="identifier">suffix</span>]</span>;</span><br><span class="line">        <span class="comment">//获得UIAlertViewDelegate协议</span></span><br><span class="line">		Protocol *protocol = objc<span class="constructor">_getProtocol(<span class="params">protocolName</span>.UTF8String)</span>;</span><br><span class="line">		<span class="keyword">if</span> (protocol) return protocol;</span><br><span class="line">		cls = <span class="keyword">class</span><span class="constructor">_getSuperclass(<span class="params">cls</span>)</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//............</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">+ (<span class="type">void</span>)bk_registerDynamicDelegateNamed:(<span class="built_in">NSString</span> *)delegateName &#123;</span><br><span class="line">	[<span class="keyword">self</span> bk_registerDynamicDelegateNamed:delegateName forProtocol:a2_delegateProtocol(<span class="keyword">self</span>)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">+ (<span class="type">void</span>)bk_registerDynamicDelegateNamed:(<span class="built_in">NSString</span> *)delegateName<span class="comment">/*delegate*/</span> forProtocol:(Protocol *)protocol<span class="comment">/*UIAlertViewDelegate*/</span> &#123;</span><br><span class="line">	<span class="built_in">NSMapTable</span> *propertyMap = [<span class="keyword">self</span> bk_delegateInfoByProtocol:<span class="literal">YES</span>];</span><br><span class="line">	A2BlockDelegateInfo *infoAsPtr = (__bridge <span class="type">void</span> *)[propertyMap objectForKey:protocol];</span><br><span class="line">	<span class="keyword">if</span> (infoAsPtr != <span class="literal">NULL</span>) &#123; <span class="keyword">return</span>; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> <span class="type">char</span> *name = delegateName.UTF8String;                 <span class="comment">/*delegate*/</span></span><br><span class="line">	objc_property_t property = class_getProperty(<span class="keyword">self</span>, name);   <span class="comment">/*获得UIAlertView 的 delegate property属性*/</span></span><br><span class="line">	SEL <span class="keyword">setter</span> = setterForProperty(property, name);             <span class="comment">/*setDelegate:*/</span></span><br><span class="line">	SEL a2_setter = prefixedSelector(<span class="keyword">setter</span>);                   <span class="comment">/*a2_SetDelegate:*/</span></span><br><span class="line">	SEL <span class="keyword">getter</span> = getterForProperty(property, name);             <span class="comment">/*delegate*/</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//A2BlockDelegateInfo 包着setter，a2_setter，getter 三个Selector</span></span><br><span class="line">	A2BlockDelegateInfo info = &#123;</span><br><span class="line">		<span class="keyword">setter</span>, a2_setter, <span class="keyword">getter</span></span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里将A2BlockDelegateInfo设置propertyMap到</span></span><br><span class="line">	[propertyMap setObject:(__bridge <span class="type">id</span>)&amp;info forKey:protocol];</span><br><span class="line">	infoAsPtr = (__bridge <span class="type">void</span> *)[propertyMap objectForKey:protocol];</span><br><span class="line"></span><br><span class="line">	<span class="comment">//交换delegate setter的selector，也就是说在XXXX.delegate 的时候就会将delegte值赋给dynamicDelegate.realDelegate</span></span><br><span class="line">	IMP setterImplementation = imp_implementationWithBlock(^(<span class="built_in">NSObject</span> *delegatingObject, <span class="type">id</span> delegate) &#123;</span><br><span class="line">		A2DynamicDelegate *dynamicDelegate = getDynamicDelegate(delegatingObject, protocol, infoAsPtr, <span class="literal">YES</span>);</span><br><span class="line">		<span class="comment">//如果dynamicDelegate 等于 delegate的话也不使用delegate</span></span><br><span class="line">		<span class="keyword">if</span> ([delegate isEqual:dynamicDelegate]) &#123;</span><br><span class="line">			delegate = <span class="literal">nil</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//dynamicDelegate 表示真实的delegate</span></span><br><span class="line">		dynamicDelegate.realDelegate = delegate;</span><br><span class="line">	&#125;);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将设置方法setter设为a2_SetDelegate</span></span><br><span class="line">	<span class="keyword">if</span> (!swizzleWithIMP(<span class="keyword">self</span>, <span class="keyword">setter</span>, a2_setter, setterImplementation, <span class="string">&quot;v@:@&quot;</span>, <span class="literal">YES</span>)) &#123;</span><br><span class="line">		bzero(infoAsPtr, <span class="keyword">sizeof</span>(A2BlockDelegateInfo));</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (![<span class="keyword">self</span> instancesRespondToSelector:<span class="keyword">getter</span>]) &#123;</span><br><span class="line">		IMP getterImplementation = imp_implementationWithBlock(^(<span class="built_in">NSObject</span> *delegatingObject) &#123;</span><br><span class="line">			<span class="comment">//获取到对应的动态代理对象</span></span><br><span class="line">			<span class="keyword">return</span> [delegatingObject bk_dynamicDelegateForProtocol:a2_protocolForDelegatingObject(delegatingObject, protocol)];</span><br><span class="line">		&#125;);</span><br><span class="line">		addMethodWithIMP(<span class="keyword">self</span>, <span class="keyword">getter</span>, <span class="literal">NULL</span>, getterImplementation, <span class="string">&quot;@@:&quot;</span>, <span class="literal">NO</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> A2DynamicDelegate *getDynamicDelegate(<span class="built_in">NSObject</span> *delegatingObject,<span class="comment">/*被代理对象*/</span> Protocol *protocol, <span class="keyword">const</span> A2BlockDelegateInfo *info, <span class="type">BOOL</span> ensuring) &#123;</span><br><span class="line">	A2DynamicDelegate *dynamicDelegate = [delegatingObject bk_dynamicDelegateForProtocol:a2_protocolForDelegatingObject(delegatingObject, protocol)<span class="comment">/*UIAlertViewDelegate*/</span>];</span><br><span class="line">	<span class="comment">//......</span></span><br><span class="line">	<span class="keyword">return</span> dynamicDelegate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">id</span>)bk_dynamicDelegateForProtocol:(Protocol *)protocol&#123;</span><br><span class="line">	Class <span class="keyword">class</span> = [A2DynamicDelegate <span class="keyword">class</span>];</span><br><span class="line">    <span class="comment">/*UIAlertViewDelegate*/</span></span><br><span class="line">	<span class="built_in">NSString</span> *protocolName = <span class="built_in">NSStringFromProtocol</span>(protocol);</span><br><span class="line">	<span class="keyword">if</span> ([protocolName hasSuffix:<span class="string">@&quot;Delegate&quot;</span>]) &#123;</span><br><span class="line">		<span class="keyword">class</span> = a2_dynamicDelegateClass([<span class="keyword">self</span> <span class="keyword">class</span>], <span class="string">@&quot;Delegate&quot;</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> ([protocolName hasSuffix:<span class="string">@&quot;DataSource&quot;</span>]) &#123;</span><br><span class="line">		<span class="keyword">class</span> = a2_dynamicDelegateClass([<span class="keyword">self</span> <span class="keyword">class</span>], <span class="string">@&quot;DataSource&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">/*A2DynamicUIAlertViewDelegate*/</span></span><br><span class="line">	<span class="keyword">return</span> [<span class="keyword">self</span> bk_dynamicDelegateWithClass:<span class="keyword">class</span> forProtocol:protocol];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> Class a2_dynamicDelegateClass(Class cls, <span class="built_in">NSString</span> *suffix) &#123;</span><br><span class="line">	<span class="keyword">while</span> (cls) &#123;</span><br><span class="line">		<span class="comment">//A2DynamicUIAlertViewDelegate</span></span><br><span class="line">		<span class="built_in">NSString</span> *className = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;A2Dynamic%@%@&quot;</span>, <span class="built_in">NSStringFromClass</span>(cls), suffix];</span><br><span class="line">		Class ddClass = <span class="built_in">NSClassFromString</span>(className);</span><br><span class="line">		<span class="keyword">if</span> (ddClass) <span class="keyword">return</span> ddClass;</span><br><span class="line">		cls = class_getSuperclass(cls);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> [A2DynamicDelegate <span class="keyword">class</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">- (id)bk_dynamicDelegateWithClass:(Class)cls forProtocol:(Protocol *)protocol&#123;</span><br><span class="line"></span><br><span class="line">	__block A2DynamicDelegate *dynamicDelegate;</span><br><span class="line"></span><br><span class="line">	dispatch<span class="constructor">_sync(<span class="params">a2_backgroundQueue</span>()</span>, ^&#123;</span><br><span class="line">		dynamicDelegate = objc<span class="constructor">_getAssociatedObject(<span class="params">self</span>, (<span class="params">__bridge</span> <span class="params">const</span> <span class="params">void</span> <span class="operator">*</span>)</span>protocol);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!dynamicDelegate) &#123;</span><br><span class="line">			<span class="comment">//将当前代理与当前对象关联，这里可以起到缓存作用</span></span><br><span class="line">			dynamicDelegate = <span class="literal">[[<span class="identifier">cls</span> <span class="identifier">alloc</span>]</span> initWithProtocol:protocol];</span><br><span class="line">			objc<span class="constructor">_setAssociatedObject(<span class="params">self</span>, (<span class="params">__bridge</span> <span class="params">const</span> <span class="params">void</span> <span class="operator">*</span>)</span>protocol, dynamicDelegate, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">	return dynamicDelegate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最为关键的在于：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">+ (<span class="type">void</span>)bk_registerDynamicDelegateNamed:(<span class="built_in">NSString</span> *)delegateName forProtocol:(Protocol *)protocol;</span><br></pre></td></tr></table></figure>

<p>以及</p>
<figure class="highlight erlang"><table><tr><td class="code"><pre><span class="line">- <span class="params">(id)</span>bk_dynamicDelegateForProtocol:<span class="params">(Protocol *)</span>protocol</span><br></pre></td></tr></table></figure>

<p>在bk_registerDynamicDelegateNamed方法中会将通过bk_dynamicDelegateForProtocol方法获取到的代理对象通过关联对象与当前对象产生关联，也就是说将A2DynamicUIAlertViewDelegate对象作为当前的dynamicDelegate属性添加到当前类中，并且原本的delegate存到dynamicDelegate 的 realDelegate对象中，获取delegate的时候，返回就是dynamicDelegate这个管理对象。从而达到替换的目的。也就是说在我们调用delegate的时候实际上是返回<strong><strong>A2DynamicUIAlertViewDelegate</strong></strong>，这时候系统调用delegate方法的时候会转调A2DynamicUIAlertViewDelegate对应的方法，</p>
<p>我们接下来看下<strong><strong>A2DynamicUIAlertViewDelegate</strong></strong>中的具体一个代理方法：</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">BOOL)alertViewShouldEnableFirstOtherButton:(UIAlertView </span>*)alertView &#123;</span><br><span class="line">	<span class="keyword">BOOL </span><span class="keyword">should </span>= YES;</span><br><span class="line">	id realDelegate = self.realDelegate;</span><br><span class="line">	if (realDelegate &amp;&amp; [realDelegate respondsToSelector:@selector(alertViewShouldEnableFirstOtherButton:)])</span><br><span class="line">		<span class="keyword">should </span>&amp;= [realDelegate alertViewShouldEnableFirstOtherButton:alertView];</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">BOOL </span>(^<span class="keyword">block)(UIAlertView </span>*) = [self <span class="keyword">blockImplementationForMethod:_cmd];</span></span><br><span class="line"><span class="keyword"></span>	if (<span class="keyword">block)</span></span><br><span class="line"><span class="keyword"></span>		<span class="keyword">should </span>&amp;= <span class="keyword">block(alertView);</span></span><br><span class="line"><span class="keyword"></span>	</span><br><span class="line">	return <span class="keyword">should;</span></span><br><span class="line"><span class="keyword"></span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在这里调用了<strong><strong>blockImplementationForMethod</strong></strong>，通过这个方法取出这个代理对应的Block执行。我们看下<strong><strong>blockImplementationForMethod</strong></strong>方法：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">id</span>)blockImplementationForMethod:(SEL)selector&#123;</span><br><span class="line">	A2BlockInvocation *invocation = <span class="literal">nil</span>;</span><br><span class="line">	<span class="keyword">if</span> ((invocation = [<span class="keyword">self</span>.invocationsBySelectors bk_objectForSelector:selector]))</span><br><span class="line">		<span class="keyword">return</span> invocation.block;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法会通过selector 从 A2BlockInvocation中获取对应的invocation，而block就存在这里，这个接下来会进行介绍。</p>
<p>这里做个简单的总结：</p>
<p>首先在load方法中通过bk_registerDynamicDelegate方法将delegate替换为我们已经实现好的A2DynamicUIAlertViewDelegate，这样在系统事件发生需要调用delegate方法的时候就会将流程转到A2DynamicUIAlertViewDelegate，在这里会通过当前selector从A2BlockInvocation中获取到对应的invocation，block就存在这个invocation中。那么这里就会产生一个问题，selector怎么和invocation产生关联的？我们接下来介绍这部分。</p>
<p>如果我们还有印象的话在load方法中还调用了<strong><strong>bk_linkDelegateMethods</strong></strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">+ (void)load&#123;</span><br><span class="line"><span class="meta">	@autoreleasepool &#123;</span></span><br><span class="line">		[self bk_registerDynamicDelegate];</span><br><span class="line">		[self bk_linkDelegateMethods:@&#123;</span><br><span class="line"><span class="meta">			@<span class="string">&quot;bk_willShowBlock&quot;</span>: @<span class="string">&quot;willPresentAlertView:&quot;</span>,</span></span><br><span class="line"><span class="meta">			@<span class="string">&quot;bk_didShowBlock&quot;</span>: @<span class="string">&quot;didPresentAlertView:&quot;</span>,</span></span><br><span class="line"><span class="meta">			@<span class="string">&quot;bk_willDismissBlock&quot;</span>: @<span class="string">&quot;alertView:willDismissWithButtonIndex:&quot;</span>,</span></span><br><span class="line"><span class="meta">			@<span class="string">&quot;bk_didDismissBlock&quot;</span>: @<span class="string">&quot;alertView:didDismissWithButtonIndex:&quot;</span>,</span></span><br><span class="line"><span class="meta">			@<span class="string">&quot;bk_shouldEnableFirstOtherButtonBlock&quot;</span>: @<span class="string">&quot;alertViewShouldEnableFirstOtherButton:&quot;</span></span></span><br><span class="line">		&#125;];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">+ (void)<span class="keyword">bk_linkDelegateMethods:(NSDictionary </span>*)<span class="keyword">dictionary&#123;</span></span><br><span class="line"><span class="keyword"></span>	[self <span class="keyword">bk_linkProtocol:a2_delegateProtocol(self) </span>methods:<span class="keyword">dictionary];</span></span><br><span class="line"><span class="keyword"></span>&#125;</span><br></pre></td></tr></table></figure>

<p><strong><strong>bk_linkProtocol</strong></strong>是这部分最为关键的方法，会将block与delegate中的selector进行关联。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">+ (void)bk_linkProtocol:(Protocol *)protocol methods:(NSDictionary *)dictionary &#123;</span><br><span class="line"></span><br><span class="line">	<span class="literal">[<span class="identifier">dictionary</span> <span class="identifier">enumerateKeysAndObjectsUsingBlock</span>:^(NSS<span class="identifier">tring</span> <span class="operator">*</span><span class="identifier">propertyName</span>, NSS<span class="identifier">tring</span> <span class="operator">*</span><span class="identifier">selectorName</span>, BOOL <span class="operator">*</span><span class="identifier">stop</span>) &#123;</span></span><br><span class="line"><span class="literal"></span></span><br><span class="line"><span class="literal">		<span class="operator">/</span><span class="operator">/</span><span class="operator">...</span><span class="operator">...</span></span></span><br><span class="line"><span class="literal">		IMP <span class="identifier">getterImplementation</span> = <span class="identifier">imp_implementationWithBlock</span>(^(NSO<span class="identifier">bject</span> <span class="operator">*</span><span class="identifier">delegatingObject</span>) &#123;</span></span><br><span class="line"><span class="literal">			A2D<span class="identifier">ynamicDelegate</span> <span class="operator">*</span><span class="identifier">delegate</span> = <span class="identifier">getDynamicDelegate</span>(<span class="identifier">delegatingObject</span>, <span class="identifier">protocol</span>, <span class="identifier">info</span>, NO);</span></span><br><span class="line"><span class="literal">			<span class="identifier">return</span> [<span class="identifier">delegate</span> <span class="identifier">blockImplementationForMethod</span>:<span class="identifier">selector</span>]</span>;</span><br><span class="line">		&#125;);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!<span class="keyword">class</span><span class="constructor">_addMethod(<span class="params">self</span>, <span class="params">getter</span>, <span class="params">getterImplementation</span>, <span class="string">&quot;@@:&quot;</span>)</span>) &#123;</span><br><span class="line">			<span class="constructor">NSCAssert(NO, @<span class="string">&quot;Could not implement getter for \&quot;%@\&quot; property.&quot;</span>, <span class="params">propertyName</span>)</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		IMP setterImplementation = imp<span class="constructor">_implementationWithBlock(^(NSObject <span class="operator">*</span><span class="params">delegatingObject</span>, <span class="params">id</span> <span class="params">block</span>)</span> &#123;</span><br><span class="line">			A2DynamicDelegate *delegate = get<span class="constructor">DynamicDelegate(<span class="params">delegatingObject</span>, <span class="params">protocol</span>, <span class="params">info</span>, YES)</span>;</span><br><span class="line">			<span class="literal">[<span class="identifier">delegate</span> <span class="identifier">implementMethod</span>:<span class="identifier">selector</span> <span class="identifier">withBlock</span>:<span class="identifier">block</span>]</span>;</span><br><span class="line">		&#125;);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!<span class="keyword">class</span><span class="constructor">_addMethod(<span class="params">self</span>, <span class="params">setter</span>, <span class="params">setterImplementation</span>, <span class="string">&quot;v@:@&quot;</span>)</span>) &#123;</span><br><span class="line">			<span class="constructor">NSCAssert(NO, @<span class="string">&quot;Could not implement setter for \&quot;%@\&quot; property.&quot;</span>, <span class="params">propertyName</span>)</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看下<strong><strong>implementMethod</strong></strong></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)implementMethod:(SEL)selector withBlock:(<span class="type">id</span>)block &#123;</span><br><span class="line">	<span class="type">BOOL</span> isClassMethod = <span class="keyword">self</span>.isClassProxy;</span><br><span class="line">	<span class="comment">//.......</span></span><br><span class="line">	<span class="keyword">struct</span> objc_method_description methodDescription = protocol_getMethodDescription(<span class="keyword">self</span>.protocol, selector, <span class="literal">YES</span>, !isClassMethod);</span><br><span class="line">	<span class="keyword">if</span> (!methodDescription.name) methodDescription = protocol_getMethodDescription(<span class="keyword">self</span>.protocol, selector, <span class="literal">NO</span>, !isClassMethod);</span><br><span class="line"></span><br><span class="line">	A2BlockInvocation *inv = <span class="literal">nil</span>;</span><br><span class="line">	<span class="keyword">if</span> (methodDescription.name) &#123;</span><br><span class="line">		<span class="built_in">NSMethodSignature</span> *protoSig = [<span class="built_in">NSMethodSignature</span> signatureWithObjCTypes:methodDescription.types];</span><br><span class="line">		inv = [[A2BlockInvocation alloc] initWithBlock:block methodSignature:protoSig];</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		inv = [[A2BlockInvocation alloc] initWithBlock:block];</span><br><span class="line">	&#125;</span><br><span class="line">	[<span class="keyword">self</span>.invocationsBySelectors bk_setObject:inv forSelector:selector];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里会新建一个A2BlockInvocation并将block 保存到 A2BlockInvocation中，并以selector为key A2BlockInvocation为value 存到self.invocationsBySelectors中。这样上一步就可以通过selector找到A2BlockInvocation进而找到关联的block了，这部分逻辑在<strong><strong>blockImplementationForMethod</strong></strong>中。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">id</span>)blockImplementationForMethod:(SEL)selector &#123;</span><br><span class="line">	A2BlockInvocation *invocation = <span class="literal">nil</span>;</span><br><span class="line">	<span class="keyword">if</span> ((invocation = [<span class="keyword">self</span>.invocationsBySelectors bk_objectForSelector:selector]))</span><br><span class="line">		<span class="keyword">return</span> invocation.block;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是你们想过没为什么要通过A2BlockInvocation而不是直接将block与selector关联？这其实涉及到下面这些部分，往分类添加的属性，这些属性分类中并没有设置它的getter方法和setter方法。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">setter</span> = bk_setCancelBlock:) <span class="type">void</span> (^bk_cancelBlock)(<span class="type">void</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">setter</span> = bk_setWillShowBlock:) <span class="type">void</span> (^bk_willShowBlock)(<span class="built_in">UIAlertView</span> *alertView);</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">setter</span> = bk_setDidShowBlock:) <span class="type">void</span> (^bk_didShowBlock)(<span class="built_in">UIAlertView</span> *alertView);</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">setter</span> = bk_setWillDismissBlock:) <span class="type">void</span> (^bk_willDismissBlock)(<span class="built_in">UIAlertView</span> *alertView, <span class="built_in">NSInteger</span> buttonIndex);</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">setter</span> = bk_setDidDismissBlock:) <span class="type">void</span> (^bk_didDismissBlock)(<span class="built_in">UIAlertView</span> *alertView, <span class="built_in">NSInteger</span> buttonIndex);</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">setter</span> = bk_SetShouldEnableFirstOtherButtonBlock:) <span class="type">BOOL</span> (^bk_shouldEnableFirstOtherButtonBlock)(<span class="built_in">UIAlertView</span> *alertView) <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">5</span>_0);</span><br></pre></td></tr></table></figure>

<p>这样做的目的就是为了通过消息分发机制来找到对应的block。</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@implementation</span> UIAlertView (BlocksKit)</span><br><span class="line"><span class="variable">@dynamic</span> bk_willShowBlock, bk_didShowBlock, bk_willDismissBlock, bk_didDismissBlock, bk_shouldEnableFirstOtherButtonBlock;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>整个分发过程在<strong><strong>A2BlockInvocation</strong></strong>类中。</p>
<p>到此为止整个流程已经结束，相关细节可以查看代码中的具体实现。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/iOS-%E5%BC%80%E6%BA%90%E5%BA%93%E5%88%86%E6%9E%90/">iOS 开源库分析</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/iOS-开源库分析/">iOS 开源库分析</a>
  </div>

</div>



<div class="comments-count">
	
	  	<span></span>
		<a href="/2019/11/26/BlocksKit-的使用/#comments" class="ds-thread-count comments-count-link" data-thread-key="2019/11/26/BlocksKit-的使用/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/11/24/MLeaksFinder-源码解析/" title="MLeaksFinder 源码解析" itemprop="url">MLeaksFinder 源码解析</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Edgar" target="_blank" itemprop="author">Edgar</a>
		
  <p class="article-time">
    <time datetime="2019-11-24T11:40:46.000Z" itemprop="datePublished"> Published 2019-11-24</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h5 id="1-开篇叨叨"><a href="#1-开篇叨叨" class="headerlink" title="1. 开篇叨叨"></a>1. 开篇叨叨</h5><p>在iOS内存优化总结那篇博客中提到过MLeaksFinder，并简要介绍了它的实现原理，这里主要从源码角度来看下MLeaksFinder是怎样做到内存泄漏检测的。</p>
<h5 id="2-代码结构与整体思路"><a href="#2-代码结构与整体思路" class="headerlink" title="2. 代码结构与整体思路"></a>2. 代码结构与整体思路</h5><p>我们先来看下整个源码的目录结构：</p>
<p><img src="/2019/11/24/MLeaksFinder-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/00001.png"></p>
<p>代码主要分成三类：</p>
<p><strong><strong>1. 各种对象的分类</strong></strong></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSObject</span>+MemoryLeak.h</span><br><span class="line"><span class="built_in">UIApplication</span>+MemoryLeak.h</span><br><span class="line"><span class="built_in">UINavigationController</span>+MemoryLeak.h</span><br><span class="line"><span class="built_in">UIPageViewController</span>+MemoryLeak.h</span><br><span class="line"><span class="built_in">UISplitViewController</span>+MemoryLeak.h</span><br><span class="line"><span class="built_in">UITabBarController</span>+MemoryLeak.h</span><br><span class="line"><span class="built_in">UITouch</span>+MemoryLeak.h</span><br><span class="line"><span class="built_in">UIView</span>+MemoryLeak.h</span><br><span class="line"><span class="built_in">UIViewController</span>+MemoryLeak.h</span><br></pre></td></tr></table></figure>
<p>这些分类主要完成触发对象回收方法的Hook,以及NSObject+MemoryLeak方法的覆盖。</p>
<p><strong><strong>2. MLeaksMessenger 发生泄漏时候的提醒执行对象</strong></strong></p>
<p><strong><strong>3. MLeakedObjectProxy 堆栈信息管理对象</strong></strong></p>
<p>再进一步往细地讲首先MemoryLeak分类会Hook对应触发回收的方法，一旦触发回收，就会递归地调用NSObject+MemoryLeak 中对应的willDealloc方法，再这个方法中会延迟2秒调用assertNotDealloc，如果这2秒内对象被销毁那么assertNotDealloc将不会被调用，否则将调用assertNotDealloc，在assertNotDealloc将会通过MLeakedObjectProxy构建泄漏堆栈，然后通过MLeaksMessenger发出泄漏提醒信息。</p>
<p>整个MLeaksFinder的代码量不是很大，顺着上面介绍的思路不会有太大理解上的问题：</p>
<h5 id="3-各个类的分类"><a href="#3-各个类的分类" class="headerlink" title="3. 各个类的分类"></a>3. 各个类的分类</h5><p>首先我们看下Hook部分。我们先来看下每个分类都Hook了哪些方法：</p>
<ul>
<li>NSObject+MemoryLeak 方法没有Hook任何方法，它只不过作为基类提供一些公共的方法。</li>
<li>UIApplication+MemoryLeak 方法,Hook了sendAction:to:from:forEvent:在这个方法中将sender存储起来，至于用来干啥用先卖个关子，后面介绍NSObject+MemoryLeak的时候介绍。</li>
<li>UINavigationController+MemoryLeak 主要是Hook了：</li>
</ul>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">pushViewController:</span>animated:</span><br><span class="line"><span class="symbol">popViewControllerAnimated:</span></span><br><span class="line"><span class="symbol">popToViewController:</span>animated:</span><br><span class="line"><span class="symbol">popToRootViewControllerAnimated:</span></span><br></pre></td></tr></table></figure>
<p>它的主要工作是对每个pop出来对ViewController调用willDealloc</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">BOOL</span>)willDealloc &#123;</span><br><span class="line">    <span class="keyword">if</span> (![<span class="variable language_">super</span> willDealloc]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="keyword">self</span> willReleaseChildren:<span class="keyword">self</span>.viewControllers];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>UIPageViewController+MemoryLeak，UISplitViewController+MemoryLeak，UITabBarController+MemoryLeak，UIView+MemoryLeak</li>
</ul>
<p>里面都只有一个方法,主要是对自己对子ViewController进行判断是否泄漏。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">BOOL</span>)willDealloc &#123;</span><br><span class="line">    <span class="keyword">if</span> (![<span class="variable language_">super</span> willDealloc]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="keyword">self</span> willReleaseChildren:<span class="keyword">self</span>.viewControllers];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>UITouch+MemoryLeak中只Hook了setView:方法在这里将view保存为sender</p>
</li>
<li><p>UIViewController+MemoryLeak Hook了</p>
</li>
</ul>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">viewDidDisappear:</span></span><br><span class="line"><span class="symbol">viewWillAppear:</span></span><br><span class="line"><span class="symbol">dismissViewControllerAnimated:</span>completion:</span><br></pre></td></tr></table></figure>

<p>并重写了：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">BOOL</span>)willDealloc &#123;</span><br><span class="line">    <span class="keyword">if</span> (![<span class="variable language_">super</span> willDealloc]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="keyword">self</span> willReleaseChildren:<span class="keyword">self</span>.childViewControllers];</span><br><span class="line">    [<span class="keyword">self</span> willReleaseChild:<span class="keyword">self</span>.presentedViewController];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.isViewLoaded) &#123;</span><br><span class="line">        [<span class="keyword">self</span> willReleaseChild:<span class="keyword">self</span>.view];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里对self.presentedViewController ，self.childViewControllers，self.view检测是否有泄漏。</p>
<h5 id="4-情景分析"><a href="#4-情景分析" class="headerlink" title="4. 情景分析"></a>4. 情景分析</h5><p>接下来我们以通过push进入一个界面到pop出来为情景看下MLeaksFinder是怎样检测内存泄漏的：</p>
<p>首先是push方法:</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)swizzled_pushViewController:(<span class="built_in">UIViewController</span> *)viewController animated:(<span class="type">BOOL</span>)animated &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.splitViewController) &#123;</span><br><span class="line">        <span class="type">id</span> detailViewController = objc_getAssociatedObject(<span class="keyword">self</span>, kPoppedDetailVCKey);</span><br><span class="line">        <span class="keyword">if</span> ([detailViewController isKindOfClass:[<span class="built_in">UIViewController</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">            [detailViewController willDealloc];</span><br><span class="line">            objc_setAssociatedObject(<span class="keyword">self</span>, kPoppedDetailVCKey, <span class="literal">nil</span>, OBJC_ASSOCIATION_RETAIN);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="keyword">self</span> swizzled_pushViewController:viewController animated:animated];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于普通的viewController self.splitViewController 为 nil所以这里实际上是没做什么工作，我们直接略过。</p>
<p>这时候UIViewController 将会被push进来这时候会调用viewWillAppear，由于viewWillAppear被Hook了，所以实际上调用的是：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)swizzled_viewWillAppear:(<span class="type">BOOL</span>)animated &#123;</span><br><span class="line">    [<span class="keyword">self</span> swizzled_viewWillAppear:animated];</span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, kHasBeenPoppedKey, @(<span class="literal">NO</span>), OBJC_ASSOCIATION_RETAIN);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里会将kHasBeenPoppedKey设置为NO,这个有什么作用我们往下看：</p>
<p>在我们pop UIViewController的时候会调用swizzled_popViewControllerAnimated</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">UIViewController</span> *)swizzled_popViewControllerAnimated:(<span class="type">BOOL</span>)animated &#123;</span><br><span class="line">    <span class="built_in">UIViewController</span> *poppedViewController = [<span class="keyword">self</span> swizzled_popViewControllerAnimated:animated];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// VC is not dealloced until disappear when popped using a left-edge swipe gesture</span></span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">const</span> <span class="type">void</span> *<span class="keyword">const</span> kHasBeenPoppedKey;</span><br><span class="line">    objc_setAssociatedObject(poppedViewController, kHasBeenPoppedKey, @(<span class="literal">YES</span>), OBJC_ASSOCIATION_RETAIN);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> poppedViewController;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在swizzled_popViewControllerAnimated方法中只是将kHasBeenPoppedKey设置为YES，但是并没调用willDealloc,这是因为在使用左边缘滑动关闭的时候，要等到UIViewController disappear的时候才开始销毁，所以这里只是设置一个标记延迟调用willDealloc。</p>
<p>在然后UIViewController的swizzled_viewDidDisappear会被调用，由于上面已经设置kHasBeenPoppedKey为YES,所以willDealloc就会被调用。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)swizzled_viewDidDisappear:(<span class="type">BOOL</span>)animated &#123;</span><br><span class="line">    [<span class="keyword">self</span> swizzled_viewDidDisappear:animated];</span><br><span class="line">    <span class="keyword">if</span> ([objc_getAssociatedObject(<span class="keyword">self</span>, kHasBeenPoppedKey) boolValue]) &#123;</span><br><span class="line">        [<span class="keyword">self</span> willDealloc];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">BOOL</span>)willDealloc &#123;</span><br><span class="line">    <span class="keyword">if</span> (![<span class="variable language_">super</span> willDealloc]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="keyword">self</span> willReleaseChildren:<span class="keyword">self</span>.childViewControllers];</span><br><span class="line">    [<span class="keyword">self</span> willReleaseChild:<span class="keyword">self</span>.presentedViewController];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.isViewLoaded) &#123;</span><br><span class="line">        [<span class="keyword">self</span> willReleaseChild:<span class="keyword">self</span>.view];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>willDealloc 中会先调用NSObject+MemoryLeak的willDealloc</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">BOOL</span>)willDealloc &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *className = <span class="built_in">NSStringFromClass</span>([<span class="keyword">self</span> <span class="keyword">class</span>]);</span><br><span class="line">    <span class="keyword">if</span> ([[<span class="built_in">NSObject</span> classNamesWhitelist] containsObject:className])</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSNumber</span> *senderPtr = objc_getAssociatedObject([<span class="built_in">UIApplication</span> sharedApplication], kLatestSenderKey);</span><br><span class="line">    <span class="keyword">if</span> ([senderPtr isEqualToNumber:@((uintptr_t)<span class="keyword">self</span>)])</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    </span><br><span class="line">    __<span class="keyword">weak</span> <span class="type">id</span> weakSelf = <span class="keyword">self</span>;</span><br><span class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">2</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        __<span class="keyword">strong</span> <span class="type">id</span> strongSelf = weakSelf;</span><br><span class="line">        [strongSelf assertNotDealloc];</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>NSObject+MemoryLeak的willDealloc 中会先判断当前类是否在白名单中。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">+ (<span class="built_in">NSMutableSet</span> *)classNamesWhitelist &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">NSMutableSet</span> *whitelist = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        whitelist = [<span class="built_in">NSMutableSet</span> setWithObjects:</span><br><span class="line">                     <span class="string">@&quot;UIFieldEditor&quot;</span>, <span class="comment">// UIAlertControllerTextField</span></span><br><span class="line">                     <span class="string">@&quot;UINavigationBar&quot;</span>,</span><br><span class="line">                     <span class="string">@&quot;_UIAlertControllerActionView&quot;</span>,</span><br><span class="line">                     <span class="string">@&quot;_UIVisualEffectBackdropView&quot;</span>,</span><br><span class="line">                     <span class="literal">nil</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// System&#x27;s bug since iOS 10 and not fixed yet up to this ci.</span></span><br><span class="line">        <span class="built_in">NSString</span> *systemVersion = [<span class="built_in">UIDevice</span> currentDevice].systemVersion;</span><br><span class="line">        <span class="keyword">if</span> ([systemVersion compare:<span class="string">@&quot;10.0&quot;</span> options:<span class="built_in">NSNumericSearch</span>] != <span class="built_in">NSOrderedAscending</span>) &#123;</span><br><span class="line">            [whitelist addObject:<span class="string">@&quot;UISwitch&quot;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> whitelist;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是说UIFieldEditor，UINavigationBar，_UIAlertControllerActionView，_UIAlertControllerActionView以及10.0以后的UISwitch都在白名单中，如果是这些对象将不做检查。</p>
<p>下一步:</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSNumber</span> *senderPtr = objc_getAssociatedObject([<span class="built_in">UIApplication</span> sharedApplication], kLatestSenderKey);</span><br><span class="line">    <span class="keyword">if</span> ([senderPtr isEqualToNumber:@((uintptr_t)<span class="keyword">self</span>)])</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br></pre></td></tr></table></figure>

<p>是否还记得在讲UIApplication+MemoryLeak中的Hook的时候有讲到UIApplication+MemoryLeak会将当前sender保存起来，这里就得提一下iOS 的 Target-Action机制了。当一个事件发生的时候，UIControl会调用sendAction:to:forEvent:将行为消息转发到UIApplication对象，再由UIApplication对象调用其sendAction:to:fromSender:forEvent:方法来将消息分发到指定的target上，而如果我们没有指定target，则会将事件分发到响应链上第一个想处理消息的对象上。而如果子类想监控或修改这种行为的话，则可以重写这个方法。在UIApplication+MemoryLeak将最近正在执行的sender存储起来就是为了在这个地方与self进行对比，也就是说如果当前对象正在执行action那么就不再对该对象进行内存检测。否则就会延迟两秒调用assertNotDealloc方法。</p>
<p>假设发生了内存泄漏，当前对象没有被释放，那么assertNotDealloc将会被调用：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="operator">-</span> (void)assertNotDealloc &#123;</span><br><span class="line">    <span class="keyword">if</span> ([<span class="type">MLeakedObjectProxy</span> isAnyObjectLeakedAtPtrs:[<span class="keyword">self</span> parentPtrs]]) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="type">MLeakedObjectProxy</span> addLeakedObject:<span class="keyword">self</span>];</span><br><span class="line">    <span class="type">NSString</span> <span class="operator">*</span>className <span class="operator">=</span> <span class="type">NSStringFromClass</span>([<span class="keyword">self</span> <span class="keyword">class</span>]);</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">&quot;Possibly Memory Leak.<span class="subst">\n</span>In case that %@ should not be dealloced, override -willDealloc in %@ by returning NO.<span class="subst">\n</span>View-ViewController stack: %@&quot;</span>, className, className, [<span class="keyword">self</span> viewStack]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在assertNotDealloc中将会检查是否已经在泄漏名单中了，如果已经在了就不再添加直接放回，如果不在那么就调用addLeakedObject将当前对象添加到泄漏名单。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">+ (<span class="type">BOOL</span>)isAnyObjectLeakedAtPtrs:(<span class="built_in">NSSet</span> *)ptrs &#123;</span><br><span class="line">    <span class="built_in">NSAssert</span>([<span class="built_in">NSThread</span> isMainThread], <span class="string">@&quot;Must be in main thread.&quot;</span>);</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        leakedObjectPtrs = [[<span class="built_in">NSMutableSet</span> alloc] init];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">if</span> (!ptrs.count) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ([leakedObjectPtrs intersectsSet:ptrs]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>紧接着就会通过MLeaksMessenger 弹出弹窗提示用户泄漏堆栈：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>)addLeakedObject:(id)<span class="built_in">object</span> &#123;</span><br><span class="line">    NSAssert([NSThread isMainThread], <span class="string">@&quot;Must be in main thread.&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    MLeakedObjectProxy *proxy = [[MLeakedObjectProxy alloc] <span class="keyword">init</span>];</span><br><span class="line">    proxy.<span class="built_in">object</span> = <span class="built_in">object</span>;</span><br><span class="line">    proxy.objectPtr = @((uintptr_t)<span class="built_in">object</span>);</span><br><span class="line">    proxy.viewStack = [<span class="built_in">object</span> viewStack];</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">void</span> *<span class="keyword">const</span> kLeakedObjectProxyKey = &amp;kLeakedObjectProxyKey;</span><br><span class="line">    objc_setAssociatedObject(<span class="built_in">object</span>, kLeakedObjectProxyKey, proxy, OBJC_ASSOCIATION_RETAIN);</span><br><span class="line">    </span><br><span class="line">    [<span class="meta">leakedObjectPtrs addObject:proxy.objectPtr</span>];</span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="keyword">if</span> _INTERNAL_MLF_RC_ENABLED</span></span><br><span class="line">    [<span class="meta">MLeaksMessenger alertWithTitle:@<span class="string">&quot;Memory Leak&quot;</span></span></span><br><span class="line"><span class="meta">                            message:[NSString stringWithFormat:@<span class="string">&quot;%@&quot;</span>, proxy.viewStack</span>]</span><br><span class="line">                           <span class="built_in">delegate</span>:proxy</span><br><span class="line">              additionalButtonTitle:<span class="string">@&quot;Retain Cycle&quot;</span>];</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    [<span class="meta">MLeaksMessenger alertWithTitle:@<span class="string">&quot;Memory Leak&quot;</span></span></span><br><span class="line"><span class="meta">                            message:[NSString stringWithFormat:@<span class="string">&quot;%@&quot;</span>, proxy.viewStack</span>]];</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们点击弹窗上的按钮查看具体的循环引用信息那么将会调用下面的方法：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)alertView:(<span class="built_in">UIAlertView</span> *)alertView clickedButtonAtIndex:(<span class="built_in">NSInteger</span>)buttonIndex &#123;</span><br><span class="line">    <span class="keyword">if</span> (!buttonIndex) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">id</span> object = <span class="keyword">self</span>.object;</span><br><span class="line">    <span class="keyword">if</span> (!object) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="keyword">if</span> _INTERNAL_MLF_RC_ENABLED</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">        FBRetainCycleDetector *detector = [FBRetainCycleDetector new];</span><br><span class="line">        [detector addCandidate:<span class="keyword">self</span>.object];</span><br><span class="line">        <span class="built_in">NSSet</span> *retainCycles = [detector findRetainCyclesWithMaxCycleLength:<span class="number">20</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="type">BOOL</span> hasFound = <span class="literal">NO</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSArray</span> *retainCycle <span class="keyword">in</span> retainCycles) &#123;</span><br><span class="line">            <span class="built_in">NSInteger</span> index = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (FBObjectiveCGraphElement *element <span class="keyword">in</span> retainCycle) &#123;</span><br><span class="line">                <span class="keyword">if</span> (element.object == object) &#123;</span><br><span class="line">                    <span class="built_in">NSArray</span> *shiftedRetainCycle = [<span class="keyword">self</span> shiftArray:retainCycle toIndex:index];</span><br><span class="line">                    </span><br><span class="line">                    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                        [MLeaksMessenger alertWithTitle:<span class="string">@&quot;Retain Cycle&quot;</span></span><br><span class="line">                                                message:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;%@&quot;</span>, shiftedRetainCycle]];</span><br><span class="line">                    &#125;);</span><br><span class="line">                    hasFound = <span class="literal">YES</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                ++index;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (hasFound) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!hasFound) &#123;</span><br><span class="line">            <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                [MLeaksMessenger alertWithTitle:<span class="string">@&quot;Retain Cycle&quot;</span></span><br><span class="line">                                        message:<span class="string">@&quot;Fail to find a retain cycle&quot;</span>];</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在alertView方法中对通过FBRetainCycleDetector来检测循环引用，然后通过弹窗进行展示，这部分将会在FBRetainCycleDetector源码解析中进行详细介绍。</p>
<p>除了对UIViewController 自身调用willDealloc还需要对当前UIViewController的self.presentedViewController，self.childViewControllers以及self.view调用willDealloc判断是否有泄漏发生。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">BOOL</span>)willDealloc &#123;</span><br><span class="line">    <span class="keyword">if</span> (![<span class="variable language_">super</span> willDealloc]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="keyword">self</span> willReleaseChildren:<span class="keyword">self</span>.childViewControllers];</span><br><span class="line">    [<span class="keyword">self</span> willReleaseChild:<span class="keyword">self</span>.presentedViewController];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.isViewLoaded) &#123;</span><br><span class="line">        [<span class="keyword">self</span> willReleaseChild:<span class="keyword">self</span>.view];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果某个对象被检测到2秒内还没被释放，但是在2秒之后还是调用了dealloc释放了，那么这种不算是内存泄漏，所以会弹出Object Deallocated提示该对象已经被释放了，不属于内存泄漏。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)dealloc &#123;</span><br><span class="line">    <span class="built_in">NSNumber</span> *objectPtr = _objectPtr;</span><br><span class="line">    <span class="built_in">NSArray</span> *viewStack = _viewStack;</span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        [leakedObjectPtrs removeObject:objectPtr];</span><br><span class="line">        [MLeaksMessenger alertWithTitle:<span class="string">@&quot;Object Deallocated&quot;</span></span><br><span class="line">                                message:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;%@&quot;</span>, viewStack]];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>














        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/%E5%BC%80%E6%BA%90%E5%BA%93%E5%88%86%E6%9E%90/">开源库分析</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/开源库分析/">开源库分析</a>
  </div>

</div>



<div class="comments-count">
	
	  	<span></span>
		<a href="/2019/11/24/MLeaksFinder-源码解析/#comments" class="ds-thread-count comments-count-link" data-thread-key="2019/11/24/MLeaksFinder-源码解析/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/11/24/PromiseKit-的使用/" title="PromiseKit 的使用" itemprop="url">PromiseKit 的使用</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Edgar" target="_blank" itemprop="author">Edgar</a>
		
  <p class="article-time">
    <time datetime="2019-11-23T18:15:12.000Z" itemprop="datePublished"> Published 2019-11-24</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h4 id="开源库资料"><a href="#开源库资料" class="headerlink" title="开源库资料"></a>开源库资料</h4><p><img src="/2019/11/24/PromiseKit-%E7%9A%84%E4%BD%BF%E7%94%A8/00001.png"></p>
<p><a target="_blank" rel="noopener" href="https://github.com/mxcl/PromiseKit">源码地址</a></p>
<p>接触过Web前端开发的同学一定知道Promise这个东西，Promise其实就是一个封装着异步操作的一个对象，它可以通过resolve以及reject来控制整个分支的流程。个人理解这个就相当于一个没有办法立即给予答复的承诺，只知道这个地方会在恰当的时机会得到一个答复，至于什么时候得到怎样的答复，新建promise的时候并不确定。</p>
<p>下面是官方给出的一个定义：</p>
<blockquote>
<p>A promise represents the future value of a task.</p>
</blockquote>
<p>每个Promises都有一个状态，新建的每个Promises都处于pending状态，而后会转到resolve状态，resolve状态可以是fulfilled 或者 rejected ，如果是rejected 则会收到一个NSError，如果是fulfilled将会收到任何形式的对象。这个具体放在下面介绍。</p>
<p>下面的使用是基于PromiseKit 6.11.0 版本，可以通过下面的pod 方式导入：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">use_frameworks</span>!</span><br><span class="line"><span class="attribute">pod</span> &#x27;PromiseKit&#x27;, &#x27;~&gt; <span class="number">6</span>.<span class="number">11</span>.<span class="number">0</span>&#x27;</span><br></pre></td></tr></table></figure>

<h4 id="一个简单的例子："><a href="#一个简单的例子：" class="headerlink" title="一个简单的例子："></a>一个简单的例子：</h4><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">self</span> promise_registerWithName:<span class="string">@&quot;linxiaohai&quot;</span>].then(^(<span class="built_in">NSString</span> *userName)&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;Regist Successfull %@ !!!&quot;</span>,userName);</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> promise_loginWithName:userName];</span><br><span class="line">&#125;).then(^(<span class="built_in">NSString</span> *userName) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;Login Successfull %@ !!!&quot;</span>,userName);</span><br><span class="line">&#125;).catch(^()&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;Login Failed !!!&quot;</span>);</span><br><span class="line">&#125;).finally(^()&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;Finally !!!&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">- (PMKPromise *)promise_registerWithName:(<span class="built_in">NSString</span> *)userName &#123;</span><br><span class="line">    <span class="keyword">return</span> [PMKPromise promiseWithAdapter:^(PMKAdapter adapter) &#123;</span><br><span class="line">        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">10</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            adapter(userName,<span class="literal">nil</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (PMKPromise *)promise_loginWithName:(<span class="built_in">NSString</span> *)userName &#123;</span><br><span class="line">    <span class="keyword">return</span> [PMKPromise promiseWithAdapter:^(PMKAdapter adapter) &#123;</span><br><span class="line">        adapter(userName,<span class="literal">nil</span>);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果我们没有使用PromiseKit那么我们会在注册成功的block里面嵌套调用登录的请求，如果一个流程只是这两步还可以容忍，但是如果超过三步整个代码就会显得非常乱。因此如果在实际项目中遇到一个请求依赖上一个请求成功后才发起请求，也就是存在链式请求的话就可以考虑使用PromiseKit来规避Callback Hell.</p>
<h4 id="PromiseKit的创建："><a href="#PromiseKit的创建：" class="headerlink" title="PromiseKit的创建："></a>PromiseKit的创建：</h4><figure class="highlight elm"><table><tr><td class="code"><pre><span class="line">+ (instance<span class="keyword">type</span>)promiseWithValue:(id)value </span><br></pre></td></tr></table></figure>
<p>将某个值封装成Promise返回</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-attr">[AnyPromise promiseWithValue:@<span class="string">&quot;linxiaohai&quot;</span>]</span><span class="selector-class">.then</span>(^(id value)&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(@&quot;%@&quot;,value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>


<figure class="highlight elm"><table><tr><td class="code"><pre><span class="line">+ (instance<span class="keyword">type</span>)promiseWithResolverBlock:(void (^)(<span class="type">PMKResolver</span> _Nonnull))resolveBlock</span><br></pre></td></tr></table></figure>

<p>当我们想将我们的非Promise异步代码添加到Promise链中的时候就可以使用上面这种方式来封装（需要注意的是这个方法仅仅适用于非Promise异步代码）这里的PMKResolver block参数是id类型，如果传入的是非NSError类型的话那么就会走到then流程，如果是NSError类型的话就会走catch流程。经过封装后的异步代码就可以使用then来链式调用了。下面是一个非常简单的一个例子：</p>
<figure class="highlight wren"><table><tr><td class="code"><pre><span class="line">[<span class="title class_">AnyPromise</span> <span class="variable">promiseWithResolverBlock</span>:<span class="title function_">^</span>(<span class="params">PMKResolver</span> _<span class="params">Nonnull</span> <span class="params">resolver</span>) &#123;</span><br><span class="line">    <span class="title function_">dispatch_after</span>(<span class="title function_">dispatch_time</span>(<span class="variable">DISPATCH_TIME_NOW</span>, (int64_t)(<span class="number">10</span> <span class="operator">*</span> <span class="variable">NSEC_PER_SEC</span>)), <span class="title function_">dispatch_get_main_queue</span>(), <span class="operator">^</span>&#123;</span><br><span class="line">        <span class="title function_">resolver</span>(@<span class="string">&quot;linxiaohai&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;].<span class="property">then</span>(<span class="title function_">^</span>(<span class="params">id</span> <span class="params">value</span>)&#123;</span><br><span class="line">    <span class="title class_">NSLog</span>(@<span class="string">&quot;%@&quot;</span>,<span class="variable">value</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>下面是使用PMKAdapter来包装异步请求</p>
<figure class="highlight elm"><table><tr><td class="code"><pre><span class="line">+ (instance<span class="keyword">type</span>)promiseWithAdapter:(void (^)(<span class="type">PMKAdapter</span> adapter))block;</span><br><span class="line">+ (instance<span class="keyword">type</span>)promiseWithIntegerAdapter:(void (^)(<span class="type">PMKIntegerAdapter</span> adapter))block;</span><br><span class="line">+ (instance<span class="keyword">type</span>)promiseWithBooleanAdapter:(void (^)(<span class="type">PMKBooleanAdapter</span> adapter))block;</span><br></pre></td></tr></table></figure>

<p>PMKAdapter Block有两个参数，第一个参数是id类型，第二个参数是NSError类型：</p>
<figure class="highlight elm"><table><tr><td class="code"><pre><span class="line">typedef void (^<span class="type">PMKAdapter</span>)(id, <span class="type">NSError</span> *);</span><br></pre></td></tr></table></figure>

<p>具体走哪个流程取决于两个值的情况，可以参照下表：</p>
<p><img src="/2019/11/24/PromiseKit-%E7%9A%84%E4%BD%BF%E7%94%A8/00002.png"></p>
<p>下面是一个例子：</p>
<figure class="highlight wren"><table><tr><td class="code"><pre><span class="line">[<span class="title class_">AnyPromise</span> <span class="variable">promiseWithAdapterBlock</span>:<span class="title function_">^</span>(<span class="params">PMKAdapter</span>  _<span class="params">Nonnull</span> <span class="params">adapter</span>) &#123;</span><br><span class="line">    <span class="title function_">dispatch_after</span>(<span class="title function_">dispatch_time</span>(<span class="variable">DISPATCH_TIME_NOW</span>, (int64_t)(<span class="number">10</span> <span class="operator">*</span> <span class="variable">NSEC_PER_SEC</span>)), <span class="title function_">dispatch_get_main_queue</span>(), <span class="operator">^</span>&#123;</span><br><span class="line">        <span class="title function_">adapter</span>(@<span class="string">&quot;linxiaohai&quot;</span>,[<span class="title class_">NSError</span> <span class="variable">errorWithDomain</span>:@<span class="string">&quot;test&quot;</span> <span class="variable">code</span>:<span class="number">100</span> <span class="variable">userInfo</span>:<span class="variable">nil</span>]);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;].<span class="property">then</span>(<span class="title function_">^</span>(<span class="params">id</span> <span class="params">value</span>)&#123;</span><br><span class="line">    <span class="title class_">NSLog</span>(@<span class="string">&quot;%@&quot;</span>,<span class="variable">value</span>);</span><br><span class="line">&#125;).<span class="property">catch</span>(<span class="title function_">^</span>(<span class="params">NSError</span> *<span class="params">error</span>)&#123;</span><br><span class="line">    <span class="title class_">NSLog</span>(@<span class="string">&quot;%@&quot;</span>,<span class="variable">error</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>


<h4 id="PMKWhen"><a href="#PMKWhen" class="headerlink" title="PMKWhen:"></a>PMKWhen:</h4><p>PMKWhen的参数是一个Promise数组,或者字典，它会等待所有的Promise执行结束，或者有一个Error发生，也就是说如果这些异步的Promise都没有Error的时候，会等到都Resolve后才执行then，并且then Block 传递回来的是各个Promise执行的结果，如果中途有Error发生就会中断，并且走到catch流程。下面是一个简单例子：</p>
<figure class="highlight erlang"><table><tr><td class="code"><pre><span class="line">- <span class="params">(void)</span>onCreate &#123;</span><br><span class="line">    [super onCreate];</span><br><span class="line">    </span><br><span class="line">    PMKWhen<span class="params">(@[[self promise_delay_1s],[self promise_delay_error],[self promise_delay_3s],[self promise_delay_8s]])</span>.then(^(id value)&#123;</span><br><span class="line">        NSLog(@<span class="string">&quot;PMKWhen %@&quot;</span>,value);</span><br><span class="line">    &#125;).<span class="keyword">catch</span>(^(NSError *error)&#123;</span><br><span class="line">        NSLog(@<span class="string">&quot;PMKWhen %@&quot;</span>,error);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- <span class="params">(AnyPromise *)</span>promise_delay_1s &#123;</span><br><span class="line">    return [AnyPromise promiseWithResolverBlock:^<span class="params">(PMKResolver resolver)</span> &#123;</span><br><span class="line">        dispatch_after<span class="params">(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">1</span> * NSEC_PER_SEC)</span>), dispatch_get_main_queue<span class="params">()</span>, ^&#123;</span><br><span class="line">            NSLog<span class="params">(@<span class="string">&quot;PMKWhen promise_delay_1s&quot;</span>)</span>;</span><br><span class="line">            resolver<span class="params">(@<span class="string">&quot;PMKWhen promise_delay_1s&quot;</span>)</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- <span class="params">(AnyPromise *)</span>promise_delay_3s &#123;</span><br><span class="line">    return [AnyPromise promiseWithResolverBlock:^<span class="params">(PMKResolver resolver)</span> &#123;</span><br><span class="line">        dispatch_after<span class="params">(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">3</span> * NSEC_PER_SEC)</span>), dispatch_get_main_queue<span class="params">()</span>, ^&#123;</span><br><span class="line">            NSLog<span class="params">(@<span class="string">&quot;PMKWhen promise_delay_3s&quot;</span>)</span>;</span><br><span class="line">            resolver<span class="params">(@<span class="string">&quot;PMKWhen promise_delay_3s&quot;</span>)</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- <span class="params">(AnyPromise *)</span>promise_delay_8s &#123;</span><br><span class="line">    return [AnyPromise promiseWithResolverBlock:^<span class="params">(PMKResolver resolver)</span> &#123;</span><br><span class="line">        dispatch_after<span class="params">(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">8</span> * NSEC_PER_SEC)</span>), dispatch_get_main_queue<span class="params">()</span>, ^&#123;</span><br><span class="line">            NSLog<span class="params">(@<span class="string">&quot;PMKWhen promise_delay_8s&quot;</span>)</span>;</span><br><span class="line">            resolver<span class="params">(@<span class="string">&quot;PMKWhen promise_delay_3s&quot;</span>)</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- <span class="params">(AnyPromise *)</span>promise_delay_error &#123;</span><br><span class="line">    return [AnyPromise promiseWithResolverBlock:^<span class="params">(PMKResolver resolver)</span> &#123;</span><br><span class="line">        dispatch_after<span class="params">(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">6</span> * NSEC_PER_SEC)</span>), dispatch_get_main_queue<span class="params">()</span>, ^&#123;</span><br><span class="line">            NSLog<span class="params">(@<span class="string">&quot;PMKWhen promise_delay_error&quot;</span>)</span>;</span><br><span class="line">            resolver<span class="params">([NSError errorWithDomain:@<span class="string">&quot;test&quot;</span> code:<span class="number">100</span> userInfo:nil])</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">2019</span>-<span class="number">11</span>-<span class="number">04</span> <span class="number">14</span>:<span class="number">19</span>:<span class="number">46</span>.<span class="number">896521</span>+<span class="number">0800</span> IDLFundationTest[<span class="number">91339</span>:<span class="number">11794858</span>] PMKWhen promise_delay_1s</span><br><span class="line"><span class="attribute">2019</span>-<span class="number">11</span>-<span class="number">04</span> <span class="number">14</span>:<span class="number">19</span>:<span class="number">48</span>.<span class="number">994048</span>+<span class="number">0800</span> IDLFundationTest[<span class="number">91339</span>:<span class="number">11794858</span>] PMKWhen promise_delay_3s</span><br><span class="line"><span class="attribute">2019</span>-<span class="number">11</span>-<span class="number">04</span> <span class="number">14</span>:<span class="number">19</span>:<span class="number">52</span>.<span class="number">477392</span>+<span class="number">0800</span> IDLFundationTest[<span class="number">91339</span>:<span class="number">11794858</span>] PMKWhen promise_delay_error</span><br><span class="line"><span class="attribute">2019</span>-<span class="number">11</span>-<span class="number">04</span> <span class="number">14</span>:<span class="number">19</span>:<span class="number">52</span>.<span class="number">477859</span>+<span class="number">0800</span> IDLFundationTest[<span class="number">91339</span>:<span class="number">11794858</span>] PMKWhen Error Domain=test Code=<span class="number">100</span> <span class="string">&quot;(null)&quot;</span> UserInfo=&#123;NSUnderlyingError=<span class="number">0</span>x600000c64450 &#123;Error Domain=test Code=<span class="number">100</span> <span class="string">&quot;(null)&quot;</span>&#125;, PMKFailingPromiseIndexKey=<span class="number">0</span>&#125;</span><br><span class="line"><span class="attribute">2019</span>-<span class="number">11</span>-<span class="number">04</span> <span class="number">14</span>:<span class="number">19</span>:<span class="number">54</span>.<span class="number">694791</span>+<span class="number">0800</span> IDLFundationTest[<span class="number">91339</span>:<span class="number">11794858</span>] PMKWhen promise_delay_8s</span><br></pre></td></tr></table></figure>

<p>这里需要注意的是6s发生错误之后走catch分支，之后就不再走then分支了，但是error发生之后promise_delay_8s还会继续进行，并不会中止。</p>
<h4 id="PMKJoin"><a href="#PMKJoin" class="headerlink" title="PMKJoin"></a>PMKJoin</h4><p>这个和PMKWhen有类似的地方，就是接受的参数是字典或者数组，但是它会等待所有的Promise都解决后才走then或者catch分支，不像PMKWhen那样一旦有错误发生就catch，下面是一个例子可以对比下：</p>
<figure class="highlight erlang"><table><tr><td class="code"><pre><span class="line">- <span class="params">(void)</span>onCreate &#123;</span><br><span class="line">    [super onCreate];</span><br><span class="line">    </span><br><span class="line">    PMKJoin<span class="params">(@[[self promise_delay_1s],[self promise_delay_error],[self promise_delay_3s],[self promise_delay_8s]])</span>.then(^(id value)&#123;</span><br><span class="line">        NSLog(@<span class="string">&quot;PMKWhen %@&quot;</span>,value);</span><br><span class="line">    &#125;).<span class="keyword">catch</span>(^(NSError *error)&#123;</span><br><span class="line">        NSLog(@<span class="string">&quot;PMKWhen %@&quot;</span>,error);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- <span class="params">(AnyPromise *)</span>promise_delay_1s &#123;</span><br><span class="line">    return [AnyPromise promiseWithResolverBlock:^<span class="params">(PMKResolver resolver)</span> &#123;</span><br><span class="line">        dispatch_after<span class="params">(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">1</span> * NSEC_PER_SEC)</span>), dispatch_get_main_queue<span class="params">()</span>, ^&#123;</span><br><span class="line">            NSLog<span class="params">(@<span class="string">&quot;PMKWhen promise_delay_1s&quot;</span>)</span>;</span><br><span class="line">            resolver<span class="params">(@<span class="string">&quot;PMKWhen promise_delay_1s&quot;</span>)</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- <span class="params">(AnyPromise *)</span>promise_delay_3s &#123;</span><br><span class="line">    return [AnyPromise promiseWithResolverBlock:^<span class="params">(PMKResolver resolver)</span> &#123;</span><br><span class="line">        dispatch_after<span class="params">(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">3</span> * NSEC_PER_SEC)</span>), dispatch_get_main_queue<span class="params">()</span>, ^&#123;</span><br><span class="line">            NSLog<span class="params">(@<span class="string">&quot;PMKWhen promise_delay_3s&quot;</span>)</span>;</span><br><span class="line">            resolver<span class="params">(@<span class="string">&quot;PMKWhen promise_delay_3s&quot;</span>)</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- <span class="params">(AnyPromise *)</span>promise_delay_8s &#123;</span><br><span class="line">    return [AnyPromise promiseWithResolverBlock:^<span class="params">(PMKResolver resolver)</span> &#123;</span><br><span class="line">        dispatch_after<span class="params">(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">8</span> * NSEC_PER_SEC)</span>), dispatch_get_main_queue<span class="params">()</span>, ^&#123;</span><br><span class="line">            NSLog<span class="params">(@<span class="string">&quot;PMKWhen promise_delay_8s&quot;</span>)</span>;</span><br><span class="line">            resolver<span class="params">(@<span class="string">&quot;PMKWhen promise_delay_8s&quot;</span>)</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- <span class="params">(AnyPromise *)</span>promise_delay_error &#123;</span><br><span class="line">    return [AnyPromise promiseWithResolverBlock:^<span class="params">(PMKResolver resolver)</span> &#123;</span><br><span class="line">        dispatch_after<span class="params">(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">6</span> * NSEC_PER_SEC)</span>), dispatch_get_main_queue<span class="params">()</span>, ^&#123;</span><br><span class="line">            NSLog<span class="params">(@<span class="string">&quot;PMKWhen promise_delay_error&quot;</span>)</span>;</span><br><span class="line">            resolver<span class="params">([NSError errorWithDomain:@<span class="string">&quot;test&quot;</span> code:<span class="number">100</span> userInfo:nil])</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是执行的结果：</p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line"><span class="number">2019-11-04</span> <span class="number">14</span>:<span class="number">23</span>:<span class="number">53.419624</span>+<span class="number">0800</span> IDLFundationTest[<span class="number">94348</span>:<span class="number">11805962</span>] PMKWhen promise_delay_1s</span><br><span class="line"><span class="number">2019-11-04</span> <span class="number">14</span>:<span class="number">23</span>:<span class="number">55.419830</span>+<span class="number">0800</span> IDLFundationTest[<span class="number">94348</span>:<span class="number">11805962</span>] PMKWhen promise_delay_3s</span><br><span class="line"><span class="number">2019-11-04</span> <span class="number">14</span>:<span class="number">23</span>:<span class="number">59.018698</span>+<span class="number">0800</span> IDLFundationTest[<span class="number">94348</span>:<span class="number">11805962</span>] PMKWhen promise_delay_error</span><br><span class="line"><span class="number">2019-11-04</span> <span class="number">14</span>:<span class="number">24:01.218821</span>+<span class="number">0800</span> IDLFundationTest[<span class="number">94348</span>:<span class="number">11805962</span>] PMKWhen promise_delay_8s</span><br><span class="line"><span class="number">2019-11-04</span> <span class="number">14</span>:<span class="number">24:01.221100</span>+<span class="number">0800</span> IDLFundationTest[<span class="number">94348</span>:<span class="number">11805962</span>] PMKWhen Error Domain=PMKErrorDomain Code=<span class="number">10</span> &quot;(null)&quot; UserInfo=&#123;PMKJoinPromisesKey=(</span><br><span class="line">    &quot;AnyPromise(PMKWhen promise_delay_1s)&quot;,</span><br><span class="line">    &quot;AnyPromise(PMKWhen promise_delay_3s)&quot;,</span><br><span class="line">    &quot;AnyPromise(PMKWhen promise_delay_8s)&quot;</span><br></pre></td></tr></table></figure>

<p>可以看出catch是在全部Promise完成后执行的，并且在UserInfo中可以看出哪些是成功的Promise.</p>
<h4 id="PMKRace"><a href="#PMKRace" class="headerlink" title="PMKRace"></a>PMKRace</h4><p>PMKRace 会在第一个resolve(不论是fullfill还是reject)的时候执行then或者catch。</p>
<figure class="highlight erlang"><table><tr><td class="code"><pre><span class="line">- <span class="params">(void)</span>onCreate &#123;</span><br><span class="line">    [super onCreate];</span><br><span class="line">    </span><br><span class="line">    PMKRace<span class="params">(@[[self promise_delay_1s],[self promise_delay_error],[self promise_delay_3s],[self promise_delay_8s]])</span>.then(^(id value)&#123;</span><br><span class="line">        NSLog(@<span class="string">&quot;PMKWhen %@&quot;</span>,value);</span><br><span class="line">    &#125;).<span class="keyword">catch</span>(^(NSError *error)&#123;</span><br><span class="line">        NSLog(@<span class="string">&quot;PMKWhen %@&quot;</span>,error);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- <span class="params">(AnyPromise *)</span>promise_delay_1s &#123;</span><br><span class="line">    return [AnyPromise promiseWithResolverBlock:^<span class="params">(PMKResolver resolver)</span> &#123;</span><br><span class="line">        dispatch_after<span class="params">(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">1</span> * NSEC_PER_SEC)</span>), dispatch_get_main_queue<span class="params">()</span>, ^&#123;</span><br><span class="line">            NSLog<span class="params">(@<span class="string">&quot;PMKWhen promise_delay_1s&quot;</span>)</span>;</span><br><span class="line">            resolver<span class="params">(@<span class="string">&quot;PMKWhen promise_delay_1s&quot;</span>)</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- <span class="params">(AnyPromise *)</span>promise_delay_3s &#123;</span><br><span class="line">    return [AnyPromise promiseWithResolverBlock:^<span class="params">(PMKResolver resolver)</span> &#123;</span><br><span class="line">        dispatch_after<span class="params">(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">3</span> * NSEC_PER_SEC)</span>), dispatch_get_main_queue<span class="params">()</span>, ^&#123;</span><br><span class="line">            NSLog<span class="params">(@<span class="string">&quot;PMKWhen promise_delay_3s&quot;</span>)</span>;</span><br><span class="line">            resolver<span class="params">(@<span class="string">&quot;PMKWhen promise_delay_3s&quot;</span>)</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- <span class="params">(AnyPromise *)</span>promise_delay_8s &#123;</span><br><span class="line">    return [AnyPromise promiseWithResolverBlock:^<span class="params">(PMKResolver resolver)</span> &#123;</span><br><span class="line">        dispatch_after<span class="params">(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">8</span> * NSEC_PER_SEC)</span>), dispatch_get_main_queue<span class="params">()</span>, ^&#123;</span><br><span class="line">            NSLog<span class="params">(@<span class="string">&quot;PMKWhen promise_delay_8s&quot;</span>)</span>;</span><br><span class="line">            resolver<span class="params">(@<span class="string">&quot;PMKWhen promise_delay_8s&quot;</span>)</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- <span class="params">(AnyPromise *)</span>promise_delay_error &#123;</span><br><span class="line">    return [AnyPromise promiseWithResolverBlock:^<span class="params">(PMKResolver resolver)</span> &#123;</span><br><span class="line">        dispatch_after<span class="params">(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">6</span> * NSEC_PER_SEC)</span>), dispatch_get_main_queue<span class="params">()</span>, ^&#123;</span><br><span class="line">            NSLog<span class="params">(@<span class="string">&quot;PMKWhen promise_delay_error&quot;</span>)</span>;</span><br><span class="line">            resolver<span class="params">([NSError errorWithDomain:@<span class="string">&quot;test&quot;</span> code:<span class="number">100</span> userInfo:nil])</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是执行结果：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">2019</span>-<span class="number">11</span>-<span class="number">04</span> <span class="number">14</span>:<span class="number">34</span>:<span class="number">06</span>.<span class="number">333085</span>+<span class="number">0800</span> IDLFundationTest[<span class="number">2020</span>:<span class="number">11831274</span>] PMKWhen promise_delay_1s</span><br><span class="line"><span class="attribute">2019</span>-<span class="number">11</span>-<span class="number">04</span> <span class="number">14</span>:<span class="number">34</span>:<span class="number">06</span>.<span class="number">333917</span>+<span class="number">0800</span> IDLFundationTest[<span class="number">2020</span>:<span class="number">11831274</span>] PMKWhen PMKWhen promise_delay_1s</span><br><span class="line"><span class="attribute">2019</span>-<span class="number">11</span>-<span class="number">04</span> <span class="number">14</span>:<span class="number">34</span>:<span class="number">08</span>.<span class="number">532678</span>+<span class="number">0800</span> IDLFundationTest[<span class="number">2020</span>:<span class="number">11831274</span>] PMKWhen promise_delay_3s</span><br><span class="line"><span class="attribute">2019</span>-<span class="number">11</span>-<span class="number">04</span> <span class="number">14</span>:<span class="number">34</span>:<span class="number">11</span>.<span class="number">834737</span>+<span class="number">0800</span> IDLFundationTest[<span class="number">2020</span>:<span class="number">11831274</span>] PMKWhen promise_delay_error</span><br><span class="line"><span class="attribute">2019</span>-<span class="number">11</span>-<span class="number">04</span> <span class="number">14</span>:<span class="number">34</span>:<span class="number">14</span>.<span class="number">034667</span>+<span class="number">0800</span> IDLFundationTest[<span class="number">2020</span>:<span class="number">11831274</span>] PMKWhen promise_delay_8s</span><br></pre></td></tr></table></figure>

<h4 id="Present-ViewController-后返回结果："><a href="#Present-ViewController-后返回结果：" class="headerlink" title="Present ViewController 后返回结果："></a>Present ViewController 后返回结果：</h4><p>在刚接触iOS开发的时候感觉这部分没有Android来得便捷，在Android中直接通过onActivityResult回调就可以拿到上一个页面传递回来的值，而PromiseKit提供了这个便捷方法,下面是一个例子：</p>
<p>页面A,开启一个页面并等待页面的返回值</p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">[<span class="name">self.viewHolder.presentViewControllerBtn</span> bk_whenTapped:^&#123;</span><br><span class="line">    [<span class="name">self</span> promiseViewController:[<span class="name">IDLListKitViewController</span> new] animated:YES completion:nil].then(<span class="name">^</span>(<span class="name">id</span> value)&#123;</span><br><span class="line">        NSLog(<span class="name">@</span><span class="string">&quot;Return Value from last ViewController %@&quot;</span>,value)<span class="comment">;</span></span><br><span class="line">    &#125;)<span class="comment">;</span></span><br><span class="line">&#125;]<span class="comment">;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>页面B,经过一系列处理后返回值给上一个界面，并关闭当前界面</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">[PMKPromise when:@&#123;<span class="string">@&quot;task1&quot;</span>:[<span class="keyword">self</span> promise_delay_1s],<span class="string">@&quot;task2&quot;</span>:[<span class="keyword">self</span> promise_delay_8s],<span class="string">@&quot;task3&quot;</span>:<span class="string">@&quot;linxiaohai&quot;</span>&#125;].then(^(<span class="type">id</span> value) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>,value);</span><br><span class="line">    [<span class="keyword">self</span> fulfill:value];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="UIView-视图动画："><a href="#UIView-视图动画：" class="headerlink" title="UIView 视图动画："></a>UIView 视图动画：</h4><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">[<span class="built_in">UIView</span> promiseWithDuration:<span class="number">3</span> animations:^&#123;</span><br><span class="line">    <span class="keyword">self</span>.viewHolder.pushViewControllerBtn.alpha = <span class="number">0</span>;</span><br><span class="line">&#125;].then(^()&#123;</span><br><span class="line">    </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="获取Promise值"><a href="#获取Promise值" class="headerlink" title="获取Promise值:"></a>获取Promise值:</h4><p>Promise值是通过then来获取的，PromiseKit目前有三个方法用于Promise值的获取，分别是then，thenInBackground，以及thenOn，分别在主线程，后台线程，指定线程获取Promise值。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (AnyPromise * __<span class="keyword">nonnull</span> (^ __<span class="keyword">nonnull</span>)(<span class="type">id</span> __<span class="keyword">nonnull</span>))then <span class="built_in">NS_REFINED_FOR_SWIFT</span>;</span><br><span class="line">- (AnyPromise * __<span class="keyword">nonnull</span>(^ __<span class="keyword">nonnull</span>)(<span class="type">id</span> __<span class="keyword">nonnull</span>))thenInBackground <span class="built_in">NS_REFINED_FOR_SWIFT</span>;</span><br><span class="line">- (AnyPromise * __<span class="keyword">nonnull</span>(^ __<span class="keyword">nonnull</span>)(<span class="built_in">dispatch_queue_t</span> __<span class="keyword">nonnull</span>, <span class="type">id</span> __<span class="keyword">nonnull</span>))thenOn <span class="built_in">NS_REFINED_FOR_SWIFT</span>;</span><br></pre></td></tr></table></figure>

<h4 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常:"></a>捕获异常:</h4><p>在Promise reject 的时候，流程会走到catch分支，PromiseKit有两种catch方式来catch抛出的异常，一种在主线程，一种需要指定处理异常的线程。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (AnyPromise * __<span class="keyword">nonnull</span>(^ __<span class="keyword">nonnull</span>)(<span class="type">id</span> __<span class="keyword">nonnull</span>))catch <span class="built_in">NS_REFINED_FOR_SWIFT</span>;</span><br><span class="line">- (AnyPromise * __<span class="keyword">nonnull</span>(^ __<span class="keyword">nonnull</span>)(<span class="type">id</span> __<span class="keyword">nonnull</span>))catchInBackground <span class="built_in">NS_REFINED_FOR_SWIFT</span>;</span><br><span class="line">- (AnyPromise * __<span class="keyword">nonnull</span>(^ __<span class="keyword">nonnull</span>)(<span class="built_in">dispatch_queue_t</span> __<span class="keyword">nonnull</span>, <span class="type">id</span> __<span class="keyword">nonnull</span>))catchOn <span class="built_in">NS_REFINED_FOR_SWIFT</span>;</span><br></pre></td></tr></table></figure>

<h4 id="善后处理"><a href="#善后处理" class="headerlink" title="善后处理:"></a>善后处理:</h4><p>在Promise 被 resolve的时候，不论结果是fullfill还是reject都会走到ensure这个分支。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- (AnyPromise * __<span class="keyword">nonnull</span>(^ __<span class="keyword">nonnull</span>)(dispatch_block_t __<span class="keyword">nonnull</span>))ensure <span class="built_in">NS_REFINED_FOR_SWIFT</span>;</span><br><span class="line">- (AnyPromise * __<span class="keyword">nonnull</span>(^ __<span class="keyword">nonnull</span>)(<span class="built_in">dispatch_queue_t</span> __<span class="keyword">nonnull</span>, dispatch_block_t __<span class="keyword">nonnull</span>))ensureOn <span class="built_in">NS_REFINED_FOR_SWIFT</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="异步处理"><a href="#异步处理" class="headerlink" title="异步处理:"></a>异步处理:</h4><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">AnyPromise *dispatch<span class="constructor">_promise_on(<span class="params">dispatch_queue_t</span> <span class="params">queue</span>, <span class="params">id</span> <span class="params">block</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>在某个队列下执行block操作</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">AnyPromise *dispatch<span class="constructor">_promise(<span class="params">id</span> <span class="params">block</span>)</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_promise</span>(^&#123;</span><br><span class="line">    return md5(input);</span><br><span class="line">&#125;)<span class="selector-class">.then</span>(^(NSString *md5)&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(@&quot;md5: %@&quot;, md5);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>在后台队列下执行block操作，如果要取消某个操作可以return NSError.一旦返回一个id对象就相当于启动了一个Promise链。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/iOS-%E5%BC%80%E6%BA%90%E5%BA%93%E5%88%86%E6%9E%90/">iOS 开源库分析</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/iOS-开源库分析/">iOS 开源库分析</a>
  </div>

</div>



<div class="comments-count">
	
	  	<span></span>
		<a href="/2019/11/24/PromiseKit-的使用/#comments" class="ds-thread-count comments-count-link" data-thread-key="2019/11/24/PromiseKit-的使用/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/11/22/YYCache-源码解析/" title="YYCache 源码解析" itemprop="url">YYCache 源码解析</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Edgar" target="_blank" itemprop="author">Edgar</a>
		
  <p class="article-time">
    <time datetime="2019-11-21T18:05:02.000Z" itemprop="datePublished"> Published 2019-11-22</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h5 id="开源代码信息"><a href="#开源代码信息" class="headerlink" title="开源代码信息"></a>开源代码信息</h5><p><a target="_blank" rel="noopener" href="https://github.com/ibireme/YYCache/tree/master/YYCache">YYCache 开源库地址</a></p>
<p>我们在分析YTKNetWork,SDWebImage的时候涉及到缓存的实现，缓存一般都包含内存缓存和磁盘缓存，并且提供磁盘空间控制，缓存内容有效期控制等功能，我们接下来也从这几个方面对YYCache进行分析。YYCache代码量不多很精简，建议大家都可以尝试阅读下，因为一旦看惯代码了，就不会觉得畏惧了。下面先给出一个之前已经绘制好的一个YYCache构成图：</p>
<p><img src="/2019/11/22/YYCache-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/0001.png"></p>
<p>整个开源库也只有8个文件四个类：</p>
<ul>
<li><p><strong><strong>YYCache</strong></strong>: YYCache 的顶层类，业务主要和它进行交互获取实现对应的缓存任务。</p>
</li>
<li><p><strong><strong>YYMemoryCache</strong></strong>： 内存缓存，它是基于双向链表结构，它和NSCache的区别在于，YYMemoryCache 剔除过期对象是基于LRU方法，而NSCache剔除对象的方法是不确定的。<br>          YYMemoryCache可以根据缓存的cost，count，age来控制缓存，而NSCache不能。在收到内存缓存不足警告，或者应用进入后台的时候可以指定剔除某些缓存。</p>
</li>
<li><p><strong><strong>YYDiskCache</strong></strong>: 它是基于文件以及sqlite数据的磁盘缓存，它会根据不同的情况自动选择使用文件还是数据库来存储缓存，和YYMemoryCache类似它也是给予LRU原则来移除无用的缓存的，也可以根据缓存的cost，count，age来控制缓存。并且能够在磁盘空间不足的时候自动剔除无用的数据。</p>
</li>
<li><p><strong><strong>YYKVStorage</strong></strong> 是YYDiskCache执行存储的重要对象。后面介绍源码的时候我们会详细看下这部分实现。</p>
</li>
</ul>
<p>我们先来看下YYCache，YYCache我们这里只会做简单介绍，因为它大部分的功能都依托于YYMemoryCache和YYDiskCache。它使用YYMemoryCache用于存储小而快的内存缓存，使用YYDiskCache来存储大的对象。它提供了对缓存进行增删改查的操作，并且每种操作都提供了同步和异步两种方式。</p>
<p>这里仅仅列出同步的增删改查代码其实上层的逻辑和其他的缓存没有太多的差别，重点是底层的实现：</p>
<figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line">- (void)setObject:(id&lt;NSCoding&gt;)<span class="built_in">object</span> forKey:(NSString *)key &#123;</span><br><span class="line">    [<span class="variable">_memoryCache</span> setObject:<span class="built_in">object</span> forKey:key];</span><br><span class="line">    [<span class="variable">_diskCache</span> setObject:<span class="built_in">object</span> forKey:key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)removeObjectForKey:(NSString *)key &#123;</span><br><span class="line">    [<span class="variable">_memoryCache</span> removeObjectForKey:key];</span><br><span class="line">    [<span class="variable">_diskCache</span> removeObjectForKey:key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (id&lt;NSCoding&gt;)objectForKey:(NSString *)key &#123;</span><br><span class="line">    id&lt;NSCoding&gt; <span class="built_in">object</span> = [<span class="variable">_memoryCache</span> objectForKey:key];</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">object</span>) &#123;</span><br><span class="line">        <span class="built_in">object</span> = [<span class="variable">_diskCache</span> objectForKey:key];</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">object</span>) &#123;</span><br><span class="line">            [<span class="variable">_memoryCache</span> setObject:<span class="built_in">object</span> forKey:key];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return <span class="built_in">object</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (BOOL)containsObjectForKey:(NSString *)key &#123;</span><br><span class="line">    return [<span class="variable">_memoryCache</span> containsObjectForKey:key] || [<span class="variable">_diskCache</span> containsObjectForKey:key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p><strong><strong>YYMemoryCache</strong></strong></p>
<p>YYMemoryCache 内部是基于 _YYLinkedMap 双向链表实现的。我们看下YYMemoryCache初始化：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">    <span class="keyword">self</span> = <span class="variable language_">super</span>.init;</span><br><span class="line">    pthread_mutex_init(&amp;_lock, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//创建_YYLinkedMap</span></span><br><span class="line">    _lru = [_YYLinkedMap new];</span><br><span class="line">    <span class="comment">//创建串行队列</span></span><br><span class="line">    _queue = dispatch_queue_create(<span class="string">&quot;com.ibireme.cache.memory&quot;</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    <span class="comment">//最大缓存对象数量限制</span></span><br><span class="line">    _countLimit = <span class="built_in">NSUIntegerMax</span>;</span><br><span class="line">    <span class="comment">//最大空间消耗限制</span></span><br><span class="line">    _costLimit = <span class="built_in">NSUIntegerMax</span>;</span><br><span class="line">    <span class="comment">//最大过期时间限制</span></span><br><span class="line">    _ageLimit = DBL_MAX;</span><br><span class="line">    <span class="comment">//自动缓存清理触发时间</span></span><br><span class="line">    _autoTrimInterval = <span class="number">5.0</span>;</span><br><span class="line">    <span class="comment">//在收到内存警告的时候是否移除全部缓存对象</span></span><br><span class="line">    _shouldRemoveAllObjectsOnMemoryWarning = <span class="literal">YES</span>;</span><br><span class="line">    <span class="comment">//在进入后台的时候是否移除全部缓存对象</span></span><br><span class="line">    _shouldRemoveAllObjectsWhenEnteringBackground = <span class="literal">YES</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//注册内存警告通知</span></span><br><span class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(_appDidReceiveMemoryWarningNotification) name:<span class="built_in">UIApplicationDidReceiveMemoryWarningNotification</span> object:<span class="literal">nil</span>];</span><br><span class="line">    <span class="comment">//注册进入后台的通知</span></span><br><span class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(_appDidEnterBackgroundNotification) name:<span class="built_in">UIApplicationDidEnterBackgroundNotification</span> object:<span class="literal">nil</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//间隔_autoTrimInterval时间定期清除过期，超过限制的缓存</span></span><br><span class="line">    [<span class="keyword">self</span> _trimRecursively];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>_YYLinkedMap是一个双向链表，这部分代码不展开介绍，但是给出了代码的相关注释：</p>
<figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line">- (void)insertNodeAtHead:(<span class="variable">_YYLinkedMapNode</span> *)node &#123;</span><br><span class="line">    CFDictionarySetValue(<span class="variable">_dic</span>, (<span class="variable">__bridge</span> const void *)(node-&gt;<span class="variable">_key</span>), (<span class="variable">__bridge</span> const void *)(node));</span><br><span class="line">    <span class="comment">//计算_totalCost</span></span><br><span class="line">    <span class="variable">_totalCost</span> += node-&gt;<span class="variable">_cost</span>;</span><br><span class="line">    <span class="comment">//计算_totalCount</span></span><br><span class="line">    <span class="variable">_totalCount</span>++;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">_head</span>) &#123;</span><br><span class="line">        <span class="comment">//将node插入到head之前</span></span><br><span class="line">        node-&gt;<span class="variable">_next</span> = <span class="variable">_head</span>;</span><br><span class="line">        <span class="variable">_head</span>-&gt;<span class="variable">_prev</span> = node;</span><br><span class="line">        <span class="variable">_head</span> = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//空的双向链表</span></span><br><span class="line">        <span class="variable">_head</span> = <span class="variable">_tail</span> = node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)bringNodeToHead:(<span class="variable">_YYLinkedMapNode</span> *)node &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">_head</span> == node) return;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将node从原来的双向链表中分离开来</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">_tail</span> == node) &#123;</span><br><span class="line">        <span class="variable">_tail</span> = node-&gt;<span class="variable">_prev</span>;</span><br><span class="line">        <span class="variable">_tail</span>-&gt;<span class="variable">_next</span> = <span class="literal">nil</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        node-&gt;<span class="variable">_next</span>-&gt;<span class="variable">_prev</span> = node-&gt;<span class="variable">_prev</span>;</span><br><span class="line">        node-&gt;<span class="variable">_prev</span>-&gt;<span class="variable">_next</span> = node-&gt;<span class="variable">_next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将node插入到head</span></span><br><span class="line">    node-&gt;<span class="variable">_next</span> = <span class="variable">_head</span>;</span><br><span class="line">    node-&gt;<span class="variable">_prev</span> = <span class="literal">nil</span>;</span><br><span class="line">    <span class="variable">_head</span>-&gt;<span class="variable">_prev</span> = node;</span><br><span class="line">    <span class="variable">_head</span> = node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)removeNode:(<span class="variable">_YYLinkedMapNode</span> *)node &#123;</span><br><span class="line">    CFDictionaryRemoveValue(<span class="variable">_dic</span>, (<span class="variable">__bridge</span> const void *)(node-&gt;<span class="variable">_key</span>));</span><br><span class="line">    <span class="comment">//计算_totalCost</span></span><br><span class="line">    <span class="variable">_totalCost</span> -= node-&gt;<span class="variable">_cost</span>;</span><br><span class="line">    <span class="comment">//计算_totalCount</span></span><br><span class="line">    <span class="variable">_totalCount</span>--;</span><br><span class="line">    <span class="comment">//移除节点</span></span><br><span class="line">    <span class="keyword">if</span> (node-&gt;<span class="variable">_next</span>) node-&gt;<span class="variable">_next</span>-&gt;<span class="variable">_prev</span> = node-&gt;<span class="variable">_prev</span>;</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;<span class="variable">_prev</span>) node-&gt;<span class="variable">_prev</span>-&gt;<span class="variable">_next</span> = node-&gt;<span class="variable">_next</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">_head</span> == node) <span class="variable">_head</span> = node-&gt;<span class="variable">_next</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">_tail</span> == node) <span class="variable">_tail</span> = node-&gt;<span class="variable">_prev</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="variable">_YYLinkedMapNode</span> *)removeTailNode &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable">_tail</span>) return <span class="literal">nil</span>;</span><br><span class="line">    <span class="variable">_YYLinkedMapNode</span> *tail = <span class="variable">_tail</span>;</span><br><span class="line">    CFDictionaryRemoveValue(<span class="variable">_dic</span>, (<span class="variable">__bridge</span> const void *)(<span class="variable">_tail</span>-&gt;<span class="variable">_key</span>));</span><br><span class="line">    <span class="variable">_totalCost</span> -= <span class="variable">_tail</span>-&gt;<span class="variable">_cost</span>;</span><br><span class="line">    <span class="variable">_totalCount</span>--;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">_head</span> == <span class="variable">_tail</span>) &#123;</span><br><span class="line">        <span class="variable">_head</span> = <span class="variable">_tail</span> = <span class="literal">nil</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable">_tail</span> = <span class="variable">_tail</span>-&gt;<span class="variable">_prev</span>;</span><br><span class="line">        <span class="variable">_tail</span>-&gt;<span class="variable">_next</span> = <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    return tail;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)removeAll &#123;</span><br><span class="line">    <span class="variable">_totalCost</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="variable">_totalCount</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="variable">_head</span> = <span class="literal">nil</span>;</span><br><span class="line">    <span class="variable">_tail</span> = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">if</span> (CFDictionaryGetCount(<span class="variable">_dic</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        CFMutableDictionaryRef holder = <span class="variable">_dic</span>;</span><br><span class="line">        <span class="variable">_dic</span> = CFDictionaryCreateMutable(CFAllocatorGetDefault(), <span class="number">0</span>, &amp;kCFTypeDictionaryKeyCallBacks, &amp;kCFTypeDictionaryValueCallBacks);</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">_releaseAsynchronously</span>) &#123;</span><br><span class="line">            dispatch_queue_t queue = <span class="variable">_releaseOnMainThread</span> ? dispatch_get_main_queue() : YYMemoryCacheGetReleaseQueue();</span><br><span class="line">            dispatch_async(queue, ^&#123;</span><br><span class="line">                CFRelease(holder); <span class="comment">// hold and release in specified queue</span></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable">_releaseOnMainThread</span> &amp;&amp; !pthread_main_np()) &#123;</span><br><span class="line">            dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                CFRelease(holder); <span class="comment">// hold and release in specified queue</span></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            CFRelease(holder);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong><strong>增&#x2F;改缓存</strong></strong></p>
<figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line">- (void)setObject:(id)<span class="built_in">object</span> forKey:(id)key withCost:(NSUInteger)cost &#123;</span><br><span class="line">    <span class="comment">// 如果设置的object对象是空的那么就会移除这个对象</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">object</span>) &#123;</span><br><span class="line">        [self removeObjectForKey:key];</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_lock(&amp;<span class="variable">_lock</span>);</span><br><span class="line">    <span class="comment">//创建一个节点</span></span><br><span class="line">    <span class="variable">_YYLinkedMapNode</span> *node = CFDictionaryGetValue(<span class="variable">_lru</span>-&gt;<span class="variable">_dic</span>, (<span class="variable">__bridge</span> const void *)(key));</span><br><span class="line">    NSTimeInterval now = CACurrentMediaTime();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (node) &#123;</span><br><span class="line">        <span class="comment">//要设置的节点在缓存链表中，用新的值来更新节点内容</span></span><br><span class="line">        <span class="variable">_lru</span>-&gt;<span class="variable">_totalCost</span> -= node-&gt;<span class="variable">_cost</span>;</span><br><span class="line">        <span class="variable">_lru</span>-&gt;<span class="variable">_totalCost</span> += cost;</span><br><span class="line">        node-&gt;<span class="variable">_cost</span> = cost;</span><br><span class="line">        node-&gt;<span class="variable">_time</span> = now;</span><br><span class="line">        node-&gt;<span class="variable">_value</span> = <span class="built_in">object</span>;</span><br><span class="line">        <span class="comment">//节点移动到缓存链表的头部，</span></span><br><span class="line">        [<span class="variable">_lru</span> bringNodeToHead:node];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//要设置的节点不在缓存链表中，新建一个node将值传入并插入到双向链表的头部</span></span><br><span class="line">        node = [<span class="variable">_YYLinkedMapNode</span> new];</span><br><span class="line">        node-&gt;<span class="variable">_cost</span> = cost;</span><br><span class="line">        node-&gt;<span class="variable">_time</span> = now;</span><br><span class="line">        node-&gt;<span class="variable">_key</span> = key;</span><br><span class="line">        node-&gt;<span class="variable">_value</span> = <span class="built_in">object</span>;</span><br><span class="line">        [<span class="variable">_lru</span> insertNodeAtHead:node];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果缓存双向链表总的空间超过了限制大小调用trimToCost清除缓存</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">_lru</span>-&gt;<span class="variable">_totalCost</span> &gt; <span class="variable">_costLimit</span>) &#123;</span><br><span class="line">        dispatch_async(<span class="variable">_queue</span>, ^&#123;</span><br><span class="line">            [self trimToCost:<span class="variable">_costLimit</span>];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果缓存数量超过了限制，移除最后的节点</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">_lru</span>-&gt;<span class="variable">_totalCount</span> &gt; <span class="variable">_countLimit</span>) &#123;</span><br><span class="line">        <span class="variable">_YYLinkedMapNode</span> *node = [<span class="variable">_lru</span> removeTailNode];</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">_lru</span>-&gt;<span class="variable">_releaseAsynchronously</span>) &#123;</span><br><span class="line">            dispatch_queue_t queue = <span class="variable">_lru</span>-&gt;<span class="variable">_releaseOnMainThread</span> ? dispatch_get_main_queue() : YYMemoryCacheGetReleaseQueue();</span><br><span class="line">            dispatch_async(queue, ^&#123;</span><br><span class="line">                [node class]; <span class="comment">//hold and release in queue</span></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable">_lru</span>-&gt;<span class="variable">_releaseOnMainThread</span> &amp;&amp; !pthread_main_np()) &#123;</span><br><span class="line">            dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                [node class]; <span class="comment">//hold and release in queue</span></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_unlock(&amp;<span class="variable">_lock</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>setObject方法会首先检查传入的当前对象是否是nil，如果是nil会从缓存链表中删除传入key的元素。如果不是nil，则会在缓存链表中查看是否已经存在，如果是的话，就使用传入的object更新节点内容，然后将其移到链表的最前面。如果不存在就新建一个node插入到缓存链表头部，然后会对链表的空间以及链表节点数量进行检查，剔除掉不用的对象。</p>
<p><strong><strong>删除缓存</strong></strong></p>
<p>这个不做过多介绍大家直接看代码：</p>
<figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line">- (void)removeObjectForKey:(id)key &#123;</span><br><span class="line">    <span class="keyword">if</span> (!key) return;</span><br><span class="line">    pthread_mutex_lock(&amp;<span class="variable">_lock</span>);</span><br><span class="line">    <span class="variable">_YYLinkedMapNode</span> *node = CFDictionaryGetValue(<span class="variable">_lru</span>-&gt;<span class="variable">_dic</span>, (<span class="variable">__bridge</span> const void *)(key));</span><br><span class="line">    <span class="keyword">if</span> (node) &#123;</span><br><span class="line">        [<span class="variable">_lru</span> removeNode:node];</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">_lru</span>-&gt;<span class="variable">_releaseAsynchronously</span>) &#123;</span><br><span class="line">            dispatch_queue_t queue = <span class="variable">_lru</span>-&gt;<span class="variable">_releaseOnMainThread</span> ? dispatch_get_main_queue() : YYMemoryCacheGetReleaseQueue();</span><br><span class="line">            dispatch_async(queue, ^&#123;</span><br><span class="line">                [node class]; <span class="comment">//hold and release in queue</span></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable">_lru</span>-&gt;<span class="variable">_releaseOnMainThread</span> &amp;&amp; !pthread_main_np()) &#123;</span><br><span class="line">            dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                [node class]; <span class="comment">//hold and release in queue</span></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_unlock(&amp;<span class="variable">_lock</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><strong>查找缓存</strong></strong></p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">- (id)objectForKey:(id)key &#123;</span><br><span class="line">    <span class="keyword">if</span> (!key) return nil;</span><br><span class="line">    pthread<span class="constructor">_mutex_lock(&amp;<span class="params">_lock</span>)</span>;</span><br><span class="line">    _YYLinkedMapNode *node = <span class="constructor">CFDictionaryGetValue(<span class="params">_lru</span>-&gt;<span class="params">_dic</span>, (<span class="params">__bridge</span> <span class="params">const</span> <span class="params">void</span> <span class="operator">*</span>)</span>(key));</span><br><span class="line">    <span class="comment">//每次查找之前都会将找到的对象移到缓存链表的最前面</span></span><br><span class="line">    <span class="keyword">if</span> (node) &#123;</span><br><span class="line">        node-&gt;_time = <span class="constructor">CACurrentMediaTime()</span>;</span><br><span class="line">        <span class="literal">[<span class="identifier">_lru</span> <span class="identifier">bringNodeToHead</span>:<span class="identifier">node</span>]</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread<span class="constructor">_mutex_unlock(&amp;<span class="params">_lock</span>)</span>;</span><br><span class="line">    return node ? node-&gt;_value : nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (BOOL)containsObjectForKey:(id)key &#123;</span><br><span class="line">    <span class="keyword">if</span> (!key) return NO;</span><br><span class="line">    pthread<span class="constructor">_mutex_lock(&amp;<span class="params">_lock</span>)</span>;</span><br><span class="line">    BOOL contains = <span class="constructor">CFDictionaryContainsKey(<span class="params">_lru</span>-&gt;<span class="params">_dic</span>, (<span class="params">__bridge</span> <span class="params">const</span> <span class="params">void</span> <span class="operator">*</span>)</span>(key));</span><br><span class="line">    pthread<span class="constructor">_mutex_unlock(&amp;<span class="params">_lock</span>)</span>;</span><br><span class="line">    return contains;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这部分最关键的是它会在每次查找缓存，找到的时候将找到的对象移动到缓存链表最前面。</p>
<p><strong><strong>缓存清理</strong></strong></p>
<p>我们上面提到了在初始化的时候会触发定期清理缓存操作，默认每隔5秒进行一次。并且在每次添加缓存的时候还会触发一次。</p>
<figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line">- (void)<span class="variable">_trimToCost</span>:(NSUInteger)costLimit &#123;</span><br><span class="line">    BOOL finish = NO;</span><br><span class="line">    pthread_mutex_lock(&amp;<span class="variable">_lock</span>);</span><br><span class="line">    <span class="keyword">if</span> (costLimit == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//如果costLimit被设置为0那么就将所有的缓存都删除</span></span><br><span class="line">        [<span class="variable">_lru</span> removeAll];</span><br><span class="line">        finish = YES;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable">_lru</span>-&gt;<span class="variable">_totalCost</span> &lt;= costLimit) &#123;</span><br><span class="line">        finish = YES;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_unlock(&amp;<span class="variable">_lock</span>);</span><br><span class="line">    <span class="keyword">if</span> (finish) return;</span><br><span class="line">    </span><br><span class="line">    NSMutableArray *holder = [NSMutableArray new];</span><br><span class="line">    <span class="keyword">while</span> (!finish) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pthread_mutex_trylock(&amp;<span class="variable">_lock</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//如果缓存的存储空间还是超过了限制，就从缓存尾部移除一个暂时添加到holder，避免频繁对内存读写，导致锁被占用，</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="variable">_lru</span>-&gt;<span class="variable">_totalCost</span> &gt; costLimit) &#123;</span><br><span class="line">                <span class="variable">_YYLinkedMapNode</span> *node = [<span class="variable">_lru</span> removeTailNode];</span><br><span class="line">                <span class="keyword">if</span> (node) [holder addObject:node];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                finish = YES;</span><br><span class="line">            &#125;</span><br><span class="line">            pthread_mutex_unlock(&amp;<span class="variable">_lock</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            usleep(<span class="number">10</span> * <span class="number">1000</span>); <span class="comment">//10 ms</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最后将待清除的对象所占用的空间清除。</span></span><br><span class="line">    <span class="keyword">if</span> (holder.<span class="built_in">count</span>) &#123;</span><br><span class="line">        dispatch_queue_t queue = <span class="variable">_lru</span>-&gt;<span class="variable">_releaseOnMainThread</span> ? dispatch_get_main_queue() : YYMemoryCacheGetReleaseQueue();</span><br><span class="line">        dispatch_async(queue, ^&#123;</span><br><span class="line">            [holder <span class="built_in">count</span>]; <span class="comment">// release in queue</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>_trimToCost 中如果有超过限制就会不断从缓存链表队尾移除一个对象，然后先将待移除的对象暂时添加到holder，避免频繁对内存读写，导致锁被占用，直到没有超过限制的时候在对应的队列中将这些对象的空间释放。****_trimToCount<strong><strong>，</strong></strong>_trimToAge**** 和 <strong><strong>_trimToCost</strong></strong> 代码类似，只不过判断的标准不一样而已，这里就不展开介绍了，有兴趣的同学可以查看对应的代码。</p>
<p><strong><strong>YYDiskCache</strong></strong></p>
<p>磁盘缓存和内存缓存对外的接口大体类似，只有一点不大一致的：</p>
<ul>
<li><strong><strong>inlineThreshold</strong></strong></li>
</ul>
<p>它多出了inlineThreshold属性，它是一个阈值，最开始的时候磁盘缓存是存储在sqlite上的，一旦存储在sqlite的磁盘缓存超过这个值的时候后续的对象就会被存储到文件，如果设置为0的话表示所有的缓存都会被存储到文件，NSUIntegerMax表示所有的对象都会被存储到sqlite，默认这个阈值是20KB</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) <span class="built_in">NSUInteger</span> inlineThreshold;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><strong>自定义归档&#x2F;反归档处理</strong></strong></li>
</ul>
<p>多出了归档对象的方式，默认情况下YYCache是通过NSKeyedArchiver和NSKeyedUnarchiver进行归档和反归档，但是这要求对象必须遵循<strong><strong>NSCoding</strong></strong>协议，如果某些对象没法做到这一点，那么可以通过指定customArchiveBlock以及customUnarchiveBlock来自定义归档和反归档将要存储的对象：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@property (<span class="params">nullable, copy</span>) NSData *(<span class="params">^customArchiveBlock</span>)(<span class="params"><span class="built_in">id</span> <span class="built_in">object</span></span>);</span></span><br><span class="line"><span class="meta">@property (<span class="params">nullable, copy</span>) id (<span class="params">^customUnarchiveBlock</span>)(<span class="params">NSData *data</span>);</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong><strong>自定义缓存文件名规范</strong></strong></li>
</ul>
<p>默认缓存文件名是通过md5(key)计算出来的，但是我们可以通过customFileNameBlock来自定义key与对它对应的缓存文件名字的命名规范。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *(^customFileNameBlock)(<span class="built_in">NSString</span> *key);</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><strong>可以扩张缓存对象的数据</strong></strong></li>
</ul>
<p>在对缓存对象进行缓存之前，还可以通过下面的方法对缓存数据进行扩展，它实际上是通过关联对象的方式来实现的。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">+ (<span class="keyword">nullable</span> <span class="built_in">NSData</span> *)getExtendedDataFromObject:(<span class="type">id</span>)object;</span><br><span class="line">+ (<span class="type">void</span>)setExtendedData:(<span class="keyword">nullable</span> <span class="built_in">NSData</span> *)extendedData toObject:(<span class="type">id</span>)object;</span><br></pre></td></tr></table></figure>

<p>我们接下来开始分析YYDiskCache</p>
<p><strong><strong>YYDiskCache的初始化</strong></strong></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)initWithPath:(<span class="built_in">NSString</span> *)path &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> initWithPath:path inlineThreshold:<span class="number">1024</span> * <span class="number">20</span>]; <span class="comment">// 20KB</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithPath:(<span class="built_in">NSString</span> *)path</span><br><span class="line">             inlineThreshold:(<span class="built_in">NSUInteger</span>)threshold &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="variable language_">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//我们在项目中可能会有多个YYDiskCache，我们会将这些YYDiskCache的实例以path为key，缓存到类型为NSMapTable的_globalInstances中。</span></span><br><span class="line">    YYDiskCache *globalCache = _YYDiskCacheGetGlobal(path);</span><br><span class="line">    <span class="comment">//如果缓存中有就先用缓存中的，避免重复创建</span></span><br><span class="line">    <span class="keyword">if</span> (globalCache) <span class="keyword">return</span> globalCache;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//根据threshold来设定缓存的存储方式：</span></span><br><span class="line">    YYKVStorageType type;</span><br><span class="line">    <span class="keyword">if</span> (threshold == <span class="number">0</span>) &#123;</span><br><span class="line">        type = YYKVStorageTypeFile;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (threshold == <span class="built_in">NSUIntegerMax</span>) &#123;</span><br><span class="line">        type = YYKVStorageTypeSQLite;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        type = YYKVStorageTypeMixed;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//新建一个YYKVStorage，所有的磁盘存储都由YYKVStorage来完成</span></span><br><span class="line">    YYKVStorage *kv = [[YYKVStorage alloc] initWithPath:path type:type];</span><br><span class="line">    <span class="keyword">if</span> (!kv) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">    _kv = kv;</span><br><span class="line">    _path = path;</span><br><span class="line">    _lock = dispatch_semaphore_create(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//磁盘操作队列</span></span><br><span class="line">    _queue = dispatch_queue_create(<span class="string">&quot;com.ibireme.cache.disk&quot;</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    <span class="comment">//一系列的限制</span></span><br><span class="line">    _inlineThreshold = threshold;</span><br><span class="line">    _countLimit = <span class="built_in">NSUIntegerMax</span>;</span><br><span class="line">    _costLimit = <span class="built_in">NSUIntegerMax</span>;</span><br><span class="line">    _ageLimit = DBL_MAX;</span><br><span class="line">    _freeDiskSpaceLimit = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//缓存整理主动触发时间默认为1分钟</span></span><br><span class="line">    _autoTrimInterval = <span class="number">60</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//触发缓存整理</span></span><br><span class="line">    [<span class="keyword">self</span> _trimRecursively];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将当前YYDiskCache缓存起来</span></span><br><span class="line">    _YYDiskCacheSetGlobal(<span class="keyword">self</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//在退出应用的时候会将kv设置为nil</span></span><br><span class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(_appWillBeTerminated) name:<span class="built_in">UIApplicationWillTerminateNotification</span> object:<span class="literal">nil</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在项目中可能会有多个YYDiskCache，我们会将这些YYDiskCache的实例以path为key，缓存到类型为NSMapTable的_globalInstances中。所以我们在最初的时候会先从globalInstances中先看下是否有已经创建好的，如果没有再新建YYDiskCache并缓存起来。YYDiskCache中最关键的就是YYKVStorage了，所有的磁盘存储都由YYKVStorage来完成。</p>
<p>YYDiskCache上层比较简单，主要的逻辑在YYKVStorage，但是在介绍YYKVStorage之前我们先简单浏览下YYDiskCache：</p>
<p><strong><strong>增&#x2F;改缓存</strong></strong></p>
<figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line">- (void)setObject:(id&lt;NSCoding&gt;)<span class="built_in">object</span> forKey:(NSString *)key &#123;</span><br><span class="line">    <span class="comment">//如果object为空表示从磁盘缓存中删除改对象，这个和YYMemoryCache是一致的</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">object</span>) &#123;</span><br><span class="line">        [self removeObjectForKey:key];</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取某个对象额外需要追加到对象上的数据</span></span><br><span class="line">    NSData *extendedData = [YYDiskCache getExtendedDataFromObject:<span class="built_in">object</span>];</span><br><span class="line">    NSData *value = <span class="literal">nil</span>;</span><br><span class="line">    <span class="comment">//如果指定了自定义的归档方式，那么使用自定义的归档方式来对要缓存的对象归档为NSData存储到磁盘缓存中</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">_customArchiveBlock</span>) &#123;</span><br><span class="line">        value = <span class="variable">_customArchiveBlock</span>(<span class="built_in">object</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//否则使用NSKeyedArchiver进行归档</span></span><br><span class="line">        @<span class="keyword">try</span> &#123;</span><br><span class="line">            value = [NSKeyedArchiver archivedDataWithRootObject:<span class="built_in">object</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        @<span class="keyword">catch</span> (NSException *exception) &#123;</span><br><span class="line">            <span class="comment">// nothing to do...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!value) return;</span><br><span class="line">    NSString *filename = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">_kv</span>.<span class="built_in">type</span> != YYKVStorageTypeSQLite) &#123;</span><br><span class="line">        <span class="keyword">if</span> (value.length &gt; <span class="variable">_inlineThreshold</span>) &#123;</span><br><span class="line">            filename = [self <span class="variable">_filenameForKey</span>:key];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//磁盘缓存</span></span><br><span class="line">    <span class="built_in">Lock</span>();</span><br><span class="line">    [<span class="variable">_kv</span> saveItemWithKey:key value:value filename:filename extendedData:extendedData];</span><br><span class="line">    Unlock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面代码注释得比较详细了，大家看代码就能看懂，就不展开了。</p>
<p><strong><strong>删除缓存</strong></strong></p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">- (void)removeObjectForKey:(NSString *)key &#123;</span><br><span class="line">    if (!key) return;</span><br><span class="line">    <span class="built_in">Lock</span>();</span><br><span class="line">    <span class="selector-attr">[_kv removeItemForKey:key]</span>;</span><br><span class="line">    <span class="built_in">Unlock</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><strong>查找缓存</strong></strong></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">BOOL</span>)containsObjectForKey:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    <span class="keyword">if</span> (!key) <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    Lock();</span><br><span class="line">    <span class="type">BOOL</span> contains = [_kv itemExistsForKey:key];</span><br><span class="line">    Unlock();</span><br><span class="line">    <span class="keyword">return</span> contains;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)containsObjectForKey:(<span class="built_in">NSString</span> *)key withBlock:(<span class="type">void</span>(^)(<span class="built_in">NSString</span> *key, <span class="type">BOOL</span> contains))block &#123;</span><br><span class="line">    <span class="keyword">if</span> (!block) <span class="keyword">return</span>;</span><br><span class="line">    __<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) _<span class="keyword">self</span> = <span class="keyword">self</span>;</span><br><span class="line">    <span class="built_in">dispatch_async</span>(_queue, ^&#123;</span><br><span class="line">        __<span class="keyword">strong</span> <span class="keyword">typeof</span>(_<span class="keyword">self</span>) <span class="keyword">self</span> = _<span class="keyword">self</span>;</span><br><span class="line">        <span class="type">BOOL</span> contains = [<span class="keyword">self</span> containsObjectForKey:key];</span><br><span class="line">        block(key, contains);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">id</span>&lt;<span class="built_in">NSCoding</span>&gt;)objectForKey:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    <span class="keyword">if</span> (!key) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    Lock();</span><br><span class="line">    YYKVStorageItem *item = [_kv getItemForKey:key];</span><br><span class="line">    Unlock();</span><br><span class="line">    <span class="keyword">if</span> (!item.value) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">id</span> object = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">if</span> (_customUnarchiveBlock) &#123;</span><br><span class="line">        object = _customUnarchiveBlock(item.value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">@try</span> &#123;</span><br><span class="line">            object = [<span class="built_in">NSKeyedUnarchiver</span> unarchiveObjectWithData:item.value];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">@catch</span> (<span class="built_in">NSException</span> *exception) &#123;</span><br><span class="line">            <span class="comment">// nothing to do...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (object &amp;&amp; item.extendedData) &#123;</span><br><span class="line">        [YYDiskCache setExtendedData:item.extendedData toObject:object];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>还是不大想解释，代码不难。</p>
<p><strong><strong>缓存清理</strong></strong></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- (<span class="type">void</span>)_trimToCost:(<span class="built_in">NSUInteger</span>)costLimit &#123;</span><br><span class="line">    <span class="keyword">if</span> (costLimit &gt;= INT_MAX) <span class="keyword">return</span>;</span><br><span class="line">    [_kv removeItemsToFitSize:(<span class="type">int</span>)costLimit];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)_trimToCount:(<span class="built_in">NSUInteger</span>)countLimit &#123;</span><br><span class="line">    <span class="keyword">if</span> (countLimit &gt;= INT_MAX) <span class="keyword">return</span>;</span><br><span class="line">    [_kv removeItemsToFitCount:(<span class="type">int</span>)countLimit];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)_trimToAge:(<span class="built_in">NSTimeInterval</span>)ageLimit &#123;</span><br><span class="line">    <span class="keyword">if</span> (ageLimit &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        [_kv removeAllItems];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> timestamp = time(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (timestamp &lt;= ageLimit) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">long</span> age = timestamp - ageLimit;</span><br><span class="line">    <span class="keyword">if</span> (age &gt;= INT_MAX) <span class="keyword">return</span>;</span><br><span class="line">    [_kv removeItemsEarlierThanTime:(<span class="type">int</span>)age];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong><strong>YYKVStorage</strong></strong></p>
<p><strong><strong>存储对象</strong></strong></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">BOOL</span>)saveItemWithKey:(<span class="built_in">NSString</span> *)key value:(<span class="built_in">NSData</span> *)value filename:(<span class="built_in">NSString</span> *)filename extendedData:(<span class="built_in">NSData</span> *)extendedData &#123;</span><br><span class="line">    <span class="comment">//.......</span></span><br><span class="line">    <span class="keyword">if</span> (filename.length) &#123;</span><br><span class="line">        <span class="comment">//如果filename不为空，表示使用文件作为磁盘缓存，这时候会先将缓存写到文件中</span></span><br><span class="line">        <span class="keyword">if</span> (![<span class="keyword">self</span> _fileWriteWithName:filename data:value]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果缓存成功写入到缓存，那么就更新缓存记录数据</span></span><br><span class="line">        <span class="keyword">if</span> (![<span class="keyword">self</span> _dbSaveWithKey:key value:value fileName:filename extendedData:extendedData]) &#123;</span><br><span class="line">            <span class="comment">//如果缓存记录数据存储失败，那么会将缓存文件同时删除以保证缓存文件与缓存记录的同步</span></span><br><span class="line">            [<span class="keyword">self</span> _fileDeleteWithName:filename];</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (_type != YYKVStorageTypeSQLite) &#123;</span><br><span class="line">            <span class="built_in">NSString</span> *filename = [<span class="keyword">self</span> _dbGetFilenameWithKey:key];</span><br><span class="line">            <span class="keyword">if</span> (filename) &#123;</span><br><span class="line">                [<span class="keyword">self</span> _fileDeleteWithName:filename];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//由于filename为nil那么会将缓存数据缓存到inline_data字段。</span></span><br><span class="line">        <span class="keyword">return</span> [<span class="keyword">self</span> _dbSaveWithKey:key value:value fileName:<span class="literal">nil</span> extendedData:extendedData];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>saveItemWithKey方法中会先判断filename是否为空，如果是有指定缓存文件名，那么就会先将缓存数据写入到文件缓存起来，同时将缓存记录写入到数据库中，作为缓存记录。如果filename为nil，那么就直接将缓存数据缓存到数据库inline_data字段。接下来我们来看下_dbSaveWithKey：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- (BOOL)_dbSaveWithKey:(NSString *)key value:(NSData *)value fileName:(NSString *)fileName extendedData:(NSData *)extendedData &#123;</span><br><span class="line">    NSString *sql = @<span class="string">&quot;insert or replace into manifest (key, filename, size, inline_data, modification_time, last_access_time, extended_data) values (?1, ?2, ?3, ?4, ?5, ?6, ?7);&quot;</span>;</span><br><span class="line">    sqlite3_stmt *stmt = <span class="literal">[<span class="identifier">self</span> <span class="identifier">_dbPrepareStmt</span>:<span class="identifier">sql</span>]</span>;</span><br><span class="line">    <span class="keyword">if</span> (!stmt) return NO;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">int</span> timestamp = (<span class="built_in">int</span>)time(NULL);</span><br><span class="line">    sqlite3<span class="constructor">_bind_text(<span class="params">stmt</span>, 1, <span class="params">key</span>.UTF8String, -1, NULL)</span>;</span><br><span class="line">    sqlite3<span class="constructor">_bind_text(<span class="params">stmt</span>, 2, <span class="params">fileName</span>.UTF8String, -1, NULL)</span>;</span><br><span class="line">    sqlite3<span class="constructor">_bind_int(<span class="params">stmt</span>, 3, (<span class="params">int</span>)</span>value.length);</span><br><span class="line">    <span class="keyword">if</span> (fileName.length<span class="operator"> == </span><span class="number">0</span>) &#123;</span><br><span class="line">        sqlite3<span class="constructor">_bind_blob(<span class="params">stmt</span>, 4, <span class="params">value</span>.<span class="params">bytes</span>, (<span class="params">int</span>)</span>value.length, <span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        sqlite3<span class="constructor">_bind_blob(<span class="params">stmt</span>, 4, NULL, 0, 0)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sqlite3<span class="constructor">_bind_int(<span class="params">stmt</span>, 5, <span class="params">timestamp</span>)</span>;</span><br><span class="line">    sqlite3<span class="constructor">_bind_int(<span class="params">stmt</span>, 6, <span class="params">timestamp</span>)</span>;</span><br><span class="line">    sqlite3<span class="constructor">_bind_blob(<span class="params">stmt</span>, 7, <span class="params">extendedData</span>.<span class="params">bytes</span>, (<span class="params">int</span>)</span>extendedData.length, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">int</span> result = sqlite3<span class="constructor">_step(<span class="params">stmt</span>)</span>;</span><br><span class="line">    <span class="keyword">if</span> (result != SQLITE_DONE) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_errorLogsEnabled) <span class="constructor">NSLog(@<span class="string">&quot;%s line:%d sqlite insert error (%d): %s&quot;</span>, <span class="params">__FUNCTION__</span>, <span class="params">__LINE__</span>, <span class="params">result</span>, <span class="params">sqlite3_errmsg</span>(<span class="params">_db</span>)</span>);</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看这个方法主要是了解这个缓存记录表的结构设计：这个缓存记录表有7个字段分别列举如下：</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="comment">* key               缓存的key</span></span><br><span class="line"><span class="comment">* filename          使用文件缓存的情况下该文件存储的路径</span></span><br><span class="line"><span class="comment">* size              缓存数据大小</span></span><br><span class="line"><span class="comment">* inline_data       数据库缓存的地方</span></span><br><span class="line"><span class="comment">* modification_time 缓存修改时间</span></span><br><span class="line"><span class="comment">* last_access_time  上一次访问时间</span></span><br><span class="line"><span class="comment">* extended_data     额外追加数据</span></span><br></pre></td></tr></table></figure>

<p><strong><strong>删除对象</strong></strong></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">BOOL</span>)removeItemForKey:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    <span class="keyword">if</span> (key.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    <span class="keyword">switch</span> (_type) &#123;</span><br><span class="line">        <span class="keyword">case</span> YYKVStorageTypeSQLite: &#123;</span><br><span class="line">            <span class="comment">//如果是YYKVStorageTypeSQLite 则只删除数据库记录就可以了，因为这时候数据是存储在数据库记录上的</span></span><br><span class="line">            <span class="keyword">return</span> [<span class="keyword">self</span> _dbDeleteItemWithKey:key];</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> YYKVStorageTypeFile:</span><br><span class="line">        <span class="keyword">case</span> YYKVStorageTypeMixed: &#123;</span><br><span class="line">            <span class="comment">//如果是YYKVStorageTypeFile或者YYKVStorageTypeMixed的形式，会同时删除缓存文件以及数据库缓存记录上的内容</span></span><br><span class="line">            <span class="built_in">NSString</span> *filename = [<span class="keyword">self</span> _dbGetFilenameWithKey:key];</span><br><span class="line">            <span class="keyword">if</span> (filename) &#123;</span><br><span class="line">                [<span class="keyword">self</span> _fileDeleteWithName:filename];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> [<span class="keyword">self</span> _dbDeleteItemWithKey:key];</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>: <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果了解了上面的表结构，其实在逻辑层面上就比较好理解了，这里就不展开介绍了。下面是一些条件删除，只是删除数据库的时候条件不一样罢了，没有啥区别：</p>
<figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line">- (BOOL)removeItemsLargerThanSize:(int)<span class="built_in">size</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">size</span> == INT_MAX) return YES;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">size</span> &lt;= <span class="number">0</span>) return [self <span class="built_in">removeAllItems</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">switch</span> (<span class="variable">_type</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> YYKVStorageTypeSQLite: &#123;</span><br><span class="line">            <span class="keyword">if</span> ([self <span class="variable">_dbDeleteItemsWithSizeLargerThan</span>:<span class="built_in">size</span>]) &#123;</span><br><span class="line">                [self <span class="variable">_dbCheckpoint</span>];</span><br><span class="line">                return YES;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="built_in">break</span>;</span><br><span class="line">        <span class="keyword">case</span> YYKVStorageTypeFile:</span><br><span class="line">        <span class="keyword">case</span> YYKVStorageTypeMixed: &#123;</span><br><span class="line">            NSArray *filenames = [self <span class="variable">_dbGetFilenamesWithSizeLargerThan</span>:<span class="built_in">size</span>];</span><br><span class="line">            <span class="keyword">for</span> (NSString *<span class="built_in">name</span> <span class="built_in">in</span> filenames) &#123;</span><br><span class="line">                [self <span class="variable">_fileDeleteWithName</span>:<span class="built_in">name</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ([self <span class="variable">_dbDeleteItemsWithSizeLargerThan</span>:<span class="built_in">size</span>]) &#123;</span><br><span class="line">                [self <span class="variable">_dbCheckpoint</span>];</span><br><span class="line">                return YES;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="built_in">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    return NO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (BOOL)removeItemsEarlierThanTime:(int)<span class="built_in">time</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">time</span> &lt;= <span class="number">0</span>) return YES;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">time</span> == INT_MAX) return [self <span class="built_in">removeAllItems</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">switch</span> (<span class="variable">_type</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> YYKVStorageTypeSQLite: &#123;</span><br><span class="line">            <span class="keyword">if</span> ([self <span class="variable">_dbDeleteItemsWithTimeEarlierThan</span>:<span class="built_in">time</span>]) &#123;</span><br><span class="line">                [self <span class="variable">_dbCheckpoint</span>];</span><br><span class="line">                return YES;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="built_in">break</span>;</span><br><span class="line">        <span class="keyword">case</span> YYKVStorageTypeFile:</span><br><span class="line">        <span class="keyword">case</span> YYKVStorageTypeMixed: &#123;</span><br><span class="line">            NSArray *filenames = [self <span class="variable">_dbGetFilenamesWithTimeEarlierThan</span>:<span class="built_in">time</span>];</span><br><span class="line">            <span class="keyword">for</span> (NSString *<span class="built_in">name</span> <span class="built_in">in</span> filenames) &#123;</span><br><span class="line">                [self <span class="variable">_fileDeleteWithName</span>:<span class="built_in">name</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ([self <span class="variable">_dbDeleteItemsWithTimeEarlierThan</span>:<span class="built_in">time</span>]) &#123;</span><br><span class="line">                [self <span class="variable">_dbCheckpoint</span>];</span><br><span class="line">                return YES;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="built_in">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    return NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">BOOL</span>)removeItemsToFitSize:(<span class="type">int</span>)maxSize &#123;</span><br><span class="line">    <span class="keyword">if</span> (maxSize == INT_MAX) <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    <span class="keyword">if</span> (maxSize &lt;= <span class="number">0</span>) <span class="keyword">return</span> [<span class="keyword">self</span> removeAllItems];</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> total = [<span class="keyword">self</span> _dbGetTotalItemSize];</span><br><span class="line">    <span class="keyword">if</span> (total &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    <span class="keyword">if</span> (total &lt;= maxSize) <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSArray</span> *items = <span class="literal">nil</span>;</span><br><span class="line">    <span class="type">BOOL</span> suc = <span class="literal">NO</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="type">int</span> perCount = <span class="number">16</span>;</span><br><span class="line">        items = [<span class="keyword">self</span> _dbGetItemSizeInfoOrderByTimeAscWithLimit:perCount];</span><br><span class="line">        <span class="keyword">for</span> (YYKVStorageItem *item <span class="keyword">in</span> items) &#123;</span><br><span class="line">            <span class="keyword">if</span> (total &gt; maxSize) &#123;</span><br><span class="line">                <span class="keyword">if</span> (item.filename) &#123;</span><br><span class="line">                    [<span class="keyword">self</span> _fileDeleteWithName:item.filename];</span><br><span class="line">                &#125;</span><br><span class="line">                suc = [<span class="keyword">self</span> _dbDeleteItemWithKey:item.key];</span><br><span class="line">                total -= item.size;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!suc) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (total &gt; maxSize &amp;&amp; items.count &gt; <span class="number">0</span> &amp;&amp; suc);</span><br><span class="line">    <span class="keyword">if</span> (suc) [<span class="keyword">self</span> _dbCheckpoint];</span><br><span class="line">    <span class="keyword">return</span> suc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">BOOL</span>)removeItemsToFitCount:(<span class="type">int</span>)maxCount &#123;</span><br><span class="line">    <span class="keyword">if</span> (maxCount == INT_MAX) <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    <span class="keyword">if</span> (maxCount &lt;= <span class="number">0</span>) <span class="keyword">return</span> [<span class="keyword">self</span> removeAllItems];</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> total = [<span class="keyword">self</span> _dbGetTotalItemCount];</span><br><span class="line">    <span class="keyword">if</span> (total &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    <span class="keyword">if</span> (total &lt;= maxCount) <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSArray</span> *items = <span class="literal">nil</span>;</span><br><span class="line">    <span class="type">BOOL</span> suc = <span class="literal">NO</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="type">int</span> perCount = <span class="number">16</span>;</span><br><span class="line">        items = [<span class="keyword">self</span> _dbGetItemSizeInfoOrderByTimeAscWithLimit:perCount];</span><br><span class="line">        <span class="keyword">for</span> (YYKVStorageItem *item <span class="keyword">in</span> items) &#123;</span><br><span class="line">            <span class="keyword">if</span> (total &gt; maxCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> (item.filename) &#123;</span><br><span class="line">                    [<span class="keyword">self</span> _fileDeleteWithName:item.filename];</span><br><span class="line">                &#125;</span><br><span class="line">                suc = [<span class="keyword">self</span> _dbDeleteItemWithKey:item.key];</span><br><span class="line">                total--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!suc) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (total &gt; maxCount &amp;&amp; items.count &gt; <span class="number">0</span> &amp;&amp; suc);</span><br><span class="line">    <span class="keyword">if</span> (suc) [<span class="keyword">self</span> _dbCheckpoint];</span><br><span class="line">    <span class="keyword">return</span> suc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><strong>获取对象</strong></strong></p>
<p>这里也不想介绍了，大家看注释吧，其实了解了数据库表结构，以及存储的思路，删除和获取其实很好理解的。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="operator">-</span> (<span class="type">YYKVStorageItem</span> <span class="operator">*</span>)getItemForKey:(<span class="type">NSString</span> <span class="operator">*</span>)key &#123;</span><br><span class="line">    <span class="keyword">if</span> (key.length <span class="operator">==</span> <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    <span class="comment">//通过key 从数据库或者到当前缓存对象的缓存记录。</span></span><br><span class="line">    <span class="type">YYKVStorageItem</span> <span class="operator">*</span>item <span class="operator">=</span> [<span class="keyword">self</span> _dbGetItemWithKey:key excludeInlineData:<span class="type">NO</span>];</span><br><span class="line">    <span class="keyword">if</span> (item) &#123;</span><br><span class="line">        <span class="comment">//更新下缓存访问时间</span></span><br><span class="line">        [<span class="keyword">self</span> _dbUpdateAccessTimeWithKey:key];</span><br><span class="line">        <span class="comment">//如果缓存记录的filename不为空，则表示是文件缓存</span></span><br><span class="line">        <span class="keyword">if</span> (item.filename) &#123;</span><br><span class="line">            <span class="comment">//读取文件，将数据添加到value字段</span></span><br><span class="line">            item.value <span class="operator">=</span> [<span class="keyword">self</span> _fileReadWithName:item.filename];</span><br><span class="line">            <span class="keyword">if</span> (<span class="operator">!</span>item.value) &#123;</span><br><span class="line">                <span class="comment">//如果缓存文件数据为空，删除缓存记录，保持缓存数据记录与缓存文件同步</span></span><br><span class="line">                [<span class="keyword">self</span> _dbDeleteItemWithKey:key];</span><br><span class="line">                item <span class="operator">=</span> <span class="literal">nil</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="operator">-</span> (<span class="type">YYKVStorageItem</span> <span class="operator">*</span>)getItemInfoForKey:(<span class="type">NSString</span> <span class="operator">*</span>)key &#123;</span><br><span class="line">    <span class="keyword">if</span> (key.length <span class="operator">==</span> <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    <span class="type">YYKVStorageItem</span> <span class="operator">*</span>item <span class="operator">=</span> [<span class="keyword">self</span> _dbGetItemWithKey:key excludeInlineData:<span class="type">YES</span>];</span><br><span class="line">    <span class="keyword">return</span> item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="operator">-</span> (<span class="type">NSData</span> <span class="operator">*</span>)getItemValueForKey:(<span class="type">NSString</span> <span class="operator">*</span>)key &#123;</span><br><span class="line">    <span class="keyword">if</span> (key.length <span class="operator">==</span> <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    <span class="type">NSData</span> <span class="operator">*</span>value <span class="operator">=</span> <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">switch</span> (_type) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="type">YYKVStorageTypeFile</span>: &#123;</span><br><span class="line">            <span class="type">NSString</span> <span class="operator">*</span>filename <span class="operator">=</span> [<span class="keyword">self</span> _dbGetFilenameWithKey:key];</span><br><span class="line">            <span class="keyword">if</span> (filename) &#123;</span><br><span class="line">                value <span class="operator">=</span> [<span class="keyword">self</span> _fileReadWithName:filename];</span><br><span class="line">                <span class="keyword">if</span> (<span class="operator">!</span>value) &#123;</span><br><span class="line">                    [<span class="keyword">self</span> _dbDeleteItemWithKey:key];</span><br><span class="line">                    value <span class="operator">=</span> <span class="literal">nil</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="type">YYKVStorageTypeSQLite</span>: &#123;</span><br><span class="line">            value <span class="operator">=</span> [<span class="keyword">self</span> _dbGetValueWithKey:key];</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="type">YYKVStorageTypeMixed</span>: &#123;</span><br><span class="line">            <span class="type">NSString</span> <span class="operator">*</span>filename <span class="operator">=</span> [<span class="keyword">self</span> _dbGetFilenameWithKey:key];</span><br><span class="line">            <span class="keyword">if</span> (filename) &#123;</span><br><span class="line">                value <span class="operator">=</span> [<span class="keyword">self</span> _fileReadWithName:filename];</span><br><span class="line">                <span class="keyword">if</span> (<span class="operator">!</span>value) &#123;</span><br><span class="line">                    [<span class="keyword">self</span> _dbDeleteItemWithKey:key];</span><br><span class="line">                    value <span class="operator">=</span> <span class="literal">nil</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                value <span class="operator">=</span> [<span class="keyword">self</span> _dbGetValueWithKey:key];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (value) &#123;</span><br><span class="line">        [<span class="keyword">self</span> _dbUpdateAccessTimeWithKey:key];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>最后看下磁盘缓存的目录结构：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/path/</span><br><span class="line">      /manifest.sqlite           </span><br><span class="line">      /manifest.sqlite-shm</span><br><span class="line">      /manifest.sqlite-wal</span><br><span class="line">      /data/</span><br><span class="line">           /e10adc3949ba59abbe56e057f20f883e</span><br><span class="line">           /e10adc3949ba59abbe56e057f20f883e</span><br><span class="line">      /trash/</span><br><span class="line">            /unused_file_or_folder</span><br></pre></td></tr></table></figure>

<p>manifest.sqlite,manifest.sqlite-shm,manifest.sqlite-wal 是数据库缓存记录相关的sqlite数据库文件，&#x2F;data&#x2F;目录是用于存储对应的文件缓存，&#x2F;trash&#x2F;则是和我们电脑的垃圾箱一样。</p>
<p><strong><strong>总结</strong></strong></p>
<p>其实大家看文章开始的那张图就啥都明白了，不明白抽我，抖机～～～～～～</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/iOS-%E5%BC%80%E6%BA%90%E5%BA%93%E5%88%86%E6%9E%90/">iOS 开源库分析</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/iOS-开源库分析/">iOS 开源库分析</a>
  </div>

</div>



<div class="comments-count">
	
	  	<span></span>
		<a href="/2019/11/22/YYCache-源码解析/#comments" class="ds-thread-count comments-count-link" data-thread-key="2019/11/22/YYCache-源码解析/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/11/20/YYModel-源码解析/" title="YYModel 源码解析" itemprop="url">YYModel 源码解析</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Edgar" target="_blank" itemprop="author">Edgar</a>
		
  <p class="article-time">
    <time datetime="2019-11-19T18:05:35.000Z" itemprop="datePublished"> Published 2019-11-20</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h5 id="开源库信息"><a href="#开源库信息" class="headerlink" title="开源库信息"></a>开源库信息</h5><p><a target="_blank" rel="noopener" href="https://github.com/ibireme/YYModel">YYModel</a></p>
<p>与同类开源库的性能对比：</p>
<p><img src="/2019/11/20/YYModel-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/00001.png"></p>
<p>YYModel是一个序列化和反序列化库，说得更直白一点就是将NSString,NSData,NSDictionary形式的数据转换为具体类型的对象，以及将具体类型的对象转换为NSDictionary。</p>
<p>我们在没有开始看源码之前，我们猜测下如果这件事情要做应该怎么做？</p>
<ul>
<li>将NSString,NSData,NSDictionary形式的数据转换为具体类型的对象</li>
</ul>
<p>首先我们需要将这些对象统一转换为NSDictionary，然后获取目标对象类的所有属性，创建一个目标对象，以目标对象的属性名为key到NSDictionary中去取值设置到目标对象上。最后返回这个对象。</p>
<ul>
<li>将具体类型的对象转换为NSDictionary</li>
</ul>
<p>这个其实是上一个过程的逆过程，首先需要获取当前对象类的信息，以及各个属性的getter&#x2F;setter方法，使用getter方法取出当前对象当前属性的值，然后再将属性名为key，属性值为value存到NSDictionary中返回。</p>
<p>当然这仅仅是大体的构想，过程中还有很多细节需要考虑到，比如key和属性名的映射，容器类型属性的元素类型的指定方式等，我们接下来就来看下这部分代码，YYModel代码量不大，只要记住上面两点就可以把握大致的一个方向，如果对runtime机制比较熟悉会有更多的帮助，但是即使不知道也不妨碍你对整个代码的理解。</p>
<h5 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h5><h5 id="1-JSON-to-Model"><a href="#1-JSON-to-Model" class="headerlink" title="1.JSON to Model"></a>1.JSON to Model</h5><p><strong><strong>1.1 转换前准备工作 – 将JSON统一成NSDictionary</strong></strong></p>
<p>将JSON结构转换为Model是通过yy_modelWithJSON方法转换的，这里的json可以是NSString,NSData,NSDictionary</p>
<figure class="highlight elm"><table><tr><td class="code"><pre><span class="line">+ (nullable instance<span class="keyword">type</span>)yy_modelWithJSON:(id)json;</span><br></pre></td></tr></table></figure>

<p>yy_modelWithJSON作为总的入口会将这些类型统一通过_yy_dictionaryWithJSON转换为NSDictionary，再调用yy_modelWithDictionary将NSDictionary转换为Model返回。</p>
<figure class="highlight elm"><table><tr><td class="code"><pre><span class="line">+ (instance<span class="keyword">type</span>)yy_modelWithJSON:(id)json &#123;</span><br><span class="line">    //将所有类型的数据都转换为<span class="type">NSDictionary</span>类型</span><br><span class="line">    <span class="type">NSDictionary</span> *dic = [self _yy_dictionaryWithJSON:json];</span><br><span class="line">    //将<span class="type">NSDictionary</span>类型转换为model</span><br><span class="line">    return [self yy_modelWithDictionary:dic];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">+ (<span class="built_in">NSDictionary</span> *)_yy_dictionaryWithJSON:(<span class="type">id</span>)json &#123;</span><br><span class="line">    <span class="keyword">if</span> (!json || json == (<span class="type">id</span>)kCFNull) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">NSDictionary</span> *dic = <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">NSData</span> *jsonData = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">if</span> ([json isKindOfClass:[<span class="built_in">NSDictionary</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        dic = json;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([json isKindOfClass:[<span class="built_in">NSString</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        jsonData = [(<span class="built_in">NSString</span> *)json dataUsingEncoding : <span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([json isKindOfClass:[<span class="built_in">NSData</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        jsonData = json;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//不论传入的json是NSDictionary，NSString还是NSData都将结果都转换为dic</span></span><br><span class="line">    <span class="keyword">if</span> (jsonData) &#123;</span><br><span class="line">        dic = [<span class="built_in">NSJSONSerialization</span> JSONObjectWithData:jsonData options:kNilOptions error:<span class="literal">NULL</span>];</span><br><span class="line">        <span class="keyword">if</span> (![dic isKindOfClass:[<span class="built_in">NSDictionary</span> <span class="keyword">class</span>]]) dic = <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dic;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>_yy_dictionaryWithJSON 这块没什么好介绍的如果是NSDictionary就直接返回，如果是NSString或者NSData都通过JSONObjectWithData 转化为 NSDictionary对象，如果是其他类型就直接返回nil。</p>
<p><strong><strong>1.2 将NSDictionary 转换为Model对象</strong></strong></p>
<p>接下来的yy_modelWithDictionary开始就比较重要了，这里就开始对Model类进行分析，提取出它的全部属性，以及各种信息。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">+ (<span class="keyword">instancetype</span>)yy_modelWithDictionary:(<span class="built_in">NSDictionary</span> *)dictionary &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!dictionary || dictionary == (<span class="type">id</span>)kCFNull) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">if</span> (![dictionary isKindOfClass:[<span class="built_in">NSDictionary</span> <span class="keyword">class</span>]]) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">    Class cls = [<span class="keyword">self</span> <span class="keyword">class</span>];</span><br><span class="line">    <span class="comment">//获取当前类的属性</span></span><br><span class="line">    _YYModelMeta *modelMeta = [_YYModelMeta metaWithClass:cls];</span><br><span class="line">    <span class="keyword">if</span> (modelMeta-&gt;_hasCustomClassFromDictionary) &#123;</span><br><span class="line">        <span class="comment">//根据dictionary来决定最后的cls</span></span><br><span class="line">        cls = [cls modelCustomClassForDictionary:dictionary] ?: cls;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 上面是获取当前类有哪些属性，哪些方法，以及实例方法，相当于建立了一个模版，</span></span><br><span class="line">    <span class="comment">// 就比方说我们定义了一个类，到上面为止，我们知道了它有a，b，c三个属性，每个属性的类型分别是NSString,NSInteger,BOOL 仅此而已，</span></span><br><span class="line">    <span class="comment">// 下面要做的就是创建出一个当前类的对象，并将传进来的字典里面的值赋给它的每个元素。这个在yy_modelSetWithDictionary中实现的。</span></span><br><span class="line">    <span class="built_in">NSObject</span> *one = [cls new];</span><br><span class="line">    <span class="keyword">if</span> ([one yy_modelSetWithDictionary:dictionary]) <span class="keyword">return</span> one;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><strong>1.2.1 提取Model信息</strong></strong></p>
<p>在上一个阶段将各种JSON格式转换为NSDictionary后，接下啦就从Model入手提取它的各种信息，我们看下_YYModelMeta的结构：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">_YYModelMeta</span> : <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">@package</span></span><br><span class="line">    YYClassInfo *_classInfo;                <span class="comment">//Model类的信息</span></span><br><span class="line">    <span class="comment">/// Key:mapped key and key path, Value:_YYModelPropertyMeta.</span></span><br><span class="line">    <span class="built_in">NSDictionary</span> *_mapper;                  <span class="comment">//所有属性的key和keyPath</span></span><br><span class="line">    <span class="comment">/// Array&lt;_YYModelPropertyMeta&gt;, all property meta of this model.</span></span><br><span class="line">    <span class="built_in">NSArray</span> *_allPropertyMetas;            <span class="comment">//所有属性的信息</span></span><br><span class="line">    <span class="comment">/// Array&lt;_YYModelPropertyMeta&gt;, property meta which is mapped to a key path.</span></span><br><span class="line">    <span class="built_in">NSArray</span> *_keyPathPropertyMetas;        <span class="comment">//属于keyPath的属性列表</span></span><br><span class="line">    <span class="comment">/// Array&lt;_YYModelPropertyMeta&gt;, property meta which is mapped to multi keys.</span></span><br><span class="line">    <span class="built_in">NSArray</span> *_multiKeysPropertyMetas;     <span class="comment">//一个属性多个key的属性列表</span></span><br><span class="line">    <span class="comment">/// The number of mapped key (and key path), same to _mapper.count.</span></span><br><span class="line">    <span class="built_in">NSUInteger</span> _keyMappedCount;           <span class="comment">//全部属性数量</span></span><br><span class="line">    <span class="comment">/// Model class type.</span></span><br><span class="line">    YYEncodingNSType _nsType;             <span class="comment">//Model类的对象</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//这个类实现覆盖方法的情况</span></span><br><span class="line">    <span class="type">BOOL</span> _hasCustomWillTransformFromDictionary;</span><br><span class="line">    <span class="type">BOOL</span> _hasCustomTransformFromDictionary;</span><br><span class="line">    <span class="type">BOOL</span> _hasCustomTransformToDictionary;</span><br><span class="line">    <span class="type">BOOL</span> _hasCustomClassFromDictionary;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>从_YYModelMeta结构中我们可以看到_YYModelMeta既有key与属性的映射关系，又有各个属性的Meta信息，所以基本上就可以通过明确知道字典中的每个key对应的value值对应的属性。只要有这个关系就可以将NSDictionary中的值映射到Model属性上。我们接下来看下这部分源码：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">+ (<span class="keyword">instancetype</span>)metaWithClass:(Class)cls &#123;</span><br><span class="line">    <span class="keyword">if</span> (!cls) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">CFMutableDictionaryRef</span> cache;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="keyword">static</span> dispatch_semaphore_t lock;</span><br><span class="line">    <span class="comment">//建立缓存</span></span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        cache = <span class="built_in">CFDictionaryCreateMutable</span>(<span class="built_in">CFAllocatorGetDefault</span>(), <span class="number">0</span>, &amp;kCFTypeDictionaryKeyCallBacks, &amp;kCFTypeDictionaryValueCallBacks);</span><br><span class="line">        lock = dispatch_semaphore_create(<span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//通过cls从缓存中取出meta</span></span><br><span class="line">    dispatch_semaphore_wait(lock, DISPATCH_TIME_FOREVER);</span><br><span class="line">    _YYModelMeta *meta = <span class="built_in">CFDictionaryGetValue</span>(cache, (__bridge <span class="keyword">const</span> <span class="type">void</span> *)(cls));</span><br><span class="line">    dispatch_semaphore_signal(lock);</span><br><span class="line">    <span class="comment">//如果之前没有缓存过或者缓存的信息需要更新</span></span><br><span class="line">    <span class="keyword">if</span> (!meta || meta-&gt;_classInfo.needUpdate) &#123;</span><br><span class="line">        <span class="comment">//通过cls 创建出一个 _YYModelMeta</span></span><br><span class="line">        meta = [[_YYModelMeta alloc] initWithClass:cls];</span><br><span class="line">        <span class="keyword">if</span> (meta) &#123;</span><br><span class="line">            <span class="comment">//将新建的_YYModelMeta添加到缓存供下次使用</span></span><br><span class="line">            dispatch_semaphore_wait(lock, DISPATCH_TIME_FOREVER);</span><br><span class="line">            <span class="built_in">CFDictionarySetValue</span>(cache, (__bridge <span class="keyword">const</span> <span class="type">void</span> *)(cls), (__bridge <span class="keyword">const</span> <span class="type">void</span> *)(meta));</span><br><span class="line">            dispatch_semaphore_signal(lock);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> meta;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在第一调用metaWithClass的时候会创建一个缓存，并且为这个缓存添加一个dispatch_semaphor信号量，为了避免每次都进行查询，这里会将每次查询的数据缓存到新建的缓存中，以加快查询速度。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithClass:(Class)cls &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//用于存储类的信息 包括当前类，父类，当前属性，实例变量，方法</span></span><br><span class="line">    YYClassInfo *classInfo = [YYClassInfo classInfoWithClass:cls];</span><br><span class="line">    <span class="keyword">if</span> (!classInfo) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="variable language_">super</span> init];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取属性黑名单</span></span><br><span class="line">    <span class="built_in">NSSet</span> *blacklist = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">if</span> ([cls respondsToSelector:<span class="keyword">@selector</span>(modelPropertyBlacklist)]) &#123;</span><br><span class="line">        <span class="built_in">NSArray</span> *properties = [(<span class="type">id</span>&lt;YYModel&gt;)cls modelPropertyBlacklist];</span><br><span class="line">        <span class="keyword">if</span> (properties) &#123;</span><br><span class="line">            blacklist = [<span class="built_in">NSSet</span> setWithArray:properties];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取属性白名单</span></span><br><span class="line">    <span class="built_in">NSSet</span> *whitelist = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">if</span> ([cls respondsToSelector:<span class="keyword">@selector</span>(modelPropertyWhitelist)]) &#123;</span><br><span class="line">        <span class="built_in">NSArray</span> *properties = [(<span class="type">id</span>&lt;YYModel&gt;)cls modelPropertyWhitelist];</span><br><span class="line">        <span class="keyword">if</span> (properties) &#123;</span><br><span class="line">            whitelist = [<span class="built_in">NSSet</span> setWithArray:properties];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取容器的元素对象，存储到genericMapper key为属性名 value为该容器类里面元素的类型</span></span><br><span class="line">    <span class="built_in">NSDictionary</span> *genericMapper = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">if</span> ([cls respondsToSelector:<span class="keyword">@selector</span>(modelContainerPropertyGenericClass)]) &#123;</span><br><span class="line">        genericMapper = [(<span class="type">id</span>&lt;YYModel&gt;)cls modelContainerPropertyGenericClass];</span><br><span class="line">        <span class="keyword">if</span> (genericMapper) &#123;</span><br><span class="line">            <span class="built_in">NSMutableDictionary</span> *tmp = [<span class="built_in">NSMutableDictionary</span> new];</span><br><span class="line">            [genericMapper enumerateKeysAndObjectsUsingBlock:^(<span class="type">id</span> key, <span class="type">id</span> obj, <span class="type">BOOL</span> *stop) &#123;</span><br><span class="line">                <span class="keyword">if</span> (![key isKindOfClass:[<span class="built_in">NSString</span> <span class="keyword">class</span>]]) <span class="keyword">return</span>;</span><br><span class="line">                Class meta = object_getClass(obj);</span><br><span class="line">                <span class="keyword">if</span> (!meta) <span class="keyword">return</span>;</span><br><span class="line">                <span class="keyword">if</span> (class_isMetaClass(meta)) &#123;</span><br><span class="line">                    <span class="comment">//key为属性名 value为该容器类里面元素的类型</span></span><br><span class="line">                    tmp[key] = obj;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([obj isKindOfClass:[<span class="built_in">NSString</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">                    Class cls = <span class="built_in">NSClassFromString</span>(obj);</span><br><span class="line">                    <span class="keyword">if</span> (cls) &#123;</span><br><span class="line">                        tmp[key] = cls;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;];</span><br><span class="line">            genericMapper = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSMutableDictionary</span> *allPropertyMetas = [<span class="built_in">NSMutableDictionary</span> new];</span><br><span class="line">    YYClassInfo *curClassInfo = classInfo;</span><br><span class="line">    <span class="comment">//遍历当前类及其父类的属性，</span></span><br><span class="line">    <span class="keyword">while</span> (curClassInfo &amp;&amp; curClassInfo.superCls != <span class="literal">nil</span>) &#123; <span class="comment">// recursive parse super class, but ignore root class (NSObject/NSProxy)</span></span><br><span class="line">        <span class="keyword">for</span> (YYClassPropertyInfo *propertyInfo <span class="keyword">in</span> curClassInfo.propertyInfos.allValues) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!propertyInfo.name) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//只有不在黑名单并且再白名单中的属性才会被加到allPropertyMetas</span></span><br><span class="line">            <span class="keyword">if</span> (blacklist &amp;&amp; [blacklist containsObject:propertyInfo.name]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (whitelist &amp;&amp; ![whitelist containsObject:propertyInfo.name]) <span class="keyword">continue</span>;</span><br><span class="line">            _YYModelPropertyMeta *meta = [_YYModelPropertyMeta metaWithClassInfo:classInfo</span><br><span class="line">                                                                    propertyInfo:propertyInfo</span><br><span class="line">                                                                         generic:genericMapper[propertyInfo.name]];</span><br><span class="line">            <span class="comment">//meta必须有值，并且有getter/setters</span></span><br><span class="line">            <span class="keyword">if</span> (!meta || !meta-&gt;_name) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (!meta-&gt;_<span class="keyword">getter</span> || !meta-&gt;_<span class="keyword">setter</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//已经存在allPropertyMetas中了则不再继续</span></span><br><span class="line">            <span class="keyword">if</span> (allPropertyMetas[meta-&gt;_name]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//将meta存到allPropertyMetas中</span></span><br><span class="line">            allPropertyMetas[meta-&gt;_name] = meta;</span><br><span class="line">        &#125;</span><br><span class="line">        curClassInfo = curClassInfo.superClassInfo;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (allPropertyMetas.count) _allPropertyMetas = allPropertyMetas.allValues.copy;</span><br><span class="line">    <span class="comment">//将所有的类属性都添加到allPropertyMetas</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 建立映射关系</span></span><br><span class="line">    <span class="built_in">NSMutableDictionary</span> *mapper = [<span class="built_in">NSMutableDictionary</span> new];</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *keyPathPropertyMetas = [<span class="built_in">NSMutableArray</span> new];</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *multiKeysPropertyMetas = [<span class="built_in">NSMutableArray</span> new];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//处理映射</span></span><br><span class="line">    <span class="keyword">if</span> ([cls respondsToSelector:<span class="keyword">@selector</span>(modelCustomPropertyMapper)]) &#123;</span><br><span class="line">        <span class="comment">//获得自定义映射字典，它用于解决json文件中关键字和定义的类的属性不一致的问题。</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         + (NSDictionary *) modelCustomPropertyMapper &#123;</span></span><br><span class="line"><span class="comment">            return @&#123;@&quot;errnoTest&quot;类属性 : @&quot;errno&quot;json中的字段&#125;;</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">        <span class="built_in">NSDictionary</span> *customMapper = [(<span class="type">id</span> &lt;YYModel&gt;)cls modelCustomPropertyMapper];</span><br><span class="line">        [customMapper enumerateKeysAndObjectsUsingBlock:^(<span class="built_in">NSString</span> *propertyName, <span class="built_in">NSString</span> *mappedToKey, <span class="type">BOOL</span> *stop) &#123;</span><br><span class="line">            <span class="comment">//取出原来key对应的属性信息</span></span><br><span class="line">            _YYModelPropertyMeta *propertyMeta = allPropertyMetas[propertyName];</span><br><span class="line">            <span class="keyword">if</span> (!propertyMeta) <span class="keyword">return</span>;</span><br><span class="line">            <span class="comment">//从allPropertyMetas移除</span></span><br><span class="line">            [allPropertyMetas removeObjectForKey:propertyName];</span><br><span class="line">            <span class="comment">//要被映射到的属性名字</span></span><br><span class="line">            <span class="keyword">if</span> ([mappedToKey isKindOfClass:[<span class="built_in">NSString</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mappedToKey.length == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">                <span class="comment">//只有一个key</span></span><br><span class="line">                propertyMeta-&gt;_mappedToKey = mappedToKey;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//去掉空keyPath</span></span><br><span class="line">                <span class="built_in">NSArray</span> *keyPath = [mappedToKey componentsSeparatedByString:<span class="string">@&quot;.&quot;</span>];</span><br><span class="line">                <span class="keyword">for</span> (<span class="built_in">NSString</span> *onePath <span class="keyword">in</span> keyPath) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (onePath.length == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="built_in">NSMutableArray</span> *tmp = keyPath.mutableCopy;</span><br><span class="line">                        [tmp removeObject:<span class="string">@&quot;&quot;</span>];</span><br><span class="line">                        keyPath = tmp;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (keyPath.count &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="comment">//有多个path的key，例如xxx.xxxx.xxx</span></span><br><span class="line">                    propertyMeta-&gt;_mappedToKeyPath = keyPath;</span><br><span class="line">                    [keyPathPropertyMetas addObject:propertyMeta];</span><br><span class="line">                &#125;</span><br><span class="line">                propertyMeta-&gt;_next = mapper[mappedToKey] ?: <span class="literal">nil</span>;</span><br><span class="line">                mapper[mappedToKey] = propertyMeta;</span><br><span class="line">                </span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([mappedToKey isKindOfClass:[<span class="built_in">NSArray</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="built_in">NSMutableArray</span> *mappedToKeyArray = [<span class="built_in">NSMutableArray</span> new];</span><br><span class="line">                <span class="keyword">for</span> (<span class="built_in">NSString</span> *oneKey <span class="keyword">in</span> ((<span class="built_in">NSArray</span> *)mappedToKey)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (![oneKey isKindOfClass:[<span class="built_in">NSString</span> <span class="keyword">class</span>]]) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span> (oneKey.length == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                    </span><br><span class="line">                    <span class="built_in">NSArray</span> *keyPath = [oneKey componentsSeparatedByString:<span class="string">@&quot;.&quot;</span>];</span><br><span class="line">                    <span class="keyword">if</span> (keyPath.count &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                        [mappedToKeyArray addObject:keyPath];</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        [mappedToKeyArray addObject:oneKey];</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">if</span> (!propertyMeta-&gt;_mappedToKey) &#123;</span><br><span class="line">                        propertyMeta-&gt;_mappedToKey = oneKey;</span><br><span class="line">                        propertyMeta-&gt;_mappedToKeyPath = keyPath.count &gt; <span class="number">1</span> ? keyPath : <span class="literal">nil</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!propertyMeta-&gt;_mappedToKey) <span class="keyword">return</span>;</span><br><span class="line">                </span><br><span class="line">                propertyMeta-&gt;_mappedToKeyArray = mappedToKeyArray;</span><br><span class="line">                [multiKeysPropertyMetas addObject:propertyMeta];</span><br><span class="line">                </span><br><span class="line">                propertyMeta-&gt;_next = mapper[mappedToKey] ?: <span class="literal">nil</span>;</span><br><span class="line">                mapper[mappedToKey] = propertyMeta;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//这些是上面还没处理的，处理后添加到mapper，所以mapper包含了全部的属性</span></span><br><span class="line">    [allPropertyMetas enumerateKeysAndObjectsUsingBlock:^(<span class="built_in">NSString</span> *name, _YYModelPropertyMeta *propertyMeta, <span class="type">BOOL</span> *stop) &#123;</span><br><span class="line">        propertyMeta-&gt;_mappedToKey = name;</span><br><span class="line">        <span class="comment">//如果有其他值绑定在同一个key上则将它赋给next</span></span><br><span class="line">        propertyMeta-&gt;_next = mapper[name] ?: <span class="literal">nil</span>;</span><br><span class="line">        <span class="comment">//将属性添加到mapper</span></span><br><span class="line">        mapper[name] = propertyMeta;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将上述的属性信息添加到_mapper以及_keyPathPropertyMetas，_multiKeysPropertyMetas</span></span><br><span class="line">    <span class="keyword">if</span> (mapper.count) _mapper = mapper;</span><br><span class="line">    <span class="keyword">if</span> (keyPathPropertyMetas) _keyPathPropertyMetas = keyPathPropertyMetas;</span><br><span class="line">    <span class="keyword">if</span> (multiKeysPropertyMetas) _multiKeysPropertyMetas = multiKeysPropertyMetas;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//赋值到对应的属性上</span></span><br><span class="line">    _classInfo = classInfo;</span><br><span class="line">    _keyMappedCount = _allPropertyMetas.count;</span><br><span class="line">    _nsType = YYClassGetNSType(cls);</span><br><span class="line">    _hasCustomWillTransformFromDictionary = ([cls instancesRespondToSelector:<span class="keyword">@selector</span>(modelCustomWillTransformFromDictionary:)]);</span><br><span class="line">    _hasCustomTransformFromDictionary = ([cls instancesRespondToSelector:<span class="keyword">@selector</span>(modelCustomTransformFromDictionary:)]);</span><br><span class="line">    _hasCustomTransformToDictionary = ([cls instancesRespondToSelector:<span class="keyword">@selector</span>(modelCustomTransformToDictionary:)]);</span><br><span class="line">    _hasCustomClassFromDictionary = ([cls respondsToSelector:<span class="keyword">@selector</span>(modelCustomClassForDictionary:)]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>嗯 是的 上面是_YYModelMeta的构造方法，哈哈，长吧。在_YYModelMeta的构造方法中主要是负责填充前面介绍过的_YYModelMeta中的属性。我们接下来将它拆成一段一段进行介绍：</p>
<ul>
<li><strong><strong>获取当前类的属性信息</strong></strong></li>
</ul>
<figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用于存储类的信息 包括当前类，父类，当前属性，实例变量，方法</span></span><br><span class="line">YYClassInfo *classInfo = [YYClassInfo classInfoWithClass:<span class="keyword">cls</span>];</span><br><span class="line"><span class="keyword">if</span> (!classInfo) <span class="keyword">return</span> nil;</span><br></pre></td></tr></table></figure>

<p>如果看过runtime源码的同学应该对接下来的这部分代码理解会比较透彻，如果不属性也无防在这里先了解下，后面看runtime的代码的时候会恍然大悟，看源码其实很多时候第一遍可能理解的只是一个大概，不要太去纠结细节，后面在某项技术补上后，或者在项目上遇到类似的问题的时候会有更深的理解，所以看不懂埋着头看下去，一遍不行，再来一遍，就是这种傻办法慢慢积累。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YYClassInfo</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>, <span class="keyword">readonly</span>) Class cls; <span class="comment">///&lt; //当前YYClassInfo 所对应的cls</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">assign</span>, <span class="keyword">readonly</span>) Class superCls; <span class="comment">///&lt; 当前类的父类</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">assign</span>, <span class="keyword">readonly</span>) Class metaCls;  <span class="comment">///&lt; 当前类的meta对象</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="type">BOOL</span> isMeta; <span class="comment">///&lt; 当前类是否是meta类</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="built_in">NSString</span> *name; <span class="comment">///&lt; 类名</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) YYClassInfo *superClassInfo; <span class="comment">///&lt; 父类信息</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, YYClassIvarInfo *&gt; *ivarInfos; <span class="comment">///&lt; 实例变量信息</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, YYClassMethodInfo *&gt; *methodInfos; <span class="comment">///&lt; 方法信息</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, YYClassPropertyInfo *&gt; *propertyInfos; <span class="comment">///&lt; 属性信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//.......</span></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>接下来看下classInfoWithClass：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">+ (<span class="keyword">instancetype</span>)classInfoWithClass:(Class)cls &#123;</span><br><span class="line">    <span class="keyword">if</span> (!cls) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    <span class="comment">//........</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建缓存</span></span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        classCache = <span class="built_in">CFDictionaryCreateMutable</span>(<span class="built_in">CFAllocatorGetDefault</span>(), <span class="number">0</span>, &amp;kCFTypeDictionaryKeyCallBacks, &amp;kCFTypeDictionaryValueCallBacks);</span><br><span class="line">        metaCache = <span class="built_in">CFDictionaryCreateMutable</span>(<span class="built_in">CFAllocatorGetDefault</span>(), <span class="number">0</span>, &amp;kCFTypeDictionaryKeyCallBacks, &amp;kCFTypeDictionaryValueCallBacks);</span><br><span class="line">        lock = dispatch_semaphore_create(<span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//获取class信息</span></span><br><span class="line">    dispatch_semaphore_wait(lock, DISPATCH_TIME_FOREVER);</span><br><span class="line">    YYClassInfo *info = <span class="built_in">CFDictionaryGetValue</span>(class_isMetaClass(cls) ? metaCache : classCache, (__bridge <span class="keyword">const</span> <span class="type">void</span> *)(cls));</span><br><span class="line">    <span class="comment">//查看是否需要更新，如果需要更新的话则调用info的_update方法</span></span><br><span class="line">    <span class="keyword">if</span> (info &amp;&amp; info-&gt;_needUpdate) &#123;</span><br><span class="line">        [info _update];</span><br><span class="line">    &#125;</span><br><span class="line">    dispatch_semaphore_signal(lock);</span><br><span class="line">    <span class="comment">//如果缓存没有则新建后添加到缓存中</span></span><br><span class="line">    <span class="keyword">if</span> (!info) &#123;</span><br><span class="line">        info = [[YYClassInfo alloc] initWithClass:cls];</span><br><span class="line">        <span class="keyword">if</span> (info) &#123;</span><br><span class="line">            dispatch_semaphore_wait(lock, DISPATCH_TIME_FOREVER);</span><br><span class="line">            <span class="built_in">CFDictionarySetValue</span>(info.isMeta ? metaCache : classCache, (__bridge <span class="keyword">const</span> <span class="type">void</span> *)(cls), (__bridge <span class="keyword">const</span> <span class="type">void</span> *)(info));</span><br><span class="line">            dispatch_semaphore_signal(lock);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> info;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>嗯，熟悉吧，还是使用了缓存，很明显数据的序列化其实是一个特别频繁的任务，基本上每次网络请求回来后都需要经过序列化后进行交付，如果每次都进行类信息的提取将会是很影响性能的任务。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)initWithClass:(Class)cls &#123;</span><br><span class="line">    <span class="keyword">if</span> (!cls) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="variable language_">super</span> init];</span><br><span class="line">    _cls = cls;</span><br><span class="line">    _superCls = class_getSuperclass(cls);</span><br><span class="line">    _isMeta = class_isMetaClass(cls);</span><br><span class="line">    <span class="keyword">if</span> (!_isMeta) &#123;</span><br><span class="line">        _metaCls = objc_getMetaClass(class_getName(cls));</span><br><span class="line">    &#125;</span><br><span class="line">    _name = <span class="built_in">NSStringFromClass</span>(cls);</span><br><span class="line">    [<span class="keyword">self</span> _update];</span><br><span class="line">    _superClassInfo = [<span class="keyword">self</span>.class classInfoWithClass:_superCls];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)_update &#123;</span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line">    </span><br><span class="line">    Class cls = <span class="keyword">self</span>.cls;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> methodCount = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//获取当前类的方法数</span></span><br><span class="line">    Method *methods = class_copyMethodList(cls, &amp;methodCount);</span><br><span class="line">    <span class="keyword">if</span> (methods) &#123;</span><br><span class="line">        <span class="built_in">NSMutableDictionary</span> *methodInfos = [<span class="built_in">NSMutableDictionary</span> new];</span><br><span class="line">        _methodInfos = methodInfos;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; methodCount; i++) &#123;</span><br><span class="line">            YYClassMethodInfo *info = [[YYClassMethodInfo alloc] initWithMethod:methods[i]];</span><br><span class="line">            <span class="comment">//key --&gt; 方法名  value 方法信息</span></span><br><span class="line">            <span class="keyword">if</span> (info.name) methodInfos[info.name] = info;</span><br><span class="line">        &#125;</span><br><span class="line">        free(methods);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取当前的属性</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> propertyCount = <span class="number">0</span>;</span><br><span class="line">    objc_property_t *properties = class_copyPropertyList(cls, &amp;propertyCount);</span><br><span class="line">    <span class="keyword">if</span> (properties) &#123;</span><br><span class="line">        <span class="built_in">NSMutableDictionary</span> *propertyInfos = [<span class="built_in">NSMutableDictionary</span> new];</span><br><span class="line">        _propertyInfos = propertyInfos;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; propertyCount; i++) &#123;</span><br><span class="line">            YYClassPropertyInfo *info = [[YYClassPropertyInfo alloc] initWithProperty:properties[i]];</span><br><span class="line">            <span class="comment">//key --&gt; 属性名  value 属性信息</span></span><br><span class="line">            <span class="keyword">if</span> (info.name) propertyInfos[info.name] = info;</span><br><span class="line">        &#125;</span><br><span class="line">        free(properties);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取当前对象的实例变量</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> ivarCount = <span class="number">0</span>;</span><br><span class="line">    Ivar *ivars = class_copyIvarList(cls, &amp;ivarCount);</span><br><span class="line">    <span class="keyword">if</span> (ivars) &#123;</span><br><span class="line">        <span class="built_in">NSMutableDictionary</span> *ivarInfos = [<span class="built_in">NSMutableDictionary</span> new];</span><br><span class="line">        _ivarInfos = ivarInfos;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; ivarCount; i++) &#123;</span><br><span class="line">            YYClassIvarInfo *info = [[YYClassIvarInfo alloc] initWithIvar:ivars[i]];</span><br><span class="line">            <span class="keyword">if</span> (info.name) ivarInfos[info.name] = info;</span><br><span class="line">        &#125;</span><br><span class="line">        free(ivars);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="comment">//更新结束</span></span><br><span class="line">    _needUpdate = <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面一整段代码就是负责使用runtime方法提取class中的属性信息，实例遍历信息，方法信息，父类信息等，</p>
<ul>
<li><strong><strong>通过属性黑白名单对属性进行过滤</strong></strong></li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取属性黑名单</span></span><br><span class="line"><span class="built_in">NSSet</span> *blacklist = <span class="literal">nil</span>;</span><br><span class="line"><span class="keyword">if</span> ([cls respondsToSelector:<span class="keyword">@selector</span>(modelPropertyBlacklist)]) &#123;</span><br><span class="line">    <span class="built_in">NSArray</span> *properties = [(<span class="type">id</span>&lt;YYModel&gt;)cls modelPropertyBlacklist];</span><br><span class="line">    <span class="keyword">if</span> (properties) &#123;</span><br><span class="line">        blacklist = [<span class="built_in">NSSet</span> setWithArray:properties];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取属性白名单</span></span><br><span class="line"><span class="built_in">NSSet</span> *whitelist = <span class="literal">nil</span>;</span><br><span class="line"><span class="keyword">if</span> ([cls respondsToSelector:<span class="keyword">@selector</span>(modelPropertyWhitelist)]) &#123;</span><br><span class="line">    <span class="built_in">NSArray</span> *properties = [(<span class="type">id</span>&lt;YYModel&gt;)cls modelPropertyWhitelist];</span><br><span class="line">    <span class="keyword">if</span> (properties) &#123;</span><br><span class="line">        whitelist = [<span class="built_in">NSSet</span> setWithArray:properties];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取容器的元素对象，存储到genericMapper key为属性名 value为该容器类里面元素的类型</span></span><br><span class="line"><span class="built_in">NSDictionary</span> *genericMapper = <span class="literal">nil</span>;</span><br><span class="line"><span class="keyword">if</span> ([cls respondsToSelector:<span class="keyword">@selector</span>(modelContainerPropertyGenericClass)]) &#123;</span><br><span class="line">    genericMapper = [(<span class="type">id</span>&lt;YYModel&gt;)cls modelContainerPropertyGenericClass];</span><br><span class="line">    <span class="keyword">if</span> (genericMapper) &#123;</span><br><span class="line">        <span class="built_in">NSMutableDictionary</span> *tmp = [<span class="built_in">NSMutableDictionary</span> new];</span><br><span class="line">        [genericMapper enumerateKeysAndObjectsUsingBlock:^(<span class="type">id</span> key, <span class="type">id</span> obj, <span class="type">BOOL</span> *stop) &#123;</span><br><span class="line">            <span class="keyword">if</span> (![key isKindOfClass:[<span class="built_in">NSString</span> <span class="keyword">class</span>]]) <span class="keyword">return</span>;</span><br><span class="line">            Class meta = object_getClass(obj);</span><br><span class="line">            <span class="keyword">if</span> (!meta) <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">if</span> (class_isMetaClass(meta)) &#123;</span><br><span class="line">                <span class="comment">//key为属性名 value为该容器类里面元素的类型</span></span><br><span class="line">                tmp[key] = obj;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([obj isKindOfClass:[<span class="built_in">NSString</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">                Class cls = <span class="built_in">NSClassFromString</span>(obj);</span><br><span class="line">                <span class="keyword">if</span> (cls) &#123;</span><br><span class="line">                    tmp[key] = cls;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;];</span><br><span class="line">        genericMapper = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="built_in">NSMutableDictionary</span> *allPropertyMetas = [<span class="built_in">NSMutableDictionary</span> new];</span><br><span class="line">YYClassInfo *curClassInfo = classInfo;</span><br><span class="line"><span class="comment">//遍历当前类及其父类的属性，</span></span><br><span class="line"><span class="keyword">while</span> (curClassInfo &amp;&amp; curClassInfo.superCls != <span class="literal">nil</span>) &#123; <span class="comment">// recursive parse super class, but ignore root class (NSObject/NSProxy)</span></span><br><span class="line">    <span class="keyword">for</span> (YYClassPropertyInfo *propertyInfo <span class="keyword">in</span> curClassInfo.propertyInfos.allValues) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!propertyInfo.name) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">//只有不在黑名单并且再白名单中的属性才会被加到allPropertyMetas</span></span><br><span class="line">        <span class="keyword">if</span> (blacklist &amp;&amp; [blacklist containsObject:propertyInfo.name]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (whitelist &amp;&amp; ![whitelist containsObject:propertyInfo.name]) <span class="keyword">continue</span>;</span><br><span class="line">        _YYModelPropertyMeta *meta = [_YYModelPropertyMeta metaWithClassInfo:classInfo</span><br><span class="line">                                                                propertyInfo:propertyInfo</span><br><span class="line">                                                                        generic:genericMapper[propertyInfo.name]];</span><br><span class="line">        <span class="comment">//meta必须有值，并且有getter/setters</span></span><br><span class="line">        <span class="keyword">if</span> (!meta || !meta-&gt;_name) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (!meta-&gt;_<span class="keyword">getter</span> || !meta-&gt;_<span class="keyword">setter</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">//已经存在allPropertyMetas中了则不再继续</span></span><br><span class="line">        <span class="keyword">if</span> (allPropertyMetas[meta-&gt;_name]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">//将meta存到allPropertyMetas中</span></span><br><span class="line">        allPropertyMetas[meta-&gt;_name] = meta;</span><br><span class="line">    &#125;</span><br><span class="line">    curClassInfo = curClassInfo.superClassInfo;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (allPropertyMetas.count) _allPropertyMetas = allPropertyMetas.allValues.copy;</span><br><span class="line"><span class="comment">//将所有的类属性都添加到allPropertyMetas</span></span><br></pre></td></tr></table></figure>

<p>上面代码虽然长但是完成的工作却很简单就是从类中提取出黑白名单，然后对当前类的全部属性，包括父对象在内的全部属性进行过滤，对于不在白名单，在黑名单的属性进行过滤。当中穿插了一个容器类元素对象类型的获取过程，如果我们的某个属性是容器对象：比如数组，元素类型这部分其实信息是丢失的。需要我们通过外部方式指定，YYmodel中会通过覆写modelContainerPropertyGenericClass方法，指定某个属性的元素类型。最终存放在genericMapper，在初始化_YYModelPropertyMeta的时候就可以通过属性最为key，查到对应的generic。添加到_YYModelProperty中。这里还必须注意每个属性都必须具备getter&#x2F;Setter 方法。最终将各个属性添加到_allPropertyMetas上。</p>
<p><strong><strong>1.2.2 提取Model信息</strong></strong></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 建立映射关系</span></span><br><span class="line"><span class="built_in">NSMutableDictionary</span> *mapper = [<span class="built_in">NSMutableDictionary</span> new];</span><br><span class="line"><span class="built_in">NSMutableArray</span> *keyPathPropertyMetas = [<span class="built_in">NSMutableArray</span> new];</span><br><span class="line"><span class="built_in">NSMutableArray</span> *multiKeysPropertyMetas = [<span class="built_in">NSMutableArray</span> new];</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理映射</span></span><br><span class="line"><span class="keyword">if</span> ([cls respondsToSelector:<span class="keyword">@selector</span>(modelCustomPropertyMapper)]) &#123;</span><br><span class="line">    <span class="comment">//获得自定义映射字典，它用于解决json文件中关键字和定义的类的属性不一致的问题。</span></span><br><span class="line">    <span class="built_in">NSDictionary</span> *customMapper = [(<span class="type">id</span> &lt;YYModel&gt;)cls modelCustomPropertyMapper];</span><br><span class="line">    [customMapper enumerateKeysAndObjectsUsingBlock:^(<span class="built_in">NSString</span> *propertyName, <span class="built_in">NSString</span> *mappedToKey, <span class="type">BOOL</span> *stop) &#123;</span><br><span class="line">        <span class="comment">//取出原来key对应的属性信息</span></span><br><span class="line">        _YYModelPropertyMeta *propertyMeta = allPropertyMetas[propertyName];</span><br><span class="line">        <span class="keyword">if</span> (!propertyMeta) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//从allPropertyMetas移除</span></span><br><span class="line">        [allPropertyMetas removeObjectForKey:propertyName];</span><br><span class="line">        <span class="keyword">if</span> ([mappedToKey isKindOfClass:[<span class="built_in">NSString</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mappedToKey.length == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">            <span class="comment">// 1.最简单的形式</span></span><br><span class="line">            propertyMeta-&gt;_mappedToKey = mappedToKey;</span><br><span class="line">            <span class="comment">//去掉空keyPath</span></span><br><span class="line">            <span class="built_in">NSArray</span> *keyPath = [mappedToKey componentsSeparatedByString:<span class="string">@&quot;.&quot;</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">NSString</span> *onePath <span class="keyword">in</span> keyPath) &#123;</span><br><span class="line">                <span class="keyword">if</span> (onePath.length == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">NSMutableArray</span> *tmp = keyPath.mutableCopy;</span><br><span class="line">                    [tmp removeObject:<span class="string">@&quot;&quot;</span>];</span><br><span class="line">                    keyPath = tmp;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (keyPath.count &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">//2. 有多个path的key，例如xxx.xxxx.xxx</span></span><br><span class="line">                propertyMeta-&gt;_mappedToKeyPath = keyPath;</span><br><span class="line">                <span class="comment">//添加到keyPathPropertyMetas</span></span><br><span class="line">                [keyPathPropertyMetas addObject:propertyMeta];</span><br><span class="line">            &#125;</span><br><span class="line">            propertyMeta-&gt;_next = mapper[mappedToKey] ?: <span class="literal">nil</span>;</span><br><span class="line">            mapper[mappedToKey] = propertyMeta;</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([mappedToKey isKindOfClass:[<span class="built_in">NSArray</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">            <span class="comment">//3.映射的对象是数组类型的时候</span></span><br><span class="line">            <span class="built_in">NSMutableArray</span> *mappedToKeyArray = [<span class="built_in">NSMutableArray</span> new];</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">NSString</span> *oneKey <span class="keyword">in</span> ((<span class="built_in">NSArray</span> *)mappedToKey)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (![oneKey isKindOfClass:[<span class="built_in">NSString</span> <span class="keyword">class</span>]]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (oneKey.length == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="built_in">NSArray</span> *keyPath = [oneKey componentsSeparatedByString:<span class="string">@&quot;.&quot;</span>];</span><br><span class="line">                <span class="keyword">if</span> (keyPath.count &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                    [mappedToKeyArray addObject:keyPath];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    [mappedToKeyArray addObject:oneKey];</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (!propertyMeta-&gt;_mappedToKey) &#123;</span><br><span class="line">                    propertyMeta-&gt;_mappedToKey = oneKey;</span><br><span class="line">                    propertyMeta-&gt;_mappedToKeyPath = keyPath.count &gt; <span class="number">1</span> ? keyPath : <span class="literal">nil</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!propertyMeta-&gt;_mappedToKey) <span class="keyword">return</span>;</span><br><span class="line">            <span class="comment">//添加到multiKeysPropertyMetas</span></span><br><span class="line">            propertyMeta-&gt;_mappedToKeyArray = mappedToKeyArray;</span><br><span class="line">            [multiKeysPropertyMetas addObject:propertyMeta];</span><br><span class="line">            </span><br><span class="line">            propertyMeta-&gt;_next = mapper[mappedToKey] ?: <span class="literal">nil</span>;</span><br><span class="line">            mapper[mappedToKey] = propertyMeta;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>我们结合下面的例子来解析上面的代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;n&quot;</span>:<span class="string">&quot;Harry Pottery&quot;</span>,</span><br><span class="line">    <span class="string">&quot;ext&quot;</span> : &#123;</span><br><span class="line">        <span class="string">&quot;desc&quot;</span> : <span class="string">&quot;A book written by J.K.Rowing.&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;ID&quot;</span> : <span class="number">100010</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (NSDictionary *)modelCustomPropertyMapper &#123;</span><br><span class="line">    <span class="keyword">return</span> @&#123;@<span class="string">&quot;name&quot;</span> : @<span class="string">&quot;n&quot;</span>,</span><br><span class="line"><span class="meta">             @<span class="string">&quot;desc&quot;</span> : @<span class="string">&quot;ext.desc&quot;</span>,</span></span><br><span class="line"><span class="meta">             @<span class="string">&quot;bookID&quot;</span> : @[@<span class="string">&quot;id&quot;</span>,@<span class="string">&quot;ID&quot;</span>,@<span class="string">&quot;book_id&quot;</span>]&#125;;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的例子三个属性分别对应代码中标出的1，2，3 三种例子，我们分别看这三种情况：</p>
<p><strong><strong>情况一 最简单的映射:</strong></strong></p>
<p>这种没啥好介绍的就是将modelCustomPropertyMapper对应的value存到propertyMeta-&gt;_mappedToKey</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.最简单的形式</span></span><br><span class="line"><span class="function"><span class="title">propertyMeta</span>-&gt;</span>_mappedToKey = mappedToKey;</span><br></pre></td></tr></table></figure>

<p><strong><strong>情况二 keyPath的映射:</strong></strong></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *keyPath = [mappedToKey componentsSeparatedByString:<span class="string">@&quot;.&quot;</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">NSString</span> *onePath <span class="keyword">in</span> keyPath) &#123;</span><br><span class="line">    <span class="keyword">if</span> (onePath.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">NSMutableArray</span> *tmp = keyPath.mutableCopy;</span><br><span class="line">        [tmp removeObject:<span class="string">@&quot;&quot;</span>];</span><br><span class="line">        keyPath = tmp;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (keyPath.count &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">//2. 有多个path的key，例如xxx.xxxx.xxx</span></span><br><span class="line">    propertyMeta-&gt;_mappedToKeyPath = keyPath;</span><br><span class="line">    <span class="comment">//添加到keyPathPropertyMetas</span></span><br><span class="line">    [keyPathPropertyMetas addObject:propertyMeta];</span><br><span class="line">&#125;</span><br><span class="line">propertyMeta-&gt;_next = mapper[mappedToKey] ?: <span class="literal">nil</span>;</span><br><span class="line">mapper[mappedToKey] = propertyMeta;</span><br></pre></td></tr></table></figure>
<p>这里和上面的区别是它会将类似ext.desc这种形式的路径转化为数组@[@”ext”,@”desc”],然后存到_mappedToKeyPath中并添加到keyPathPropertyMetas，以后如果要找到这种带路径的属性可以直接从keyPathPropertyMetas找。</p>
<p><strong><strong>情况三 多映射类型key的映射:</strong></strong></p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line"><span class="comment">//3.映射的对象是数组类型的时候</span></span><br><span class="line">NSMutableArray *mappedToKeyArray = [NSMutableArray new];</span><br><span class="line"><span class="keyword">for</span> (NSString *oneKey <span class="built_in">in</span> ((NSArray *)mappedToKey)) &#123;</span><br><span class="line">    <span class="comment">//........</span></span><br><span class="line">    NSArray *keyPath = [oneKey componentsSeparatedByString:@<span class="string">&quot;.&quot;</span>];</span><br><span class="line">    <span class="keyword">if</span> (keyPath.count &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        [mappedToKeyArray addObject:keyPath];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        [mappedToKeyArray addObject:oneKey];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//先填充_mappedToKey和_mappedToKeyPath</span></span><br><span class="line">    <span class="function"><span class="title">if</span> (!propertyMeta-&gt;</span>_mappedToKey) &#123;</span><br><span class="line">        <span class="function"><span class="title">propertyMeta</span>-&gt;</span>_mappedToKey = oneKey;</span><br><span class="line">        <span class="function"><span class="title">propertyMeta</span>-&gt;</span>_mappedToKeyPath = keyPath.count &gt; <span class="number">1</span> ? keyPath : <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">if</span> (!propertyMeta-&gt;</span>_mappedToKey) return;</span><br><span class="line"><span class="comment">//添加到multiKeysPropertyMetas</span></span><br><span class="line"><span class="function"><span class="title">propertyMeta</span>-&gt;</span>_mappedToKeyArray = mappedToKeyArray;</span><br><span class="line">[multiKeysPropertyMetas addObject:propertyMeta];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">propertyMeta</span>-&gt;</span>_next = mapper[mappedToKey] ?: <span class="literal">nil</span>;</span><br><span class="line">mapper[mappedToKey] = propertyMeta;</span><br></pre></td></tr></table></figure>

<p>我们拿 @”bookID” : @[@”id”,@”ID”,@”book_id”]作为例子，经过上面处理后propertyMeta-&gt;_mappedToKey &#x3D; @”ID”,propertyMeta-&gt;_mappedToKeyPath &#x3D; nil, propertyMeta-&gt;_mappedToKeyArray &#x3D; @[@”id”,@”ID”,@”book_id”] 最后propertyMeta会被添加到multiKeysPropertyMetas数组中。</p>
<p><strong><strong>情况四 其余不在modelCustomPropertyMapper中指定的映射:</strong></strong></p>
<figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line">[allPropertyMetas enumerateKeysAndObjectsUsingBlock:^(NSString *<span class="built_in">name</span>, <span class="variable">_YYModelPropertyMeta</span> *propertyMeta, BOOL *<span class="built_in">stop</span>) &#123;</span><br><span class="line">    propertyMeta-&gt;<span class="variable">_mappedToKey</span> = <span class="built_in">name</span>;</span><br><span class="line">    <span class="comment">//如果有其他值绑定在同一个key上则将它赋给next</span></span><br><span class="line">    propertyMeta-&gt;<span class="variable">_next</span> = mapper[<span class="built_in">name</span>] ?: <span class="literal">nil</span>;</span><br><span class="line">    <span class="comment">//将属性添加到mapper</span></span><br><span class="line">    mapper[<span class="built_in">name</span>] = propertyMeta;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<p>上面三种情况都是处理在modelCustomPropertyMapper中特别指定的属性，而上面的这种情况是没有特殊指定的属性，这种情况下就是将属性名赋给_mappedToKey。</p>
<p>综上几种情况，所有的映射关系都存在于_mappedToKey，_mappedToKeyPath，_mappedToKeyArray这三个属性中,比如下面这种情况：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Model:</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Book</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSString</span> *test;</span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSString</span> *desc;</span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSString</span> *bookID;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Book</span></span></span><br><span class="line">+ (<span class="built_in">NSDictionary</span> *)modelCustomPropertyMapper &#123;</span><br><span class="line">    <span class="keyword">return</span> @&#123;<span class="string">@&quot;name&quot;</span> : <span class="string">@&quot;n&quot;</span>,</span><br><span class="line">             <span class="string">@&quot;desc&quot;</span> : <span class="string">@&quot;ext.desc&quot;</span>,</span><br><span class="line">             <span class="string">@&quot;bookID&quot;</span> : @[<span class="string">@&quot;id&quot;</span>,<span class="string">@&quot;ID&quot;</span>,<span class="string">@&quot;book_id&quot;</span>]&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>属性name的_mappedToKey &#x3D; @”n”,_mappedToKeyPath &#x3D; nil,_mappedToKeyArray &#x3D; nil<br>属性test的_mappedToKey &#x3D; @”test”,_mappedToKeyPath &#x3D; nil,_mappedToKeyArray &#x3D; nil<br>属性desc的_mappedToKey &#x3D; @”ext.desc”,_mappedToKeyPath &#x3D; @[@”ext”,@”desc”],_mappedToKeyArray &#x3D; nil<br>属性bookID的_mappedToKey &#x3D; @”id”,_mappedToKeyPath &#x3D; nil ,_mappedToKeyArray &#x3D; @[@”id”,@”ID”,@”book_id”]</p>
<p><strong><strong>1.2.3 使用NSDictionary的数据填充Model</strong></strong></p>
<p>我们前面已经获取到了Model类的class结构信息，并且完成了属性黑白名单的过滤，以及属性名和JSON中字段名的对应关系，接下来我们就可以使用Model 类创建出一个Model,并从JSON (NSDictionary)中取出对应的值，对Model对象进行填充，最后再将生成的model对象返回就完成了整个序列化过程,这部分代码位于<strong><strong>yy_modelSetWithDictionary</strong></strong>：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">BOOL</span>)yy_modelSetWithDictionary:(<span class="built_in">NSDictionary</span> *)dic &#123;</span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line">    _YYModelMeta *modelMeta = [_YYModelMeta metaWithClass:object_getClass(<span class="keyword">self</span>)];</span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line">    <span class="comment">//构建context 上下文中包括modelMeta model的各种映射信息，model 要填充的model对象， dictionary 包含数据的字典</span></span><br><span class="line">    ModelSetContext context = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    context.modelMeta = (__bridge <span class="type">void</span> *)(modelMeta);</span><br><span class="line">    context.model = (__bridge <span class="type">void</span> *)(<span class="keyword">self</span>);</span><br><span class="line">    context.dictionary = (__bridge <span class="type">void</span> *)(dic);</span><br><span class="line">    <span class="comment">//开始将dictionary数据填充到model上，这里最关键的就是ModelSetWithPropertyMetaArrayFunction方法。</span></span><br><span class="line">    <span class="keyword">if</span> (modelMeta-&gt;_keyMappedCount &gt;= <span class="built_in">CFDictionaryGetCount</span>((<span class="built_in">CFDictionaryRef</span>)dic)) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">CFDictionaryApplyFunction</span>((<span class="built_in">CFDictionaryRef</span>)dic, ModelSetWithDictionaryFunction, &amp;context);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (modelMeta-&gt;_keyPathPropertyMetas) &#123;</span><br><span class="line">            <span class="built_in">CFArrayApplyFunction</span>((<span class="built_in">CFArrayRef</span>)modelMeta-&gt;_keyPathPropertyMetas,</span><br><span class="line">                                 <span class="built_in">CFRangeMake</span>(<span class="number">0</span>, <span class="built_in">CFArrayGetCount</span>((<span class="built_in">CFArrayRef</span>)modelMeta-&gt;_keyPathPropertyMetas)),</span><br><span class="line">                                 ModelSetWithPropertyMetaArrayFunction,</span><br><span class="line">                                 &amp;context);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (modelMeta-&gt;_multiKeysPropertyMetas) &#123;</span><br><span class="line">            <span class="built_in">CFArrayApplyFunction</span>((<span class="built_in">CFArrayRef</span>)modelMeta-&gt;_multiKeysPropertyMetas,</span><br><span class="line">                                 <span class="built_in">CFRangeMake</span>(<span class="number">0</span>, <span class="built_in">CFArrayGetCount</span>((<span class="built_in">CFArrayRef</span>)modelMeta-&gt;_multiKeysPropertyMetas)),</span><br><span class="line">                                 ModelSetWithPropertyMetaArrayFunction,</span><br><span class="line">                                 &amp;context);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">CFArrayApplyFunction</span>((<span class="built_in">CFArrayRef</span>)modelMeta-&gt;_allPropertyMetas,</span><br><span class="line">                             <span class="built_in">CFRangeMake</span>(<span class="number">0</span>, modelMeta-&gt;_keyMappedCount),</span><br><span class="line">                             ModelSetWithPropertyMetaArrayFunction,</span><br><span class="line">                             &amp;context);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//........</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们先来看下：</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">CFDictionaryApplyFunction((<span class="name">CFDictionaryRef</span>)dic, ModelSetWithDictionaryFunction, <span class="symbol">&amp;context</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>它实际上是对dic，也就是当前JSON所对应的NSDictionary的所有元素，应用ModelSetWithDictionaryFunction方法,并在每次调用中将context传递进去，下面是<strong><strong>ModelSetWithDictionaryFunction</strong></strong>的定义：CFDictionaryApplyFunction 会将NSDictionary中的每个元素的key，作为ModelSetWithDictionaryFunction第一个参数，value作为第二个参数，最后是一个context用户存对应的公共数据。比如这里的modelMeta，model，dictionary，<strong><strong>ModelSetWithDictionaryFunction</strong></strong>就是将dictionary各个元素取出来，使用key的映射关系来找到modelMeta中的属性meta，取出dictionary中的值通过属性meta中的setter将值设置到model中。我们来看下这部分代码：</p>
<figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line">static void ModelSetWithDictionaryFunction(const void *<span class="variable">_key</span>, const void *<span class="variable">_value</span>, void *<span class="variable">_context</span>) &#123;</span><br><span class="line">    ModelSetContext *context = <span class="variable">_context</span>;</span><br><span class="line">    <span class="variable">__unsafe_unretained</span> <span class="variable">_YYModelMeta</span> *meta = (<span class="variable">__bridge</span> <span class="variable">_YYModelMeta</span> *)(context-&gt;modelMeta);</span><br><span class="line">    <span class="comment">//取出单个属性</span></span><br><span class="line">    <span class="variable">__unsafe_unretained</span> <span class="variable">_YYModelPropertyMeta</span> *propertyMeta = [meta-&gt;<span class="variable">_mapper</span> objectForKey:(<span class="variable">__bridge</span> id)(<span class="variable">_key</span>)];</span><br><span class="line">    <span class="comment">//取出model</span></span><br><span class="line">    <span class="variable">__unsafe_unretained</span> id model = (<span class="variable">__bridge</span> id)(context-&gt;model);</span><br><span class="line">    <span class="keyword">while</span> (propertyMeta) &#123;</span><br><span class="line">        <span class="keyword">if</span> (propertyMeta-&gt;<span class="variable">_setter</span>) &#123;</span><br><span class="line">            <span class="comment">//将从dictionary中获取到的某个值赋给某个model对象的某个属性</span></span><br><span class="line">            ModelSetValueForProperty(model<span class="comment">/*对象*/</span>, (<span class="variable">__bridge</span> <span class="variable">__unsafe_unretained</span> id)<span class="variable">_value</span><span class="comment">/*某个属性的值*/</span>, propertyMeta<span class="comment">/*属性信息*/</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        propertyMeta = propertyMeta-&gt;<span class="variable">_next</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于_keyPathPropertyMetas 以及 _multiKeysPropertyMetas通过调用ModelSetWithPropertyMetaArrayFunction来设置的，最终也是归到<strong><strong>ModelSetValueForProperty</strong></strong></p>
<figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line">static void ModelSetWithPropertyMetaArrayFunction(const void *<span class="variable">_propertyMeta</span>, void *<span class="variable">_context</span>) &#123;</span><br><span class="line">    ModelSetContext *context = <span class="variable">_context</span>;</span><br><span class="line">    <span class="variable">__unsafe_unretained</span> NSDictionary *dictionary = (<span class="variable">__bridge</span> NSDictionary *)(context-&gt;dictionary);</span><br><span class="line">    <span class="variable">__unsafe_unretained</span> <span class="variable">_YYModelPropertyMeta</span> *propertyMeta = (<span class="variable">__bridge</span> <span class="variable">_YYModelPropertyMeta</span> *)(<span class="variable">_propertyMeta</span>);</span><br><span class="line">    <span class="keyword">if</span> (!propertyMeta-&gt;<span class="variable">_setter</span>) return;</span><br><span class="line">    id value = <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//通过属性信息里面的key的映射关系拿到字典里面对应的value值。</span></span><br><span class="line">    <span class="keyword">if</span> (propertyMeta-&gt;<span class="variable">_mappedToKeyArray</span>) &#123;</span><br><span class="line">        value = YYValueForMultiKeys(dictionary, propertyMeta-&gt;<span class="variable">_mappedToKeyArray</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (propertyMeta-&gt;<span class="variable">_mappedToKeyPath</span>) &#123;</span><br><span class="line">        value = YYValueForKeyPath(dictionary, propertyMeta-&gt;<span class="variable">_mappedToKeyPath</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        value = [dictionary objectForKey:propertyMeta-&gt;<span class="variable">_mappedToKey</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将value赋给model中的属性</span></span><br><span class="line">    <span class="keyword">if</span> (value) &#123;</span><br><span class="line">        <span class="variable">__unsafe_unretained</span> id model = (<span class="variable">__bridge</span> id)(context-&gt;model);</span><br><span class="line">        ModelSetValueForProperty(model, value, propertyMeta);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ModelSetValueForProperty是整个库中算得上是比较长的代码了，之所以长是因为类型比较多？我们取其中简单的一种作为例子—- JSON中的某个值为字符类型，Model中的某个属性为NSString,或者NSMutableString类型，这时候通过objc_msgSend 完 model中调用对应属性的setter方法将值设置到model上。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">void</span> ModelSetValueForProperty(__<span class="keyword">unsafe_unretained</span> <span class="type">id</span> model,</span><br><span class="line">                                     __<span class="keyword">unsafe_unretained</span> <span class="type">id</span> value,</span><br><span class="line">                                     __<span class="keyword">unsafe_unretained</span> _YYModelPropertyMeta *meta) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取meta的的类型，也就是要将字典里面的值，转成的目标类型。这里为什么用objc_msgSend，是因为可能有些属性会自定义不同的setter。</span></span><br><span class="line">    <span class="keyword">if</span> (meta-&gt;_isCNumber) &#123;</span><br><span class="line">        <span class="comment">//.....</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (meta-&gt;_nsType) &#123;</span><br><span class="line">        <span class="keyword">if</span> (value == (<span class="type">id</span>)kCFNull) &#123;</span><br><span class="line">            <span class="comment">//......</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">switch</span> (meta-&gt;_nsType) &#123;</span><br><span class="line">                <span class="keyword">case</span> YYEncodingTypeNSString:</span><br><span class="line">                <span class="keyword">case</span> YYEncodingTypeNSMutableString: &#123;</span><br><span class="line">                    <span class="keyword">if</span> ([value isKindOfClass:[<span class="built_in">NSString</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (meta-&gt;_nsType == YYEncodingTypeNSString) &#123;</span><br><span class="line">                            ((<span class="type">void</span> (*)(<span class="type">id</span>, SEL, <span class="type">id</span>))(<span class="type">void</span> *) objc_msgSend)((<span class="type">id</span>)model, meta-&gt;_<span class="keyword">setter</span>, value);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            ((<span class="type">void</span> (*)(<span class="type">id</span>, SEL, <span class="type">id</span>))(<span class="type">void</span> *) objc_msgSend)((<span class="type">id</span>)model, meta-&gt;_<span class="keyword">setter</span>, ((<span class="built_in">NSString</span> *)value).mutableCopy);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; </span><br><span class="line">                <span class="comment">//......</span></span><br><span class="line">                <span class="keyword">default</span>: <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-Model-to-JSON"><a href="#2-Model-to-JSON" class="headerlink" title="2. Model to JSON"></a>2. Model to JSON</h5><p>在yy_modelToJSONObject方法的开头有下面一段注释：</p>
<blockquote>
<p>Apple said:<br>The top level object is an NSArray or NSDictionary.<br>All objects are instances of NSString, NSNumber, NSArray, NSDictionary, or NSNull.<br>All dictionary keys are instances of NSString.<br>Numbers are not NaN or infinity.</p>
</blockquote>
<p>翻译成中文就是，标准的JSON顶层是一个NSArray或者NSDictionary，并且所有的对象都是NSString，NSNumber，NSArray，NSDictionary，NSNull这些类的实例，并且字典中的key都是NSString类型的实例，数值都是非NaN或者无穷，这其实大家都比较清楚这里强调下对后续代码的理解会有一定的帮助，我们继续看下怎么将Model转换为NSDictionary Model，入口是<strong><strong>yy_modelToJSONObject</strong></strong></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">id</span>)yy_modelToJSONObject &#123;</span><br><span class="line">    <span class="type">id</span> jsonObject = ModelToJSONObjectRecursive(<span class="keyword">self</span>);</span><br><span class="line">    <span class="keyword">if</span> ([jsonObject isKindOfClass:[<span class="built_in">NSArray</span> <span class="keyword">class</span>]]) <span class="keyword">return</span> jsonObject;</span><br><span class="line">    <span class="keyword">if</span> ([jsonObject isKindOfClass:[<span class="built_in">NSDictionary</span> <span class="keyword">class</span>]]) <span class="keyword">return</span> jsonObject;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在yy_modelToJSONObject方法中就先调用ModelToJSONObjectRecursive来递归地将当前对象转换为jsonObject，只有顶层对象是NSArray和NSDictionary才返回，否则都是nil。因此最关键的转换应该在ModelToJSONObjectRecursive方法中。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="type">id</span> ModelToJSONObjectRecursive(<span class="built_in">NSObject</span> *model) &#123;</span><br><span class="line">    <span class="comment">// 对于简单的NSString，NSNumber，nill类型</span></span><br><span class="line">    <span class="keyword">if</span> (!model || model == (<span class="type">id</span>)kCFNull) <span class="keyword">return</span> model;</span><br><span class="line">    <span class="keyword">if</span> ([model isKindOfClass:[<span class="built_in">NSString</span> <span class="keyword">class</span>]]) <span class="keyword">return</span> model;</span><br><span class="line">    <span class="keyword">if</span> ([model isKindOfClass:[<span class="built_in">NSNumber</span> <span class="keyword">class</span>]]) <span class="keyword">return</span> model;</span><br><span class="line">    <span class="keyword">if</span> ([model isKindOfClass:[<span class="built_in">NSURL</span> <span class="keyword">class</span>]]) <span class="keyword">return</span> ((<span class="built_in">NSURL</span> *)model).absoluteString;</span><br><span class="line">    <span class="keyword">if</span> ([model isKindOfClass:[<span class="built_in">NSAttributedString</span> <span class="keyword">class</span>]]) <span class="keyword">return</span> ((<span class="built_in">NSAttributedString</span> *)model).string;</span><br><span class="line">    <span class="keyword">if</span> ([model isKindOfClass:[<span class="built_in">NSDate</span> <span class="keyword">class</span>]]) <span class="keyword">return</span> [YYISODateFormatter() stringFromDate:(<span class="type">id</span>)model];</span><br><span class="line">    <span class="keyword">if</span> ([model isKindOfClass:[<span class="built_in">NSData</span> <span class="keyword">class</span>]]) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果当前对象是NSDictionary</span></span><br><span class="line">    <span class="keyword">if</span> ([model isKindOfClass:[<span class="built_in">NSDictionary</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="comment">// 简单的字典</span></span><br><span class="line">        <span class="keyword">if</span> ([<span class="built_in">NSJSONSerialization</span> isValidJSONObject:model]) <span class="keyword">return</span> model;</span><br><span class="line">        <span class="comment">// 对象是复杂的对象</span></span><br><span class="line">        <span class="built_in">NSMutableDictionary</span> *newDic = [<span class="built_in">NSMutableDictionary</span> new];</span><br><span class="line">        [((<span class="built_in">NSDictionary</span> *)model) enumerateKeysAndObjectsUsingBlock:^(<span class="built_in">NSString</span> *key, <span class="type">id</span> obj, <span class="type">BOOL</span> *stop) &#123;</span><br><span class="line">            <span class="built_in">NSString</span> *stringKey = [key isKindOfClass:[<span class="built_in">NSString</span> <span class="keyword">class</span>]] ? key : key.description;</span><br><span class="line">            <span class="keyword">if</span> (!stringKey) <span class="keyword">return</span>;</span><br><span class="line">            <span class="comment">//复杂对象需要递归转换</span></span><br><span class="line">            <span class="type">id</span> jsonObj = ModelToJSONObjectRecursive(obj);</span><br><span class="line">            <span class="keyword">if</span> (!jsonObj) jsonObj = (<span class="type">id</span>)kCFNull;</span><br><span class="line">            newDic[stringKey] = jsonObj;</span><br><span class="line">        &#125;];</span><br><span class="line">        <span class="keyword">return</span> newDic;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果当前对象是NSSet</span></span><br><span class="line">    <span class="keyword">if</span> ([model isKindOfClass:[<span class="built_in">NSSet</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="comment">// 简单的NSSet</span></span><br><span class="line">        <span class="built_in">NSArray</span> *array = ((<span class="built_in">NSSet</span> *)model).allObjects;</span><br><span class="line">        <span class="keyword">if</span> ([<span class="built_in">NSJSONSerialization</span> isValidJSONObject:array]) <span class="keyword">return</span> array;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 对象是复杂的对象</span></span><br><span class="line">        <span class="built_in">NSMutableArray</span> *newArray = [<span class="built_in">NSMutableArray</span> new];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">id</span> obj <span class="keyword">in</span> array) &#123;</span><br><span class="line">            <span class="keyword">if</span> ([obj isKindOfClass:[<span class="built_in">NSString</span> <span class="keyword">class</span>]] || [obj isKindOfClass:[<span class="built_in">NSNumber</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">                [newArray addObject:obj];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">id</span> jsonObj = ModelToJSONObjectRecursive(obj);</span><br><span class="line">                <span class="keyword">if</span> (jsonObj &amp;&amp; jsonObj != (<span class="type">id</span>)kCFNull) [newArray addObject:jsonObj];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newArray;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果当前对象是NSArray</span></span><br><span class="line">    <span class="keyword">if</span> ([model isKindOfClass:[<span class="built_in">NSArray</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="comment">// 简单的NSArray</span></span><br><span class="line">        <span class="keyword">if</span> ([<span class="built_in">NSJSONSerialization</span> isValidJSONObject:model]) <span class="keyword">return</span> model;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 对象是复杂的对象</span></span><br><span class="line">        <span class="built_in">NSMutableArray</span> *newArray = [<span class="built_in">NSMutableArray</span> new];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">id</span> obj <span class="keyword">in</span> (<span class="built_in">NSArray</span> *)model) &#123;</span><br><span class="line">            <span class="keyword">if</span> ([obj isKindOfClass:[<span class="built_in">NSString</span> <span class="keyword">class</span>]] || [obj isKindOfClass:[<span class="built_in">NSNumber</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">                [newArray addObject:obj];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">id</span> jsonObj = ModelToJSONObjectRecursive(obj);</span><br><span class="line">                <span class="keyword">if</span> (jsonObj &amp;&amp; jsonObj != (<span class="type">id</span>)kCFNull) [newArray addObject:jsonObj];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newArray;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取Model信息</span></span><br><span class="line">    _YYModelMeta *modelMeta = [_YYModelMeta metaWithClass:[model <span class="keyword">class</span>]];</span><br><span class="line">    <span class="keyword">if</span> (!modelMeta || modelMeta-&gt;_keyMappedCount == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSMutableDictionary</span> *result = [[<span class="built_in">NSMutableDictionary</span> alloc] initWithCapacity:<span class="number">64</span>];</span><br><span class="line">    __<span class="keyword">unsafe_unretained</span> <span class="built_in">NSMutableDictionary</span> *dic = result; <span class="comment">// avoid retain and release in block</span></span><br><span class="line">    [modelMeta-&gt;_mapper enumerateKeysAndObjectsUsingBlock:^(<span class="built_in">NSString</span> *propertyMappedKey, _YYModelPropertyMeta *propertyMeta, <span class="type">BOOL</span> *stop) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!propertyMeta-&gt;_<span class="keyword">getter</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 通过属性信息中的_getter方法使用objc_msgSend从model中获取当前对应属性的值，值获取到了，mapkey也知道了就可以构造返回的dictionary了。</span></span><br><span class="line">        <span class="type">id</span> value = <span class="literal">nil</span>;</span><br><span class="line">        <span class="keyword">if</span> (propertyMeta-&gt;_isCNumber) &#123;</span><br><span class="line">            value = ModelCreateNumberFromProperty(model, propertyMeta);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (propertyMeta-&gt;_nsType) &#123;</span><br><span class="line">            <span class="type">id</span> v = ((<span class="type">id</span> (*)(<span class="type">id</span>, SEL))(<span class="type">void</span> *) objc_msgSend)((<span class="type">id</span>)model, propertyMeta-&gt;_<span class="keyword">getter</span>);</span><br><span class="line">            value = ModelToJSONObjectRecursive(v);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">switch</span> (propertyMeta-&gt;_type &amp; YYEncodingTypeMask) &#123;</span><br><span class="line">                <span class="keyword">case</span> YYEncodingTypeObject: &#123;</span><br><span class="line">                    <span class="type">id</span> v = ((<span class="type">id</span> (*)(<span class="type">id</span>, SEL))(<span class="type">void</span> *) objc_msgSend)((<span class="type">id</span>)model, propertyMeta-&gt;_<span class="keyword">getter</span>);</span><br><span class="line">                    value = ModelToJSONObjectRecursive(v);</span><br><span class="line">                    <span class="keyword">if</span> (value == (<span class="type">id</span>)kCFNull) value = <span class="literal">nil</span>;</span><br><span class="line">                &#125; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> YYEncodingTypeClass: &#123;</span><br><span class="line">                    Class v = ((Class (*)(<span class="type">id</span>, SEL))(<span class="type">void</span> *) objc_msgSend)((<span class="type">id</span>)model, propertyMeta-&gt;_<span class="keyword">getter</span>);</span><br><span class="line">                    value = v ? <span class="built_in">NSStringFromClass</span>(v) : <span class="literal">nil</span>;</span><br><span class="line">                &#125; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> YYEncodingTypeSEL: &#123;</span><br><span class="line">                    SEL v = ((SEL (*)(<span class="type">id</span>, SEL))(<span class="type">void</span> *) objc_msgSend)((<span class="type">id</span>)model, propertyMeta-&gt;_<span class="keyword">getter</span>);</span><br><span class="line">                    value = v ? <span class="built_in">NSStringFromSelector</span>(v) : <span class="literal">nil</span>;</span><br><span class="line">                &#125; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>: <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!value) <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//根据是否有_mappedToKeyPath将上面获取到的值加入到字典中。</span></span><br><span class="line">        <span class="keyword">if</span> (propertyMeta-&gt;_mappedToKeyPath) &#123;</span><br><span class="line">            <span class="built_in">NSMutableDictionary</span> *superDic = dic;</span><br><span class="line">            <span class="built_in">NSMutableDictionary</span> *subDic = <span class="literal">nil</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>, max = propertyMeta-&gt;_mappedToKeyPath.count; i &lt; max; i++) &#123;</span><br><span class="line">                <span class="built_in">NSString</span> *key = propertyMeta-&gt;_mappedToKeyPath[i];</span><br><span class="line">                <span class="keyword">if</span> (i + <span class="number">1</span> == max) &#123; <span class="comment">// end</span></span><br><span class="line">                    <span class="keyword">if</span> (!superDic[key]) superDic[key] = value;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                subDic = superDic[key];</span><br><span class="line">                <span class="keyword">if</span> (subDic) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ([subDic isKindOfClass:[<span class="built_in">NSDictionary</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">                        subDic = subDic.mutableCopy;</span><br><span class="line">                        superDic[key] = subDic;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    subDic = [<span class="built_in">NSMutableDictionary</span> new];</span><br><span class="line">                    superDic[key] = subDic;</span><br><span class="line">                &#125;</span><br><span class="line">                superDic = subDic;</span><br><span class="line">                subDic = <span class="literal">nil</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!dic[propertyMeta-&gt;_mappedToKey]) &#123;</span><br><span class="line">                dic[propertyMeta-&gt;_mappedToKey] = value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    <span class="keyword">if</span> (modelMeta-&gt;_hasCustomTransformToDictionary) &#123;</span><br><span class="line">        <span class="type">BOOL</span> suc = [((<span class="type">id</span>&lt;YYModel&gt;)model) modelCustomTransformToDictionary:dic];</span><br><span class="line">        <span class="keyword">if</span> (!suc) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ModelToJSONObjectRecurs代码很长我们分段进行解析：</p>
<p><strong><strong>简单类型</strong></strong></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">if</span> (!model || model == (<span class="type">id</span>)kCFNull) <span class="keyword">return</span> model;</span><br><span class="line"><span class="keyword">if</span> ([model isKindOfClass:[<span class="built_in">NSString</span> <span class="keyword">class</span>]]) <span class="keyword">return</span> model;</span><br><span class="line"><span class="keyword">if</span> ([model isKindOfClass:[<span class="built_in">NSNumber</span> <span class="keyword">class</span>]]) <span class="keyword">return</span> model;</span><br><span class="line"><span class="keyword">if</span> ([model isKindOfClass:[<span class="built_in">NSURL</span> <span class="keyword">class</span>]]) <span class="keyword">return</span> ((<span class="built_in">NSURL</span> *)model).absoluteString;</span><br><span class="line"><span class="keyword">if</span> ([model isKindOfClass:[<span class="built_in">NSAttributedString</span> <span class="keyword">class</span>]]) <span class="keyword">return</span> ((<span class="built_in">NSAttributedString</span> *)model).string;</span><br><span class="line"><span class="keyword">if</span> ([model isKindOfClass:[<span class="built_in">NSDate</span> <span class="keyword">class</span>]]) <span class="keyword">return</span> [YYISODateFormatter() stringFromDate:(<span class="type">id</span>)model];</span><br><span class="line"><span class="keyword">if</span> ([model isKindOfClass:[<span class="built_in">NSData</span> <span class="keyword">class</span>]]) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br></pre></td></tr></table></figure>

<p>这部分就不介绍了。</p>
<p><strong><strong>NSDictionary, NSSet,NSArray 容器类型</strong></strong></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ([model isKindOfClass:[<span class="built_in">NSDictionary</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="comment">// 简单的字典</span></span><br><span class="line">        <span class="keyword">if</span> ([<span class="built_in">NSJSONSerialization</span> isValidJSONObject:model]) <span class="keyword">return</span> model;</span><br><span class="line">        <span class="comment">// 对象是复杂的对象</span></span><br><span class="line">        <span class="built_in">NSMutableDictionary</span> *newDic = [<span class="built_in">NSMutableDictionary</span> new];</span><br><span class="line">        [((<span class="built_in">NSDictionary</span> *)model) enumerateKeysAndObjectsUsingBlock:^(<span class="built_in">NSString</span> *key, <span class="type">id</span> obj, <span class="type">BOOL</span> *stop) &#123;</span><br><span class="line">            <span class="built_in">NSString</span> *stringKey = [key isKindOfClass:[<span class="built_in">NSString</span> <span class="keyword">class</span>]] ? key : key.description;</span><br><span class="line">            <span class="keyword">if</span> (!stringKey) <span class="keyword">return</span>;</span><br><span class="line">            <span class="comment">//复杂对象需要递归转换</span></span><br><span class="line">            <span class="type">id</span> jsonObj = ModelToJSONObjectRecursive(obj);</span><br><span class="line">            <span class="keyword">if</span> (!jsonObj) jsonObj = (<span class="type">id</span>)kCFNull;</span><br><span class="line">            newDic[stringKey] = jsonObj;</span><br><span class="line">        &#125;];</span><br><span class="line">        <span class="keyword">return</span> newDic;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果当前对象是NSSet</span></span><br><span class="line">    <span class="keyword">if</span> ([model isKindOfClass:[<span class="built_in">NSSet</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="comment">//.....</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果当前对象是NSArray</span></span><br><span class="line">    <span class="keyword">if</span> ([model isKindOfClass:[<span class="built_in">NSArray</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="comment">//.....</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>对于NSDictionary, NSSet,NSArray 容器类型处理的过程是类似的，我们这里以NSDictionary为例子进行分析，如果model是NSDictionary会遍历每个元素，对每个值递归调用ModelToJSONObjectRecursive后存储到newDic中作为value。最后返回newDic。</p>
<p><strong><strong>其他对象类型</strong></strong></p>
<p>对于我们自定义的类型我们处理逻辑如下：首先我们会先通过metaWithClass进行抽取Model的详细信息，然后对model全部属性进行遍历，通过调用每个属性的getter方法提取出属性值，并通过属性名与NSDictionary key的映射关系确定key后将值存到key对应的value中，从而完成整个过程。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">_YYModelMeta *modelMeta = [_YYModelMeta metaWithClass:[model <span class="keyword">class</span>]];</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSMutableDictionary</span> *result = [[<span class="built_in">NSMutableDictionary</span> alloc] initWithCapacity:<span class="number">64</span>];</span><br><span class="line">__<span class="keyword">unsafe_unretained</span> <span class="built_in">NSMutableDictionary</span> *dic = result; <span class="comment">// avoid retain and release in block</span></span><br><span class="line">[modelMeta-&gt;_mapper enumerateKeysAndObjectsUsingBlock:^(<span class="built_in">NSString</span> *propertyMappedKey, _YYModelPropertyMeta *propertyMeta, <span class="type">BOOL</span> *stop) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!propertyMeta-&gt;_<span class="keyword">getter</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 通过属性信息中的_getter方法使用objc_msgSend从model中获取当前对应属性的值，值获取到了，mapkey也知道了就可以构造返回的dictionary了。</span></span><br><span class="line">    <span class="type">id</span> value = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">if</span> (propertyMeta-&gt;_isCNumber) &#123;</span><br><span class="line">        value = ModelCreateNumberFromProperty(model, propertyMeta);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (propertyMeta-&gt;_nsType) &#123;</span><br><span class="line">        <span class="type">id</span> v = ((<span class="type">id</span> (*)(<span class="type">id</span>, SEL))(<span class="type">void</span> *) objc_msgSend)((<span class="type">id</span>)model, propertyMeta-&gt;_<span class="keyword">getter</span>);</span><br><span class="line">        value = ModelToJSONObjectRecursive(v);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (propertyMeta-&gt;_type &amp; YYEncodingTypeMask) &#123;</span><br><span class="line">            <span class="keyword">case</span> YYEncodingTypeObject: &#123;</span><br><span class="line">                <span class="type">id</span> v = ((<span class="type">id</span> (*)(<span class="type">id</span>, SEL))(<span class="type">void</span> *) objc_msgSend)((<span class="type">id</span>)model, propertyMeta-&gt;_<span class="keyword">getter</span>);</span><br><span class="line">                value = ModelToJSONObjectRecursive(v);</span><br><span class="line">                <span class="keyword">if</span> (value == (<span class="type">id</span>)kCFNull) value = <span class="literal">nil</span>;</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> YYEncodingTypeClass: &#123;</span><br><span class="line">                Class v = ((Class (*)(<span class="type">id</span>, SEL))(<span class="type">void</span> *) objc_msgSend)((<span class="type">id</span>)model, propertyMeta-&gt;_<span class="keyword">getter</span>);</span><br><span class="line">                value = v ? <span class="built_in">NSStringFromClass</span>(v) : <span class="literal">nil</span>;</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> YYEncodingTypeSEL: &#123;</span><br><span class="line">                SEL v = ((SEL (*)(<span class="type">id</span>, SEL))(<span class="type">void</span> *) objc_msgSend)((<span class="type">id</span>)model, propertyMeta-&gt;_<span class="keyword">getter</span>);</span><br><span class="line">                value = v ? <span class="built_in">NSStringFromSelector</span>(v) : <span class="literal">nil</span>;</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>: <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!value) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据是否有_mappedToKeyPath将上面获取到的值加入到字典中。</span></span><br><span class="line">    <span class="keyword">if</span> (propertyMeta-&gt;_mappedToKeyPath) &#123;</span><br><span class="line">        <span class="built_in">NSMutableDictionary</span> *superDic = dic;</span><br><span class="line">        <span class="built_in">NSMutableDictionary</span> *subDic = <span class="literal">nil</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>, max = propertyMeta-&gt;_mappedToKeyPath.count; i &lt; max; i++) &#123;</span><br><span class="line">            <span class="built_in">NSString</span> *key = propertyMeta-&gt;_mappedToKeyPath[i];</span><br><span class="line">            <span class="keyword">if</span> (i + <span class="number">1</span> == max) &#123; <span class="comment">// end</span></span><br><span class="line">                <span class="keyword">if</span> (!superDic[key]) superDic[key] = value;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            subDic = superDic[key];</span><br><span class="line">            <span class="keyword">if</span> (subDic) &#123;</span><br><span class="line">                <span class="keyword">if</span> ([subDic isKindOfClass:[<span class="built_in">NSDictionary</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">                    subDic = subDic.mutableCopy;</span><br><span class="line">                    superDic[key] = subDic;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                subDic = [<span class="built_in">NSMutableDictionary</span> new];</span><br><span class="line">                superDic[key] = subDic;</span><br><span class="line">            &#125;</span><br><span class="line">            superDic = subDic;</span><br><span class="line">            subDic = <span class="literal">nil</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!dic[propertyMeta-&gt;_mappedToKey]) &#123;</span><br><span class="line">            dic[propertyMeta-&gt;_mappedToKey] = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-其他JSON-转-Model-方法"><a href="#3-其他JSON-转-Model-方法" class="headerlink" title="3. 其他JSON 转 Model 方法"></a>3. 其他JSON 转 Model 方法</h5><p>除了上面介绍的JSON 转 Model 方法，适用于如下类型：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;key1&quot;</span><span class="punctuation">:</span><span class="string">&quot;value1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;key2&quot;</span><span class="punctuation">:</span><span class="string">&quot;value2&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;key3&quot;</span><span class="punctuation">:</span><span class="string">&quot;value3&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;key4&quot;</span><span class="punctuation">:</span><span class="string">&quot;value4&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;key5&quot;</span><span class="punctuation">:</span><span class="string">&quot;value5&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>当然YYModel还适合序列化对象数组类型的JSON比如：</p>
<figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;key1&quot;</span>:<span class="string">&quot;value1&quot;</span>,</span><br><span class="line">        <span class="string">&quot;key2&quot;</span>:<span class="string">&quot;value2&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;key3&quot;</span>:<span class="string">&quot;value3&quot;</span>,</span><br><span class="line">        <span class="string">&quot;key4&quot;</span>:<span class="string">&quot;value4&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;key5&quot;</span>:<span class="string">&quot;value5&quot;</span>,</span><br><span class="line">        <span class="string">&quot;key6&quot;</span>:<span class="string">&quot;value6&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>这里仅仅贴出代码，有了上面的介绍理解下面的代码应该不会有任何困难。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">+ (<span class="built_in">NSArray</span> *)yy_modelArrayWithClass:(Class)cls json:(<span class="type">id</span>)json &#123;</span><br><span class="line">    <span class="keyword">if</span> (!json) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">NSArray</span> *arr = <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">NSData</span> *jsonData = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">if</span> ([json isKindOfClass:[<span class="built_in">NSArray</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        arr = json;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([json isKindOfClass:[<span class="built_in">NSString</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        jsonData = [(<span class="built_in">NSString</span> *)json dataUsingEncoding : <span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([json isKindOfClass:[<span class="built_in">NSData</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        jsonData = json;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (jsonData) &#123;</span><br><span class="line">        arr = [<span class="built_in">NSJSONSerialization</span> JSONObjectWithData:jsonData options:kNilOptions error:<span class="literal">NULL</span>];</span><br><span class="line">        <span class="keyword">if</span> (![arr isKindOfClass:[<span class="built_in">NSArray</span> <span class="keyword">class</span>]]) arr = <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> yy_modelArrayWithClass:cls array:arr];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">NSArray</span> *)yy_modelArrayWithClass:(Class)cls array:(<span class="built_in">NSArray</span> *)arr &#123;</span><br><span class="line">    <span class="keyword">if</span> (!cls || !arr) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *result = [<span class="built_in">NSMutableArray</span> new];</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSDictionary</span> *dic <span class="keyword">in</span> arr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (![dic isKindOfClass:[<span class="built_in">NSDictionary</span> <span class="keyword">class</span>]]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">NSObject</span> *obj = [cls yy_modelWithDictionary:dic];</span><br><span class="line">        <span class="keyword">if</span> (obj) [result addObject:obj];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还可以解析下面类型的JSON,</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;obj1&quot;</span><span class="punctuation">:</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;key1&quot;</span><span class="punctuation">:</span><span class="string">&quot;value1&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;key2&quot;</span><span class="punctuation">:</span><span class="string">&quot;value2&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;obj2&quot;</span><span class="punctuation">:</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;key3&quot;</span><span class="punctuation">:</span><span class="string">&quot;value3&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;key4&quot;</span><span class="punctuation">:</span><span class="string">&quot;value4&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;obj3&quot;</span><span class="punctuation">:</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;key5&quot;</span><span class="punctuation">:</span><span class="string">&quot;value5&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;key6&quot;</span><span class="punctuation">:</span><span class="string">&quot;value6&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>代码如下和上面的那个其实是类似的，只不过是顶层元素换成字典罢了，这类个人在项目中用得不多。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">+ (<span class="built_in">NSDictionary</span> *)yy_modelDictionaryWithClass:(Class)cls json:(<span class="type">id</span>)json &#123;</span><br><span class="line">    <span class="keyword">if</span> (!json) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">NSDictionary</span> *dic = <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">NSData</span> *jsonData = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">if</span> ([json isKindOfClass:[<span class="built_in">NSDictionary</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        dic = json;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([json isKindOfClass:[<span class="built_in">NSString</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        jsonData = [(<span class="built_in">NSString</span> *)json dataUsingEncoding : <span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([json isKindOfClass:[<span class="built_in">NSData</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        jsonData = json;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (jsonData) &#123;</span><br><span class="line">        dic = [<span class="built_in">NSJSONSerialization</span> JSONObjectWithData:jsonData options:kNilOptions error:<span class="literal">NULL</span>];</span><br><span class="line">        <span class="keyword">if</span> (![dic isKindOfClass:[<span class="built_in">NSDictionary</span> <span class="keyword">class</span>]]) dic = <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> yy_modelDictionaryWithClass:cls dictionary:dic];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">NSDictionary</span> *)yy_modelDictionaryWithClass:(Class)cls dictionary:(<span class="built_in">NSDictionary</span> *)dic &#123;</span><br><span class="line">    <span class="keyword">if</span> (!cls || !dic) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">NSMutableDictionary</span> *result = [<span class="built_in">NSMutableDictionary</span> new];</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSString</span> *key <span class="keyword">in</span> dic.allKeys) &#123;</span><br><span class="line">        <span class="keyword">if</span> (![key isKindOfClass:[<span class="built_in">NSString</span> <span class="keyword">class</span>]]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">NSObject</span> *obj = [cls yy_modelWithDictionary:dic[key]];</span><br><span class="line">        <span class="keyword">if</span> (obj) result[key] = obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>除了上面介绍的方法外，YYModel还提供了极大减轻个人工作量的方法：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 深度拷贝</span></span><br><span class="line">- (id)yy_modelCopy;</span><br><span class="line"><span class="comment">// NSCoding</span></span><br><span class="line">- (void)yy_modelEncodeWithCoder:(NSCoder *)aCoder;</span><br><span class="line">- (id)yy_modelInitWithCoder:(NSCoder *)aDecoder;</span><br><span class="line"><span class="comment">// Hash值生成</span></span><br><span class="line">- (NSUInteger)yy_modelHash;</span><br><span class="line"><span class="comment">// 判断是否一致</span></span><br><span class="line">- (BOOL)yy_modelIsEqual:(id)model;</span><br><span class="line"><span class="comment">// 当前对象的描述</span></span><br><span class="line">- (NSString *)yy_modelDescription;</span><br></pre></td></tr></table></figure>
<h5 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h5><p>YYModel代码就解析到这里，其实大体的思路就是，解析Model对象信息，明确NSDictionary key 与 Model属性名之间的映射关系，通过这种映射关系，新建一个model对象，使用model对象的setter方法将NSDictionary中的值设置到model中，从而完成JSON转Model 的过程。Model 转 JSON是通过model的getter方法，取出对应属性的值，然后通过NSDictionary key和model属性名的映射关系，确定对应的key，然后将model值设置到NSDictionary中。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/iOS-%E5%BC%80%E6%BA%90%E5%BA%93%E5%88%86%E6%9E%90/">iOS 开源库分析</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/iOS-开源库分析/">iOS 开源库分析</a>
  </div>

</div>



<div class="comments-count">
	
	  	<span></span>
		<a href="/2019/11/20/YYModel-源码解析/#comments" class="ds-thread-count comments-count-link" data-thread-key="2019/11/20/YYModel-源码解析/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/11/17/YYDispatchQueuePool-源码解析/" title="YYDispatchQueuePool 源码解析" itemprop="url">YYDispatchQueuePool 源码解析</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Edgar" target="_blank" itemprop="author">Edgar</a>
		
  <p class="article-time">
    <time datetime="2019-11-16T18:07:40.000Z" itemprop="datePublished"> Published 2019-11-17</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h4 id="源码信息"><a href="#源码信息" class="headerlink" title="源码信息"></a>源码信息</h4><p>开源地址: <a target="_blank" rel="noopener" href="https://github.com/ibireme/YYDispatchQueuePool">YYDispatchQueuePool</a></p>
<h4 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h4><p>按照惯例我们还是先看它的用法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从全局队列中队列池中获取到一个串行队列</span></span><br><span class="line"><span class="type">dispatch_queue_t</span> queue = <span class="built_in">YYDispatchQueueGetForQOS</span>(NSQualityOfServiceUtility);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得一个指定类型的串行队列池</span></span><br><span class="line">YYDispatchQueuePool *pool = [[YYDispatchQueuePool alloc] initWithName:@<span class="string">&quot;file.read&quot;</span> queueCount:<span class="number">5</span> qos:NSQualityOfServiceBackground];</span><br><span class="line"><span class="comment">// 从队列池中获取一个串行队列</span></span><br><span class="line"><span class="type">dispatch_queue_t</span> queue = [pool queue];</span><br></pre></td></tr></table></figure>

<p>我们接下来就从这两个情景进行分析：</p>
<p>**** 情景一 ****</p>
<p>好了先贴代码：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">dispatch_queue_t <span class="constructor">YYDispatchQueueGetForQOS(NSQualityOfService <span class="params">qos</span>)</span> &#123;</span><br><span class="line">    return <span class="constructor">YYDispatchContextGetQueue(YYDispatchContextGetForQOS(<span class="params">qos</span>)</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Queality of Service 是 iOS8 提出的一个新的概念，一个高质量的服务就意味着更多的资源得以提供来更快的完成操作, 它可以是如下值：</p>
<figure class="highlight elm"><table><tr><td class="code"><pre><span class="line">typedef <span class="type">NS_ENUM</span>(<span class="type">NSInteger</span>, <span class="type">NSQualityOfService</span>) &#123;</span><br><span class="line">    <span class="type">NSQualityOfServiceUserInteractive</span> = 0x21,</span><br><span class="line">    <span class="type">NSQualityOfServiceUserInitated</span> = 0x19,</span><br><span class="line">    <span class="type">NSQualityOfServiceUtility</span> = 0x11,</span><br><span class="line">    <span class="type">NSQualityOfServiceBackground</span> = 0x09,</span><br><span class="line">    <span class="type">NSQualityOfServiceDefault</span> = -1</span><br><span class="line">&#125; <span class="type">NS_ENUM_AVAILABLE</span>(10_10, 8_0);</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><strong>UserInteractive QoS</strong></strong> 用于直接参与提供一个交互式UI，如处理事件或对屏幕的绘制。</li>
<li><strong><strong>UserInitiated QoS</strong></strong> 用于表示执行工作已经被用户显示提出并且要求结果能够立即展示以便进行进一步的用户交互。</li>
<li><strong><strong>Utility QoS</strong></strong> 用于表述执行一项工作后，用户并不需要立即得到结果。这一工作通常用户已经请求过或者在初始化的时候已经自动执行，不会阻碍用户用户的进一步交互，通常在用户可见的时间尺度和可能由一个非模态的进度指示器展示给用户。</li>
<li><strong><strong>Background QoS</strong></strong> 用于那些非用户初始化或可见的工作。通常说来，用户甚至不知道这想工作已经发生，但是它会以最有效的方法运行同时会树丛那些高优先级的QoS。例如:内容抓取，搜索索引，备份，同步与外部系统的数据。</li>
<li><strong><strong>Default QoS</strong></strong> 表明QoS信息缺失。尽可能的从其它资源推断可能的QoS信息。如果这一推断不成立，一个位于UserInitiated和Utility之间的QoS将得以使用。</li>
</ul>
<p>这里创建的QoS 为 NSQualityOfServiceUtility：</p>
<figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">static</span> YYDispatchContext *YYDispatchContextGetForQOS(NSQualityOfService qos) &#123;</span><br><span class="line">    <span class="keyword">static</span> YYDispatchContext *context[<span class="number">5</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">switch</span> (qos) &#123;</span><br><span class="line">        <span class="comment">//.........</span></span><br><span class="line">        <span class="keyword">case</span> NSQualityOfServiceUtility: &#123;</span><br><span class="line">            <span class="keyword">static</span> dispatch_once_t onceToken;</span><br><span class="line">            dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">                <span class="built_in">int</span> <span class="keyword">count</span> = (<span class="built_in">int</span>)[NSProcessInfo processInfo].activeProcessorCount;</span><br><span class="line">                <span class="keyword">count</span> = <span class="keyword">count</span> &lt; <span class="number">1</span> ? <span class="number">1</span> : <span class="keyword">count</span> &gt; MAX_QUEUE_COUNT ? MAX_QUEUE_COUNT : <span class="keyword">count</span>;</span><br><span class="line">                context[<span class="number">2</span>] = YYDispatchContextCreate(<span class="string">&quot;com.ibireme.yykit.utility&quot;</span>, <span class="keyword">count</span>, qos);</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">return</span> context[<span class="number">2</span>];</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//.........</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建的串行队列数和处理器的内核数一致，这里还有一个需要注意的是这里创建了五个YYDispatchContext，也就是每次使用一种QoS都会创建出和内核数相等的当前类型QoS的串行队列。我们看下整个创建过程：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> YYDispatchContext *<span class="title">YYDispatchContextCreate</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                 <span class="type">uint32_t</span> queueCount,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                 NSQualityOfService qos)</span> </span>&#123;</span><br><span class="line">    YYDispatchContext *context = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="built_in">sizeof</span>(YYDispatchContext));</span><br><span class="line">    <span class="keyword">if</span> (!context) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    context-&gt;queues =  <span class="built_in">calloc</span>(queueCount, <span class="built_in">sizeof</span>(<span class="type">void</span> *));</span><br><span class="line">    <span class="keyword">if</span> (!context-&gt;queues) &#123;</span><br><span class="line">        <span class="built_in">free</span>(context);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ([UIDevice currentDevice].systemVersion.floatValue &gt;= <span class="number">8.0</span>) &#123;</span><br><span class="line">        <span class="type">dispatch_qos_class_t</span> qosClass = <span class="built_in">NSQualityOfServiceToQOSClass</span>(qos);</span><br><span class="line">        <span class="keyword">for</span> (NSUInteger i = <span class="number">0</span>; i &lt; queueCount; i++) &#123;</span><br><span class="line">            <span class="type">dispatch_queue_attr_t</span> attr = <span class="built_in">dispatch_queue_attr_make_with_qos_class</span>(DISPATCH_QUEUE_SERIAL, qosClass, <span class="number">0</span>);</span><br><span class="line">            <span class="type">dispatch_queue_t</span> queue = <span class="built_in">dispatch_queue_create</span>(name, attr);</span><br><span class="line">            context-&gt;queues[i] = (__bridge_retained <span class="type">void</span> *)(queue);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">long</span> identifier = <span class="built_in">NSQualityOfServiceToDispatchPriority</span>(qos);</span><br><span class="line">        <span class="keyword">for</span> (NSUInteger i = <span class="number">0</span>; i &lt; queueCount; i++) &#123;</span><br><span class="line">            <span class="type">dispatch_queue_t</span> queue = <span class="built_in">dispatch_queue_create</span>(name, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">            <span class="built_in">dispatch_set_target_queue</span>(queue, <span class="built_in">dispatch_get_global_queue</span>(identifier, <span class="number">0</span>));</span><br><span class="line">            context-&gt;queues[i] = (__bridge_retained <span class="type">void</span> *)(queue);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    context-&gt;queueCount = queueCount;</span><br><span class="line">    <span class="keyword">if</span> (name) &#123;</span><br><span class="line">         context-&gt;name = <span class="built_in">strdup</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个和YYAsyncDisplay里面显示串行队列的创建代码相一致。</p>
<p>YYDispatchContextGetQueue中会从YYDispatchContext中取出对应的queue，这里用到了OSAtomicIncrement32，每次调用的时候会将context-&gt;counter递增1，所以返回的queue会在context-&gt;queues中循环顺序取出。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">dispatch_queue_t</span> <span class="title">YYDispatchContextGetQueue</span><span class="params">(YYDispatchContext *context)</span> </span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> counter = (<span class="type">uint32_t</span>)<span class="built_in">OSAtomicIncrement32</span>(&amp;context-&gt;counter);</span><br><span class="line">    <span class="type">void</span> *queue = context-&gt;queues[counter % context-&gt;queueCount];</span><br><span class="line">    <span class="keyword">return</span> (__bridge <span class="type">dispatch_queue_t</span>)(queue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>**** 情景二 ****</p>
<p>有了上面介绍后看下面代码就比较简单了，它通过YYDispatchQueuePool的初始化方法创建一个指定类型Qos的串行队列池，再通过YYDispatchContextGetQueue从前面创建的YYDispatchContext中的queues中去除一个串行队列</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)initWithName:(<span class="built_in">NSString</span> *)name queueCount:(<span class="built_in">NSUInteger</span>)queueCount qos:(<span class="built_in">NSQualityOfService</span>)qos &#123;</span><br><span class="line">    <span class="keyword">if</span> (queueCount == <span class="number">0</span> || queueCount &gt; MAX_QUEUE_COUNT) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="variable language_">super</span> init];</span><br><span class="line">    _context = YYDispatchContextCreate(name.UTF8String, (uint32_t)queueCount, qos);</span><br><span class="line">    <span class="keyword">if</span> (!_context) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    _name = name;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">dispatch_queue_t</span>)queue &#123;</span><br><span class="line">    <span class="keyword">return</span> YYDispatchContextGetQueue(_context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是根据源码绘制的结构图：</p>
<p><img src="/2019/11/17/YYDispatchQueuePool-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/000001.png"></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/iOS-%E5%BC%80%E6%BA%90%E5%BA%93%E5%88%86%E6%9E%90/">iOS 开源库分析</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/iOS-开源库分析/">iOS 开源库分析</a>
  </div>

</div>



<div class="comments-count">
	
	  	<span></span>
		<a href="/2019/11/17/YYDispatchQueuePool-源码解析/#comments" class="ds-thread-count comments-count-link" data-thread-key="2019/11/17/YYDispatchQueuePool-源码解析/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>







  <nav id="page-nav" class="clearfix">
    <a class="extend prev" rel="prev" href="/page/3/">&lt;span&gt;&lt;&#x2F;span&gt;Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/30/">30</a><a class="extend next" rel="next" href="/page/5/">Next&lt;span&gt;&lt;&#x2F;span&gt;</a>
  </nav>

</div>
      <div class="openaside"><a class="navbutton" href="#" title="Show Sidebar"></a></div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="Hide Sidebar"></a></div>
<aside class="clearfix">
<div id="authorInfo">
	
		<div class="author-img"></div>		
	
	<div class="social-info" class="clearfix">
		
		
		<a href="https://github.com/tbfungeek" target="_blank" class="icon-github" title="github"></a>
		
		
		
		
		
		
		
		
		
		
		<a href="mailto:tbfungeek@163.com" target="_blank" class="icon-email" title="Email Me"></a>
		

	</div>
</div>

  
<div class="categorieslist">
	<p class="asidetitle">Categories</p>
		<ul>
		
		  
			<li><a href="/categories/Android-小经验/" title="Android 小经验">Android 小经验<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Android-源码分析/" title="Android 源码分析">Android 源码分析<sup>21</sup></a></li>
		  
		
		  
			<li><a href="/categories/Android其他/" title="Android其他">Android其他<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Android初步/" title="Android初步">Android初步<sup>21</sup></a></li>
		  
		
		  
			<li><a href="/categories/Android进阶/" title="Android进阶">Android进阶<sup>100</sup></a></li>
		  
		
		  
			<li><a href="/categories/Hexo-使用/" title="Hexo 使用">Hexo 使用<sup>10</sup></a></li>
		  
		
		  
			<li><a href="/categories/JavaScript理论/" title="JavaScript理论">JavaScript理论<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Objective-C-相关/" title="Objective C 相关">Objective C 相关<sup>24</sup></a></li>
		  
		
		  
			<li><a href="/categories/OpenCV/" title="OpenCV">OpenCV<sup>6</sup></a></li>
		  
		
		  
			<li><a href="/categories/ROS/" title="ROS">ROS<sup>9</sup></a></li>
		  
		
		  
			<li><a href="/categories/iOS-工具使用/" title="iOS 工具使用">iOS 工具使用<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/iOS-开源库分析/" title="iOS 开源库分析">iOS 开源库分析<sup>36</sup></a></li>
		  
		
		  
			<li><a href="/categories/iOS-理论基础/" title="iOS 理论基础">iOS 理论基础<sup>14</sup></a></li>
		  
		
		  
			<li><a href="/categories/iOS-进阶/" title="iOS 进阶">iOS 进阶<sup>4</sup></a></li>
		  
		
		  
			<li><a href="/categories/个人收藏/" title="个人收藏">个人收藏<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/代码规范/" title="代码规范">代码规范<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/其他/" title="其他">其他<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/博客分类目录/" title="博客分类目录">博客分类目录<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/叨叨系列/" title="叨叨系列">叨叨系列<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/开源代码分析/" title="开源代码分析">开源代码分析<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/开源库分析/" title="开源库分析">开源库分析<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/树莓派/" title="树莓派">树莓派<sup>4</sup></a></li>
		  
		
		  
			<li><a href="/categories/版本控制/" title="版本控制">版本控制<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/直播/" title="直播">直播<sup>6</sup></a></li>
		  
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">Tags</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/iOS-开源库分析/" title="iOS 开源库分析">iOS 开源库分析<sup>36</sup></a></li>
			
		
			
				<li><a href="/tags/Android-设计模式/" title="Android 设计模式">Android 设计模式<sup>29</sup></a></li>
			
		
			
				<li><a href="/tags/Objective-C-相关/" title="Objective C 相关">Objective C 相关<sup>24</sup></a></li>
			
		
			
				<li><a href="/tags/Android基础/" title="Android基础">Android基础<sup>21</sup></a></li>
			
		
			
				<li><a href="/tags/AOSP-源码/" title="AOSP 源码">AOSP 源码<sup>17</sup></a></li>
			
		
			
				<li><a href="/tags/Android-常用第三方库/" title="Android 常用第三方库">Android 常用第三方库<sup>15</sup></a></li>
			
		
			
				<li><a href="/tags/iOS-理论基础/" title="iOS 理论基础">iOS 理论基础<sup>14</sup></a></li>
			
		
			
				<li><a href="/tags/Hexo-使用/" title="Hexo 使用">Hexo 使用<sup>10</sup></a></li>
			
		
			
				<li><a href="/tags/ROS/" title="ROS">ROS<sup>9</sup></a></li>
			
		
			
				<li><a href="/tags/Android-动画进阶/" title="Android 动画进阶">Android 动画进阶<sup>8</sup></a></li>
			
		
			
				<li><a href="/tags/Android-JNI/" title="Android JNI">Android JNI<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/Android-绘图进阶/" title="Android 绘图进阶">Android 绘图进阶<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/Android性能优化/" title="Android性能优化">Android性能优化<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/Android-自动化测试/" title="Android 自动化测试">Android 自动化测试<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/OpenCV/" title="OpenCV">OpenCV<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/直播/" title="直播">直播<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/Android-开源源码/" title="Android 开源源码">Android 开源源码<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/Android-自定义View进阶/" title="Android 自定义View进阶">Android 自定义View进阶<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/树莓派/" title="树莓派">树莓派<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/iOS-进阶/" title="iOS 进阶">iOS 进阶<sup>4</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">Links</p>
    <ul>
        
          <li>
            
            	<a href="https://hexo.io" target="_blank" title="Hexo">Hexo</a>
            
          </li>
        
          <li>
            
            	<a href="https://pages.github.com/" target="_blank" title="GitHub">GitHub</a>
            
          </li>
        
          <li>
            
            	<a href="http://pf18.github.io/" target="_blank" title="PF18">PF18</a>
            
          </li>
        
          <li>
            
            	<a href="http://toutiao.io/" target="_blank" title="开发者头条">开发者头条</a>
            
          </li>
        
          <li>
            
            	<a href="http://www.jcodecraeer.com/" target="_blank" title="泡在网上的日子">泡在网上的日子</a>
            
          </li>
        
    </ul>
</div>

  


  <div class="rsspart">
	<a href="atom.xml" target="_blank" title="rss">RSS</a>
</div>

  
  <div class="tagcloudlist">
    <p class="asidetitle">Tag Cloud</p>
    <div class="tagcloudlist clearfix">
       <a href="/tags/AOSP-%E6%BA%90%E7%A0%81/" style="font-size: 17.14px;">AOSP 源码</a> <a href="/tags/Android-APK-%E7%AD%BE%E5%90%8D/" style="font-size: 10px;">Android APK 签名</a> <a href="/tags/Android-JNI/" style="font-size: 12.86px;">Android JNI</a> <a href="/tags/Android-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E8%BF%9B%E9%98%B6/" style="font-size: 10.71px;">Android 事件处理进阶</a> <a href="/tags/Android-%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6/" style="font-size: 13.57px;">Android 动画进阶</a> <a href="/tags/Android-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%80%E5%8F%91/" style="font-size: 10px;">Android 多线程开发</a> <a href="/tags/Android-%E5%B0%8F%E7%BB%8F%E9%AA%8C/" style="font-size: 10px;">Android 小经验</a> <a href="/tags/Android-%E5%B8%B8%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/" style="font-size: 16.43px;">Android 常用第三方库</a> <a href="/tags/Android-%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/" style="font-size: 10px;">Android 开发流程</a> <a href="/tags/Android-%E5%BC%80%E6%BA%90%E6%BA%90%E7%A0%81/" style="font-size: 12.14px;">Android 开源源码</a> <a href="/tags/Android-%E7%BB%98%E5%9B%BE%E8%BF%9B%E9%98%B6/" style="font-size: 12.86px;">Android 绘图进阶</a> <a href="/tags/Android-%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/" style="font-size: 12.86px;">Android 自动化测试</a> <a href="/tags/Android-%E8%87%AA%E5%AE%9A%E4%B9%89View%E8%BF%9B%E9%98%B6/" style="font-size: 12.14px;">Android 自定义View进阶</a> <a href="/tags/Android-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 19.29px;">Android 设计模式</a> <a href="/tags/Android%E5%85%B6%E4%BB%96/" style="font-size: 10px;">Android其他</a> <a href="/tags/Android%E5%9F%BA%E7%A1%80/" style="font-size: 17.86px;">Android基础</a> <a href="/tags/Android%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/" style="font-size: 10px;">Android开发流程</a> <a href="/tags/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" style="font-size: 12.86px;">Android性能优化</a> <a href="/tags/Android%E6%B7%B7%E6%B7%86%E6%8A%80%E6%9C%AF/" style="font-size: 10px;">Android混淆技术</a> <a href="/tags/Android%E8%B4%A8%E9%87%8F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/" style="font-size: 11.43px;">Android质量管理工具</a> <a href="/tags/Android%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/" style="font-size: 10px;">Android逆向工程</a> <a href="/tags/Git-github/" style="font-size: 10px;">Git && github</a> <a href="/tags/Hexo-%E4%BD%BF%E7%94%A8/" style="font-size: 15px;">Hexo 使用</a> <a href="/tags/JavaScript/" style="font-size: 10px;">JavaScript</a> <a href="/tags/Linux-%E4%BD%BF%E7%94%A8/" style="font-size: 10px;">Linux 使用</a> <a href="/tags/Objective-C-%E7%9B%B8%E5%85%B3/" style="font-size: 18.57px;">Objective C 相关</a> <a href="/tags/OpenCV/" style="font-size: 12.86px;">OpenCV</a> <a href="/tags/ROS/" style="font-size: 14.29px;">ROS</a> <a href="/tags/iOS-%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/" style="font-size: 10.71px;">iOS 工具使用</a> <a href="/tags/iOS-%E5%BC%80%E6%BA%90%E5%BA%93%E5%88%86%E6%9E%90/" style="font-size: 20px;">iOS 开源库分析</a> <a href="/tags/iOS-%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/" style="font-size: 15.71px;">iOS 理论基础</a> <a href="/tags/iOS-%E8%BF%9B%E9%98%B6/" style="font-size: 12.14px;">iOS 进阶</a> <a href="/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/" style="font-size: 10px;">代码规范</a> <a href="/tags/%E5%8D%9A%E5%AE%A2%E5%88%86%E7%B1%BB%E7%9B%AE%E5%BD%95/" style="font-size: 10.71px;">博客分类目录</a> <a href="/tags/%E5%8F%A8%E5%8F%A8%E7%B3%BB%E5%88%97/" style="font-size: 10px;">叨叨系列</a> <a href="/tags/%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/" style="font-size: 11.43px;">工具的使用</a> <a href="/tags/%E5%BC%80%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/" style="font-size: 10.71px;">开源代码分析</a> <a href="/tags/%E5%BC%80%E6%BA%90%E5%BA%93%E5%88%86%E6%9E%90/" style="font-size: 10px;">开源库分析</a> <a href="/tags/%E6%9D%82%E7%B1%BB/" style="font-size: 10px;">杂类</a> <a href="/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/" style="font-size: 12.14px;">树莓派</a> <a href="/tags/%E7%9B%B4%E6%92%AD/" style="font-size: 12.86px;">直播</a> <a href="/tags/%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/" style="font-size: 10.71px;">编程技巧</a> <a href="/tags/%E7%BD%91%E7%AB%99%E6%94%B6%E8%97%8F/" style="font-size: 10px;">网站收藏</a> <a href="/tags/%E9%87%8D%E8%A6%81%E6%8E%A7%E4%BB%B6/" style="font-size: 11.43px;">重要控件</a>
    </div>
  </div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
		
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/hsihohuang/kiddochan" target="_blank" title="Kiddochan">Kiddochan</a> © 2022 
		
		<a href="/about" target="_blank" title="Edgar">Edgar</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
        
    }
  });
});
</script>










<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?7c9443b0374f1cf6b1dbb5ab84d939cb";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="Back to Top"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
 </html>
