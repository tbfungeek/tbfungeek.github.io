
 <!DOCTYPE HTML>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
  
    <title>Edgar&#39;s Blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="Edgar">
    

    
    <meta name="description" content="Android | 全栈工程师">
<meta property="og:type" content="website">
<meta property="og:title" content="Edgar&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Edgar&#39;s Blog">
<meta property="og:description" content="Android | 全栈工程师">
<meta property="og:locale">
<meta property="article:author" content="Edgar">
<meta name="twitter:card" content="summary">

    
    <link rel="alternative" href="atom.xml" title="Edgar&#39;s Blog" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/unnamed4_n_mSY_icon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/profile.png">
    <link rel="apple-touch-icon-precomposed" href="/img/profile.png">
    
    
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 6.2.0"></head>

  <body>
    <header>
      
<div>
		
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="Edgar&#39;s Blog">Edgar&#39;s Blog</a></h1>
				<h2 class="blog-motto"></h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="Menu">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
					<li>
 					
					<form class="search" action="/search/index.html" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" autocomplete="off" name="q" maxlength="20" placeholder="Search" />
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main">

   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2020/02/02/iOS-Runtime源码解析initialize-load-attribute-总结/" title="iOS Runtime源码解析initialize load __attribute__总结" itemprop="url">iOS Runtime源码解析initialize load __attribute__总结</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Edgar" target="_blank" itemprop="author">Edgar</a>
		
  <p class="article-time">
    <time datetime="2020-02-01T23:52:30.000Z" itemprop="datePublished"> Published 2020-02-02</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>经过前面几篇论文关于Runtime部分已经介绍差不多了，这篇算是一个总结性的文章吧，其实+initialize 和 +load 已经在之前的几篇博客中都做了十分详细的介绍，这里放在一起无非就是对比一下，增加下记忆，所以这篇博客不会写得很长很复杂，好了言归正传：</p>
<h6 id="initialize"><a href="#initialize" class="headerlink" title="+initialize"></a><strong><strong>+initialize</strong></strong></h6><ul>
<li><p>initialize的特点是惰性调用方式，它的调用时机是在对某个对象发送第一条消息的时候，也就是说如果我们不对某个对象发送消息，那么这个对象的initialize是不会被调用的。</p>
</li>
<li><p>在分类中也可以实现initialize方法，只不过分类中的initialize方法会覆盖主类中的initialize方法，如果在多个分类中同时实现了initialize方法，那么只有最后被编译的那个分类的initialize方法会被调用。它会强制先向父类先发送 +initialize。</p>
</li>
<li><p>与 load 不同，initialize 方法调用时，所有的类都已经加载到了内存中。</p>
</li>
<li><p>其作用也非常局限，一般我们只会在 initialize 方法中进行一些常量的初始化。</p>
</li>
</ul>
<figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line"><span class="operator">+</span> (<span class="keyword">void</span>)<span class="keyword">initialize</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (self <span class="operator">==</span> [FLAnimatedImage <span class="keyword">class</span>]) &#123;</span><br><span class="line">        <span class="comment">//......</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="load"><a href="#load" class="headerlink" title="+load"></a><strong><strong>+load</strong></strong></h6><p>+load 方法相对于 +initialize 来说更为常见它是我们开发过程中可以接触到的调用时机最靠前的方法，和initialize不同的是它的调用<strong><strong>不是惰性的</strong></strong>，在主函数运行之前，load 方法就会被调用，并且它只会在程序调用期间调用一次，最重要的是如果在类与分类中都实现了 load 方法，它们都会被调用，不像+initialize 在分类中实现的方法会被覆盖，但是在使用load方法的时候需要注意，由于load方法的运行时间过早，所以可能不是一个理想的环境，因为它不能保证某些类可能需要在在其它类之前加载，但是在这个时间点，所有的 framework 都已经加载到了运行时中，所以调用 framework 中的方法都是安全的，同时需要注意的是重载Class 的 +load 方法时不能调父类super。</p>
<p><strong><strong>load &#x2F; initialize 对比</strong></strong></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>load</th>
<th>initialize</th>
</tr>
</thead>
<tbody><tr>
<td>是否惰性</td>
<td>否，都会被调用，并且只会被调用一次</td>
<td>是，只有在第一次向某个对象发送消息的时候调用</td>
</tr>
<tr>
<td>调用时机</td>
<td>main之前</td>
<td>main之后，第一次向某个对象发送消息的时候</td>
</tr>
<tr>
<td>在分类中的行为</td>
<td>在分类中和在主类中都会被调用，不会发生覆盖，并且先父类，再主类，再父类分类，主类分类</td>
<td>分类中的会覆盖主类中的initialize，所有分类中只有最后编译的那个生效，会强制先向父类先发送 +initialize</td>
</tr>
<tr>
<td>在调用的时候是否全部类已经加载完毕</td>
<td>否</td>
<td>是</td>
</tr>
</tbody></table>
<h6 id="attribute"><a href="#attribute" class="headerlink" title="attribute"></a><strong><strong><strong>attribute</strong></strong></strong></h6><p>关于__attribute__有很多很好的文档，大家如果看了还不大明白的话可以在下面文档中找答案，这里只想列出在开发过程中比较常用的几个：</p>
<ul>
<li><strong><strong><strong>attribute</strong>((objc_requires_super))</strong></strong></li>
</ul>
<p>有时候我们自己编写的框架需要给别人用的时候，某个方法在使用的时候必须先调用父类的方法，一种做法是写注释，但是如果使用者不看注释就gg了，所以比较好的方式是使用__attribute__((objc_requires_super)) 如果我们没有调用父类的这个方法编译器就会发出警告。</p>
<ul>
<li><strong><strong><strong>attribute</strong>((unavailable(“not available”)))</strong></strong></li>
</ul>
<p>告诉编译器方法不可用，如果使用了就会编译失败，提示错误。比如自定义了初始化方法，为了防止别人调用init初始化，就可以使用它来提示错误，这个在开发中也很常见，但是一般写成：</p>
<figure class="highlight elm"><table><tr><td class="code"><pre><span class="line">- (instance<span class="keyword">type</span>)init <span class="type">NS_UNAVAILABLE</span>; </span><br></pre></td></tr></table></figure>

<ul>
<li><strong><strong><strong>attribute</strong>((deprecated(“该方法已经废弃”)))</strong></strong></li>
</ul>
<p>用于在编译时提示方法过时：</p>
<figure class="highlight d"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)deprecatedMethod:(NSString *)<span class="built_in">string</span> __attribute__((<span class="keyword">deprecated</span>(<span class="string">&quot;该方法已经废弃，请使用xxx方法&quot;</span>)));</span><br><span class="line">- (<span class="keyword">void</span>)deprecatedMethod DEPRECATED_ATTRIBUTE; </span><br></pre></td></tr></table></figure>

<ul>
<li><strong><strong><strong>attribute</strong>((cleanup))</strong></strong></li>
</ul>
<p>声明到一个变量或者block上，当这个变量作用域结束时，调用指定的一个函数. 这个个人在时机工作中用得不多，大家可以看sunnyxx的<a target="_blank" rel="noopener" href="http://blog.sunnyxx.com/2014/09/15/objc-attribute-cleanup/">黑魔法__attribute__((cleanup))</a>这篇博客。</p>
<ul>
<li><strong><strong><strong>attribute</strong>((overloadable))</strong></strong></li>
</ul>
<p>这个个人在时机工作中也用得不多，它主要用于C语言函数,可以定义若干个函数名相同，但参数不同的方法，调用时编译器会自动根据参数选择函数原型.</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="constructor">__attribute__((<span class="params">overloadable</span>)</span>) void print(NSString *<span class="built_in">string</span>)&#123;</span><br><span class="line">    <span class="constructor">NSLog(@<span class="string">&quot;%@&quot;</span>,<span class="params">string</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="constructor">__attribute__((<span class="params">overloadable</span>)</span>) void print(<span class="built_in">int</span> num)&#123;</span><br><span class="line">    <span class="constructor">NSLog(@<span class="string">&quot;%d&quot;</span>,<span class="params">num</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><strong><strong>attribute</strong>((objc_runtime_name(“NSObject”)))</strong></strong></li>
</ul>
<p>这个用于将类或协议的名字在编译时指定成另一个，这个没用过。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">__attribute__((objc_runtime_name(<span class="string">&quot;NSObject&quot;</span>)))</span><br><span class="line">@<span class="keyword">interface</span> <span class="symbol">IDLObject</span> :<span class="symbol">NSObject</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong><strong><strong>attribute</strong>((objc_subclassing_restricted))</strong></strong></li>
</ul>
<p>这个用于禁止被继承的时候使用，很少用到。</p>
<ul>
<li><strong><strong><strong>attribute</strong>((constructor)) &#x2F; <strong>attribute</strong>((destructor))</strong></strong></li>
</ul>
<p>最后介绍的是我们开发过程中经常用到的两个，在用之前需要和load区分开来，我们在将到load方法的时候有提到它的不足之处是它调用的时候某些类可能还没有被加载完成，所以不能在load方法中使用我们自己的类，这样很可能类都没被加载起来。那么__attribute__((constructor))的好处是什么呢？在__attribute__((constructor))标志的方法执行的时候，所有 Class 都已经加载完成，所以可以使用任意的类，并且它可以单独放在一个文件中，不用挂载在一个 Class 中，它和load的方法一样都是在main还未执行的时候调用。如果有多个 constructor 并且想按照指定顺序执行的话，可以写成 <strong>attribute</strong>((constructor(101)))这种形式，1 ~ 100 为系统保留，所以一般以101 为开始，里面的数字越小优先级越高。</p>
<h6 id="推荐文档"><a href="#推荐文档" class="headerlink" title="[推荐文档]"></a><strong><strong>[推荐文档]</strong></strong></h6><ul>
<li><a target="_blank" rel="noopener" href="https://blog.sunnyxx.com/2016/05/14/clang-attributes/">Clang Attributes 黑魔法小记</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.twitter.com/engineering/en_us/a/2014/attribute-directives-in-objective-c.html"><strong>attribute</strong> directives in Objective-C</a></li>
<li><a target="_blank" rel="noopener" href="https://nshipster.com/__attribute__/">nshipster <strong>attribute</strong></a></li>
<li><a target="_blank" rel="noopener" href="https://gcc.gnu.org/onlinedocs/gcc-4.0.0/gcc/Function-Attributes.html">官方文档</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/29eb7b5c8b2d"><strong>attribute</strong> 总结</a></li>
</ul>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Objective-C-%E7%9B%B8%E5%85%B3/">Objective C 相关</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/Objective-C-相关/">Objective C 相关</a>
  </div>

</div>



<div class="comments-count">
	
	  	<span></span>
		<a href="/2020/02/02/iOS-Runtime源码解析initialize-load-attribute-总结/#comments" class="ds-thread-count comments-count-link" data-thread-key="2020/02/02/iOS-Runtime源码解析initialize-load-attribute-总结/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2020/02/02/iOS-Runtime源码解析消息处理/" title="iOS Runtime源码解析消息处理" itemprop="url">iOS Runtime源码解析消息处理</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Edgar" target="_blank" itemprop="author">Edgar</a>
		
  <p class="article-time">
    <time datetime="2020-02-01T23:49:24.000Z" itemprop="datePublished"> Published 2020-02-02</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>我们知道Objective C 是一门动态语言，它是在编译器和Runtime共同协作下完成的，编译时期决定了向哪个对象发送哪个消息，但是这个对象在收到具体消息的时候如何处理是由Runtime决定的,Runtime对消息的处理包括了消息的发送和消息的转发。我们接下来就来看下这部分处理：</p>
<p>在Objective C代码编译期间当遇到一个方法调用的时候，编译器会产生一个对<strong><strong>objc_msgSend</strong></strong>，<strong><strong>objc_msgSend_stret</strong></strong>，<strong><strong>objc_msgSendSuper</strong></strong>，<strong><strong>objc_msgSendSuper_stret</strong></strong>的函数调用</p>
<ul>
<li>如果调用的是[super xxxx] 那么将会调用objc_msgSendSuper objc_msgSendSuper_stret 也就是有带super的函数</li>
<li>如果调用的是[obj xxxxx] 那么将会调用objc_msgSend objc_msgSend_stret</li>
<li>如果返回的值是带有结构的将会调用 objc_msgSendSuper_stret objc_msgSend_stret 也就是带有stret的。</li>
</ul>
<p>为了简单起见我们这里只研究<strong><strong>objc_msgSend</strong></strong>的情况：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">OBJC_EXPORT</span> id _Nullable objc_msgSend(id _Nullable self, SEL _Nonnull op, ...) OBJC_AVAILABLE(<span class="number">10</span>.<span class="number">0</span>, <span class="number">2</span>.<span class="number">0</span>, <span class="number">9</span>.<span class="number">0</span>, <span class="number">1</span>.<span class="number">0</span>, <span class="number">2</span>.<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>这里的第一个参数为消息的接收对象，第二个参数为SEL，可以看成是一个消息。</p>
<p>objc_msgSend底层代码是通过汇编实现的：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">    ENTRY _objc_msgSend</span><br><span class="line">    UNWIND _objc_msgSend, NoFrame</span><br><span class="line">    <span class="regexp">//</span>判空 如果检测方法的接受者是nil，那么系统会自动clean并且return。</span><br><span class="line">    NilTest	NORMAL</span><br><span class="line">    <span class="regexp">//</span>可以快速地获取到对象的 isa 指针地址放到 r11 寄存器</span><br><span class="line">    GetIsaFast NORMAL           <span class="regexp">//</span> r10 = self-&gt;isa</span><br><span class="line">    <span class="regexp">//</span>在缓存中查找IMP 如果查找成功直接调用 IMP</span><br><span class="line">    CacheLookup NORMAL, CALL    <span class="regexp">//</span> calls IMP on success</span><br><span class="line">    <span class="regexp">//</span>检查是否返回值为空</span><br><span class="line">    NilTestReturnZero NORMAL</span><br><span class="line"></span><br><span class="line">    GetIsaSupport NORMAL</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span>查找缓存失败，在方法列表中查找</span><br><span class="line">LCacheMiss:</span><br><span class="line">    <span class="regexp">//</span> isa still <span class="keyword">in</span> r10</span><br><span class="line">    jmp	__objc_msgSend_uncached</span><br><span class="line">    END_ENTRY _objc_msgSend</span><br></pre></td></tr></table></figure>

<p>上面的汇编代码会通过isa找到消息接收者的objc_class，然后通过CacheLookup汇编代码在objc_class 方法缓存中查找，是否有和当前SEL匹配的方法缓存，如果有直接调用对应的IMP,如果没有则走LCacheMiss分支，它会跳转到__objc_msgSend_uncached中：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">STATIC_ENTRY __objc_msgSend_uncached</span><br><span class="line">UNWIND __objc_msgSend_uncached, FrameWithNoSaves</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span> THIS IS NOT A CALLABLE C FUNCTION</span><br><span class="line"><span class="regexp">//</span> Out-of-band r10 is the searched class</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span> 在方法表中查找对应的IMP</span><br><span class="line"><span class="regexp">//</span> r10 is already the class to search</span><br><span class="line">MethodTableLookup NORMAL	<span class="regexp">//</span> r11 = IMP</span><br><span class="line"><span class="regexp">//</span> 跳到对应的IMP去执行</span><br><span class="line">jmp	*%r11			<span class="regexp">//</span> goto *imp</span><br><span class="line"></span><br><span class="line">END_ENTRY __objc_msgSend_uncached</span><br></pre></td></tr></table></figure>

<p>在__objc_msgSend_uncached会调用MethodTableLookup从方法列表中查找：</p>
<figure class="highlight mel"><table><tr><td class="code"><pre><span class="line">.macro MethodTableLookup</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line"></span><br><span class="line">.<span class="keyword">if</span> $0 == NORMAL</span><br><span class="line">    <span class="comment">// receiver already in a1</span></span><br><span class="line">    <span class="comment">// selector already in a2</span></span><br><span class="line">.<span class="keyword">else</span></span><br><span class="line">    movq    %a2, %a1</span><br><span class="line">    movq    %a3, %a2</span><br><span class="line">.endif</span><br><span class="line">    movq    %r10, %a3</span><br><span class="line">    <span class="comment">// 调用__class_lookupMethodAndLoadCache3</span></span><br><span class="line">    call    __class_lookupMethodAndLoadCache3</span><br><span class="line"></span><br><span class="line">    <span class="comment">// IMP is now in %rax</span></span><br><span class="line">    movq    %rax, %r11</span><br><span class="line"></span><br><span class="line"><span class="comment">//......</span></span><br><span class="line"></span><br><span class="line">.endmacro</span><br></pre></td></tr></table></figure>
<p>这里会调用****__class_lookupMethodAndLoadCache3**** 进行查找。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">IMP _class_lookupMethodAndLoadCache3(<span class="type">id</span> obj, SEL sel, Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> lookUpImpOrForward(cls, sel, obj, </span><br><span class="line">                              <span class="literal">YES</span><span class="comment">/*initialize*/</span>, <span class="literal">NO</span><span class="comment">/*cache*/</span>, <span class="literal">YES</span><span class="comment">/*resolver*/</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>_class_lookupMethodAndLoadCache3 是专门提供给汇编调用的不需要查找方法缓存，直接查找objc_class方法列表的方法。所以这里调用<strong><strong>lookUpImpOrForward</strong></strong>时候cache传的是NO.</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">IMP lookUpImpOrForward(Class cls, SEL sel, id inst, </span><br><span class="line">                       bool initialize, bool cache, bool resolver)</span><br><span class="line">&#123;</span><br><span class="line">    IMP imp = <span class="literal">nil</span>;</span><br><span class="line">    bool triedResolver = NO;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//确保进入的时候是没锁住的</span></span><br><span class="line">    runtimeLock.assertUnlocked(); <span class="comment">//这个是加一个读写锁，保证线程安全。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//优化缓存查找传入的参数cache 用于表示是否找到cache的布尔量，</span></span><br><span class="line">    <span class="comment">//从_class_lookupMethodAndLoadCache3进来的是在缓存中已经找过并且没找到的情景,这时候cache为NO</span></span><br><span class="line">    <span class="keyword">if</span> (cache) &#123;</span><br><span class="line">        <span class="comment">//如果传入的是YES，那么就会调用cache_getImp方法去找到缓存里面的IMP,注意cache_getImp是通过汇编实现的，cache_getImp会把找到的IMP放在r11中</span></span><br><span class="line">        imp = cache_getImp(cls, sel);</span><br><span class="line">        <span class="keyword">if</span> (imp) return imp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//锁住读写锁</span></span><br><span class="line">    runtimeLock.lock();</span><br><span class="line">    <span class="comment">//.......</span></span><br><span class="line">    <span class="comment">//如果已经初始化会在objc_class对应的标识位设置为true</span></span><br><span class="line">    <span class="function"><span class="title">if</span> (!cls-&gt;</span>isRealized()) &#123;</span><br><span class="line">        <span class="comment">//实例化类结构</span></span><br><span class="line">        realizeClass(cls);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// +initialize就是在这个阶段调用的</span></span><br><span class="line">    <span class="function"><span class="title">if</span> (initialize  &amp;&amp;  !cls-&gt;</span>isInitialized()) &#123;</span><br><span class="line">        runtimeLock.unlock();</span><br><span class="line">        <span class="comment">//_class_initialize是类初始化的过程。它会发送一个initialize消息给当前类</span></span><br><span class="line">        _class_initialize (_class_getNonMetaClass(cls, inst));</span><br><span class="line">        runtimeLock.lock();</span><br><span class="line">        <span class="comment">//如果我们发送的sel就是initialize那么这里的_class_initialize会发送一次+initialize，后续还会发送一次+initialize，但是这种情况很少见</span></span><br><span class="line">        <span class="comment">// If sel == initialize, _class_initialize will send +initialize and </span></span><br><span class="line">        <span class="comment">// then the messenger will send +initialize again after this </span></span><br><span class="line">        <span class="comment">// procedure finishes. Of course, if this is not being called </span></span><br><span class="line">        <span class="comment">// from the messenger then it won&#x27;t happen. 2778172</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"> retry:    </span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从缓存中查找方法实现</span></span><br><span class="line">    imp = cache_getImp(cls, sel);</span><br><span class="line">    <span class="keyword">if</span> (imp) goto done;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//尝试在本类的方法列表中查找</span></span><br><span class="line">    &#123;</span><br><span class="line">        Method meth = getMethodNoSuper_nolock(cls, sel);</span><br><span class="line">        <span class="keyword">if</span> (meth) &#123;</span><br><span class="line">            <span class="comment">//找到的情况下添加到缓存并返回方法实现</span></span><br><span class="line">            <span class="function"><span class="title">log_and_fill_cache</span>(cls, meth-&gt;</span>imp, sel, inst, cls);</span><br><span class="line">            <span class="function"><span class="title">imp</span> = meth-&gt;</span>imp;</span><br><span class="line">            goto done;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//尝试在父类的缓存和方法列表中查找</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果以上尝试都失败了，接下来就会循环尝试父类的缓存和方法列表。一直找到NSObject为止。因为NSObject的superclass为nil，才跳出循环。</span></span><br><span class="line">        unsigned attempts = unreasonableClassCount();</span><br><span class="line">        <span class="function"><span class="title">for</span> (Class curClass = cls-&gt;</span>superclass;</span><br><span class="line">             curClass != <span class="literal">nil</span>;</span><br><span class="line">             <span class="function"><span class="title">curClass</span> = curClass-&gt;</span>superclass)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Halt if there is a cycle in the superclass chain.</span></span><br><span class="line">            <span class="keyword">if</span> (--attempts == <span class="number">0</span>) &#123;</span><br><span class="line">                _objc_fatal(<span class="string">&quot;Memory corruption in class list.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Superclass cache.</span></span><br><span class="line">            imp = cache_getImp(curClass, sel);</span><br><span class="line">            <span class="keyword">if</span> (imp) &#123;</span><br><span class="line">                <span class="keyword">if</span> (imp != (IMP)_objc_msgForward_impcache) &#123;</span><br><span class="line">                    <span class="comment">// Found the method in a superclass. Cache it in this class.</span></span><br><span class="line">                    log_and_fill_cache(cls, imp, sel, inst, curClass);</span><br><span class="line">                    goto done;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// Found a forward:: entry in a superclass.</span></span><br><span class="line">                    <span class="comment">// Stop searching, but don&#x27;t cache yet; call method </span></span><br><span class="line">                    <span class="comment">// resolver for this class first.</span></span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Superclass method list.</span></span><br><span class="line">            Method meth = getMethodNoSuper_nolock(curClass, sel);</span><br><span class="line">            <span class="keyword">if</span> (meth) &#123;</span><br><span class="line">                <span class="function"><span class="title">log_and_fill_cache</span>(cls, meth-&gt;</span>imp, sel, inst, curClass);</span><br><span class="line">                <span class="function"><span class="title">imp</span> = meth-&gt;</span>imp;</span><br><span class="line">                goto done;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//没有找到实现方法，尝试寻找方法的解决者</span></span><br><span class="line">    <span class="comment">// No implementation found. Try method resolver once.</span></span><br><span class="line">    <span class="keyword">if</span> (resolver  &amp;&amp;  !triedResolver) &#123;</span><br><span class="line">        runtimeLock.unlock();</span><br><span class="line">        <span class="comment">//如果父类找到NSObject还没有找到，那么就会开始尝试_class_resolveMethod方法。</span></span><br><span class="line">        <span class="comment">//注意，这些需要打开读锁，因为开发者可能会在这里动态增加方法实现，所以不需要缓存结果。</span></span><br><span class="line">        <span class="comment">//此处虽然锁被打开，可能会出现线程问题，所以在执行完_class_resolveMethod方法之后，会goto retry，重新执行一遍之前查找的过程。</span></span><br><span class="line">        <span class="comment">// try [nonMetaClass resolveClassMethod:sel]</span></span><br><span class="line">        <span class="comment">// and [cls resolveInstanceMethod:sel]</span></span><br><span class="line">        _class_resolveMethod(cls, sel, inst);</span><br><span class="line">        runtimeLock.lock();</span><br><span class="line">        <span class="comment">//寻找用户指定的方法的解决者</span></span><br><span class="line">        <span class="comment">// Don&#x27;t cache the result; we don&#x27;t hold the lock so it may have </span></span><br><span class="line">        <span class="comment">// changed already. Re-do the search from scratch instead.</span></span><br><span class="line">        triedResolver = YES;</span><br><span class="line">        <span class="comment">//重新查找</span></span><br><span class="line">        goto retry;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// No implementation found, and method resolver didn&#x27;t help. </span></span><br><span class="line">    <span class="comment">// Use forwarding.</span></span><br><span class="line">    <span class="comment">// 消息转发</span></span><br><span class="line">    imp = (IMP)_objc_msgForward_impcache;</span><br><span class="line">    <span class="comment">//---&gt; __objc_msgForward_impcache --&gt; __objc_msgForward --&gt; __objc_forward_handler --&gt; objc_defaultForwardHandler</span></span><br><span class="line">    <span class="comment">//在cache_fill中还会去调用cache_fill_nolock函数，如果缓存中的内容大于容量的 3/4就会扩充缓存，使缓存的大小翻倍。找到第一个空的 bucket_t，以 (SEL, IMP)的形式填充进去。</span></span><br><span class="line">    cache_fill(cls, sel, imp, inst);</span><br><span class="line"> done:</span><br><span class="line">    runtimeLock.unlock();</span><br><span class="line"></span><br><span class="line">    return imp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>lookUpImpOrForward 会先根据实际情况看要不要从缓存中查找，然后再从objc_class的方法列表中查找，如果还没有找到再从父类的缓存和方法列表中找，一直找到NSObject如果发现还没有，那么就调用_class_resolveMethod，这时候_class_resolveMethod可能会通过代码为该类增加方法实现，所以在_class_resolveMethod结束之后还需要通过goto retry走一遍上面流程。上面的resolve过程有些地方称为动态方法决议，下面给出一个简单例子：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> customMethodIMP(<span class="type">id</span> <span class="keyword">self</span>, SEL _cmd) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">&quot;customMethodIMP running&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">IDLResolveTestClass</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="type">BOOL</span>)resolveInstanceMethod:(SEL)aSEL &#123;</span><br><span class="line">    <span class="keyword">if</span> (aSEL == <span class="keyword">@selector</span>(unimplementSelector)) &#123;</span><br><span class="line">          class_addMethod([<span class="keyword">self</span> <span class="keyword">class</span>], aSEL, (IMP) customMethodIMP, <span class="string">&quot;v@:&quot;</span>);</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="variable language_">super</span> resolveInstanceMethod:aSEL];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>上面例子中会判断如果向当前对象发送unimplementSelector消息的时候，resolveInstanceMethod会通过class_addMethod动态完类中添加unimplementSelector的IMP <strong><strong>customMethodIMP</strong></strong>，并返回YES,由于前面介绍了这个流程走完还会走一遍goto retry，所以就会在goto retry中找到customMethodIMP并执行。</p>
<p>如果方法决议还没有找到就准备走消息转发机制了，也就是：</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">imp</span> <span class="operator">=</span> (IMP)_objc_msgForward_impcache<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>先结合下面这张图有个大致的认知下，后面会整理个比较全面的流程图：</p>
<p><img src="/2020/02/02/iOS-Runtime%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86/000000003.png"></p>
<p>这里同时需要注意一点：初始化方法+initialize就是在这个阶段调用的。也就是在第一次往某个对象发送消息的时候如果没有初始化就会调用+initialize。</p>
<p>前面我们了解到缓存查找cache_getImp是汇编实现的，我们接着来看下类方法列表的查找是怎样的：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">static method_t<span class="operator"> *</span></span><br><span class="line"><span class="operator"></span>get<span class="constructor">MethodNoSuper_nolock(Class <span class="params">cls</span>, SEL <span class="params">sel</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    runtimeLock.<span class="keyword">assert</span><span class="constructor">Locked()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">assert</span>(cls-&gt;is<span class="constructor">Realized()</span>);</span><br><span class="line">    <span class="comment">//在getMethodNoSuper_nolock方法中，会遍历一次methodList链表，从begin一直遍历到end。遍历过程中会调用search_method_list函数。</span></span><br><span class="line">    <span class="keyword">for</span> (auto mlists = cls-&gt;data<span class="literal">()</span>-&gt;methods.<span class="keyword">begin</span><span class="constructor">Lists()</span>, </span><br><span class="line">              <span class="keyword">end</span> = cls-&gt;data<span class="literal">()</span>-&gt;methods.<span class="keyword">end</span><span class="constructor">Lists()</span>; </span><br><span class="line">         mlists != <span class="keyword">end</span>;</span><br><span class="line">         ++mlists)</span><br><span class="line">    &#123;</span><br><span class="line">        method_t *m = search<span class="constructor">_method_list(<span class="operator">*</span><span class="params">mlists</span>, <span class="params">sel</span>)</span>;</span><br><span class="line">        <span class="keyword">if</span> (m) return m;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">static method_t *search<span class="constructor">_method_list(<span class="params">const</span> <span class="params">method_list_t</span> <span class="operator">*</span><span class="params">mlist</span>, SEL <span class="params">sel</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> methodListIsFixedUp = mlist-&gt;is<span class="constructor">FixedUp()</span>;</span><br><span class="line">    <span class="built_in">int</span> methodListHasExpectedSize = mlist-&gt;entsize<span class="literal">()</span><span class="operator"> == </span>sizeof(method_t);</span><br><span class="line">    <span class="comment">//在search_method_list函数中，会去判断当前methodList是否有序，如果有序，会调用findMethodInSortedMethodList方法，这个方法里面的实现是一个二分搜索</span></span><br><span class="line">    <span class="comment">//如果非有序，就调用线性的傻瓜式遍历搜索。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="constructor">__builtin_expect(<span class="params">methodListIsFixedUp</span> <span class="operator">&amp;&amp;</span> <span class="params">methodListHasExpectedSize</span>, 1)</span>) &#123;</span><br><span class="line">        return find<span class="constructor">MethodInSortedMethodList(<span class="params">sel</span>, <span class="params">mlist</span>)</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Linear search of unsorted method list</span></span><br><span class="line">        <span class="keyword">for</span> (auto&amp; meth : *mlist) &#123;</span><br><span class="line">            <span class="keyword">if</span> (meth.name<span class="operator"> == </span>sel) return &amp;meth;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里需要注意的是search_method_list方法，它会去判断当前methodList是否有序，如果有序，会调用findMethodInSortedMethodList方法，这个方法里面的实现是一个二分搜索，如果是无序的，就调用线性的傻瓜式遍历搜索。</p>
<p>消息查找已经大致介绍完了，如果这时候没有找到方法，就会进入下个阶段<strong><strong>消息转发阶段</strong></strong>了，消息转发顾名思义就是在当前对象不能处理当前消息的情况下将消息转给能够处理的对象进行处理。</p>
<p>我们紧接着上面_objc_msgForward_impcache来讲：</p>
<figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line">STATIC_ENTRY <span class="variable">__objc_msgForward_impcache</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// No stret specialization.</span></span><br><span class="line">b	<span class="variable">__objc_msgForward</span></span><br><span class="line"></span><br><span class="line">END_ENTRY <span class="variable">__objc_msgForward_impcache</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ENTRY <span class="variable">__objc_msgForward</span></span><br><span class="line"></span><br><span class="line">adrp	x17, <span class="variable">__objc_forward_handler</span>@PAGE</span><br><span class="line">ldr	p17, [x17, <span class="variable">__objc_forward_handler</span>@PAGEOFF]</span><br><span class="line">TailCallFunctionPointer x17</span><br><span class="line"></span><br><span class="line">END_ENTRY <span class="variable">__objc_msgForward</span></span><br></pre></td></tr></table></figure>
<p>__objc_msgForward_impcache 内部很简单就是调用了__objc_msgForward，而在__objc_msgForward中也只是简单得转调了__objc_forward_handler。但是期间还有一系列的调用，我们没有办法看到源码，这部分大家可以看下杨萧玉的 <a target="_blank" rel="noopener" href="http://yulingtianxia.com/blog/2016/06/15/Objective-C-Message-Sending-and-Forwarding/">Objective-C 消息发送与转发机制原理</a>,这里为避免复杂化我们直接介绍结论：</p>
<p>在我们通过动态方法决议给类添加缺失的方法无效的情况下，Runtime就会继续调用****-(id)forwardingTargetForSelector:(SEL)aSelector<strong><strong>，这个方法会根据传入的selector，返回一个备用的target，这个消息会被转发给它进行处理，如果</strong></strong>-(id)forwardingTargetForSelector:(SEL)aSelector**** 返回nil 或者self，就会进入下一步。运行时系统首先会调用****-(NSMethodSignature <em>)methodSignatureForSelector:(SEL)aSelector</em><em><strong>方法来获得记录了方法的参数和返回值的信息的方法签名。如果</strong></em><em>methodSignatureForSelector</em>*** 返回的是nil, 运行时系统会抛出<strong><strong>unrecognized selector exception</strong></strong> ，<br>程序到这里就结束了否则会继续调用 <em><em><strong>-(void)forwardInvocation:(NSInvocation <em>)anInvocation</em></strong></em>。我们这里要看下</em><em><strong>NSInvocation</strong></em>*有哪些功能，才能知道forwardInvocation 可以做哪些工作，NSInvocation定义如下：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSInvocation</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">NSInvocation</span> *)invocationWithMethodSignature:(<span class="built_in">NSMethodSignature</span> *)sig;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">retain</span>) <span class="built_in">NSMethodSignature</span> *methodSignature;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)retainArguments;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) <span class="type">BOOL</span> argumentsRetained;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">assign</span>) <span class="type">id</span> target;</span><br><span class="line"><span class="keyword">@property</span> SEL selector;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)getReturnValue:(<span class="type">void</span> *)retLoc;</span><br><span class="line">- (<span class="type">void</span>)setReturnValue:(<span class="type">void</span> *)retLoc;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)getArgument:(<span class="type">void</span> *)argumentLocation atIndex:(<span class="built_in">NSInteger</span>)idx;</span><br><span class="line">- (<span class="type">void</span>)setArgument:(<span class="type">void</span> *)argumentLocation atIndex:(<span class="built_in">NSInteger</span>)idx;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)invoke;</span><br><span class="line">- (<span class="type">void</span>)invokeWithTarget:(<span class="type">id</span>)target;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>这里最关键的属性包括<strong><strong>methodSignature</strong></strong>，<strong><strong>target</strong></strong>，<strong><strong>selector</strong></strong>，方法部分主要可以分成三类，参数设置获取部分，返回值设置获取部分，以及触发部分，触发可以通过invokeWithTarget交给某个具体目标对象执行。</p>
<p>接着我们再来看下NSMethodSignature：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSMethodSignature</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">nullable</span> <span class="built_in">NSMethodSignature</span> *)signatureWithObjCTypes:(<span class="keyword">const</span> <span class="type">char</span> *)types;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) <span class="built_in">NSUInteger</span> numberOfArguments;</span><br><span class="line">- (<span class="keyword">const</span> <span class="type">char</span> *)getArgumentTypeAtIndex:(<span class="built_in">NSUInteger</span>)idx <span class="built_in">NS_RETURNS_INNER_POINTER</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) <span class="built_in">NSUInteger</span> frameLength;</span><br><span class="line"></span><br><span class="line">- (<span class="type">BOOL</span>)isOneway;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) <span class="keyword">const</span> <span class="type">char</span> *methodReturnType <span class="built_in">NS_RETURNS_INNER_POINTER</span>;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) <span class="built_in">NSUInteger</span> methodReturnLength;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>它主要包括了方法参数和返回值的信息获取。最后以一个流程图来做个总结：</p>
<p><img src="/2020/02/02/iOS-Runtime%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86/000000001.png"></p>
<p>整个过程可以分成如下三个阶段：</p>
<ol>
<li>消息查找</li>
</ol>
<p>这个阶段开始之前会进行一系列的检查，比如检查当前selector是否是忽略的selector，检查target是否为空。然后查找当前对象的缓存是否有当前的要查找的对象，如果没有则进入方法列表的查找阶段，这个阶段会先在当前对象的方法列表中查找是否有待查找的方法，如果没有则顺着继承链往上找，先找父类的方法缓存，再找方法列表。一直找到NSObject都没找到的时候，就进入消息动态决议阶段。</p>
<ol start="2">
<li>消息动态决议</li>
</ol>
<p>消息动态决议实际上是通过resolveInstanceMethod针对当前的消息，添加一个补充的IMP,然后再重新走消息查找的流程。如果还没找到则进入消息转发流程。</p>
<ol start="3">
<li>消息转发</li>
</ol>
<p>消息转发可以分成两种，第一种通过forwardingTargetForSelector它不对消息参数和返回值类型做处理单纯转发给某个对象，这种比较简单，但是灵活性不如后者。</p>
<p>第二种通过forwardInvocation它可以通过methodSignatureForSelector改写方法签名，并在forwardInvocation中对参数数值进行修改，然后再调用invokeWithTarget将消息转发给某个特定的对象，在拿到返回值的时候还可以对返回值进行处理，可以说这是最灵活的一种方式了，JSPatch以及Aspect都是基于这种方式实现的。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Objective-C-%E7%9B%B8%E5%85%B3/">Objective C 相关</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/Objective-C-相关/">Objective C 相关</a>
  </div>

</div>



<div class="comments-count">
	
	  	<span></span>
		<a href="/2020/02/02/iOS-Runtime源码解析消息处理/#comments" class="ds-thread-count comments-count-link" data-thread-key="2020/02/02/iOS-Runtime源码解析消息处理/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2020/02/02/iOS-Runtime源码解析-Runtime初始化/" title="iOS Runtime源码解析 Runtime初始化" itemprop="url">iOS Runtime源码解析 Runtime初始化</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Edgar" target="_blank" itemprop="author">Edgar</a>
		
  <p class="article-time">
    <time datetime="2020-02-01T23:49:23.000Z" itemprop="datePublished"> Published 2020-02-02</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>前面我们介绍了Mach O的结构，App的启动，dyld的加载，以及通过dyld将镜像加载进来，经过rebase&#x2F;Bind处理后，找到main入口，以及Runtime相关的数据结构，有了前面的一系列铺垫这里介绍Runtime初始化就显得相对轻松了，这篇博客我们从《iOS Runtime源码解析之dyld》结尾处接着介绍，《iOS Runtime源码解析之dyld》中介绍了从dyld入口__dyld_start作为起点，到找到并跳转到主函数入口期间的一系列工作：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1.</span> 将主程序初始化为imageLoader</span><br><span class="line"><span class="bullet">2.</span> 加载共享库到内存</span><br><span class="line"><span class="bullet">3.</span> 加载插入的动态库</span><br><span class="line"><span class="bullet">4.</span> 链接主程序,链接插入库</span><br><span class="line"><span class="bullet">5.</span> 初始化主程序，插入库</span><br><span class="line"><span class="bullet">6.</span> 寻找主程序入口点</span><br></pre></td></tr></table></figure>
<p>这篇博客和《iOS Runtime源码解析之dyld》的衔接点就在于第5步初始化主程序，插入库这一步，在这个阶段，会调用使用attribute((constructor) 进行修饰的方法,其中有个十分重要的动态库初始化方法，<strong><strong>libSystem_initializer</strong></strong>：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">static <span class="constructor">__attribute__((<span class="params">constructor</span>)</span>) </span><br><span class="line">void lib<span class="constructor">System_initializer(<span class="params">int</span> <span class="params">argc</span>, <span class="params">const</span> <span class="params">char</span><span class="operator">*</span> <span class="params">argv</span>[], <span class="params">const</span> <span class="params">char</span><span class="operator">*</span> <span class="params">envp</span>[], <span class="params">const</span> <span class="params">char</span><span class="operator">*</span> <span class="params">apple</span>[], <span class="params">const</span> <span class="params">struct</span> ProgramVars<span class="operator">*</span> <span class="params">vars</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line"></span><br><span class="line">    <span class="constructor">_libkernel_init(<span class="params">libkernel_funcs</span>)</span>;</span><br><span class="line"></span><br><span class="line">    bootstrap<span class="constructor">_init()</span>;</span><br><span class="line">    mach<span class="constructor">_init()</span>;</span><br><span class="line">    pthread<span class="constructor">_init()</span>;</span><br><span class="line">    <span class="constructor">__libc_init(<span class="params">vars</span>, <span class="params">libSystem_atfork_prepare</span>, <span class="params">libSystem_atfork_parent</span>, <span class="params">libSystem_atfork_child</span>, <span class="params">apple</span>)</span>;</span><br><span class="line">    <span class="constructor">__keymgr_initializer()</span>;</span><br><span class="line">    <span class="constructor">_dyld_initializer()</span>;</span><br><span class="line">    libdispatch<span class="constructor">_init()</span>;</span><br><span class="line">    <span class="constructor">_libxpc_initializer()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="constructor">__stack_logging_early_finished()</span>;</span><br><span class="line">    <span class="comment">//.......</span></span><br><span class="line">    errno = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在libSystem.dylib的初始化方法libSystem_initializer中初始化了多了dylib库,比如:liblaunch.dylib,libc.a,libdispatch.a等等，这里最关键的是****<a target="_blank" rel="noopener" href="https://github.com/nickhutchinson/libdispatch">libdispatch_init</a>****:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">libdispatch_init</span>(<span class="params"><span class="keyword">void</span></span>) &#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="title function_">_os_object_init</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在libdispatch_init的最后部分会调用****_os_object_init****：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line"><span class="title function_">_os_object_init</span>(<span class="params"><span class="keyword">void</span></span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="title function_">_objc_init</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><strong>_os_object_init</strong></strong>方法只有一行代码就是转调_objc_init，这就是我们十分关注的Runtime 初始化的入口。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">void <span class="constructor">_objc_init(<span class="params">void</span>)</span> &#123;</span><br><span class="line">    static <span class="built_in">bool</span> initialized = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (initialized) return;</span><br><span class="line">    initialized = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fixme defer initialization until an objc-using image is found?</span></span><br><span class="line">    environ<span class="constructor">_init()</span>;</span><br><span class="line">    tls<span class="constructor">_init()</span>;</span><br><span class="line">    static<span class="constructor">_init()</span>;</span><br><span class="line">    lock<span class="constructor">_init()</span>;</span><br><span class="line">    <span class="keyword">exception</span><span class="constructor">_init()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//_dyld_objc_notify_register(&amp;map_2_images, load_images, unmap_image);</span></span><br><span class="line">    <span class="comment">//向dyld注册了回调函数,当imagemap到内存中,当初始化完成image时和卸载image的时候都会回调注册者</span></span><br><span class="line">    <span class="constructor">_dyld_objc_notify_register(&amp;<span class="params">map_images</span>, <span class="params">load_images</span>, <span class="params">unmap_image</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><strong>_objc_init</strong></strong>向dyld注册了map_images，load_images，unmap_image三个关键的回调函数,各个关键阶段节点常量定义如下：</p>
<figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">enum</span> <span class="keyword">dyld_image_states</span></span><br><span class="line">&#123;</span><br><span class="line">    dyld_image_state_mapped                 <span class="operator">=</span> <span class="number">10</span>,       <span class="comment">// No batch notification for this</span></span><br><span class="line">    dyld_image_state_dependents_mapped      <span class="operator">=</span> <span class="number">20</span>,       <span class="comment">// Only batch notification for this</span></span><br><span class="line">    dyld_image_state_rebased                <span class="operator">=</span> <span class="number">30</span>,</span><br><span class="line">    dyld_image_state_bound                  <span class="operator">=</span> <span class="number">40</span>,</span><br><span class="line">    dyld_image_state_dependents_initialized <span class="operator">=</span> <span class="number">45</span>,       <span class="comment">// Only single notification for this</span></span><br><span class="line">    dyld_image_state_initialized            <span class="operator">=</span> <span class="number">50</span>,</span><br><span class="line">    dyld_image_state_terminated             <span class="operator">=</span> <span class="number">60</span>        <span class="comment">// Only single notification for this</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们看下****_dyld_objc_notify_register****这个方法的注释，通过注释我们可以了解到，在runtime中可以通过这个方法可以向dyld注册用于处理镜像完成映射，取消映射和初始化之后的处理方法。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">//</span><br><span class="line">// Note: <span class="keyword">only</span> <span class="keyword">for</span> use <span class="keyword">by</span> objc runtime</span><br><span class="line">// Register handlers <span class="keyword">to</span> be <span class="keyword">called</span> <span class="keyword">when</span> objc images are mapped, unmapped, <span class="keyword">and</span> initialized.</span><br><span class="line">// Dyld will <span class="keyword">call</span> back the &quot;mapped&quot; <span class="keyword">function</span> <span class="keyword">with</span> an <span class="keyword">array</span> <span class="keyword">of</span> images that contain an objc-image-<span class="keyword">info</span> section.</span><br><span class="line">// Those images that are dylibs will have the <span class="keyword">ref</span>-counts automatically bumped, so objc will <span class="keyword">no</span> longer need <span class="keyword">to</span></span><br><span class="line">// <span class="keyword">call</span> dlopen() <span class="keyword">on</span> them <span class="keyword">to</span> keep them <span class="keyword">from</span> being unloaded.  During the <span class="keyword">call</span> <span class="keyword">to</span> _dyld_objc_notify_register(),</span><br><span class="line">// dyld will <span class="keyword">call</span> the &quot;mapped&quot; <span class="keyword">function</span> <span class="keyword">with</span> already loaded objc images.  During <span class="keyword">any</span> later dlopen() <span class="keyword">call</span>,</span><br><span class="line">// dyld will <span class="keyword">also</span> <span class="keyword">call</span> the &quot;mapped&quot; <span class="keyword">function</span>.  Dyld will <span class="keyword">call</span> the &quot;init&quot; <span class="keyword">function</span> <span class="keyword">when</span> dyld would be <span class="keyword">called</span></span><br><span class="line">// initializers <span class="keyword">in</span> that image.  This <span class="keyword">is</span> <span class="keyword">when</span> objc calls <span class="keyword">any</span> +<span class="keyword">load</span> methods <span class="keyword">in</span> that image.</span><br><span class="line">// 通过这个方法可以向dyld注册用于处理镜像完成映射，取消映射和初始化之后的处理方法。</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> _dyld_objc_notify_register(_dyld_objc_notify_mapped    mapped,</span><br><span class="line">                                _dyld_objc_notify_init      init,</span><br><span class="line">                                _dyld_objc_notify_unmapped  unmapped);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们重点关注下****_dyld_objc_notify_mapped<strong><strong>以及</strong></strong>_dyld_objc_notify_init****，</p>
<ul>
<li><strong><strong>_dyld_objc_notify_mapped</strong></strong></li>
</ul>
<p><strong><strong>map_images</strong></strong>会在主程序以及其他库加载进来后调用<strong><strong>ImageLoader::setMapped</strong></strong>发出通知，调用map_images：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void ImageLoader::set<span class="constructor">Mapped(<span class="params">const</span> LinkContext&amp; <span class="params">context</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    fState = dyld_image_state_mapped;</span><br><span class="line">    context.notify<span class="constructor">Single(<span class="params">dyld_image_state_mapped</span>, <span class="params">this</span>)</span>;  <span class="comment">// note: can throw exception</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而<strong><strong>ImageLoader::setMapped</strong></strong>会在instantiateMainExecutable实例话主程序，instantiateFromFile实例化镜像的时候被调用：</p>
<ul>
<li><strong><strong>_dyld_objc_notify_init</strong></strong></li>
</ul>
<p>会在<strong><strong>ImageLoader::runInitializers</strong></strong> 方法中被调用，而<strong><strong>ImageLoader::runInitializers</strong></strong> 则会在 <strong><strong>initializeMainExecutable</strong></strong>中调用。</p>
<p>也即是说在实例化主程序或者其他dylib库的时候都会发出_dyld_objc_notify_mapped通知，这时候会调用runtime 的 map_images方法进行后续处理，在这些初始化完成的时候会发出_dyld_objc_notify_init通知调用load_images方法进行后续处理。</p>
<p>我们紧接着来看下<strong><strong>map_images</strong></strong>以及<strong><strong>load_images</strong></strong>的处理，其实在介绍分类的时候已经介绍过了map_images这里为保证整个文章的完整性再过一遍这部分内容：</p>
<ul>
<li><h5 id="map-images"><a href="#map-images" class="headerlink" title="map_images"></a><strong><strong>map_images</strong></strong></h5></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">map_images</span><span class="params">(<span class="type">unsigned</span> count, <span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> paths[],</span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="type">const</span> <span class="keyword">struct</span> mach_header * <span class="type">const</span> mhdrs[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="type">mutex_locker_t</span> <span class="title">lock</span><span class="params">(runtimeLock)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">map_images_nolock</span>(count, paths, mhdrs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> </span></span><br><span class="line"><span class="function"><span class="title">map_images_nolock</span><span class="params">(<span class="type">unsigned</span> mhCount, <span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> mhPaths[],</span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="type">const</span> <span class="keyword">struct</span> mach_header * <span class="type">const</span> mhdrs[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="keyword">if</span> (hCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//读取镜像信息</span></span><br><span class="line">        _read_images(hList, hCount, totalClasses, unoptimizedTotalClasses);</span><br><span class="line">    &#125;</span><br><span class="line">    firstTime = NO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">void _read_images(header_info **hList, uint32_t hCount, int totalClasses, int unoptimizedTotalClasses)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// =================================查找classes=================================</span></span><br><span class="line">    <span class="comment">// Discover classes. Fix up unresolved future classes. Mark bundle classes.</span></span><br><span class="line">    <span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">        <span class="comment">//从Mach-O的 __DATA区 __objc_classlist 获取所有类,并加入gdb_objc_realized_classes list中</span></span><br><span class="line">        classref_t *classlist = _getObjc2ClassList(hi, &amp;count);</span><br><span class="line">        <span class="comment">//.......</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            Class cls = (Class)classlist[i];</span><br><span class="line">            Class newCls = readClass(cls, headerIsBundle, headerIsPreoptimized);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (newCls != cls  &amp;&amp;  newCls) &#123;</span><br><span class="line">                <span class="comment">// 类被移动了但是没有被删除的情况</span></span><br><span class="line">                <span class="comment">// Class was moved but not deleted. Currently this occurs </span></span><br><span class="line">                <span class="comment">// only when the new class resolved a future class.</span></span><br><span class="line">                <span class="comment">// Non-lazily realize the class below.</span></span><br><span class="line">                resolvedFutureClasses = (Class *)realloc(resolvedFutureClasses, (resolvedFutureClassCount+<span class="number">1</span>) * sizeof(Class));</span><br><span class="line">                resolvedFutureClasses[resolvedFutureClassCount++] = newCls;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ts.<span class="built_in">log</span>(<span class="string">&quot;IMAGE TIMES: discover classes&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修复重新映射的类</span></span><br><span class="line">    <span class="comment">// Fix up remapped classes</span></span><br><span class="line">    <span class="comment">// Class list and nonlazy class list remain unremapped.</span></span><br><span class="line">    <span class="comment">// Class refs and super refs are remapped for message dispatching.</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!noClassesRemapped()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">            Class *classrefs = _getObjc2ClassRefs(hi, &amp;count);</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">                remapClassRef(&amp;classrefs[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// fixme why doesn&#x27;t test future1 catch the absence of this?</span></span><br><span class="line">            classrefs = _getObjc2SuperRefs(hi, &amp;count);</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">                remapClassRef(&amp;classrefs[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新映射类</span></span><br><span class="line">    ts.<span class="built_in">log</span>(<span class="string">&quot;IMAGE TIMES: remap classes&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Fix up @selector references</span></span><br><span class="line">    static size_t UnfixedSelectors;</span><br><span class="line">    &#123;</span><br><span class="line">        mutex_locker_t lock(selLock);</span><br><span class="line">        <span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">            <span class="function"><span class="title">if</span> (hi-&gt;</span>isPreoptimized()) continue;</span><br><span class="line">            </span><br><span class="line">            <span class="function"><span class="title">bool</span> isBundle = hi-&gt;</span>isBundle();</span><br><span class="line">            SEL *sels = _getObjc2SelectorRefs(hi, &amp;count);</span><br><span class="line">            UnfixedSelectors += count;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">                const char *<span class="keyword">name</span> = sel_cname(sels[i]);</span><br><span class="line">                <span class="comment">// 3. 注册Sel,并存储到全局变量namedSelectors的list中</span></span><br><span class="line">                sels[i] = sel_registerNameNoLock(<span class="keyword">name</span>, isBundle);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ts.<span class="built_in">log</span>(<span class="string">&quot;IMAGE TIMES: fix up selector references&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Discover protocols. Fix up protocol refs.</span></span><br><span class="line">    <span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">        extern objc_class OBJC_CLASS_$_Protocol;</span><br><span class="line">        Class cls = (Class)&amp;OBJC_CLASS_$_Protocol;</span><br><span class="line">        assert(cls);</span><br><span class="line">        NXMapTable *protocol_map = protocols();</span><br><span class="line">        <span class="function"><span class="title">bool</span> isPreoptimized = hi-&gt;</span>isPreoptimized();</span><br><span class="line">        <span class="function"><span class="title">bool</span> isBundle = hi-&gt;</span>isBundle();</span><br><span class="line">        <span class="comment">//找到所有Protocol并处理引用</span></span><br><span class="line">        protocol_t **protolist = _getObjc2ProtocolList(hi, &amp;count);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            readProtocol(protolist[i], cls, protocol_map, </span><br><span class="line">                         isPreoptimized, isBundle);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ts.<span class="built_in">log</span>(<span class="string">&quot;IMAGE TIMES: discover protocols&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Fix up @protocol references</span></span><br><span class="line">    <span class="comment">// Preoptimized images may have the right </span></span><br><span class="line">    <span class="comment">// answer already but we don&#x27;t know for sure.</span></span><br><span class="line">    <span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">        protocol_t **protolist = _getObjc2ProtocolRefs(hi, &amp;count);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            remapProtocolRef(&amp;protolist[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ts.<span class="built_in">log</span>(<span class="string">&quot;IMAGE TIMES: fix up @protocol references&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Realize non-lazy classes (for +load methods and static instances)</span></span><br><span class="line">    <span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">        classref_t *classlist = </span><br><span class="line">            _getObjc2NonlazyClassList(hi, &amp;count);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            Class cls = remapClass(classlist[i]);</span><br><span class="line">            <span class="keyword">if</span> (!cls) continue;</span><br><span class="line">            addClassTableEntry(cls);</span><br><span class="line">            realizeClass(cls);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ts.<span class="built_in">log</span>(<span class="string">&quot;IMAGE TIMES: realize non-lazy classes&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Realize newly-resolved future classes, in case CF manipulates them</span></span><br><span class="line">    <span class="keyword">if</span> (resolvedFutureClasses) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; resolvedFutureClassCount; i++) &#123;</span><br><span class="line">            realizeClass(resolvedFutureClasses[i]);</span><br><span class="line">            <span class="function"><span class="title">resolvedFutureClasses</span>[i]-&gt;</span>setInstancesRequireRawIsa(<span class="literal">false</span><span class="comment">/*inherited*/</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        free(resolvedFutureClasses);</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    ts.<span class="built_in">log</span>(<span class="string">&quot;IMAGE TIMES: realize future classes&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Discover categories. </span></span><br><span class="line">    <span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">        category_t **catlist = </span><br><span class="line">            _getObjc2CategoryList(hi, &amp;count);</span><br><span class="line">        <span class="comment">//查看是否包含属性</span></span><br><span class="line">        <span class="function"><span class="title">bool</span> hasClassProperties = hi-&gt;</span><span class="function"><span class="title">info</span>()-&gt;</span>hasCategoryClassProperties();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            category_t *cat = catlist[i];</span><br><span class="line">            <span class="comment">//获取到所属的类</span></span><br><span class="line">            C<span class="function"><span class="title">lass</span> cls = remapClass(cat-&gt;</span>cls);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!cls) &#123;</span><br><span class="line">                <span class="comment">// Category&#x27;s target class is missing (probably weak-linked).</span></span><br><span class="line">                <span class="comment">// Disavow any knowledge of this category.</span></span><br><span class="line">                catlist[i] = <span class="literal">nil</span>;</span><br><span class="line">                <span class="keyword">if</span> (PrintConnecting) &#123;</span><br><span class="line">                    _objc_inform(<span class="string">&quot;CLASS: IGNORING category \?\?\?(%s) %p with &quot;</span></span><br><span class="line">                                 <span class="string">&quot;missing weak-linked target class&quot;</span>, </span><br><span class="line">                                 <span class="function"><span class="title">cat</span>-&gt;</span><span class="keyword">name</span>, cat);</span><br><span class="line">                &#125;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Process this category. </span></span><br><span class="line">            <span class="comment">// First, register the category with its target class. </span></span><br><span class="line">            <span class="comment">// Then, rebuild the class&#x27;s method lists (etc) if </span></span><br><span class="line">            <span class="comment">// the class is realized. </span></span><br><span class="line">            bool classExists = NO;</span><br><span class="line">            <span class="comment">//如果有实例方法，协议或者实例属性</span></span><br><span class="line">            <span class="function"><span class="title">if</span> (cat-&gt;</span><span class="function"><span class="title">instanceMethods</span> ||  cat-&gt;</span>protocols  </span><br><span class="line">                ||  <span class="function"><span class="title">cat</span>-&gt;</span>instanceProperties) </span><br><span class="line">            &#123;</span><br><span class="line">                addUnattachedCategoryForClass(cat, cls, hi);</span><br><span class="line">                <span class="function"><span class="title">if</span> (cls-&gt;</span>isRealized()) &#123;</span><br><span class="line">                    <span class="comment">//将分类添到属性，方法，协议添加到对应的类中</span></span><br><span class="line">                    remethodizeClass(cls);</span><br><span class="line">                    classExists = YES;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (PrintConnecting) &#123;</span><br><span class="line">                    _objc_inform(<span class="string">&quot;CLASS: found category -%s(%s) %s&quot;</span>, </span><br><span class="line">                                 <span class="function"><span class="title">cls</span>-&gt;</span><span class="function"><span class="title">nameForLogging</span>(), cat-&gt;</span><span class="keyword">name</span>, </span><br><span class="line">                                 classExists ? <span class="string">&quot;on existing class&quot;</span> : <span class="string">&quot;&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果有类方法，协议或者类属性</span></span><br><span class="line">            <span class="function"><span class="title">if</span> (cat-&gt;</span><span class="function"><span class="title">classMethods</span>  ||  cat-&gt;</span>protocols  </span><br><span class="line">                ||  (<span class="function"><span class="title">hasClassProperties</span> &amp;&amp; cat-&gt;</span>_classProperties)) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="function"><span class="title">addUnattachedCategoryForClass</span>(cat, cls-&gt;</span>ISA(), hi);</span><br><span class="line">                <span class="function"><span class="title">if</span> (cls-&gt;</span>ISA()-&gt;isRealized()) &#123;</span><br><span class="line">                    <span class="function"><span class="title">remethodizeClass</span>(cls-&gt;</span>ISA());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (PrintConnecting) &#123;</span><br><span class="line">                    _objc_inform(<span class="string">&quot;CLASS: found category +%s(%s)&quot;</span>, </span><br><span class="line">                                 <span class="function"><span class="title">cls</span>-&gt;</span><span class="function"><span class="title">nameForLogging</span>(), cat-&gt;</span><span class="keyword">name</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ts.<span class="built_in">log</span>(<span class="string">&quot;IMAGE TIMES: discover categories&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Category discovery MUST BE LAST to avoid potential races </span></span><br><span class="line">    <span class="comment">// when other threads call the new category code before </span></span><br><span class="line">    <span class="comment">// this thread finishes its fixups.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// +load handled by prepare_load_methods()</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (DebugNonFragileIvars) &#123;</span><br><span class="line">        realizeAllClasses();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>map_images 最关键的代码在_read_images方法中，****_read_images<strong><strong>故名思议就是读取镜像，在这个方法中会从镜像的_DATA区域通过</strong></strong>_getObjc2XXXX****将该镜像的类列表，分类列表，协议列表读取出来，对应的方法以及读取的session部分可以查看如下声明，这里需要提一下_DATA区域中的这些session数据是由编译器写入的。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">//      function name                 content type     section name</span></span><br><span class="line"><span class="constructor">GETSECT(<span class="params">_getObjc2SelectorRefs</span>,        SEL,             <span class="string">&quot;__objc_selrefs&quot;</span>)</span>; </span><br><span class="line"><span class="constructor">GETSECT(<span class="params">_getObjc2MessageRefs</span>,         <span class="params">message_ref_t</span>,   <span class="string">&quot;__objc_msgrefs&quot;</span>)</span>; </span><br><span class="line"><span class="constructor">GETSECT(<span class="params">_getObjc2ClassRefs</span>,           Class,           <span class="string">&quot;__objc_classrefs&quot;</span>)</span>;</span><br><span class="line"><span class="constructor">GETSECT(<span class="params">_getObjc2SuperRefs</span>,           Class,           <span class="string">&quot;__objc_superrefs&quot;</span>)</span>;</span><br><span class="line"><span class="constructor">GETSECT(<span class="params">_getObjc2ClassList</span>,           <span class="params">classref_t</span>,      <span class="string">&quot;__objc_classlist&quot;</span>)</span>;</span><br><span class="line"><span class="constructor">GETSECT(<span class="params">_getObjc2NonlazyClassList</span>,    <span class="params">classref_t</span>,      <span class="string">&quot;__objc_nlclslist&quot;</span>)</span>;</span><br><span class="line"><span class="constructor">GETSECT(<span class="params">_getObjc2CategoryList</span>,        <span class="params">category_t</span> <span class="operator">*</span>,    <span class="string">&quot;__objc_catlist&quot;</span>)</span>;</span><br><span class="line"><span class="constructor">GETSECT(<span class="params">_getObjc2NonlazyCategoryList</span>, <span class="params">category_t</span> <span class="operator">*</span>,    <span class="string">&quot;__objc_nlcatlist&quot;</span>)</span>;</span><br><span class="line"><span class="constructor">GETSECT(<span class="params">_getObjc2ProtocolList</span>,        <span class="params">protocol_t</span> <span class="operator">*</span>,    <span class="string">&quot;__objc_protolist&quot;</span>)</span>;</span><br><span class="line"><span class="constructor">GETSECT(<span class="params">_getObjc2ProtocolRefs</span>,        <span class="params">protocol_t</span> <span class="operator">*</span>,    <span class="string">&quot;__objc_protorefs&quot;</span>)</span>;</span><br><span class="line"><span class="constructor">GETSECT(<span class="params">getLibobjcInitializers</span>,       UnsignedInitializer, <span class="string">&quot;__objc_init_func&quot;</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>这个方法的每个阶段结束都会调用ts.log(“IMAGE TIMES:XXXXXX)来提示每个阶段结束，在这些阶段中有我们之前分析过的Catogies 加载，以及协议加载。我们重点看下最末尾的realizeAllClasses方法：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">static void realize<span class="constructor">AllClasses(<span class="params">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    runtimeLock.<span class="keyword">assert</span><span class="constructor">Locked()</span>;</span><br><span class="line">    header_info *hi;</span><br><span class="line">    <span class="keyword">for</span> (hi = FirstHeader; hi; hi = hi-&gt;get<span class="constructor">Next()</span>) &#123;</span><br><span class="line">        realize<span class="constructor">AllClassesInImage(<span class="params">hi</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">static void realize<span class="constructor">AllClassesInImage(<span class="params">header_info</span> <span class="operator">*</span><span class="params">hi</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">    runtimeLock.<span class="keyword">assert</span><span class="constructor">Locked()</span>;</span><br><span class="line"></span><br><span class="line">    size_t count, i;</span><br><span class="line">    classref_t *classlist;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hi-&gt;are<span class="constructor">AllClassesRealized()</span>) return;</span><br><span class="line"></span><br><span class="line">    classlist = <span class="constructor">_getObjc2ClassList(<span class="params">hi</span>, &amp;<span class="params">count</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        realize<span class="constructor">Class(<span class="params">remapClass</span>(<span class="params">classlist</span>[<span class="params">i</span>])</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    hi-&gt;set<span class="constructor">AllClassesRealized(YES)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>realizeAllClasses会对镜像中的所有class调用realizeClass方法。</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">static Class realizeClass(Class cls) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line">    const class_ro_t *ro;</span><br><span class="line">    class_rw_t *rw;</span><br><span class="line">    Class supercls;</span><br><span class="line">    Class metacls;</span><br><span class="line">    bool isMeta;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!cls) return <span class="literal">nil</span>;               <span class="comment">//cls 不能为空</span></span><br><span class="line">    <span class="function"><span class="title">if</span> (cls-&gt;</span>isRealized()) return cls;  <span class="comment">//cls 如果已经初始化直接返回</span></span><br><span class="line">    assert(cls == remapClass(cls));     <span class="comment">//cls 没有重新分配，remapClass 返回指向cls的实时指针</span></span><br><span class="line">    <span class="comment">// 【✨】获取只读结构体</span></span><br><span class="line">    <span class="function"><span class="title">ro</span> = (const class_ro_t *)cls-&gt;</span><span class="keyword">data</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Normal class. Allocate writeable class data.</span></span><br><span class="line">    rw = (class_rw_t *)calloc(sizeof(class_rw_t), <span class="number">1</span>);           <span class="comment">//分配读写数据</span></span><br><span class="line">    <span class="function"><span class="title">rw</span>-&gt;</span>ro = ro;                                                <span class="comment">//只写数据</span></span><br><span class="line">    <span class="function"><span class="title">rw</span>-&gt;</span>flags = RW_REALIZED|RW_REALIZING;                       <span class="comment">//设置已经初始化标志</span></span><br><span class="line">    <span class="function"><span class="title">cls</span>-&gt;</span>setData(rw);                                           <span class="comment">//为cls设置data数据</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">isMeta</span> = ro-&gt;</span>flags &amp; RO_META;                                   <span class="comment">//判断是否是元类</span></span><br><span class="line">    <span class="function"><span class="title">rw</span>-&gt;</span>version = isMeta ? <span class="number">7</span> : <span class="number">0</span>;  <span class="comment">// old runtime went up to 6      //版本信息，旧版本的版本信息为6</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line">    <span class="comment">// Realize superclass and metaclass, if they aren&#x27;t already.</span></span><br><span class="line">    <span class="comment">// This needs to be done after RW_REALIZED is set above, for root classes.</span></span><br><span class="line">    <span class="comment">// This needs to be done after class index is chosen, for root metaclasses.</span></span><br><span class="line">    <span class="comment">// 【✨】为supercls，metacls 分配空间</span></span><br><span class="line">    <span class="function"><span class="title">supercls</span> = realizeClass(remapClass(cls-&gt;</span>superclass));</span><br><span class="line">    <span class="function"><span class="title">metacls</span> = realizeClass(remapClass(cls-&gt;</span>ISA()));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 【✨】 Update superclass and metaclass in case of remapping</span></span><br><span class="line">    <span class="function"><span class="title">cls</span>-&gt;</span><span class="function"><span class="title">superclass</span> = supercls; //将supercls赋给 cls-&gt;</span>superclass</span><br><span class="line">    <span class="comment">//将上面分配的metacls赋给cls</span></span><br><span class="line">    <span class="function"><span class="title">cls</span>-&gt;</span>initClassIsa(metacls);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调整实例变量的偏移和布局，这个将会重新分配class_ro_t</span></span><br><span class="line">    <span class="comment">// Reconcile instance variable offsets / layout.</span></span><br><span class="line">    <span class="comment">// This may reallocate class_ro_t, updating our ro variable.</span></span><br><span class="line">    <span class="keyword">if</span> (supercls  &amp;&amp;  !isMeta) reconcileInstanceVariables(cls, supercls, ro);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置对象尺寸</span></span><br><span class="line">    <span class="comment">// Set fastInstanceSize if it wasn&#x27;t set already.</span></span><br><span class="line">    <span class="function"><span class="title">cls</span>-&gt;</span><span class="function"><span class="title">setInstanceSize</span>(ro-&gt;</span>instanceSize);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【✨】从ro中拷贝部分标志位到rw 字段</span></span><br><span class="line">    <span class="comment">// Copy some flags from ro to rw</span></span><br><span class="line">    <span class="function"><span class="title">if</span> (ro-&gt;</span>flags &amp; RO_HAS_CXX_STRUCTORS) &#123;</span><br><span class="line">        <span class="function"><span class="title">cls</span>-&gt;</span>setHasCxxDtor();</span><br><span class="line">        <span class="function"><span class="title">if</span> (! (ro-&gt;</span>flags &amp; RO_HAS_CXX_DTOR_ONLY)) &#123;</span><br><span class="line">            <span class="function"><span class="title">cls</span>-&gt;</span>setHasCxxCtor();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 【✨】 Connect this class to its superclass&#x27;s subclass lists</span></span><br><span class="line">    <span class="comment">// 将当前class与父类相关连</span></span><br><span class="line">    <span class="keyword">if</span> (supercls) &#123;</span><br><span class="line">        <span class="comment">//将当前类作为supercls的子类添加到父类的子类列表</span></span><br><span class="line">        addSubclass(supercls, cls);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//将当前类作为根类</span></span><br><span class="line">        addRootClass(cls);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【✨】实例化类结构</span></span><br><span class="line">    <span class="comment">// Attach categories</span></span><br><span class="line">    <span class="comment">// 使得类有条理</span></span><br><span class="line">    methodizeClass(cls);</span><br><span class="line"></span><br><span class="line">    return cls;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>realizeClass 方法实际上是为类的class_rw_t，superclass，metacls等分配空间，并初始化。在最后的时候会调用methodizeClass进行进一步的初始化：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">static void methodize<span class="constructor">Class(Class <span class="params">cls</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//检查锁</span></span><br><span class="line">    runtimeLock.<span class="keyword">assert</span><span class="constructor">Locked()</span>;</span><br><span class="line">    <span class="comment">//是否是元类</span></span><br><span class="line">    <span class="built_in">bool</span> isMeta = cls-&gt;is<span class="constructor">MetaClass()</span>;</span><br><span class="line">    <span class="comment">//获取可读写字段</span></span><br><span class="line">    auto rw = cls-&gt;data<span class="literal">()</span>;</span><br><span class="line">    <span class="comment">//获取只读字段</span></span><br><span class="line">    auto ro = rw-&gt;ro;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Install methods and properties that the class implements itself.</span></span><br><span class="line">    <span class="comment">// 加载类自身实现的方法和属性</span></span><br><span class="line">    method_list_t *<span class="built_in">list</span> = ro-&gt;base<span class="constructor">Methods()</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span>) &#123;</span><br><span class="line">        prepare<span class="constructor">MethodLists(<span class="params">cls</span>, &amp;<span class="params">list</span><span class="operator">/</span><span class="operator">*</span>自身实现的方法列表<span class="operator">*</span><span class="operator">/</span>, 1, YES, <span class="params">isBundleClass</span>(<span class="params">cls</span>)</span>);</span><br><span class="line">        <span class="comment">//将ro-&gt;baseMethods方法添加到rw-&gt;methods</span></span><br><span class="line">        rw-&gt;methods.attach<span class="constructor">Lists(&amp;<span class="params">list</span>, 1)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    property_list_t *proplist = ro-&gt;baseProperties;</span><br><span class="line">    <span class="keyword">if</span> (proplist) &#123;</span><br><span class="line">        <span class="comment">//将ro-&gt;baseProperties方法添加到rw-&gt;properties</span></span><br><span class="line">        rw-&gt;properties.attach<span class="constructor">Lists(&amp;<span class="params">proplist</span>, 1)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protocol_list_t *protolist = ro-&gt;baseProtocols;</span><br><span class="line">    <span class="keyword">if</span> (protolist) &#123;</span><br><span class="line">        <span class="comment">//将ro-&gt;baseProtocols方法添加到rw-&gt;protocols</span></span><br><span class="line">        rw-&gt;protocols.attach<span class="constructor">Lists(&amp;<span class="params">protolist</span>, 1)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Root classes get bonus method implementations if they don&#x27;t have </span></span><br><span class="line">    <span class="comment">// them already. These apply before category replacements.</span></span><br><span class="line">    <span class="keyword">if</span> (cls-&gt;is<span class="constructor">RootMetaclass()</span>) &#123;</span><br><span class="line">        <span class="comment">// root metaclass</span></span><br><span class="line">        add<span class="constructor">Method(<span class="params">cls</span>, SEL_initialize, (IMP)</span>&amp;objc_noop_imp, <span class="string">&quot;&quot;</span>, NO);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Attach categories.</span></span><br><span class="line">    <span class="comment">// 获取未添加的分类</span></span><br><span class="line">    category_list *cats = unattached<span class="constructor">CategoriesForClass(<span class="params">cls</span>, <span class="params">true</span> <span class="operator">/</span><span class="operator">*</span><span class="params">realizing</span><span class="operator">*</span><span class="operator">/</span>)</span>;</span><br><span class="line">    <span class="comment">// 添加分类</span></span><br><span class="line">    attach<span class="constructor">Categories(<span class="params">cls</span>, <span class="params">cats</span>, <span class="params">false</span> <span class="operator">/</span><span class="operator">*</span><span class="params">don</span>&#x27;<span class="params">t</span> <span class="params">flush</span> <span class="params">caches</span><span class="operator">*</span><span class="operator">/</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (cats) free(cats);</span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>methodizeClass方法则进一步初始化rw，这一步将ro中的属性，协议，方法拷贝到rw，以及将分类中对应的属性，协议，方法也拷贝到class中的rw对应字段。</p>
<p>回顾整个map_image阶段就是在镜像实例话结束后，通过读取_DATA中的指定session数据，来读出整个镜像中各个class的关键数据，并构建objc_class数据结构对象，通过从_DATA中读取的数据来填充objc_class来完成整个类的实例化。</p>
<ul>
<li><h5 id="load-images"><a href="#load-images" class="headerlink" title="load_images"></a><strong><strong>load_images</strong></strong></h5></li>
</ul>
<p>load方法是我们在日常开发中可以接触到的调用时间最靠前的方法，它的调用不是惰性的，在主函数运行之前，load 方法就会调用，并且它只会在程序调用期间调用一次，最重要的是，如果在类与分类中都实现了 load 方法，它们都会被调用，<br>不像其它的在分类中实现的方法会被覆盖，但是在使用load方法的时候需要注意，由于load方法的运行时间过早，所以可能不是一个理想的环境，因为它不能保证某些类可能需要在在其它类之前加载，但是在这个时间点，所有的 framework 都已经加载到了运行时中，所以调用 framework 中的方法都是安全的，同时需要注意的是重载Class 的 +load 方法时不能调父类super，我们来看下这部分逻辑：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void</span><br><span class="line">load<span class="constructor">_images(<span class="params">const</span> <span class="params">char</span> <span class="operator">*</span><span class="params">path</span> <span class="params">__unused</span>, <span class="params">const</span> <span class="params">struct</span> <span class="params">mach_header</span> <span class="operator">*</span><span class="params">mh</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="comment">// Discover load methods</span></span><br><span class="line">    &#123;</span><br><span class="line">        mutex_locker_t lock2(runtimeLock);</span><br><span class="line">        <span class="comment">//prepare_load_methods方法中对load方法进行了前期准备</span></span><br><span class="line">        prepare<span class="constructor">_load_methods((<span class="params">const</span> <span class="params">headerType</span> <span class="operator">*</span>)</span>mh);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用+load方法</span></span><br><span class="line">    <span class="comment">// Call +load methods (without runtimeLock - re-entrant)</span></span><br><span class="line">    call<span class="constructor">_load_methods()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>load_images 方法中主要调用了prepare_load_methods 以及 call_load_methods</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void prepare<span class="constructor">_load_methods(<span class="params">const</span> <span class="params">headerType</span> <span class="operator">*</span><span class="params">mhdr</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">    <span class="comment">//获取类</span></span><br><span class="line">    classref_t *classlist = </span><br><span class="line">        <span class="constructor">_getObjc2NonlazyClassList(<span class="params">mhdr</span>, &amp;<span class="params">count</span>)</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        schedule<span class="constructor">_class_load(<span class="params">remapClass</span>(<span class="params">classlist</span>[<span class="params">i</span>])</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加分类</span></span><br><span class="line">    category_t **categorylist = <span class="constructor">_getObjc2NonlazyCategoryList(<span class="params">mhdr</span>, &amp;<span class="params">count</span>)</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        category_t *cat = categorylist<span class="literal">[<span class="identifier">i</span>]</span>;</span><br><span class="line">        Class cls = remap<span class="constructor">Class(<span class="params">cat</span>-&gt;<span class="params">cls</span>)</span>;</span><br><span class="line">        <span class="keyword">if</span> (!cls) continue;  <span class="comment">// category for ignored weak-linked class</span></span><br><span class="line">        realize<span class="constructor">Class(<span class="params">cls</span>)</span>;</span><br><span class="line">        <span class="keyword">assert</span>(cls-&gt;<span class="constructor">ISA()</span>-&gt;is<span class="constructor">Realized()</span>);</span><br><span class="line">        add<span class="constructor">_category_to_loadable_list(<span class="params">cat</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">static void <span class="built_in">schedule_class_load</span>(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    if (!cls) return;</span><br><span class="line">    <span class="built_in">assert</span>(cls-&gt;isRealized());  <span class="comment">// _read_images should realize</span></span><br><span class="line"></span><br><span class="line">    if (cls-&gt;data()-&gt;flags &amp; RW_LOADED) return;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//先加载父类</span></span><br><span class="line">    <span class="comment">// Ensure superclass-first ordering</span></span><br><span class="line">    <span class="comment">//分析这段代码，可以知道，在将子类添加到加载列表之前，其父类一定会优先加载到列表中。</span></span><br><span class="line">    <span class="comment">//这也是为何父类的+load方法在子类的+load方法之前调用的根本原因。</span></span><br><span class="line">    <span class="built_in">schedule_class_load</span>(cls-&gt;superclass);</span><br><span class="line">    <span class="comment">//将类添加到可加载列表</span></span><br><span class="line">    <span class="built_in">add_class_to_loadable_list</span>(cls);</span><br><span class="line">    cls-&gt;<span class="built_in">setInfo</span>(RW_LOADED); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>prepare_load_methods 以及 schedule_class_load方法会按照父类，子类，分类的顺序将需要调用load方法的class添加到loadable_list中去</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void add<span class="constructor">_class_to_loadable_list(Class <span class="params">cls</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    IMP <span class="keyword">method</span>;</span><br><span class="line"></span><br><span class="line">    loadMethodLock.<span class="keyword">assert</span><span class="constructor">Locked()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//该类是否有load方法</span></span><br><span class="line">    <span class="keyword">method</span> = cls-&gt;get<span class="constructor">LoadMethod()</span>;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">method</span>) return;  <span class="comment">// Don&#x27;t bother if cls has no +load method</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//........</span></span><br><span class="line">    <span class="keyword">if</span> (loadable_classes_used<span class="operator"> == </span>loadable_classes_allocated) &#123;</span><br><span class="line">        loadable_classes_allocated = loadable_classes_allocated*<span class="number">2</span> + <span class="number">16</span>;</span><br><span class="line">        loadable_classes = (<span class="keyword">struct</span> loadable_class *)</span><br><span class="line">            realloc(loadable_classes,</span><br><span class="line">                              loadable_classes_allocated<span class="operator"> *</span></span><br><span class="line"><span class="operator">                              </span>sizeof(<span class="keyword">struct</span> loadable_class));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    loadable_classes<span class="literal">[<span class="identifier">loadable_classes_used</span>]</span>.cls = cls;</span><br><span class="line">    loadable_classes<span class="literal">[<span class="identifier">loadable_classes_used</span>]</span>.<span class="keyword">method</span> = <span class="keyword">method</span>;</span><br><span class="line">    loadable_classes_used++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void add<span class="constructor">_category_to_loadable_list(Category <span class="params">cat</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    IMP <span class="keyword">method</span>;</span><br><span class="line"></span><br><span class="line">    loadMethodLock.<span class="keyword">assert</span><span class="constructor">Locked()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//该分类是否有load方法</span></span><br><span class="line">    <span class="keyword">method</span> = <span class="constructor">_category_getLoadMethod(<span class="params">cat</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">method</span>) return;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (loadable_categories_used<span class="operator"> == </span>loadable_categories_allocated) &#123;</span><br><span class="line">        loadable_categories_allocated = loadable_categories_allocated*<span class="number">2</span> + <span class="number">16</span>;</span><br><span class="line">        loadable_categories = (<span class="keyword">struct</span> loadable_category *)</span><br><span class="line">            realloc(loadable_categories,</span><br><span class="line">                              loadable_categories_allocated<span class="operator"> *</span></span><br><span class="line"><span class="operator">                              </span>sizeof(<span class="keyword">struct</span> loadable_category));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    loadable_categories<span class="literal">[<span class="identifier">loadable_categories_used</span>]</span>.cat = cat;</span><br><span class="line">    loadable_categories<span class="literal">[<span class="identifier">loadable_categories_used</span>]</span>.<span class="keyword">method</span> = <span class="keyword">method</span>;</span><br><span class="line">    loadable_categories_used++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用类以及分类中的load方法</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">/<span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">**<span class="emphasis">*</span></span></span><br><span class="line"><span class="emphasis"><span class="strong">*</span> call<span class="emphasis">_load_</span>methods</span></span><br><span class="line"><span class="strong"><span class="emphasis">* Call all pending class and category +load methods.</span></span></span><br><span class="line"><span class="emphasis"><span class="strong">*</span> Class +load methods are called superclass-first. </span></span><br><span class="line"><span class="strong"><span class="emphasis">* Category +load methods are not called until after the parent class&#x27;s +load.</span></span></span><br><span class="line"><span class="emphasis"><span class="strong">*</span> </span></span><br><span class="line"><span class="strong"><span class="emphasis">* This method must be RE-ENTRANT, because a +load could trigger </span></span></span><br><span class="line"><span class="emphasis"><span class="strong">*</span> more image mapping. In addition, the superclass-first ordering </span></span><br><span class="line"><span class="strong"><span class="emphasis">* must be preserved in the face of re-entrant calls. Therefore, </span></span></span><br><span class="line"><span class="emphasis"><span class="strong">*</span> only the OUTERMOST call of this function will do anything, and </span></span><br><span class="line"><span class="strong"><span class="emphasis">* that call will handle all loadable classes, even those generated </span></span></span><br><span class="line"><span class="emphasis"><span class="strong">*</span> while it was running.</span></span><br><span class="line"><span class="strong"><span class="emphasis">*</span></span></span><br><span class="line"><span class="emphasis"><span class="strong">*</span> The sequence below preserves +load ordering in the face of </span></span><br><span class="line"><span class="strong"><span class="emphasis">* image loading during a +load, and make sure that no </span></span></span><br><span class="line"><span class="emphasis"><span class="strong">*</span> +load method is forgotten because it was added during </span></span><br><span class="line"><span class="strong"><span class="emphasis">* a +load call.</span></span></span><br><span class="line"><span class="emphasis"><span class="strong">*</span> Sequence:</span></span><br><span class="line"><span class="strong"><span class="emphasis">* 1. Repeatedly call class +loads until there aren&#x27;t any more</span></span></span><br><span class="line"><span class="emphasis"><span class="strong">*</span> 2. Call category +loads ONCE.</span></span><br><span class="line"><span class="strong"><span class="emphasis">* 3. Run more +loads if:</span></span></span><br><span class="line"><span class="emphasis"><span class="strong">*</span>    (a) there are more classes to load, OR</span></span><br><span class="line"><span class="strong"><span class="emphasis">*    (b) there are some potential category +loads that have </span></span></span><br><span class="line"><span class="emphasis"><span class="strong">*</span>        still never been attempted.</span></span><br><span class="line"><span class="strong"><span class="emphasis">* Category +loads are only run once to ensure &quot;parent class first&quot; </span></span></span><br><span class="line"><span class="emphasis"><span class="strong">*</span> ordering, even if a category +load triggers a new loadable class </span></span><br><span class="line"><span class="strong"><span class="emphasis">* and a new loadable category attached to that class. </span></span></span><br><span class="line"><span class="emphasis"><span class="strong">*</span></span></span><br><span class="line"><span class="strong"><span class="emphasis">* Locking: loadMethodLock must be held by the caller </span></span></span><br><span class="line"><span class="emphasis"><span class="strong">*</span>   All other locks must not be held.</span></span><br><span class="line"><span class="strong">**</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span>/</span><br><span class="line">void call<span class="emphasis">_load_</span>methods(void)</span><br><span class="line">&#123;</span><br><span class="line"><span class="code">    static bool loading = NO;</span></span><br><span class="line"><span class="code">    bool more_categories;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">    loadMethodLock.assertLocked();</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">    // Re-entrant calls do nothing; the outermost call will finish the job.</span></span><br><span class="line"><span class="code">    if (loading) return;</span></span><br><span class="line"><span class="code">    loading = YES;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">    void *pool = objc_autoreleasePoolPush();</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">    do &#123;</span></span><br><span class="line"><span class="code">        // 1. Repeatedly call class +loads until there aren&#x27;t any more</span></span><br><span class="line"><span class="code">        while (loadable_classes_used &gt; 0) &#123;</span></span><br><span class="line"><span class="code">            //调用类的load方法</span></span><br><span class="line"><span class="code">            call_class_loads();</span></span><br><span class="line"><span class="code">        &#125;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">        // 2. Call category +loads ONCE</span></span><br><span class="line"><span class="code">        //调用分类的load方法</span></span><br><span class="line"><span class="code">        more_categories = call_category_loads();</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">        // 3. Run more +loads if there are classes OR more untried categories</span></span><br><span class="line"><span class="code">    &#125; while (loadable_classes_used &gt; 0  ||  more_categories);</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">    objc_autoreleasePoolPop(pool);</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">    loading = NO;</span></span><br><span class="line"><span class="code">&#125;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">call_class_loads</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Detach current loadable list.</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">loadable_class</span> *classes = loadable_classes;<span class="comment">/*这是preppare阶段构造的*/</span></span><br><span class="line">    <span class="type">int</span> used = loadable_classes_used;</span><br><span class="line">    loadable_classes = nil;</span><br><span class="line">    loadable_classes_allocated = <span class="number">0</span>;</span><br><span class="line">    loadable_classes_used = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Call all +loads for the detached list.</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; used; i++) &#123;</span><br><span class="line">        Class cls = classes[i].cls;</span><br><span class="line"></span><br><span class="line">        <span class="type">load_method_t</span> load_method = (<span class="type">load_method_t</span>)classes[i].method;</span><br><span class="line">        <span class="keyword">if</span> (!cls) <span class="keyword">continue</span>; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (PrintLoading) &#123;</span><br><span class="line">            _objc_inform(<span class="string">&quot;LOAD: +[%s load]\n&quot;</span>, cls-&gt;<span class="built_in">nameForLogging</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//调用+load方法</span></span><br><span class="line">        (*load_method)(cls, SEL_load);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Destroy the detached list.</span></span><br><span class="line">    <span class="keyword">if</span> (classes) <span class="built_in">free</span>(classes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">call_category_loads</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, shift;</span><br><span class="line">    <span class="type">bool</span> new_categories_added = NO;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Detach current loadable list.</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">loadable_category</span> *cats = loadable_categories;<span class="comment">/*数据来源 在prepare阶段构建*/</span></span><br><span class="line">    <span class="type">int</span> used = loadable_categories_used;</span><br><span class="line">    <span class="type">int</span> allocated = loadable_categories_allocated;</span><br><span class="line">    loadable_categories = nil;</span><br><span class="line">    loadable_categories_allocated = <span class="number">0</span>;</span><br><span class="line">    loadable_categories_used = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Call all +loads for the detached list.</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; used; i++) &#123;</span><br><span class="line">        Category cat = cats[i].cat;</span><br><span class="line">        <span class="type">load_method_t</span> load_method = (<span class="type">load_method_t</span>)cats[i].method;</span><br><span class="line">        Class cls;</span><br><span class="line">        <span class="keyword">if</span> (!cat) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        cls = _category_getClass(cat);</span><br><span class="line">        <span class="keyword">if</span> (cls  &amp;&amp;  cls-&gt;<span class="built_in">isLoadable</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (PrintLoading) &#123;</span><br><span class="line">                _objc_inform(<span class="string">&quot;LOAD: +[%s(%s) load]\n&quot;</span>, </span><br><span class="line">                             cls-&gt;<span class="built_in">nameForLogging</span>(), </span><br><span class="line">                             _category_getName(cat));</span><br><span class="line">            &#125;</span><br><span class="line">            (*load_method)(cls, SEL_load);</span><br><span class="line">            cats[i].cat = nil;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Compact detached list (order-preserving)</span></span><br><span class="line">    shift = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; used; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cats[i].cat) &#123;</span><br><span class="line">            cats[i-shift] = cats[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            shift++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    used -= shift;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy any new +load candidates from the new list to the detached list.</span></span><br><span class="line">    new_categories_added = (loadable_categories_used &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; loadable_categories_used; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (used == allocated) &#123;</span><br><span class="line">            allocated = allocated*<span class="number">2</span> + <span class="number">16</span>;</span><br><span class="line">            cats = (<span class="keyword">struct</span> loadable_category *)</span><br><span class="line">                <span class="built_in">realloc</span>(cats, allocated *</span><br><span class="line">                                  <span class="built_in">sizeof</span>(<span class="keyword">struct</span> loadable_category));</span><br><span class="line">        &#125;</span><br><span class="line">        cats[used++] = loadable_categories[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Destroy the new list.</span></span><br><span class="line">    <span class="keyword">if</span> (loadable_categories) <span class="built_in">free</span>(loadable_categories);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Reattach the (now augmented) detached list. </span></span><br><span class="line">    <span class="comment">// But if there&#x27;s nothing left to load, destroy the list.</span></span><br><span class="line">    <span class="keyword">if</span> (used) &#123;</span><br><span class="line">        loadable_categories = cats;</span><br><span class="line">        loadable_categories_used = used;</span><br><span class="line">        loadable_categories_allocated = allocated;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (cats) <span class="built_in">free</span>(cats);</span><br><span class="line">        loadable_categories = nil;</span><br><span class="line">        loadable_categories_used = <span class="number">0</span>;</span><br><span class="line">        loadable_categories_allocated = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (PrintLoading) &#123;</span><br><span class="line">        <span class="keyword">if</span> (loadable_categories_used != <span class="number">0</span>) &#123;</span><br><span class="line">            _objc_inform(<span class="string">&quot;LOAD: %d categories still waiting for +load\n&quot;</span>,</span><br><span class="line">                         loadable_categories_used);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> new_categories_added;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们在这篇博客的最后对整个过程进行一个简单的总结：</p>
<p>在应用启动的时候会从镜像中查找dyld的地址，而后将dyld加载进来，找到dyld的入口地址__dyld_start,并将后续工作交给 dyld 负责：</p>
<ol>
<li>dyld 开始将程序二进制文件实例化为一个ImageLoader</li>
<li>交由 ImageLoader 读取 image 其中包含了我们的类、方法等各种符号，以及根据Mach-O的Load Commands段加载所有依赖的动态库并完成链接，初始化工作。在主程序初始化阶段，runtime会向dyld绑定回调。</li>
<li>当image加载到内存后，dyld 会通知 runtime 进行处理，runtime 接手后调用 map_images 做解析和处理，接下来 load_images 中调用 call_load_methods 方法，<br>遍历所有加载进来的 Class，按继承层级依次调用 Class 的 +load 方法和其 Category 的 +load 方法</li>
<li>当map_images以及load_images执行完毕之后可执行文件中和动态库所有的符号（Class，Protocol，Selector，IMP，…）都已经按格式成功加载到内存中，被 runtime 所管理。</li>
<li>所有初始化工作结束后，dyld 调用真正的 main 函数，紧接着dyld 会清理现场，将调用栈回归，只剩下main函数。</li>
</ol>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Objective-C-%E7%9B%B8%E5%85%B3/">Objective C 相关</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/Objective-C-相关/">Objective C 相关</a>
  </div>

</div>



<div class="comments-count">
	
	  	<span></span>
		<a href="/2020/02/02/iOS-Runtime源码解析-Runtime初始化/#comments" class="ds-thread-count comments-count-link" data-thread-key="2020/02/02/iOS-Runtime源码解析-Runtime初始化/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2020/02/02/iOS-Runtime源码解析重要的数据结构介绍/" title="iOS Runtime源码解析重要的数据结构介绍" itemprop="url">iOS Runtime源码解析重要的数据结构介绍</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Edgar" target="_blank" itemprop="author">Edgar</a>
		
  <p class="article-time">
    <time datetime="2020-02-01T23:49:22.000Z" itemprop="datePublished"> Published 2020-02-02</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>很早之前写过图解Runtime系列，那时候比较忙只是画了流程图，当然对自己理解已经够用了，但是对于没有看过源码对同学可能会看不懂，想着一个系列的博客都快完成了，少了这块总觉得缺了什么，并且Runtime是iOS的核心对理解底层有很大帮助，所以找了个空余时间将这块补上了。</p>
<p>我们知道编程语言有静态语言和动态语言之分，静态语言在编译的时候就已经明确了每行代码最终执行哪些代码，Objective C 作为动态语言它的底层是由编译器和Runtime构成，编译时期只是决定向某个对象发送某个消息，但是最终这个对象怎么处理这个消息取决于这个对象而不是固定的，也就是说在编译之后还可以针对发过来的消息对这个消息进行一系列处理最终决定执行哪些代码，这部分工作都交由Runtime处理。在介绍Runtime细节之前我们先看下相关的数据结构，熟悉这些数据结构对理解Runtime来说是必不可少的。本文将以Objc 2.0 中的数据结构为研究对象。</p>
<p>我们上层最经常接触的应该算是<strong><strong>Class</strong></strong>和<strong><strong>id</strong></strong>这两个类型了，它实际上分别是****objc_class * <strong><strong>，</strong></strong>objc_object * ****的重定义类型。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">objc_class</span> *Class;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">objc_object</span> *id;</span><br></pre></td></tr></table></figure>

<ul>
<li><h6 id="objc-object-结构"><a href="#objc-object-结构" class="headerlink" title="objc_object 结构"></a><strong><strong>objc_object 结构</strong></strong></h6></li>
</ul>
<p>objc_object里面有个重要的成员对象<strong><strong>isa_t isa</strong></strong>，因为objc_object是用来存储对象数据用的，所以不宜将无用的数据存储在objc_object上，所以这里只存放了<strong><strong>isa_t isa</strong></strong>，通过<strong><strong>isa_t isa</strong></strong>可以找到objc_class，objc_class中存放的才是这些对象公用的数据。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">objc_object</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">isa_t</span> isa;</span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><h6 id="objc-class-结构"><a href="#objc-class-结构" class="headerlink" title="objc_class 结构"></a><strong><strong>objc_class 结构</strong></strong></h6></li>
</ul>
<p>objc_class结构如下所示：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">objc_class</span> : objc_object &#123;</span><br><span class="line">    <span class="comment">// Class ISA;</span></span><br><span class="line">    Class superclass;</span><br><span class="line">    <span class="type">cache_t</span> cache;             <span class="comment">// formerly cache pointer and vtable</span></span><br><span class="line">    <span class="type">class_data_bits_t</span> bits;    <span class="comment">// class_rw_t * plus custom rr/alloc flags</span></span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们从它的定义上看，它其实也是一个objc_object，所以objc_class也会有一个isa，它其实指向的是Meta class，Meta class 也是一个objc_class它和objc_object指向objc_class区别在于它的cache以及bits中存放的是类静态方法等数据。这些会在后面介绍。</p>
<ul>
<li><h6 id="isa-t-结构"><a href="#isa-t-结构" class="headerlink" title="isa_t 结构"></a><strong><strong>isa_t 结构</strong></strong></h6></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">union</span> <span class="title class_">isa_t</span> &#123;</span><br><span class="line">    <span class="built_in">isa_t</span>() &#123; &#125;</span><br><span class="line">    <span class="built_in">isa_t</span>(<span class="type">uintptr_t</span> value) : <span class="built_in">bits</span>(value) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    Class cls;</span><br><span class="line">    <span class="type">uintptr_t</span> bits;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(ISA_BITFIELD)</span></span><br><span class="line">    <span class="keyword">struct</span> &#123;</span><br><span class="line">        ISA_BITFIELD;  <span class="comment">// defined in isa.h</span></span><br><span class="line">    &#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong><strong>isa_t</strong></strong> 是一个共用体，在64位机器中会启用NONPOINTER_ISA优化，具体见<a target="_blank" rel="noopener" href="https://github.com/tbfungeek/iOS-Daily-Interview/issues/2">谈谈iOS的内存管理方式的理解</a>,这时候isa就不单纯用于存储指向某个类的指针。那么当启用NONPOINTER_ISA优化的时候作用域是怎样的呢？我们这里看到****#if defined(ISA_BITFIELD)****，这个条件编译，ISA_BITFIELD是在isa.h中定义的我们来看下它的具体定义：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"># <span class="keyword">if</span> __arm64__</span><br><span class="line"><span class="comment">//.........</span></span><br><span class="line">#   define ISA_BITFIELD                                                      \</span><br><span class="line">      <span class="built_in">uint</span>ptr_t nonpointer        : <span class="number">1</span>;                                       \</span><br><span class="line">      <span class="built_in">uint</span>ptr_t has_assoc         : <span class="number">1</span>;                                       \</span><br><span class="line">      <span class="built_in">uint</span>ptr_t has_cxx_dtor      : <span class="number">1</span>;                                       \</span><br><span class="line">      <span class="built_in">uint</span>ptr_t shiftcls          : <span class="number">33</span>; <span class="comment">/*MACH_VM_MAX_ADDRESS 0x1000000000*/</span> \</span><br><span class="line">      <span class="built_in">uint</span>ptr_t magic             : <span class="number">6</span>;                                       \</span><br><span class="line">      <span class="built_in">uint</span>ptr_t weakly_referenced : <span class="number">1</span>;                                       \</span><br><span class="line">      <span class="built_in">uint</span>ptr_t deallocating      : <span class="number">1</span>;                                       \</span><br><span class="line">      <span class="built_in">uint</span>ptr_t has_sidetable_rc  : <span class="number">1</span>;                                       \</span><br><span class="line">      <span class="built_in">uint</span>ptr_t extra_rc          : <span class="number">19</span></span><br></pre></td></tr></table></figure>

<p>下面是这些字段的意义：</p>
<ul>
<li><p><strong><strong>nonpointer （1位）</strong></strong> 标记是否是纯的ISA指针，还是非指针型的NOPOINTER_ISA指针indexed，0表示普通的isa,1表示NOPOINTER_ISA指针</p>
</li>
<li><p><strong><strong>has_assoc （1位）</strong></strong> 表示该对象是否包含 associated object，如果没有，则析构时会更快</p>
</li>
<li><p><strong><strong>has_cxx_dtor （1位）</strong></strong> 表示该对象是否有 C++ 或 ARC 的析构函数，如果没有，则析构时更快</p>
</li>
<li><p><strong><strong>shiftcls （33位）</strong></strong> 类的指针</p>
</li>
<li><p><strong><strong>magic（6位）</strong></strong> 固定值为 0xd2，用于在调试时分辨对象是否未完成初始化</p>
</li>
<li><p><strong><strong>weakly_referenced（1位）</strong></strong> 标记对象是否有弱引用指针weakly_referenced</p>
</li>
<li><p><strong><strong>deallocating （1位）</strong></strong> 该对象是否正在析构</p>
</li>
<li><p><strong><strong>has_sidetable_rc （1位）</strong></strong> 是否使用了引用计数表sideTable</p>
</li>
<li><p><strong><strong>extra_rc（19位）</strong></strong> 存储引用计数值减一后的值 (首先会存储在该字段中，当到达上限后，has_sidetable_rc 等于1，对应的引用计数值存入相应的引用计数表中)</p>
</li>
<li><h6 id="cache-t-结构"><a href="#cache-t-结构" class="headerlink" title="cache_t 结构"></a><strong><strong>cache_t 结构</strong></strong></h6></li>
</ul>
<p>cache_t主要用于存储某个类中使用过方法的缓存，一般一个类会有很多方法，这些方法并不都是常用的，如果每次调用都需要从该类的所有方法列表中查询明显会降低效率，所以这里引入了cache_t，通过这种以空间换时间的方式来加快方法查找效率。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">cache_t</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">bucket_t</span> *_buckets;</span><br><span class="line">    <span class="type">mask_t</span> _mask;</span><br><span class="line">    <span class="type">mask_t</span> _occupied;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>cache_t中包含三个属性：</p>
<p><strong><strong>_buckets</strong></strong> 指向bucket_t结构体，它实际上是一个可动态扩展的哈希表。在存储的数据超过3&#x2F;4的时候就会调用expend方法进行扩展。****_mask**** 表示整个_buckets链表的大小，****_occupied****表示当前_buckets链表里面缓存的bucket_t节点数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">bucket_t</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    MethodCacheIMP _imp;</span><br><span class="line">    <span class="type">cache_key_t</span> _key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><strong>bucket_t</strong></strong> 结构也十分简单，就是一个以selector映射而成的cache_key_t以及方法指针_imp。</p>
<ul>
<li><h6 id="class-data-bits-t-结构"><a href="#class-data-bits-t-结构" class="headerlink" title="class_data_bits_t 结构"></a><strong><strong>class_data_bits_t 结构</strong></strong></h6></li>
</ul>
<p>我们再继续看objc_class中的class_data_bits_t类型：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">class_data_bits_t</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">uintptr_t</span> bits;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">class_rw_t</span>* <span class="title">data</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">class_rw_t</span> *)(bits &amp; FAST_DATA_MASK);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里最关键的数据为class_rw_t，它才是包含类最有用信息的部分，我们从名字上可以看出它是可读写的，为什么要强调它是可读写的，因为它里面还有一个十分重要的class_ro_t类型。这个我们后面再介绍，我们先将重心放在class_rw_t中：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">class_rw_t</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> flags;</span><br><span class="line">    <span class="type">uint32_t</span> version;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">class_ro_t</span> *ro;</span><br><span class="line"></span><br><span class="line">    <span class="type">method_array_t</span> methods;</span><br><span class="line">    <span class="type">property_array_t</span> properties;</span><br><span class="line">    <span class="type">protocol_array_t</span> protocols;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">class_rw_t</span>* <span class="title">data</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">class_rw_t</span> *)(bits &amp; FAST_DATA_MASK);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//........</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><strong><strong>methods</strong></strong>对象或者类的方法，这部分是可读写的，在Runtime阶段，会将分类的中的方法追加到这部分。</li>
<li><strong><strong>properties</strong></strong>对象或者类的属性</li>
<li><strong><strong>protocols</strong></strong>对象或者类的协议</li>
<li><strong><strong>ro</strong></strong>对象或者类中只读的部分，这部分在编译时期就已经确定了。</li>
</ul>
<p>我们再来看下<strong><strong>class_ro_t</strong></strong>结构：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">class_ro_t</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> * name;</span><br><span class="line">    <span class="type">uint32_t</span> flags;</span><br><span class="line">    <span class="type">uint32_t</span> instanceStart;</span><br><span class="line">    <span class="type">uint32_t</span> instanceSize;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">ivar_list_t</span> * ivars;</span><br><span class="line">    <span class="type">const</span> <span class="type">uint8_t</span> * ivarLayout;</span><br><span class="line">    <span class="type">const</span> <span class="type">uint8_t</span> * weakIvarLayout;</span><br><span class="line"></span><br><span class="line">    <span class="type">method_list_t</span> * baseMethodList;</span><br><span class="line">    <span class="type">protocol_list_t</span> * baseProtocols;</span><br><span class="line">    <span class="type">property_list_t</span> *baseProperties;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>它包括实例起始位置<strong><strong>instanceStart</strong></strong>，以及实例大小<strong><strong>instanceSize</strong></strong>。<br>成员变量相关：<strong><strong>ivars</strong></strong>，<strong><strong>ivarLayout</strong></strong>，<strong><strong>weakIvarLayout</strong></strong>。<br>基础成分：<strong><strong>baseMethodList</strong></strong>，<strong><strong>baseProtocols</strong></strong>，<strong><strong>baseProperties</strong></strong></p>
<ul>
<li><h6 id="SEL-定义"><a href="#SEL-定义" class="headerlink" title="SEL 定义"></a><strong><strong>SEL 定义</strong></strong></h6></li>
</ul>
<p>SEL和id Class 一样都是objc对应类型的结构体指针的便捷定义。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">objc_selector</span> *SEL;</span><br></pre></td></tr></table></figure>

<p>objc_selector是一个映射到方法的C字符串，不同类中相同名字的方法所对应的selector是相同的，即使方法名字相同而变量类型不同也会导致它们具有相同的selector。由于这点特性，导致了OC不支持函数重载。简单说SEL不包含返回值类型，参数类型，以及所属类的信息。只包含方法名对应的信息，实际上它在Runtime中作为消息发送给对象，对象根据它来查找对应的 IMP进行执行。</p>
<ul>
<li><h6 id="IMP-定义"><a href="#IMP-定义" class="headerlink" title="IMP 定义"></a><strong><strong>IMP 定义</strong></strong></h6></li>
</ul>
<p>IMP是函数指针，即函数执行的入口。该函数使用标准的C调用。</p>
<figure class="highlight elm"><table><tr><td class="code"><pre><span class="line">typedef id _Nullable (*<span class="type">IMP</span>)(id _Nonnull, <span class="type">SEL</span> _Nonnull, ...); </span><br></pre></td></tr></table></figure>
<p>它包含两个参数：</p>
<ul>
<li><p>第一个参数指向 self（它代表当前类实例的地址，如果是类则指向的是它的元类），作为消息的接受者；</p>
</li>
<li><p>第二个参数代表方法的选择子；</p>
</li>
<li><p>… 代表可选参数，前面的 id 代表返回值。</p>
</li>
<li><h6 id="Method-定义"><a href="#Method-定义" class="headerlink" title="Method 定义"></a><strong><strong>Method 定义</strong></strong></h6></li>
</ul>
<figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line">typedef struct method_t *<span class="keyword">Method</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">struct method_t &#123;</span><br><span class="line">    SEL name<span class="comment">;</span></span><br><span class="line">    const char *types<span class="comment">;</span></span><br><span class="line">    MethodListIMP imp<span class="comment">;</span></span><br><span class="line">    //.....</span><br><span class="line">&#125;<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>我们知道一个方法的组成包括方法返回值，方法参数，方法名，方法实现体，对应于method_t分别是<strong><strong>types</strong></strong>，<strong><strong>name</strong></strong>，<strong><strong>imp</strong></strong>，关于types涉及到类型编码，如果大家不了解可以通过如下链接进行扩展阅读：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://nshipster.cn/type-encodings/">Type Encodings</a></li>
<li><a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html">Apple Develper Type Encodings</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/liumengdi666/article/details/52402296">iOS类型编码Type Encodings与属性类型Property Type</a></li>
</ul>
<p>在实际编程中可以通过method_getTypeEncoding方法来获得：</p>
<figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> char * _Nullable method_getTypeEncoding(<span class="keyword">Method</span> _<span class="title function_">Nonnull</span> <span class="title function_">m</span>)</span><br></pre></td></tr></table></figure>

<p><img src="/2020/02/02/iOS-Runtime%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E9%87%8D%E8%A6%81%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BB%8B%E7%BB%8D/000000001.png"></p>
<ul>
<li><h6 id="protocol-t-定义"><a href="#protocol-t-定义" class="headerlink" title="protocol_t 定义"></a><strong><strong>protocol_t 定义</strong></strong></h6></li>
</ul>
<p>protocol_t 主要用于存放协议相关的数据（注意它其实也是一个objc_object），由于协议也可以遵循协议，所以协议内部有协议列表用于存放当前协议所遵循的协议。而实例方法和类方法都包含必须实现和可选实现的部分，这两部是分开存放的，同时需要注意的是协议内部也为实例方法中提供了属性的存储，实际上协议也可以声明属性的，在介绍协议的使用的时候会给予介绍。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">protocol_t</span> : objc_object &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">protocol_list_t</span> *protocols;</span><br><span class="line">    <span class="type">method_list_t</span> *instanceMethods;</span><br><span class="line">    <span class="type">method_list_t</span> *classMethods;</span><br><span class="line">    <span class="type">method_list_t</span> *optionalInstanceMethods;</span><br><span class="line">    <span class="type">method_list_t</span> *optionalClassMethods;</span><br><span class="line">    <span class="type">property_list_t</span> *instanceProperties;</span><br><span class="line">    <span class="type">uint32_t</span> size;   <span class="comment">// sizeof(protocol_t)</span></span><br><span class="line">    <span class="type">uint32_t</span> flags;</span><br><span class="line">    <span class="comment">//.......</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<ul>
<li><h6 id="property-t-定义"><a href="#property-t-定义" class="headerlink" title="property_t 定义"></a><strong><strong>property_t 定义</strong></strong></h6></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">property_t</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *attributes;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对于属性结构比较简单就只有属性名字，以及对应的属性字符串，至于属性至于属性字符串的介绍可以看下面官方的文档介绍：</p>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtPropertyIntrospection.html">Property Type and Functions</a></p>
</li>
<li><h6 id="ivar-t-定义"><a href="#ivar-t-定义" class="headerlink" title="ivar_t 定义"></a><strong><strong>ivar_t 定义</strong></strong></h6></li>
</ul>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ivar_t</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int32_t</span> *offset;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *type;</span><br><span class="line">    <span class="comment">// alignment is sometimes -1; use alignment() instead</span></span><br><span class="line">    <span class="type">uint32_t</span> alignment_raw;</span><br><span class="line">    <span class="type">uint32_t</span> size;</span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果我们使用下面方式声明实例变量，那么这些实例变量就会转换为ivar_t</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@interface</span> <span class="attribute">TestClass </span>: NSObject &#123;</span><br><span class="line">    <span class="variable">@public</span></span><br><span class="line">        NSString *_name;</span><br><span class="line">    <span class="variable">@private</span></span><br><span class="line">        NSString *_ID;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是实际开发中大多数使用属性而不使用这种方法，使用这种写法，对象布局在编译器就已经固定了。只要碰到访问_name变量的代码，编译器就把其替换为偏移量ivar_t 中的（offset），这个偏移量是硬编码，表示该变量距离存放对象的内存区域的起始地址有多远。但是如果在运行过程中，又新增了一个实例变量，硬编码于其中的变量就会读到错误的值，这也是为什么OC无法动态添加成员变量的原因。</p>
<p>最后使用一个图来总结下全文的内容：</p>
<p><img src="/2020/02/02/iOS-Runtime%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E9%87%8D%E8%A6%81%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BB%8B%E7%BB%8D/000000002.png"></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Objective-C-%E7%9B%B8%E5%85%B3/">Objective C 相关</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/Objective-C-相关/">Objective C 相关</a>
  </div>

</div>



<div class="comments-count">
	
	  	<span></span>
		<a href="/2020/02/02/iOS-Runtime源码解析重要的数据结构介绍/#comments" class="ds-thread-count comments-count-link" data-thread-key="2020/02/02/iOS-Runtime源码解析重要的数据结构介绍/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2020/01/18/iOS-Runtime源码解析之Runtime较好的文章推荐-md/" title="iOS-Runtime源码解析之Runtime较好的文章推荐" itemprop="url">iOS-Runtime源码解析之Runtime较好的文章推荐</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Edgar" target="_blank" itemprop="author">Edgar</a>
		
  <p class="article-time">
    <time datetime="2020-01-18T15:33:27.000Z" itemprop="datePublished"> Published 2020-01-18</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h5 id="1-draveness"><a href="#1-draveness" class="headerlink" title="1. draveness"></a>1. <a target="_blank" rel="noopener" href="https://github.com/draveness/analyze">draveness</a></h5><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/draveness/analyze/blob/master/contents/objc/%E4%BB%8E%20NSObject%20%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E4%BA%86%E8%A7%A3%20isa.md">从 NSObject 的初始化了解 isa</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/draveness/analyze/blob/master/contents/objc/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%20ObjC%20%E4%B8%AD%E6%96%B9%E6%B3%95%E7%9A%84%E7%BB%93%E6%9E%84.md">深入解析 ObjC 中方法的结构</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/draveness/analyze/blob/master/contents/objc/%E4%BB%8E%E6%BA%90%E4%BB%A3%E7%A0%81%E7%9C%8B%20ObjC%20%E4%B8%AD%E6%B6%88%E6%81%AF%E7%9A%84%E5%8F%91%E9%80%81.md">从源代码看 ObjC 中消息的发送</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/draveness/analyze/blob/master/contents/objc/%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3%20load%20%E6%96%B9%E6%B3%95%E4%B9%88%EF%BC%9F.md">你真的了解 load 方法么？</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/draveness/analyze/blob/master/contents/objc/%E8%87%AA%E5%8A%A8%E9%87%8A%E6%94%BE%E6%B1%A0%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F.md">自动释放池的前世今生</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/draveness/analyze/blob/master/contents/objc/%E9%BB%91%E7%AE%B1%E4%B8%AD%E7%9A%84%20retain%20%E5%92%8C%20release.md">黑箱中的 retain 和 release</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/draveness/analyze/blob/master/contents/objc/%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1%20AssociatedObject%20%E5%AE%8C%E5%85%A8%E8%A7%A3%E6%9E%90.md">关联对象 AssociatedObject 完全解析</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/draveness/analyze/blob/master/contents/objc/%E6%87%92%E6%83%B0%E7%9A%84%20initialize%20%E6%96%B9%E6%B3%95.md">懒惰的 initialize 方法</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/draveness/analyze/blob/master/contents/objc/%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%A6%82%E4%BD%95%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%EF%BC%88iOS%EF%BC%89.md">对象是如何初始化的（iOS）</a></li>
</ul>
<h5 id="2-南峰子"><a href="#2-南峰子" class="headerlink" title="2. 南峰子"></a>2. <a target="_blank" rel="noopener" href="https://southpeak.github.io/">南峰子</a></h5><ul>
<li><a target="_blank" rel="noopener" href="http://southpeak.github.io/2014/10/25/objective-c-runtime-1/">Objective-C Runtime 运行时之一：类与对象</a></li>
<li><a target="_blank" rel="noopener" href="http://southpeak.github.io/2014/10/30/objective-c-runtime-2/">Objective-C Runtime 运行时之二：成员变量与属性</a></li>
<li><a target="_blank" rel="noopener" href="http://southpeak.github.io/2014/11/03/objective-c-runtime-3/">Objective-C Runtime 运行时之三：方法与消息</a></li>
<li><a target="_blank" rel="noopener" href="http://southpeak.github.io/2014/11/06/objective-c-runtime-4/">Objective-C Runtime 运行时之四：Method Swizzling</a></li>
<li><a target="_blank" rel="noopener" href="http://southpeak.github.io/2014/11/08/objective-c-runtime-5/">Objective-C Runtime 运行时之五：协议与分类</a></li>
<li><a target="_blank" rel="noopener" href="http://southpeak.github.io/2014/11/09/objective-c-runtime-6/">Objective-C Runtime 运行时之六：拾遗</a></li>
</ul>
<h5 id="3-halfrost"><a href="#3-halfrost" class="headerlink" title="3. halfrost"></a>3. <a target="_blank" rel="noopener" href="https://halfrost.com/">halfrost</a></h5><ul>
<li><a target="_blank" rel="noopener" href="http://halfrost.com/objc_life/">Objc 对象的今生今世</a></li>
<li><a target="_blank" rel="noopener" href="http://halfrost.com/objc_runtime_isa_class/">神经病院 Objective-C Runtime 入院第一天 —— isa 和 Class</a></li>
<li><a target="_blank" rel="noopener" href="http://halfrost.com/objc_runtime_objc_msgsend/">神经病院 Objective-C Runtime 住院第二天 —— 消息发送与转发</a></li>
<li><a target="_blank" rel="noopener" href="http://halfrost.com/how_to_use_runtime/">神经病院 Objective-C Runtime 出院第三天 —— 如何正确使用 Runtime</a></li>
</ul>
<h5 id="4-雷纯锋"><a href="#4-雷纯锋" class="headerlink" title="4. 雷纯锋"></a>4. <a target="_blank" rel="noopener" href="http://blog.leichunfeng.com/">雷纯锋</a></h5><ul>
<li><a target="_blank" rel="noopener" href="http://blog.leichunfeng.com/blog/2015/04/25/objective-c-object-model/">Objective-C 对象模型</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.leichunfeng.com/blog/2015/05/02/objective-c-plus-load-vs-plus-initialize/">Objective-C +load vs +initialize</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.leichunfeng.com/blog/2015/05/18/objective-c-category-implementation-principle/">Objective-C Category 的实现原理</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.leichunfeng.com/blog/2015/05/31/objective-c-autorelease-pool-implementation-principle/">Objective-C Autorelease Pool 的实现原理</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.leichunfeng.com/blog/2015/06/14/objective-c-method-swizzling-best-practice/">Objective-C Method Swizzling 的最佳实践</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.leichunfeng.com/blog/2015/06/26/objective-c-associated-objects-implementation-principle/">Objective-C Associated Objects 的实现原理</a></li>
</ul>
<h5 id="5-sunnyxx"><a href="#5-sunnyxx" class="headerlink" title="5. sunnyxx"></a>5. <a target="_blank" rel="noopener" href="http://blog.sunnyxx.com/">sunnyxx</a></h5><ul>
<li><a target="_blank" rel="noopener" href="http://blog.sunnyxx.com/2014/08/24/objc-duck/">objc 与鸭子对象（上）</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.sunnyxx.com/2014/08/26/objc-duck-advanced/">objc 与鸭子对象（下）</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.sunnyxx.com/2014/11/06/runtime-nuts/">神经病院 objc runtime 入院考试</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.sunnyxx.com/2016/08/13/reunderstanding-runtime-0/">重识 Objective-C Runtime - Smalltalk 与 C 的融合</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.sunnyxx.com/2016/08/13/reunderstanding-runtime-1/">重识 Objective-C Runtime - 看透 Type 与 Value</a></li>
</ul>
<h5 id="6-ibireme"><a href="#6-ibireme" class="headerlink" title="6. ibireme"></a>6. <a target="_blank" rel="noopener" href="http://blog.sunnyxx.com/">ibireme</a></h5><ul>
<li><a target="_blank" rel="noopener" href="https://blog.ibireme.com/2013/11/25/objc-object/">Objective-C 中的类和对象</a></li>
</ul>
<h5 id="7-唐巧"><a href="#7-唐巧" class="headerlink" title="7. 唐巧"></a>7. <a target="_blank" rel="noopener" href="https://blog.devtang.com/">唐巧</a></h5><ul>
<li><a target="_blank" rel="noopener" href="https://blog.devtang.com/2013/10/15/objective-c-object-model/">Objective-C对象模型及应用</a></li>
</ul>
<h5 id="8-CornBallast"><a href="#8-CornBallast" class="headerlink" title="8. CornBallast"></a>8. <a target="_blank" rel="noopener" href="https://www.jianshu.com/u/a9008a597529">CornBallast</a></h5><ul>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/88d11bb12ba1">Runtime 深度解析以及实用技巧</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/37e1b71ad03a">Runtime 奇技淫巧__带你深入理解 Runtime 特有概念</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/38bbde2c5632">Runtime 奇技淫巧__不受限制的消息发送</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/cb55dbb72c84">Runtime 奇技淫巧__获取类的实例变量以及属性并强势 与KVC、msgSend 混用</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/13ab44c46904">Runtime 奇技淫巧__方法交换</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/48220940118f">Runtime 奇技淫巧__动态链接对象以及给分类添加属性</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/c5bdd6f7a68c">Runtime 奇技淫巧__动态添加方法，消息转发改善异常</a></li>
</ul>
<h5 id="9-杨萧玉"><a href="#9-杨萧玉" class="headerlink" title="9. 杨萧玉"></a>9. <a target="_blank" rel="noopener" href="http://yulingtianxia.com/">杨萧玉</a></h5><ul>
<li><a target="_blank" rel="noopener" href="http://yulingtianxia.com/blog/2014/11/05/objective-c-runtime/">Objective-C Runtime</a></li>
<li><a target="_blank" rel="noopener" href="http://yulingtianxia.com/blog/2016/06/15/Objective-C-Message-Sending-and-Forwarding/">Objective-C 消息发送与转发机制原理</a></li>
</ul>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Objective-C-%E7%9B%B8%E5%85%B3/">Objective C 相关</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/Objective-C-相关/">Objective C 相关</a>
  </div>

</div>



<div class="comments-count">
	
	  	<span></span>
		<a href="/2020/01/18/iOS-Runtime源码解析之Runtime较好的文章推荐-md/#comments" class="ds-thread-count comments-count-link" data-thread-key="2020/01/18/iOS-Runtime源码解析之Runtime较好的文章推荐-md/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2020/01/14/iOS-Runtime源码解析之dyld/" title="iOS Runtime源码解析之dyld" itemprop="url">iOS Runtime源码解析之dyld</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Edgar" target="_blank" itemprop="author">Edgar</a>
		
  <p class="article-time">
    <time datetime="2020-01-13T16:19:28.000Z" itemprop="datePublished"> Published 2020-01-14</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h4 id="源码地址"><a href="#源码地址" class="headerlink" title="源码地址"></a>源码地址</h4><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/opensource-apple/dyld">dyld</a></li>
</ul>
<h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><p>上一篇博客已经介绍到dyld被加载，以及设置dyld的入口点为__dyld_start,这篇博客就从__dyld_start开始看下应用执行main之前都经历了哪些过程，在开始之前我们需要先对iOS中对动态库有一定对了解，如果你之前接触过其他平台你可能会听说过Windows系统下的DLL文件，Linux 系统下的so文件，iOS系统则是使用dylib作为动态库，至于iOS动态库与静态库的对比我们会专门用一篇博客进行介绍，dylib和普通的可执行文件在文件结构上大同小异，都是Mach O格式文件，只不过在文件类型上，一个是MH_DYLIB,一个是MH_EXECUTE，但是动态库不能像可执行文件那样直接运行，而是需要通过dyld加载到内存与主程序链接后才可以执行，在主程序启动后会通过dyld将它所依赖的全部动态链接库链接起来，最终组成可运行的应用。</p>
<p>如果想查看某个可执行文件所依赖的动态链接库可以通过命令：<strong><strong>jtool -L IDLFundation</strong></strong> 来查看，我们接下来就来看下整个过程：</p>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line">__dyld_start:</span><br><span class="line">	popq	%rdi		<span class="comment"># param1 = mh of app</span></span><br><span class="line">	pushq	$0		<span class="comment"># push a zero for debugger end of frames marker</span></span><br><span class="line">	movq	%rsp,%rbp	<span class="comment"># pointer to base of kernel frame</span></span><br><span class="line">	andq    $-<span class="number">16</span>,%rsp       <span class="comment"># force SSE alignment</span></span><br><span class="line">	subq	$16,%rsp	<span class="comment"># room for local variables</span></span><br><span class="line">	</span><br><span class="line">    //调用dyldbootstrap::start</span><br><span class="line">	<span class="comment"># call dyldbootstrap::start(app_mh, argc, argv, slide, dyld_mh, &amp;startGlue)</span></span><br><span class="line">	movl	<span class="number">8</span>(%rbp),%esi	<span class="comment"># param2 = argc into %esi</span></span><br><span class="line">	leaq	<span class="number">16</span>(%rbp),%rdx	<span class="comment"># param3 = &amp;argv[0] into %rdx</span></span><br><span class="line">	movq	__dyld_start_static(%rip), %r8</span><br><span class="line">	leaq	__dyld_start(%rip), %rcx</span><br><span class="line">	subq	 %r8, %rcx	<span class="comment"># param4 = slide into %rcx</span></span><br><span class="line">	leaq	___dso_handle(%rip),%r8 <span class="comment"># param5 = dyldsMachHeader</span></span><br><span class="line">	leaq	-<span class="number">8</span>(%rbp),%r9</span><br><span class="line">	call	__ZN13dyldbootstrap5startEPK12macho_headeriPPKclS2_Pm</span><br><span class="line">	movq	-<span class="number">8</span>(%rbp),%rdi</span><br><span class="line">	cmpq	$0,%rdi</span><br><span class="line">	jne	Lnew</span><br></pre></td></tr></table></figure>

<p>在__dyld_start会通过汇编调用dyldbootstrap::start方法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">uintptr_t</span> <span class="title">start</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> macho_header* appsMachHeader, <span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv[], </span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">intptr_t</span> slide, <span class="type">const</span> <span class="keyword">struct</span> macho_header* dyldsMachHeader,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">uintptr_t</span>* startGlue)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//.........</span></span><br><span class="line">    <span class="keyword">return</span> dyld::_main(appsMachHeader, appsSlide, argc, argv, envp, apple, startGlue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>dyldbootstrap::start方法中会进入dyld的入口main函数。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">_main(<span class="type">const</span> macho_header* mainExecutableMH, <span class="type">uintptr_t</span> mainExecutableSlide, </span><br><span class="line">        <span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv[], <span class="type">const</span> <span class="type">char</span>* envp[], <span class="type">const</span> <span class="type">char</span>* apple[], </span><br><span class="line">        <span class="type">uintptr_t</span>* startGlue)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uintptr_t</span> result = <span class="number">0</span>;</span><br><span class="line">    sMainExecutableMachHeader = mainExecutableMH;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置ImageLoader的context</span></span><br><span class="line">    <span class="built_in">setContext</span>(mainExecutableMH, argc, argv, envp, apple);</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="comment">// instantiate ImageLoader for main executable</span></span><br><span class="line">        <span class="comment">// 加载Image(代表镜像)</span></span><br><span class="line">        <span class="comment">// 为主程序初始化imageLoader,用于后续的链接等过程</span></span><br><span class="line">        sMainExecutable = <span class="built_in">instantiateFromLoadedImage</span>(mainExecutableMH, mainExecutableSlide, sExecPath);</span><br><span class="line">        gLinkContext.mainExecutable = sMainExecutable;</span><br><span class="line">        gLinkContext.processIsRestricted = sProcessIsRestricted;</span><br><span class="line">        gLinkContext.processRequiresLibraryValidation = sProcessRequiresLibraryValidation;</span><br><span class="line">        gLinkContext.mainExecutableCodeSigned = <span class="built_in">hasCodeSignatureLoadCommand</span>(mainExecutableMH);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//.....</span></span><br><span class="line">        <span class="keyword">if</span> ( gLinkContext.sharedRegionMode != ImageLoader::kDontUseSharedRegion )</span><br><span class="line">            <span class="comment">// 将共享库加载到内存中</span></span><br><span class="line">            <span class="built_in">mapSharedCache</span>();</span><br><span class="line">        <span class="comment">// .......</span></span><br><span class="line">        <span class="comment">// 如果有插入的库,加载</span></span><br><span class="line">        <span class="comment">// load any inserted libraries</span></span><br><span class="line">        <span class="keyword">if</span>( sEnv.DYLD_INSERT_LIBRARIES != <span class="literal">NULL</span> ) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">const</span> <span class="type">char</span>* <span class="type">const</span>* lib = sEnv.DYLD_INSERT_LIBRARIES; *lib != <span class="literal">NULL</span>; ++lib) </span><br><span class="line">                <span class="comment">//// 加载环境变量DYLD_INSERT_LIBRARIES中的动态库，使用loadInsertedDylib进行加载</span></span><br><span class="line">                <span class="built_in">loadInsertedDylib</span>(*lib);<span class="comment">//把环境变量DYLD_INSERT_LIBRARIES 中的动态库调用loadInsertedDylib进行加载</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// record count of inserted libraries so that a flat search will look at </span></span><br><span class="line">        <span class="comment">// inserted libraries, then main, then others.</span></span><br><span class="line">        sInsertedDylibCount = sAllImages.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// link main executable</span></span><br><span class="line">        <span class="comment">// 链接主程序</span></span><br><span class="line">        gLinkContext.linkingMainExecutable = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//继续回到dyld的_main函数中来,继续加载根目录Framework目录下的其他动态库. 加载完所有的dylibs之后,每个dylib之间还是没有关联,</span></span><br><span class="line">        <span class="comment">//不知道怎么调用,这时候就该进行link操作了,link操作分成rebase和binding辆部分.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//ASLR（Address space layout randomization）是一种针对缓冲区溢出的安全保护技术，</span></span><br><span class="line">        <span class="comment">//通过对堆、栈、共享库映射等线性区布局的随机化，通过增加攻击者预测目的地址的难度，防止攻击者直接定位攻击代码位置，达到阻止溢出攻击的目的。</span></span><br><span class="line">        <span class="comment">//据研究表明ASLR可以有效的降低缓冲区溢出攻击的成功率，如今Linux、FreeBSD、Windows等主流操作系统都已采用了该技术。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//rebase: 由于ASLR访问地址被随机化,所以rebase在动态库内部进行修正访问地址,并创建访问地址存储在__DATA段,这个期间可能会产生缺页并进行IO操作</span></span><br><span class="line">        <span class="comment">//binding: 主要负责动态库之间的调用地址的修正和创建</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//initialize</span></span><br><span class="line">        <span class="comment">//这里就比较简单了, 这个时候各个库都已经load完成,访问地址指针也已经修正过,就可以初始化所有dylib了, 会调用C++的初始化构造方法,</span></span><br><span class="line">        <span class="comment">//也就是用__attribute__((constructor))修饰的方法,被修饰的方法都会在main()方法之前调用</span></span><br><span class="line">        <span class="built_in">link</span>(sMainExecutable, sEnv.DYLD_BIND_AT_LAUNCH, <span class="literal">true</span>, ImageLoader::<span class="built_in">RPathChain</span>(<span class="literal">NULL</span>, <span class="literal">NULL</span>));</span><br><span class="line">        sMainExecutable-&gt;<span class="built_in">setNeverUnloadRecursive</span>();</span><br><span class="line">        <span class="keyword">if</span> ( sMainExecutable-&gt;forceFlat() ) &#123;</span><br><span class="line">            gLinkContext.bindFlat = <span class="literal">true</span>;</span><br><span class="line">            gLinkContext.prebindUsage = ImageLoader::kUseNoPrebinding;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// link any inserted libraries</span></span><br><span class="line">        <span class="comment">// 链接任何插入的库</span></span><br><span class="line">        <span class="comment">// do this after linking main executable so that any dylibs pulled in by inserted </span></span><br><span class="line">        <span class="comment">// dylibs (e.g. libSystem) will not be in front of dylibs the program uses</span></span><br><span class="line">        <span class="keyword">if</span> ( sInsertedDylibCount &gt; <span class="number">0</span> ) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">unsigned</span> <span class="type">int</span> i=<span class="number">0</span>; i &lt; sInsertedDylibCount; ++i) &#123;</span><br><span class="line">                ImageLoader* image = sAllImages[i+<span class="number">1</span>];</span><br><span class="line">                <span class="built_in">link</span>(image, sEnv.DYLD_BIND_AT_LAUNCH, <span class="literal">true</span>, ImageLoader::<span class="built_in">RPathChain</span>(<span class="literal">NULL</span>, <span class="literal">NULL</span>));</span><br><span class="line">                image-&gt;<span class="built_in">setNeverUnloadRecursive</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// only INSERTED libraries can interpose</span></span><br><span class="line">            <span class="comment">// register interposing info after all inserted libraries are bound so chaining works</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">unsigned</span> <span class="type">int</span> i=<span class="number">0</span>; i &lt; sInsertedDylibCount; ++i) &#123;</span><br><span class="line">                ImageLoader* image = sAllImages[i+<span class="number">1</span>];</span><br><span class="line">                image-&gt;<span class="built_in">registerInterposing</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// &lt;rdar://problem/19315404&gt; dyld should support interposition even without DYLD_INSERT_LIBRARIES</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=sInsertedDylibCount+<span class="number">1</span>; i &lt; sAllImages.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            ImageLoader* image = sAllImages[i];</span><br><span class="line">            <span class="keyword">if</span> ( image-&gt;<span class="built_in">inSharedCache</span>() )</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            image-&gt;<span class="built_in">registerInterposing</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// apply interposing to initial set of images</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i &lt; sImageRoots.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            sImageRoots[i]-&gt;<span class="built_in">applyInterposing</span>(gLinkContext);</span><br><span class="line">        &#125;</span><br><span class="line">        gLinkContext.linkingMainExecutable = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        sMainExecutable-&gt;<span class="built_in">weakBind</span>(gLinkContext);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">initializeMainExecutable</span>(); </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 寻找主程序的入口</span></span><br><span class="line">        <span class="comment">// find entry point for main executable</span></span><br><span class="line">        result = (<span class="type">uintptr_t</span>)sMainExecutable-&gt;<span class="built_in">getThreadPC</span>();</span><br><span class="line">        <span class="keyword">if</span> ( result != <span class="number">0</span> ) &#123;</span><br><span class="line">            <span class="comment">// 主可执行文件使用lc_main，需要返回libdyld.dylib中的glue</span></span><br><span class="line">            <span class="comment">//调用main()</span></span><br><span class="line">            <span class="comment">//当执行完dyld::_main方法之后,返回了main()函数地址,这个时候所有初始化工作都已经完成了,正式进入Objc声明周期</span></span><br><span class="line">            <span class="comment">// main executable uses LC_MAIN, needs to return to glue in libdyld.dylib</span></span><br><span class="line">            <span class="keyword">if</span> ( (gLibSystemHelpers != <span class="literal">NULL</span>) &amp;&amp; (gLibSystemHelpers-&gt;version &gt;= <span class="number">9</span>) )</span><br><span class="line">                *startGlue = (<span class="type">uintptr_t</span>)gLibSystemHelpers-&gt;startGlueToCallExit;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">halt</span>(<span class="string">&quot;libdyld.dylib support not present for LC_MAIN&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// main executable uses LC_UNIXTHREAD, dyld needs to let &quot;start&quot; in program set up for main()</span></span><br><span class="line">            result = (<span class="type">uintptr_t</span>)sMainExecutable-&gt;<span class="built_in">getMain</span>();</span><br><span class="line">            *startGlue = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span>(<span class="type">const</span> <span class="type">char</span>* message) &#123;</span><br><span class="line">        <span class="built_in">syncAllImages</span>();</span><br><span class="line">        <span class="built_in">halt</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span>(...) &#123;</span><br><span class="line">        dyld::<span class="built_in">log</span>(<span class="string">&quot;dyld: launch failed\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在main函数中会执行如下操作：</p>
<ol>
<li>将主程序初始化为imageLoader,用于后续的链接等操作</li>
<li>加载共享库到内存</li>
<li>加载插入的动态库</li>
<li>链接主程序,链接插入库</li>
<li>初始化主程序</li>
<li>寻找主程序入口点</li>
</ol>
<p>接下来我们将按照上面的顺序进行展开：</p>
<p><strong><strong>将主程序初始化为imageLoader</strong></strong></p>
<p>在dyld main方法中会通过instantiateFromLoadedImage创建ImageLoader，其中第一个参数传入的是mainExecutableMH为主程序的Mach O Header,有了mainExecutableMH，dyld就可以从头开始遍历整个Mach O文件信息了。在开始创建ImageLoader之前会先调用isCompatibleMachO来查看mainExecutableMH中的cputype与cpusubtype是否与当前设备兼容，只有兼容的情况下才会继续创建ImageLoader,创建后的ImageLoader会通过addImage添加到sAllImages，然后调用addMappedRange()申请内存，更新主程序镜像映射的内存区。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">static ImageLoader* instantiate<span class="constructor">FromLoadedImage(<span class="params">const</span> <span class="params">macho_header</span><span class="operator">*</span> <span class="params">mh</span>, <span class="params">uintptr_t</span> <span class="params">slide</span>, <span class="params">const</span> <span class="params">char</span><span class="operator">*</span> <span class="params">path</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 检测mach-o header的cputype与cpusubtype是否与当前系统兼容</span></span><br><span class="line">    <span class="keyword">if</span> ( is<span class="constructor">CompatibleMachO((<span class="params">const</span> <span class="params">uint8_t</span><span class="operator">*</span>)</span>mh, path) ) &#123;</span><br><span class="line">        <span class="comment">//初始化镜像加载器</span></span><br><span class="line">        ImageLoader* image = ImageLoaderMachO::instantiate<span class="constructor">MainExecutable(<span class="params">mh</span>, <span class="params">slide</span>, <span class="params">path</span>, <span class="params">gLinkContext</span>)</span>;</span><br><span class="line">        add<span class="constructor">Image(<span class="params">image</span>)</span>;</span><br><span class="line">        return image;</span><br><span class="line">    &#125;</span><br><span class="line">    throw <span class="string">&quot;main executable not a known format&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看下ImageLoader的创建方法：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">ImageLoader* ImageLoaderMachO::instantiate<span class="constructor">MainExecutable(<span class="params">const</span> <span class="params">macho_header</span><span class="operator">*</span> <span class="params">mh</span>, <span class="params">uintptr_t</span> <span class="params">slide</span>, <span class="params">const</span> <span class="params">char</span><span class="operator">*</span> <span class="params">path</span>, <span class="params">const</span> LinkContext&amp; <span class="params">context</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">bool</span> compressed;</span><br><span class="line">    unsigned <span class="built_in">int</span> segCount;</span><br><span class="line">    unsigned <span class="built_in">int</span> libCount;</span><br><span class="line">    const linkedit_data_command* codeSigCmd;</span><br><span class="line">    const encryption_info_command* encryptCmd;</span><br><span class="line">    <span class="comment">// sniffLoadCommands主要获取加载命令中compressed的值（压缩还是传统）以及segment的数量、libCount(需要加载的动态库的数量)</span></span><br><span class="line">    sniff<span class="constructor">LoadCommands(<span class="params">mh</span>, <span class="params">path</span>, <span class="params">false</span>, &amp;<span class="params">compressed</span>, &amp;<span class="params">segCount</span>, &amp;<span class="params">libCount</span>, <span class="params">context</span>, &amp;<span class="params">codeSigCmd</span>, &amp;<span class="params">encryptCmd</span>)</span>;</span><br><span class="line">    <span class="comment">// instantiate concrete class based on content of load commands</span></span><br><span class="line">    <span class="keyword">if</span> ( compressed ) </span><br><span class="line">        return ImageLoaderMachOCompressed::instantiate<span class="constructor">MainExecutable(<span class="params">mh</span>, <span class="params">slide</span>, <span class="params">path</span>, <span class="params">segCount</span>, <span class="params">libCount</span>, <span class="params">context</span>)</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">#<span class="keyword">if</span> SUPPORT_CLASSIC_MACHO</span><br><span class="line">        return ImageLoaderMachOClassic::instantiate<span class="constructor">MainExecutable(<span class="params">mh</span>, <span class="params">slide</span>, <span class="params">path</span>, <span class="params">segCount</span>, <span class="params">libCount</span>, <span class="params">context</span>)</span>;</span><br><span class="line">#<span class="keyword">else</span></span><br><span class="line">        throw <span class="string">&quot;missing LC_DYLD_INFO load command&quot;</span>;</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>instantiateMainExecutable会首先调用sniffLoadCommands从加载信息中获取到当前的主程序是Compressed还是Classic类型的，以及segment的数量，需要加载的动态库的数量。然后根据主程序的类型来创建ImageLoaderMachOCompressed或者ImageLoaderMachOClassic类型的ImageLoader.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ImageLoaderMachO::sniffLoadCommands</span><span class="params">(<span class="type">const</span> macho_header* mh, <span class="type">const</span> <span class="type">char</span>* path, <span class="type">bool</span> inCache, <span class="type">bool</span>* compressed,</span></span></span><br><span class="line"><span class="params"><span class="function">                                            <span class="type">unsigned</span> <span class="type">int</span>* segCount, <span class="type">unsigned</span> <span class="type">int</span>* libCount, <span class="type">const</span> LinkContext&amp; context,</span></span></span><br><span class="line"><span class="params"><span class="function">                                            <span class="type">const</span> linkedit_data_command** codeSigCmd,</span></span></span><br><span class="line"><span class="params"><span class="function">                                            <span class="type">const</span> encryption_info_command** encryptCmd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint32_t</span> i = <span class="number">0</span>; i &lt; cmd_count; ++i) &#123;</span><br><span class="line">        <span class="type">uint32_t</span> cmdLength = cmd-&gt;cmdsize;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">macho_segment_command</span>* segCmd;</span><br><span class="line">        <span class="comment">//.....</span></span><br><span class="line">        <span class="keyword">switch</span> (cmd-&gt;cmd) &#123;</span><br><span class="line">            <span class="keyword">case</span> LC_DYLD_INFO:</span><br><span class="line">            <span class="keyword">case</span> LC_DYLD_INFO_ONLY:</span><br><span class="line">                *compressed = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> LC_SEGMENT_COMMAND:</span><br><span class="line">                segCmd = (<span class="keyword">struct</span> macho_segment_command*)cmd;</span><br><span class="line">                <span class="comment">//.........</span></span><br><span class="line">                <span class="comment">// ignore zero-sized segments</span></span><br><span class="line">                <span class="keyword">if</span> ( segCmd-&gt;vmsize != <span class="number">0</span> )</span><br><span class="line">                    *segCount += <span class="number">1</span>;</span><br><span class="line">                <span class="comment">//......</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//.....</span></span><br><span class="line">            <span class="keyword">case</span> LC_LOAD_DYLIB:</span><br><span class="line">            <span class="keyword">case</span> LC_LOAD_WEAK_DYLIB:</span><br><span class="line">            <span class="keyword">case</span> LC_REEXPORT_DYLIB:</span><br><span class="line">            <span class="keyword">case</span> LC_LOAD_UPWARD_DYLIB:</span><br><span class="line">                *libCount += <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> LC_CODE_SIGNATURE:</span><br><span class="line">                *codeSigCmd = (<span class="keyword">struct</span> linkedit_data_command*)cmd; <span class="comment">// only support one LC_CODE_SIGNATURE per image</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> LC_ENCRYPTION_INFO:</span><br><span class="line">            <span class="keyword">case</span> LC_ENCRYPTION_INFO_64:</span><br><span class="line">                *encryptCmd = (<span class="keyword">struct</span> encryption_info_command*)cmd; <span class="comment">// only support one LC_ENCRYPTION_INFO[_64] per image</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cmd = nextCmd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//.......</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// fSegmentsArrayCount is only 8-bits</span></span><br><span class="line">    <span class="keyword">if</span> ( *segCount &gt; <span class="number">255</span> )</span><br><span class="line">        dyld::<span class="built_in">throwf</span>(<span class="string">&quot;malformed mach-o image: more than 255 segments in %s&quot;</span>, path);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fSegmentsArrayCount is only 8-bits</span></span><br><span class="line">    <span class="keyword">if</span> ( *libCount &gt; <span class="number">4095</span> )</span><br><span class="line">        dyld::<span class="built_in">throwf</span>(<span class="string">&quot;malformed mach-o image: more than 4095 dependent libraries in %s&quot;</span>, path);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">needsAddedLibSystemDepency</span>(*libCount, mh) )</span><br><span class="line">        *libCount = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>sniffLoadCommands 会根据Mach 文件中是否有<strong><strong>LC_DYLD_INFO</strong></strong>，<strong><strong>LC_DYLD_INFO_ONLY</strong></strong>来判断当前Mach O文件是否是compressed的，并且获取segment 数量以及所依赖的动态库数量libCount，还有代码签名命令codeSigCmd以及加密命令encryptCmd。我们这里以compressed类型作为例子。那么上面返回的就是<strong><strong>ImageLoaderMachOCompressed</strong></strong>,</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function">ImageLoaderMachOCompressed* <span class="title">ImageLoaderMachOCompressed::instantiateMainExecutable</span><span class="params">(<span class="type">const</span> macho_header* mh, <span class="type">uintptr_t</span> slide, <span class="type">const</span> <span class="type">char</span>* path, </span></span></span><br><span class="line"><span class="params"><span class="function">                                                        <span class="type">unsigned</span> <span class="type">int</span> segCount, <span class="type">unsigned</span> <span class="type">int</span> libCount, <span class="type">const</span> LinkContext&amp; context)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ImageLoaderMachOCompressed* image = ImageLoaderMachOCompressed::<span class="built_in">instantiateStart</span>(mh, path, segCount, libCount);</span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line">    image-&gt;<span class="built_in">disableCoverageCheck</span>();</span><br><span class="line">    image-&gt;<span class="built_in">instantiateFinish</span>(context);</span><br><span class="line">    image-&gt;<span class="built_in">setMapped</span>(context);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">    <span class="keyword">return</span> image;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><strong>加载共享库到内存</strong></strong></p>
<p>dyld加载的时候会启动共享缓存技术对这个过程进行优化，共享缓存会在进程启动的时候被dyld映射到内存中，不同App间访问的共享库最终都会映射到同一块物理内存，之后在加载任何Mach O镜像的时候，都会先去检查该Mach O镜像以及所需的动态库文件是否已经存在在共享缓存中，如果存在则直接将它在共享内存中的内存地址映射到进程的内存地址空间，从而加快动态库的加载的速度，对启动性能会有较大的提高。在Mac OS系统中，动态库共享缓存以文件的形式存放在&#x2F;var&#x2F;db&#x2F;dyld目录下，我们需要根据当前设备的CPU架构类型去匹配要打开的缓存文件，接着读取缓存文件的前8192字节，解析并加载缓存头dyld_cache_header信息到内存，我们可以通过&#x2F;usr&#x2F;bin&#x2F;update_dyld_shared_cache来更新共享库。</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">static void mapSharedCache()</span><br><span class="line">&#123;</span><br><span class="line">    uint64_t cacheBaseAddress = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 检查当前共享缓存是否已经映射到共享区域</span></span><br><span class="line">    <span class="keyword">if</span> ( _shared_region_check_np(&amp;cacheBaseAddress) == <span class="number">0</span> ) &#123;</span><br><span class="line">        <span class="comment">/// 共享库已经被映射到内存中</span></span><br><span class="line">        sSharedCache = (dyld_cache_header*)cacheBaseAddress;</span><br><span class="line">        <span class="comment">// 检查共享库的兼容性，如果已经映射到内存中的共享库但是不兼容，这时候我们将忽略它</span></span><br><span class="line">        <span class="function"><span class="title">if</span> ( strcmp(sSharedCache-&gt;</span>magic, magic) != <span class="number">0</span> ) &#123;</span><br><span class="line">            sSharedCache = NULL;</span><br><span class="line">            <span class="comment">//.....</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//.........</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果共享库没有加载到内存中，进行加载</span></span><br><span class="line">        int fd = openSharedCacheFile();</span><br><span class="line">        <span class="keyword">if</span> ( fd != -<span class="number">1</span> ) &#123;</span><br><span class="line">            uint8_t firstPages[<span class="number">8192</span>];</span><br><span class="line">            <span class="comment">// 获取共享库文件的句柄，然后进行读取解析</span></span><br><span class="line">            <span class="keyword">if</span> ( ::read(fd, firstPages, <span class="number">8192</span>) == <span class="number">8192</span> ) &#123;</span><br><span class="line">                dyld_cache_header* header = (dyld_cache_header*)firstPages;</span><br><span class="line">                <span class="comment">//共享缓存合法性检查</span></span><br><span class="line">                <span class="function"><span class="title">if</span> ( strcmp(header-&gt;</span>magic, magic) == <span class="number">0</span> ) &#123;</span><br><span class="line">                    <span class="comment">//.......</span></span><br><span class="line">                    <span class="comment">// 校验缓存文件的完整性</span></span><br><span class="line">                    <span class="comment">//.......</span></span><br><span class="line">                    <span class="keyword">if</span> ( goodCache ) &#123;</span><br><span class="line">                        <span class="comment">//.......</span></span><br><span class="line">                        <span class="comment">// 将共享缓存映射到共享区域</span></span><br><span class="line">                        <span class="keyword">if</span> (_shared_region_map_and_slide_np(fd, mappingCount, mappings, codeSignatureMappingIndex, cacheSlide, slideInfo, slideInfoSize) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="comment">// successfully mapped cache into shared region</span></span><br><span class="line">                            sSharedCache = (dyld_cache_header*)mappings[<span class="number">0</span>].sfm_address;</span><br><span class="line">                            sSharedCacheSlide = cacheSlide;</span><br><span class="line">                            <span class="function"><span class="title">dyld</span>::gProcessInfo-&gt;</span>sharedCacheSlide = cacheSlide;</span><br><span class="line">                            <span class="function"><span class="title">if</span> ( header-&gt;</span>mappingOffset &gt;= <span class="number">0</span>x68 ) &#123;</span><br><span class="line">                                <span class="function"><span class="title">memcpy</span>(dyld::gProcessInfo-&gt;</span><span class="function"><span class="title">sharedCacheUUID</span>, header-&gt;</span>uuid, <span class="number">16</span>);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="comment">//........</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> ( gLinkContext.verboseMapping ) </span><br><span class="line">                        dyld::<span class="built_in">log</span>(<span class="string">&quot;dyld: shared cached file is invalid\n&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> ( gLinkContext.verboseMapping ) </span><br><span class="line">                    dyld::<span class="built_in">log</span>(<span class="string">&quot;dyld: shared cached file cannot be read\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            close(fd);  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> ( gLinkContext.verboseMapping ) </span><br><span class="line">                dyld::<span class="built_in">log</span>(<span class="string">&quot;dyld: shared cached file cannot be opened\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="comment">// tell gdb where the shared cache is</span></span><br><span class="line">    <span class="comment">//........</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><strong>加载插入的动态库</strong></strong></p>
<p>插入的动态库会存储在DYLD_INSERT_LIBRARIES，在这时候会遍历DYLD_INSERT_LIBRARIES环境变量中指定的动态库列表，并调用loadInsertedDylib()将其加载。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>( sEnv.DYLD_INSERT_LIBRARIES != <span class="literal">NULL</span> ) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="type">char</span>* <span class="type">const</span>* lib = sEnv.DYLD_INSERT_LIBRARIES; *lib != <span class="literal">NULL</span>; ++lib) </span><br><span class="line">        <span class="comment">// 加载环境变量DYLD_INSERT_LIBRARIES中的动态库，使用loadInsertedDylib进行加载</span></span><br><span class="line">        <span class="built_in">loadInsertedDylib</span>(*lib);<span class="comment">//把环境变量DYLD_INSERT_LIBRARIES 中的动态库调用loadInsertedDylib进行加载</span></span><br><span class="line">&#125;</span><br><span class="line">sInsertedDylibCount = sAllImages.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br></pre></td></tr></table></figure>
<p>loadInsertedDylib会调用load方法完成加载工作。load方法会先调用loadPhase0尝试从文件加载，然后一直从loadPhase0一直到loadPhase6，查找动态库的路径，每个阶段都会为下一阶段生成搜索的路径。整个查找顺序会顺着: ****DYLD_ROOT_PATH -&gt; LD_LIBRARY_PATH -&gt; DYLD_FRAMEWORK_PATH -&gt; raw path - &gt;DYLD_FALLBACK_LIBRARY_PATH **** 如果找到则调用ImageLoaderMachO::instantiateFromFile来实例化一个ImageLoader，之后调用checkandAddImage验证映像并将其加入到全局映像列表中。如果loadPhase0返回空，表示在路径中没有找到动态库，就尝试从共享缓存中查找，找到就调用ImageLoaderMachO::instantiateFromCache()从缓存中加载，否则就抛出没找到映像的异常。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">ImageLoader* load(const <span class="built_in">char</span>* path, const LoadContext&amp; context)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line">    <span class="comment">// 尝试所有路径排列并检查现有加载的镜像</span></span><br><span class="line">    <span class="comment">// try all path permutations and check against existing loaded images</span></span><br><span class="line">    ImageLoader* image = load<span class="constructor">Phase0(<span class="params">path</span>, <span class="params">orgPath</span>, <span class="params">context</span>, NULL)</span>;</span><br><span class="line">    <span class="keyword">if</span> ( image != NULL ) &#123;</span><br><span class="line">        return image;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    image = load<span class="constructor">Phase0(<span class="params">path</span>, <span class="params">orgPath</span>, <span class="params">context</span>, &amp;<span class="params">exceptions</span>)</span>;</span><br><span class="line">    <span class="keyword">if</span> ( (image<span class="operator"> == </span>NULL)<span class="operator"> &amp;&amp; </span>cacheable<span class="constructor">Path(<span class="params">path</span>)</span><span class="operator"> &amp;&amp; </span>!context.dontLoad ) &#123;</span><br><span class="line">        <span class="comment">//......    </span></span><br><span class="line">        <span class="keyword">if</span> ( (myerr<span class="operator"> == </span>ENOENT)<span class="operator"> || </span>(myerr<span class="operator"> == </span><span class="number">0</span>) ) &#123;</span><br><span class="line">            <span class="comment">// see if this image is in shared cache</span></span><br><span class="line">            <span class="comment">//......</span></span><br><span class="line">            <span class="keyword">if</span> ( find<span class="constructor">InSharedCacheImage(<span class="params">resolvedPath</span>, <span class="params">false</span>, NULL, &amp;<span class="params">mhInCache</span>, &amp;<span class="params">pathInCache</span>, &amp;<span class="params">slideInCache</span>)</span> ) &#123;</span><br><span class="line">                <span class="comment">//......</span></span><br><span class="line">                image = ImageLoaderMachO::instantiate<span class="constructor">FromCache(<span class="params">mhInCache</span>, <span class="params">pathInCache</span>, <span class="params">slideInCache</span>, <span class="params">stat_buf</span>, <span class="params">gLinkContext</span>)</span>;</span><br><span class="line">                    image = checkand<span class="constructor">AddImage(<span class="params">image</span>, <span class="params">context</span>)</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">static ImageLoader* load<span class="constructor">Phase6(<span class="params">int</span> <span class="params">fd</span>, <span class="params">const</span> <span class="params">struct</span> <span class="params">stat</span>&amp; <span class="params">stat_buf</span>, <span class="params">const</span> <span class="params">char</span><span class="operator">*</span> <span class="params">path</span>, <span class="params">const</span> LoadContext&amp; <span class="params">context</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//.......</span></span><br><span class="line">    <span class="comment">// try mach-o loader</span></span><br><span class="line">    <span class="keyword">if</span> ( shortPage ) </span><br><span class="line">        throw <span class="string">&quot;file too short&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> ( is<span class="constructor">CompatibleMachO(<span class="params">firstPage</span>, <span class="params">path</span>)</span> ) &#123;</span><br><span class="line">        <span class="comment">// 只有MH_BUNDLE，MH_DYLIB，以及一些MH_EXECUTE 才能被动态加载</span></span><br><span class="line">        switch ( ((mach_header*)firstPage)-&gt;filetype ) &#123;</span><br><span class="line">            case MH_EXECUTE:</span><br><span class="line">            case MH_DYLIB:</span><br><span class="line">            case MH_BUNDLE:</span><br><span class="line">                break;</span><br><span class="line">            default:</span><br><span class="line">                throw <span class="string">&quot;mach-o, but wrong filetype&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//实例化镜像</span></span><br><span class="line">        ImageLoader* image = ImageLoaderMachO::instantiate<span class="constructor">FromFile(<span class="params">path</span>, <span class="params">fd</span>, <span class="params">firstPage</span>, <span class="params">fileOffset</span>, <span class="params">fileLength</span>, <span class="params">stat_buf</span>, <span class="params">gLinkContext</span>)</span>;</span><br><span class="line">        <span class="comment">// validate</span></span><br><span class="line">        return checkand<span class="constructor">AddImage(<span class="params">image</span>, <span class="params">context</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><strong>链接主程序</strong></strong></p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="built_in">link</span>(sMainExecutable, sEnv.DYLD_BIND_AT_LAUNCH, <span class="literal">true</span>, ImageLoader::<span class="built_in">RPathChain</span>(<span class="literal">NULL</span>, <span class="literal">NULL</span>));</span><br><span class="line"><span class="comment">//......</span></span><br><span class="line"><span class="comment">// 4.link any inserted libraries</span></span><br><span class="line"><span class="comment">// 链接任何插入的库</span></span><br><span class="line"><span class="comment">// do this after linking main executable so that any dylibs pulled in by inserted </span></span><br><span class="line"><span class="comment">// dylibs (e.g. libSystem) will not be in front of dylibs the program uses</span></span><br><span class="line"><span class="keyword">if</span> ( sInsertedDylibCount &gt; <span class="number">0</span> ) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">unsigned</span> <span class="type">int</span> i=<span class="number">0</span>; i &lt; sInsertedDylibCount; ++i) &#123;</span><br><span class="line">        ImageLoader* image = sAllImages[i+<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">link</span>(image, sEnv.DYLD_BIND_AT_LAUNCH, <span class="literal">true</span>, ImageLoader::<span class="built_in">RPathChain</span>(<span class="literal">NULL</span>, <span class="literal">NULL</span>));</span><br><span class="line">        image-&gt;<span class="built_in">setNeverUnloadRecursive</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//......</span></span><br><span class="line">gLinkContext.linkingMainExecutable = <span class="literal">false</span>;</span><br><span class="line">sMainExecutable-&gt;<span class="built_in">weakBind</span>(gLinkContext);</span><br></pre></td></tr></table></figure>

<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void ImageLoader::link(const LinkContext&amp; context, <span class="built_in">bool</span> forceLazysBound, <span class="built_in">bool</span> preflightOnly, <span class="built_in">bool</span> neverUnload, const RPathChain&amp; loaderRPaths)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="comment">//递归加载所有依赖库进内存。</span></span><br><span class="line">    this-&gt;recursive<span class="constructor">LoadLibraries(<span class="params">context</span>, <span class="params">preflightOnly</span>, <span class="params">loaderRPaths</span>)</span>;</span><br><span class="line">    context.notify<span class="constructor">Batch(<span class="params">dyld_image_state_dependents_mapped</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line">    uint64_t t1 = mach<span class="constructor">_absolute_time()</span>;</span><br><span class="line">    context.clear<span class="constructor">AllDepths()</span>;</span><br><span class="line">    this-&gt;recursive<span class="constructor">UpdateDepth(<span class="params">context</span>.<span class="params">imageCount</span>()</span>);</span><br><span class="line"></span><br><span class="line">    uint64_t t2 = mach<span class="constructor">_absolute_time()</span>;</span><br><span class="line">    <span class="comment">//递归对自己以及依赖库进行复基位操作。在以前，程序每次加载其在内存中的堆栈基地址都是一样的，这意味着你的方法，变量等地址每次都一样的，这使得程序很不安全，后面就出现ASLR（Address space layout randomization,地址空间配置随机加载），</span></span><br><span class="line">    <span class="comment">//程序每次启动后地址都会随机变化，这样程序里所有的代码地址都是错的，需要重新对代码地址进行计算修复才能正常访问</span></span><br><span class="line">    <span class="comment">// 递归修正自己和依赖库的基地址，因为ASLR的原因，需要根据随机slide修正基地址</span></span><br><span class="line">    this-&gt;recursive<span class="constructor">Rebase(<span class="params">context</span>)</span>;</span><br><span class="line">    context.notify<span class="constructor">Batch(<span class="params">dyld_image_state_rebased</span>)</span>;</span><br><span class="line"></span><br><span class="line">    uint64_t t3 = mach<span class="constructor">_absolute_time()</span>;</span><br><span class="line">    <span class="comment">//对库中所有nolazy的符号进行bind,一般的情况下多数符号都是lazybind的，他们在第一次使用的时候才进行bind。</span></span><br><span class="line">    <span class="comment">// recursiveBind对于noLazy的符号进行绑定，lazy的符号会在运行时动态绑定</span></span><br><span class="line">    this-&gt;recursive<span class="constructor">Bind(<span class="params">context</span>, <span class="params">forceLazysBound</span>, <span class="params">neverUnload</span>)</span>;</span><br><span class="line"></span><br><span class="line">    uint64_t t4 = mach<span class="constructor">_absolute_time()</span>;</span><br><span class="line">    <span class="keyword">if</span> ( !context.linkingMainExecutable )</span><br><span class="line">        this-&gt;weak<span class="constructor">Bind(<span class="params">context</span>)</span>;</span><br><span class="line">    uint64_t t5 = mach<span class="constructor">_absolute_time()</span>;	</span><br><span class="line"></span><br><span class="line">    context.notify<span class="constructor">Batch(<span class="params">dyld_image_state_bound</span>)</span>;</span><br><span class="line">    <span class="comment">//........</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong><strong>recursiveLoadLibraries</strong></strong>会先获取当前镜像所需要的库列表，然后会先从缓存库中加载所需要的库，如果没在缓存库中找到则调用loadLibrary进行加载，loadLibrary 实际上调用的是之前介绍的load方法。将依赖的库加载进来并装载。<strong><strong>recursiveUpdateDepth</strong></strong> 会对镜像及其依赖库进行排序。</p>
<p>接下来我们看下<strong><strong>recursiveRebase</strong></strong></p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void ImageLoader::recursive<span class="constructor">Rebase(<span class="params">const</span> LinkContext&amp; <span class="params">context</span>)</span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">if</span> ( fState &lt; dyld_image_state_rebased ) &#123;</span><br><span class="line">        <span class="comment">// break cycles</span></span><br><span class="line">        fState = dyld_image_state_rebased;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// rebase lower level libraries first</span></span><br><span class="line">            <span class="keyword">for</span>(unsigned <span class="built_in">int</span> i=<span class="number">0</span>; i &lt; library<span class="constructor">Count()</span>; ++i) &#123;</span><br><span class="line">                ImageLoader* dependentImage = lib<span class="constructor">Image(<span class="params">i</span>)</span>;</span><br><span class="line">                <span class="keyword">if</span> ( dependentImage != NULL )</span><br><span class="line">                    dependentImage-&gt;recursive<span class="constructor">Rebase(<span class="params">context</span>)</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// rebase this image</span></span><br><span class="line">            <span class="keyword">do</span><span class="constructor">Rebase(<span class="params">context</span>)</span>;</span><br><span class="line">            <span class="comment">// notify</span></span><br><span class="line">            context.notify<span class="constructor">Single(<span class="params">dyld_image_state_rebased</span>, <span class="params">this</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//......</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在之前的步骤中我们都在完成库的加载，但是这些dylibs之间是没有关联的，需要rebase，binding对地址修正，不知道大家看过高达之类的动画片没有，在变身过程中装备会从四面八方飞过来，然后会一个个安装到身上，嗯，link就是这个过程，动态库中的地址是相对的，因为它需要保证它内部逻辑的独立性，同时为了降低缓冲区溢出攻击的成功率主流的操作系统都会采用ASLR（Address space layout randomization）技术，它通过对堆、栈、共享库映射等线性区布局的随机化来增加攻击者预测目的地址的难度，防止攻击者直接定位攻击代码位置，达到阻止溢出攻击的目的。</p>
<p>****Rebase：在镜像内部调整指针的指向 ****</p>
<p>就像上面提到的未加载到内存的动态库镜像里面的地址都是相对的，是距第一个Segement的偏移量，而当加载到内存中的时候，起始地址就是申请的内存的起始地址，就不再是0，那么如何再能够找到这些引用的正确内存位置呢？这个就是rebase需要解决的问题，rebase这一步就是将相对地址调整为绝对地址，以及修正ASLR带来的地址不确定性：在没有使用ASLR技术之前，动态库加载的时候会把 dylib 加载到指定地址，所有指针和数据对于代码来说都是确定的，使用了ASLR后每次加载都会将dylib 加载到新的随机地址，这个随机的地址跟代码和数据指向的旧地址会有偏差，dyld 在rebase这个阶段需要修正这个偏差，做法就是将 dylib 内部的指针地址都加上这个偏移量，然后重复不断地对 __DATA 段中需要 rebase 的指针加上这个偏移量。也就是说经过rebase处理后镜像内部在内存中的映射已经确定下来了，不再是相对于动态库内部的相对地址，并创建访问地址存储在__DATA段。总的来说经过rebase处理后我们会在内存中获得一个有明确入口的，并且内部地址明确的动态库，但是对其他外部依赖库调用的地址在这步还没修正，需要在binding阶段进行处理。我们先继续往下看：</p>
<p><strong><strong>recursiveRebase</strong></strong> 里面调用的是<strong><strong>doRebase</strong></strong>，而<strong><strong>doRebase</strong></strong>会调用ImageLoaderMachOCompressed::rebase</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title class_">ImageLoaderMachO</span>::<span class="title function_">doRebase</span>(<span class="params"><span class="keyword">const</span> LinkContext&amp; context</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//.......</span></span><br><span class="line">    <span class="comment">// do actual rebasing</span></span><br><span class="line">    <span class="variable language_">this</span>-&gt;<span class="title function_">rebase</span>(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ImageLoaderMachOCompressed::rebase</span><span class="params">(<span class="type">const</span> LinkContext&amp; context)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//.....</span></span><br><span class="line">        <span class="type">bool</span> done = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span> ( !done &amp;&amp; (p &lt; end) ) &#123;</span><br><span class="line">            <span class="type">uint8_t</span> immediate = *p &amp; REBASE_IMMEDIATE_MASK;</span><br><span class="line">            <span class="type">uint8_t</span> opcode = *p &amp; REBASE_OPCODE_MASK;</span><br><span class="line">            ++p;</span><br><span class="line">            <span class="keyword">switch</span> (opcode) &#123;</span><br><span class="line">                <span class="keyword">case</span> REBASE_OPCODE_DONE:</span><br><span class="line">                    done = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> REBASE_OPCODE_SET_TYPE_IMM:</span><br><span class="line">                    type = immediate;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> REBASE_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB:</span><br><span class="line">                    segmentIndex = immediate;</span><br><span class="line">                    <span class="comment">//.....</span></span><br><span class="line">                    address = <span class="built_in">segActualLoadAddress</span>(segmentIndex) + <span class="built_in">read_uleb128</span>(p, end);</span><br><span class="line">                    segmentEndAddress = <span class="built_in">segActualEndAddress</span>(segmentIndex);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> REBASE_OPCODE_ADD_ADDR_ULEB:</span><br><span class="line">                    address += <span class="built_in">read_uleb128</span>(p, end);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> REBASE_OPCODE_ADD_ADDR_IMM_SCALED:</span><br><span class="line">                    address += immediate*<span class="built_in">sizeof</span>(<span class="type">uintptr_t</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> REBASE_OPCODE_DO_REBASE_IMM_TIMES:</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i &lt; immediate; ++i) &#123;</span><br><span class="line">                        <span class="keyword">if</span> ( address &gt;= segmentEndAddress ) </span><br><span class="line">                            <span class="built_in">throwBadRebaseAddress</span>(address, segmentEndAddress, segmentIndex, start, end, p);</span><br><span class="line">                        <span class="built_in">rebaseAt</span>(context, address, slide, type);</span><br><span class="line">                        address += <span class="built_in">sizeof</span>(<span class="type">uintptr_t</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    fgTotalRebaseFixups += immediate;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> REBASE_OPCODE_DO_REBASE_ULEB_TIMES:</span><br><span class="line">                    count = <span class="built_in">read_uleb128</span>(p, end);</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">uint32_t</span> i=<span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">                        <span class="built_in">rebaseAt</span>(context, address, slide, type);</span><br><span class="line">                        address += <span class="built_in">sizeof</span>(<span class="type">uintptr_t</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    fgTotalRebaseFixups += count;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> REBASE_OPCODE_DO_REBASE_ADD_ADDR_ULEB:</span><br><span class="line">                    <span class="built_in">rebaseAt</span>(context, address, slide, type);</span><br><span class="line">                    address += <span class="built_in">read_uleb128</span>(p, end) + <span class="built_in">sizeof</span>(<span class="type">uintptr_t</span>);</span><br><span class="line">                    ++fgTotalRebaseFixups;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> REBASE_OPCODE_DO_REBASE_ULEB_TIMES_SKIPPING_ULEB:</span><br><span class="line">                    count = <span class="built_in">read_uleb128</span>(p, end);</span><br><span class="line">                    skip = <span class="built_in">read_uleb128</span>(p, end);</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">uint32_t</span> i=<span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">                        <span class="built_in">rebaseAt</span>(context, address, slide, type);</span><br><span class="line">                        address += skip + <span class="built_in">sizeof</span>(<span class="type">uintptr_t</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    fgTotalRebaseFixups += count;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    dyld::<span class="built_in">throwf</span>(<span class="string">&quot;bad rebase opcode %d&quot;</span>, *p);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">const</span> <span class="type">char</span>* msg) &#123;</span><br><span class="line">        <span class="comment">//......</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">CRSetCrashLogMessage2</span>(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在ImageLoaderMachOCompressed::rebase方法中就是对这些地址进行修正，从而获得明确的绝对地址。</p>
<p>接下来我们看下Bind 过程的代码<strong><strong>recursiveBind</strong></strong>：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void ImageLoader::recursive<span class="constructor">Bind(<span class="params">const</span> LinkContext&amp; <span class="params">context</span>, <span class="params">bool</span> <span class="params">forceLazysBound</span>, <span class="params">bool</span> <span class="params">neverUnload</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Normally just non-lazy pointers are bound immediately.</span></span><br><span class="line">    <span class="comment">// The exceptions are:</span></span><br><span class="line">    <span class="comment">//   1) DYLD_BIND_AT_LAUNCH will cause lazy pointers to be bound immediately</span></span><br><span class="line">    <span class="comment">//   2) some API&#x27;s (e.g. RTLD_NOW) can cause lazy pointers to be bound immediately</span></span><br><span class="line">    <span class="keyword">if</span> ( fState &lt; dyld_image_state_bound ) &#123;</span><br><span class="line">        <span class="comment">// break cycles</span></span><br><span class="line">        fState = dyld_image_state_bound;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// bind lower level libraries first</span></span><br><span class="line">            <span class="keyword">for</span>(unsigned <span class="built_in">int</span> i=<span class="number">0</span>; i &lt; library<span class="constructor">Count()</span>; ++i) &#123;</span><br><span class="line">                ImageLoader* dependentImage = lib<span class="constructor">Image(<span class="params">i</span>)</span>;</span><br><span class="line">                <span class="keyword">if</span> ( dependentImage != NULL )</span><br><span class="line">                    dependentImage-&gt;recursive<span class="constructor">Bind(<span class="params">context</span>, <span class="params">forceLazysBound</span>, <span class="params">neverUnload</span>)</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// bind this image</span></span><br><span class="line">            this-&gt;<span class="keyword">do</span><span class="constructor">Bind(<span class="params">context</span>, <span class="params">forceLazysBound</span>)</span>;	</span><br><span class="line">            <span class="comment">// ......</span></span><br><span class="line">            context.notify<span class="constructor">Single(<span class="params">dyld_image_state_bound</span>, <span class="params">this</span>)</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        catch (const <span class="built_in">char</span>* msg) &#123;</span><br><span class="line">            <span class="comment">//......</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void ImageLoaderMachOCompressed::<span class="keyword">do</span><span class="constructor">Bind(<span class="params">const</span> LinkContext&amp; <span class="params">context</span>, <span class="params">bool</span> <span class="params">forceLazysBound</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="constructor">CRSetCrashLogMessage2(<span class="params">this</span>-&gt;<span class="params">getPath</span>()</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if prebound and loaded at prebound address, and all libraries are same as when this was prebound, then no need to bind</span></span><br><span class="line">    <span class="comment">// note: flat-namespace binaries need to have imports rebound (even if correctly prebound)</span></span><br><span class="line">    <span class="keyword">if</span> ( this-&gt;usable<span class="constructor">Prebinding(<span class="params">context</span>)</span> ) &#123;</span><br><span class="line">        <span class="comment">// don&#x27;t need to bind</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">    #<span class="keyword">if</span> TEXT_RELOC_SUPPORT</span><br><span class="line">        <span class="comment">// if there are __TEXT fixups, temporarily make __TEXT writable</span></span><br><span class="line">        <span class="keyword">if</span> ( fTextSegmentBinds )</span><br><span class="line">            this-&gt;make<span class="constructor">TextSegmentWritable(<span class="params">context</span>, <span class="params">true</span>)</span>;</span><br><span class="line">    #endif</span><br><span class="line"></span><br><span class="line">        <span class="comment">// run through all binding opcodes</span></span><br><span class="line">        each<span class="constructor">Bind(<span class="params">context</span>, &amp;ImageLoaderMachOCompressed::<span class="params">bindAt</span>)</span>;</span><br><span class="line">    #<span class="keyword">if</span> TEXT_RELOC_SUPPORT</span><br><span class="line">        <span class="comment">// if there were __TEXT fixups, restore write protection</span></span><br><span class="line">        <span class="keyword">if</span> ( fTextSegmentBinds )    </span><br><span class="line">        this-&gt;make<span class="constructor">TextSegmentWritable(<span class="params">context</span>, <span class="params">false</span>)</span>;</span><br><span class="line">    #endif  </span><br><span class="line">        <span class="comment">// if this image is in the shared cache, but depends on something no longer in the shared cache,</span></span><br><span class="line">        <span class="comment">// there is no way to reset the lazy pointers, so force bind them now</span></span><br><span class="line">        <span class="keyword">if</span> ( forceLazysBound<span class="operator"> || </span>fInSharedCache ) </span><br><span class="line">            this-&gt;<span class="keyword">do</span><span class="constructor">BindJustLazies(<span class="params">context</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// this image is in cache, but something below it is not.  If</span></span><br><span class="line">        <span class="comment">// this image has lazy pointer to a resolver function, then</span></span><br><span class="line">        <span class="comment">// the stub may have been altered to point to a shared lazy pointer.</span></span><br><span class="line">        <span class="keyword">if</span> ( fInSharedCache ) </span><br><span class="line">            this-&gt;update<span class="constructor">OptimizedLazyPointers(<span class="params">context</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// tell kernel we are done with chunks of LINKEDIT</span></span><br><span class="line">        <span class="keyword">if</span> ( !context.preFetchDisabled ) </span><br><span class="line">            this-&gt;mark<span class="constructor">FreeLINKEDIT(<span class="params">context</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// set up dyld entry points in image</span></span><br><span class="line">    <span class="comment">// do last so flat main executables will have __dyld or __program_vars set up</span></span><br><span class="line">    this-&gt;setup<span class="constructor">LazyPointerHandler(<span class="params">context</span>)</span>;</span><br><span class="line">    <span class="constructor">CRSetCrashLogMessage2(NULL)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>****Bind：将指针指向镜像外部的内容 ****</p>
<p>我们前面提到了经过rebase处理后我们将会在内存中获取该库的一个明确的入口地址，并且库内部的相对地址会被确定为一个明确的地址，但是对其他库引用的地方还是没明确，这部分就需要Binding阶段进行处理了，Binding阶段主要的任务就是根据被导出符号重定位表项，去符号表中找出符号的基本信息，再去其他库符号表中resolve符号，将resolve结果bind到需要重定位地址上。说句人话就是，在其他库的符号表中去查找明确地址，然后在当前动态库中使用这个地址。一般我们使用另一个动态库的某个方法的时候会有一个间接引用，这个地址中存放的就是我们需要跳转的地址，在binding阶段会将其他库中查找的地址这需要很多计算，去符号表里查找。找到后会将内容存储到 __DATA 段中的那个指针中，下次调用的时候就会从这个地方去拿这个地址去跳转到要调用其他动态库的函数地址。</p>
<p>这里还有两种特殊的绑定：</p>
<p><strong><strong>Lazy Bind:</strong></strong></p>
<p>我们启动优化中常常会考虑将某些动态依赖库改为静态依赖，虽然静态依赖会增大包的体积，但是会改善启动缓慢的问题，上面看到Bind的过程，发现Bind的过程需要查到对应的符号再进行bind. 如果在启动的时候，所有的符号都立即Bind成功，那么势必拖慢启动速度，那么我们可以将某些不必要的符号绑定延后吗？嗯，肯定可以的，Lazy Bind就是第一次调用到才会进行真正的Bind.这里其实用到dyld_stub_binder，在需要绑定的时候会将调用信息传递给它，由它来找到最终要跳转的地址，从而完成绑定。</p>
<p><strong><strong>Weak Bind:</strong></strong></p>
<p>Weak Bind这一步是将相同的弱符号统一化，如果有强符号则统一成强符号，否则统一成按装载顺序的首个弱符号，在这个过程中会去寻找，找到一个相同的符号后，如果是强符号则不需要再查找，否则从装载顺序找到首个弱符号地址，将所有库中的相同符号都覆盖为该地址。</p>
<p><strong><strong>初始化主程序:</strong></strong></p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">void <span class="built_in">initializeMainExecutable</span>()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化任意插入的dylibs</span></span><br><span class="line">    <span class="comment">// run initialzers for any inserted dylibs</span></span><br><span class="line">    if ( rootCount &gt; <span class="number">1</span> ) &#123;</span><br><span class="line">        <span class="comment">//这里需要注意的是sImageRoots 中的第一个变量是主程序镜像, 因此这里初始化的时候需要跳过第一个数据, 对其他后面插入的dylib进行调用ImageLoader::runInitializers进行初始化</span></span><br><span class="line">        <span class="built_in">for</span>(size_t i=<span class="number">1</span>; i &lt; rootCount; ++i) &#123;</span><br><span class="line">            sImageRoots<span class="selector-attr">[i]</span>-&gt;<span class="built_in">runInitializers</span>(gLinkContext, initializerTimes[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后运行主程序的初始化器</span></span><br><span class="line">    <span class="comment">// run initializers for main executable and everything it brings up </span></span><br><span class="line">    sMainExecutable-&gt;<span class="built_in">runInitializers</span>(gLinkContext, initializerTimes[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//.........</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看到<strong><strong>initializeMainExecutable</strong></strong>方法中会先对插入的动态链接库进行初始化，然后再对主程序进行初始化，初始化都是调用<strong><strong>runInitializers</strong></strong></p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void ImageLoader::run<span class="constructor">Initializers(<span class="params">const</span> LinkContext&amp; <span class="params">context</span>, InitializerTimingList&amp; <span class="params">timingInfo</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="comment">//处理初始化器</span></span><br><span class="line">    process<span class="constructor">Initializers(<span class="params">context</span>, <span class="params">thisThread</span>, <span class="params">timingInfo</span>, <span class="params">up</span>)</span>;</span><br><span class="line">    context.notify<span class="constructor">Batch(<span class="params">dyld_image_state_initialized</span>)</span>;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>runInitializers方法中就做两件事情，一个就是调用processInitializers，以及在初始化结束发出通知，告诉监听者，当前已经初始化完毕。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ImageLoader::processInitializers</span><span class="params">(<span class="type">const</span> LinkContext&amp; context, <span class="type">mach_port_t</span> thisThread,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    InitializerTimingList&amp; timingInfo, ImageLoader::UninitedUpwards&amp; images)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//在镜像列表中的所有镜像进行递归初始化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uintptr_t</span> i=<span class="number">0</span>; i &lt; images.count; ++i) &#123;</span><br><span class="line">        images.images[i]-&gt;<span class="built_in">recursiveInitialization</span>(context, thisThread, timingInfo, ups);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ImageLoader::recursiveInitialization</span><span class="params">(<span class="type">const</span> LinkContext&amp; context, <span class="type">mach_port_t</span> this_thread,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        InitializerTimingList&amp; timingInfo, UninitedUpwards&amp; uninitUps)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">recursive_lock <span class="title">lock_info</span><span class="params">(this_thread)</span></span>;</span><br><span class="line">    <span class="built_in">recursiveSpinLock</span>(lock_info);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( fState &lt; dyld_image_state_dependents_initialized<span class="number">-1</span> ) &#123;</span><br><span class="line">        <span class="comment">//......</span></span><br><span class="line">        <span class="comment">// let objc know we are about to initialize this image</span></span><br><span class="line">        <span class="type">uint64_t</span> t1 = <span class="built_in">mach_absolute_time</span>();</span><br><span class="line">        fState = dyld_image_state_dependents_initialized;</span><br><span class="line">        oldState = fState;  </span><br><span class="line">        <span class="comment">// 通知 runtime, 当前状态发生变化 -- image的依赖已经完全加载. 如果在runtime中注册了状态监听，当状态发送变化时, 会触发回调函数.</span></span><br><span class="line">        context.<span class="built_in">notifySingle</span>(dyld_image_state_dependents_initialized, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//递归的调用当前image的依赖的dylib动态库的初始化函数进行初始化</span></span><br><span class="line">        <span class="comment">// initialize this image    </span></span><br><span class="line">        <span class="type">bool</span> hasInitializers = <span class="keyword">this</span>-&gt;<span class="built_in">doInitialization</span>(context);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// let anyone know we finished initializing this image</span></span><br><span class="line">        fState = dyld_image_state_initialized;</span><br><span class="line">        oldState = fState;</span><br><span class="line">        <span class="comment">// 通知runtime, 当前镜像初始化完成</span></span><br><span class="line">        context.<span class="built_in">notifySingle</span>(dyld_image_state_initialized, <span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">//.....</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">recursiveSpinUnLock</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="built_in">bool</span> ImageLoaderMachO::<span class="keyword">do</span><span class="constructor">Initialization(<span class="params">const</span> LinkContext&amp; <span class="params">context</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 初始化镜像</span></span><br><span class="line">    <span class="comment">// mach-o has -init and static initializers</span></span><br><span class="line">    <span class="keyword">do</span><span class="constructor">ImageInit(<span class="params">context</span>)</span>;</span><br><span class="line">    <span class="keyword">do</span><span class="constructor">ModInitFunctions(<span class="params">context</span>)</span>;</span><br><span class="line">    return (fHasDashInit<span class="operator"> || </span>fHasInitializers);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line"><span class="literal">void</span> ImageLoaderMachO::doImageInit(<span class="keyword">const</span> LinkContext&amp; context)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ( fHasDashInit ) &#123;</span><br><span class="line">        <span class="keyword">const</span> uint32_t <span class="function"><span class="title">cmd_count</span> = <span class="params">((macho_header*)fMachOData)</span>-&gt;</span>ncmds;</span><br><span class="line">        <span class="keyword">const</span> struct load_command* <span class="keyword">const</span> cmds = (struct load_command*)&amp;fMachOData[sizeof(macho_header)];</span><br><span class="line">        <span class="keyword">const</span> struct load_command* cmd = cmds;</span><br><span class="line">        <span class="keyword">for</span> (uint32_t i = <span class="number">0</span>; i &lt; cmd_count; ++i) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (cmd-&gt;cmd) &#123;</span><br><span class="line">                <span class="keyword">case</span> LC_ROUTINES_COMMAND:</span><br><span class="line">                    Initializer <span class="function"><span class="title">func</span> = <span class="params">(Initializer)(((struct macho_routines_command*)cmd)-&gt;init_address + fSlide)</span>;</span></span><br><span class="line"><span class="function">                    //.......</span></span><br><span class="line"><span class="function">                    <span class="title">func</span><span class="params">(context.argc, context.argv, context.envp, context.apple, &amp;context.programVars)</span>;</span></span><br><span class="line"><span class="function">                    <span class="title">break</span>;</span></span><br><span class="line"><span class="function">            &#125;</span></span><br><span class="line"><span class="function">            <span class="title">cmd</span> = <span class="params">(<span class="keyword">const</span> struct load_command*)(((char*)cmd)+cmd-&gt;cmdsize)</span>;</span></span><br><span class="line"><span class="function">        &#125;</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>

<p>doImageInit方法主要获取Mach O的init方法的地址并调用它，完成初始化操作。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">void ImageLoaderMachO::<span class="title function_ invoke__">doModInitFunctions</span>(<span class="keyword">const</span> LinkContext&amp; context)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="title function_ invoke__">if</span> ( fHasInitializers ) &#123;</span><br><span class="line">        <span class="keyword">const</span> uint32_t cmd_count = ((macho_header*)fMachOData)<span class="punctuation">-&gt;</span>ncmds;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">struct</span> <span class="title class_">load_command</span>* <span class="keyword">const</span> cmds = (<span class="keyword">struct</span> <span class="title class_">load_command</span>*)&amp;fMachOData[<span class="title function_ invoke__">sizeof</span>(macho_header)];<span class="keyword">const</span> <span class="keyword">struct</span> <span class="title class_">load_command</span>* cmd = cmds;</span><br><span class="line">        <span class="title function_ invoke__">for</span> (uint32_t i = <span class="number">0</span>; i &lt; cmd_count; ++i) &#123;</span><br><span class="line">            <span class="title function_ invoke__">if</span> ( cmd<span class="punctuation">-&gt;</span>cmd == LC_SEGMENT_COMMAND ) &#123;</span><br><span class="line">                <span class="keyword">const</span> <span class="keyword">struct</span> <span class="title class_">macho_segment_command</span>* seg = (<span class="keyword">struct</span> <span class="title class_">macho_segment_command</span>*)cmd;</span><br><span class="line">                <span class="keyword">const</span> <span class="keyword">struct</span> <span class="title class_">macho_section</span>* <span class="keyword">const</span> sectionsStart = (<span class="keyword">struct</span> <span class="title class_">macho_section</span>*)((<span class="type">char</span>*)seg + <span class="title function_ invoke__">sizeof</span>(<span class="keyword">struct</span> <span class="title class_">macho_segment_command</span>));</span><br><span class="line">                <span class="keyword">const</span> <span class="keyword">struct</span> <span class="title class_">macho_section</span>* <span class="keyword">const</span> sectionsEnd = &amp;sectionsStart[seg<span class="punctuation">-&gt;</span>nsects];</span><br><span class="line">                <span class="title function_ invoke__">for</span> (<span class="keyword">const</span> <span class="keyword">struct</span> <span class="title class_">macho_section</span>* sect=sectionsStart; sect &lt; sectionsEnd; ++sect) &#123;</span><br><span class="line">                    <span class="keyword">const</span> uint8_t <span class="keyword">type</span> = sect<span class="punctuation">-&gt;</span>flags &amp; SECTION_TYPE;</span><br><span class="line">                    <span class="title function_ invoke__">if</span> ( <span class="keyword">type</span> == S_MOD_INIT_FUNC_POINTERS ) &#123;</span><br><span class="line">                        <span class="comment">//初始化器</span></span><br><span class="line">                        Initializer* inits = (Initializer*)(sect<span class="punctuation">-&gt;</span>addr + fSlide);</span><br><span class="line">                        <span class="keyword">const</span> size_t count = sect<span class="punctuation">-&gt;</span>size / <span class="title function_ invoke__">sizeof</span>(uintptr_t);</span><br><span class="line">                        <span class="title function_ invoke__">for</span> (size_t i=<span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">                            <span class="comment">//......</span></span><br><span class="line">                            <span class="title function_ invoke__">func</span>(context.argc, context.argv, context.envp, context.apple, &amp;context.programVars);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            cmd = (<span class="keyword">const</span> <span class="keyword">struct</span> <span class="title class_">load_command</span>*)(((<span class="type">char</span>*)cmd)+cmd<span class="punctuation">-&gt;</span>cmdsize);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>doModInitFunctions方法主要获取Mach O的static initializer的地址并调用</p>
<p>这里需要注意的是这里的initalizer并非指的是名为initalizer的方法, 而是使用 attribute((constructor) 进行修饰的方法, 在ImageLoader类中initializer函数指针所指向该初始化方法的地址。</p>
<p>这里有一个十分重要的动态库初始化方法，<strong><strong>libSystem_initializer</strong></strong>就是在这个阶段被调用的。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">static <span class="constructor">__attribute__((<span class="params">constructor</span>)</span>) </span><br><span class="line">void lib<span class="constructor">System_initializer(<span class="params">int</span> <span class="params">argc</span>, <span class="params">const</span> <span class="params">char</span><span class="operator">*</span> <span class="params">argv</span>[], <span class="params">const</span> <span class="params">char</span><span class="operator">*</span> <span class="params">envp</span>[], <span class="params">const</span> <span class="params">char</span><span class="operator">*</span> <span class="params">apple</span>[], <span class="params">const</span> <span class="params">struct</span> ProgramVars<span class="operator">*</span> <span class="params">vars</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="constructor">_libkernel_init(<span class="params">libkernel_funcs</span>)</span>;</span><br><span class="line"></span><br><span class="line">    bootstrap<span class="constructor">_init()</span>;</span><br><span class="line">    mach<span class="constructor">_init()</span>;</span><br><span class="line">    pthread<span class="constructor">_init()</span>;</span><br><span class="line">    <span class="constructor">__libc_init(<span class="params">vars</span>, <span class="params">libSystem_atfork_prepare</span>, <span class="params">libSystem_atfork_parent</span>, <span class="params">libSystem_atfork_child</span>, <span class="params">apple</span>)</span>;</span><br><span class="line">    <span class="constructor">__keymgr_initializer()</span>;</span><br><span class="line">    <span class="constructor">_dyld_initializer()</span>;</span><br><span class="line"></span><br><span class="line">    libdispatch<span class="constructor">_init()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="constructor">_libxpc_initializer()</span>;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">	errno = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>libSystem_initializer会调用libdispatch_init再到_objc_init初始化runtime在_objc_init中通过注册了几个关键通知, 从dyld这里接手了关键时机的处理，这个方法会在下一篇介绍runtime的博客中进行介绍，我们先继续往下看。对于Libsystem代码地址可以在<a target="_blank" rel="noopener" href="https://opensource.apple.com/tarballs/Libsystem/">该地址</a>进行下载.</p>
<p><strong><strong>获取主程序入口</strong></strong></p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">result</span> = (uintptr_t)sMainExecutable-&gt;</span>getThreadPC();</span><br><span class="line"><span class="keyword">if</span> ( result != <span class="number">0</span> ) &#123;</span><br><span class="line">    <span class="comment">// 主可执行文件使用lc_main，需要返回libdyld.dylib中的glue</span></span><br><span class="line">    <span class="comment">//调用main()</span></span><br><span class="line">    <span class="comment">//当执行完dyld::_main方法之后,返回了main()函数地址,这个时候所有初始化工作都已经完成了,正式进入Objc声明周期</span></span><br><span class="line">    <span class="comment">// main executable uses LC_MAIN, needs to return to glue in libdyld.dylib</span></span><br><span class="line">    <span class="function"><span class="title">if</span> ( (gLibSystemHelpers != NULL) &amp;&amp; (gLibSystemHelpers-&gt;</span>version &gt;= <span class="number">9</span>) )</span><br><span class="line">        *<span class="function"><span class="title">startGlue</span> = (uintptr_t)gLibSystemHelpers-&gt;</span>startGlueToCallExit;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        halt(<span class="string">&quot;libdyld.dylib support not present for LC_MAIN&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// main executable uses LC_UNIXTHREAD, dyld needs to let &quot;start&quot; in program set up for main()</span></span><br><span class="line">    <span class="function"><span class="title">result</span> = (uintptr_t)sMainExecutable-&gt;</span>getMain();</span><br><span class="line">    *startGlue = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>main 地址有两种方式获取，一种是存放在LC_MAIN命令中，这时候需要调用<strong><strong>getThreadPC</strong></strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="title">ImageLoaderMachO::getThreadPC</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">uint32_t</span> cmd_count = ((macho_header*)fMachOData)-&gt;ncmds;</span><br><span class="line">    <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">load_command</span>* <span class="type">const</span> cmds = (<span class="keyword">struct</span> load_command*)&amp;fMachOData[<span class="built_in">sizeof</span>(macho_header)];</span><br><span class="line">    <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">load_command</span>* cmd = cmds;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint32_t</span> i = <span class="number">0</span>; i &lt; cmd_count; ++i) &#123;</span><br><span class="line">        <span class="comment">// 遍历loadCommand,加载loadCommand中的&#x27;LC_MAIN&#x27;所指向的偏移地址</span></span><br><span class="line">        <span class="keyword">if</span> ( cmd-&gt;cmd == LC_MAIN ) &#123;</span><br><span class="line">            entry_point_command* mainCmd = (entry_point_command*)cmd;</span><br><span class="line">            <span class="comment">// 偏移量 + header所占的字节数，就是main的入口</span></span><br><span class="line">            <span class="type">void</span>* entry = (<span class="type">void</span>*)(mainCmd-&gt;entryoff + (<span class="type">char</span>*)fMachOData);</span><br><span class="line">            <span class="keyword">if</span> ( <span class="keyword">this</span>-&gt;<span class="built_in">containsAddress</span>(entry) )</span><br><span class="line">                <span class="keyword">return</span> entry;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="string">&quot;LC_MAIN entryoff is out of range&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cmd = (<span class="type">const</span> <span class="keyword">struct</span> load_command*)(((<span class="type">char</span>*)cmd)+cmd-&gt;cmdsize);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>getThreadPC主要逻辑就是遍历loadCommand，找到’LC_MAIN’指令，得到该指令所指向的偏移地址，经过处理后，就得到了main函数的地址，将此地址返回给__dyld_start。__dyld_start中将main函数地址保存在寄存器后，跳转到对应的地址，开始执行main函数，另一种Mach O不支持LC_MAIN仅支持LC_UNIXTHREAD，这时候就需要调用<strong><strong>getMain</strong></strong>方法。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="title">ImageLoaderMachO::getMain</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">uint32_t</span> cmd_count = ((macho_header*)fMachOData)-&gt;ncmds;</span><br><span class="line">    <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">load_command</span>* <span class="type">const</span> cmds = (<span class="keyword">struct</span> load_command*)&amp;fMachOData[<span class="built_in">sizeof</span>(macho_header)];</span><br><span class="line">    <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">load_command</span>* cmd = cmds;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint32_t</span> i = <span class="number">0</span>; i &lt; cmd_count; ++i) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (cmd-&gt;cmd) &#123;</span><br><span class="line">            <span class="keyword">case</span> LC_UNIXTHREAD: </span><br><span class="line">            &#123;</span><br><span class="line">            <span class="meta">#<span class="keyword">if</span> __i386__</span></span><br><span class="line">                <span class="type">const</span> <span class="type">i386_thread_state_t</span>* registers = (<span class="type">i386_thread_state_t</span>*)(((<span class="type">char</span>*)cmd) + <span class="number">16</span>);</span><br><span class="line">                <span class="type">void</span>* entry = (<span class="type">void</span>*)(registers-&gt;eip + fSlide);</span><br><span class="line">            <span class="meta">#<span class="keyword">elif</span> __x86_64__</span></span><br><span class="line">                <span class="type">const</span> <span class="type">x86_thread_state64_t</span>* registers = (<span class="type">x86_thread_state64_t</span>*)(((<span class="type">char</span>*)cmd) + <span class="number">16</span>);</span><br><span class="line">                <span class="type">void</span>* entry = (<span class="type">void</span>*)(registers-&gt;rip + fSlide);</span><br><span class="line">            <span class="comment">//.....</span></span><br><span class="line">            &#125;   </span><br><span class="line">            <span class="keyword">break</span>;      </span><br><span class="line">        &#125;</span><br><span class="line">        cmd = (<span class="type">const</span> <span class="keyword">struct</span> load_command*)(((<span class="type">char</span>*)cmd)+cmd-&gt;cmdsize);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">&quot;no valid entry point&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>上一篇博客我们主要介绍了从点击应用到加载dyld，再将地址设置到dyld到入口地址，这篇博客就从dyld入口地址__dyld_start作为起点，在这个阶段中主要做了如下工作：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1.</span> 将主程序初始化为imageLoader</span><br><span class="line"><span class="bullet">2.</span> 加载共享库到内存</span><br><span class="line"><span class="bullet">3.</span> 加载插入的动态库</span><br><span class="line"><span class="bullet">4.</span> 链接主程序,链接插入库</span><br><span class="line"><span class="bullet">5.</span> 初始化主程序，插入库</span><br><span class="line"><span class="bullet">6.</span> 寻找主程序入口点</span><br></pre></td></tr></table></figure>

<p>而下一篇博客要给大家介绍的是十分关键的runtime，它的初始化就发生在初始化主程序，插入库这个阶段，这个阶段会调用使用 attribute((constructor) 进行修饰的方法, 其中这里有一个十分重要的动态库初始化方法，<strong><strong>libSystem_initializer</strong></strong>就是在这个阶段被调用的libSystem_initializer会调用libdispatch_init再到_objc_init初始化runtime在_objc_init中通过注册了几个关键通知, 从dyld这里接手了关键时机的处理，包括镜像映射，镜像加载，镜像卸载，这些都是下一篇博客将要介绍的。从下一篇开始就要正式介入介绍Runtime了。</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://yulingtianxia.com/blog/2016/10/30/Optimizing-App-Startup-Time/">优化 App 的启动时间</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.cnbluebox.com/blog/2017/06/20/dyldyu-objc/">dyld与ObjC</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.cnbluebox.com/blog/2017/10/12/dyld2/">Dyld之二: 动态链接过程</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/d2eeb4085af5">iOS App启动时发生了什么?</a></li>
<li><a target="_blank" rel="noopener" href="https://zhiyongzou.github.io/2018/03/26/App-%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96%E6%8E%A2%E7%B4%A2/">App 启动优化探索</a></li>
</ul>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Objective-C-%E7%9B%B8%E5%85%B3/">Objective C 相关</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/Objective-C-相关/">Objective C 相关</a>
  </div>

</div>



<div class="comments-count">
	
	  	<span></span>
		<a href="/2020/01/14/iOS-Runtime源码解析之dyld/#comments" class="ds-thread-count comments-count-link" data-thread-key="2020/01/14/iOS-Runtime源码解析之dyld/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2020/01/09/iOS-Runtime源码解析之App启动/" title="iOS Runtime源码解析之App启动" itemprop="url">iOS Runtime源码解析之App启动</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Edgar" target="_blank" itemprop="author">Edgar</a>
		
  <p class="article-time">
    <time datetime="2020-01-09T13:34:38.000Z" itemprop="datePublished"> Published 2020-01-09</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>上一篇博客介绍了Mach O文件的格式，以及每个部分的作用，这一部分开始将要介绍的是在上一个基础上如何将Mach O文件加载并运行起来。我们会从点击执行应用开始，到加载dyld，初始化dyld，再到dyld将镜像加载到内存，Rebase&#x2F;Bind，Runtime初始化，其它的初始化代码，最后运行main函数为止。整个过程如下图所示：</p>
<p><img src="/2020/01/09/iOS-Runtime%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8BApp%E5%90%AF%E5%8A%A8/000001.png"></p>
<p>在开始这篇博客内容规划之前，最难的是从哪里开头讲，后面查看了XNU代码后发现个人能hold住的起点应该是load_init_program，当然后面随着技术的提高肯定能够从更深层次给大家讲明白这个问题，都是时间问题，对自己有信心，好了不说太多无关的内容了，直接切入主题：</p>
<p>我们知道XNU内核启动后，启动的第一个进程是launchd。launchd启动之后会启动其他守护进程。我们可以看XNU源码中有如下一句注释：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">//</span> Description:	Load the <span class="string">&quot;init&quot;</span> program; <span class="keyword">in</span> most cases, this will be <span class="string">&quot;launchd&quot;</span></span><br></pre></td></tr></table></figure>
<p>我们先来看下<strong><strong>load_init_program</strong></strong>：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">load_init_program(proc_t p)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Copy out program name.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    init_addr = VM_MIN_ADDRESS;</span><br><span class="line">    (<span class="type">void</span>) vm_allocate(current_map(), &amp;init_addr, PAGE_SIZE,VM_FLAGS_ANYWHERE);</span><br><span class="line">    <span class="keyword">if</span> (init_addr == <span class="number">0</span>)</span><br><span class="line">        init_addr++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将/sbin/launchd拷贝到 init_addr = 1 </span></span><br><span class="line">    (<span class="type">void</span>) copyout((caddr_t) init_program_name, <span class="built_in">CAST_USER_ADDR_T</span>(init_addr),(<span class="type">unsigned</span>) <span class="keyword">sizeof</span>(init_program_name)+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    argv[argc++] = (<span class="type">char</span> *) init_addr; <span class="comment">//argv[0] = &quot;/sbin/launchd&quot;</span></span><br><span class="line">    init_addr += <span class="keyword">sizeof</span>(init_program_name);</span><br><span class="line">    init_addr = (vm_offset_t)ROUND_PTR(<span class="type">char</span>, init_addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (boothowto &amp; RB_SINGLE) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="type">char</span> *init_args = <span class="string">&quot;-s&quot;</span>;</span><br><span class="line">        copyout(init_args, <span class="built_in">CAST_USER_ADDR_T</span>(init_addr),strlen(init_args));</span><br><span class="line">        argv[argc++] = (<span class="type">char</span> *)init_addr; <span class="comment">//argv[1] = &quot;-s&quot;</span></span><br><span class="line">        init_addr += strlen(init_args);</span><br><span class="line">        init_addr = (vm_offset_t)ROUND_PTR(<span class="type">char</span>, init_addr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Null-end the argument list</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    argv[argc] = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Copy out the argument list.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//参数拷贝到指定到位置</span></span><br><span class="line">    (<span class="type">void</span>) copyout((caddr_t) argv, <span class="built_in">CAST_USER_ADDR_T</span>(init_addr),(<span class="type">unsigned</span>) <span class="keyword">sizeof</span>(argv));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//到此位置 argv[0] = &quot;/sbin/launchd&quot;</span></span><br><span class="line">    <span class="comment">//        argv[1] = &quot;-s&quot;</span></span><br><span class="line">    <span class="comment">//        argv[2] = 参数列表</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Set up argument block for fake call to execve.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    init_exec_args.fname = <span class="built_in">CAST_USER_ADDR_T</span>(argv[<span class="number">0</span>]);  <span class="comment">//argv[0] = &quot;/sbin/launchd&quot;</span></span><br><span class="line">    init_exec_args.argp = <span class="built_in">CAST_USER_ADDR_T</span>((<span class="type">char</span> **)init_addr);</span><br><span class="line">    init_exec_args.envp = <span class="built_in">CAST_USER_ADDR_T</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将init_exec_args作为参数传递给execve</span></span><br><span class="line">    error = execve(p,&amp;init_exec_args,retval);</span><br><span class="line">    <span class="keyword">if</span> (error)</span><br><span class="line">        panic(<span class="string">&quot;Process 1 exec of %s failed, errno %d\n&quot;</span>,</span><br><span class="line">              init_program_name, error);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们接下来看下<strong><strong>execve</strong></strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">execve</span><span class="params">(<span class="type">proc_t</span> p, <span class="keyword">struct</span> execve_args *uap, <span class="type">register_t</span> *retval)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">__mac_execve_args</span> muap;</span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line">    muap.fname = uap-&gt;fname;   <span class="comment">//程序执行路径</span></span><br><span class="line">    muap.argp = uap-&gt;argp;     <span class="comment">//参数列表</span></span><br><span class="line">    muap.envp = uap-&gt;envp;     <span class="comment">//环境变量</span></span><br><span class="line">    muap.mac_p = USER_ADDR_NULL;</span><br><span class="line">    <span class="comment">//这里只是调用了__mac_execve将执行文件名，参数列表，环境变量传入</span></span><br><span class="line">    err = __mac_execve(p, &amp;muap, retval);</span><br><span class="line">    <span class="keyword">return</span>(err);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在execve主要将execve_args中的程序执行文件路径，参数列表，环境变量通过__mac_execve传入到后续流程：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> <span class="constructor">__mac_execve(<span class="params">proc_t</span> <span class="params">p</span>, <span class="params">struct</span> <span class="params">__mac_execve_args</span> <span class="operator">*</span><span class="params">uap</span>, <span class="params">register_t</span> <span class="operator">*</span><span class="params">retval</span>)</span> &#123;</span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line">    task = current<span class="constructor">_task()</span>;   <span class="comment">//获取当前的任务</span></span><br><span class="line">    <span class="comment">//.......</span></span><br><span class="line">    <span class="comment">//激活镜像:主要是为加载镜像进行数据的初始化，以及资源相关的操作</span></span><br><span class="line">    error = exec<span class="constructor">_activate_image(<span class="params">imgp</span>)</span>;</span><br><span class="line">    <span class="comment">//.......</span></span><br><span class="line">    return(error);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>__mac_execve 主要是调用exec_activate_image来激活镜像</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * exec_activate_image</span><br><span class="line"> * 遍历可用镜像激活器，并激活与imgp 结构相关的镜像</span><br><span class="line"> * 主要是拷贝可执行文件到内存中，并根据不同的可执行文件类型选择不同的加载函数，</span><br><span class="line"> * 所有的镜像的加载要么终止在一个错误上，要么最终完成加载镜像。</span><br><span class="line"> */</span><br><span class="line">static int exec_activate_image(struct image_params *imgp) &#123;</span><br><span class="line">    <span class="regexp">//</span>.......</span><br><span class="line">again:</span><br><span class="line">    <span class="regexp">//</span> 检查镜像是否是普通文件，是否可执行，是否可读</span><br><span class="line">    error = exec_check_permissions(imgp);</span><br><span class="line">    <span class="regexp">//</span>......</span><br><span class="line">encapsulated_binary:</span><br><span class="line">    <span class="regexp">//</span>根据不同的可执行文件类型选择不同的加载函数</span><br><span class="line">    <span class="regexp">//</span>OS X有三种可执行文件，mach-o由exec_mach_imgact处理，fat binary由exec_fat_imgact处理，</span><br><span class="line">    <span class="regexp">//i</span>nterpreter（解释器）由exec_shell_imgact处理</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; error == -<span class="number">1</span> &amp;&amp; execsw[i].ex_imgact != NULL; i++) &#123;</span><br><span class="line">        <span class="regexp">//</span>遍历镜像激活函数，寻找可以激活当前镜像的激活器</span><br><span class="line">        error = (*execsw[i].ex_imgact)(imgp);</span><br><span class="line">        <span class="regexp">//</span>...........</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="regexp">//</span>........</span><br><span class="line">    return (error);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>exec_activate_image主要任务是遍历可用镜像激活器，按照可执行文件的格式，执行不同的函数。目前有三种格式，单指令集可执行文件（Mach-o Binary），多指令集可执行文件（Fat Binary），shell 脚本（Interpreter Script）。<br>exec_activate_image首先会对镜像文件进行一次校验，检查镜像是否是普通文件，是否可执行，是否可读，然后遍历镜像激活函数，寻找可以激活当前镜像的激活器。<strong><strong>execsw</strong></strong>是当前能够支持的镜像激活表。它是一个结构体指针，每项结构体的结构如下所示：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> execsw &#123;</span><br><span class="line">    <span class="built_in">int</span> (*ex_imgact)(<span class="keyword">struct</span> image_params *); <span class="comment">//激活镜像的方法指针</span></span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">char</span> *ex_name;                     <span class="comment">//镜像名</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>包含激活镜像的方法，以及镜像名。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> execsw &#123;</span><br><span class="line">    <span class="type">int</span> (*ex_imgact)(<span class="keyword">struct</span> image_params *); <span class="comment">//激活镜像的方法指针</span></span><br><span class="line">    <span class="keyword">const</span> <span class="type">char</span> *ex_name;                     <span class="comment">//镜像名</span></span><br><span class="line">&#125; execsw[] = &#123;</span><br><span class="line">    &#123; exec_mach_imgact, <span class="string">&quot;Mach-o Binary&quot;</span> &#125;,</span><br><span class="line">    &#123; exec_fat_imgact, <span class="string">&quot;Fat Binary&quot;</span> &#125;,</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> IMGPF_POWERPC</span></span><br><span class="line">    &#123; exec_powerpc32_imgact, <span class="string">&quot;PowerPC binary&quot;</span> &#125;,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">/* IMGPF_POWERPC */</span></span></span><br><span class="line">    &#123; exec_shell_imgact, <span class="string">&quot;Interpreter Script&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们这里只以Mach-o Binary的激活器为例子来看下是怎么激活的。</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">static int exec_mach_imgact(struct image_params *imgp) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">struct</span> mach_header *mach_header = (struct mach_header *)imgp-&gt;</span>ip_vdata;</span><br><span class="line">    <span class="comment">//........</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 首先确保这是个Mach-O 1.0 或者Mach-O 2.0二进制文件</span></span><br><span class="line"><span class="comment">     * make sure it&#x27;s a Mach-O 1.0 or Mach-O 2.0 binary; the difference</span></span><br><span class="line"><span class="comment">     * is a reserved field on the end, so for the most part, we can</span></span><br><span class="line"><span class="comment">     * treat them as if they were identical.</span></span><br><span class="line"><span class="comment">     * magic检查</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="title">if</span> ((mach_header-&gt;</span>magic != MH_MAGIC<span class="comment">/*32位架构*/</span>) &amp;&amp;</span><br><span class="line">        (<span class="function"><span class="title">mach_header</span>-&gt;</span>magic != MH_MAGIC_64<span class="comment">/*64位架构*/</span>)) &#123;</span><br><span class="line">        error = -<span class="number">1</span>;</span><br><span class="line">        goto bad;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果文件类型为MH_DYLIB 或者MH_BUNDLE 返回错误</span></span><br><span class="line">    <span class="comment">//为什么MH_DYLIB，MH_BUNDLE 要认定为error</span></span><br><span class="line">    <span class="function"><span class="title">switch</span> (mach_header-&gt;</span>filetype) &#123;</span><br><span class="line">    case MH_DYLIB:</span><br><span class="line">    case MH_BUNDLE:</span><br><span class="line">        error = -<span class="number">1</span>;</span><br><span class="line">        goto bad;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//cpu 类型检查</span></span><br><span class="line">    <span class="function"><span class="title">if</span> (!imgp-&gt;</span>ip_origcputype) &#123;</span><br><span class="line">        <span class="function"><span class="title">imgp</span>-&gt;</span><span class="function"><span class="title">ip_origcputype</span> = mach_header-&gt;</span>cputype;</span><br><span class="line">        <span class="function"><span class="title">imgp</span>-&gt;</span><span class="function"><span class="title">ip_origcpusubtype</span> = mach_header-&gt;</span>cpusubtype;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    task = current_task();</span><br><span class="line">    thread = current_thread();</span><br><span class="line">    uthread = get_bsdthread_info(thread);</span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     *  加载 Mach-O 文件 </span></span><br><span class="line"><span class="comment">     *  Load the Mach-O file.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * <span class="doctag">NOTE:</span> An error after this point  indicates we have potentially</span></span><br><span class="line"><span class="comment">     * destroyed or overwrote some process state while attempting an</span></span><br><span class="line"><span class="comment">     * execve() following a vfork(), which is an unrecoverable condition.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * We reset the task to 64-bit (or not) here.  It may have picked up</span></span><br><span class="line"><span class="comment">     * a new map, and we need that to reflect its true 64-bit nature.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    task_set_64bit(task, </span><br><span class="line">               ((<span class="function"><span class="title">imgp</span>-&gt;</span>ip_flags &amp; IMGPF_IS_64BIT) == IMGPF_IS_64BIT));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 实际加载我们之前想要加载的镜像</span></span><br><span class="line"><span class="comment">     * Actually load the image file we previously decided to load.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    lret = load_machfile(imgp, mach_header, thread, map, &amp;load_result);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line">    <span class="comment">/* load_machfile() maps the vnode */</span></span><br><span class="line">    (<span class="function"><span class="title">void</span>)ubc_map(imgp-&gt;</span>ip_vp, PROT_READ | PROT_EXEC);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Set up the system reserved areas in the new address space.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    vm_map_exec(get_task_map(task),</span><br><span class="line">            task,</span><br><span class="line">            (<span class="function"><span class="title">void</span> *) p-&gt;</span><span class="function"><span class="title">p_fd</span>-&gt;</span>fd_rdir,</span><br><span class="line">            cpu_type());</span><br><span class="line">    <span class="comment">//.......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>exec_mach_imgact 其实会对Mach O文件的header信息校验，确保当前的文件是Mach O文件，并且校验它的cpu类型是否符合当前设备平台。当这些都校验通过后就通过load_machfile加载Mach O文件。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">load_return_t</span> <span class="title">load_machfile</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">struct</span> image_params *imgp,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">struct</span> mach_header  *header,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">thread_t</span>    thread,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">vm_map_t</span>    new_map,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">load_result_t</span>   *result</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="comment">//解析mach文件</span></span><br><span class="line">    lret = <span class="built_in">parse_machfile</span>(vp, map, thread, header, file_offset, macho_size,<span class="number">0</span>, result);</span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>load_machfile会加载Mach-O中的各种load monmand命令。在其内部会禁止数据段执行防止溢出漏洞攻击，还会设置地址空间布局随机化（ASLR），还有一些映射的调整。load_machfile内部直接调用了parse_machfile方法。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">load_return_t</span> <span class="title">parse_machfile</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">struct</span> vnode         *vp,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">vm_map_t</span>             map,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">thread_t</span>             thread,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">struct</span> mach_header   *header,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">off_t</span>                file_offset,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">off_t</span>                macho_size,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span>                  depth,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">load_result_t</span>       *result</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line">    <span class="comment">//类型校验</span></span><br><span class="line">    <span class="keyword">if</span> (header-&gt;magic == MH_MAGIC_64 || header-&gt;magic == MH_CIGAM_64) &#123;</span><br><span class="line">        mach_header_sz = <span class="built_in">sizeof</span>(<span class="keyword">struct</span> mach_header_64);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     *	Break infinite recursion</span></span><br><span class="line"><span class="comment">     *  打破因为层级较深导致的无限递归</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (depth &gt; <span class="number">6</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>(LOAD_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    task = (<span class="type">task_t</span>)<span class="built_in">get_threadtask</span>(thread);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//深度计数值递增</span></span><br><span class="line">    <span class="comment">// depth负责parse_machfile 遍历次数，第一次是解析mach-o, 第二次&#x27;load_dylinker&#x27;会调用此函数来进行dyld的解析</span></span><br><span class="line">    depth++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     *  检查是否是正确的计算机类型</span></span><br><span class="line"><span class="comment">     *  Check to see if right machine type.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (((<span class="type">cpu_type_t</span>)(header-&gt;cputype &amp; ~CPU_ARCH_MASK) != <span class="built_in">cpu_type</span>()) ||</span><br><span class="line">        !<span class="built_in">grade_binary</span>(header-&gt;cputype, </span><br><span class="line">            header-&gt;cpusubtype &amp; ~CPU_SUBTYPE_MASK))</span><br><span class="line">        <span class="keyword">return</span>(LOAD_BADARCH);</span><br><span class="line"></span><br><span class="line">    abi64 = ((header-&gt;cputype &amp; CPU_ARCH_ABI64) == CPU_ARCH_ABI64);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//主要是用来对Mach-O做检测，会检测Mach-O头部，解析其架构、检查imgp等内容，</span></span><br><span class="line">    <span class="comment">//并拒绝接受Dylib和Bundle这样的文件，这些文件会由dyld负责加载</span></span><br><span class="line">    <span class="keyword">switch</span> (header-&gt;filetype) &#123;</span><br><span class="line">    <span class="keyword">case</span> MH_OBJECT:</span><br><span class="line">    <span class="keyword">case</span> MH_EXECUTE:</span><br><span class="line">    <span class="keyword">case</span> MH_PRELOAD:</span><br><span class="line">        <span class="comment">//第一次的时候这里会走通</span></span><br><span class="line">        <span class="keyword">if</span> (depth != <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> (LOAD_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> MH_FVMLIB:</span><br><span class="line">    <span class="keyword">case</span> MH_DYLIB:</span><br><span class="line">        <span class="keyword">if</span> (depth == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> (LOAD_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> MH_DYLINKER:</span><br><span class="line">        <span class="comment">//第二次的时候这里会走通</span></span><br><span class="line">        <span class="keyword">if</span> (depth != <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> (LOAD_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> (LOAD_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     *  Round size of Mach-O commands up to page boundry.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    size = <span class="built_in">round_page</span>(mach_header_sz + header-&gt;sizeofcmds);</span><br><span class="line">    <span class="keyword">if</span> (size &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>(LOAD_BADMACHO);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 将加载命令映射到内核地址</span></span><br><span class="line"><span class="comment">     * Map the load commands into kernel memory.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//.......</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     *  扫描每个命令，处理每个命令</span></span><br><span class="line"><span class="comment">     *  Scan through the commands, processing each one as necessary.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">for</span> (pass = <span class="number">1</span>; pass &lt;= <span class="number">2</span>; pass++) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Loop through each of the load_commands indicated by the</span></span><br><span class="line"><span class="comment">         * Mach-O header; if an absurd value is provided, we just</span></span><br><span class="line"><span class="comment">         * run off the end of the reserved section by incrementing</span></span><br><span class="line"><span class="comment">         * the offset too far, so we are implicitly fail-safe.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        offset = mach_header_sz;</span><br><span class="line">        <span class="comment">//加载命令数目</span></span><br><span class="line">        ncmds = header-&gt;ncmds;</span><br><span class="line">        <span class="keyword">while</span> (ncmds--) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             *  获取指向命令的地址</span></span><br><span class="line"><span class="comment">             *  Get a pointer to the command.</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            lcp = (<span class="keyword">struct</span> load_command *)(addr + offset);</span><br><span class="line">            oldoffset = offset;</span><br><span class="line">            offset += lcp-&gt;cmdsize;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Perform prevalidation of the struct load_command</span></span><br><span class="line"><span class="comment">             * before we attempt to use its contents.  Invalid</span></span><br><span class="line"><span class="comment">             * values are ones which result in an overflow, or</span></span><br><span class="line"><span class="comment">             * which can not possibly be valid commands, or which</span></span><br><span class="line"><span class="comment">             * straddle or exist past the reserved section at the</span></span><br><span class="line"><span class="comment">             * start of the image.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (oldoffset &gt; offset ||</span><br><span class="line">                lcp-&gt;cmdsize &lt; <span class="built_in">sizeof</span>(<span class="keyword">struct</span> load_command) ||</span><br><span class="line">                offset &gt; header-&gt;sizeofcmds + mach_header_sz) &#123;</span><br><span class="line">                ret = LOAD_BADMACHO;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Act on struct load_command&#x27;s for which kernel</span></span><br><span class="line"><span class="comment">             * intervention is required.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">switch</span>(lcp-&gt;cmd) &#123;</span><br><span class="line">            <span class="comment">/*加载64位segment*/</span></span><br><span class="line">            <span class="keyword">case</span> LC_SEGMENT_64:</span><br><span class="line">                <span class="keyword">if</span> (pass != <span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                ret = <span class="built_in">load_segment_64</span>(</span><br><span class="line">                        (<span class="keyword">struct</span> segment_command_64 *)lcp,</span><br><span class="line">                           pager,</span><br><span class="line">                           file_offset,</span><br><span class="line">                           macho_size,</span><br><span class="line">                           <span class="built_in">ubc_getsize</span>(vp),</span><br><span class="line">                           map,</span><br><span class="line">                           result);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">/*加载32位segment*/</span></span><br><span class="line">            <span class="keyword">case</span> LC_SEGMENT:</span><br><span class="line">                <span class="keyword">if</span> (pass != <span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                ret = <span class="built_in">load_segment</span>(</span><br><span class="line">                           (<span class="keyword">struct</span> segment_command *) lcp,</span><br><span class="line">                           pager,</span><br><span class="line">                           file_offset,</span><br><span class="line">                           macho_size,</span><br><span class="line">                           <span class="built_in">ubc_getsize</span>(vp),</span><br><span class="line">                           map,</span><br><span class="line">                           result);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">/*加载线程数据*/</span></span><br><span class="line">            <span class="keyword">case</span> LC_THREAD:</span><br><span class="line">                <span class="keyword">if</span> (pass != <span class="number">2</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">                ret = <span class="built_in">load_thread</span>((<span class="keyword">struct</span> thread_command *)lcp,</span><br><span class="line">                           thread,</span><br><span class="line">                           result);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">/*加载unix线程数据*/</span></span><br><span class="line">            <span class="keyword">case</span> LC_UNIXTHREAD:</span><br><span class="line">                <span class="keyword">if</span> (pass != <span class="number">2</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                ret = <span class="built_in">load_unixthread</span>(</span><br><span class="line">                        (<span class="keyword">struct</span> thread_command *) lcp,</span><br><span class="line">                         thread,</span><br><span class="line">                         result);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">/*加载动态加载器 程序需要的dyld的路径*/</span></span><br><span class="line">            <span class="keyword">case</span> LC_LOAD_DYLINKER:</span><br><span class="line">                <span class="keyword">if</span> (pass != <span class="number">2</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> ((depth == <span class="number">1</span>) &amp;&amp; (dlp == <span class="number">0</span>)) &#123;</span><br><span class="line">                    dlp = (<span class="keyword">struct</span> dylinker_command *)lcp;</span><br><span class="line">                    dlarchbits = (header-&gt;cputype &amp; CPU_ARCH_MASK);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ret = LOAD_FAILURE;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">/*加载代码签名加载器*/</span></span><br><span class="line">            <span class="keyword">case</span> LC_CODE_SIGNATURE:</span><br><span class="line">                <span class="comment">/* CODE SIGNING */</span></span><br><span class="line">                <span class="keyword">if</span> (pass != <span class="number">2</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">/* pager -&gt; uip -&gt;</span></span><br><span class="line"><span class="comment">                   load signatures &amp; store in uip</span></span><br><span class="line"><span class="comment">                    set VM object &quot;signed_pages&quot;</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                ret = <span class="built_in">load_code_signature</span>(</span><br><span class="line">                    (<span class="keyword">struct</span> linkedit_data_command *) lcp,</span><br><span class="line">                    vp,</span><br><span class="line">                    file_offset,</span><br><span class="line">                    macho_size,</span><br><span class="line">                    header-&gt;cputype,</span><br><span class="line">                    (depth == <span class="number">1</span>) ? result : <span class="literal">NULL</span>);</span><br><span class="line">                <span class="keyword">if</span> (ret != LOAD_SUCCESS) &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;proc %d: load code signature error %d &quot;</span></span><br><span class="line">                           <span class="string">&quot;for file \&quot;%s\&quot;\n&quot;</span>,</span><br><span class="line">                           p-&gt;p_pid, ret, vp-&gt;v_name);</span><br><span class="line">                    ret = LOAD_SUCCESS; <span class="comment">/* ignore error */</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    got_code_signatures = TRUE;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="comment">/* Other commands are ignored by the kernel */</span></span><br><span class="line">                ret = LOAD_SUCCESS;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ret != LOAD_SUCCESS)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ret != LOAD_SUCCESS)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//加载成功</span></span><br><span class="line">    <span class="keyword">if</span> (ret == LOAD_SUCCESS) &#123; </span><br><span class="line">        <span class="keyword">if</span> (! got_code_signatures) &#123;</span><br><span class="line">            <span class="keyword">struct</span> <span class="title class_">cs_blob</span> *blob;</span><br><span class="line">            <span class="comment">/* no embedded signatures: look for detached ones */</span></span><br><span class="line">            blob = <span class="built_in">ubc_cs_blob_get</span>(vp, <span class="number">-1</span>, file_offset);</span><br><span class="line">            <span class="keyword">if</span> (blob != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="comment">/* get flags to be applied to the process */</span></span><br><span class="line">                result-&gt;csflags |= blob-&gt;csb_flags;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//加载动态链接器dlp为从上面获取到的动态dyliner的路径</span></span><br><span class="line">        <span class="keyword">if</span> (dlp != <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//加载dylinker</span></span><br><span class="line">            ret = <span class="built_in">load_dylinker</span>(dlp, dlarchbits, map, thread, depth, result, abi64);</span><br><span class="line">            <span class="comment">//......</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line">    <span class="keyword">return</span>(ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在parse_machfile中会将Mach O文件中loadCommand部分的命令加载到内存执行。这些command中最重要的命令是<strong><strong>LC_SEGMENT&#x2F;LC_SEGMENT_64</strong></strong> 以及 <strong><strong>LC_UNIXTHREAD&#x2F;LC_MAIN</strong></strong>，<strong><strong>LC_SEGMENT&#x2F;LC_SEGMENT_64</strong></strong>用于告诉加载器某些可执行的部分代码需要映射到指定的内存区域，<strong><strong>LC_UNIXTHREAD&#x2F;LC_MAIN</strong></strong> 告诉加载器在可执行代码加载后的入口点，有了它动态加载器知道在加载结束后跳到哪个位置，这些入口点要么是main方法，要么是在编译时期编译器添加的启动代码。如果没有动态库，这些命令已经足够了，但是如果有依赖动态库，在将所有的segments映射到内存中的时候，加载器还需要处理可执行代码的全部依赖，这些在后面的时候会详细介绍。由于parse_machfile会在后续递归调用，所以这里用了一个depth来控制递归深度。</p>
<p>当depth等于1的时候：</p>
<figure class="highlight gml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (header-&gt;filetype) &#123;</span><br><span class="line"><span class="keyword">case</span> MH_OBJECT:</span><br><span class="line"><span class="keyword">case</span> MH_EXECUTE:</span><br><span class="line"><span class="keyword">case</span> MH_PRELOAD:</span><br><span class="line">    <span class="comment">//depth=1 时候这里会走通</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">depth</span> != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> (LOAD_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> MH_FVMLIB:</span><br><span class="line"><span class="keyword">case</span> MH_DYLIB:</span><br><span class="line">    <span class="comment">//depth=1 时候这里会失败</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">depth</span> == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> (LOAD_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> MH_DYLINKER:</span><br><span class="line">    <span class="comment">//depth=1 时候这里会失败</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">depth</span> != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> (LOAD_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">return</span> (LOAD_FAILURE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这时候如果Mach O 文件类型为 <strong><strong>MH_OBJECT</strong></strong>，<strong><strong>MH_EXECUTE</strong></strong>，<strong><strong>MH_PRELOAD</strong></strong> 就会走到下面的流程，下面的流程会先执行LC_SEGMENT_64，LC_SEGMENT将某些可执行的代码映射到指定的内存区域。然后再执行LC_THREAD，LC_UNIXTHREAD，LC_LOAD_DYLINKER，LC_CODE_SIGNATURE。这里最为关键的命令是LC_LOAD_DYLINKER，它会对dyld进行赋值。在最后会调用：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">ret = load<span class="constructor">_dylinker(<span class="params">dlp</span>, <span class="params">dlarchbits</span>, <span class="params">map</span>, <span class="params">thread</span>, <span class="params">depth</span>, <span class="params">result</span>, <span class="params">abi64</span>)</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span></span></span><br><span class="line"><span class="function"><span class="type">load_return_t</span></span></span><br><span class="line"><span class="function"><span class="title">load_dylinker</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">struct</span> dylinker_command *lcp,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">integer_t</span>   archbits,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">vm_map_t</span>    map,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">thread_t</span>    thread,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span>         depth,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">load_result_t</span>   *result,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">boolean_t</span>       is_64bit</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//..........</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 首先直接映射dyld </span></span><br><span class="line"><span class="comment">     *  First try to map dyld in directly.  This should work most of</span></span><br><span class="line"><span class="comment">     *  the time since there shouldn&#x27;t normally be something already</span></span><br><span class="line"><span class="comment">     *  mapped to its address.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 解析dyld</span></span><br><span class="line">    ret = <span class="built_in">parse_machfile</span>(vp, map, thread, &amp;header, file_offset, macho_size, depth, &amp;myresult);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     *  If it turned out something was in the way, then we&#x27;ll take</span></span><br><span class="line"><span class="comment">     *  take this longer path to map dyld into a temporary map and</span></span><br><span class="line"><span class="comment">     *  copy it into destination map at a different address.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//如果加载成功设置会返回entry_point</span></span><br><span class="line">    <span class="keyword">if</span> (ret == LOAD_SUCCESS) &#123;</span><br><span class="line">        result-&gt;dynlinker = TRUE;</span><br><span class="line">        result-&gt;entry_point = myresult.entry_point;</span><br><span class="line">        (<span class="type">void</span>)<span class="built_in">ubc_map</span>(vp, PROT_READ | PROT_EXEC);</span><br><span class="line">    &#125;</span><br><span class="line">out:</span><br><span class="line">    <span class="built_in">vnode_put</span>(vp);</span><br><span class="line">    <span class="keyword">return</span> (ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>load_dylinker函数主要负责加载dyld,以及调用parse_machfile函数对dyld解析。这时候header-&gt;filetype &#x3D; MH_DYLINKER 并且 depth &#x3D; 2.</p>
<figure class="highlight gml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (header-&gt;filetype) &#123;</span><br><span class="line"><span class="keyword">case</span> MH_OBJECT:</span><br><span class="line"><span class="keyword">case</span> MH_EXECUTE:</span><br><span class="line"><span class="keyword">case</span> MH_PRELOAD:</span><br><span class="line">    <span class="comment">//depth=2 时候这里走不通</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">depth</span> != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> (LOAD_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> MH_FVMLIB:</span><br><span class="line"><span class="keyword">case</span> MH_DYLIB:</span><br><span class="line">    <span class="comment">//depth=2 时候这里会走通</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">depth</span> == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> (LOAD_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> MH_DYLINKER:</span><br><span class="line">    <span class="comment">//depth=2 时候这里会走通</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">depth</span> != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> (LOAD_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">return</span> (LOAD_FAILURE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面的流程会先执行LC_SEGMENT_64，LC_SEGMENT将某些可执行的代码映射到指定的内存区域。然后再执行LC_THREAD，LC_UNIXTHREAD，LC_CODE_SIGNATURE。这时候dyld就被加载进来了，在LC_UNIXTHREAD中会设置dyld的entry point。</p>
<p>我们来看下LC_UNIXTHREAD</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> LC_UNIXTHREAD:</span><br><span class="line">    <span class="keyword">if</span> (pass != <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    ret = <span class="built_in">load_unixthread</span>(</span><br><span class="line">                (<span class="keyword">struct</span> thread_command *) lcp,</span><br><span class="line">                thread,</span><br><span class="line">                result);</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span></span></span><br><span class="line"><span class="function"><span class="type">load_return_t</span></span></span><br><span class="line"><span class="function"><span class="title">load_thread</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">struct</span> thread_command	*tcp,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="type">thread_t</span>			thread,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="type">load_result_t</span>		*result</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line">	task = <span class="built_in">get_threadtask</span>(thread);</span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line"></span><br><span class="line">	lret = <span class="built_in">load_threadstate</span>(thread,</span><br><span class="line">		       (<span class="type">unsigned</span> <span class="type">long</span> *)(((<span class="type">vm_offset_t</span>)tcp) + </span><br><span class="line">		       		<span class="built_in">sizeof</span>(<span class="keyword">struct</span> thread_command)),</span><br><span class="line">		       tcp-&gt;cmdsize - <span class="built_in">sizeof</span>(<span class="keyword">struct</span> thread_command));</span><br><span class="line">	<span class="keyword">if</span> (lret != LOAD_SUCCESS)</span><br><span class="line">		<span class="keyword">return</span> (lret);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (result-&gt;thread_count == <span class="number">0</span>) &#123;</span><br><span class="line">		lret = <span class="built_in">load_threadstack</span>(thread,</span><br><span class="line">				(<span class="type">unsigned</span> <span class="type">long</span> *)(((<span class="type">vm_offset_t</span>)tcp) + </span><br><span class="line">					<span class="built_in">sizeof</span>(<span class="keyword">struct</span> thread_command)),</span><br><span class="line">				tcp-&gt;cmdsize - <span class="built_in">sizeof</span>(<span class="keyword">struct</span> thread_command),</span><br><span class="line">				&amp;result-&gt;user_stack,</span><br><span class="line">				&amp;customstack);</span><br><span class="line">		<span class="keyword">if</span> (customstack)</span><br><span class="line">				result-&gt;customstack = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">				result-&gt;customstack = <span class="number">0</span>;</span><br><span class="line">			</span><br><span class="line">		<span class="keyword">if</span> (lret != LOAD_SUCCESS)</span><br><span class="line">			<span class="keyword">return</span>(lret);</span><br><span class="line"></span><br><span class="line">		lret = <span class="built_in">load_threadentry</span>(thread,</span><br><span class="line">				(<span class="type">unsigned</span> <span class="type">long</span> *)(((<span class="type">vm_offset_t</span>)tcp) + </span><br><span class="line">					<span class="built_in">sizeof</span>(<span class="keyword">struct</span> thread_command)),</span><br><span class="line">				tcp-&gt;cmdsize - <span class="built_in">sizeof</span>(<span class="keyword">struct</span> thread_command),</span><br><span class="line">				&amp;result-&gt;entry_point);</span><br><span class="line">		<span class="keyword">if</span> (lret != LOAD_SUCCESS)</span><br><span class="line">			<span class="keyword">return</span>(lret);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">thread_resume</span>(thread);</span><br><span class="line">		</span><br><span class="line">	result-&gt;thread_count++;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span>(LOAD_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里最关键的部分是<strong><strong>load_threadentry</strong></strong></p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span></span></span><br><span class="line"><span class="function"><span class="type">load_return_t</span></span></span><br><span class="line"><span class="function"><span class="title">load_threadentry</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="type">thread_t</span>	thread,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="type">unsigned</span> <span class="type">long</span>	*ts,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="type">unsigned</span> <span class="type">long</span>	total_size,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="type">mach_vm_offset_t</span>	*entry_point</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 *	Set the thread state.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	*entry_point = MACH_VM_MIN_ADDRESS;</span><br><span class="line">	<span class="keyword">while</span> (total_size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		flavor = *ts++;</span><br><span class="line">		size = *ts++;</span><br><span class="line">		entry_size = (size+<span class="number">2</span>)*<span class="built_in">sizeof</span>(<span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line">		<span class="keyword">if</span> (entry_size &gt; total_size)</span><br><span class="line">			<span class="keyword">return</span>(LOAD_BADMACHO);</span><br><span class="line">		total_size -= entry_size;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Third argument is a kernel space pointer; it gets cast</span></span><br><span class="line"><span class="comment">		 * to the appropriate type in thread_entrypoint() based on</span></span><br><span class="line"><span class="comment">		 * the value of flavor.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		ret = <span class="built_in">thread_entrypoint</span>(thread, flavor, (<span class="type">thread_state_t</span>)ts, size, entry_point);</span><br><span class="line">		<span class="keyword">if</span> (ret != KERN_SUCCESS) &#123;</span><br><span class="line">			<span class="keyword">return</span>(LOAD_FAILURE);</span><br><span class="line">		&#125;</span><br><span class="line">		ts += size;	<span class="comment">/* ts is a (unsigned long *) */</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>(LOAD_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">kern_return_t</span></span></span><br><span class="line"><span class="function"><span class="title">thread_entrypoint</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    __unused <span class="type">thread_t</span>   thread,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span>                 flavor,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">thread_state_t</span>      tstate,</span></span></span><br><span class="line"><span class="params"><span class="function">    __unused <span class="type">unsigned</span> <span class="type">int</span>        count,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">mach_vm_offset_t</span>    *entry_point</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Set a default.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (*entry_point == <span class="number">0</span>)</span><br><span class="line">		*entry_point = VM_MIN_ADDRESS;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (flavor) &#123;</span><br><span class="line">	<span class="keyword">case</span> x86_THREAD_STATE32:</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">x86_thread_state32_t</span> *state25;</span><br><span class="line"></span><br><span class="line">			state25 = (<span class="type">i386_thread_state_t</span> *) tstate;</span><br><span class="line">			*entry_point = state25-&gt;eip ? state25-&gt;eip: VM_MIN_ADDRESS;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> x86_THREAD_STATE64:</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">x86_thread_state64_t</span> *state25;</span><br><span class="line"></span><br><span class="line">			state25 = (<span class="type">x86_thread_state64_t</span> *) tstate;</span><br><span class="line">			*entry_point = state25-&gt;rip ? state25-&gt;rip: VM_MIN_ADDRESS64;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> (KERN_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>thread_entrypoint 中会对entry_point进行设置。那么state25-&gt;rip又是什么呢？它就是dyld的入口地址****_dyld_start<strong><strong>。也就是说在dyld加载到内存结束后，会将入口指向</strong></strong>_dyld_start****。<br>如果想对dyld有比较直观的了解，其实在deviceSupport&#x2F;xx.x.x&#x2F;Symbols&#x2F;usr&#x2F;lib&#x2F;dyld.到此为止就是从launchd开始到dyld加载结束到指定dyld的入口地址的全部过程。下篇博客将会对dyld进行详细的介绍。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://justinyan.me/post/4057">macOS 内核之一个 App 如何运行起来</a></li>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/39863112/what-is-required-for-a-mach-o-executable-to-load">What is required for a Mach-O executable to load?</a></li>
<li><a target="_blank" rel="noopener" href="https://zhangbuhuai.com/post/dyld-bootstrap.html">分析 dyld 的启动过程</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.cnbluebox.com/blog/2017/06/30/dyld2/">Dyld系列之一：_dyld_start之前</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/apple/darwin-xnu">darwin-xnu</a></li>
<li><a target="_blank" rel="noopener" href="http://darlinghq.org/developer-zone/mach-o-dynamic-loader/">Darling</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/I60p2M-IHDmeUanDUkFdVw">XNU、dyld源码分析Mach-O和动态库的加载过程(上)</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/fdDPyjRkVf9AdWiikBagHg">XNU、dyld 源码分析，Mach-O 和动态库的加载过程 (下)</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5a0c5c3451882554bd509a46">趣探 Mach-O：加载过程</a></li>
</ul>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Objective-C-%E7%9B%B8%E5%85%B3/">Objective C 相关</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/Objective-C-相关/">Objective C 相关</a>
  </div>

</div>



<div class="comments-count">
	
	  	<span></span>
		<a href="/2020/01/09/iOS-Runtime源码解析之App启动/#comments" class="ds-thread-count comments-count-link" data-thread-key="2020/01/09/iOS-Runtime源码解析之App启动/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2020/01/08/iOS-Runtime源码解析之Mach-O-结构/" title="iOS Runtime源码解析Mach O 结构" itemprop="url">iOS Runtime源码解析Mach O 结构</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Edgar" target="_blank" itemprop="author">Edgar</a>
		
  <p class="article-time">
    <time datetime="2020-01-08T13:51:12.000Z" itemprop="datePublished"> Published 2020-01-08</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>我们编译出的.app 文件其实也是Mach O的一种，我们在对Runtime进行分析之前总是绕不开Mach O 和 dyld 这两大块内容，所以在这个系列开始之前对带大家了解下Mach O 和 dyld。</p>
<p>下图是Mach O文件的组成，主要分成三大部分,我们接下来以otool命令行工具来输出这些数据的内容：</p>
<p><strong><strong>Header</strong></strong>: 头部区域；<br><strong><strong>LoadCommands</strong></strong>: 加载命令，由多个Segments command组成；<br><strong><strong>Data</strong></strong>:Segments的具体数据；</p>
<p>我们一一看下这些部分的组成数据结构以及功能：</p>
<h5 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">mach_header_64</span> &#123;</span><br><span class="line">	<span class="type">uint32_t</span>	magic;		<span class="comment">/* mach magic number identifier */</span></span><br><span class="line">	<span class="type">cpu_type_t</span>	cputype;	<span class="comment">/* cpu specifier */</span></span><br><span class="line">	<span class="type">cpu_subtype_t</span>	cpusubtype;	<span class="comment">/* machine specifier */</span></span><br><span class="line">	<span class="type">uint32_t</span>	filetype;	<span class="comment">/* type of file */</span></span><br><span class="line">	<span class="type">uint32_t</span>	ncmds;		<span class="comment">/* number of load commands */</span></span><br><span class="line">	<span class="type">uint32_t</span>	sizeofcmds;	<span class="comment">/* the size of all the load commands */</span></span><br><span class="line">	<span class="type">uint32_t</span>	flags;		<span class="comment">/* flags */</span></span><br><span class="line">	<span class="type">uint32_t</span>	reserved;	<span class="comment">/* reserved */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>magic: 从这个字段上可以看出当前镜像的平台是64位还是32位的：<br>由于这里只研究64位的，所以这个值为<strong><strong>MH_MAGIC_64</strong></strong></li>
<li>cputype: cpu类型          （具体可查看<strong><strong>mach&#x2F;machine.h</strong></strong>）</li>
<li>cpusubtype: cpu子类型     （具体可查看<strong><strong>mach&#x2F;machine.h</strong></strong>）</li>
<li>filetype : 文件类型，是可执行文件还是动态链接文件</li>
<li>ncmds : load command 的数量</li>
<li>sizeofcmds : load command 占用的空间大小</li>
<li>flags : dyld 加载的标志</li>
</ul>
<p>下面是otool工具打印出的某个应用的Header部分：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">$ otool -hV IDLFundation</span><br><span class="line">Mach <span class="keyword">header</span></span><br><span class="line">      magic cputype cpusubtype  caps    filetype ncmds sizeofcmds      flags</span><br><span class="line">MH_MAGIC_64  X86_64        <span class="keyword">ALL</span>  <span class="number">0x00</span>     <span class="keyword">EXECUTE</span>    <span class="number">85</span>       <span class="number">8400</span>   NOUNDEFS DYLDLINK TWOLEVEL WEAK_DEFINES BINDS_TO_WEAK PIE</span><br></pre></td></tr></table></figure>

<p>这里简单提下几种常见的Mach-O类型，也就是上面提到的filetype：</p>
<ul>
<li><p><strong><strong>MH_EXECUTE</strong></strong><br>可单独执行的可执行文件，这种文件一般有main方法作为入口。</p>
</li>
<li><p><strong><strong>MH_DYLINKER</strong></strong><br>动态链接器，用于加载动态库 在iOS 中就是&#x2F;usr&#x2F;lib&#x2F;dyld，&#x2F;usr&#x2F;lib&#x2F;dyld仅会处理MH_BUNDLE, MH_DYLIB，MH_EXECUTE类型文件。</p>
</li>
<li><p><strong><strong>MH_OBJECT</strong></strong><br>.m，.c等文件编译出来的目标文件，文件后缀是.o。Static Library类型产出是MH_OBJECT类型文件的archieve。</p>
</li>
<li><p><strong><strong>MH_FVMLIB</strong></strong> <strong><strong>MH_CORE</strong></strong> <strong><strong>MH_PRELOAD</strong></strong> <strong><strong>MH_DYLIB</strong></strong><br>动态库文件，包括.dylib文件，动态framework；对应Dynamic Library类型产出。</p>
</li>
<li><p><strong><strong>MH_BUNDLE</strong></strong><br>独立的二进制文件，不支持在项目中添加Link Binary使用。可以在Copy Bundle Resources中作为资源添加。 通过NSBundle load的方式加载；对应Bundle类型产出。典型的例子就是&#x2F;System&#x2F;Library&#x2F;AccessibilityBundles目录的.axbundle后缀的文件。</p>
</li>
<li><p><strong><strong>MH_DSYM</strong></strong><br>存储二进制文件符号信息的文件，用于Debug分析；</p>
</li>
</ul>
<h5 id="Load-Commands"><a href="#Load-Commands" class="headerlink" title="Load Commands"></a>Load Commands</h5><p>load commands 紧随着mach_header，它的总大小以及命令数都存储在mach_header中。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">load_command</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> cmd;       <span class="comment">/* type of load command */</span></span><br><span class="line">    <span class="type">uint32_t</span> cmdsize;   <span class="comment">/* total size of command in bytes */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>load_command结构比较简单就两个字段cmd和cmdsize，cmd存放的是命令的类型，每个类型有一个专门的结构体。</p>
<p>这些加载命令在Mach-O文件加载解析时，用于指导如何加载对应的二进制数据段，下面列出了一些加载命令类型的常量，更多的加载命令类型可以查看<strong><strong>loader.h</strong></strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>	LC_SEGMENT	     0x1	<span class="comment">/* segment of this file to be mapped */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	LC_SEGMENT_64	0x19	<span class="comment">/* 64-bit segment of this file to be mapped */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	LC_SYMTAB	0x2	<span class="comment">/* link-edit stab symbol table info */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	LC_SYMSEG	0x3	<span class="comment">/* link-edit gdb symbol table info (obsolete) */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	LC_THREAD	0x4	<span class="comment">/* thread */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	LC_UNIXTHREAD	0x5	<span class="comment">/* unix thread (includes a stack) */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	LC_LOADFVMLIB	0x6	<span class="comment">/* load a specified fixed VM shared library */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	LC_IDFVMLIB	0x7	<span class="comment">/* fixed VM shared library identification */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	LC_IDENT	0x8	<span class="comment">/* object identification info (obsolete) */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LC_FVMFILE	0x9	<span class="comment">/* fixed VM file inclusion (internal use) */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LC_PREPAGE      0xa     <span class="comment">/* prepage command (internal use) */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	LC_DYSYMTAB	0xb	<span class="comment">/* dynamic link-edit symbol table info */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	LC_LOAD_DYLIB	0xc	<span class="comment">/* load a dynamically linked shared library */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	LC_ID_DYLIB	0xd	<span class="comment">/* dynamically linked shared lib ident */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LC_LOAD_DYLINKER 0xe	<span class="comment">/* load a dynamic linker */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LC_ID_DYLINKER	0xf	<span class="comment">/* dynamic linker identification */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	LC_PREBOUND_DYLIB 0x10	<span class="comment">/* modules prebound for a dynamically */</span></span></span><br><span class="line">				<span class="comment">/*  linked shared library */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	LC_ROUTINES	0x11	<span class="comment">/* image routines */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	LC_SUB_FRAMEWORK 0x12	<span class="comment">/* sub framework */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	LC_SUB_UMBRELLA 0x13	<span class="comment">/* sub umbrella */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	LC_SUB_CLIENT	0x14	<span class="comment">/* sub client */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	LC_SUB_LIBRARY  0x15	<span class="comment">/* sub library */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	LC_TWOLEVEL_HINTS 0x16	<span class="comment">/* two-level namespace lookup hints */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	LC_PREBIND_CKSUM  0x17	<span class="comment">/* prebind checksum */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	LC_LOAD_WEAK_DYLIB (0x18 | LC_REQ_DYLD)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	LC_ROUTINES_64	0x1a	<span class="comment">/* 64-bit image routines */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LC_UUID		0x1b	<span class="comment">/* the uuid */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LC_RPATH       (0x1c | LC_REQ_DYLD)    <span class="comment">/* runpath additions */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LC_CODE_SIGNATURE 0x1d	<span class="comment">/* local of code signature */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LC_SEGMENT_SPLIT_INFO 0x1e <span class="comment">/* local of info to split segments */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LC_REEXPORT_DYLIB (0x1f | LC_REQ_DYLD) <span class="comment">/* load and re-export dylib */</span></span></span><br></pre></td></tr></table></figure>

<p>下面是通过otool命令来输出的load commands：</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">otool -l IDLFundation</span></span><br></pre></td></tr></table></figure>

<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Load</span> command <span class="number">20</span></span><br><span class="line">          <span class="attribute">cmd</span> LC_LOAD_DYLIB</span><br><span class="line">      <span class="attribute">cmdsize</span> <span class="number">80</span></span><br><span class="line">         <span class="attribute">name</span> @rpath/FLAnimatedImage.framework/FLAnimatedImage (offset <span class="number">24</span>)</span><br><span class="line">   <span class="attribute">time</span> stamp <span class="number">2</span> Thu Jan  <span class="number">1</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">02</span> <span class="number">1970</span></span><br><span class="line">      <span class="attribute">current</span> version <span class="number">1</span>.<span class="number">0</span>.<span class="number">0</span></span><br><span class="line"><span class="attribute">compatibility</span> version <span class="number">1</span>.<span class="number">0</span>.<span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>这里比较重要的是加载segments的命令：</p>
<p>它用于表示当前文件的一部分将会被映射到64位任务的地址空间</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">segment_command_64</span> &#123; <span class="comment">/* for 64-bit architectures */</span></span><br><span class="line">	<span class="type">uint32_t</span>	cmd;		    <span class="comment">/* 对于64位系统来说这个值恒为 LC_SEGMENT_64 */</span></span><br><span class="line">	<span class="type">uint32_t</span>	cmdsize;	    <span class="comment">/* 用于表示这个命令的大小 */</span></span><br><span class="line">	<span class="type">char</span>		segname[<span class="number">16</span>];	<span class="comment">/* 该segment的名字 */</span></span><br><span class="line">	<span class="type">uint64_t</span>	vmaddr;		    <span class="comment">/* 这个segment的虚拟内存地址空间 */</span></span><br><span class="line">	<span class="type">uint64_t</span>	vmsize;		    <span class="comment">/* 这个segment的虚拟内存大小 */</span></span><br><span class="line">	<span class="type">uint64_t</span>	fileoff;	    <span class="comment">/* 这个segment位于这个文件的偏移 */</span></span><br><span class="line">	<span class="type">uint64_t</span>	filesize;	    <span class="comment">/* 文件的大小 */</span></span><br><span class="line">	<span class="type">vm_prot_t</span>	maxprot;	    <span class="comment">/* 最大虚拟内存保护 */</span></span><br><span class="line">	<span class="type">vm_prot_t</span>	initprot;	    <span class="comment">/* 初始的内存保护 */</span></span><br><span class="line">	<span class="type">uint32_t</span>	nsects;		    <span class="comment">/* segments的session数 */</span></span><br><span class="line">	<span class="type">uint32_t</span>	flags;		    <span class="comment">/* flags */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>通过这个命令会将该段对应的文件从offset处加载 file size大小到虚拟内存 vmaddr处。</p>
<h5 id="Segments-amp-Session"><a href="#Segments-amp-Session" class="headerlink" title="Segments &amp; Session"></a>Segments &amp; Session</h5><p>Mach O文件中有一系列的Segment，每个segment又是由一系列的session构成。我们看下Mach O文件中都有哪些Segment:</p>
<ul>
<li><strong><strong>__TEXT</strong></strong> :代码段&#x2F;只读数据段</li>
<li><strong><strong>__DATA</strong></strong> :数据段</li>
<li><strong><strong>__PAGEZERO</strong></strong>: 空指针陷阱段，用于捕获对NULL指针的引用</li>
<li><strong><strong>__LINKEDIT</strong></strong>: 动态链接库使用的原始数据，比如符号，字符串，重定位表条目等等， 该段可读写。</li>
<li><strong><strong>__OBJC</strong></strong>: 包括会被Runtime使用到的一些数据</li>
</ul>
<p>可以用如下命令打印出各个段的数据</p>
<figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line">otool -v -s <span class="variable">__DATA</span> <span class="variable">__objc_selrefs</span> IDLFundation</span><br></pre></td></tr></table></figure>

<p>下面是****__TEXT<strong><strong>以及</strong></strong>__DATA****segment下的重要section：</p>
<p><strong><strong>__TEXT 部分</strong></strong></p>
<figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line"><span class="variable">__text</span>	程序代码</span><br><span class="line"><span class="variable">__stubs</span>	用于动态链接的存根</span><br><span class="line"><span class="variable">__stub_helper</span>	用于动态链接的存根</span><br><span class="line"><span class="variable">__const</span>	程序中const关键字修饰的常量变量</span><br><span class="line"><span class="variable">__objc_methname</span>	objc方法名</span><br><span class="line"><span class="variable">__cstring</span>	程序中硬编码的ANSI的字符串</span><br><span class="line"><span class="variable">__objc_classname</span>	objc类名</span><br><span class="line"><span class="variable">__objc_methtype</span>	objc方法类型</span><br><span class="line"><span class="variable">__gcc_except_tab</span>	异常处理相关</span><br><span class="line"><span class="variable">__ustring</span>	unicode字符串</span><br><span class="line"><span class="variable">__unwind_info</span>	异常处理</span><br><span class="line"><span class="variable">__eh_frame</span>	异常处理</span><br></pre></td></tr></table></figure>

<p><strong><strong>__DATA 部分</strong></strong></p>
<figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line"><span class="variable">__nl_symbol_ptr</span>	动态符号链接相关,指针数组</span><br><span class="line"><span class="variable">__got</span>	全局偏移表, Global Offset Table</span><br><span class="line"><span class="variable">__la_symbol_ptr</span>	动态符号链接相关，也是指针数组，通过dyld_stub_binder辅助链接</span><br><span class="line"><span class="variable">__mod_init_func</span>	初始化的全局函数地址，会在main之前被调用</span><br><span class="line"><span class="variable">__const</span>	const修饰的常量</span><br><span class="line"><span class="variable">__cstring</span>	程序中硬编码的ANSI的字符串</span><br><span class="line"><span class="variable">__cfstring</span>	CF用到的字符串</span><br><span class="line"><span class="variable">__objc_classlist</span>	objc类列表</span><br><span class="line"><span class="variable">__objc_nlclslist</span>	objcload方法列表</span><br><span class="line"><span class="variable">__objc_catlist</span>	objc category列表</span><br><span class="line"><span class="variable">__objc_protolist</span>	objc protocol列表</span><br><span class="line"><span class="variable">__objc_imageinfo</span>	镜像信息</span><br><span class="line"><span class="variable">__objc_const</span>	objc的常量</span><br><span class="line"><span class="variable">__objc_selrefs</span>	objc引用的SEL列表</span><br><span class="line"><span class="variable">__objc_protorefs</span>	objc引用的protocol列表</span><br><span class="line"><span class="variable">__objc_classrefs</span>	objc引用的class列表</span><br><span class="line"><span class="variable">__objc_superrefs</span>	objc父类的引用列表</span><br><span class="line"><span class="variable">__objc_ivar</span>	objcivar信息</span><br><span class="line"><span class="variable">__objc_data</span>	class信息</span><br><span class="line"><span class="variable">__bss</span>	未初始化的静态变量区</span><br><span class="line"><span class="variable">__data</span>	初始化的可变变量</span><br></pre></td></tr></table></figure>

<p>关于Mach O结构部分先介绍到这，在博客的末尾简单列下：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">-f <span class="built_in">print</span> the fat headers</span><br><span class="line">-a <span class="built_in">print</span> the archive header</span><br><span class="line">-h <span class="built_in">print</span> the mach header</span><br><span class="line">-l <span class="built_in">print</span> the load commands</span><br><span class="line">-L <span class="built_in">print</span> shared libraries used</span><br><span class="line">-D <span class="built_in">print</span> shared library id name</span><br><span class="line">-t <span class="built_in">print</span> the text section (disassemble with -v)</span><br><span class="line">-x <span class="built_in">print</span> all text sections (disassemble with -v)</span><br><span class="line">-p &lt;routine name&gt;  start dissassemble <span class="keyword">from</span> routine name</span><br><span class="line">-s &lt;segname&gt; &lt;sectname&gt; <span class="built_in">print</span> contents of section</span><br><span class="line">-d <span class="built_in">print</span> the data section</span><br><span class="line">-o <span class="built_in">print</span> the Objective-C segment</span><br><span class="line">-r <span class="built_in">print</span> the relocation entries</span><br><span class="line">-S <span class="built_in">print</span> the table of contents of a library (obsolete)</span><br><span class="line">-T <span class="built_in">print</span> the table of contents of a dynamic shared library (obsolete)</span><br><span class="line">-M <span class="built_in">print</span> the module table of a dynamic shared library (obsolete)</span><br><span class="line">-R <span class="built_in">print</span> the reference table of a dynamic shared library (obsolete)</span><br><span class="line">-I <span class="built_in">print</span> the indirect symbol table</span><br><span class="line">-H <span class="built_in">print</span> the two-level hints table (obsolete)</span><br><span class="line">-G <span class="built_in">print</span> the data <span class="keyword">in</span> code table</span><br><span class="line">-v <span class="built_in">print</span> verbosely (symbolically) when possible</span><br><span class="line">-V <span class="built_in">print</span> disassembled operands symbolically</span><br><span class="line">-c <span class="built_in">print</span> argument strings of a core file</span><br><span class="line">-X <span class="built_in">print</span> <span class="literal">no</span> leading addresses <span class="keyword">or</span> headers</span><br><span class="line">-m don<span class="string">&#x27;t use archive(member) syntax</span></span><br><span class="line"><span class="string">-B force Thumb disassembly (ARM objects only)</span></span><br><span class="line"><span class="string">-q use llvm&#x27;</span>s disassembler (the default)</span><br><span class="line">-Q use otool(1)<span class="string">&#x27;s disassembler</span></span><br><span class="line"><span class="string">-mcpu=arg use `arg&#x27;</span> as the cpu <span class="keyword">for</span> disassembly</span><br><span class="line">-j <span class="built_in">print</span> opcode bytes</span><br><span class="line">-P <span class="built_in">print</span> the <span class="built_in">info</span> plist section as strings</span><br><span class="line">-C <span class="built_in">print</span> linker optimization hints</span><br><span class="line">--version <span class="built_in">print</span> the version of /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/otool</span><br></pre></td></tr></table></figure>

<p>大家可以通过任何途径获取到你想研究应用到ipa包，然后把后缀名改为zip，解压缩得到Payload文件夹，里面就是你的APP，打开终端，直接cd到你的xxxx.app目录下。具体做法，输入cd，然后把xxxx.app直接拖到终端里打个回车。然后就可以通过otool命令来进行研究它了。</p>
<p>还有一个otool的扩展版本<a target="_blank" rel="noopener" href="http://www.newosxbook.com/tools/jtool.html">jtool</a>大家有兴趣可以看下</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Objective-C-%E7%9B%B8%E5%85%B3/">Objective C 相关</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/Objective-C-相关/">Objective C 相关</a>
  </div>

</div>



<div class="comments-count">
	
	  	<span></span>
		<a href="/2020/01/08/iOS-Runtime源码解析之Mach-O-结构/#comments" class="ds-thread-count comments-count-link" data-thread-key="2020/01/08/iOS-Runtime源码解析之Mach-O-结构/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2020/01/06/iOS-Category-源码解析/" title="iOS Category 源码解析" itemprop="url">iOS Category 源码解析</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Edgar" target="_blank" itemprop="author">Edgar</a>
		
  <p class="article-time">
    <time datetime="2020-01-06T15:21:05.000Z" itemprop="datePublished"> Published 2020-01-06</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>在之前的博客《iOS 分类扩展与协议总结》中介绍了分类的用法以及性质，该博客将会从分类的源码对分类进一步分析。</p>
<p>首先我们先看下分类的数据结构：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">category_t</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;                           <span class="comment">//类的名字</span></span><br><span class="line">    <span class="type">classref_t</span> cls;                             <span class="comment">//类</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">method_list_t</span> *instanceMethods;      <span class="comment">//catogies 中所有给类添加的实例方法列表</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">method_list_t</span> *classMethods;         <span class="comment">//catogies 中所有给类添加的类方法列表</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">protocol_list_t</span> *protocols;          <span class="comment">//catogies 中所有给类添加的协议列表</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">property_list_t</span> *instanceProperties; <span class="comment">//catogies 中所有给类添加的属性</span></span><br><span class="line">    <span class="comment">// Fields below this point are not always present on disk.</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">property_list_t</span> *_classProperties;   <span class="comment">//catogies 中所有给类添加的类属性</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">method_list_t</span> *<span class="title">methodsForMeta</span><span class="params">(<span class="type">bool</span> isMeta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isMeta) <span class="keyword">return</span> classMethods;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> instanceMethods;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">property_list_t</span> *<span class="title">propertiesForMeta</span><span class="params">(<span class="type">bool</span> isMeta, <span class="keyword">struct</span> header_info *hi)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>从上述对象中可以看出通过category可以添加实例方法，类方法，协议，属性，但是不能为对象添加实例变量。因为category是在运行时添加到类中的，这时候类的内存布局已经确定，如果添加实例变量就会破坏类的内部布局。</p>
<p>接下来我们就从runtime最开始介绍分类是如何添加到类中的。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void <span class="constructor">_objc_init(<span class="params">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    static <span class="built_in">bool</span> initialized = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (initialized) return;</span><br><span class="line">    initialized = <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// fixme defer initialization until an objc-using image is found?</span></span><br><span class="line">    environ<span class="constructor">_init()</span>;</span><br><span class="line">    tls<span class="constructor">_init()</span>;</span><br><span class="line">    static<span class="constructor">_init()</span>;</span><br><span class="line">    lock<span class="constructor">_init()</span>;</span><br><span class="line">    <span class="keyword">exception</span><span class="constructor">_init()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向dyld注册了回调函数,当image map到内存中,当初始化完成image时和卸载image的时候都会回调注册者</span></span><br><span class="line">    <span class="constructor">_dyld_objc_notify_register(&amp;<span class="params">map_images</span>, <span class="params">load_images</span>, <span class="params">unmap_image</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在_objc_init方法中会向dyld注册三个十分关键的回调函数：map_images，load_images，unmap_image</p>
<p>在镜像被加载后会回调map_images，分类的添加就是在这个阶段完成的，这以后会调用<strong><strong>map_images_nolock</strong></strong>方法来处理被dyld映射进来的镜像。map_images_nolock方法很长，但是和我们今天代码相关的只有</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="constructor">_read_images(<span class="params">hList</span>, <span class="params">hCount</span>, <span class="params">totalClasses</span>, <span class="params">unoptimizedTotalClasses</span>)</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void <span class="constructor">_read_images(<span class="params">header_info</span> <span class="operator">**</span><span class="params">hList</span>, <span class="params">uint32_t</span> <span class="params">hCount</span>, <span class="params">int</span> <span class="params">totalClasses</span>, <span class="params">int</span> <span class="params">unoptimizedTotalClasses</span>)</span> &#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="comment">// Discover categories. </span></span><br><span class="line">    <span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">        category_t **catlist = <span class="constructor">_getObjc2CategoryList(<span class="params">hi</span>, &amp;<span class="params">count</span>)</span>;</span><br><span class="line">        <span class="comment">//查看是否包含类属性</span></span><br><span class="line">        <span class="built_in">bool</span> hasClassProperties = hi-&gt;info<span class="literal">()</span>-&gt;has<span class="constructor">CategoryClassProperties()</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            category_t *cat = catlist<span class="literal">[<span class="identifier">i</span>]</span>;</span><br><span class="line">            <span class="comment">//获取到所属的类</span></span><br><span class="line">            Class cls = remap<span class="constructor">Class(<span class="params">cat</span>-&gt;<span class="params">cls</span>)</span>;</span><br><span class="line">            <span class="comment">// ....</span></span><br><span class="line">            <span class="comment">// Process this category. </span></span><br><span class="line">            <span class="built_in">bool</span> classExists = NO;</span><br><span class="line">            <span class="comment">//如果有实例方法，协议或者实例属性</span></span><br><span class="line">            <span class="keyword">if</span> (cat-&gt;instanceMethods<span class="operator"> ||  </span>cat-&gt;protocols<span class="operator"> ||  </span>cat-&gt;instanceProperties) &#123;</span><br><span class="line">                add<span class="constructor">UnattachedCategoryForClass(<span class="params">cat</span>, <span class="params">cls</span>, <span class="params">hi</span>)</span>;</span><br><span class="line">                <span class="keyword">if</span> (cls-&gt;is<span class="constructor">Realized()</span>) &#123;</span><br><span class="line">                    <span class="comment">//将分类添到属性，方法，协议添加到对应的类中</span></span><br><span class="line">                    remethodize<span class="constructor">Class(<span class="params">cls</span>)</span>;</span><br><span class="line">                    classExists = YES;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//......</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果有类方法，协议或者类属性</span></span><br><span class="line">            <span class="keyword">if</span> (cat-&gt;classMethods<span class="operator">  ||  </span>cat-&gt;protocols<span class="operator">  ||  </span>(hasClassProperties<span class="operator"> &amp;&amp; </span>cat-&gt;_classProperties))  &#123;</span><br><span class="line">                add<span class="constructor">UnattachedCategoryForClass(<span class="params">cat</span>, <span class="params">cls</span>-&gt;ISA()</span>, hi);</span><br><span class="line">                <span class="keyword">if</span> (cls-&gt;<span class="constructor">ISA()</span>-&gt;is<span class="constructor">Realized()</span>) &#123;</span><br><span class="line">                    remethodize<span class="constructor">Class(<span class="params">cls</span>-&gt;ISA()</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//......</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ts.log(<span class="string">&quot;IMAGE TIMES: discover categories&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//.......</span></span><br><span class="line">    <span class="comment">// +load handled by prepare_load_methods()</span></span><br><span class="line">    <span class="keyword">if</span> (DebugNonFragileIvars) &#123;</span><br><span class="line">        realize<span class="constructor">AllClasses()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//.......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>_read_images 会从镜像中读取很多数据，这里只关注分类的部分。</p>
<p>首先通过****_getObjc2CategoryList****从_DATA_部分的__objc_catlist获取到当前镜像中全部的分类。__objc_catlist这个数据是哪里来的呢？其实是编译时候生成的。</p>
<p>那么编译阶段，编译器做了哪些事情呢？</p>
<ul>
<li>编译器生成了实例方法列表</li>
<li>编译器生成了category本身</li>
<li>编译器在DATA段下的objc_catlist section里保存了一个大小为1的category_t的数组</li>
</ul>
<p>objc_catlist section就是在加载镜像的时候被加载进来的。</p>
<p>我们继续，然后针对每个分类调用<strong><strong>addUnattachedCategoryForClass</strong></strong></p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">static void add<span class="constructor">UnattachedCategoryForClass(<span class="params">category_t</span> <span class="operator">*</span><span class="params">cat</span>, Class <span class="params">cls</span>, <span class="params">header_info</span> <span class="operator">*</span><span class="params">catHeader</span>)</span> &#123;</span><br><span class="line">    runtimeLock.<span class="keyword">assert</span><span class="constructor">Locked()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// DO NOT use cat-&gt;cls! cls may be cat-&gt;cls-&gt;isa instead</span></span><br><span class="line">    NXMapTable *cats = unattached<span class="constructor">Categories()</span>;</span><br><span class="line">    category_list *<span class="built_in">list</span>;</span><br><span class="line">    <span class="built_in">list</span> = (category_list *)<span class="constructor">NXMapGet(<span class="params">cats</span>, <span class="params">cls</span>)</span>;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">list</span>) &#123;</span><br><span class="line">        <span class="built_in">list</span> = (category_list *)</span><br><span class="line">            calloc(sizeof(*<span class="built_in">list</span>) + sizeof(<span class="built_in">list</span>-&gt;<span class="built_in">list</span><span class="literal">[<span class="number">0</span>]</span>), <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">list</span> = (category_list *)</span><br><span class="line">            realloc(<span class="built_in">list</span>, sizeof(*<span class="built_in">list</span>) + sizeof(<span class="built_in">list</span>-&gt;<span class="built_in">list</span><span class="literal">[<span class="number">0</span>]</span>)<span class="operator"> * </span>(<span class="built_in">list</span>-&gt;count + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">list</span>-&gt;<span class="built_in">list</span><span class="literal">[<span class="identifier">list</span>-&gt;<span class="identifier">count</span><span class="operator">++</span>]</span> = (locstamped_category_t)&#123;cat, catHeader&#125;;</span><br><span class="line">    <span class="constructor">NXMapInsert(<span class="params">cats</span>, <span class="params">cls</span>, <span class="params">list</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在分析addUnattachedCategoryForClass之前我们先看下unattachedCategories方法:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="title class_">NXMapTable</span> *<span class="title function_">unattachedCategories</span>(<span class="params"><span class="keyword">void</span></span>) &#123;</span><br><span class="line">    runtimeLock.<span class="title function_">assertLocked</span>();</span><br><span class="line">    <span class="keyword">static</span> <span class="title class_">NXMapTable</span> *category_map = nil;</span><br><span class="line">    <span class="keyword">if</span> (category_map) <span class="keyword">return</span> category_map;</span><br><span class="line">    <span class="comment">// fixme initial map size</span></span><br><span class="line">    category_map = <span class="title class_">NXCreateMapTable</span>(<span class="title class_">NXPtrValueMapPrototype</span>, <span class="number">16</span>);</span><br><span class="line">    <span class="keyword">return</span> category_map;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意category_map是静态的，首次的时候会通过NXCreateMapTable(NXPtrValueMapPrototype, 16)创建一个MapTable，后续会将同一个category_map返回。category_map存放的是什么呢？它存放的是 class &#x3D;&gt; categories 映射关系，这些分类是未添加到对应类上的所以叫做<strong><strong>unattachedCategories</strong></strong>。我们再回到addUnattachedCategoryForClass：</p>
<p>在调用unattachedCategories获取到全部类以及它的分类映射map之后，通过<strong><strong>NXMapGet(cats, cls)</strong></strong> 获取到的是cats map中以cls类作为key的，为添加到cls的分类列表，然后开辟一个list-&gt;count + 1 再加sizeof(*list)大小的空间，用于存放cat以及catHeader。然后再将这个列表添加到category_map中。所以经过addUnattachedCategoryForClass处理后。我们获得到的数据将会以如下的形式组织起来：</p>
<p><img src="/2020/01/06/iOS-Category-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/0001.png"></p>
<p>接下来我们来看下分类的添加过程：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">static void remethodize<span class="constructor">Class(Class <span class="params">cls</span>)</span> &#123;</span><br><span class="line">    category_list *cats;</span><br><span class="line">    <span class="built_in">bool</span> isMeta;</span><br><span class="line">    runtimeLock.<span class="keyword">assert</span><span class="constructor">Locked()</span>;</span><br><span class="line">    isMeta = cls-&gt;is<span class="constructor">MetaClass()</span>;</span><br><span class="line">    <span class="comment">// Re-methodizing: check for more categories</span></span><br><span class="line">    <span class="keyword">if</span> ((cats = unattached<span class="constructor">CategoriesForClass(<span class="params">cls</span>, <span class="params">false</span><span class="operator">/</span><span class="operator">*</span><span class="params">not</span> <span class="params">realizing</span><span class="operator">*</span><span class="operator">/</span>)</span>)) &#123;    </span><br><span class="line">        attach<span class="constructor">Categories(<span class="params">cls</span>, <span class="params">cats</span>, <span class="params">true</span> <span class="operator">/</span><span class="operator">*</span><span class="params">flush</span> <span class="params">caches</span><span class="operator">*</span><span class="operator">/</span>)</span>;        </span><br><span class="line">        free(cats);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>remethodizeClass方法中先通过unattachedCategoriesForClass获取到当前类的未添加的分类cats：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">static category_list<span class="operator"> *</span></span><br><span class="line"><span class="operator"></span>unattached<span class="constructor">CategoriesForClass(Class <span class="params">cls</span>, <span class="params">bool</span> <span class="params">realizing</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    runtimeLock.<span class="keyword">assert</span><span class="constructor">Locked()</span>;</span><br><span class="line">    return (category_list *)<span class="constructor">NXMapRemove(<span class="params">unattachedCategories</span>()</span>, cls);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意这里返回分类列表后会调用NXMapRemove从category_map中移除。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">static void </span><br><span class="line">attach<span class="constructor">Categories(Class <span class="params">cls</span>, <span class="params">category_list</span> <span class="operator">*</span><span class="params">cats</span>, <span class="params">bool</span> <span class="params">flush_caches</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!cats) return;</span><br><span class="line">    <span class="built_in">bool</span> isMeta = cls-&gt;is<span class="constructor">MetaClass()</span>;</span><br><span class="line">    <span class="comment">// 方法列表</span></span><br><span class="line">    method_list_t **mlists = (method_list_t **)malloc(cats-&gt;count<span class="operator"> * </span>sizeof(*mlists));</span><br><span class="line">    <span class="comment">// 属性列表</span></span><br><span class="line">    property_list_t **proplists = (property_list_t **)malloc(cats-&gt;count<span class="operator"> * </span>sizeof(*proplists));</span><br><span class="line">    <span class="comment">// 协议列表</span></span><br><span class="line">    protocol_list_t **protolists = (protocol_list_t **)malloc(cats-&gt;count<span class="operator"> * </span>sizeof(*protolists));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Count backwards through cats to get newest categories first</span></span><br><span class="line">    <span class="built_in">int</span> mcount = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">int</span> propcount = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">int</span> protocount = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">int</span> i = cats-&gt;count;</span><br><span class="line">    <span class="built_in">bool</span> fromBundle = NO;</span><br><span class="line">    <span class="comment">//i 表示分类列表序号</span></span><br><span class="line">    <span class="keyword">while</span> (i--) &#123; <span class="comment">//这里注意是逆序遍历，所以最后加载的最先添加到类中</span></span><br><span class="line">        auto&amp; entry = cats-&gt;<span class="built_in">list</span><span class="literal">[<span class="identifier">i</span>]</span>;</span><br><span class="line">        method_list_t *mlist = entry.cat-&gt;methods<span class="constructor">ForMeta(<span class="params">isMeta</span>)</span>;</span><br><span class="line">        <span class="keyword">if</span> (mlist) &#123;</span><br><span class="line">            mlists<span class="literal">[<span class="identifier">mcount</span><span class="operator">++</span>]</span> = mlist;</span><br><span class="line">            fromBundle <span class="pattern-match">|= entry.hi-&gt;is<span class="constructor">Bundle()</span>;</span></span><br><span class="line"><span class="pattern-match">        &#125;</span></span><br><span class="line"><span class="pattern-match">        property<span class="constructor">_list_t</span> <span class="operator">*</span>proplist = </span></span><br><span class="line"><span class="pattern-match">            entry.cat-&gt;properties<span class="constructor">ForMeta(<span class="params">isMeta</span>, <span class="params">entry</span>.<span class="params">hi</span>)</span>;</span></span><br><span class="line"><span class="pattern-match">        <span class="keyword">if</span> (proplist) &#123;</span></span><br><span class="line"><span class="pattern-match">            proplists[propcount<span class="operator">++</span>] = proplist;</span></span><br><span class="line"><span class="pattern-match">        &#125;</span></span><br><span class="line"><span class="pattern-match">        protocol<span class="constructor">_list_t</span> <span class="operator">*</span>protolist = entry.cat-&gt;protocols;</span></span><br><span class="line"><span class="pattern-match">        <span class="keyword">if</span> (protolist) &#123;</span></span><br><span class="line"><span class="pattern-match">            protolists[protocount<span class="operator">++</span>] = protolist;</span></span><br><span class="line"><span class="pattern-match">        &#125;</span></span><br><span class="line"><span class="pattern-match">    &#125;</span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match">    <span class="operator">/</span><span class="operator">/</span>将catories中的方法属性以及协议添加到rw中</span></span><br><span class="line"><span class="pattern-match">    auto rw = cls-&gt;data();</span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match">    prepare<span class="constructor">MethodLists(<span class="params">cls</span>, <span class="params">mlists</span>, <span class="params">mcount</span>, NO, <span class="params">fromBundle</span>)</span>;</span></span><br><span class="line"><span class="pattern-match">    rw-&gt;methods.attach<span class="constructor">Lists(<span class="params">mlists</span>, <span class="params">mcount</span>)</span>;</span></span><br><span class="line"><span class="pattern-match">    free(mlists);</span></span><br><span class="line"><span class="pattern-match">    <span class="keyword">if</span> (flush<span class="constructor">_caches</span>  <span class="operator">&amp;&amp;</span>  mcount &gt; 0) flush<span class="constructor">Caches(<span class="params">cls</span>)</span>;</span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match">    rw-&gt;properties.attach<span class="constructor">Lists(<span class="params">proplists</span>, <span class="params">propcount</span>)</span>;</span></span><br><span class="line"><span class="pattern-match">    free(proplists);</span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match">    rw-&gt;protocols.attach<span class="constructor">Lists(<span class="params">protolists</span>, <span class="params">protocount</span>)</span>;</span></span><br><span class="line"><span class="pattern-match">    free(protolists);</span></span><br><span class="line"><span class="pattern-match">&#125;</span></span><br></pre></td></tr></table></figure>

<p>分类的添加的逻辑位于attachCategories方法中。这里要特别注意理解数据结构的组织，为了帮助大家理解，我这里画了一张图：</p>
<p><img src="/2020/01/06/iOS-Category-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/0002.png"></p>
<p>mlists，proplists，protolists如上图所示，从横向看，mlists，proplists，protolists是当前类所有分类的方法列表，属性列表以及协议列表。从纵向看，分别是某个分类的方法列表，协议列表，以及属性列表。这里需要十分注意的是上面的遍历是逆序遍历，所以最后加载的分类最先添加到类中，也就是说后添加的分类的方法，协议，以及属性会覆盖先添加的同名的方法，协议，以及属性，这就导致查找某个方法的时候会逆着分类加载链寻找，一旦找到立刻停止。</p>
<p>紧接着将当前类的所有方法列表，属性列表和分类列表追加到类的可写区域中。这里我们再重点看下attachLists方法。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">void</span> attachLists(List* <span class="keyword">const</span> * addedLists, <span class="built_in">uint32</span>_t addedCount) &#123;</span><br><span class="line">    <span class="keyword">if</span> (addedCount == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (hasArray()) &#123;</span><br><span class="line">        <span class="comment">// many lists -&gt; many lists</span></span><br><span class="line">        <span class="comment">// 原有数组的元素个数</span></span><br><span class="line">        <span class="built_in">uint32</span>_t oldCount = <span class="built_in">array</span>()-&gt;count;</span><br><span class="line">        <span class="comment">// 待添加数组元素个数</span></span><br><span class="line">        <span class="built_in">uint32</span>_t newCount = oldCount + addedCount;</span><br><span class="line">        <span class="comment">// 为新数组开辟对应的空间</span></span><br><span class="line">        setArray((<span class="built_in">array</span>_t *)realloc(<span class="built_in">array</span>(), <span class="built_in">array</span>_t::byteSize(newCount)));</span><br><span class="line">        <span class="built_in">array</span>()-&gt;count = newCount;</span><br><span class="line">        <span class="comment">//原有的数据向后腾出addedCount大小的空间，给addedLists。</span></span><br><span class="line">        memmove(<span class="built_in">array</span>()-&gt;lists + addedCount<span class="comment">/*指向用于存储复制内容的目标数组的起始地址*/</span>, <span class="built_in">array</span>()-&gt;lists<span class="comment">/*指向要复制的数据源*/</span>, oldCount * sizeof(<span class="built_in">array</span>()-&gt;lists[<span class="number">0</span>]<span class="comment">/*要被复制的字节数*/</span>));</span><br><span class="line">        <span class="comment">//将addedLists添加到原有数据的前面。</span></span><br><span class="line">        memcpy(<span class="built_in">array</span>()-&gt;lists, addedLists, addedCount * sizeof(<span class="built_in">array</span>()-&gt;lists[<span class="number">0</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!list  &amp;&amp;  addedCount == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 0 lists -&gt; 1 list</span></span><br><span class="line">        list = addedLists[<span class="number">0</span>];</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 1 list -&gt; many lists</span></span><br><span class="line">        List* oldList = list;</span><br><span class="line">        <span class="built_in">uint32</span>_t oldCount = oldList ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">uint32</span>_t newCount = oldCount + addedCount;</span><br><span class="line">        setArray((<span class="built_in">array</span>_t *)malloc(<span class="built_in">array</span>_t::byteSize(newCount)));</span><br><span class="line">        <span class="built_in">array</span>()-&gt;count = newCount;</span><br><span class="line">        <span class="keyword">if</span> (oldList) <span class="built_in">array</span>()-&gt;lists[addedCount] = oldList;</span><br><span class="line">        memcpy(<span class="built_in">array</span>()-&gt;lists, addedLists, </span><br><span class="line">                addedCount * sizeof(<span class="built_in">array</span>()-&gt;lists[<span class="number">0</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>attachLists其实是将该类所有的分类对应的方法列表，属性列表，协议列表，添加到类的可读写区域中，attachLists方法会重新开辟一个内存空间，将原有的数据向后腾出空间，给分类对应的元素。这意味着什么？意味着分类的方法，协议，以及属性，会被添加到类原有的方法，协议，以及属性之前。</p>
<p>通过上面的源码解析不难理解下面的一些细节点：</p>
<ul>
<li><p>category的方法没有“完全替换掉”原来类已经有的方法，也就是说如果category和原来类都有methodA，那么category附加完成之后，类的方法列表里会有两个methodA。只不过category的方法被放到了新方法列表的前面，而原来类的方法被放到了新方法列表的后面，这也就是我们平常所说的category的方法会“覆盖”掉原来类的同名方法，这是因为运行时在查找方法的时候是顺着方法列表的顺序查找的，它只要一找到对应名字的方法，就会停止查找。</p>
</li>
<li><p>在编译路径中位于后面的分类会先添加到列表，所以最后编译的分类最终生效。</p>
</li>
</ul>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>



<div class="comments-count">
	
	  	<span></span>
		<a href="/2020/01/06/iOS-Category-源码解析/#comments" class="ds-thread-count comments-count-link" data-thread-key="2020/01/06/iOS-Category-源码解析/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2020/01/04/iOS-内存管理之对象创建，销毁，持有，弱引用源码剖析/" title="iOS 内存管理之对象创建，销毁，持有，弱引用源码剖析" itemprop="url">iOS 内存管理之对象创建，销毁，持有，弱引用源码剖析</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Edgar" target="_blank" itemprop="author">Edgar</a>
		
  <p class="article-time">
    <time datetime="2020-01-04T07:56:07.000Z" itemprop="datePublished"> Published 2020-01-04</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>iOS 这部分代码位于 <strong><strong>objc-runtime&#x2F;runtime&#x2F;NSObject.mm</strong></strong>:</p>
<h5 id="1-对象的创建-alloc-x2F-init："><a href="#1-对象的创建-alloc-x2F-init：" class="headerlink" title="1 对象的创建 alloc&#x2F;init："></a>1 对象的创建 alloc&#x2F;init：</h5><p><em><strong>调用栈</strong></em></p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line"><span class="comment">--- alloc </span></span><br><span class="line">    <span class="comment">--- _objc_rootAlloc</span></span><br><span class="line">        <span class="comment">--- callAlloc</span></span><br><span class="line">            <span class="comment">--- allocWithZone</span></span><br><span class="line">                <span class="comment">--- class_createInstance</span></span><br><span class="line">                    <span class="comment">--- _class_createInstanceFromZone</span></span><br><span class="line">                        <span class="comment">--- calloc</span></span><br><span class="line">                        <span class="comment">--- initIsa</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--- init</span></span><br><span class="line">    <span class="comment">--- _objc_rootInit</span></span><br></pre></td></tr></table></figure>


<p>我们在创建对象的时候会调用 alloc 方法为要创建的对象分配内存空间：</p>
<figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line"><span class="operator">+</span> (<span class="built_in">id</span>)<span class="keyword">alloc</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> _objc_rootAlloc(self);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在alloc中会调用_objc_rootAlloc</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">id</span><br><span class="line"><span class="constructor">_objc_rootAlloc(Class <span class="params">cls</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    return call<span class="constructor">Alloc(<span class="params">cls</span>, <span class="params">false</span><span class="operator">/</span><span class="operator">*</span><span class="params">checkNil</span><span class="operator">*</span><span class="operator">/</span>, <span class="params">true</span><span class="operator">/</span><span class="operator">*</span><span class="params">allocWithZone</span><span class="operator">*</span><span class="operator">/</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在_objc_rootAlloc中会调用callAlloc，它有两个参数第一个参数表示是否检查cls参数是否为空，第二个参数表示是否在zone中分配这个内存。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">static ALWAYS_INLINE id</span><br><span class="line">call<span class="constructor">Alloc(Class <span class="params">cls</span>, <span class="params">bool</span> <span class="params">checkNil</span><span class="operator">/</span><span class="operator">*</span><span class="params">false</span><span class="operator">*</span><span class="operator">/</span>, <span class="params">bool</span> <span class="params">allocWithZone</span>=<span class="params">false</span><span class="operator">/</span><span class="operator">*</span><span class="params">true</span><span class="operator">*</span><span class="operator">/</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (slowpath(checkNil<span class="operator"> &amp;&amp; </span>!cls)) return nil;</span><br><span class="line"></span><br><span class="line">#<span class="keyword">if</span> __OBJC2__</span><br><span class="line">    <span class="comment">//hasCustomAWZ( )方法是用来判断当前class是否有自定义的allocWithZone。</span></span><br><span class="line">    <span class="keyword">if</span> (fastpath(!cls-&gt;<span class="constructor">ISA()</span>-&gt;has<span class="constructor">CustomAWZ()</span>)) &#123;</span><br><span class="line">        <span class="comment">// 没有自定义的alloc/allocWithZone实现的时候</span></span><br><span class="line">        <span class="comment">// No alloc/allocWithZone implementation. Go straight to the allocator.</span></span><br><span class="line">        <span class="comment">// fixme store hasCustomAWZ in the non-meta class and </span></span><br><span class="line">        <span class="comment">// add it to canAllocFast&#x27;s summary</span></span><br><span class="line">        <span class="keyword">if</span> (fastpath(cls-&gt;can<span class="constructor">AllocFast()</span>)) &#123;</span><br><span class="line">            <span class="comment">// No ctors, raw isa, etc. Go straight to the metal.</span></span><br><span class="line">            <span class="built_in">bool</span> dtor = cls-&gt;has<span class="constructor">CxxDtor()</span>;</span><br><span class="line">            id obj = (id)calloc(<span class="number">1</span>, cls-&gt;bits.fast<span class="constructor">InstanceSize()</span>);</span><br><span class="line">            <span class="keyword">if</span> (slowpath(!obj)) return call<span class="constructor">BadAllocHandler(<span class="params">cls</span>)</span>;</span><br><span class="line">            obj-&gt;init<span class="constructor">InstanceIsa(<span class="params">cls</span>, <span class="params">dtor</span>)</span>;</span><br><span class="line">            return obj;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Has ctor or raw isa or something. Use the slower path.</span></span><br><span class="line">            id obj = <span class="keyword">class</span><span class="constructor">_createInstance(<span class="params">cls</span>, 0)</span>;</span><br><span class="line">            <span class="keyword">if</span> (slowpath(!obj)) return call<span class="constructor">BadAllocHandler(<span class="params">cls</span>)</span>;</span><br><span class="line">            return obj;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    <span class="comment">// No shortcuts available.</span></span><br><span class="line">    <span class="keyword">if</span> (allocWithZone) return <span class="literal">[<span class="identifier">cls</span> <span class="identifier">allocWithZone</span>:<span class="identifier">nil</span>]</span>;</span><br><span class="line">    return <span class="literal">[<span class="identifier">cls</span> <span class="identifier">alloc</span>]</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先看下hasCustomAWZ</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">bool</span> <span class="title">hasCustomAWZ</span>()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ! bits.hasDefaultAWZ();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">bool</span> <span class="title">hasDefaultAWZ</span>(<span class="params"> </span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> data()-&gt;flags &amp; RW_HAS_DEFAULT_AWZ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RW_HAS_DEFAULT_AWZ    (1&lt;&lt;16)</span></span><br></pre></td></tr></table></figure>

<p>它实际上是查看metaclass 中的对应标识位flags的RW_HAS_DEFAULT_AWZ来查看当前的class或者是superclass是否有默认的alloc&#x2F;allocWithZone:如果这个标志位被标记了那么hasCustomAWZ就为NO.</p>
<p>cls-&gt;canAllocFast() 这个一般情况下会返回false. 代码中有注解<strong><strong>No ctors, raw isa, etc</strong></strong>的情况下cls-&gt;canAllocFast() 返回YES.具体还不是很清楚这是什么意思。待弄明白后补上，这里记得返回false就好。</p>
<p>我们以最常见的：没有自定义alloc&#x2F;allocWithZone:的情况作为简化后的分析对象：<br>这时候代码可以简化为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> ALWAYS_INLINE id</span></span><br><span class="line"><span class="function"><span class="title">callAlloc</span><span class="params">(Class cls, <span class="type">bool</span> checkNil<span class="comment">/*false*/</span>, <span class="type">bool</span> allocWithZone=<span class="literal">false</span><span class="comment">/*true*/</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// No shortcuts available.</span></span><br><span class="line">    <span class="keyword">if</span> (allocWithZone) <span class="keyword">return</span> [cls allocWithZone:nil];</span><br><span class="line">    <span class="keyword">return</span> [cls alloc];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们继续往下看：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">+ (id)allocWithZone:(<span class="keyword">struct</span> _NSZone *)zone &#123;</span><br><span class="line">    return <span class="constructor">_objc_rootAllocWithZone(<span class="params">self</span>, (<span class="params">malloc_zone_t</span> <span class="operator">*</span>)</span>zone);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">id</span><br><span class="line"><span class="constructor">_objc_rootAllocWithZone(Class <span class="params">cls</span>, <span class="params">malloc_zone_t</span> <span class="operator">*</span><span class="params">zone</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    id obj;</span><br><span class="line"></span><br><span class="line">#<span class="keyword">if</span> __OBJC2__</span><br><span class="line">    <span class="comment">// allocWithZone under __OBJC2__ ignores the zone parameter</span></span><br><span class="line">    (void)zone;</span><br><span class="line">    obj = <span class="keyword">class</span><span class="constructor">_createInstance(<span class="params">cls</span>, 0)</span>;</span><br><span class="line">#<span class="keyword">else</span></span><br><span class="line">    <span class="keyword">if</span> (!zone) &#123;</span><br><span class="line">        obj = <span class="keyword">class</span><span class="constructor">_createInstance(<span class="params">cls</span>, 0)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        obj = <span class="keyword">class</span><span class="constructor">_createInstanceFromZone(<span class="params">cls</span>, 0, <span class="params">zone</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (slowpath(!obj)) obj = call<span class="constructor">BadAllocHandler(<span class="params">cls</span>)</span>;</span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们记住这里zone传进去的是nil，所以_objc_rootAllocWithZone代码简化后如下：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">id</span><br><span class="line"><span class="constructor">_objc_rootAllocWithZone(Class <span class="params">cls</span>, <span class="params">malloc_zone_t</span> <span class="operator">*</span><span class="params">zone</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    id obj;</span><br><span class="line"></span><br><span class="line">    (void)zone;</span><br><span class="line">    obj = <span class="keyword">class</span><span class="constructor">_createInstance(<span class="params">cls</span>, 0)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (slowpath(!obj)) obj = call<span class="constructor">BadAllocHandler(<span class="params">cls</span>)</span>;</span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">id </span><br><span class="line"><span class="keyword">class</span><span class="constructor">_createInstance(Class <span class="params">cls</span>, <span class="params">size_t</span> <span class="params">extraBytes</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    return <span class="constructor">_class_createInstanceFromZone(<span class="params">cls</span>, <span class="params">extraBytes</span>, <span class="params">nil</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> __attribute__((always_inline)) </span><br><span class="line">id</span><br><span class="line">_class_createInstanceFromZone(Class cls, <span class="type">size_t</span> extraBytes, <span class="type">void</span> *zone, </span><br><span class="line">                              <span class="type">bool</span> cxxConstruct = <span class="literal">true</span>, </span><br><span class="line">                              <span class="type">size_t</span> *outAllocatedSize = nil)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Read class&#x27;s info bits all at once for performance</span></span><br><span class="line">    <span class="comment">// 当前class或者superclass 是否有构造方法的实现</span></span><br><span class="line">    <span class="type">bool</span> hasCxxCtor = cls-&gt;<span class="built_in">hasCxxCtor</span>();</span><br><span class="line">    <span class="comment">// 判断当前class或者superclass 是否有析构方法的实现。</span></span><br><span class="line">    <span class="type">bool</span> hasCxxDtor = cls-&gt;<span class="built_in">hasCxxDtor</span>();</span><br><span class="line">    <span class="comment">// 获取对象的大小</span></span><br><span class="line">    <span class="type">size_t</span> size = cls-&gt;<span class="built_in">instanceSize</span>(extraBytes);</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">    <span class="comment">//分配size内存空间</span></span><br><span class="line">    obj = (id)<span class="built_in">calloc</span>(<span class="number">1</span>, size);</span><br><span class="line">    <span class="comment">//初始化isa</span></span><br><span class="line">    obj-&gt;<span class="built_in">initIsa</span>(cls);</span><br><span class="line">    <span class="comment">//是否有构造函数</span></span><br><span class="line">    <span class="keyword">if</span> (cxxConstruct &amp;&amp; hasCxxCtor) &#123;</span><br><span class="line">        obj = _objc_constructOrFree(obj, cls);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>_class_createInstanceFromZone 方法中首先判断当前class或者superclass 是否有构造方法和析构方法。然后从类对象中获取要创建当前对象所需要的空间大小，紧接着就调用calloc分配内存，然后初始化Isa结构体。如果有构造函数的情况下还需要调用_objc_constructOrFree。_objc_constructOrFree最终会找到该类的C++构造方法，向它发送消息。</p>
<figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line"><span class="operator">-</span> (<span class="built_in">id</span>)<span class="keyword">init</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> _objc_rootInit(self);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">id</span></span><br><span class="line">_objc_rootInit(<span class="built_in">id</span> obj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// In practice, it will be hard to rely on this function.</span></span><br><span class="line">    <span class="comment">// Many classes do not properly chain -init calls.</span></span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-对象的持有-retain"><a href="#2-对象的持有-retain" class="headerlink" title="2 对象的持有 retain"></a>2 对象的持有 retain</h5><p><strong><strong>调用栈</strong></strong></p>
<p>对象的持有实际上是在对应的SideTable散列表中通过当前对象的地址作为散列值，找到存储当前对象引用计数的哈希表将引用计数增加1.我们下面看下整个调用过程：</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line"><span class="comment">--- retain</span></span><br><span class="line">    <span class="comment">--- rootRetain</span></span><br><span class="line">        <span class="comment">--- sidetable_retain</span></span><br></pre></td></tr></table></figure>



<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">- (id)retain &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">((id)self)</span>-&gt;</span>rootRetain();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable constant_">ALWAYS_INLINE</span> id </span><br><span class="line"><span class="attr">objc_object</span>::<span class="title function_">rootRetain</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">rootRetain</span>(<span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">ALWAYS_INLINE id </span><br><span class="line">objc_object::root<span class="constructor">Retain(<span class="params">bool</span> <span class="params">tryRetain</span>, <span class="params">bool</span> <span class="params">handleOverflow</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (is<span class="constructor">TaggedPointer()</span>) return (id)this;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bool</span> sideTableLocked = <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">bool</span> transcribeToSideTable = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    isa_t oldisa;</span><br><span class="line">    isa_t newisa;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        transcribeToSideTable = <span class="literal">false</span>;</span><br><span class="line">        oldisa = <span class="constructor">LoadExclusive(&amp;<span class="params">isa</span>.<span class="params">bits</span>)</span>;</span><br><span class="line">        newisa = oldisa;</span><br><span class="line">        <span class="keyword">if</span> (slowpath(!newisa.nonpointer)) &#123;</span><br><span class="line">            <span class="constructor">ClearExclusive(&amp;<span class="params">isa</span>.<span class="params">bits</span>)</span>;</span><br><span class="line">            <span class="keyword">if</span> (!tryRetain<span class="operator"> &amp;&amp; </span>sideTableLocked) sidetable<span class="constructor">_unlock()</span>;</span><br><span class="line">            <span class="keyword">if</span> (tryRetain) return sidetable<span class="constructor">_tryRetain()</span> ? (id)this : nil;</span><br><span class="line">            <span class="keyword">else</span> return sidetable<span class="constructor">_retain()</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// don&#x27;t check newisa.fast_rr; we already called any RR overrides</span></span><br><span class="line">        <span class="keyword">if</span> (slowpath(tryRetain<span class="operator"> &amp;&amp; </span>newisa.deallocating)) &#123;</span><br><span class="line">            <span class="constructor">ClearExclusive(&amp;<span class="params">isa</span>.<span class="params">bits</span>)</span>;</span><br><span class="line">            <span class="keyword">if</span> (!tryRetain<span class="operator"> &amp;&amp; </span>sideTableLocked) sidetable<span class="constructor">_unlock()</span>;</span><br><span class="line">            return nil;</span><br><span class="line">        &#125;</span><br><span class="line">        uintptr_t carry;</span><br><span class="line">        newisa.bits = addc(newisa.bits, RC_ONE, <span class="number">0</span>, &amp;carry);  <span class="comment">// extra_rc++</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (slowpath(carry)) &#123;</span><br><span class="line">            <span class="comment">// newisa.extra_rc++ overflowed</span></span><br><span class="line">            <span class="keyword">if</span> (!handleOverflow) &#123;</span><br><span class="line">                <span class="constructor">ClearExclusive(&amp;<span class="params">isa</span>.<span class="params">bits</span>)</span>;</span><br><span class="line">                return root<span class="constructor">Retain_overflow(<span class="params">tryRetain</span>)</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Leave half of the retain counts inline and </span></span><br><span class="line">            <span class="comment">// prepare to copy the other half to the side table.</span></span><br><span class="line">            <span class="keyword">if</span> (!tryRetain<span class="operator"> &amp;&amp; </span>!sideTableLocked) sidetable<span class="constructor">_lock()</span>;</span><br><span class="line">            sideTableLocked = <span class="literal">true</span>;</span><br><span class="line">            transcribeToSideTable = <span class="literal">true</span>;</span><br><span class="line">            newisa.extra_rc = RC_HALF;</span><br><span class="line">            newisa.has_sidetable_rc = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (slowpath(!<span class="constructor">StoreExclusive(&amp;<span class="params">isa</span>.<span class="params">bits</span>, <span class="params">oldisa</span>.<span class="params">bits</span>, <span class="params">newisa</span>.<span class="params">bits</span>)</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (slowpath(transcribeToSideTable)) &#123;</span><br><span class="line">        <span class="comment">// Copy the other half of the retain counts to the side table.</span></span><br><span class="line">        sidetable<span class="constructor">_addExtraRC_nolock(RC_HALF)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (slowpath(!tryRetain<span class="operator"> &amp;&amp; </span>sideTableLocked)) sidetable<span class="constructor">_unlock()</span>;</span><br><span class="line">    return (id)this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里最关键的是sidetable_retain，至于什么是SiteTable,以及对象引用计数的存储介绍可以查看 我准备的一个面试题：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/tbfungeek/iOS-Daily-Interview/issues/2">谈谈iOS的内存管理方式的理解</a>来理解如何查找散列表的过程。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">id</span></span><br><span class="line"><span class="function"><span class="title">objc_object::sidetable_retain</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> SUPPORT_NONPOINTER_ISA</span></span><br><span class="line">    <span class="built_in">assert</span>(!isa.nonpointer);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    SideTable&amp; table = <span class="built_in">SideTables</span>()[<span class="keyword">this</span>];</span><br><span class="line">    </span><br><span class="line">    table.<span class="built_in">lock</span>();</span><br><span class="line">    <span class="type">size_t</span>&amp; refcntStorage = table.refcnts[<span class="keyword">this</span>];</span><br><span class="line">    <span class="keyword">if</span> (! (refcntStorage &amp; SIDE_TABLE_RC_PINNED)) &#123;</span><br><span class="line">        refcntStorage += SIDE_TABLE_RC_ONE;</span><br><span class="line">    &#125;</span><br><span class="line">    table.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (id)<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-对象的释放-release"><a href="#3-对象的释放-release" class="headerlink" title="3 对象的释放 release"></a>3 对象的释放 release</h5><p><strong><strong>调用栈</strong></strong></p>
<p>对象的释放实际上是在对应的SideTable散列表中通过当前对象的地址作为散列值，找到存储当前对象引用计数的哈希表将引用计数减1.如果减去1后为0 那么就会调用dealloc释放对象：</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line"><span class="comment">--- release</span></span><br><span class="line">    <span class="comment">--- rootRelease</span></span><br><span class="line">        <span class="comment">--- sidetable_release</span></span><br></pre></td></tr></table></figure>



<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">- (oneway <span class="literal">void</span>)release &#123;</span><br><span class="line">    <span class="function"><span class="params">((id)self)</span>-&gt;</span>rootRelease();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">objc_object</span>::<span class="title function_">rootRelease</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">rootRelease</span>(<span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">ALWAYS_INLINE bool </span><br><span class="line">objc_object:<span class="type"></span>:rootRelease(bool performDealloc, bool handleUnderflow)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (isTaggedPointer()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    bool sideTableLocked = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    isa_t oldisa;</span><br><span class="line">    isa_t <span class="keyword">new</span><span class="type">isa</span>;</span><br><span class="line"></span><br><span class="line"> retry:<span class="type"></span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        oldisa = LoadExclusive(&amp;isa.bits);</span><br><span class="line">        <span class="keyword">new</span><span class="type">isa</span> = oldisa;</span><br><span class="line">        <span class="keyword">if</span> (slowpath(!<span class="keyword">new</span><span class="type">isa</span>.nonpointer)) &#123;</span><br><span class="line">            ClearExclusive(&amp;isa.bits);</span><br><span class="line">            <span class="keyword">if</span> (sideTableLocked) sidetable_unlock();</span><br><span class="line">            <span class="keyword">return</span> sidetable_release(performDealloc);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// don&#x27;t check newisa.fast_rr; we already called any RR overrides</span></span><br><span class="line">        uintptr_t carry;</span><br><span class="line">        <span class="keyword">new</span><span class="type">isa</span>.bits = subc(<span class="keyword">new</span><span class="type">isa</span>.bits, RC_ONE, <span class="number">0</span>, &amp;carry);  <span class="comment">// extra_rc--</span></span><br><span class="line">        <span class="keyword">if</span> (slowpath(carry)) &#123;</span><br><span class="line">            <span class="comment">// don&#x27;t ClearExclusive()</span></span><br><span class="line">            goto underflow;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (slowpath(!StoreReleaseExclusive(&amp;isa.bits, </span><br><span class="line">                                             oldisa.bits, <span class="keyword">new</span><span class="type">isa</span>.bits)));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (slowpath(sideTableLocked)) sidetable_unlock();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"> underflow:<span class="type"></span></span><br><span class="line">    <span class="comment">// newisa.extra_rc-- underflowed: borrow from side table or deallocate</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// abandon newisa to undo the decrement</span></span><br><span class="line">    <span class="keyword">new</span><span class="type">isa</span> = oldisa;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (slowpath(<span class="keyword">new</span><span class="type">isa</span>.has_sidetable_rc)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!handleUnderflow) &#123;</span><br><span class="line">            ClearExclusive(&amp;isa.bits);</span><br><span class="line">            <span class="keyword">return</span> rootRelease_underflow(performDealloc);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Transfer retain count from side table to inline storage.</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!sideTableLocked) &#123;</span><br><span class="line">            ClearExclusive(&amp;isa.bits);</span><br><span class="line">            sidetable_lock();</span><br><span class="line">            sideTableLocked = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// Need to start over to avoid a race against </span></span><br><span class="line">            <span class="comment">// the nonpointer -&gt; raw pointer transition.</span></span><br><span class="line">            goto retry;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Try to remove some retain counts from the side table.        </span></span><br><span class="line">        size_t borrowed = sidetable_subExtraRC_nolock(RC_HALF);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// To avoid races, has_sidetable_rc must remain set </span></span><br><span class="line">        <span class="comment">// even if the side table count is now zero.</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (borrowed &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// Side table retain count decreased.</span></span><br><span class="line">            <span class="comment">// Try to add them to the inline count.</span></span><br><span class="line">            <span class="keyword">new</span><span class="type">isa</span>.extra_rc = borrowed - <span class="number">1</span>;  <span class="comment">// redo the original decrement too</span></span><br><span class="line">            bool stored = StoreReleaseExclusive(&amp;isa.bits, </span><br><span class="line">                                                oldisa.bits, <span class="keyword">new</span><span class="type">isa</span>.bits);</span><br><span class="line">            <span class="keyword">if</span> (!stored) &#123;</span><br><span class="line">                <span class="comment">// Inline update failed. </span></span><br><span class="line">                <span class="comment">// Try it again right now. This prevents livelock on LL/SC </span></span><br><span class="line">                <span class="comment">// architectures where the side table access itself may have </span></span><br><span class="line">                <span class="comment">// dropped the reservation.</span></span><br><span class="line">                isa_t oldisa2 = LoadExclusive(&amp;isa.bits);</span><br><span class="line">                isa_t <span class="keyword">new</span><span class="type">isa2</span> = oldisa2;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">new</span><span class="type">isa2</span>.nonpointer) &#123;</span><br><span class="line">                    uintptr_t overflow;</span><br><span class="line">                    <span class="keyword">new</span><span class="type">isa2</span>.bits = </span><br><span class="line">                        addc(<span class="keyword">new</span><span class="type">isa2</span>.bits, RC_ONE * (borrowed<span class="number">-1</span>), <span class="number">0</span>, &amp;overflow);</span><br><span class="line">                    <span class="keyword">if</span> (!overflow) &#123;</span><br><span class="line">                        stored = StoreReleaseExclusive(&amp;isa.bits, oldisa2.bits, </span><br><span class="line">                                                       <span class="keyword">new</span><span class="type">isa2</span>.bits);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!stored) &#123;</span><br><span class="line">                <span class="comment">// Inline update failed.</span></span><br><span class="line">                <span class="comment">// Put the retains back in the side table.</span></span><br><span class="line">                sidetable_addExtraRC_nolock(borrowed);</span><br><span class="line">                goto retry;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Decrement successful after borrowing from side table.</span></span><br><span class="line">            <span class="comment">// This decrement cannot be the deallocating decrement - the side </span></span><br><span class="line">            <span class="comment">// table lock and has_sidetable_rc bit ensure that if everyone </span></span><br><span class="line">            <span class="comment">// else tried to -release while we worked, the last one would block.</span></span><br><span class="line">            sidetable_unlock();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Side table is empty after all. Fall-through to the dealloc path.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Really deallocate.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (slowpath(<span class="keyword">new</span><span class="type">isa</span>.deallocating)) &#123;</span><br><span class="line">        ClearExclusive(&amp;isa.bits);</span><br><span class="line">        <span class="keyword">if</span> (sideTableLocked) sidetable_unlock();</span><br><span class="line">        <span class="keyword">return</span> overrelease_error();</span><br><span class="line">        <span class="comment">// does not actually return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">new</span><span class="type">isa</span>.deallocating = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (!StoreExclusive(&amp;isa.bits, oldisa.bits, <span class="keyword">new</span><span class="type">isa</span>.bits)) goto retry;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (slowpath(sideTableLocked)) sidetable_unlock();</span><br><span class="line"></span><br><span class="line">    __sync_synchronize();</span><br><span class="line">    <span class="keyword">if</span> (performDealloc) &#123;</span><br><span class="line">        ((void(*)(objc_object *, SEL))objc_msgSend)(<span class="built_in">this</span>, SEL_dealloc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">uintptr_t</span></span></span><br><span class="line"><span class="function"><span class="title">objc_object::sidetable_release</span><span class="params">(<span class="type">bool</span> performDealloc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> SUPPORT_NONPOINTER_ISA</span></span><br><span class="line">    <span class="built_in">assert</span>(!isa.nonpointer);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    SideTable&amp; table = <span class="built_in">SideTables</span>()[<span class="keyword">this</span>];</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> do_dealloc = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    table.<span class="built_in">lock</span>();</span><br><span class="line">    <span class="comment">//在散列表中找到当前对象对应的引用计数</span></span><br><span class="line">    RefcountMap::iterator it = table.refcnts.<span class="built_in">find</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (it == table.refcnts.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        <span class="comment">//没找到，标记为已经销毁</span></span><br><span class="line">        do_dealloc = <span class="literal">true</span>;</span><br><span class="line">        table.refcnts[<span class="keyword">this</span>] = SIDE_TABLE_DEALLOCATING;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (it-&gt;second &lt; SIDE_TABLE_DEALLOCATING) &#123;</span><br><span class="line">        <span class="comment">// SIDE_TABLE_WEAKLY_REFERENCED may be set. Don&#x27;t change it.</span></span><br><span class="line">        do_dealloc = <span class="literal">true</span>;</span><br><span class="line">        it-&gt;second |= SIDE_TABLE_DEALLOCATING;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (! (it-&gt;second &amp; SIDE_TABLE_RC_PINNED)) &#123;</span><br><span class="line">        <span class="comment">//引用计数减去1</span></span><br><span class="line">        it-&gt;second -= SIDE_TABLE_RC_ONE;</span><br><span class="line">    &#125;</span><br><span class="line">    table.<span class="built_in">unlock</span>();</span><br><span class="line">    <span class="comment">//释放已经释放</span></span><br><span class="line">    <span class="keyword">if</span> (do_dealloc  &amp;&amp;  performDealloc) &#123;</span><br><span class="line">        <span class="comment">//调用dealloc</span></span><br><span class="line">        ((<span class="built_in">void</span>(*)(objc_object *, SEL))objc_msgSend)(<span class="keyword">this</span>, SEL_dealloc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> do_dealloc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="4-对象的销毁-dealloc"><a href="#4-对象的销毁-dealloc" class="headerlink" title="4 对象的销毁 dealloc"></a>4 对象的销毁 dealloc</h5><p>在介绍对象释放的最后有提到在某个对象的引用计数减为0的时候会调用对象的dealloc. 下面是相关的方法调用：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">- (void)dealloc &#123;</span><br><span class="line">    <span class="built_in">_objc_rootDealloc</span>(self);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">void</span><br><span class="line"><span class="built_in">_objc_rootDealloc</span>(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">assert</span>(obj);</span><br><span class="line"></span><br><span class="line">    obj-&gt;<span class="built_in">rootDealloc</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">inline void</span><br><span class="line">objc_object::rootDealloc()</span><br><span class="line">&#123;</span><br><span class="line">    if (isTaggedPointer()) return;  <span class="comment">// fixme necessary?</span></span><br><span class="line"></span><br><span class="line">    if (fastpath(isa.nonpointer  &amp;&amp;  </span><br><span class="line">                 !isa.weakly_referenced  &amp;&amp;  </span><br><span class="line">                 !isa.has_assoc  &amp;&amp;  </span><br><span class="line">                 !isa.has_cxx_dtor  &amp;&amp;  </span><br><span class="line">                 !isa.has_sidetable_rc))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">assert</span>(!sidetable_present());</span><br><span class="line">        <span class="built_in">free</span>(this);</span><br><span class="line">    &#125; </span><br><span class="line">    else &#123;</span><br><span class="line">        <span class="built_in">object_dispose</span>((id)this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">id </span><br><span class="line"><span class="built_in">object_dispose</span>(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    if (!obj) return nil;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">objc_destructInstance</span>(obj);    </span><br><span class="line">    <span class="built_in">free</span>(obj);</span><br><span class="line"></span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">void *objc<span class="constructor">_destructInstance(<span class="params">id</span> <span class="params">obj</span>)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj) &#123;</span><br><span class="line">        <span class="comment">// Read all of the flags at once for performance.</span></span><br><span class="line">        <span class="built_in">bool</span> cxx = obj-&gt;has<span class="constructor">CxxDtor()</span>;</span><br><span class="line">        <span class="built_in">bool</span> assoc = obj-&gt;has<span class="constructor">AssociatedObjects()</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// This order is important.</span></span><br><span class="line">        <span class="keyword">if</span> (cxx) <span class="keyword">object</span><span class="constructor">_cxxDestruct(<span class="params">obj</span>)</span>;</span><br><span class="line">        <span class="keyword">if</span> (assoc) <span class="constructor">_object_remove_assocations(<span class="params">obj</span>)</span>;</span><br><span class="line">        obj-&gt;clear<span class="constructor">Deallocating()</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里需要注意的是rootDealloc方法，它会先判断是否是taggpointer，如果是的话就直接返回，因为这种对象不需要释放内存，它的值就存放在指针中，这部分相关的内容可以查看<br><a target="_blank" rel="noopener" href="https://github.com/tbfungeek/iOS-Daily-Interview/issues/2">谈谈iOS的内存管理方式的理解</a>，紧接会判断当前对象的具体情况，如果当前对象是Nonpointer_ISA类型，那么要看相应的标识位，判断是否是弱引用，是否有关联对象，是否有C++析构函数，是否用到了散列表？如果都没有的话就直接free对象。否则通过object_dispose进行后续处理：</p>
<p>相关的具体处理最终在objc_destructInstance中实现。大家可以看下该方法的注释：</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line">/<span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>*</span><br><span class="line"><span class="bullet">* </span>objc_destructInstance</span><br><span class="line"><span class="bullet">* </span>Destroys an instance without freeing memory. </span><br><span class="line"><span class="bullet">* </span>Calls C++ destructors.</span><br><span class="line"><span class="bullet">* </span>Calls ARC ivar cleanup.</span><br><span class="line"><span class="bullet">* </span>Removes associative references.</span><br><span class="line"><span class="bullet">* </span>Returns <span class="code">`obj`</span>. Does nothing if <span class="code">`obj`</span> is nil.</span><br><span class="line"><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>/</span><br></pre></td></tr></table></figure>

<p>这里面重点针对是否有C++析构函数，是否有关联对象，是否有弱引用进行了对应的处理，我们接下来重点对这部分进行介绍：</p>
<p><strong><strong>调用析构函数是否对象</strong></strong></p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void <span class="keyword">object</span><span class="constructor">_cxxDestruct(<span class="params">id</span> <span class="params">obj</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!obj) return;</span><br><span class="line">    <span class="keyword">if</span> (obj-&gt;is<span class="constructor">TaggedPointer()</span>) return;</span><br><span class="line">    <span class="keyword">object</span><span class="constructor">_cxxDestructFromClass(<span class="params">obj</span>, <span class="params">obj</span>-&gt;ISA()</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">static</span> void object_cxxDestructFromClass(id obj, <span class="class"><span class="keyword">Class</span> <span class="title">cls</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    void (*dtor)(id);</span><br><span class="line"></span><br><span class="line">    // Call <span class="built_in">cls</span><span class="string">&#x27;s dtor first, then superclasses&#x27;</span>s dtors.</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ( ; <span class="built_in">cls</span>; <span class="built_in">cls</span> = <span class="built_in">cls</span>-&gt;superclass) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">cls</span>-&gt;hasCxxDtor()) <span class="keyword">return</span>; </span><br><span class="line">        dtor = (void(*)(id))</span><br><span class="line">            lookupMethodInClassAndLoadCache(<span class="built_in">cls</span>, SEL_cxx_destruct);</span><br><span class="line">        <span class="keyword">if</span> (dtor != (void(*)(id))_objc_msgForward_impcache) &#123;</span><br><span class="line">            <span class="keyword">if</span> (PrintCxxCtors) &#123;</span><br><span class="line">                _objc_inform(<span class="string">&quot;CXX: calling C++ destructors for class %s&quot;</span>, </span><br><span class="line">                             <span class="built_in">cls</span>-&gt;nameForLogging());</span><br><span class="line">            &#125;</span><br><span class="line">            (*dtor)(obj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>实际上就是在类的方法列表中查找对应的析构函数，然后对其进行调用。如果针对这部分想要细致了解大家可以查看<a target="_blank" rel="noopener" href="http://blog.sunnyxx.com/2014/04/02/objc_dig_arc_dealloc/">ARC下dealloc过程及.cxx_destruct的探究</a>这篇博客。</p>
<p>ARC下在编译器插入的.cxx_desctruct方法中会完成成员变量的自动释放。而对象的实例变量的销毁发生在根类[NSObject dealloc]方法中。</p>
<p><strong><strong>关联属性移除</strong></strong></p>
<p>关于关联对象大家可以查看对应的博客，它其实是由全局AssociationsManager进行管理的，在这里会找到对应的关联对象，然后添加到elements，然后对elements里面的对象调用ReleaseValue进行移除。这样和这个对象相关的关联对象就从AssociationsManager中移除了。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void <span class="constructor">_object_remove_assocations(<span class="params">id</span> <span class="params">object</span>)</span> &#123;</span><br><span class="line">    vector&lt; ObjcAssociation,ObjcAllocator&lt;ObjcAssociation&gt; &gt; elements;</span><br><span class="line">    &#123;</span><br><span class="line">        AssociationsManager manager;</span><br><span class="line">        AssociationsHashMap &amp;associations(manager.associations<span class="literal">()</span>);</span><br><span class="line">        <span class="keyword">if</span> (associations.size<span class="literal">()</span><span class="operator"> == </span><span class="number">0</span>) return;</span><br><span class="line">        disguised_ptr_t disguised_object = <span class="constructor">DISGUISE(<span class="params">object</span>)</span>;</span><br><span class="line">        AssociationsHashMap::iterator i = associations.find(disguised_object);</span><br><span class="line">        <span class="keyword">if</span> (i != associations.<span class="keyword">end</span><span class="literal">()</span>) &#123;</span><br><span class="line">            <span class="comment">// copy all of the associations that need to be removed.</span></span><br><span class="line">            ObjectAssociationMap *refs = i-&gt;second;</span><br><span class="line">            <span class="keyword">for</span> (ObjectAssociationMap::iterator j = refs-&gt;<span class="keyword">begin</span><span class="literal">()</span>, <span class="keyword">end</span> = refs-&gt;<span class="keyword">end</span><span class="literal">()</span>; j != <span class="keyword">end</span>; ++j) &#123;</span><br><span class="line">                elements.push<span class="constructor">_back(<span class="params">j</span>-&gt;<span class="params">second</span>)</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// remove the secondary table.</span></span><br><span class="line">            delete refs;</span><br><span class="line">            associations.erase(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// the calls to releaseValue() happen outside of the lock.</span></span><br><span class="line">    <span class="keyword">for</span><span class="constructor">_each(<span class="params">elements</span>.<span class="params">begin</span>()</span>, elements.<span class="keyword">end</span><span class="literal">()</span>, <span class="constructor">ReleaseValue()</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong><strong>清除剩余标识位</strong></strong></p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">inline void </span><br><span class="line">objc_object::clearDeallocating()</span><br><span class="line">&#123;</span><br><span class="line">    if (slowpath(!isa.nonpointer)) &#123;</span><br><span class="line">        <span class="comment">// Slow path for raw pointer isa.</span></span><br><span class="line">        <span class="comment">// 普通类型的指针指向的对象</span></span><br><span class="line">        <span class="built_in">sidetable_clearDeallocating</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    else if (slowpath(isa.weakly_referenced  ||  isa.has_sidetable_rc)) &#123;</span><br><span class="line">        <span class="comment">// Slow path for non-pointer isa with weak refs and/or side table data.</span></span><br><span class="line">        <span class="comment">// non-pointer isa 类型的对象。这种对象之所以要和普通对象区分开是因为它的弱引用标记以及是否使用散列表信息都存在“指针”中，所以要分开处理，但是处理的流程都是一样的，都是查看是否被弱引用指针指向，如果有则将这些设置为nil。紧接着从散列表中清除引用计数。最后将弱引用项从弱引用表中移除。</span></span><br><span class="line">        <span class="built_in">clearDeallocating_slow</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert</span>(!sidetable_present());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>clearDeallocating 中实际上是用于处理剩余的标识位，这里分成是否是non-pointer isa：<br>non-pointer isa 对象之所以要和普通对象区分开是因为它的弱引用标记以及是否使用散列表信息都存在“指针”中，所以要分开处理，但是处理的流程都是一样的，都是查看是否被弱引用指针指向，如果有则将这些设置为nil。紧接着从散列表中清除引用计数。最后将弱引用项从弱引用表中移除。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> </span><br><span class="line">objc_object::sidetable_clearDeallocating()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//找到对应的散列表</span></span><br><span class="line">    SideTable&amp; <span class="keyword">table</span> = SideTables()[<span class="keyword">this</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// clear any weak table items</span></span><br><span class="line">    <span class="comment">// clear extra retain count and deallocating bit</span></span><br><span class="line">    <span class="comment">// (fixme warn or abort if extra retain count == 0 ?)</span></span><br><span class="line">    <span class="keyword">table</span><span class="variable">.lock</span>();</span><br><span class="line">    RefcountMap::iterator it = <span class="keyword">table</span><span class="variable">.refcnts</span><span class="variable">.find</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (it != <span class="keyword">table</span><span class="variable">.refcnts</span><span class="variable">.end</span>()) &#123;</span><br><span class="line">        <span class="comment">//当前对象是否是弱引用对象</span></span><br><span class="line">        <span class="keyword">if</span> (it-&gt;second &amp; SIDE_TABLE_WEAKLY_REFERENCED) &#123;</span><br><span class="line">            <span class="comment">//如果是的话则将对应对象对它的引用设置为nil</span></span><br><span class="line">            weak_clear_no_lock(&amp;<span class="keyword">table</span><span class="variable">.weak_table</span>, (id)<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//清除引用计数</span></span><br><span class="line">        <span class="keyword">table</span><span class="variable">.refcnts</span><span class="variable">.erase</span>(it);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">table</span><span class="variable">.unlock</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>sidetable_clearDeallocating 就做了三件事情：</p>
<ol>
<li>找到对应的散列表</li>
<li>查看弱引用标记，是否是弱引用，如果是的话则将其他对象对它的引用置为nil，并将弱引用标志从SideTable的弱引用表中移除。</li>
<li>将该对象对应的引用计数表从SideTables中移除</li>
</ol>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">void</span> </span><br><span class="line">weak_clear_no_lock(weak_table_t *weak_table, id <span class="built_in">ref</span>erent_id) </span><br><span class="line">&#123;</span><br><span class="line">    objc_object *<span class="built_in">ref</span>erent = (objc_object *)<span class="built_in">ref</span>erent_id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//找到对应的弱引用项入口</span></span><br><span class="line">    weak_entry_t *entry = weak_entry_for_referent(weak_table, <span class="built_in">ref</span>erent);</span><br><span class="line">    <span class="keyword">if</span> (entry == nil) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// zero out references</span></span><br><span class="line">    weak_referrer_t *<span class="built_in">ref</span>errers;</span><br><span class="line">    size_t count;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (entry-&gt;out_of_line()) &#123;</span><br><span class="line">        <span class="built_in">ref</span>errers = entry-&gt;<span class="built_in">ref</span>errers;</span><br><span class="line">        count = TABLE_SIZE(entry);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">ref</span>errers = entry-&gt;inline_referrers;</span><br><span class="line">        count = WEAK_INLINE_COUNT;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">        objc_object **<span class="built_in">ref</span>errer = <span class="built_in">ref</span>errers[i];</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">ref</span>errer) &#123;</span><br><span class="line">            <span class="keyword">if</span> (*<span class="built_in">ref</span>errer == <span class="built_in">ref</span>erent) &#123;</span><br><span class="line">                <span class="comment">//将其他对象对他的引用设置为nil</span></span><br><span class="line">                *<span class="built_in">ref</span>errer = nil;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (*<span class="built_in">ref</span>errer) &#123;</span><br><span class="line">                _objc_inform(<span class="string">&quot;__weak variable at %p holds %p instead of %p. &quot;</span></span><br><span class="line">                             <span class="string">&quot;This is probably incorrect use of &quot;</span></span><br><span class="line">                             <span class="string">&quot;objc_storeWeak() and objc_loadWeak(). &quot;</span></span><br><span class="line">                             <span class="string">&quot;Break on objc_weak_error to debug.\n&quot;</span>, </span><br><span class="line">                             <span class="built_in">ref</span>errer, (<span class="built_in">void</span>*)*<span class="built_in">ref</span>errer, (<span class="built_in">void</span>*)<span class="built_in">ref</span>erent);</span><br><span class="line">                objc_weak_error();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//移除该项</span></span><br><span class="line">    weak_entry_remove(weak_table, entry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-Weak指针原理"><a href="#5-Weak指针原理" class="headerlink" title="5 Weak指针原理"></a>5 Weak指针原理</h5><p>__weak 修饰的变量有两大特点：</p>
<ul>
<li>不会增加指向对象的引用计数 （规避循环引用）</li>
<li>指向对象释放后，变量会自动置 nil （规避野指针访问错误）</li>
</ul>
<p>大体的实现思路如下：</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">使用__weak 修饰的变量时，runtime 会生成对应的 weak_entry 结构放入 weak_table 中，以赋值对象地址生成的 hash 值为 key，以包装 __weak 修饰的指针变量地址的 <span class="keyword">entry</span> 为 value，当赋值对象释放时，runtime 会在目标对象的 dealloc 处理过程中，以对象地址（self）为 key 去 weak_table 查找 <span class="keyword">entry</span> ，置空 <span class="keyword">entry</span> 指向的的所有对象指针。weak_entry 使用数组保存指针变量地址，当地址数量小于<span class="number">4</span>的时候，这个数组就是个普通的内置数组，在地址数量大于<span class="number">4</span>的时候，这个数组就会扩充成一个 hash table。</span><br></pre></td></tr></table></figure>

<p>我们接下来看下这部分源码：</p>
<p>当我们声明一个指针变量的时候就会调用<strong><strong>objc_initWeak</strong></strong>方法：</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">id</span><br><span class="line">objc_initWeak(id *location, id <span class="keyword">new</span><span class="type">Obj</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">new</span><span class="type">Obj</span>) &#123;</span><br><span class="line">        *location = nil;</span><br><span class="line">        <span class="keyword">return</span> nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> storeWeak&lt;DontHaveOld, DoHaveNew, DoCrashIfDeallocating&gt;</span><br><span class="line">        (location, (objc_object*)<span class="keyword">new</span><span class="type">Obj</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>weak 对象的存储是通过storeWeak完成的，在看storeWeak代码之前我们先来看下<strong><strong>weak_table_t</strong></strong></p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">struct weak_table_t &#123;</span><br><span class="line">    weak_entry_t *weak_entries<span class="comment">;</span></span><br><span class="line">    size_t    num_entries<span class="comment">;</span></span><br><span class="line">    uintptr_t mask<span class="comment">;</span></span><br><span class="line">    uintptr_t max_hash_displacement<span class="comment">;</span></span><br><span class="line">&#125;<span class="comment">;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>weak_table_t 中存储的每个weak_entry_t是以被引用对象地址为hash Code 进行存储的，这个没啥好说的，我们来看下weak_entry_t。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">weak_entry_t</span> &#123;</span><br><span class="line">    DisguisedPtr&lt;objc_object&gt; referent;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">struct</span> &#123;</span><br><span class="line">            <span class="type">weak_referrer_t</span> *referrers;</span><br><span class="line">            <span class="type">uintptr_t</span>        out_of_line_ness : <span class="number">2</span>;</span><br><span class="line">            <span class="type">uintptr_t</span>        num_refs : PTR_MINUS_2;</span><br><span class="line">            <span class="type">uintptr_t</span>        mask;</span><br><span class="line">            <span class="type">uintptr_t</span>        max_hash_displacement;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">struct</span> &#123;</span><br><span class="line">            <span class="comment">// out_of_line_ness field is low bits of inline_referrers[1]</span></span><br><span class="line">            <span class="type">weak_referrer_t</span>  inline_referrers[WEAK_INLINE_COUNT];</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">out_of_line</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (out_of_line_ness == REFERRERS_OUT_OF_LINE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">weak_entry_t</span>&amp; <span class="keyword">operator</span>=(<span class="type">const</span> <span class="type">weak_entry_t</span>&amp; other) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(<span class="keyword">this</span>, &amp;other, <span class="built_in">sizeof</span>(other));</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">weak_entry_t</span>(objc_object *newReferent, objc_object **newReferrer)</span><br><span class="line">        : <span class="built_in">referent</span>(newReferent)</span><br><span class="line">    &#123;</span><br><span class="line">        inline_referrers[<span class="number">0</span>] = newReferrer;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; WEAK_INLINE_COUNT; i++) &#123;</span><br><span class="line">            inline_referrers[i] = nil;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>weak_entry_t 里面包含了一个union，里面有两个结构体，其中 WEAK_INLINE_COUNT 宏为 4 ，也就是说在初始状态下，这个 union 的空间有 weak_referrer_t inline_referrers[4] 这么大，当 entry 保存指针变量地址的个数不大于 4 个时，我们就可以直接使用 inline_referrers 数组，这样写的话，访问更加快速便捷。但是如果超过4个的话则使用哈希表来存储，这样会加速查找的速度。</p>
<p>下面是weak相关数据结构的大体示意图：</p>
<p><img src="/2020/01/04/iOS-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B9%8B%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%EF%BC%8C%E9%94%80%E6%AF%81%EF%BC%8C%E6%8C%81%E6%9C%89%EF%BC%8C%E5%BC%B1%E5%BC%95%E7%94%A8%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/00001.png"></p>
<p>referent: 是内存上的weak对象<br>referrers: 是指向weak对象的所有变量</p>
<p>有了上面的存储结构的介绍对storeWeak会有更清晰的理解</p>
<p>在设置新的关联前，如果 __weak 修饰的指针变量已经关联了其他对象，那么此函数会先解除旧关联，再设置新的。如果 newObjc 是 nil，那么只会进行解除关联以及指针置 nil 操作，objc_destroyWeak 就以这种方式调用 storeWeak 来执行销毁动作，这个后面会介绍。</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">template &lt;HaveOld haveOld, HaveNew haveNew,</span><br><span class="line">          CrashIfDeallocating crashIfDeallocating&gt;</span><br><span class="line"><span class="keyword">static</span> id </span><br><span class="line">storeWeak(id *location, objc_object *<span class="keyword">new</span><span class="type">Obj</span>)</span><br><span class="line">&#123;</span><br><span class="line">    assert(haveOld  ||  haveNew);</span><br><span class="line">    <span class="keyword">if</span> (!haveNew) assert(<span class="keyword">new</span><span class="type">Obj</span> == nil);</span><br><span class="line"></span><br><span class="line">    Class previouslyInitializedClass = nil;</span><br><span class="line">    id oldObj;</span><br><span class="line">    SideTable *oldTable;</span><br><span class="line">    SideTable *<span class="keyword">new</span><span class="type">Table</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//..........</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Clean up old value, if any.</span></span><br><span class="line">    <span class="keyword">if</span> (haveOld) &#123;</span><br><span class="line">        <span class="comment">//__weak 修饰的指针变量已经指向过某对象</span></span><br><span class="line">        <span class="comment">// 需要把这个对象和此指针变量的关联断开</span></span><br><span class="line">        weak_unregister_no_lock(&amp;oldTable-&gt;weak_table, oldObj, location);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Assign new value, if any.</span></span><br><span class="line">    <span class="keyword">if</span> (haveNew) &#123;</span><br><span class="line">        <span class="comment">// 关联新对象和 __weak 修饰的指针变量</span></span><br><span class="line">        <span class="keyword">new</span><span class="type">Obj</span> = (objc_object *)</span><br><span class="line">            weak_register_no_lock(&amp;<span class="keyword">new</span><span class="type">Table</span>-&gt;weak_table, (id)<span class="keyword">new</span><span class="type">Obj</span>, location, </span><br><span class="line">                                  crashIfDeallocating);</span><br><span class="line">        <span class="comment">// weak_register_no_lock returns nil if weak store should be rejected</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Set is-weakly-referenced bit in refcount table.</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">new</span><span class="type">Obj</span>  &amp;&amp;  !<span class="keyword">new</span><span class="type">Obj</span>-&gt;isTaggedPointer()) &#123;</span><br><span class="line">            <span class="comment">// 设置 isa 指针的 weakly_referenced 位 / sidetable 中的 SIDE_TABLE_WEAKLY_REFERENCED 位</span></span><br><span class="line">            <span class="comment">// 标记此对象被 __weak 修饰的指针变量指向了，dealloc 时可以加速置 nil 处理</span></span><br><span class="line">            <span class="keyword">new</span><span class="type">Obj</span>-&gt;setWeaklyReferenced_nolock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置 __weak 修饰的指针变量的值为 newObj</span></span><br><span class="line">        <span class="comment">// Do not set *location anywhere else. That would introduce a race.</span></span><br><span class="line">        *location = (id)<span class="keyword">new</span><span class="type">Obj</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// No new value. The storage is not changed.</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    SideTable:<span class="type"></span>:unlockTwo&lt;haveOld, haveNew&gt;(oldTable, <span class="keyword">new</span><span class="type">Table</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (id)<span class="keyword">new</span><span class="type">Obj</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">id </span><br><span class="line">weak_register_no_lock(weak_table_t *weak_table, id <span class="built_in">ref</span>erent_id, </span><br><span class="line">                      id *<span class="built_in">ref</span>errer_id, <span class="built_in">bool</span> crashIfDeallocating)</span><br><span class="line">&#123;</span><br><span class="line">    objc_object *<span class="built_in">ref</span>erent = (objc_object *)<span class="built_in">ref</span>erent_id;</span><br><span class="line">    objc_object **<span class="built_in">ref</span>errer = (objc_object **)<span class="built_in">ref</span>errer_id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">ref</span>erent  ||  <span class="built_in">ref</span>erent-&gt;isTaggedPointer()) <span class="keyword">return</span> <span class="built_in">ref</span>erent_id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ensure that the referenced object is viable</span></span><br><span class="line">    <span class="built_in">bool</span> deallocating;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">ref</span>erent-&gt;ISA()-&gt;hasCustomRR()) &#123;</span><br><span class="line">        deallocating = <span class="built_in">ref</span>erent-&gt;rootIsDeallocating();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        BOOL (*allowsWeakReference)(objc_object *, SEL) = </span><br><span class="line">            (BOOL(*)(objc_object *, SEL))</span><br><span class="line">            object_getMethodImplementation((id)<span class="built_in">ref</span>erent, </span><br><span class="line">                                           SEL_allowsWeakReference);</span><br><span class="line">        <span class="keyword">if</span> ((IMP)allowsWeakReference == _objc_msgForward) &#123;</span><br><span class="line">            <span class="keyword">return</span> nil;</span><br><span class="line">        &#125;</span><br><span class="line">        deallocating =</span><br><span class="line">            ! (*allowsWeakReference)(<span class="built_in">ref</span>erent, SEL_allowsWeakReference);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (deallocating) &#123;</span><br><span class="line">        <span class="keyword">if</span> (crashIfDeallocating) &#123;</span><br><span class="line">            _objc_fatal(<span class="string">&quot;Cannot form weak reference to instance (%p) of &quot;</span></span><br><span class="line">                        <span class="string">&quot;class %s. It is possible that this object was &quot;</span></span><br><span class="line">                        <span class="string">&quot;over-released, or is in the process of deallocation.&quot;</span>,</span><br><span class="line">                        (<span class="built_in">void</span>*)<span class="built_in">ref</span>erent, object_getClassName((id)<span class="built_in">ref</span>erent));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> nil;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// now remember it and where it is being stored</span></span><br><span class="line">    weak_entry_t *entry;</span><br><span class="line">    <span class="keyword">if</span> ((entry = weak_entry_for_referent(weak_table, <span class="built_in">ref</span>erent))) &#123;</span><br><span class="line">        append_referrer(entry, <span class="built_in">ref</span>errer);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        weak_entry_t new_entry(<span class="built_in">ref</span>erent, <span class="built_in">ref</span>errer);</span><br><span class="line">        weak_grow_maybe(weak_table);</span><br><span class="line">        weak_entry_insert(weak_table, &amp;new_entry);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Do not set *referrer. objc_storeWeak() requires that the </span></span><br><span class="line">    <span class="comment">// value not change.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ref</span>erent_id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>最关键的代码在<strong><strong>weak_register_no_lock</strong></strong> 中，它会判断某个referent的weak_entry是否存在，如果存在则直接在这个weak_entry中添加referrer，否则新建一个weak_entry，加到weak_table中。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">weak_entry_t *entry;</span><br><span class="line"><span class="keyword">if</span> ((entry = weak<span class="constructor">_entry_for_referent(<span class="params">weak_table</span>, <span class="params">referent</span>)</span>)) &#123;</span><br><span class="line">    append<span class="constructor">_referrer(<span class="params">entry</span>, <span class="params">referrer</span>)</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    weak_entry_t <span class="keyword">new</span><span class="constructor">_entry(<span class="params">referent</span>, <span class="params">referrer</span>)</span>;</span><br><span class="line">    weak<span class="constructor">_grow_maybe(<span class="params">weak_table</span>)</span>;</span><br><span class="line">    weak<span class="constructor">_entry_insert(<span class="params">weak_table</span>, &amp;<span class="params">new_entry</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong><strong>销毁弱引用对象</strong></strong></p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">objc_destroyWeak(id *<span class="keyword">location</span>)</span><br><span class="line">&#123;</span><br><span class="line">    (<span class="type">void</span>)storeWeak&lt;DoHaveOld, DontHaveNew, DontCrashIfDeallocating&gt;</span><br><span class="line">        (<span class="keyword">location</span>, nil);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>销毁弱引用对象和创建弱引用对象入口实际上是一样的，都是storeWeak，只不过这里传入的值为nil。由于传入的是非 nil 新值，storeWeak会删除而不会新建关联信息。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">void</span> weak_unregister_no_lock(weak_table_t *weak_table, id <span class="built_in">ref</span>erent_id, </span><br><span class="line">                        id *<span class="built_in">ref</span>errer_id)</span><br><span class="line">&#123;</span><br><span class="line">    objc_object *<span class="built_in">ref</span>erent = (objc_object *)<span class="built_in">ref</span>erent_id;</span><br><span class="line">    objc_object **<span class="built_in">ref</span>errer = (objc_object **)<span class="built_in">ref</span>errer_id;</span><br><span class="line"></span><br><span class="line">    weak_entry_t *entry;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">ref</span>erent) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 根据对象地址获取 entry</span></span><br><span class="line">    <span class="keyword">if</span> ((entry = weak_entry_for_referent(weak_table, <span class="built_in">ref</span>erent))) &#123;</span><br><span class="line">        <span class="comment">// 移除 entry 中值为 referrer 的指针变量地址</span></span><br><span class="line">        remove_referrer(entry, <span class="built_in">ref</span>errer);</span><br><span class="line">        <span class="built_in">bool</span> empty = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// entry 中是否有关联的指针变量地址</span></span><br><span class="line">        <span class="keyword">if</span> (entry-&gt;out_of_line()  &amp;&amp;  entry-&gt;num_refs != <span class="number">0</span>) &#123;</span><br><span class="line">            empty = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; WEAK_INLINE_COUNT; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (entry-&gt;inline_referrers[i]) &#123;</span><br><span class="line">                    empty = <span class="literal">false</span>; </span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (empty) &#123;</span><br><span class="line">            <span class="comment">// 如果 entry 是空的话，就从 weak_table 中移除掉</span></span><br><span class="line">            weak_entry_remove(weak_table, entry);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>



<div class="comments-count">
	
	  	<span></span>
		<a href="/2020/01/04/iOS-内存管理之对象创建，销毁，持有，弱引用源码剖析/#comments" class="ds-thread-count comments-count-link" data-thread-key="2020/01/04/iOS-内存管理之对象创建，销毁，持有，弱引用源码剖析/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>







  <nav id="page-nav" class="clearfix">
    <a class="extend prev" rel="prev" href="/">&lt;span&gt;&lt;&#x2F;span&gt;Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/30/">30</a><a class="extend next" rel="next" href="/page/3/">Next&lt;span&gt;&lt;&#x2F;span&gt;</a>
  </nav>

</div>
      <div class="openaside"><a class="navbutton" href="#" title="Show Sidebar"></a></div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="Hide Sidebar"></a></div>
<aside class="clearfix">
<div id="authorInfo">
	
		<div class="author-img"></div>		
	
	<div class="social-info" class="clearfix">
		
		
		<a href="https://github.com/tbfungeek" target="_blank" class="icon-github" title="github"></a>
		
		
		
		
		
		
		
		
		
		
		<a href="mailto:tbfungeek@163.com" target="_blank" class="icon-email" title="Email Me"></a>
		

	</div>
</div>

  
<div class="categorieslist">
	<p class="asidetitle">Categories</p>
		<ul>
		
		  
			<li><a href="/categories/Android-小经验/" title="Android 小经验">Android 小经验<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Android-源码分析/" title="Android 源码分析">Android 源码分析<sup>21</sup></a></li>
		  
		
		  
			<li><a href="/categories/Android其他/" title="Android其他">Android其他<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Android初步/" title="Android初步">Android初步<sup>21</sup></a></li>
		  
		
		  
			<li><a href="/categories/Android进阶/" title="Android进阶">Android进阶<sup>100</sup></a></li>
		  
		
		  
			<li><a href="/categories/Hexo-使用/" title="Hexo 使用">Hexo 使用<sup>10</sup></a></li>
		  
		
		  
			<li><a href="/categories/JavaScript理论/" title="JavaScript理论">JavaScript理论<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Objective-C-相关/" title="Objective C 相关">Objective C 相关<sup>24</sup></a></li>
		  
		
		  
			<li><a href="/categories/OpenCV/" title="OpenCV">OpenCV<sup>6</sup></a></li>
		  
		
		  
			<li><a href="/categories/ROS/" title="ROS">ROS<sup>9</sup></a></li>
		  
		
		  
			<li><a href="/categories/iOS-工具使用/" title="iOS 工具使用">iOS 工具使用<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/iOS-开源库分析/" title="iOS 开源库分析">iOS 开源库分析<sup>36</sup></a></li>
		  
		
		  
			<li><a href="/categories/iOS-理论基础/" title="iOS 理论基础">iOS 理论基础<sup>14</sup></a></li>
		  
		
		  
			<li><a href="/categories/iOS-进阶/" title="iOS 进阶">iOS 进阶<sup>4</sup></a></li>
		  
		
		  
			<li><a href="/categories/个人收藏/" title="个人收藏">个人收藏<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/代码规范/" title="代码规范">代码规范<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/其他/" title="其他">其他<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/博客分类目录/" title="博客分类目录">博客分类目录<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/叨叨系列/" title="叨叨系列">叨叨系列<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/开源代码分析/" title="开源代码分析">开源代码分析<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/开源库分析/" title="开源库分析">开源库分析<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/树莓派/" title="树莓派">树莓派<sup>4</sup></a></li>
		  
		
		  
			<li><a href="/categories/版本控制/" title="版本控制">版本控制<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/直播/" title="直播">直播<sup>6</sup></a></li>
		  
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">Tags</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/iOS-开源库分析/" title="iOS 开源库分析">iOS 开源库分析<sup>36</sup></a></li>
			
		
			
				<li><a href="/tags/Android-设计模式/" title="Android 设计模式">Android 设计模式<sup>29</sup></a></li>
			
		
			
				<li><a href="/tags/Objective-C-相关/" title="Objective C 相关">Objective C 相关<sup>24</sup></a></li>
			
		
			
				<li><a href="/tags/Android基础/" title="Android基础">Android基础<sup>21</sup></a></li>
			
		
			
				<li><a href="/tags/AOSP-源码/" title="AOSP 源码">AOSP 源码<sup>17</sup></a></li>
			
		
			
				<li><a href="/tags/Android-常用第三方库/" title="Android 常用第三方库">Android 常用第三方库<sup>15</sup></a></li>
			
		
			
				<li><a href="/tags/iOS-理论基础/" title="iOS 理论基础">iOS 理论基础<sup>14</sup></a></li>
			
		
			
				<li><a href="/tags/Hexo-使用/" title="Hexo 使用">Hexo 使用<sup>10</sup></a></li>
			
		
			
				<li><a href="/tags/ROS/" title="ROS">ROS<sup>9</sup></a></li>
			
		
			
				<li><a href="/tags/Android-动画进阶/" title="Android 动画进阶">Android 动画进阶<sup>8</sup></a></li>
			
		
			
				<li><a href="/tags/Android-JNI/" title="Android JNI">Android JNI<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/Android-绘图进阶/" title="Android 绘图进阶">Android 绘图进阶<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/Android性能优化/" title="Android性能优化">Android性能优化<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/Android-自动化测试/" title="Android 自动化测试">Android 自动化测试<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/OpenCV/" title="OpenCV">OpenCV<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/直播/" title="直播">直播<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/Android-开源源码/" title="Android 开源源码">Android 开源源码<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/Android-自定义View进阶/" title="Android 自定义View进阶">Android 自定义View进阶<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/树莓派/" title="树莓派">树莓派<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/iOS-进阶/" title="iOS 进阶">iOS 进阶<sup>4</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">Links</p>
    <ul>
        
          <li>
            
            	<a href="https://hexo.io" target="_blank" title="Hexo">Hexo</a>
            
          </li>
        
          <li>
            
            	<a href="https://pages.github.com/" target="_blank" title="GitHub">GitHub</a>
            
          </li>
        
          <li>
            
            	<a href="http://pf18.github.io/" target="_blank" title="PF18">PF18</a>
            
          </li>
        
          <li>
            
            	<a href="http://toutiao.io/" target="_blank" title="开发者头条">开发者头条</a>
            
          </li>
        
          <li>
            
            	<a href="http://www.jcodecraeer.com/" target="_blank" title="泡在网上的日子">泡在网上的日子</a>
            
          </li>
        
    </ul>
</div>

  


  <div class="rsspart">
	<a href="atom.xml" target="_blank" title="rss">RSS</a>
</div>

  
  <div class="tagcloudlist">
    <p class="asidetitle">Tag Cloud</p>
    <div class="tagcloudlist clearfix">
       <a href="/tags/AOSP-%E6%BA%90%E7%A0%81/" style="font-size: 17.14px;">AOSP 源码</a> <a href="/tags/Android-APK-%E7%AD%BE%E5%90%8D/" style="font-size: 10px;">Android APK 签名</a> <a href="/tags/Android-JNI/" style="font-size: 12.86px;">Android JNI</a> <a href="/tags/Android-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E8%BF%9B%E9%98%B6/" style="font-size: 10.71px;">Android 事件处理进阶</a> <a href="/tags/Android-%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6/" style="font-size: 13.57px;">Android 动画进阶</a> <a href="/tags/Android-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%80%E5%8F%91/" style="font-size: 10px;">Android 多线程开发</a> <a href="/tags/Android-%E5%B0%8F%E7%BB%8F%E9%AA%8C/" style="font-size: 10px;">Android 小经验</a> <a href="/tags/Android-%E5%B8%B8%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/" style="font-size: 16.43px;">Android 常用第三方库</a> <a href="/tags/Android-%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/" style="font-size: 10px;">Android 开发流程</a> <a href="/tags/Android-%E5%BC%80%E6%BA%90%E6%BA%90%E7%A0%81/" style="font-size: 12.14px;">Android 开源源码</a> <a href="/tags/Android-%E7%BB%98%E5%9B%BE%E8%BF%9B%E9%98%B6/" style="font-size: 12.86px;">Android 绘图进阶</a> <a href="/tags/Android-%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/" style="font-size: 12.86px;">Android 自动化测试</a> <a href="/tags/Android-%E8%87%AA%E5%AE%9A%E4%B9%89View%E8%BF%9B%E9%98%B6/" style="font-size: 12.14px;">Android 自定义View进阶</a> <a href="/tags/Android-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 19.29px;">Android 设计模式</a> <a href="/tags/Android%E5%85%B6%E4%BB%96/" style="font-size: 10px;">Android其他</a> <a href="/tags/Android%E5%9F%BA%E7%A1%80/" style="font-size: 17.86px;">Android基础</a> <a href="/tags/Android%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/" style="font-size: 10px;">Android开发流程</a> <a href="/tags/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" style="font-size: 12.86px;">Android性能优化</a> <a href="/tags/Android%E6%B7%B7%E6%B7%86%E6%8A%80%E6%9C%AF/" style="font-size: 10px;">Android混淆技术</a> <a href="/tags/Android%E8%B4%A8%E9%87%8F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/" style="font-size: 11.43px;">Android质量管理工具</a> <a href="/tags/Android%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/" style="font-size: 10px;">Android逆向工程</a> <a href="/tags/Git-github/" style="font-size: 10px;">Git && github</a> <a href="/tags/Hexo-%E4%BD%BF%E7%94%A8/" style="font-size: 15px;">Hexo 使用</a> <a href="/tags/JavaScript/" style="font-size: 10px;">JavaScript</a> <a href="/tags/Linux-%E4%BD%BF%E7%94%A8/" style="font-size: 10px;">Linux 使用</a> <a href="/tags/Objective-C-%E7%9B%B8%E5%85%B3/" style="font-size: 18.57px;">Objective C 相关</a> <a href="/tags/OpenCV/" style="font-size: 12.86px;">OpenCV</a> <a href="/tags/ROS/" style="font-size: 14.29px;">ROS</a> <a href="/tags/iOS-%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/" style="font-size: 10.71px;">iOS 工具使用</a> <a href="/tags/iOS-%E5%BC%80%E6%BA%90%E5%BA%93%E5%88%86%E6%9E%90/" style="font-size: 20px;">iOS 开源库分析</a> <a href="/tags/iOS-%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/" style="font-size: 15.71px;">iOS 理论基础</a> <a href="/tags/iOS-%E8%BF%9B%E9%98%B6/" style="font-size: 12.14px;">iOS 进阶</a> <a href="/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/" style="font-size: 10px;">代码规范</a> <a href="/tags/%E5%8D%9A%E5%AE%A2%E5%88%86%E7%B1%BB%E7%9B%AE%E5%BD%95/" style="font-size: 10.71px;">博客分类目录</a> <a href="/tags/%E5%8F%A8%E5%8F%A8%E7%B3%BB%E5%88%97/" style="font-size: 10px;">叨叨系列</a> <a href="/tags/%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/" style="font-size: 11.43px;">工具的使用</a> <a href="/tags/%E5%BC%80%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/" style="font-size: 10.71px;">开源代码分析</a> <a href="/tags/%E5%BC%80%E6%BA%90%E5%BA%93%E5%88%86%E6%9E%90/" style="font-size: 10px;">开源库分析</a> <a href="/tags/%E6%9D%82%E7%B1%BB/" style="font-size: 10px;">杂类</a> <a href="/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/" style="font-size: 12.14px;">树莓派</a> <a href="/tags/%E7%9B%B4%E6%92%AD/" style="font-size: 12.86px;">直播</a> <a href="/tags/%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/" style="font-size: 10.71px;">编程技巧</a> <a href="/tags/%E7%BD%91%E7%AB%99%E6%94%B6%E8%97%8F/" style="font-size: 10px;">网站收藏</a> <a href="/tags/%E9%87%8D%E8%A6%81%E6%8E%A7%E4%BB%B6/" style="font-size: 11.43px;">重要控件</a>
    </div>
  </div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
		
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/hsihohuang/kiddochan" target="_blank" title="Kiddochan">Kiddochan</a> © 2022 
		
		<a href="/about" target="_blank" title="Edgar">Edgar</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
        
    }
  });
});
</script>










<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?7c9443b0374f1cf6b1dbb5ab84d939cb";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="Back to Top"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
 </html>
