
 <!DOCTYPE HTML>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
  
    <title>iOS Runtime源码解析 Runtime初始化 | Edgar&#39;s Blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="Edgar">
    

    
    <meta name="description" content="前面我们介绍了Mach O的结构，App的启动，dyld的加载，以及通过dyld将镜像加载进来，经过rebase&#x2F;Bind处理后，找到main入口，以及Runtime相关的数据结构，有了前面的一系列铺垫这里介绍Runtime初始化就显得相对轻松了，这篇博客我们从《iOS Runtime源码解析之dyld》结尾处接着介绍，《iOS Runtime源码解析之dyld》中介绍了从dyld入口">
<meta property="og:type" content="article">
<meta property="og:title" content="iOS Runtime源码解析 Runtime初始化">
<meta property="og:url" content="http://yoursite.com/2020/02/02/iOS-Runtime%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-Runtime%E5%88%9D%E5%A7%8B%E5%8C%96/index.html">
<meta property="og:site_name" content="Edgar&#39;s Blog">
<meta property="og:description" content="前面我们介绍了Mach O的结构，App的启动，dyld的加载，以及通过dyld将镜像加载进来，经过rebase&#x2F;Bind处理后，找到main入口，以及Runtime相关的数据结构，有了前面的一系列铺垫这里介绍Runtime初始化就显得相对轻松了，这篇博客我们从《iOS Runtime源码解析之dyld》结尾处接着介绍，《iOS Runtime源码解析之dyld》中介绍了从dyld入口">
<meta property="og:locale">
<meta property="article:published_time" content="2020-02-01T23:49:23.000Z">
<meta property="article:modified_time" content="2020-02-04T17:52:10.000Z">
<meta property="article:author" content="Edgar">
<meta property="article:tag" content="Objective C 相关">
<meta name="twitter:card" content="summary">

    
    <link rel="alternative" href="atom.xml" title="Edgar&#39;s Blog" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/unnamed4_n_mSY_icon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/profile.png">
    <link rel="apple-touch-icon-precomposed" href="/img/profile.png">
    
    
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 6.2.0"></head>

  <body>
    <header>
      
<div>
		
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="Edgar&#39;s Blog">Edgar&#39;s Blog</a></h1>
				<h2 class="blog-motto"></h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="Menu">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
					<li>
 					
					<form class="search" action="/search/index.html" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" autocomplete="off" name="q" maxlength="20" placeholder="Search" />
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
  
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2020/02/02/iOS-Runtime源码解析-Runtime初始化/" title="iOS Runtime源码解析 Runtime初始化" itemprop="url">iOS Runtime源码解析 Runtime初始化</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Edgar" target="_blank" itemprop="author">Edgar</a>
		
  <p class="article-time">
    <time datetime="2020-02-01T23:49:23.000Z" itemprop="datePublished"> Published 2020-02-02</time>
    
  </p>
</header>
	<div class="article-content">
		
		<p>前面我们介绍了Mach O的结构，App的启动，dyld的加载，以及通过dyld将镜像加载进来，经过rebase&#x2F;Bind处理后，找到main入口，以及Runtime相关的数据结构，有了前面的一系列铺垫这里介绍Runtime初始化就显得相对轻松了，这篇博客我们从《iOS Runtime源码解析之dyld》结尾处接着介绍，《iOS Runtime源码解析之dyld》中介绍了从dyld入口__dyld_start作为起点，到找到并跳转到主函数入口期间的一系列工作：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1.</span> 将主程序初始化为imageLoader</span><br><span class="line"><span class="bullet">2.</span> 加载共享库到内存</span><br><span class="line"><span class="bullet">3.</span> 加载插入的动态库</span><br><span class="line"><span class="bullet">4.</span> 链接主程序,链接插入库</span><br><span class="line"><span class="bullet">5.</span> 初始化主程序，插入库</span><br><span class="line"><span class="bullet">6.</span> 寻找主程序入口点</span><br></pre></td></tr></table></figure>
<p>这篇博客和《iOS Runtime源码解析之dyld》的衔接点就在于第5步初始化主程序，插入库这一步，在这个阶段，会调用使用attribute((constructor) 进行修饰的方法,其中有个十分重要的动态库初始化方法，<strong><strong>libSystem_initializer</strong></strong>：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">static <span class="constructor">__attribute__((<span class="params">constructor</span>)</span>) </span><br><span class="line">void lib<span class="constructor">System_initializer(<span class="params">int</span> <span class="params">argc</span>, <span class="params">const</span> <span class="params">char</span><span class="operator">*</span> <span class="params">argv</span>[], <span class="params">const</span> <span class="params">char</span><span class="operator">*</span> <span class="params">envp</span>[], <span class="params">const</span> <span class="params">char</span><span class="operator">*</span> <span class="params">apple</span>[], <span class="params">const</span> <span class="params">struct</span> ProgramVars<span class="operator">*</span> <span class="params">vars</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line"></span><br><span class="line">    <span class="constructor">_libkernel_init(<span class="params">libkernel_funcs</span>)</span>;</span><br><span class="line"></span><br><span class="line">    bootstrap<span class="constructor">_init()</span>;</span><br><span class="line">    mach<span class="constructor">_init()</span>;</span><br><span class="line">    pthread<span class="constructor">_init()</span>;</span><br><span class="line">    <span class="constructor">__libc_init(<span class="params">vars</span>, <span class="params">libSystem_atfork_prepare</span>, <span class="params">libSystem_atfork_parent</span>, <span class="params">libSystem_atfork_child</span>, <span class="params">apple</span>)</span>;</span><br><span class="line">    <span class="constructor">__keymgr_initializer()</span>;</span><br><span class="line">    <span class="constructor">_dyld_initializer()</span>;</span><br><span class="line">    libdispatch<span class="constructor">_init()</span>;</span><br><span class="line">    <span class="constructor">_libxpc_initializer()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="constructor">__stack_logging_early_finished()</span>;</span><br><span class="line">    <span class="comment">//.......</span></span><br><span class="line">    errno = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在libSystem.dylib的初始化方法libSystem_initializer中初始化了多了dylib库,比如:liblaunch.dylib,libc.a,libdispatch.a等等，这里最关键的是****<a target="_blank" rel="noopener" href="https://github.com/nickhutchinson/libdispatch">libdispatch_init</a>****:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">libdispatch_init</span>(<span class="params"><span class="keyword">void</span></span>) &#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="title function_">_os_object_init</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在libdispatch_init的最后部分会调用****_os_object_init****：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line"><span class="title function_">_os_object_init</span>(<span class="params"><span class="keyword">void</span></span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="title function_">_objc_init</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><strong>_os_object_init</strong></strong>方法只有一行代码就是转调_objc_init，这就是我们十分关注的Runtime 初始化的入口。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">void <span class="constructor">_objc_init(<span class="params">void</span>)</span> &#123;</span><br><span class="line">    static <span class="built_in">bool</span> initialized = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (initialized) return;</span><br><span class="line">    initialized = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fixme defer initialization until an objc-using image is found?</span></span><br><span class="line">    environ<span class="constructor">_init()</span>;</span><br><span class="line">    tls<span class="constructor">_init()</span>;</span><br><span class="line">    static<span class="constructor">_init()</span>;</span><br><span class="line">    lock<span class="constructor">_init()</span>;</span><br><span class="line">    <span class="keyword">exception</span><span class="constructor">_init()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//_dyld_objc_notify_register(&amp;map_2_images, load_images, unmap_image);</span></span><br><span class="line">    <span class="comment">//向dyld注册了回调函数,当imagemap到内存中,当初始化完成image时和卸载image的时候都会回调注册者</span></span><br><span class="line">    <span class="constructor">_dyld_objc_notify_register(&amp;<span class="params">map_images</span>, <span class="params">load_images</span>, <span class="params">unmap_image</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><strong>_objc_init</strong></strong>向dyld注册了map_images，load_images，unmap_image三个关键的回调函数,各个关键阶段节点常量定义如下：</p>
<figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">enum</span> <span class="keyword">dyld_image_states</span></span><br><span class="line">&#123;</span><br><span class="line">    dyld_image_state_mapped                 <span class="operator">=</span> <span class="number">10</span>,       <span class="comment">// No batch notification for this</span></span><br><span class="line">    dyld_image_state_dependents_mapped      <span class="operator">=</span> <span class="number">20</span>,       <span class="comment">// Only batch notification for this</span></span><br><span class="line">    dyld_image_state_rebased                <span class="operator">=</span> <span class="number">30</span>,</span><br><span class="line">    dyld_image_state_bound                  <span class="operator">=</span> <span class="number">40</span>,</span><br><span class="line">    dyld_image_state_dependents_initialized <span class="operator">=</span> <span class="number">45</span>,       <span class="comment">// Only single notification for this</span></span><br><span class="line">    dyld_image_state_initialized            <span class="operator">=</span> <span class="number">50</span>,</span><br><span class="line">    dyld_image_state_terminated             <span class="operator">=</span> <span class="number">60</span>        <span class="comment">// Only single notification for this</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们看下****_dyld_objc_notify_register****这个方法的注释，通过注释我们可以了解到，在runtime中可以通过这个方法可以向dyld注册用于处理镜像完成映射，取消映射和初始化之后的处理方法。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">//</span><br><span class="line">// Note: <span class="keyword">only</span> <span class="keyword">for</span> use <span class="keyword">by</span> objc runtime</span><br><span class="line">// Register handlers <span class="keyword">to</span> be <span class="keyword">called</span> <span class="keyword">when</span> objc images are mapped, unmapped, <span class="keyword">and</span> initialized.</span><br><span class="line">// Dyld will <span class="keyword">call</span> back the &quot;mapped&quot; <span class="keyword">function</span> <span class="keyword">with</span> an <span class="keyword">array</span> <span class="keyword">of</span> images that contain an objc-image-<span class="keyword">info</span> section.</span><br><span class="line">// Those images that are dylibs will have the <span class="keyword">ref</span>-counts automatically bumped, so objc will <span class="keyword">no</span> longer need <span class="keyword">to</span></span><br><span class="line">// <span class="keyword">call</span> dlopen() <span class="keyword">on</span> them <span class="keyword">to</span> keep them <span class="keyword">from</span> being unloaded.  During the <span class="keyword">call</span> <span class="keyword">to</span> _dyld_objc_notify_register(),</span><br><span class="line">// dyld will <span class="keyword">call</span> the &quot;mapped&quot; <span class="keyword">function</span> <span class="keyword">with</span> already loaded objc images.  During <span class="keyword">any</span> later dlopen() <span class="keyword">call</span>,</span><br><span class="line">// dyld will <span class="keyword">also</span> <span class="keyword">call</span> the &quot;mapped&quot; <span class="keyword">function</span>.  Dyld will <span class="keyword">call</span> the &quot;init&quot; <span class="keyword">function</span> <span class="keyword">when</span> dyld would be <span class="keyword">called</span></span><br><span class="line">// initializers <span class="keyword">in</span> that image.  This <span class="keyword">is</span> <span class="keyword">when</span> objc calls <span class="keyword">any</span> +<span class="keyword">load</span> methods <span class="keyword">in</span> that image.</span><br><span class="line">// 通过这个方法可以向dyld注册用于处理镜像完成映射，取消映射和初始化之后的处理方法。</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> _dyld_objc_notify_register(_dyld_objc_notify_mapped    mapped,</span><br><span class="line">                                _dyld_objc_notify_init      init,</span><br><span class="line">                                _dyld_objc_notify_unmapped  unmapped);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们重点关注下****_dyld_objc_notify_mapped<strong><strong>以及</strong></strong>_dyld_objc_notify_init****，</p>
<ul>
<li><strong><strong>_dyld_objc_notify_mapped</strong></strong></li>
</ul>
<p><strong><strong>map_images</strong></strong>会在主程序以及其他库加载进来后调用<strong><strong>ImageLoader::setMapped</strong></strong>发出通知，调用map_images：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void ImageLoader::set<span class="constructor">Mapped(<span class="params">const</span> LinkContext&amp; <span class="params">context</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    fState = dyld_image_state_mapped;</span><br><span class="line">    context.notify<span class="constructor">Single(<span class="params">dyld_image_state_mapped</span>, <span class="params">this</span>)</span>;  <span class="comment">// note: can throw exception</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而<strong><strong>ImageLoader::setMapped</strong></strong>会在instantiateMainExecutable实例话主程序，instantiateFromFile实例化镜像的时候被调用：</p>
<ul>
<li><strong><strong>_dyld_objc_notify_init</strong></strong></li>
</ul>
<p>会在<strong><strong>ImageLoader::runInitializers</strong></strong> 方法中被调用，而<strong><strong>ImageLoader::runInitializers</strong></strong> 则会在 <strong><strong>initializeMainExecutable</strong></strong>中调用。</p>
<p>也即是说在实例化主程序或者其他dylib库的时候都会发出_dyld_objc_notify_mapped通知，这时候会调用runtime 的 map_images方法进行后续处理，在这些初始化完成的时候会发出_dyld_objc_notify_init通知调用load_images方法进行后续处理。</p>
<p>我们紧接着来看下<strong><strong>map_images</strong></strong>以及<strong><strong>load_images</strong></strong>的处理，其实在介绍分类的时候已经介绍过了map_images这里为保证整个文章的完整性再过一遍这部分内容：</p>
<ul>
<li><h5 id="map-images"><a href="#map-images" class="headerlink" title="map_images"></a><strong><strong>map_images</strong></strong></h5></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">map_images</span><span class="params">(<span class="type">unsigned</span> count, <span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> paths[],</span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="type">const</span> <span class="keyword">struct</span> mach_header * <span class="type">const</span> mhdrs[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="type">mutex_locker_t</span> <span class="title">lock</span><span class="params">(runtimeLock)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">map_images_nolock</span>(count, paths, mhdrs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> </span></span><br><span class="line"><span class="function"><span class="title">map_images_nolock</span><span class="params">(<span class="type">unsigned</span> mhCount, <span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> mhPaths[],</span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="type">const</span> <span class="keyword">struct</span> mach_header * <span class="type">const</span> mhdrs[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="keyword">if</span> (hCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//读取镜像信息</span></span><br><span class="line">        _read_images(hList, hCount, totalClasses, unoptimizedTotalClasses);</span><br><span class="line">    &#125;</span><br><span class="line">    firstTime = NO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">void _read_images(header_info **hList, uint32_t hCount, int totalClasses, int unoptimizedTotalClasses)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// =================================查找classes=================================</span></span><br><span class="line">    <span class="comment">// Discover classes. Fix up unresolved future classes. Mark bundle classes.</span></span><br><span class="line">    <span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">        <span class="comment">//从Mach-O的 __DATA区 __objc_classlist 获取所有类,并加入gdb_objc_realized_classes list中</span></span><br><span class="line">        classref_t *classlist = _getObjc2ClassList(hi, &amp;count);</span><br><span class="line">        <span class="comment">//.......</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            Class cls = (Class)classlist[i];</span><br><span class="line">            Class newCls = readClass(cls, headerIsBundle, headerIsPreoptimized);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (newCls != cls  &amp;&amp;  newCls) &#123;</span><br><span class="line">                <span class="comment">// 类被移动了但是没有被删除的情况</span></span><br><span class="line">                <span class="comment">// Class was moved but not deleted. Currently this occurs </span></span><br><span class="line">                <span class="comment">// only when the new class resolved a future class.</span></span><br><span class="line">                <span class="comment">// Non-lazily realize the class below.</span></span><br><span class="line">                resolvedFutureClasses = (Class *)realloc(resolvedFutureClasses, (resolvedFutureClassCount+<span class="number">1</span>) * sizeof(Class));</span><br><span class="line">                resolvedFutureClasses[resolvedFutureClassCount++] = newCls;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ts.<span class="built_in">log</span>(<span class="string">&quot;IMAGE TIMES: discover classes&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修复重新映射的类</span></span><br><span class="line">    <span class="comment">// Fix up remapped classes</span></span><br><span class="line">    <span class="comment">// Class list and nonlazy class list remain unremapped.</span></span><br><span class="line">    <span class="comment">// Class refs and super refs are remapped for message dispatching.</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!noClassesRemapped()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">            Class *classrefs = _getObjc2ClassRefs(hi, &amp;count);</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">                remapClassRef(&amp;classrefs[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// fixme why doesn&#x27;t test future1 catch the absence of this?</span></span><br><span class="line">            classrefs = _getObjc2SuperRefs(hi, &amp;count);</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">                remapClassRef(&amp;classrefs[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新映射类</span></span><br><span class="line">    ts.<span class="built_in">log</span>(<span class="string">&quot;IMAGE TIMES: remap classes&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Fix up @selector references</span></span><br><span class="line">    static size_t UnfixedSelectors;</span><br><span class="line">    &#123;</span><br><span class="line">        mutex_locker_t lock(selLock);</span><br><span class="line">        <span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">            <span class="function"><span class="title">if</span> (hi-&gt;</span>isPreoptimized()) continue;</span><br><span class="line">            </span><br><span class="line">            <span class="function"><span class="title">bool</span> isBundle = hi-&gt;</span>isBundle();</span><br><span class="line">            SEL *sels = _getObjc2SelectorRefs(hi, &amp;count);</span><br><span class="line">            UnfixedSelectors += count;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">                const char *<span class="keyword">name</span> = sel_cname(sels[i]);</span><br><span class="line">                <span class="comment">// 3. 注册Sel,并存储到全局变量namedSelectors的list中</span></span><br><span class="line">                sels[i] = sel_registerNameNoLock(<span class="keyword">name</span>, isBundle);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ts.<span class="built_in">log</span>(<span class="string">&quot;IMAGE TIMES: fix up selector references&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Discover protocols. Fix up protocol refs.</span></span><br><span class="line">    <span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">        extern objc_class OBJC_CLASS_$_Protocol;</span><br><span class="line">        Class cls = (Class)&amp;OBJC_CLASS_$_Protocol;</span><br><span class="line">        assert(cls);</span><br><span class="line">        NXMapTable *protocol_map = protocols();</span><br><span class="line">        <span class="function"><span class="title">bool</span> isPreoptimized = hi-&gt;</span>isPreoptimized();</span><br><span class="line">        <span class="function"><span class="title">bool</span> isBundle = hi-&gt;</span>isBundle();</span><br><span class="line">        <span class="comment">//找到所有Protocol并处理引用</span></span><br><span class="line">        protocol_t **protolist = _getObjc2ProtocolList(hi, &amp;count);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            readProtocol(protolist[i], cls, protocol_map, </span><br><span class="line">                         isPreoptimized, isBundle);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ts.<span class="built_in">log</span>(<span class="string">&quot;IMAGE TIMES: discover protocols&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Fix up @protocol references</span></span><br><span class="line">    <span class="comment">// Preoptimized images may have the right </span></span><br><span class="line">    <span class="comment">// answer already but we don&#x27;t know for sure.</span></span><br><span class="line">    <span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">        protocol_t **protolist = _getObjc2ProtocolRefs(hi, &amp;count);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            remapProtocolRef(&amp;protolist[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ts.<span class="built_in">log</span>(<span class="string">&quot;IMAGE TIMES: fix up @protocol references&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Realize non-lazy classes (for +load methods and static instances)</span></span><br><span class="line">    <span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">        classref_t *classlist = </span><br><span class="line">            _getObjc2NonlazyClassList(hi, &amp;count);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            Class cls = remapClass(classlist[i]);</span><br><span class="line">            <span class="keyword">if</span> (!cls) continue;</span><br><span class="line">            addClassTableEntry(cls);</span><br><span class="line">            realizeClass(cls);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ts.<span class="built_in">log</span>(<span class="string">&quot;IMAGE TIMES: realize non-lazy classes&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Realize newly-resolved future classes, in case CF manipulates them</span></span><br><span class="line">    <span class="keyword">if</span> (resolvedFutureClasses) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; resolvedFutureClassCount; i++) &#123;</span><br><span class="line">            realizeClass(resolvedFutureClasses[i]);</span><br><span class="line">            <span class="function"><span class="title">resolvedFutureClasses</span>[i]-&gt;</span>setInstancesRequireRawIsa(<span class="literal">false</span><span class="comment">/*inherited*/</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        free(resolvedFutureClasses);</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    ts.<span class="built_in">log</span>(<span class="string">&quot;IMAGE TIMES: realize future classes&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Discover categories. </span></span><br><span class="line">    <span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">        category_t **catlist = </span><br><span class="line">            _getObjc2CategoryList(hi, &amp;count);</span><br><span class="line">        <span class="comment">//查看是否包含属性</span></span><br><span class="line">        <span class="function"><span class="title">bool</span> hasClassProperties = hi-&gt;</span><span class="function"><span class="title">info</span>()-&gt;</span>hasCategoryClassProperties();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            category_t *cat = catlist[i];</span><br><span class="line">            <span class="comment">//获取到所属的类</span></span><br><span class="line">            C<span class="function"><span class="title">lass</span> cls = remapClass(cat-&gt;</span>cls);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!cls) &#123;</span><br><span class="line">                <span class="comment">// Category&#x27;s target class is missing (probably weak-linked).</span></span><br><span class="line">                <span class="comment">// Disavow any knowledge of this category.</span></span><br><span class="line">                catlist[i] = <span class="literal">nil</span>;</span><br><span class="line">                <span class="keyword">if</span> (PrintConnecting) &#123;</span><br><span class="line">                    _objc_inform(<span class="string">&quot;CLASS: IGNORING category \?\?\?(%s) %p with &quot;</span></span><br><span class="line">                                 <span class="string">&quot;missing weak-linked target class&quot;</span>, </span><br><span class="line">                                 <span class="function"><span class="title">cat</span>-&gt;</span><span class="keyword">name</span>, cat);</span><br><span class="line">                &#125;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Process this category. </span></span><br><span class="line">            <span class="comment">// First, register the category with its target class. </span></span><br><span class="line">            <span class="comment">// Then, rebuild the class&#x27;s method lists (etc) if </span></span><br><span class="line">            <span class="comment">// the class is realized. </span></span><br><span class="line">            bool classExists = NO;</span><br><span class="line">            <span class="comment">//如果有实例方法，协议或者实例属性</span></span><br><span class="line">            <span class="function"><span class="title">if</span> (cat-&gt;</span><span class="function"><span class="title">instanceMethods</span> ||  cat-&gt;</span>protocols  </span><br><span class="line">                ||  <span class="function"><span class="title">cat</span>-&gt;</span>instanceProperties) </span><br><span class="line">            &#123;</span><br><span class="line">                addUnattachedCategoryForClass(cat, cls, hi);</span><br><span class="line">                <span class="function"><span class="title">if</span> (cls-&gt;</span>isRealized()) &#123;</span><br><span class="line">                    <span class="comment">//将分类添到属性，方法，协议添加到对应的类中</span></span><br><span class="line">                    remethodizeClass(cls);</span><br><span class="line">                    classExists = YES;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (PrintConnecting) &#123;</span><br><span class="line">                    _objc_inform(<span class="string">&quot;CLASS: found category -%s(%s) %s&quot;</span>, </span><br><span class="line">                                 <span class="function"><span class="title">cls</span>-&gt;</span><span class="function"><span class="title">nameForLogging</span>(), cat-&gt;</span><span class="keyword">name</span>, </span><br><span class="line">                                 classExists ? <span class="string">&quot;on existing class&quot;</span> : <span class="string">&quot;&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果有类方法，协议或者类属性</span></span><br><span class="line">            <span class="function"><span class="title">if</span> (cat-&gt;</span><span class="function"><span class="title">classMethods</span>  ||  cat-&gt;</span>protocols  </span><br><span class="line">                ||  (<span class="function"><span class="title">hasClassProperties</span> &amp;&amp; cat-&gt;</span>_classProperties)) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="function"><span class="title">addUnattachedCategoryForClass</span>(cat, cls-&gt;</span>ISA(), hi);</span><br><span class="line">                <span class="function"><span class="title">if</span> (cls-&gt;</span>ISA()-&gt;isRealized()) &#123;</span><br><span class="line">                    <span class="function"><span class="title">remethodizeClass</span>(cls-&gt;</span>ISA());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (PrintConnecting) &#123;</span><br><span class="line">                    _objc_inform(<span class="string">&quot;CLASS: found category +%s(%s)&quot;</span>, </span><br><span class="line">                                 <span class="function"><span class="title">cls</span>-&gt;</span><span class="function"><span class="title">nameForLogging</span>(), cat-&gt;</span><span class="keyword">name</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ts.<span class="built_in">log</span>(<span class="string">&quot;IMAGE TIMES: discover categories&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Category discovery MUST BE LAST to avoid potential races </span></span><br><span class="line">    <span class="comment">// when other threads call the new category code before </span></span><br><span class="line">    <span class="comment">// this thread finishes its fixups.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// +load handled by prepare_load_methods()</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (DebugNonFragileIvars) &#123;</span><br><span class="line">        realizeAllClasses();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>map_images 最关键的代码在_read_images方法中，****_read_images<strong><strong>故名思议就是读取镜像，在这个方法中会从镜像的_DATA区域通过</strong></strong>_getObjc2XXXX****将该镜像的类列表，分类列表，协议列表读取出来，对应的方法以及读取的session部分可以查看如下声明，这里需要提一下_DATA区域中的这些session数据是由编译器写入的。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">//      function name                 content type     section name</span></span><br><span class="line"><span class="constructor">GETSECT(<span class="params">_getObjc2SelectorRefs</span>,        SEL,             <span class="string">&quot;__objc_selrefs&quot;</span>)</span>; </span><br><span class="line"><span class="constructor">GETSECT(<span class="params">_getObjc2MessageRefs</span>,         <span class="params">message_ref_t</span>,   <span class="string">&quot;__objc_msgrefs&quot;</span>)</span>; </span><br><span class="line"><span class="constructor">GETSECT(<span class="params">_getObjc2ClassRefs</span>,           Class,           <span class="string">&quot;__objc_classrefs&quot;</span>)</span>;</span><br><span class="line"><span class="constructor">GETSECT(<span class="params">_getObjc2SuperRefs</span>,           Class,           <span class="string">&quot;__objc_superrefs&quot;</span>)</span>;</span><br><span class="line"><span class="constructor">GETSECT(<span class="params">_getObjc2ClassList</span>,           <span class="params">classref_t</span>,      <span class="string">&quot;__objc_classlist&quot;</span>)</span>;</span><br><span class="line"><span class="constructor">GETSECT(<span class="params">_getObjc2NonlazyClassList</span>,    <span class="params">classref_t</span>,      <span class="string">&quot;__objc_nlclslist&quot;</span>)</span>;</span><br><span class="line"><span class="constructor">GETSECT(<span class="params">_getObjc2CategoryList</span>,        <span class="params">category_t</span> <span class="operator">*</span>,    <span class="string">&quot;__objc_catlist&quot;</span>)</span>;</span><br><span class="line"><span class="constructor">GETSECT(<span class="params">_getObjc2NonlazyCategoryList</span>, <span class="params">category_t</span> <span class="operator">*</span>,    <span class="string">&quot;__objc_nlcatlist&quot;</span>)</span>;</span><br><span class="line"><span class="constructor">GETSECT(<span class="params">_getObjc2ProtocolList</span>,        <span class="params">protocol_t</span> <span class="operator">*</span>,    <span class="string">&quot;__objc_protolist&quot;</span>)</span>;</span><br><span class="line"><span class="constructor">GETSECT(<span class="params">_getObjc2ProtocolRefs</span>,        <span class="params">protocol_t</span> <span class="operator">*</span>,    <span class="string">&quot;__objc_protorefs&quot;</span>)</span>;</span><br><span class="line"><span class="constructor">GETSECT(<span class="params">getLibobjcInitializers</span>,       UnsignedInitializer, <span class="string">&quot;__objc_init_func&quot;</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>这个方法的每个阶段结束都会调用ts.log(“IMAGE TIMES:XXXXXX)来提示每个阶段结束，在这些阶段中有我们之前分析过的Catogies 加载，以及协议加载。我们重点看下最末尾的realizeAllClasses方法：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">static void realize<span class="constructor">AllClasses(<span class="params">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    runtimeLock.<span class="keyword">assert</span><span class="constructor">Locked()</span>;</span><br><span class="line">    header_info *hi;</span><br><span class="line">    <span class="keyword">for</span> (hi = FirstHeader; hi; hi = hi-&gt;get<span class="constructor">Next()</span>) &#123;</span><br><span class="line">        realize<span class="constructor">AllClassesInImage(<span class="params">hi</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">static void realize<span class="constructor">AllClassesInImage(<span class="params">header_info</span> <span class="operator">*</span><span class="params">hi</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">    runtimeLock.<span class="keyword">assert</span><span class="constructor">Locked()</span>;</span><br><span class="line"></span><br><span class="line">    size_t count, i;</span><br><span class="line">    classref_t *classlist;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hi-&gt;are<span class="constructor">AllClassesRealized()</span>) return;</span><br><span class="line"></span><br><span class="line">    classlist = <span class="constructor">_getObjc2ClassList(<span class="params">hi</span>, &amp;<span class="params">count</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        realize<span class="constructor">Class(<span class="params">remapClass</span>(<span class="params">classlist</span>[<span class="params">i</span>])</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    hi-&gt;set<span class="constructor">AllClassesRealized(YES)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>realizeAllClasses会对镜像中的所有class调用realizeClass方法。</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">static Class realizeClass(Class cls) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line">    const class_ro_t *ro;</span><br><span class="line">    class_rw_t *rw;</span><br><span class="line">    Class supercls;</span><br><span class="line">    Class metacls;</span><br><span class="line">    bool isMeta;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!cls) return <span class="literal">nil</span>;               <span class="comment">//cls 不能为空</span></span><br><span class="line">    <span class="function"><span class="title">if</span> (cls-&gt;</span>isRealized()) return cls;  <span class="comment">//cls 如果已经初始化直接返回</span></span><br><span class="line">    assert(cls == remapClass(cls));     <span class="comment">//cls 没有重新分配，remapClass 返回指向cls的实时指针</span></span><br><span class="line">    <span class="comment">// 【✨】获取只读结构体</span></span><br><span class="line">    <span class="function"><span class="title">ro</span> = (const class_ro_t *)cls-&gt;</span><span class="keyword">data</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Normal class. Allocate writeable class data.</span></span><br><span class="line">    rw = (class_rw_t *)calloc(sizeof(class_rw_t), <span class="number">1</span>);           <span class="comment">//分配读写数据</span></span><br><span class="line">    <span class="function"><span class="title">rw</span>-&gt;</span>ro = ro;                                                <span class="comment">//只写数据</span></span><br><span class="line">    <span class="function"><span class="title">rw</span>-&gt;</span>flags = RW_REALIZED|RW_REALIZING;                       <span class="comment">//设置已经初始化标志</span></span><br><span class="line">    <span class="function"><span class="title">cls</span>-&gt;</span>setData(rw);                                           <span class="comment">//为cls设置data数据</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">isMeta</span> = ro-&gt;</span>flags &amp; RO_META;                                   <span class="comment">//判断是否是元类</span></span><br><span class="line">    <span class="function"><span class="title">rw</span>-&gt;</span>version = isMeta ? <span class="number">7</span> : <span class="number">0</span>;  <span class="comment">// old runtime went up to 6      //版本信息，旧版本的版本信息为6</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line">    <span class="comment">// Realize superclass and metaclass, if they aren&#x27;t already.</span></span><br><span class="line">    <span class="comment">// This needs to be done after RW_REALIZED is set above, for root classes.</span></span><br><span class="line">    <span class="comment">// This needs to be done after class index is chosen, for root metaclasses.</span></span><br><span class="line">    <span class="comment">// 【✨】为supercls，metacls 分配空间</span></span><br><span class="line">    <span class="function"><span class="title">supercls</span> = realizeClass(remapClass(cls-&gt;</span>superclass));</span><br><span class="line">    <span class="function"><span class="title">metacls</span> = realizeClass(remapClass(cls-&gt;</span>ISA()));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 【✨】 Update superclass and metaclass in case of remapping</span></span><br><span class="line">    <span class="function"><span class="title">cls</span>-&gt;</span><span class="function"><span class="title">superclass</span> = supercls; //将supercls赋给 cls-&gt;</span>superclass</span><br><span class="line">    <span class="comment">//将上面分配的metacls赋给cls</span></span><br><span class="line">    <span class="function"><span class="title">cls</span>-&gt;</span>initClassIsa(metacls);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调整实例变量的偏移和布局，这个将会重新分配class_ro_t</span></span><br><span class="line">    <span class="comment">// Reconcile instance variable offsets / layout.</span></span><br><span class="line">    <span class="comment">// This may reallocate class_ro_t, updating our ro variable.</span></span><br><span class="line">    <span class="keyword">if</span> (supercls  &amp;&amp;  !isMeta) reconcileInstanceVariables(cls, supercls, ro);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置对象尺寸</span></span><br><span class="line">    <span class="comment">// Set fastInstanceSize if it wasn&#x27;t set already.</span></span><br><span class="line">    <span class="function"><span class="title">cls</span>-&gt;</span><span class="function"><span class="title">setInstanceSize</span>(ro-&gt;</span>instanceSize);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【✨】从ro中拷贝部分标志位到rw 字段</span></span><br><span class="line">    <span class="comment">// Copy some flags from ro to rw</span></span><br><span class="line">    <span class="function"><span class="title">if</span> (ro-&gt;</span>flags &amp; RO_HAS_CXX_STRUCTORS) &#123;</span><br><span class="line">        <span class="function"><span class="title">cls</span>-&gt;</span>setHasCxxDtor();</span><br><span class="line">        <span class="function"><span class="title">if</span> (! (ro-&gt;</span>flags &amp; RO_HAS_CXX_DTOR_ONLY)) &#123;</span><br><span class="line">            <span class="function"><span class="title">cls</span>-&gt;</span>setHasCxxCtor();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 【✨】 Connect this class to its superclass&#x27;s subclass lists</span></span><br><span class="line">    <span class="comment">// 将当前class与父类相关连</span></span><br><span class="line">    <span class="keyword">if</span> (supercls) &#123;</span><br><span class="line">        <span class="comment">//将当前类作为supercls的子类添加到父类的子类列表</span></span><br><span class="line">        addSubclass(supercls, cls);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//将当前类作为根类</span></span><br><span class="line">        addRootClass(cls);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【✨】实例化类结构</span></span><br><span class="line">    <span class="comment">// Attach categories</span></span><br><span class="line">    <span class="comment">// 使得类有条理</span></span><br><span class="line">    methodizeClass(cls);</span><br><span class="line"></span><br><span class="line">    return cls;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>realizeClass 方法实际上是为类的class_rw_t，superclass，metacls等分配空间，并初始化。在最后的时候会调用methodizeClass进行进一步的初始化：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">static void methodize<span class="constructor">Class(Class <span class="params">cls</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//检查锁</span></span><br><span class="line">    runtimeLock.<span class="keyword">assert</span><span class="constructor">Locked()</span>;</span><br><span class="line">    <span class="comment">//是否是元类</span></span><br><span class="line">    <span class="built_in">bool</span> isMeta = cls-&gt;is<span class="constructor">MetaClass()</span>;</span><br><span class="line">    <span class="comment">//获取可读写字段</span></span><br><span class="line">    auto rw = cls-&gt;data<span class="literal">()</span>;</span><br><span class="line">    <span class="comment">//获取只读字段</span></span><br><span class="line">    auto ro = rw-&gt;ro;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Install methods and properties that the class implements itself.</span></span><br><span class="line">    <span class="comment">// 加载类自身实现的方法和属性</span></span><br><span class="line">    method_list_t *<span class="built_in">list</span> = ro-&gt;base<span class="constructor">Methods()</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span>) &#123;</span><br><span class="line">        prepare<span class="constructor">MethodLists(<span class="params">cls</span>, &amp;<span class="params">list</span><span class="operator">/</span><span class="operator">*</span>自身实现的方法列表<span class="operator">*</span><span class="operator">/</span>, 1, YES, <span class="params">isBundleClass</span>(<span class="params">cls</span>)</span>);</span><br><span class="line">        <span class="comment">//将ro-&gt;baseMethods方法添加到rw-&gt;methods</span></span><br><span class="line">        rw-&gt;methods.attach<span class="constructor">Lists(&amp;<span class="params">list</span>, 1)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    property_list_t *proplist = ro-&gt;baseProperties;</span><br><span class="line">    <span class="keyword">if</span> (proplist) &#123;</span><br><span class="line">        <span class="comment">//将ro-&gt;baseProperties方法添加到rw-&gt;properties</span></span><br><span class="line">        rw-&gt;properties.attach<span class="constructor">Lists(&amp;<span class="params">proplist</span>, 1)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protocol_list_t *protolist = ro-&gt;baseProtocols;</span><br><span class="line">    <span class="keyword">if</span> (protolist) &#123;</span><br><span class="line">        <span class="comment">//将ro-&gt;baseProtocols方法添加到rw-&gt;protocols</span></span><br><span class="line">        rw-&gt;protocols.attach<span class="constructor">Lists(&amp;<span class="params">protolist</span>, 1)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Root classes get bonus method implementations if they don&#x27;t have </span></span><br><span class="line">    <span class="comment">// them already. These apply before category replacements.</span></span><br><span class="line">    <span class="keyword">if</span> (cls-&gt;is<span class="constructor">RootMetaclass()</span>) &#123;</span><br><span class="line">        <span class="comment">// root metaclass</span></span><br><span class="line">        add<span class="constructor">Method(<span class="params">cls</span>, SEL_initialize, (IMP)</span>&amp;objc_noop_imp, <span class="string">&quot;&quot;</span>, NO);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Attach categories.</span></span><br><span class="line">    <span class="comment">// 获取未添加的分类</span></span><br><span class="line">    category_list *cats = unattached<span class="constructor">CategoriesForClass(<span class="params">cls</span>, <span class="params">true</span> <span class="operator">/</span><span class="operator">*</span><span class="params">realizing</span><span class="operator">*</span><span class="operator">/</span>)</span>;</span><br><span class="line">    <span class="comment">// 添加分类</span></span><br><span class="line">    attach<span class="constructor">Categories(<span class="params">cls</span>, <span class="params">cats</span>, <span class="params">false</span> <span class="operator">/</span><span class="operator">*</span><span class="params">don</span>&#x27;<span class="params">t</span> <span class="params">flush</span> <span class="params">caches</span><span class="operator">*</span><span class="operator">/</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (cats) free(cats);</span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>methodizeClass方法则进一步初始化rw，这一步将ro中的属性，协议，方法拷贝到rw，以及将分类中对应的属性，协议，方法也拷贝到class中的rw对应字段。</p>
<p>回顾整个map_image阶段就是在镜像实例话结束后，通过读取_DATA中的指定session数据，来读出整个镜像中各个class的关键数据，并构建objc_class数据结构对象，通过从_DATA中读取的数据来填充objc_class来完成整个类的实例化。</p>
<ul>
<li><h5 id="load-images"><a href="#load-images" class="headerlink" title="load_images"></a><strong><strong>load_images</strong></strong></h5></li>
</ul>
<p>load方法是我们在日常开发中可以接触到的调用时间最靠前的方法，它的调用不是惰性的，在主函数运行之前，load 方法就会调用，并且它只会在程序调用期间调用一次，最重要的是，如果在类与分类中都实现了 load 方法，它们都会被调用，<br>不像其它的在分类中实现的方法会被覆盖，但是在使用load方法的时候需要注意，由于load方法的运行时间过早，所以可能不是一个理想的环境，因为它不能保证某些类可能需要在在其它类之前加载，但是在这个时间点，所有的 framework 都已经加载到了运行时中，所以调用 framework 中的方法都是安全的，同时需要注意的是重载Class 的 +load 方法时不能调父类super，我们来看下这部分逻辑：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void</span><br><span class="line">load<span class="constructor">_images(<span class="params">const</span> <span class="params">char</span> <span class="operator">*</span><span class="params">path</span> <span class="params">__unused</span>, <span class="params">const</span> <span class="params">struct</span> <span class="params">mach_header</span> <span class="operator">*</span><span class="params">mh</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="comment">// Discover load methods</span></span><br><span class="line">    &#123;</span><br><span class="line">        mutex_locker_t lock2(runtimeLock);</span><br><span class="line">        <span class="comment">//prepare_load_methods方法中对load方法进行了前期准备</span></span><br><span class="line">        prepare<span class="constructor">_load_methods((<span class="params">const</span> <span class="params">headerType</span> <span class="operator">*</span>)</span>mh);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用+load方法</span></span><br><span class="line">    <span class="comment">// Call +load methods (without runtimeLock - re-entrant)</span></span><br><span class="line">    call<span class="constructor">_load_methods()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>load_images 方法中主要调用了prepare_load_methods 以及 call_load_methods</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void prepare<span class="constructor">_load_methods(<span class="params">const</span> <span class="params">headerType</span> <span class="operator">*</span><span class="params">mhdr</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">    <span class="comment">//获取类</span></span><br><span class="line">    classref_t *classlist = </span><br><span class="line">        <span class="constructor">_getObjc2NonlazyClassList(<span class="params">mhdr</span>, &amp;<span class="params">count</span>)</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        schedule<span class="constructor">_class_load(<span class="params">remapClass</span>(<span class="params">classlist</span>[<span class="params">i</span>])</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加分类</span></span><br><span class="line">    category_t **categorylist = <span class="constructor">_getObjc2NonlazyCategoryList(<span class="params">mhdr</span>, &amp;<span class="params">count</span>)</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        category_t *cat = categorylist<span class="literal">[<span class="identifier">i</span>]</span>;</span><br><span class="line">        Class cls = remap<span class="constructor">Class(<span class="params">cat</span>-&gt;<span class="params">cls</span>)</span>;</span><br><span class="line">        <span class="keyword">if</span> (!cls) continue;  <span class="comment">// category for ignored weak-linked class</span></span><br><span class="line">        realize<span class="constructor">Class(<span class="params">cls</span>)</span>;</span><br><span class="line">        <span class="keyword">assert</span>(cls-&gt;<span class="constructor">ISA()</span>-&gt;is<span class="constructor">Realized()</span>);</span><br><span class="line">        add<span class="constructor">_category_to_loadable_list(<span class="params">cat</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">static void <span class="built_in">schedule_class_load</span>(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    if (!cls) return;</span><br><span class="line">    <span class="built_in">assert</span>(cls-&gt;isRealized());  <span class="comment">// _read_images should realize</span></span><br><span class="line"></span><br><span class="line">    if (cls-&gt;data()-&gt;flags &amp; RW_LOADED) return;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//先加载父类</span></span><br><span class="line">    <span class="comment">// Ensure superclass-first ordering</span></span><br><span class="line">    <span class="comment">//分析这段代码，可以知道，在将子类添加到加载列表之前，其父类一定会优先加载到列表中。</span></span><br><span class="line">    <span class="comment">//这也是为何父类的+load方法在子类的+load方法之前调用的根本原因。</span></span><br><span class="line">    <span class="built_in">schedule_class_load</span>(cls-&gt;superclass);</span><br><span class="line">    <span class="comment">//将类添加到可加载列表</span></span><br><span class="line">    <span class="built_in">add_class_to_loadable_list</span>(cls);</span><br><span class="line">    cls-&gt;<span class="built_in">setInfo</span>(RW_LOADED); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>prepare_load_methods 以及 schedule_class_load方法会按照父类，子类，分类的顺序将需要调用load方法的class添加到loadable_list中去</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void add<span class="constructor">_class_to_loadable_list(Class <span class="params">cls</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    IMP <span class="keyword">method</span>;</span><br><span class="line"></span><br><span class="line">    loadMethodLock.<span class="keyword">assert</span><span class="constructor">Locked()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//该类是否有load方法</span></span><br><span class="line">    <span class="keyword">method</span> = cls-&gt;get<span class="constructor">LoadMethod()</span>;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">method</span>) return;  <span class="comment">// Don&#x27;t bother if cls has no +load method</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//........</span></span><br><span class="line">    <span class="keyword">if</span> (loadable_classes_used<span class="operator"> == </span>loadable_classes_allocated) &#123;</span><br><span class="line">        loadable_classes_allocated = loadable_classes_allocated*<span class="number">2</span> + <span class="number">16</span>;</span><br><span class="line">        loadable_classes = (<span class="keyword">struct</span> loadable_class *)</span><br><span class="line">            realloc(loadable_classes,</span><br><span class="line">                              loadable_classes_allocated<span class="operator"> *</span></span><br><span class="line"><span class="operator">                              </span>sizeof(<span class="keyword">struct</span> loadable_class));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    loadable_classes<span class="literal">[<span class="identifier">loadable_classes_used</span>]</span>.cls = cls;</span><br><span class="line">    loadable_classes<span class="literal">[<span class="identifier">loadable_classes_used</span>]</span>.<span class="keyword">method</span> = <span class="keyword">method</span>;</span><br><span class="line">    loadable_classes_used++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void add<span class="constructor">_category_to_loadable_list(Category <span class="params">cat</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    IMP <span class="keyword">method</span>;</span><br><span class="line"></span><br><span class="line">    loadMethodLock.<span class="keyword">assert</span><span class="constructor">Locked()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//该分类是否有load方法</span></span><br><span class="line">    <span class="keyword">method</span> = <span class="constructor">_category_getLoadMethod(<span class="params">cat</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">method</span>) return;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (loadable_categories_used<span class="operator"> == </span>loadable_categories_allocated) &#123;</span><br><span class="line">        loadable_categories_allocated = loadable_categories_allocated*<span class="number">2</span> + <span class="number">16</span>;</span><br><span class="line">        loadable_categories = (<span class="keyword">struct</span> loadable_category *)</span><br><span class="line">            realloc(loadable_categories,</span><br><span class="line">                              loadable_categories_allocated<span class="operator"> *</span></span><br><span class="line"><span class="operator">                              </span>sizeof(<span class="keyword">struct</span> loadable_category));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    loadable_categories<span class="literal">[<span class="identifier">loadable_categories_used</span>]</span>.cat = cat;</span><br><span class="line">    loadable_categories<span class="literal">[<span class="identifier">loadable_categories_used</span>]</span>.<span class="keyword">method</span> = <span class="keyword">method</span>;</span><br><span class="line">    loadable_categories_used++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用类以及分类中的load方法</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">/<span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">**<span class="emphasis">*</span></span></span><br><span class="line"><span class="emphasis"><span class="strong">*</span> call<span class="emphasis">_load_</span>methods</span></span><br><span class="line"><span class="strong"><span class="emphasis">* Call all pending class and category +load methods.</span></span></span><br><span class="line"><span class="emphasis"><span class="strong">*</span> Class +load methods are called superclass-first. </span></span><br><span class="line"><span class="strong"><span class="emphasis">* Category +load methods are not called until after the parent class&#x27;s +load.</span></span></span><br><span class="line"><span class="emphasis"><span class="strong">*</span> </span></span><br><span class="line"><span class="strong"><span class="emphasis">* This method must be RE-ENTRANT, because a +load could trigger </span></span></span><br><span class="line"><span class="emphasis"><span class="strong">*</span> more image mapping. In addition, the superclass-first ordering </span></span><br><span class="line"><span class="strong"><span class="emphasis">* must be preserved in the face of re-entrant calls. Therefore, </span></span></span><br><span class="line"><span class="emphasis"><span class="strong">*</span> only the OUTERMOST call of this function will do anything, and </span></span><br><span class="line"><span class="strong"><span class="emphasis">* that call will handle all loadable classes, even those generated </span></span></span><br><span class="line"><span class="emphasis"><span class="strong">*</span> while it was running.</span></span><br><span class="line"><span class="strong"><span class="emphasis">*</span></span></span><br><span class="line"><span class="emphasis"><span class="strong">*</span> The sequence below preserves +load ordering in the face of </span></span><br><span class="line"><span class="strong"><span class="emphasis">* image loading during a +load, and make sure that no </span></span></span><br><span class="line"><span class="emphasis"><span class="strong">*</span> +load method is forgotten because it was added during </span></span><br><span class="line"><span class="strong"><span class="emphasis">* a +load call.</span></span></span><br><span class="line"><span class="emphasis"><span class="strong">*</span> Sequence:</span></span><br><span class="line"><span class="strong"><span class="emphasis">* 1. Repeatedly call class +loads until there aren&#x27;t any more</span></span></span><br><span class="line"><span class="emphasis"><span class="strong">*</span> 2. Call category +loads ONCE.</span></span><br><span class="line"><span class="strong"><span class="emphasis">* 3. Run more +loads if:</span></span></span><br><span class="line"><span class="emphasis"><span class="strong">*</span>    (a) there are more classes to load, OR</span></span><br><span class="line"><span class="strong"><span class="emphasis">*    (b) there are some potential category +loads that have </span></span></span><br><span class="line"><span class="emphasis"><span class="strong">*</span>        still never been attempted.</span></span><br><span class="line"><span class="strong"><span class="emphasis">* Category +loads are only run once to ensure &quot;parent class first&quot; </span></span></span><br><span class="line"><span class="emphasis"><span class="strong">*</span> ordering, even if a category +load triggers a new loadable class </span></span><br><span class="line"><span class="strong"><span class="emphasis">* and a new loadable category attached to that class. </span></span></span><br><span class="line"><span class="emphasis"><span class="strong">*</span></span></span><br><span class="line"><span class="strong"><span class="emphasis">* Locking: loadMethodLock must be held by the caller </span></span></span><br><span class="line"><span class="emphasis"><span class="strong">*</span>   All other locks must not be held.</span></span><br><span class="line"><span class="strong">**</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span>/</span><br><span class="line">void call<span class="emphasis">_load_</span>methods(void)</span><br><span class="line">&#123;</span><br><span class="line"><span class="code">    static bool loading = NO;</span></span><br><span class="line"><span class="code">    bool more_categories;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">    loadMethodLock.assertLocked();</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">    // Re-entrant calls do nothing; the outermost call will finish the job.</span></span><br><span class="line"><span class="code">    if (loading) return;</span></span><br><span class="line"><span class="code">    loading = YES;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">    void *pool = objc_autoreleasePoolPush();</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">    do &#123;</span></span><br><span class="line"><span class="code">        // 1. Repeatedly call class +loads until there aren&#x27;t any more</span></span><br><span class="line"><span class="code">        while (loadable_classes_used &gt; 0) &#123;</span></span><br><span class="line"><span class="code">            //调用类的load方法</span></span><br><span class="line"><span class="code">            call_class_loads();</span></span><br><span class="line"><span class="code">        &#125;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">        // 2. Call category +loads ONCE</span></span><br><span class="line"><span class="code">        //调用分类的load方法</span></span><br><span class="line"><span class="code">        more_categories = call_category_loads();</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">        // 3. Run more +loads if there are classes OR more untried categories</span></span><br><span class="line"><span class="code">    &#125; while (loadable_classes_used &gt; 0  ||  more_categories);</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">    objc_autoreleasePoolPop(pool);</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">    loading = NO;</span></span><br><span class="line"><span class="code">&#125;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">call_class_loads</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Detach current loadable list.</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">loadable_class</span> *classes = loadable_classes;<span class="comment">/*这是preppare阶段构造的*/</span></span><br><span class="line">    <span class="type">int</span> used = loadable_classes_used;</span><br><span class="line">    loadable_classes = nil;</span><br><span class="line">    loadable_classes_allocated = <span class="number">0</span>;</span><br><span class="line">    loadable_classes_used = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Call all +loads for the detached list.</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; used; i++) &#123;</span><br><span class="line">        Class cls = classes[i].cls;</span><br><span class="line"></span><br><span class="line">        <span class="type">load_method_t</span> load_method = (<span class="type">load_method_t</span>)classes[i].method;</span><br><span class="line">        <span class="keyword">if</span> (!cls) <span class="keyword">continue</span>; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (PrintLoading) &#123;</span><br><span class="line">            _objc_inform(<span class="string">&quot;LOAD: +[%s load]\n&quot;</span>, cls-&gt;<span class="built_in">nameForLogging</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//调用+load方法</span></span><br><span class="line">        (*load_method)(cls, SEL_load);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Destroy the detached list.</span></span><br><span class="line">    <span class="keyword">if</span> (classes) <span class="built_in">free</span>(classes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">call_category_loads</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, shift;</span><br><span class="line">    <span class="type">bool</span> new_categories_added = NO;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Detach current loadable list.</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">loadable_category</span> *cats = loadable_categories;<span class="comment">/*数据来源 在prepare阶段构建*/</span></span><br><span class="line">    <span class="type">int</span> used = loadable_categories_used;</span><br><span class="line">    <span class="type">int</span> allocated = loadable_categories_allocated;</span><br><span class="line">    loadable_categories = nil;</span><br><span class="line">    loadable_categories_allocated = <span class="number">0</span>;</span><br><span class="line">    loadable_categories_used = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Call all +loads for the detached list.</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; used; i++) &#123;</span><br><span class="line">        Category cat = cats[i].cat;</span><br><span class="line">        <span class="type">load_method_t</span> load_method = (<span class="type">load_method_t</span>)cats[i].method;</span><br><span class="line">        Class cls;</span><br><span class="line">        <span class="keyword">if</span> (!cat) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        cls = _category_getClass(cat);</span><br><span class="line">        <span class="keyword">if</span> (cls  &amp;&amp;  cls-&gt;<span class="built_in">isLoadable</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (PrintLoading) &#123;</span><br><span class="line">                _objc_inform(<span class="string">&quot;LOAD: +[%s(%s) load]\n&quot;</span>, </span><br><span class="line">                             cls-&gt;<span class="built_in">nameForLogging</span>(), </span><br><span class="line">                             _category_getName(cat));</span><br><span class="line">            &#125;</span><br><span class="line">            (*load_method)(cls, SEL_load);</span><br><span class="line">            cats[i].cat = nil;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Compact detached list (order-preserving)</span></span><br><span class="line">    shift = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; used; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cats[i].cat) &#123;</span><br><span class="line">            cats[i-shift] = cats[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            shift++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    used -= shift;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy any new +load candidates from the new list to the detached list.</span></span><br><span class="line">    new_categories_added = (loadable_categories_used &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; loadable_categories_used; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (used == allocated) &#123;</span><br><span class="line">            allocated = allocated*<span class="number">2</span> + <span class="number">16</span>;</span><br><span class="line">            cats = (<span class="keyword">struct</span> loadable_category *)</span><br><span class="line">                <span class="built_in">realloc</span>(cats, allocated *</span><br><span class="line">                                  <span class="built_in">sizeof</span>(<span class="keyword">struct</span> loadable_category));</span><br><span class="line">        &#125;</span><br><span class="line">        cats[used++] = loadable_categories[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Destroy the new list.</span></span><br><span class="line">    <span class="keyword">if</span> (loadable_categories) <span class="built_in">free</span>(loadable_categories);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Reattach the (now augmented) detached list. </span></span><br><span class="line">    <span class="comment">// But if there&#x27;s nothing left to load, destroy the list.</span></span><br><span class="line">    <span class="keyword">if</span> (used) &#123;</span><br><span class="line">        loadable_categories = cats;</span><br><span class="line">        loadable_categories_used = used;</span><br><span class="line">        loadable_categories_allocated = allocated;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (cats) <span class="built_in">free</span>(cats);</span><br><span class="line">        loadable_categories = nil;</span><br><span class="line">        loadable_categories_used = <span class="number">0</span>;</span><br><span class="line">        loadable_categories_allocated = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (PrintLoading) &#123;</span><br><span class="line">        <span class="keyword">if</span> (loadable_categories_used != <span class="number">0</span>) &#123;</span><br><span class="line">            _objc_inform(<span class="string">&quot;LOAD: %d categories still waiting for +load\n&quot;</span>,</span><br><span class="line">                         loadable_categories_used);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> new_categories_added;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们在这篇博客的最后对整个过程进行一个简单的总结：</p>
<p>在应用启动的时候会从镜像中查找dyld的地址，而后将dyld加载进来，找到dyld的入口地址__dyld_start,并将后续工作交给 dyld 负责：</p>
<ol>
<li>dyld 开始将程序二进制文件实例化为一个ImageLoader</li>
<li>交由 ImageLoader 读取 image 其中包含了我们的类、方法等各种符号，以及根据Mach-O的Load Commands段加载所有依赖的动态库并完成链接，初始化工作。在主程序初始化阶段，runtime会向dyld绑定回调。</li>
<li>当image加载到内存后，dyld 会通知 runtime 进行处理，runtime 接手后调用 map_images 做解析和处理，接下来 load_images 中调用 call_load_methods 方法，<br>遍历所有加载进来的 Class，按继承层级依次调用 Class 的 +load 方法和其 Category 的 +load 方法</li>
<li>当map_images以及load_images执行完毕之后可执行文件中和动态库所有的符号（Class，Protocol，Selector，IMP，…）都已经按格式成功加载到内存中，被 runtime 所管理。</li>
<li>所有初始化工作结束后，dyld 调用真正的 main 函数，紧接着dyld 会清理现场，将调用栈回归，只剩下main函数。</li>
</ol>
  
	</div>
		<footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Objective-C-%E7%9B%B8%E5%85%B3/">Objective C 相关</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/Objective-C-相关/">Objective C 相关</a>
  </div>

</div>



</footer>

   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2020/02/02/iOS-Runtime源码解析消息处理/" title="iOS Runtime源码解析消息处理">
  <span>
  iOS Runtime源码解析消息处理</span>
</a>
</div>


<div class="next">
<a href="/2020/02/02/iOS-Runtime源码解析重要的数据结构介绍/"  title="iOS Runtime源码解析重要的数据结构介绍">
 <span>iOS Runtime源码解析重要的数据结构介绍
</span>
</a>
</div>

</nav>

	
<section id="comments" class="comment">
	<div class="ds-thread" data-thread-key="2020/02/02/iOS-Runtime源码解析-Runtime初始化/" data-title="iOS Runtime源码解析 Runtime初始化" data-url="http://yoursite.com/2020/02/02/iOS-Runtime%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-Runtime%E5%88%9D%E5%A7%8B%E5%8C%96/"></div>
</section>


<section id="comments" class="comment">
  <div id="disqus_thread">
    <noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  </div>
</section>

</div>  
      <div class="openaside"><a class="navbutton" href="#" title="Show Sidebar"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">Contents</strong>
 
 <ol class="toc"><li class="toc-item toc-level-5"><a class="toc-link" href="#map-images"><span class="toc-number">1.</span> <span class="toc-text">map_images</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#load-images"><span class="toc-number">2.</span> <span class="toc-text">load_images</span></a></li></ol>
 
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="Hide Sidebar"></a></div>
<aside class="clearfix">
<div id="authorInfo">
	
		<div class="author-img"></div>		
	
	<div class="social-info" class="clearfix">
		
		
		<a href="https://github.com/tbfungeek" target="_blank" class="icon-github" title="github"></a>
		
		
		
		
		
		
		
		
		
		
		<a href="mailto:tbfungeek@163.com" target="_blank" class="icon-email" title="Email Me"></a>
		

	</div>
</div>

  
<div class="categorieslist">
	<p class="asidetitle">Categories</p>
		<ul>
		
		  
			<li><a href="/categories/Android-小经验/" title="Android 小经验">Android 小经验<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Android-源码分析/" title="Android 源码分析">Android 源码分析<sup>21</sup></a></li>
		  
		
		  
			<li><a href="/categories/Android其他/" title="Android其他">Android其他<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Android初步/" title="Android初步">Android初步<sup>21</sup></a></li>
		  
		
		  
			<li><a href="/categories/Android进阶/" title="Android进阶">Android进阶<sup>100</sup></a></li>
		  
		
		  
			<li><a href="/categories/Hexo-使用/" title="Hexo 使用">Hexo 使用<sup>10</sup></a></li>
		  
		
		  
			<li><a href="/categories/JavaScript理论/" title="JavaScript理论">JavaScript理论<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Objective-C-相关/" title="Objective C 相关">Objective C 相关<sup>24</sup></a></li>
		  
		
		  
			<li><a href="/categories/OpenCV/" title="OpenCV">OpenCV<sup>6</sup></a></li>
		  
		
		  
			<li><a href="/categories/ROS/" title="ROS">ROS<sup>9</sup></a></li>
		  
		
		  
			<li><a href="/categories/iOS-工具使用/" title="iOS 工具使用">iOS 工具使用<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/iOS-开源库分析/" title="iOS 开源库分析">iOS 开源库分析<sup>36</sup></a></li>
		  
		
		  
			<li><a href="/categories/iOS-理论基础/" title="iOS 理论基础">iOS 理论基础<sup>14</sup></a></li>
		  
		
		  
			<li><a href="/categories/iOS-进阶/" title="iOS 进阶">iOS 进阶<sup>4</sup></a></li>
		  
		
		  
			<li><a href="/categories/个人收藏/" title="个人收藏">个人收藏<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/代码规范/" title="代码规范">代码规范<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/其他/" title="其他">其他<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/博客分类目录/" title="博客分类目录">博客分类目录<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/叨叨系列/" title="叨叨系列">叨叨系列<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/开源代码分析/" title="开源代码分析">开源代码分析<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/开源库分析/" title="开源库分析">开源库分析<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/树莓派/" title="树莓派">树莓派<sup>4</sup></a></li>
		  
		
		  
			<li><a href="/categories/版本控制/" title="版本控制">版本控制<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/直播/" title="直播">直播<sup>6</sup></a></li>
		  
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">Tags</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/iOS-开源库分析/" title="iOS 开源库分析">iOS 开源库分析<sup>36</sup></a></li>
			
		
			
				<li><a href="/tags/Android-设计模式/" title="Android 设计模式">Android 设计模式<sup>29</sup></a></li>
			
		
			
				<li><a href="/tags/Objective-C-相关/" title="Objective C 相关">Objective C 相关<sup>24</sup></a></li>
			
		
			
				<li><a href="/tags/Android基础/" title="Android基础">Android基础<sup>21</sup></a></li>
			
		
			
				<li><a href="/tags/AOSP-源码/" title="AOSP 源码">AOSP 源码<sup>17</sup></a></li>
			
		
			
				<li><a href="/tags/Android-常用第三方库/" title="Android 常用第三方库">Android 常用第三方库<sup>15</sup></a></li>
			
		
			
				<li><a href="/tags/iOS-理论基础/" title="iOS 理论基础">iOS 理论基础<sup>14</sup></a></li>
			
		
			
				<li><a href="/tags/Hexo-使用/" title="Hexo 使用">Hexo 使用<sup>10</sup></a></li>
			
		
			
				<li><a href="/tags/ROS/" title="ROS">ROS<sup>9</sup></a></li>
			
		
			
				<li><a href="/tags/Android-动画进阶/" title="Android 动画进阶">Android 动画进阶<sup>8</sup></a></li>
			
		
			
				<li><a href="/tags/Android-JNI/" title="Android JNI">Android JNI<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/Android-绘图进阶/" title="Android 绘图进阶">Android 绘图进阶<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/Android性能优化/" title="Android性能优化">Android性能优化<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/Android-自动化测试/" title="Android 自动化测试">Android 自动化测试<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/OpenCV/" title="OpenCV">OpenCV<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/直播/" title="直播">直播<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/Android-开源源码/" title="Android 开源源码">Android 开源源码<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/Android-自定义View进阶/" title="Android 自定义View进阶">Android 自定义View进阶<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/树莓派/" title="树莓派">树莓派<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/iOS-进阶/" title="iOS 进阶">iOS 进阶<sup>4</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">Links</p>
    <ul>
        
          <li>
            
            	<a href="https://hexo.io" target="_blank" title="Hexo">Hexo</a>
            
          </li>
        
          <li>
            
            	<a href="https://pages.github.com/" target="_blank" title="GitHub">GitHub</a>
            
          </li>
        
          <li>
            
            	<a href="http://pf18.github.io/" target="_blank" title="PF18">PF18</a>
            
          </li>
        
          <li>
            
            	<a href="http://toutiao.io/" target="_blank" title="开发者头条">开发者头条</a>
            
          </li>
        
          <li>
            
            	<a href="http://www.jcodecraeer.com/" target="_blank" title="泡在网上的日子">泡在网上的日子</a>
            
          </li>
        
    </ul>
</div>

  


  <div class="rsspart">
	<a href="atom.xml" target="_blank" title="rss">RSS</a>
</div>

  
  <div class="tagcloudlist">
    <p class="asidetitle">Tag Cloud</p>
    <div class="tagcloudlist clearfix">
       <a href="/tags/AOSP-%E6%BA%90%E7%A0%81/" style="font-size: 17.14px;">AOSP 源码</a> <a href="/tags/Android-APK-%E7%AD%BE%E5%90%8D/" style="font-size: 10px;">Android APK 签名</a> <a href="/tags/Android-JNI/" style="font-size: 12.86px;">Android JNI</a> <a href="/tags/Android-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E8%BF%9B%E9%98%B6/" style="font-size: 10.71px;">Android 事件处理进阶</a> <a href="/tags/Android-%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6/" style="font-size: 13.57px;">Android 动画进阶</a> <a href="/tags/Android-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%80%E5%8F%91/" style="font-size: 10px;">Android 多线程开发</a> <a href="/tags/Android-%E5%B0%8F%E7%BB%8F%E9%AA%8C/" style="font-size: 10px;">Android 小经验</a> <a href="/tags/Android-%E5%B8%B8%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/" style="font-size: 16.43px;">Android 常用第三方库</a> <a href="/tags/Android-%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/" style="font-size: 10px;">Android 开发流程</a> <a href="/tags/Android-%E5%BC%80%E6%BA%90%E6%BA%90%E7%A0%81/" style="font-size: 12.14px;">Android 开源源码</a> <a href="/tags/Android-%E7%BB%98%E5%9B%BE%E8%BF%9B%E9%98%B6/" style="font-size: 12.86px;">Android 绘图进阶</a> <a href="/tags/Android-%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/" style="font-size: 12.86px;">Android 自动化测试</a> <a href="/tags/Android-%E8%87%AA%E5%AE%9A%E4%B9%89View%E8%BF%9B%E9%98%B6/" style="font-size: 12.14px;">Android 自定义View进阶</a> <a href="/tags/Android-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 19.29px;">Android 设计模式</a> <a href="/tags/Android%E5%85%B6%E4%BB%96/" style="font-size: 10px;">Android其他</a> <a href="/tags/Android%E5%9F%BA%E7%A1%80/" style="font-size: 17.86px;">Android基础</a> <a href="/tags/Android%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/" style="font-size: 10px;">Android开发流程</a> <a href="/tags/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" style="font-size: 12.86px;">Android性能优化</a> <a href="/tags/Android%E6%B7%B7%E6%B7%86%E6%8A%80%E6%9C%AF/" style="font-size: 10px;">Android混淆技术</a> <a href="/tags/Android%E8%B4%A8%E9%87%8F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/" style="font-size: 11.43px;">Android质量管理工具</a> <a href="/tags/Android%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/" style="font-size: 10px;">Android逆向工程</a> <a href="/tags/Git-github/" style="font-size: 10px;">Git && github</a> <a href="/tags/Hexo-%E4%BD%BF%E7%94%A8/" style="font-size: 15px;">Hexo 使用</a> <a href="/tags/JavaScript/" style="font-size: 10px;">JavaScript</a> <a href="/tags/Linux-%E4%BD%BF%E7%94%A8/" style="font-size: 10px;">Linux 使用</a> <a href="/tags/Objective-C-%E7%9B%B8%E5%85%B3/" style="font-size: 18.57px;">Objective C 相关</a> <a href="/tags/OpenCV/" style="font-size: 12.86px;">OpenCV</a> <a href="/tags/ROS/" style="font-size: 14.29px;">ROS</a> <a href="/tags/iOS-%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/" style="font-size: 10.71px;">iOS 工具使用</a> <a href="/tags/iOS-%E5%BC%80%E6%BA%90%E5%BA%93%E5%88%86%E6%9E%90/" style="font-size: 20px;">iOS 开源库分析</a> <a href="/tags/iOS-%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/" style="font-size: 15.71px;">iOS 理论基础</a> <a href="/tags/iOS-%E8%BF%9B%E9%98%B6/" style="font-size: 12.14px;">iOS 进阶</a> <a href="/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/" style="font-size: 10px;">代码规范</a> <a href="/tags/%E5%8D%9A%E5%AE%A2%E5%88%86%E7%B1%BB%E7%9B%AE%E5%BD%95/" style="font-size: 10.71px;">博客分类目录</a> <a href="/tags/%E5%8F%A8%E5%8F%A8%E7%B3%BB%E5%88%97/" style="font-size: 10px;">叨叨系列</a> <a href="/tags/%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/" style="font-size: 11.43px;">工具的使用</a> <a href="/tags/%E5%BC%80%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/" style="font-size: 10.71px;">开源代码分析</a> <a href="/tags/%E5%BC%80%E6%BA%90%E5%BA%93%E5%88%86%E6%9E%90/" style="font-size: 10px;">开源库分析</a> <a href="/tags/%E6%9D%82%E7%B1%BB/" style="font-size: 10px;">杂类</a> <a href="/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/" style="font-size: 12.14px;">树莓派</a> <a href="/tags/%E7%9B%B4%E6%92%AD/" style="font-size: 12.86px;">直播</a> <a href="/tags/%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/" style="font-size: 10.71px;">编程技巧</a> <a href="/tags/%E7%BD%91%E7%AB%99%E6%94%B6%E8%97%8F/" style="font-size: 10px;">网站收藏</a> <a href="/tags/%E9%87%8D%E8%A6%81%E6%8E%A7%E4%BB%B6/" style="font-size: 11.43px;">重要控件</a>
    </div>
  </div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
		
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/hsihohuang/kiddochan" target="_blank" title="Kiddochan">Kiddochan</a> © 2022 
		
		<a href="/about" target="_blank" title="Edgar">Edgar</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
        getSize();
        if (myWidth >= 1024) {
          c.click();
        }
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  c.click(function(){
    ta.css('display', 'block').addClass('fadeIn');
  });
  o.click(function(){
    ta.css('display', 'none');
  });
  $(window).scroll(function(){
    ta.css("top",Math.max(140,320-$(this).scrollTop()));
  });
});
</script>




<script type="text/javascript">
  var duoshuoQuery = {short_name:"tbfungeek"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script> 


<script type="text/javascript">

var disqus_shortname = 'tbfungeek';

(function(){
  var dsq = document.createElement('script');
  dsq.type = 'text/javascript';
  dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
}());
(function(){
  var dsq = document.createElement('script');
  dsq.type = 'text/javascript';
  dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/count.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
}());
</script>






<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?7c9443b0374f1cf6b1dbb5ab84d939cb";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="Back to Top"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
</html>
