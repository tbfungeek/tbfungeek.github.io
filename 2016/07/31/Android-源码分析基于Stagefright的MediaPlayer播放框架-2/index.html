
 <!DOCTYPE HTML>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
  
    <title>Android 源码分析之基于Stagefright的MediaPlayer播放框架[3] | Edgar&#39;s Blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="Edgar">
    

    
    <meta name="description" content="MediaPlayer播放框架源代码解析：Prepare–加载解码器，数据缓存的初始化通过setDataSource设置播放资源后。就可以调用Prepare方法为播放做准备了。Prepare的整个流程是最为复杂的一个阶段，从整体上可以分成两大部分，第一部分是解码器的加载，第二部分是数据缓存的设置，Prepare之前的调用流程和setDataSource一样都是通过Java层到jni层再到nativ">
<meta property="og:type" content="article">
<meta property="og:title" content="Android 源码分析之基于Stagefright的MediaPlayer播放框架[3]">
<meta property="og:url" content="http://yoursite.com/2016/07/31/Android-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E5%9F%BA%E4%BA%8EStagefright%E7%9A%84MediaPlayer%E6%92%AD%E6%94%BE%E6%A1%86%E6%9E%B6-2/index.html">
<meta property="og:site_name" content="Edgar&#39;s Blog">
<meta property="og:description" content="MediaPlayer播放框架源代码解析：Prepare–加载解码器，数据缓存的初始化通过setDataSource设置播放资源后。就可以调用Prepare方法为播放做准备了。Prepare的整个流程是最为复杂的一个阶段，从整体上可以分成两大部分，第一部分是解码器的加载，第二部分是数据缓存的设置，Prepare之前的调用流程和setDataSource一样都是通过Java层到jni层再到nativ">
<meta property="og:locale">
<meta property="og:image" content="http://yoursite.com/2016/07/31/Android-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E5%9F%BA%E4%BA%8EStagefright%E7%9A%84MediaPlayer%E6%92%AD%E6%94%BE%E6%A1%86%E6%9E%B6-2/1.png">
<meta property="og:image" content="http://yoursite.com/2016/07/31/Android-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E5%9F%BA%E4%BA%8EStagefright%E7%9A%84MediaPlayer%E6%92%AD%E6%94%BE%E6%A1%86%E6%9E%B6-2/22.png">
<meta property="og:image" content="http://yoursite.com/2016/07/31/Android-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E5%9F%BA%E4%BA%8EStagefright%E7%9A%84MediaPlayer%E6%92%AD%E6%94%BE%E6%A1%86%E6%9E%B6-2/23.png">
<meta property="og:image" content="http://yoursite.com/2016/07/31/Android-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E5%9F%BA%E4%BA%8EStagefright%E7%9A%84MediaPlayer%E6%92%AD%E6%94%BE%E6%A1%86%E6%9E%B6-2/24.png">
<meta property="og:image" content="http://yoursite.com/2016/07/31/Android-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E5%9F%BA%E4%BA%8EStagefright%E7%9A%84MediaPlayer%E6%92%AD%E6%94%BE%E6%A1%86%E6%9E%B6-2/25.png">
<meta property="og:image" content="http://yoursite.com/2016/07/31/Android-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E5%9F%BA%E4%BA%8EStagefright%E7%9A%84MediaPlayer%E6%92%AD%E6%94%BE%E6%A1%86%E6%9E%B6-2/26.png">
<meta property="og:image" content="http://yoursite.com/2016/07/31/Android-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E5%9F%BA%E4%BA%8EStagefright%E7%9A%84MediaPlayer%E6%92%AD%E6%94%BE%E6%A1%86%E6%9E%B6-2/27.png">
<meta property="article:published_time" content="2016-07-31T13:54:41.000Z">
<meta property="article:modified_time" content="2016-08-05T23:55:00.000Z">
<meta property="article:author" content="Edgar">
<meta property="article:tag" content="AOSP 源码">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/2016/07/31/Android-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E5%9F%BA%E4%BA%8EStagefright%E7%9A%84MediaPlayer%E6%92%AD%E6%94%BE%E6%A1%86%E6%9E%B6-2/1.png">

    
    <link rel="alternative" href="atom.xml" title="Edgar&#39;s Blog" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/unnamed4_n_mSY_icon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/profile.png">
    <link rel="apple-touch-icon-precomposed" href="/img/profile.png">
    
    
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 6.2.0"></head>

  <body>
    <header>
      
<div>
		
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="Edgar&#39;s Blog">Edgar&#39;s Blog</a></h1>
				<h2 class="blog-motto"></h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="Menu">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
					<li>
 					
					<form class="search" action="/search/index.html" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" autocomplete="off" name="q" maxlength="20" placeholder="Search" />
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
  
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/07/31/Android-源码分析基于Stagefright的MediaPlayer播放框架-2/" title="Android 源码分析之基于Stagefright的MediaPlayer播放框架[3]" itemprop="url">Android 源码分析之基于Stagefright的MediaPlayer播放框架[3]</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Edgar" target="_blank" itemprop="author">Edgar</a>
		
  <p class="article-time">
    <time datetime="2016-07-31T13:54:41.000Z" itemprop="datePublished"> Published 2016-07-31</time>
    
  </p>
</header>
	<div class="article-content">
		
		<h5 id="MediaPlayer播放框架源代码解析："><a href="#MediaPlayer播放框架源代码解析：" class="headerlink" title="MediaPlayer播放框架源代码解析："></a>MediaPlayer播放框架源代码解析：</h5><h6 id="Prepare–加载解码器，数据缓存的初始化"><a href="#Prepare–加载解码器，数据缓存的初始化" class="headerlink" title="Prepare–加载解码器，数据缓存的初始化"></a>Prepare–加载解码器，数据缓存的初始化</h6><p>通过setDataSource设置播放资源后。就可以调用Prepare方法为播放做准备了。Prepare的整个流程是最为复杂的一个阶段，从整体上可以分成两大部分，第一部分是解码器的加载，第二部分是数据缓存的设置，Prepare之前的调用流程和setDataSource一样都是通过Java层到jni层再到native层，这部分就不做过多的介绍了，这部分的代码如下。</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">public void <span class="built_in">prepare</span>() throws IOException, IllegalStateException &#123;</span><br><span class="line">    <span class="built_in">_prepare</span>();</span><br><span class="line">    <span class="built_in">scanInternalSubtitleTracks</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="function"><span class="keyword">void</span> <span class="title">_prepare</span><span class="params">()</span> <span class="keyword">throws</span> IOException, IllegalStateException</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">static void</span><br><span class="line">android<span class="constructor">_media_MediaPlayer_prepare(JNIEnv <span class="operator">*</span><span class="params">env</span>, <span class="params">jobject</span> <span class="params">thiz</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    sp&lt;MediaPlayer&gt; mp = get<span class="constructor">MediaPlayer(<span class="params">env</span>, <span class="params">thiz</span>)</span>;</span><br><span class="line">    <span class="keyword">if</span> (mp<span class="operator"> == </span>NULL ) &#123;</span><br><span class="line">        jni<span class="constructor">ThrowException(<span class="params">env</span>, <span class="string">&quot;java/lang/IllegalStateException&quot;</span>, NULL)</span>;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Handle the case where the display surface was set before the mp was</span></span><br><span class="line">    <span class="comment">// initialized. We try again to make it stick.</span></span><br><span class="line">    sp&lt;IGraphicBufferProducer&gt; st = get<span class="constructor">VideoSurfaceTexture(<span class="params">env</span>, <span class="params">thiz</span>)</span>;</span><br><span class="line">    mp-&gt;set<span class="constructor">VideoSurfaceTexture(<span class="params">st</span>)</span>;</span><br><span class="line">    process<span class="constructor">_media_player_call( <span class="params">env</span>, <span class="params">thiz</span>, <span class="params">mp</span>-&gt;<span class="params">prepare</span>()</span>, <span class="string">&quot;java/io/IOException&quot;</span>, <span class="string">&quot;Prepare failed.&quot;</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">MediaPlayer::prepare</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Mutex::Autolock _l(mLock);</span><br><span class="line">    mLockThreadId = <span class="built_in">getThreadId</span>();</span><br><span class="line">    <span class="keyword">if</span> (mPrepareSync) &#123;</span><br><span class="line">        mLockThreadId = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> -EALREADY;</span><br><span class="line">    &#125;</span><br><span class="line">    mPrepareSync = <span class="literal">true</span>;</span><br><span class="line">    <span class="type">status_t</span> ret = <span class="built_in">prepareAsync_l</span>()；</span><br><span class="line">    <span class="keyword">if</span> (mPrepareSync) &#123;</span><br><span class="line">        mSignal.<span class="built_in">wait</span>(mLock);  <span class="comment">// wait for prepare done</span></span><br><span class="line">        mPrepareSync = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mLockThreadId = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> mPrepareStatus;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们从这里开始：<br>MediaPlayer 中调用了mPlayer-&gt;prepareAsync()方法，这里的mPlayer表示的是Stagefright Player，我们继续往下看：</p>
<figure class="highlight coq"><table><tr><td class="code"><pre><span class="line">status_t MediaPlayer::prepareAsync_l()&#123;</span><br><span class="line">    <span class="keyword">if</span> ( (mPlayer != <span class="number">0</span>) &amp;&amp; ( mCurrentState &amp; (MEDIA_PLAYER_INITIALIZED | <span class="type">MEDIA_PLAYER_STOPPED</span>) ) ) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mAudioAttributesParcel != NULL) &#123;</span><br><span class="line">            mPlayer-&gt;setParameter(KEY_PARAMETER_AUDIO_ATTRIBUTES, </span><br><span class="line">            *mAudioAttributesParcel);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mPlayer-&gt;setAudioStreamType(mStreamType);</span><br><span class="line">        &#125;</span><br><span class="line">        mCurrentState = MEDIA_PLAYER_PREPARING;</span><br><span class="line">        <span class="keyword">return</span> mPlayer-&gt;prepareAsync();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> INVALID_OPERATION;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在StagefrightPlayer中只是简单地调用AwesomePlayer的prepareAsync</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">StagefrightPlayer::prepareAsync</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mPlayer-&gt;<span class="built_in">prepareAsync</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">AwesomePlayer::prepareAsync</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">ATRACE_CALL</span>();</span><br><span class="line">    <span class="function">Mutex::Autolock <span class="title">autoLock</span><span class="params">(mLock)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (mFlags &amp; PREPARING) &#123;</span><br><span class="line">        <span class="keyword">return</span> UNKNOWN_ERROR;  <span class="comment">// async prepare already pending</span></span><br><span class="line">    &#125;</span><br><span class="line">    mIsAsyncPrepare = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">prepareAsync_l</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在AwesomePlayer类的prepareAsync_l方法中将会创建一个AwesomeEvent，启动Queue，将创建的mAsyncPrepareEvent post到Queue中。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">status_t AwesomePlayer::prepare<span class="constructor">Async_l()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mFlags &amp; PREPARING) &#123;</span><br><span class="line">        return UNKNOWN_ERROR;  <span class="comment">// async prepare already pending</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!mQueueStarted) &#123;</span><br><span class="line">        mQueue.start<span class="literal">()</span>;</span><br><span class="line">        mQueueStarted = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    modify<span class="constructor">Flags(PREPARING, SET)</span>;</span><br><span class="line">    mAsyncPrepareEvent = <span class="keyword">new</span> <span class="constructor">AwesomeEvent(<span class="params">this</span>, &amp;AwesomePlayer::<span class="params">onPrepareAsyncEvent</span>)</span>;</span><br><span class="line">    mQueue.post<span class="constructor">Event(<span class="params">mAsyncPrepareEvent</span>)</span>;</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在继续介绍prepare流程之前我们先来看下TimedEventQueue这个类。从名称上看它是一个事件队列。先来看下它的构造方法，这里很简单只是给它的成员变量初始化，并绑定一个DeathRecipient.</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">TimedEventQueue::<span class="constructor">TimedEventQueue()</span></span><br><span class="line">    : m<span class="constructor">NextEventID(1)</span>,</span><br><span class="line">      m<span class="constructor">Running(<span class="params">false</span>)</span>,</span><br><span class="line">      m<span class="constructor">Stopped(<span class="params">false</span>)</span>,</span><br><span class="line">      m<span class="constructor">DeathRecipient(<span class="params">new</span> PMDeathRecipient(<span class="params">this</span>)</span>),</span><br><span class="line">      m<span class="constructor">WakeLockCount(0)</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在start方法中创建一个ThreadWrapper线程。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void TimedEventQueue::start<span class="literal">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mRunning) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    mStopped = <span class="literal">false</span>;</span><br><span class="line">    pthread_attr_t attr;</span><br><span class="line">    pthread<span class="constructor">_attr_init(&amp;<span class="params">attr</span>)</span>;</span><br><span class="line">    pthread<span class="constructor">_attr_setdetachstate(&amp;<span class="params">attr</span>, PTHREAD_CREATE_JOINABLE)</span>;</span><br><span class="line">    pthread<span class="constructor">_create(&amp;<span class="params">mThread</span>, &amp;<span class="params">attr</span>, ThreadWrapper, <span class="params">this</span>)</span>;</span><br><span class="line">    pthread<span class="constructor">_attr_destroy(&amp;<span class="params">attr</span>)</span>;</span><br><span class="line">    mRunning = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="comment">// static</span></span><br><span class="line">void *TimedEventQueue::ThreadWrapper(void *me) &#123;</span><br><span class="line">    <span class="built_in">androidSetThreadPriority</span>(<span class="number">0</span>, ANDROID_PRIORITY_FOREGROUND);</span><br><span class="line">    static_cast&lt;TimedEventQueue *&gt;(me)-&gt;<span class="built_in">threadEntry</span>();</span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在ThreadWrapper线程中将会不断循环查看消息队列中的每个Event，看下是否达到执行的时间，如果消息队列为空则将会等待，如果达到超时时间10秒则会退出线程，如果在超时时间之前达到它的执行时间则调用该Event的fire方法。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TimedEventQueue::threadEntry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">prctl</span>(PR_SET_NAME, (<span class="type">unsigned</span> <span class="type">long</span>)<span class="string">&quot;TimedEventQueue&quot;</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">int64_t</span> now_us = <span class="number">0</span>;</span><br><span class="line">        sp&lt;Event&gt; event;</span><br><span class="line">        <span class="type">bool</span> wakeLocked = <span class="literal">false</span>;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">Mutex::Autolock <span class="title">autoLock</span><span class="params">(mLock)</span></span>;</span><br><span class="line">            <span class="keyword">if</span> (mStopped) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (mQueue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                mQueueNotEmptyCondition.<span class="built_in">wait</span>(mLock);</span><br><span class="line">            &#125;</span><br><span class="line">            event_id eventID = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mQueue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                    <span class="comment">// The only event in the queue could have been cancelled</span></span><br><span class="line">                    <span class="comment">// while we were waiting for its scheduled time.</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                List&lt;QueueItem&gt;::iterator it = mQueue.<span class="built_in">begin</span>();</span><br><span class="line">                eventID = (*it).event-&gt;<span class="built_in">eventID</span>();</span><br><span class="line"></span><br><span class="line">                now_us = ALooper::<span class="built_in">GetNowUs</span>();</span><br><span class="line">                <span class="type">int64_t</span> when_us = (*it).realtime_us;</span><br><span class="line">                <span class="type">int64_t</span> delay_us;</span><br><span class="line">                <span class="keyword">if</span> (when_us &lt; <span class="number">0</span> || when_us == INT64_MAX) &#123;</span><br><span class="line">                    delay_us = <span class="number">0</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    delay_us = when_us - now_us;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (delay_us &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">static</span> <span class="type">int64_t</span> kMaxTimeoutUs = <span class="number">10000000ll</span>;  <span class="comment">// 10 secs</span></span><br><span class="line">                <span class="type">bool</span> timeoutCapped = <span class="literal">false</span>;</span><br><span class="line">                    delay_us = kMaxTimeoutUs;</span><br><span class="line">                    timeoutCapped = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">status_t</span> err = mQueueHeadChangedCondition.<span class="built_in">waitRelative</span>(</span><br><span class="line">                        mLock, delay_us * <span class="number">1000ll</span>);</span><br><span class="line">                <span class="keyword">if</span> (!timeoutCapped &amp;&amp; err == -ETIMEDOUT) &#123;</span><br><span class="line">                    <span class="comment">// We finally hit the time this event is supposed to</span></span><br><span class="line">                    <span class="comment">// trigger.</span></span><br><span class="line">                    now_us = ALooper::<span class="built_in">GetNowUs</span>();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// The event w/ this id may have been cancelled while we&#x27;re</span></span><br><span class="line">            <span class="comment">// waiting for its trigger-time, in that case</span></span><br><span class="line">            <span class="comment">// removeEventFromQueue_l will return NULL.</span></span><br><span class="line">            <span class="comment">// Otherwise, the QueueItem will be removed</span></span><br><span class="line">            <span class="comment">// from the queue and the referenced event returned.</span></span><br><span class="line">            event = <span class="built_in">removeEventFromQueue_l</span>(eventID, &amp;wakeLocked);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (event != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// Fire event with the lock NOT held.</span></span><br><span class="line">            event-&gt;<span class="built_in">fire</span>(<span class="keyword">this</span>, now_us);</span><br><span class="line">            <span class="keyword">if</span> (wakeLocked) &#123;</span><br><span class="line">                <span class="function">Mutex::Autolock <span class="title">autoLock</span><span class="params">(mLock)</span></span>;</span><br><span class="line">                <span class="built_in">releaseWakeLock_l</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>fire 方法里面直接调用AwesomeEvent中mPlayer的mMethod方法，这个mMethod也就是我们在new AwesomeEvent时候传递进去的onPrepareAsyncEvent。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> AwesomeEvent : public TimedEventQueue::Event &#123;</span><br><span class="line"><span class="constructor">AwesomeEvent(AwesomePlayer <span class="operator">*</span><span class="params">player</span>,<span class="params">void</span> (AwesomePlayer::<span class="operator">*</span><span class="params">method</span>)</span><span class="literal">()</span>)</span><br><span class="line">    : m<span class="constructor">Player(<span class="params">player</span>)</span>,</span><br><span class="line">        m<span class="constructor">Method(<span class="params">method</span>)</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line">protected:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="constructor">AwesomeEvent()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> void fire(TimedEventQueue<span class="operator"> * </span><span class="comment">/* queue */</span>, int64_t <span class="comment">/* now_us */</span>) &#123;</span><br><span class="line">        (mPlayer-&gt;*mMethod)<span class="literal">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    AwesomePlayer *mPlayer;</span><br><span class="line">    void (AwesomePlayer::*mMethod)<span class="literal">()</span>;</span><br><span class="line">    <span class="constructor">AwesomeEvent(<span class="params">const</span> AwesomeEvent &amp;)</span>;</span><br><span class="line">    AwesomeEvent &amp;operator=(const AwesomeEvent &amp;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>所以我们需要看下AwesomePlayer 下的onPrepareAsyncEvent方法。在onPrepareAsyncEvent<br>方法中调用了beginPrepareAsync_l。在该方法中调用initAudioDecoder()对解码器进行了初始化。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void AwesomePlayer::on<span class="constructor">PrepareAsyncEvent()</span> &#123;</span><br><span class="line">    Mutex::Autolock auto<span class="constructor">Lock(<span class="params">mLock</span>)</span>;</span><br><span class="line">    <span class="keyword">begin</span><span class="constructor">PrepareAsync_l()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void AwesomePlayer::<span class="keyword">begin</span><span class="constructor">PrepareAsync_l()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mFlags &amp; PREPARE_CANCELLED) &#123;</span><br><span class="line">        <span class="constructor">ALOGI(<span class="string">&quot;prepare was cancelled before doing anything&quot;</span>)</span>;</span><br><span class="line">        abort<span class="constructor">Prepare(UNKNOWN_ERROR)</span>;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mUri.size<span class="literal">()</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        status_t err = finish<span class="constructor">SetDataSource_l()</span>;</span><br><span class="line">        <span class="keyword">if</span> (err != OK) &#123;</span><br><span class="line">            abort<span class="constructor">Prepare(<span class="params">err</span>)</span>;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mVideoTrack != NULL<span class="operator"> &amp;&amp; </span>mVideoSource<span class="operator"> == </span>NULL) &#123;</span><br><span class="line">        status_t err = init<span class="constructor">VideoDecoder()</span>;</span><br><span class="line">        <span class="keyword">if</span> (err != OK) &#123;</span><br><span class="line">            abort<span class="constructor">Prepare(<span class="params">err</span>)</span>;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mAudioTrack != NULL<span class="operator"> &amp;&amp; </span>mAudioSource<span class="operator"> == </span>NULL) &#123;</span><br><span class="line">        status_t err = init<span class="constructor">AudioDecoder()</span>;</span><br><span class="line">        <span class="keyword">if</span> (err != OK) &#123;</span><br><span class="line">            abort<span class="constructor">Prepare(<span class="params">err</span>)</span>;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    modify<span class="constructor">Flags(PREPARING_CONNECTED, SET)</span>;</span><br><span class="line">    <span class="keyword">if</span> (is<span class="constructor">StreamingHTTP()</span>) &#123;</span><br><span class="line">        post<span class="constructor">BufferingEvent_l()</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        finish<span class="constructor">AsyncPrepare_l()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整个过程如下图所示：<br><img src="/2016/07/31/Android-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E5%9F%BA%E4%BA%8EStagefright%E7%9A%84MediaPlayer%E6%92%AD%E6%94%BE%E6%A1%86%E6%9E%B6-2/1.png"></p>
<p>接下来我们重点看下解码器是怎样创建出来的，首先将会调用OMXCodec::Create来创建解码器。</p>
<figure class="highlight zephir"><table><tr><td class="code"><pre><span class="line">status_t AwesomePlayer::initAudioDecoder() &#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    sp&lt;MetaData&gt; meta = mAudioTrack-&gt;getFormat();</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *mime;</span><br><span class="line">    CHECK(meta-&gt;findCString(kKeyMIMEType, &amp;mime));</span><br><span class="line">    audio_stream_type_t streamType = AUDIO_STREAM_MUSIC;</span><br><span class="line">    <span class="keyword">if</span> (mAudioSink != NULL) &#123;</span><br><span class="line">        streamType = mAudioSink-&gt;getAudioStreamType();</span><br><span class="line">    &#125;</span><br><span class="line">    mOffloadAudio = canOffloadStream(meta, (mVideoSource != NULL),</span><br><span class="line">                                     isStreamingHTTP(), streamType);</span><br><span class="line">    <span class="keyword">if</span> (!strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_RAW)) &#123;</span><br><span class="line">        mAudioSource = mAudioTrack;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mOmxSource = OMXCodec::Create(</span><br><span class="line">                mClient.<span class="keyword">interface</span>(), mAudioTrack-&gt;getFormat(),</span><br><span class="line">                <span class="keyword">false</span>, <span class="comment">// createEncoder</span></span><br><span class="line">                mAudioTrack);</span><br><span class="line">        <span class="keyword">if</span> (mOffloadAudio) &#123;</span><br><span class="line">            mAudioSource = mAudioTrack;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mAudioSource = mOmxSource;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mAudioSource != NULL) &#123;</span><br><span class="line">        int64_t durationUs;</span><br><span class="line">        <span class="keyword">if</span> (mAudioTrack-&gt;getFormat()-&gt;findInt64(kKeyDuration, &amp;durationUs)) &#123;</span><br><span class="line">            Mutex::Autolock autoLock(mMiscStateLock);</span><br><span class="line">            <span class="keyword">if</span> (mDurationUs &lt; <span class="number">0</span> || durationUs &gt; mDurationUs) &#123;</span><br><span class="line">                mDurationUs = durationUs;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        status_t err = mAudioSource-&gt;start();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_QCELP)) &#123;</span><br><span class="line">        <span class="comment">// For legacy reasons we&#x27;re simply going to ignore the absence</span></span><br><span class="line">        <span class="comment">// of an audio decoder for QCELP instead of aborting playback</span></span><br><span class="line">        <span class="comment">// altogether.</span></span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mAudioSource != NULL) &#123;</span><br><span class="line">        Mutex::Autolock autoLock(mStatsLock);</span><br><span class="line">        TrackStat *stat = &amp;mStats.mTracks.editItemAt(mStats.mAudioTrackIndex);</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *component;</span><br><span class="line">        <span class="keyword">if</span> (!mAudioSource-&gt;getFormat()</span><br><span class="line">                -&gt;findCString(kKeyDecoderComponent, &amp;component)) &#123;</span><br><span class="line">            component = <span class="string">&quot;none&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        stat-&gt;mDecoderName = component;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mAudioSource != NULL ? OK : UNKNOWN_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建解码器之前我们需要获取当前播放文件的mimeType，然后根据这个mimeType查找对应的解码器，然后创建OMXCodecObserver，并将其赋给每个由allocateNode创建的解码器，并返回。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// static</span></span><br><span class="line"><span class="function">sp&lt;MediaSource&gt; <span class="title">OMXCodec::Create</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> sp&lt;IOMX&gt; &amp;omx,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> sp&lt;MetaData&gt; &amp;meta, <span class="type">bool</span> createEncoder,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> sp&lt;MediaSource&gt; &amp;source,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> <span class="type">char</span> *matchComponentName,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">uint32_t</span> flags,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> sp&lt;ANativeWindow&gt; &amp;nativeWindow)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取MimeType</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *mime;</span><br><span class="line">    <span class="type">bool</span> success = meta-&gt;<span class="built_in">findCString</span>(kKeyMIMEType, &amp;mime);</span><br><span class="line">    Vector&lt;CodecNameAndQuirks&gt; matchingCodecs;</span><br><span class="line">    <span class="comment">//查找匹配的解码器，这里主要从/etc/media_codecs.xml  /etc/media_codecs_performence.xml 中加载匹配对应mimetype的解码器。</span></span><br><span class="line">    <span class="built_in">findMatchingCodecs</span>(mime, createEncoder, matchComponentName, flags, &amp;matchingCodecs);</span><br><span class="line">    <span class="comment">//这里找到之后将放在matchingCodecs中，主要的存放形式为MediaCodecInfo的列表</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建OMXCodecObserver</span></span><br><span class="line">    sp&lt;OMXCodecObserver&gt; observer = <span class="keyword">new</span> OMXCodecObserver;</span><br><span class="line">    IOMX::node_id node = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; matchingCodecs.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *componentNameBase = matchingCodecs[i].mName.<span class="built_in">string</span>();</span><br><span class="line">        <span class="type">uint32_t</span> quirks = matchingCodecs[i].mQuirks;</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *componentName = componentNameBase;</span><br><span class="line">        <span class="comment">//通过从上面获取</span></span><br><span class="line">        <span class="type">status_t</span> err = omx-&gt;<span class="built_in">allocateNode</span>(componentName, observer, &amp;node);</span><br><span class="line">        <span class="keyword">if</span> (err == OK) &#123;</span><br><span class="line">            sp&lt;OMXCodec&gt; codec = <span class="keyword">new</span> <span class="built_in">OMXCodec</span>(</span><br><span class="line">                    omx, node, quirks, flags,</span><br><span class="line">                    createEncoder, mime, componentName,</span><br><span class="line">                    source, nativeWindow);</span><br><span class="line">            observer-&gt;<span class="built_in">setCodec</span>(codec);</span><br><span class="line">            err = codec-&gt;<span class="built_in">configureCodec</span>(meta);</span><br><span class="line">            <span class="keyword">if</span> (err == OK) &#123;</span><br><span class="line">                <span class="keyword">return</span> codec;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解码器的匹配是调用findMatchingCodecs来实现的，在开始之前首先获取当前所拥有的编码器的列表，它主要是通过解析&#x2F;etc&#x2F;media_codecs.xml这个文件来获取的，然后调用findCodecByType来判断能够处理当前播放文件类型的解码器，并将这些解码器添加到matchingCodecs中，这样返回的就是支持当前播放文件类型的解码器。</p>
<figure class="highlight zephir"><table><tr><td class="code"><pre><span class="line"><span class="comment">// static</span></span><br><span class="line">void OMXCodec::findMatchingCodecs(</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *mime,</span><br><span class="line">        <span class="keyword">bool</span> createEncoder, <span class="keyword">const</span> <span class="keyword">char</span> *matchComponentName,</span><br><span class="line">        uint32_t flags,</span><br><span class="line">        Vector&lt;CodecNameAndQuirks&gt; *matchingCodecs) &#123;</span><br><span class="line">    matchingCodecs-&gt;clear();</span><br><span class="line">    <span class="comment">//获取当前所拥有的编码器的列表</span></span><br><span class="line">    <span class="keyword">const</span> sp&lt;IMediaCodecList&gt; list = MediaCodecList::getInstance();</span><br><span class="line">    size_t index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="comment">//通过调用findCodecByType来判断的是否存在能够处理当前播放类型的解码器</span></span><br><span class="line">        ssize_t matchIndex =</span><br><span class="line">            list-&gt;findCodecByType(mime, createEncoder, index);</span><br><span class="line">        <span class="keyword">if</span> (matchIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        index = matchIndex + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">const</span> sp&lt;MediaCodecInfo&gt; info = list-&gt;getCodecInfo(matchIndex);</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *componentName = info-&gt;getCodecName();</span><br><span class="line">        <span class="keyword">if</span> (matchComponentName &amp;&amp; strcmp(componentName, matchComponentName)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// When requesting software-only codecs, only push software codecs</span></span><br><span class="line">        <span class="comment">// When requesting hardware-only codecs, only push hardware codecs</span></span><br><span class="line">        <span class="comment">// When there is request neither for software-only nor for</span></span><br><span class="line">        <span class="comment">// hardware-only codecs, push all codecs</span></span><br><span class="line">        <span class="keyword">if</span> (((flags &amp; kSoftwareCodecsOnly) &amp;&amp;   IsSoftwareCodec(componentName)) ||</span><br><span class="line">            ((flags &amp; kHardwareCodecsOnly) &amp;&amp;  !IsSoftwareCodec(componentName)) ||</span><br><span class="line">            (!(flags &amp; (kSoftwareCodecsOnly | kHardwareCodecsOnly)))) &#123;</span><br><span class="line">            <span class="comment">//将匹配的解码器添加到matchingCodecs</span></span><br><span class="line">            ssize_t index = matchingCodecs-&gt;add();</span><br><span class="line">            CodecNameAndQuirks *entry = &amp;matchingCodecs-&gt;editItemAt(index);</span><br><span class="line">            entry-&gt;mName = String8(componentName);</span><br><span class="line">            entry-&gt;mQuirks = getComponentQuirks(info);</span><br><span class="line"></span><br><span class="line">            ALOGV(<span class="string">&quot;matching &#x27;%s&#x27; quirks 0x%08x&quot;</span>,</span><br><span class="line">                  entry-&gt;mName.<span class="keyword">string</span>(), entry-&gt;mQuirks);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对解码器进行排序</span></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; kPreferSoftwareCodecs) &#123;</span><br><span class="line">        matchingCodecs-&gt;sort(CompareSoftwareCodecsFirst);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight isbl"><table><tr><td class="code"><pre><span class="line"><span class="comment">// static</span></span><br><span class="line"><span class="variable">sp</span>&lt;<span class="variable">IMediaCodecList</span>&gt; <span class="variable">MediaCodecList</span>::<span class="function"><span class="title">getInstance</span>() &#123;</span></span><br><span class="line"><span class="function">    <span class="variable">Mutex</span>::<span class="variable">Autolock</span> <span class="title">_l</span>(<span class="variable">sRemoteInitMutex</span>);</span></span><br><span class="line"><span class="function">    <span class="variable"><span class="keyword">if</span></span> (<span class="variable">sRemoteList</span> == <span class="variable"><span class="literal">NULL</span></span>) &#123;</span></span><br><span class="line"><span class="function">        <span class="variable">sp</span>&lt;<span class="variable">IBinder</span>&gt; <span class="variable">binder</span> =</span></span><br><span class="line"><span class="function">            <span class="title">defaultServiceManager</span>()-&gt;<span class="title">getService</span>(<span class="title">String16</span>(<span class="string">&quot;media.player&quot;</span>));</span></span><br><span class="line"><span class="function">        <span class="variable">sp</span>&lt;<span class="variable">IMediaPlayerService</span>&gt; <span class="variable">service</span> =</span></span><br><span class="line"><span class="function">            <span class="variable">interface_cast</span>&lt;<span class="variable">IMediaPlayerService</span>&gt;(<span class="variable">binder</span>);</span></span><br><span class="line"><span class="function">        <span class="variable"><span class="keyword">if</span></span> (<span class="variable">service.get</span>() <span class="variable">!</span>= <span class="variable"><span class="literal">NULL</span></span>) &#123;</span></span><br><span class="line"><span class="function">            <span class="variable">sRemoteList</span> = <span class="variable">service</span>-&gt;<span class="title">getCodecList</span>();</span></span><br><span class="line"><span class="function">        &#125;</span></span><br><span class="line"><span class="function">        <span class="variable"><span class="keyword">if</span></span> (<span class="variable">sRemoteList</span> == <span class="variable"><span class="literal">NULL</span></span>) &#123;</span></span><br><span class="line"><span class="function">            <span class="comment">// if failed to get remote list, create local list</span></span></span><br><span class="line"><span class="function">            <span class="variable">sRemoteList</span> = <span class="title">getLocalInstance</span>();</span></span><br><span class="line"><span class="function">        &#125;</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function">    <span class="variable">return</span> <span class="variable">sRemoteList</span>;</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">sp&lt;IMediaCodecList&gt; MediaPlayerService::<span class="built_in">getCodecList</span>() const &#123;</span><br><span class="line">    return MediaCodecList::<span class="built_in">getLocalInstance</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// static</span></span><br><span class="line"><span class="function">sp&lt;IMediaCodecList&gt; <span class="title">MediaCodecList::getLocalInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Mutex::Autolock <span class="title">autoLock</span><span class="params">(sInitMutex)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (sCodecList == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        MediaCodecList *codecList = <span class="keyword">new</span> MediaCodecList;</span><br><span class="line">        <span class="keyword">if</span> (codecList-&gt;<span class="built_in">initCheck</span>() == OK) &#123;</span><br><span class="line">            sCodecList = codecList;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">delete</span> codecList;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sCodecList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">MediaCodecList::<span class="constructor">MediaCodecList()</span></span><br><span class="line">    : m<span class="constructor">InitCheck(NO_INIT)</span>,</span><br><span class="line">      m<span class="constructor">Update(<span class="params">false</span>)</span>,</span><br><span class="line">      m<span class="constructor">GlobalSettings(<span class="params">new</span> AMessage()</span>) &#123;</span><br><span class="line">    parse<span class="constructor">TopLevelXMLFile(<span class="string">&quot;/etc/media_codecs.xml&quot;</span>)</span>;</span><br><span class="line">    parse<span class="constructor">TopLevelXMLFile(<span class="string">&quot;/etc/media_codecs_performance.xml&quot;</span>, <span class="params">true</span>)</span>;</span><br><span class="line">    parse<span class="constructor">TopLevelXMLFile(<span class="params">kProfilingResults</span>, <span class="params">true</span><span class="operator">/</span><span class="operator">*</span> <span class="params">ignore_errors</span> <span class="operator">*</span><span class="operator">/</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">MediaCodecList::findCodecByType</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> <span class="type">char</span> *type, <span class="type">bool</span> encoder, <span class="type">size_t</span> startIndex)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">char</span> *advancedFeatures[] = &#123;</span><br><span class="line">        <span class="string">&quot;feature-secure-playback&quot;</span>,</span><br><span class="line">        <span class="string">&quot;feature-tunneled-playback&quot;</span>,</span><br><span class="line">    &#125;;  </span><br><span class="line">    <span class="type">size_t</span> numCodecs = mCodecInfos.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">//遍历编解码器列表中的每个项。</span></span><br><span class="line">    <span class="keyword">for</span> (; startIndex &lt; numCodecs; ++startIndex) &#123;</span><br><span class="line">        <span class="type">const</span> MediaCodecInfo &amp;info = *mCodecInfos.<span class="built_in">itemAt</span>(startIndex).<span class="built_in">get</span>();</span><br><span class="line">        <span class="comment">//判断是否是解码器，如果不是则接着加载下一个进行判断</span></span><br><span class="line">        <span class="keyword">if</span> (info.<span class="built_in">isEncoder</span>() != encoder) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断是否能够支持当前的MimeType</span></span><br><span class="line">        sp&lt;MediaCodecInfo::Capabilities&gt; capabilities = info.<span class="built_in">getCapabilitiesFor</span>(type);</span><br><span class="line">        <span class="keyword">if</span> (capabilities == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">const</span> sp&lt;AMessage&gt; &amp;details = capabilities-&gt;<span class="built_in">getDetails</span>();</span><br><span class="line">        <span class="type">int32_t</span> required;</span><br><span class="line">        <span class="type">bool</span> isAdvanced = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> ix = <span class="number">0</span>; ix &lt; <span class="built_in">ARRAY_SIZE</span>(advancedFeatures); ix++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (details-&gt;<span class="built_in">findInt32</span>(advancedFeatures[ix], &amp;required) &amp;&amp;</span><br><span class="line">                    required != <span class="number">0</span>) &#123;</span><br><span class="line">                isAdvanced = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!isAdvanced) &#123;</span><br><span class="line">            <span class="keyword">return</span> startIndex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -ENOENT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2016/07/31/Android-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E5%9F%BA%E4%BA%8EStagefright%E7%9A%84MediaPlayer%E6%92%AD%E6%94%BE%E6%A1%86%E6%9E%B6-2/22.png"></p>
<p>通过上述步骤只是过滤出能够支持当前播放文件类型的解码器信息，但是并没有对这些解码器进行实例化。解码器的实例化是通过如下代码片来完成的。</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line"><span class="comment">//分配节点</span></span><br><span class="line"><span class="function"><span class="title">status_t</span> err = omx-&gt;</span>allocateNode(componentName, observer, &amp;node);</span><br><span class="line"><span class="comment">//创建解码器的实例</span></span><br><span class="line">sp&lt;OMXCodec&gt; codec = new OMXCodec(omx, node, quirks, flags,</span><br><span class="line">                    createEncoder, mime, componentName,</span><br><span class="line">                    source, nativeWindow);</span><br><span class="line"><span class="comment">//将实例赋给observer</span></span><br><span class="line"><span class="function"><span class="title">observer</span>-&gt;</span>setCodec(codec);</span><br><span class="line"><span class="comment">//并用meta来配置创建出来的解码器实例</span></span><br><span class="line"><span class="function"><span class="title">err</span> = codec-&gt;</span>configureCodec(meta);</span><br></pre></td></tr></table></figure>
<p>在allocateNode开始的时候首先创建OMXNodeInstance对象，然后调用<br>makeComponentInstance创建实例。</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">status_t OMX::allocateNode(</span><br><span class="line">        const char *name, const sp<span class="tag">&lt;IOMXObserver&gt;</span> &amp;observer, node_id *<span class="keyword">node</span><span class="title">) &#123;</span></span><br><span class="line"><span class="title">    Mutex</span>::Autolock autoLock(mLock);</span><br><span class="line">    *<span class="keyword">node</span> <span class="title">= 0</span>;</span><br><span class="line">    OMXNodeInstance *instance = new OMXNodeInstance(this, observer, name);</span><br><span class="line">    OMX_COMPONENTTYPE *handle;</span><br><span class="line">    OMX_ERRORTYPE err = mMaster-&gt;makeComponentInstance(name, &amp;OMXNodeInstance::kCallbacks,instance, &amp;handle);</span><br><span class="line">    *<span class="keyword">node</span> <span class="title">= makeNodeID</span>(instance);</span><br><span class="line">    mDispatchers.add(*<span class="keyword">node</span><span class="title">, new</span> CallbackDispatcher(instance));</span><br><span class="line">    instance-&gt;setHandle(*<span class="keyword">node</span><span class="title">, handle</span>);</span><br><span class="line">    mLiveNodes.add(IInterface::asBinder(observer), instance);</span><br><span class="line">    IInterface::asBinder(observer)-&gt;linkToDeath(this);</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>OMXNodeInstance构造方法比较简单这里就不详细介绍了。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">OMXNodeInstance::OMXNodeInstance(</span><br><span class="line">        OMX *<span class="keyword">owner</span>, const sp&lt;IOMXObserver&gt; &amp;observer, const <span class="type">char</span> *<span class="type">name</span>)</span><br><span class="line">    : mOwner(<span class="keyword">owner</span>),</span><br><span class="line">      mNodeID(<span class="number">0</span>),</span><br><span class="line">      mHandle(<span class="keyword">NULL</span>),</span><br><span class="line">      mObserver(observer),</span><br><span class="line">      mDying(<span class="keyword">false</span>),</span><br><span class="line">      mBufferIDCount(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    mName = ADebug::GetDebugName(<span class="type">name</span>);</span><br><span class="line">    <span class="keyword">DEBUG</span> = ADebug::GetDebugLevelFromProperty(<span class="type">name</span>, &quot;debug.stagefright.omx-debug&quot;);</span><br><span class="line">    ALOGV(&quot;debug level for %s is %d&quot;, <span class="type">name</span>, <span class="keyword">DEBUG</span>);</span><br><span class="line">    DEBUG_BUMP = <span class="keyword">DEBUG</span>;</span><br><span class="line">    mNumPortBuffers[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    mNumPortBuffers[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    mDebugLevelBumpPendingBuffers[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    mDebugLevelBumpPendingBuffers[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    mMetadataType[<span class="number">0</span>] = kMetadataBufferTypeInvalid;</span><br><span class="line">    mMetadataType[<span class="number">1</span>] = kMetadataBufferTypeInvalid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>makeComponentInstance方法首先通过调用mPluginByComponentName.indexOfKey(String8(name))找到指定名字解码器的索引,然后调用mPluginByComponentName.valueAt(index);返回解码器实例。这个mPluginByComponentName是在创建AwesomePlayer的时候创建的。里面存放的是所支持的VentorPlugin以及SoftPlugin<br>ssize_t index &#x3D; mPluginByComponentName.indexOfKey(String8(name));<br>OMXPluginBase *plugin &#x3D; mPluginByComponentName.valueAt(index);然后调用对应plugin的makeComponentInstance创建出实例，然后将其添加到mPluginByInstance中</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">OMX_ERRORTYPE OMXMaster::makeComponentInstance(</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *name,</span><br><span class="line">        <span class="keyword">const</span> OMX_CALLBACKTYPE *callbacks,</span><br><span class="line">        OMX_PTR appData,</span><br><span class="line">        OMX_COMPONENTTYPE **component) &#123;</span><br><span class="line">    Mutex::Autolock autoLock(mLock);</span><br><span class="line"><span class="comment">*component = NULL;</span></span><br><span class="line"><span class="comment">//首先通过调用mPluginByComponentName.indexOfKey(String8(name))找到指定名字解码器的索引,然后调用mPluginByComponentName.valueAt(index);返回解码器实例。</span></span><br><span class="line"><span class="comment">//这个mPluginByComponentName是在创建AwesomePlayer的时候创建的。里面存放的  </span></span><br><span class="line"><span class="comment">//是所支持的VentorPlugin以及SoftPlugin</span></span><br><span class="line">    ssize_t index = mPluginByComponentName.indexOfKey(String8(name));</span><br><span class="line">OMXPluginBase *<span class="keyword">plugin</span> = mPluginByComponentName.valueAt(index);</span><br><span class="line"><span class="comment">//然后调用对应plugin的makeComponentInstance创建出实例，然后将其添加到  </span></span><br><span class="line"><span class="comment">//mPluginByInstance中</span></span><br><span class="line">    OMX_ERRORTYPE <span class="keyword">err</span> =</span><br><span class="line">        <span class="keyword">plugin</span>-&gt;makeComponentInstance(name, callbacks, appData, component);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">err</span> != OMX_ErrorNone) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">err</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mPluginByInstance.add(*component, <span class="keyword">plugin</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">err</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们以软解码器为例子来分析makeComponentInstance过程：<br>首先SoftOMXPlugin::makeComponentInstance会从kComponents数组中找到对应的解码器信息，kComponents是一个结构体数组，存放着编码器名，动态链接库后缀，以及是编码器还是解码器信息。然后根据动态链接库的后缀构建出对应解码器的库文件名，接着打开该库文件，调用其中的createSoftOMXComponent方法，创建出对应的软解码器。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">OMX_ERRORTYPE <span class="title">SoftOMXPlugin::makeComponentInstance</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> <span class="type">char</span> *name,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> OMX_CALLBACKTYPE *callbacks,</span></span></span><br><span class="line"><span class="params"><span class="function">        OMX_PTR appData,</span></span></span><br><span class="line"><span class="params"><span class="function">        OMX_COMPONENTTYPE **component)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; kNumComponents; ++i) &#123;</span><br><span class="line">        <span class="comment">// 在kComponents数组中找到对应的解码器信息，</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(name, kComponents[i].mName)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//构建出对应解码器的库文件名，我们以MP3为例返回的库文件名为：</span></span><br><span class="line">        <span class="comment">// libstagefright_soft_mp3dec.so</span></span><br><span class="line">        AString libName = <span class="string">&quot;libstagefright_soft_&quot;</span>;</span><br><span class="line">        libName.<span class="built_in">append</span>(kComponents[i].mLibNameSuffix);</span><br><span class="line">        libName.<span class="built_in">append</span>(<span class="string">&quot;.so&quot;</span>);</span><br><span class="line">        <span class="comment">//打开该库文件，调用其中的createSoftOMXComponent方法</span></span><br><span class="line">       <span class="comment">//创建对应的解码器</span></span><br><span class="line">        <span class="type">void</span> *libHandle = <span class="built_in">dlopen</span>(libName.<span class="built_in">c_str</span>(), RTLD_NOW);</span><br><span class="line">        <span class="keyword">typedef</span> SoftOMXComponent *(*CreateSoftOMXComponentFunc)(</span><br><span class="line">                <span class="type">const</span> <span class="type">char</span> *, <span class="type">const</span> OMX_CALLBACKTYPE *,</span><br><span class="line">                OMX_PTR, OMX_COMPONENTTYPE **);</span><br><span class="line">        CreateSoftOMXComponentFunc createSoftOMXComponent =</span><br><span class="line">            (CreateSoftOMXComponentFunc)<span class="built_in">dlsym</span>(</span><br><span class="line">                    libHandle,</span><br><span class="line">                    <span class="string">&quot;_Z22createSoftOMXComponentPKcPK16OMX_CALLBACKTYPE&quot;</span></span><br><span class="line">                    <span class="string">&quot;PvPP17OMX_COMPONENTTYPE&quot;</span>);</span><br><span class="line">        sp&lt;SoftOMXComponent&gt; codec =</span><br><span class="line">            (*createSoftOMXComponent)(name, callbacks, appData, component);</span><br><span class="line">        OMX_ERRORTYPE err = codec-&gt;<span class="built_in">initCheck</span>();</span><br><span class="line">        codec-&gt;<span class="built_in">incStrong</span>(<span class="keyword">this</span>);</span><br><span class="line">        codec-&gt;<span class="built_in">setLibHandle</span>(libHandle);</span><br><span class="line">        <span class="keyword">return</span> OMX_ErrorNone;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OMX_ErrorInvalidComponentName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *mName;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *mLibNameSuffix;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *mRole;</span><br><span class="line">&#125; kComponents[] = &#123;</span><br><span class="line">    &#123; <span class="string">&quot;OMX.google.aac.decoder&quot;</span>, <span class="string">&quot;aacdec&quot;</span>, <span class="string">&quot;audio_decoder.aac&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;OMX.google.aac.encoder&quot;</span>, <span class="string">&quot;aacenc&quot;</span>, <span class="string">&quot;audio_encoder.aac&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;OMX.google.amrnb.decoder&quot;</span>, <span class="string">&quot;amrdec&quot;</span>, <span class="string">&quot;audio_decoder.amrnb&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;OMX.google.amrnb.encoder&quot;</span>, <span class="string">&quot;amrnbenc&quot;</span>, <span class="string">&quot;audio_encoder.amrnb&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;OMX.google.amrwb.decoder&quot;</span>, <span class="string">&quot;amrdec&quot;</span>, <span class="string">&quot;audio_decoder.amrwb&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;OMX.google.amrwb.encoder&quot;</span>, <span class="string">&quot;amrwbenc&quot;</span>, <span class="string">&quot;audio_encoder.amrwb&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;OMX.google.h264.decoder&quot;</span>, <span class="string">&quot;avcdec&quot;</span>, <span class="string">&quot;video_decoder.avc&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;OMX.google.h264.encoder&quot;</span>, <span class="string">&quot;avcenc&quot;</span>, <span class="string">&quot;video_encoder.avc&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;OMX.google.hevc.decoder&quot;</span>, <span class="string">&quot;hevcdec&quot;</span>, <span class="string">&quot;video_decoder.hevc&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;OMX.google.g711.alaw.decoder&quot;</span>, <span class="string">&quot;g711dec&quot;</span>, <span class="string">&quot;audio_decoder.g711alaw&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;OMX.google.g711.mlaw.decoder&quot;</span>, <span class="string">&quot;g711dec&quot;</span>, <span class="string">&quot;audio_decoder.g711mlaw&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;OMX.google.mpeg2.decoder&quot;</span>, <span class="string">&quot;mpeg2dec&quot;</span>, <span class="string">&quot;video_decoder.mpeg2&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;OMX.google.h263.decoder&quot;</span>, <span class="string">&quot;mpeg4dec&quot;</span>, <span class="string">&quot;video_decoder.h263&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;OMX.google.h263.encoder&quot;</span>, <span class="string">&quot;mpeg4enc&quot;</span>, <span class="string">&quot;video_encoder.h263&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;OMX.google.mpeg4.decoder&quot;</span>, <span class="string">&quot;mpeg4dec&quot;</span>, <span class="string">&quot;video_decoder.mpeg4&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;OMX.google.mpeg4.encoder&quot;</span>, <span class="string">&quot;mpeg4enc&quot;</span>, <span class="string">&quot;video_encoder.mpeg4&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;OMX.google.mp3.decoder&quot;</span>, <span class="string">&quot;mp3dec&quot;</span>, <span class="string">&quot;audio_decoder.mp3&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;OMX.google.vorbis.decoder&quot;</span>, <span class="string">&quot;vorbisdec&quot;</span>, <span class="string">&quot;audio_decoder.vorbis&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;OMX.google.opus.decoder&quot;</span>, <span class="string">&quot;opusdec&quot;</span>, <span class="string">&quot;audio_decoder.opus&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;OMX.google.vp8.decoder&quot;</span>, <span class="string">&quot;vpxdec&quot;</span>, <span class="string">&quot;video_decoder.vp8&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;OMX.google.vp9.decoder&quot;</span>, <span class="string">&quot;vpxdec&quot;</span>, <span class="string">&quot;video_decoder.vp9&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;OMX.google.vp8.encoder&quot;</span>, <span class="string">&quot;vpxenc&quot;</span>, <span class="string">&quot;video_encoder.vp8&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;OMX.google.raw.decoder&quot;</span>, <span class="string">&quot;rawdec&quot;</span>, <span class="string">&quot;audio_decoder.raw&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;OMX.google.flac.encoder&quot;</span>, <span class="string">&quot;flacenc&quot;</span>, <span class="string">&quot;audio_encoder.flac&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;OMX.google.gsm.decoder&quot;</span>, <span class="string">&quot;gsmdec&quot;</span>, <span class="string">&quot;audio_decoder.gsm&quot;</span> &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>每个软解码器都有一个createSoftOMXComponent方法。我们以MP3软解码器为例，在它内部通过 android::SoftMP3构造方法创建出MP3软解码器。</p>
<figure class="highlight zephir"><table><tr><td class="code"><pre><span class="line">android::SoftOMXComponent *createSoftOMXComponent(</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> OMX_CALLBACKTYPE *callbacks,</span><br><span class="line">        OMX_PTR appData, OMX_COMPONENTTYPE **component) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> android::SoftMP3(name, callbacks, appData, component);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里估计大家会有点晕了吧，如果有点晕我这里再上个图做个小总结：<br><img src="/2016/07/31/Android-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E5%9F%BA%E4%BA%8EStagefright%E7%9A%84MediaPlayer%E6%92%AD%E6%94%BE%E6%A1%86%E6%9E%B6-2/23.png"><br>我们在创建解码器实例的时候传入的是媒体文件的mimeType，拿着这个mimetype我们去匹配可以处理这个格式的解码器，和什么匹配？就是从&#x2F;etc&#x2F;media_codecs.xml.&#x2F;etc&#x2F;media_codec_performance.xml这两个xml文件中解析出来的数据中匹配，这里记录了平台所支持的每个编解码器的信息，每个信息封装在一个MediaCodecInfo对象中。<br>匹配后的所有MediaCodecInfo存放在matchingCodecs列表中，然后再拿着这个列表中的每个解码器的ComponentName到mPluginByComponentName中查找对应的plugin。比如MP3那么我们会找到SoftOMXPlugin，然后再从对应的库中调用库内部的createSoftOMXComponent方法创建出SoftMp3这个component，初始化后加入到mPluginByInstance</p>
<p>在MP3软编码器构造方法中最重要的有三个步骤</p>
<ol>
<li>SimpleSoftOMXComponent的创建</li>
<li>initPorts();</li>
<li>initDecoder();<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">SoftMP3::<span class="built_in">SoftMP3</span>(</span><br><span class="line">        const char *name,</span><br><span class="line">        const OMX_CALLBACKTYPE *callbacks,</span><br><span class="line">        OMX_PTR appData,</span><br><span class="line">        OMX_COMPONENTTYPE **component)</span><br><span class="line">    : <span class="built_in">SimpleSoftOMXComponent</span>(name, callbacks, appData, component),</span><br><span class="line">      <span class="built_in">mConfig</span>(new tPVMP3DecoderExternal),</span><br><span class="line">      <span class="built_in">mDecoderBuf</span>(NULL),</span><br><span class="line">      <span class="built_in">mAnchorTimeUs</span>(<span class="number">0</span>),</span><br><span class="line">      <span class="built_in">mNumFramesOutput</span>(<span class="number">0</span>),</span><br><span class="line">      <span class="built_in">mNumChannels</span>(<span class="number">2</span>),</span><br><span class="line">      <span class="built_in">mSamplingRate</span>(<span class="number">44100</span>),</span><br><span class="line">      <span class="built_in">mSignalledError</span>(false),</span><br><span class="line">      <span class="built_in">mSawInputEos</span>(false),</span><br><span class="line">      <span class="built_in">mSignalledOutputEos</span>(false),</span><br><span class="line">      <span class="built_in">mOutputPortSettingsChange</span>(NONE) &#123;</span><br><span class="line">    initPorts();</span><br><span class="line">    initDecoder();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
在SimpleSoftOMXComponent构造方法中主要是创建了SoftOMXComponent，并初始化了一个mHandler以及一个mLooper，并将mHandler注册到对应的mLooper，然后启动mLooper。<br>在mHandler中能够处理kWhatEmptyThisBuffer，kWhatFillThisBuffer，kWhatSendCommand这些事件，当这些事件触发后将会被发送到SimpleSoftOMXComponent::onMessageReceived中进行处理。<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">SimpleSoftOMXComponent::SimpleSoftOMXComponent(</span><br><span class="line">        const char *<span class="keyword">name</span>,</span><br><span class="line">        const OMX_CALLBACKTYPE *callbacks,</span><br><span class="line">        OMX_PTR appData,</span><br><span class="line">        OMX_COMPONENTTYPE **component)</span><br><span class="line">    : SoftOMXComponent(<span class="keyword">name</span>, callbacks, appData, component),</span><br><span class="line">      mLooper(new ALooper),</span><br><span class="line">      mHandler(new AHandlerReflector&lt;SimpleSoftOMXComponent&gt;(this)),</span><br><span class="line">      mState(OMX_StateLoaded),</span><br><span class="line">      mTargetState(OMX_StateLoaded) &#123;</span><br><span class="line">    <span class="function"><span class="title">mLooper</span>-&gt;</span>setName(<span class="keyword">name</span>);</span><br><span class="line">    <span class="function"><span class="title">mLooper</span>-&gt;</span>registerHandler(mHandler);</span><br><span class="line">    <span class="function"><span class="title">mLooper</span>-&gt;</span>start(</span><br><span class="line">            <span class="literal">false</span>, <span class="comment">// runOnCallingThread</span></span><br><span class="line">            <span class="literal">false</span>, <span class="comment">// canCallJava</span></span><br><span class="line">            ANDROID_PRIORITY_FOREGROUND);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
我们看下SoftOMXComponent::SoftOMXComponent，这部分主要是new出一个OMX_COMPONENTTYPE，它是一个结构体对象，在<br>frameworks&#x2F;native&#x2F;include&#x2F;media&#x2F;openmax&#x2F;OMX_Component.h文件中对其定义。<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">SoftOMXComponent::SoftOMXComponent(</span><br><span class="line">        const char *<span class="keyword">name</span>,</span><br><span class="line">        const OMX_CALLBACKTYPE *callbacks,</span><br><span class="line">        OMX_PTR appData,</span><br><span class="line">        OMX_COMPONENTTYPE **component)</span><br><span class="line">    : mName(<span class="keyword">name</span>),</span><br><span class="line">      mCallbacks(callbacks),</span><br><span class="line">      mComponent(new OMX_COMPONENTTYPE),</span><br><span class="line">      mLibHandle(NULL) &#123;</span><br><span class="line">    <span class="function"><span class="title">mComponent</span>-&gt;</span>nSize = sizeof(*mComponent);</span><br><span class="line">    <span class="function"><span class="title">mComponent</span>-&gt;</span>nVersion.s.nVersionMajor = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="title">mComponent</span>-&gt;</span>nVersion.s.nVersionMinor = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="title">mComponent</span>-&gt;</span>nVersion.s.nRevision = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="title">mComponent</span>-&gt;</span>nVersion.s.nStep = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="title">mComponent</span>-&gt;</span>pComponentPrivate = this;</span><br><span class="line">    <span class="function"><span class="title">mComponent</span>-&gt;</span>pApplicationPrivate = appData;</span><br><span class="line">    <span class="function"><span class="title">mComponent</span>-&gt;</span>GetComponentVersion = NULL;</span><br><span class="line">    <span class="function"><span class="title">mComponent</span>-&gt;</span>SendCommand = SendCommandWrapper;</span><br><span class="line">    <span class="function"><span class="title">mComponent</span>-&gt;</span>GetParameter = GetParameterWrapper;</span><br><span class="line">    <span class="function"><span class="title">mComponent</span>-&gt;</span>SetParameter = SetParameterWrapper;</span><br><span class="line">    <span class="function"><span class="title">mComponent</span>-&gt;</span>GetConfig = GetConfigWrapper;</span><br><span class="line">    <span class="function"><span class="title">mComponent</span>-&gt;</span>SetConfig = SetConfigWrapper;</span><br><span class="line">    <span class="function"><span class="title">mComponent</span>-&gt;</span>GetExtensionIndex = GetExtensionIndexWrapper;</span><br><span class="line">    <span class="function"><span class="title">mComponent</span>-&gt;</span>GetState = GetStateWrapper;</span><br><span class="line">    <span class="function"><span class="title">mComponent</span>-&gt;</span>ComponentTunnelRequest = NULL;</span><br><span class="line">    <span class="function"><span class="title">mComponent</span>-&gt;</span>UseBuffer = UseBufferWrapper;</span><br><span class="line">    <span class="function"><span class="title">mComponent</span>-&gt;</span>AllocateBuffer = AllocateBufferWrapper;</span><br><span class="line">    <span class="function"><span class="title">mComponent</span>-&gt;</span>FreeBuffer = FreeBufferWrapper;</span><br><span class="line">    <span class="function"><span class="title">mComponent</span>-&gt;</span>EmptyThisBuffer = EmptyThisBufferWrapper;</span><br><span class="line">    <span class="function"><span class="title">mComponent</span>-&gt;</span>FillThisBuffer = FillThisBufferWrapper;</span><br><span class="line">    <span class="function"><span class="title">mComponent</span>-&gt;</span>SetCallbacks = NULL;</span><br><span class="line">    <span class="function"><span class="title">mComponent</span>-&gt;</span>ComponentDeInit = NULL;</span><br><span class="line">    <span class="function"><span class="title">mComponent</span>-&gt;</span>UseEGLImage = NULL;</span><br><span class="line">    <span class="function"><span class="title">mComponent</span>-&gt;</span>ComponentRoleEnum = NULL;</span><br><span class="line">    *component = mComponent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
上面构造方法中的callback的定义如下：<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// static</span></span><br><span class="line">OMX_CALLBACKTYPE OMXNodeInstance::kC<span class="attr">allbacks</span> <span class="operator">=</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="variable">&amp;</span>OnEvent, <span class="variable">&amp;</span>OnEmptyBufferDone, <span class="variable">&amp;</span>OnFillBufferDone</span><br><span class="line"><span class="punctuation">&#125;;</span></span><br></pre></td></tr></table></figure>
在initPorts方法中创建了两个端口，一个为输入端口，一个为输出端口，其中输入端口的index为0，输出端口的index为1.<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">void SoftMP3::initPorts() &#123;</span><br><span class="line">    OMX_PARAM_PORTDEFINITIONTYPE <span class="keyword">def</span>;</span><br><span class="line">    InitOMXParams(&amp;<span class="keyword">def</span>);</span><br><span class="line">    <span class="keyword">def</span>.nPortIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">def</span>.eDir = OMX_DirInput;</span><br><span class="line">    <span class="keyword">def</span>.nBufferCountMin = kNumBuffers;</span><br><span class="line">    <span class="keyword">def</span>.nBufferCountActual = <span class="keyword">def</span>.nBufferCountMin;</span><br><span class="line">    <span class="keyword">def</span>.nBufferSize = <span class="number">8192</span>;</span><br><span class="line">    <span class="keyword">def</span>.bEnabled = OMX_TRUE;</span><br><span class="line">    <span class="keyword">def</span>.bPopulated = OMX_FALSE;</span><br><span class="line">    <span class="keyword">def</span>.eDomain = OMX_PortDomainAudio;</span><br><span class="line">    <span class="keyword">def</span>.bBuffersContiguous = OMX_FALSE;</span><br><span class="line">    <span class="keyword">def</span>.nBufferAlignment = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">def</span>.<span class="built_in">format</span>.audio.cMIMEType = const_cast&lt;char *&gt;(MEDIA_MIMETYPE_AUDIO_MPEG);</span><br><span class="line">    <span class="keyword">def</span>.<span class="built_in">format</span>.audio.pNativeRender = NULL;</span><br><span class="line">    <span class="keyword">def</span>.<span class="built_in">format</span>.audio.bFlagErrorConcealment = OMX_FALSE;</span><br><span class="line">    <span class="keyword">def</span>.<span class="built_in">format</span>.audio.eEncoding = OMX_AUDIO_CodingMP3;</span><br><span class="line">    addPort(<span class="keyword">def</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span>.nPortIndex = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">def</span>.eDir = OMX_DirOutput;</span><br><span class="line">    <span class="keyword">def</span>.nBufferCountMin = kNumBuffers;</span><br><span class="line">    <span class="keyword">def</span>.nBufferCountActual = <span class="keyword">def</span>.nBufferCountMin;</span><br><span class="line">    <span class="keyword">def</span>.nBufferSize = kOutputBufferSize;</span><br><span class="line">    <span class="keyword">def</span>.bEnabled = OMX_TRUE;</span><br><span class="line">    <span class="keyword">def</span>.bPopulated = OMX_FALSE;</span><br><span class="line">    <span class="keyword">def</span>.eDomain = OMX_PortDomainAudio;</span><br><span class="line">    <span class="keyword">def</span>.bBuffersContiguous = OMX_FALSE;</span><br><span class="line">    <span class="keyword">def</span>.nBufferAlignment = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">def</span>.<span class="built_in">format</span>.audio.cMIMEType = const_cast&lt;char *&gt;(<span class="string">&quot;audio/raw&quot;</span>);</span><br><span class="line">    <span class="keyword">def</span>.<span class="built_in">format</span>.audio.pNativeRender = NULL;</span><br><span class="line">    <span class="keyword">def</span>.<span class="built_in">format</span>.audio.bFlagErrorConcealment = OMX_FALSE;</span><br><span class="line">    <span class="keyword">def</span>.<span class="built_in">format</span>.audio.eEncoding = OMX_AUDIO_CodingPCM;</span><br><span class="line">    addPort(<span class="keyword">def</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
紧接着调用initDecoder来初始化解码器。<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void SoftMP3::init<span class="constructor">Decoder()</span> &#123;</span><br><span class="line">    mConfig-&gt;equalizerType = flat;</span><br><span class="line">    mConfig-&gt;crcEnabled = <span class="literal">false</span>;</span><br><span class="line">    uint32_t memRequirements = pvmp3<span class="constructor">_decoderMemRequirements()</span>;</span><br><span class="line">    mDecoderBuf = malloc(memRequirements);</span><br><span class="line">    pvmp3<span class="constructor">_InitDecoder(<span class="params">mConfig</span>, <span class="params">mDecoderBuf</span>)</span>;</span><br><span class="line">    mIsFirst = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
到这里我们再回头总结下，我们之前介绍过如何从传入的mimetype到创建出component。这里component个人认为是一个解码组件，它有一个核心的解码器以及一个输入端口，一个输出端口，上面所作的工作就是初始化这个核心解码器，以及解码器的输入端口和输出端口的配置。<br>这里还需要注意的是OMX_CALLBACKTYPE，OMX_COMPONENTTYPE这两个对象以及mHandler。还是上个图吧，无图无真相！</li>
</ol>
<p><img src="/2016/07/31/Android-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E5%9F%BA%E4%BA%8EStagefright%E7%9A%84MediaPlayer%E6%92%AD%E6%94%BE%E6%A1%86%E6%9E%B6-2/24.png"></p>
<p>我们回过头来看下allocateNode，在对应的解码器创建结束后调用makeNodeID为对应的node创建ID并添加到mNodeIDToInstance中。这里每个实例对应一个id</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">OMX::node_id OMX::makeNodeID(OMXNodeInstance *instance) &#123;</span><br><span class="line">    // mLock is already held.</span><br><span class="line">    node_id <span class="keyword">node</span> <span class="title">= (node_id</span>)++mNodeCounter;</span><br><span class="line">    mNodeIDToInstance.add(<span class="keyword">node</span><span class="title">, instance</span>);</span><br><span class="line">    return <span class="keyword">node</span><span class="title">;</span></span><br><span class="line"><span class="title">&#125;</span></span><br></pre></td></tr></table></figure>
<p>紧接着就是创建OMXCodec，在OMXCodec构造方法中调用setComponentRole，根据对应的mimeType，以及isEncoder来获取对应的Role Name，并对其进行初始化。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">OMXCodec::<span class="built_in">OMXCodec</span>(</span><br><span class="line">        <span class="type">const</span> sp&lt;IOMX&gt; &amp;omx, IOMX::node_id node,</span><br><span class="line">        <span class="type">uint32_t</span> quirks, <span class="type">uint32_t</span> flags,</span><br><span class="line">        <span class="type">bool</span> isEncoder,</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *mime,</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *componentName,</span><br><span class="line">        <span class="type">const</span> sp&lt;MediaSource&gt; &amp;source,</span><br><span class="line">        <span class="type">const</span> sp&lt;ANativeWindow&gt; &amp;nativeWindow)</span><br><span class="line">    : <span class="built_in">mOMX</span>(omx),</span><br><span class="line">    <span class="comment">//……………………………………….</span></span><br><span class="line">    mPortStatus[kPortIndexInput] = ENABLED;</span><br><span class="line">    mPortStatus[kPortIndexOutput] = ENABLED;</span><br><span class="line">    <span class="built_in">setComponentRole</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">OMXCodec::setComponentRole</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> sp&lt;IOMX&gt; &amp;omx, IOMX::node_id node, <span class="type">bool</span> isEncoder,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> <span class="type">char</span> *mime)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">MimeToRole</span> &#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *mime;</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *decoderRole;</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *encoderRole;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> MimeToRole kMimeToRole[] = &#123;</span><br><span class="line">        &#123; MEDIA_MIMETYPE_AUDIO_MPEG,</span><br><span class="line">            <span class="string">&quot;audio_decoder.mp3&quot;</span>, <span class="string">&quot;audio_encoder.mp3&quot;</span> &#125;,</span><br><span class="line">        &#123; MEDIA_MIMETYPE_AUDIO_MPEG_LAYER_I,</span><br><span class="line">            <span class="string">&quot;audio_decoder.mp1&quot;</span>, <span class="string">&quot;audio_encoder.mp1&quot;</span> &#125;,</span><br><span class="line">        &#123; MEDIA_MIMETYPE_AUDIO_MPEG_LAYER_II,</span><br><span class="line">            <span class="string">&quot;audio_decoder.mp2&quot;</span>, <span class="string">&quot;audio_encoder.mp2&quot;</span> &#125;,</span><br><span class="line">        &#123; MEDIA_MIMETYPE_AUDIO_AMR_NB,</span><br><span class="line">            <span class="string">&quot;audio_decoder.amrnb&quot;</span>, <span class="string">&quot;audio_encoder.amrnb&quot;</span> &#125;,</span><br><span class="line">        &#123; MEDIA_MIMETYPE_AUDIO_AMR_WB,</span><br><span class="line">            <span class="string">&quot;audio_decoder.amrwb&quot;</span>, <span class="string">&quot;audio_encoder.amrwb&quot;</span> &#125;,</span><br><span class="line">        &#123; MEDIA_MIMETYPE_AUDIO_AAC,</span><br><span class="line">            <span class="string">&quot;audio_decoder.aac&quot;</span>, <span class="string">&quot;audio_encoder.aac&quot;</span> &#125;,</span><br><span class="line">        &#123; MEDIA_MIMETYPE_AUDIO_VORBIS,</span><br><span class="line">            <span class="string">&quot;audio_decoder.vorbis&quot;</span>, <span class="string">&quot;audio_encoder.vorbis&quot;</span> &#125;,</span><br><span class="line">        &#123; MEDIA_MIMETYPE_AUDIO_OPUS,</span><br><span class="line">            <span class="string">&quot;audio_decoder.opus&quot;</span>, <span class="string">&quot;audio_encoder.opus&quot;</span> &#125;,</span><br><span class="line">        &#123; MEDIA_MIMETYPE_AUDIO_G711_MLAW,</span><br><span class="line">            <span class="string">&quot;audio_decoder.g711mlaw&quot;</span>, <span class="string">&quot;audio_encoder.g711mlaw&quot;</span> &#125;,</span><br><span class="line">        &#123; MEDIA_MIMETYPE_AUDIO_G711_ALAW,</span><br><span class="line">            <span class="string">&quot;audio_decoder.g711alaw&quot;</span>, <span class="string">&quot;audio_encoder.g711alaw&quot;</span> &#125;,</span><br><span class="line">        &#123; MEDIA_MIMETYPE_VIDEO_AVC,</span><br><span class="line">            <span class="string">&quot;video_decoder.avc&quot;</span>, <span class="string">&quot;video_encoder.avc&quot;</span> &#125;,</span><br><span class="line">        &#123; MEDIA_MIMETYPE_VIDEO_HEVC,</span><br><span class="line">            <span class="string">&quot;video_decoder.hevc&quot;</span>, <span class="string">&quot;video_encoder.hevc&quot;</span> &#125;,</span><br><span class="line">        &#123; MEDIA_MIMETYPE_VIDEO_MPEG4,</span><br><span class="line">            <span class="string">&quot;video_decoder.mpeg4&quot;</span>, <span class="string">&quot;video_encoder.mpeg4&quot;</span> &#125;,</span><br><span class="line">        &#123; MEDIA_MIMETYPE_VIDEO_H263,</span><br><span class="line">            <span class="string">&quot;video_decoder.h263&quot;</span>, <span class="string">&quot;video_encoder.h263&quot;</span> &#125;,</span><br><span class="line">        &#123; MEDIA_MIMETYPE_VIDEO_VP8,</span><br><span class="line">            <span class="string">&quot;video_decoder.vp8&quot;</span>, <span class="string">&quot;video_encoder.vp8&quot;</span> &#125;,</span><br><span class="line">        &#123; MEDIA_MIMETYPE_VIDEO_VP9,</span><br><span class="line">            <span class="string">&quot;video_decoder.vp9&quot;</span>, <span class="string">&quot;video_encoder.vp9&quot;</span> &#125;,</span><br><span class="line">        &#123; MEDIA_MIMETYPE_AUDIO_RAW,</span><br><span class="line">            <span class="string">&quot;audio_decoder.raw&quot;</span>, <span class="string">&quot;audio_encoder.raw&quot;</span> &#125;,</span><br><span class="line">        &#123; MEDIA_MIMETYPE_AUDIO_FLAC,</span><br><span class="line">            <span class="string">&quot;audio_decoder.flac&quot;</span>, <span class="string">&quot;audio_encoder.flac&quot;</span> &#125;,</span><br><span class="line">        &#123; MEDIA_MIMETYPE_AUDIO_MSGSM,</span><br><span class="line">            <span class="string">&quot;audio_decoder.gsm&quot;</span>, <span class="string">&quot;audio_encoder.gsm&quot;</span> &#125;,</span><br><span class="line">        &#123; MEDIA_MIMETYPE_VIDEO_MPEG2,</span><br><span class="line">            <span class="string">&quot;video_decoder.mpeg2&quot;</span>, <span class="string">&quot;video_encoder.mpeg2&quot;</span> &#125;,</span><br><span class="line">        &#123; MEDIA_MIMETYPE_AUDIO_AC3,</span><br><span class="line">            <span class="string">&quot;audio_decoder.ac3&quot;</span>, <span class="string">&quot;audio_encoder.ac3&quot;</span> &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">size_t</span> kNumMimeToRole =</span><br><span class="line">        <span class="built_in">sizeof</span>(kMimeToRole) / <span class="built_in">sizeof</span>(kMimeToRole[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; kNumMimeToRole; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcasecmp</span>(mime, kMimeToRole[i].mime)) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i == kNumMimeToRole) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *role =</span><br><span class="line">        isEncoder ? kMimeToRole[i].encoderRole</span><br><span class="line">                  : kMimeToRole[i].decoderRole;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (role != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        OMX_PARAM_COMPONENTROLETYPE roleParams;</span><br><span class="line">        <span class="built_in">InitOMXParams</span>(&amp;roleParams);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">strncpy</span>((<span class="type">char</span> *)roleParams.cRole,</span><br><span class="line">                role, OMX_MAX_STRINGNAME_SIZE - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        roleParams.cRole[OMX_MAX_STRINGNAME_SIZE - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">status_t</span> err = omx-&gt;<span class="built_in">setParameter</span>(</span><br><span class="line">                node, OMX_IndexParamStandardComponentRole,</span><br><span class="line">                &amp;roleParams, <span class="built_in">sizeof</span>(roleParams));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (err != OK) &#123;</span><br><span class="line">            <span class="built_in">ALOGW</span>(<span class="string">&quot;Failed to set standard component role &#x27;%s&#x27;.&quot;</span>, role);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看完了解码器的创建过程，我们继续看下initAudioDecoder中的</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">status_t</span> err = mAudioSource-&gt;</span>start()，首先我们需要明确mAudioSource是怎么来的，</span><br><span class="line">status_t AwesomePlayer::initAudioDecoder() &#123;</span><br><span class="line">    <span class="keyword">if</span> (!strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_RAW)) &#123;</span><br><span class="line">        mAudioSource = mAudioTrack;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mOmxSource = OMXCodec::Create(</span><br><span class="line">                <span class="function"><span class="title">mClient</span>.interface(), mAudioTrack-&gt;</span>getFormat(),</span><br><span class="line">                <span class="literal">false</span>, <span class="comment">// createEncoder</span></span><br><span class="line">                mAudioTrack);</span><br><span class="line">        <span class="keyword">if</span> (mOffloadAudio) &#123;</span><br><span class="line">            mAudioSource = mAudioTrack;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mAudioSource = mOmxSource;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;        </span><br><span class="line"><span class="function"><span class="title">status_t</span> err = mAudioSource-&gt;</span>start();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>从上面可以看出mAudioSource指的是mOmxSource，是创建出来的OMXCodec。而OMXCodec::Create返回值是一个OMXCodec对象。所以我们接下来看下OMXCodec的start方法.</p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line">status_t OMXCodec<span class="type">::start</span>(MetaData *meta) &#123;</span><br><span class="line">    Mutex<span class="type">::Autolock</span> autoLock(mLock);</span><br><span class="line">    sp&lt;MetaData&gt; <span class="keyword">params</span> = <span class="literal">new</span> MetaData;</span><br><span class="line">    <span class="comment">//………………………………………………..</span></span><br><span class="line">    <span class="comment">// Decoder case</span></span><br><span class="line">    <span class="keyword">if</span> ((err = mSource-&gt;start(<span class="keyword">params</span>.get())) != OK) &#123;</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在该方法中调用了mSource的start方法，以及init()方法，我们在该段代码中主要针对这两部分进行分析。同样我们在分析具体流程之前需要明确mSource到底指的是什么，这就需要从它的根源找起.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">OMXCodec::<span class="built_in">OMXCodec</span>(</span><br><span class="line">        <span class="type">const</span> sp&lt;IOMX&gt; &amp;omx, IOMX::node_id node,</span><br><span class="line">        <span class="type">uint32_t</span> quirks, <span class="type">uint32_t</span> flags,</span><br><span class="line">        <span class="type">bool</span> isEncoder,</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *mime,</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *componentName,</span><br><span class="line">        <span class="type">const</span> sp&lt;MediaSource&gt; &amp;source,</span><br><span class="line">        <span class="type">const</span> sp&lt;ANativeWindow&gt; &amp;nativeWindow)</span><br><span class="line">    : <span class="built_in">mOMX</span>(omx),</span><br><span class="line">      <span class="comment">//……………………………….</span></span><br><span class="line">      <span class="built_in">mSource</span>(source),</span><br><span class="line">      <span class="comment">//……………………………..&#123;</span></span><br><span class="line">    mPortStatus[kPortIndexInput] = ENABLED;</span><br><span class="line">    mPortStatus[kPortIndexOutput] = ENABLED;</span><br><span class="line">    <span class="built_in">setComponentRole</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">sp<span class="variable">&lt;MediaSource&gt;</span> OMXCodec::Create(</span><br><span class="line">        <span class="keyword">const</span> sp<span class="variable">&lt;IOMX&gt;</span> &amp;omx,</span><br><span class="line">        <span class="keyword">const</span> sp<span class="variable">&lt;MetaData&gt;</span> &amp;meta, bool createEncoder,</span><br><span class="line">        <span class="keyword">const</span> sp<span class="variable">&lt;MediaSource&gt;</span> &amp;source,</span><br><span class="line">        <span class="keyword">const</span> char *<span class="built_in">match</span>ComponentName,</span><br><span class="line">        uint32_t <span class="keyword">flags</span>,</span><br><span class="line">        <span class="keyword">const</span> sp<span class="variable">&lt;ANativeWindow&gt;</span> &amp;nativeWindow) &#123;</span><br><span class="line">            sp<span class="variable">&lt;OMXCodec&gt;</span> codec = new OMXCodec(</span><br><span class="line">                    omx, node, quirks, <span class="keyword">flags</span>,</span><br><span class="line">                    createEncoder, mime, componentName,</span><br><span class="line">                    source, nativeWindow);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight zephir"><table><tr><td class="code"><pre><span class="line">status_t AwesomePlayer::initAudioDecoder() &#123;</span><br><span class="line">        mOmxSource = OMXCodec::Create(</span><br><span class="line">                mClient.<span class="keyword">interface</span>(), mAudioTrack-&gt;getFormat(),</span><br><span class="line">                <span class="keyword">false</span>, <span class="comment">// createEncoder</span></span><br><span class="line">                mAudioTrack);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> AwesomePlayer::setAudioSource(sp&lt;MediaSource&gt; <span class="keyword">source</span>) &#123;</span><br><span class="line">    CHECK(<span class="keyword">source</span> != <span class="keyword">NULL</span>);</span><br><span class="line">    mAudioTrack = <span class="keyword">source</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里使用MediaExtractor对视频文件做A&#x2F;V的分离</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">status_t AwesomePlayer::set<span class="constructor">DataSource_l(<span class="params">const</span> <span class="params">sp</span>&lt;MediaExtractor&gt; &amp;<span class="params">extractor</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; extractor-&gt;count<span class="constructor">Tracks()</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!haveVideo<span class="operator"> &amp;&amp; </span>!strncasecmp(mime.<span class="built_in">string</span><span class="literal">()</span>, <span class="string">&quot;video/&quot;</span>, <span class="number">6</span>)) &#123;</span><br><span class="line">           set<span class="constructor">VideoSource(<span class="params">extractor</span>-&gt;<span class="params">getTrack</span>(<span class="params">i</span>)</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!haveAudio<span class="operator"> &amp;&amp; </span>!strncasecmp(mime.<span class="built_in">string</span><span class="literal">()</span>, <span class="string">&quot;audio/&quot;</span>, <span class="number">6</span>)) &#123;</span><br><span class="line">            set<span class="constructor">AudioSource(<span class="params">extractor</span>-&gt;<span class="params">getTrack</span>(<span class="params">i</span>)</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面是整个调用的过程，从上面可以看出最终的调用根源来自extractor-&gt;getTrack，假设当前播放歌曲的格式为MP3格式，那么extractor就是MP3Extractor,则mAudioTrack就是MP3Extractor::getTrack的返回值，也就是MP3Source，知道了这点我们就可以继续对prepare流程进行分析了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">sp&lt;MediaSource&gt; <span class="title">MP3Extractor::getTrack</span><span class="params">(<span class="type">size_t</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mInitCheck != OK || index != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">MP3Source</span>(</span><br><span class="line">            mMeta, mDataSource, mFirstFramePos, mFixedHeader,</span><br><span class="line">            mSeeker);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MP3Source::start中主要创建出一个MediaBuffer然后调用MediaBufferGroup的add_buffer方法将其添加到MediaBufferGroup中。并且将一些相关的标志位置为初始状态。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">status_t MP3Source::start(MetaData *) &#123;</span><br><span class="line">    <span class="constructor">CHECK(!<span class="params">mStarted</span>)</span>;</span><br><span class="line">    mGroup = <span class="keyword">new</span> MediaBufferGroup;</span><br><span class="line">    mGroup-&gt;add<span class="constructor">_buffer(<span class="params">new</span> MediaBuffer(<span class="params">kMaxFrameSize</span>)</span>);</span><br><span class="line">    mCurrentPos = mFirstFramePos;</span><br><span class="line">    mCurrentTimeUs = <span class="number">0</span>;</span><br><span class="line">    mBasisTimeUs = mCurrentTimeUs;</span><br><span class="line">    mSamplesRead = <span class="number">0</span>;</span><br><span class="line">    mStarted = <span class="literal">true</span>;</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来我们看下init方法。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">status_t OMXCodec::init<span class="literal">()</span> &#123;</span><br><span class="line">    <span class="comment">// mLock is held.</span></span><br><span class="line">    status_t err;</span><br><span class="line">    <span class="keyword">if</span> (!(mQuirks &amp; kRequiresLoadedToIdleAfterAllocation)) &#123;</span><br><span class="line">        err = mOMX-&gt;send<span class="constructor">Command(<span class="params">mNode</span>, OMX_CommandStateSet, OMX_StateIdle)</span>;</span><br><span class="line">        set<span class="constructor">State(LOADED_TO_IDLE)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    err = allocate<span class="constructor">Buffers()</span>;</span><br><span class="line">    <span class="keyword">if</span> (mQuirks &amp; kRequiresLoadedToIdleAfterAllocation) &#123;</span><br><span class="line">        err = mOMX-&gt;send<span class="constructor">Command(<span class="params">mNode</span>, OMX_CommandStateSet, OMX_StateIdle)</span>;</span><br><span class="line">        set<span class="constructor">State(LOADED_TO_IDLE)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (mState != EXECUTING<span class="operator"> &amp;&amp; </span>mState != ERROR) &#123;</span><br><span class="line">        mAsyncCompletion.wait(mLock);</span><br><span class="line">    &#125;</span><br><span class="line">    return mState<span class="operator"> == </span>ERROR ? UNKNOWN_ERROR : OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在init方法中主要是通过调用allocateBuffers来为输入输出端口分配缓存，紧接着调用mOMX-&gt;sendCommand将状态设置到底层。首先我们看下allocateBuffers方法：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">status_t OMXCodec::allocate<span class="constructor">Buffers()</span> &#123;</span><br><span class="line">    status_t err = allocate<span class="constructor">BuffersOnPort(<span class="params">kPortIndexInput</span>)</span>;</span><br><span class="line">    return allocate<span class="constructor">BuffersOnPort(<span class="params">kPortIndexOutput</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在allocateBuffersOnPort中分别为输入输出端口分配指定大小的缓存空间并对其统一管理。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">OMXCodec::allocateBuffersOnPort</span><span class="params">(OMX_U32 portIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mNativeWindow != <span class="literal">NULL</span> &amp;&amp; portIndex == kPortIndexOutput) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">allocateOutputBuffersFromNativeWindow</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">status_t</span> err = OK;</span><br><span class="line">    <span class="keyword">if</span> ((mFlags &amp; kStoreMetaDataInVideoBuffers)</span><br><span class="line">            &amp;&amp; portIndex == kPortIndexInput) &#123;</span><br><span class="line">        err = mOMX-&gt;<span class="built_in">storeMetaDataInBuffers</span>(mNode, kPortIndexInput, OMX_TRUE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    OMX_PARAM_PORTDEFINITIONTYPE def;</span><br><span class="line">    <span class="comment">//在获取参数def之前先初始下</span></span><br><span class="line">    <span class="built_in">InitOMXParams</span>(&amp;def);</span><br><span class="line">    def.nPortIndex = portIndex;</span><br><span class="line">    <span class="comment">//获取指定端口的def参数</span></span><br><span class="line">    err = mOMX-&gt;<span class="built_in">getParameter</span>(mNode, OMX_IndexParamPortDefinition, &amp;def, <span class="built_in">sizeof</span>(def));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CODEC_LOGV</span>(<span class="string">&quot;allocating %u buffers of size %u on %s port&quot;</span>,</span><br><span class="line">            def.nBufferCountActual, def.nBufferSize,</span><br><span class="line">            portIndex == kPortIndexInput ? <span class="string">&quot;input&quot;</span> : <span class="string">&quot;output&quot;</span>);</span><br><span class="line">    <span class="comment">//开始为指定端口分配大小为def.nBufferSize 个数为def.nBufferCountActual的缓存</span></span><br><span class="line">    <span class="comment">//在分配参数之前先检查def.nBufferSize ，def.nBufferCountActual 是否合理</span></span><br><span class="line">    <span class="keyword">if</span> (def.nBufferSize != <span class="number">0</span> &amp;&amp; def.nBufferCountActual &gt; SIZE_MAX / def.nBufferSize) &#123;</span><br><span class="line">        <span class="keyword">return</span> BAD_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//开始分配大小为totalSize的总空间</span></span><br><span class="line">    <span class="type">size_t</span> totalSize = def.nBufferCountActual * def.nBufferSize;</span><br><span class="line">    mDealer[portIndex] = <span class="keyword">new</span> <span class="built_in">MemoryDealer</span>(totalSize, <span class="string">&quot;OMXCodec&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (OMX_U32 i = <span class="number">0</span>; i &lt; def.nBufferCountActual; ++i) &#123;</span><br><span class="line">    <span class="comment">//从总缓存空间中划分出一个大小为 def.nBufferSize的空间</span></span><br><span class="line">        sp&lt;IMemory&gt; mem = mDealer[portIndex]-&gt;<span class="built_in">allocate</span>(def.nBufferSize);</span><br><span class="line">        BufferInfo info;</span><br><span class="line">        info.mData = <span class="literal">NULL</span>;</span><br><span class="line">        info.mSize = def.nBufferSize;</span><br><span class="line">        IOMX::buffer_id buffer;</span><br><span class="line">        <span class="keyword">if</span> (portIndex == kPortIndexInput</span><br><span class="line">                &amp;&amp; ((mQuirks &amp; kRequiresAllocateBufferOnInputPorts)</span><br><span class="line">                    || (mFlags &amp; kUseSecureInputBuffers))) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mOMXLivesLocally) &#123;</span><br><span class="line">               <span class="comment">//在使用前将存储空间进行清除</span></span><br><span class="line">                mem.<span class="built_in">clear</span>();</span><br><span class="line">               <span class="comment">//为该解码器输入端口分配空间</span></span><br><span class="line">                err = mOMX-&gt;<span class="built_in">allocateBuffer</span>(</span><br><span class="line">                        mNode, portIndex, def.nBufferSize, &amp;buffer,</span><br><span class="line">                        &amp;info.mData);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                err = mOMX-&gt;<span class="built_in">allocateBufferWithBackup</span>(</span><br><span class="line">                        mNode, portIndex, mem, &amp;buffer, mem-&gt;<span class="built_in">size</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (portIndex == kPortIndexOutput</span><br><span class="line">                &amp;&amp; (mQuirks &amp; kRequiresAllocateBufferOnOutputPorts)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mOMXLivesLocally) &#123;</span><br><span class="line">               <span class="comment">//在使用前将存储空间进行清除</span></span><br><span class="line">                mem.<span class="built_in">clear</span>();</span><br><span class="line">               <span class="comment">//为该解码器输入端口分配空间</span></span><br><span class="line">                err = mOMX-&gt;<span class="built_in">allocateBuffer</span>(</span><br><span class="line">                        mNode, portIndex, def.nBufferSize, &amp;buffer,</span><br><span class="line">                        &amp;info.mData);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                err = mOMX-&gt;<span class="built_in">allocateBufferWithBackup</span>(</span><br><span class="line">                        mNode, portIndex, mem, &amp;buffer, mem-&gt;<span class="built_in">size</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            err = mOMX-&gt;<span class="built_in">useBuffer</span>(mNode, portIndex, mem, &amp;buffer, mem-&gt;<span class="built_in">size</span>());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mem != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            info.mData = mem-&gt;<span class="built_in">pointer</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        info.mBuffer = buffer;</span><br><span class="line">        info.mStatus = OWNED_BY_US;</span><br><span class="line">        info.mMem = mem;</span><br><span class="line">        info.mMediaBuffer = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">//将分配的缓存信息添加到端口缓存表中进行统一管理</span></span><br><span class="line">        mPortBuffers[portIndex].<span class="built_in">push</span>(info);</span><br><span class="line">        <span class="built_in">CODEC_LOGV</span>(<span class="string">&quot;allocated buffer %u on %s port&quot;</span>, buffer,</span><br><span class="line">             portIndex == kPortIndexInput ? <span class="string">&quot;input&quot;</span> : <span class="string">&quot;output&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (portIndex == kPortIndexOutput) &#123;</span><br><span class="line">        sp&lt;MetaData&gt; meta = mSource-&gt;<span class="built_in">getFormat</span>();</span><br><span class="line">        <span class="type">int32_t</span> delay = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (!meta-&gt;<span class="built_in">findInt32</span>(kKeyEncoderDelay, &amp;delay)) &#123;</span><br><span class="line">            delay = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int32_t</span> padding = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (!meta-&gt;<span class="built_in">findInt32</span>(kKeyEncoderPadding, &amp;padding)) &#123;</span><br><span class="line">            padding = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int32_t</span> numchannels = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (delay + padding) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mOutputFormat-&gt;<span class="built_in">findInt32</span>(kKeyChannelCount, &amp;numchannels)) &#123;</span><br><span class="line">                <span class="type">size_t</span> frameSize = numchannels * <span class="built_in">sizeof</span>(<span class="type">int16_t</span>);</span><br><span class="line">                <span class="keyword">if</span> (mSkipCutBuffer != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                    <span class="type">size_t</span> prevbuffersize = mSkipCutBuffer-&gt;<span class="built_in">size</span>();</span><br><span class="line">                    <span class="keyword">if</span> (prevbuffersize != <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="built_in">ALOGW</span>(<span class="string">&quot;Replacing SkipCutBuffer holding %zu bytes&quot;</span>,</span><br><span class="line">                        prevbuffersize);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                mSkipCutBuffer = <span class="keyword">new</span> <span class="built_in">SkipCutBuffer</span>(delay * frameSize, padding * frameSize);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (portIndex == kPortIndexInput &amp;&amp; (mFlags &amp; kUseSecureInputBuffers)) &#123;</span><br><span class="line">        Vector&lt;MediaBuffer *&gt; buffers;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; def.nBufferCountActual; ++i) &#123;</span><br><span class="line">            <span class="type">const</span> BufferInfo &amp;info = mPortBuffers[kPortIndexInput].<span class="built_in">itemAt</span>(i);</span><br><span class="line"></span><br><span class="line">            MediaBuffer *mbuf = <span class="keyword">new</span> <span class="built_in">MediaBuffer</span>(info.mData, info.mSize);</span><br><span class="line">            buffers.<span class="built_in">push</span>(mbuf);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">status_t</span> err = mSource-&gt;<span class="built_in">setBuffers</span>(buffers);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">OMX::allocateBuffer</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        node_id node, OMX_U32 port_index, <span class="type">size_t</span> size,</span></span></span><br><span class="line"><span class="params"><span class="function">        buffer_id *buffer, <span class="type">void</span> **buffer_data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">findInstance</span>(node)-&gt;<span class="built_in">allocateBuffer</span>(port_index, size, buffer, buffer_data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">status_t OMXNodeInstance::allocateBuffer(</span><br><span class="line">        OMX_U32 portIndex, size_t size, OMX::<span class="keyword">buffer_id </span>*<span class="keyword">buffer,</span></span><br><span class="line"><span class="keyword"></span>        void **<span class="keyword">buffer_data) </span>&#123;</span><br><span class="line"><span class="symbol">    Mutex:</span>:Autolock autoLock(mLock);</span><br><span class="line">    <span class="keyword">BufferMeta </span>*<span class="keyword">buffer_meta </span>= new <span class="keyword">BufferMeta(size);</span></span><br><span class="line"><span class="keyword"></span>    OMX_BUFFERHEADERTYPE *header;</span><br><span class="line">    OMX_ERRORTYPE err = OMX_AllocateBuffer(mHandle, &amp;header, portIndex, <span class="keyword">buffer_meta, </span>size);</span><br><span class="line">    if (err != OMX_ErrorNone) &#123;</span><br><span class="line">        <span class="keyword">CLOG_ERROR(allocateBuffer, </span>err, <span class="keyword">BUFFER_FMT(portIndex, </span><span class="string">&quot;%zu@&quot;</span>, size));</span><br><span class="line">        delete <span class="keyword">buffer_meta;</span></span><br><span class="line"><span class="keyword"></span>        <span class="keyword">buffer_meta </span>= NULL;</span><br><span class="line">        *<span class="keyword">buffer </span>= <span class="number">0</span>;</span><br><span class="line">        return StatusFromOMXError(err);</span><br><span class="line">    &#125;</span><br><span class="line">    CHECK_EQ(header-&gt;pAppPrivate, <span class="keyword">buffer_meta);</span></span><br><span class="line"><span class="keyword"></span>    *<span class="keyword">buffer </span>= makeBufferID(header);</span><br><span class="line">    *<span class="keyword">buffer_data </span>= header-&gt;pBuffer;</span><br><span class="line">    <span class="keyword">addActiveBuffer(portIndex, </span>*<span class="keyword">buffer);</span></span><br><span class="line"><span class="keyword"></span>    <span class="built_in">sp</span>&lt;GraphicBufferSource&gt; <span class="keyword">bufferSource(getGraphicBufferSource());</span></span><br><span class="line"><span class="keyword"></span>    if (<span class="keyword">bufferSource </span>!= NULL &amp;&amp; portIndex == kPortIndexInput) &#123;</span><br><span class="line">        <span class="keyword">bufferSource-&gt;addCodecBuffer(header);</span></span><br><span class="line"><span class="keyword"></span>    &#125;</span><br><span class="line">    <span class="keyword">CLOG_BUFFER(allocateBuffer, </span>NEW_BUFFER_FMT(*<span class="keyword">buffer, </span>portIndex, <span class="string">&quot;%zu@%p&quot;</span>, size, *<span class="keyword">buffer_data));</span></span><br><span class="line"><span class="keyword"></span>    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之前我们提到过我们创建一个Component的时候会调用initPort初始化端口参数，但是那时候还没为端口分配内存，仅仅只是参数设置而已，这里的init就开始为每个端口分配内存空间了，在空间分配的时候会先从内存中划分出一整块所需的总空间，然后再细分后调用addActiveBuffer将其分配给某个端口：<br>老办法上图来说明内存分配这部分的原理：<br><img src="/2016/07/31/Android-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E5%9F%BA%E4%BA%8EStagefright%E7%9A%84MediaPlayer%E6%92%AD%E6%94%BE%E6%A1%86%E6%9E%B6-2/25.png"></p>
<p>接下来我们看下sendCommand部分：</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">status_t OMX::sendCommand(</span><br><span class="line">        node_id <span class="keyword">node</span><span class="title">, OMX_COMMANDTYPE</span> cmd, OMX_S32 param) &#123;</span><br><span class="line">    return findInstance(<span class="keyword">node</span><span class="title">)-&gt;sendCommand</span>(cmd, param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">OMXNodeInstance *OMX::find<span class="constructor">Instance(<span class="params">node_id</span> <span class="params">node</span>)</span> &#123;</span><br><span class="line">    Mutex::Autolock auto<span class="constructor">Lock(<span class="params">mLock</span>)</span>;</span><br><span class="line">    ssize_t index = mNodeIDToInstance.index<span class="constructor">OfKey(<span class="params">node</span>)</span>;</span><br><span class="line">    return index &lt; <span class="number">0</span> ? NULL : mNodeIDToInstance.value<span class="constructor">At(<span class="params">index</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">OMXNodeInstance::sendCommand</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        OMX_COMMANDTYPE cmd, OMX_S32 param)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="type">const</span> sp&lt;GraphicBufferSource&gt;&amp; <span class="title">bufferSource</span><span class="params">(getGraphicBufferSource())</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (bufferSource != <span class="literal">NULL</span> &amp;&amp; cmd == OMX_CommandStateSet) &#123;</span><br><span class="line">        <span class="keyword">if</span> (param == OMX_StateIdle) &#123;</span><br><span class="line">          <span class="comment">//将状态从Executing到Idle，ACodec等待所有的缓存返回，并且不再向解码器缓存中发送数据。</span></span><br><span class="line">            bufferSource-&gt;<span class="built_in">omxIdle</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (param == OMX_StateLoaded) &#123;</span><br><span class="line">            <span class="comment">// Initiating transition from Idle/Executing -&gt; Loaded</span></span><br><span class="line">            <span class="comment">// Buffers are about to be freed.</span></span><br><span class="line">            bufferSource-&gt;<span class="built_in">omxLoaded</span>();</span><br><span class="line">            <span class="built_in">setGraphicBufferSource</span>(<span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// fall through</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//………………………………………………..</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *paramString =</span><br><span class="line">    cmd == OMX_CommandStateSet ? <span class="built_in">asString</span>((OMX_STATETYPE)param) : <span class="built_in">portString</span>(param);</span><br><span class="line">    <span class="built_in">CLOG_STATE</span>(sendCommand, <span class="string">&quot;%s(%d), %s(%d)&quot;</span>, <span class="built_in">asString</span>(cmd), cmd, paramString, param);</span><br><span class="line">    OMX_ERRORTYPE err = <span class="built_in">OMX_SendCommand</span>(mHandle, cmd, param, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">CLOG_IF_ERROR</span>(sendCommand, err, <span class="string">&quot;%s(%d), %s(%d)&quot;</span>, <span class="built_in">asString</span>(cmd), cmd, paramString, param);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">StatusFromOMXError</span>(err);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看到上述的OMXNodeInstance::sendCommand主要有两项工作：</p>
<ol>
<li>调用 bufferSource-&gt;omxIdle();将状态从Executing到Idle，等待原先的解码结束，并不再发送数据到解码器中进行解码。</li>
<li>调用OMX_SendCommand继续后续的处理。<br>我们可以在hardware&#x2F;qcom&#x2F;media&#x2F;mm-core&#x2F;inc&#x2F;OMX_Core.h中找到OMX_SendCommand宏方法的定义，它调用hComponent中的SendCommand方法，将处理流程转给它来处理。<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">#define OMX_SendCommand(                                    \</span></span><br><span class="line">         hComponent,                                        <span class="string">\</span></span><br><span class="line">         Cmd,                                               <span class="string">\</span></span><br><span class="line">         nParam,                                            <span class="string">\</span></span><br><span class="line">         pCmdData)                                          <span class="string">\</span></span><br><span class="line">     <span class="function"><span class="params">((OMX_COMPONENTTYPE*)hComponent)</span>-&gt;</span>SendCommand(         <span class="string">\</span></span><br><span class="line">         hComponent,                                        <span class="string">\</span></span><br><span class="line">         Cmd,                                               <span class="string">\</span></span><br><span class="line">         nParam,                                            <span class="string">\</span></span><br><span class="line">         pCmdData)                          <span class="comment">/* Macro End */</span></span><br></pre></td></tr></table></figure>
OMX_SendCommand(mHandle, cmd, param, NULL)进行宏展开之后就变成将cmd这个命令传递给mHandle，让它来处理。所以我们必须明确到底mHandle指的是什么，我们在OMXNodeInstance中看到，mHandle是通过setHandle进行赋值的。<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void OMXNodeInstance::set<span class="constructor">Handle(OMX::<span class="params">node_id</span> <span class="params">node_id</span>, OMX_HANDLETYPE <span class="params">handle</span>)</span> &#123;</span><br><span class="line">    mNodeID = node_id;</span><br><span class="line">    <span class="constructor">CLOG_LIFE(<span class="params">allocateNode</span>, <span class="string">&quot;handle=%p&quot;</span>, <span class="params">handle</span>)</span>;</span><br><span class="line">    <span class="constructor">CHECK(<span class="params">mHandle</span> <span class="operator">==</span> NULL)</span>;</span><br><span class="line">    mHandle = handle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
而OMXNodeInstance::setHandle方法是在OMX::allocateNode中被调用的，而这个handle是通过mMaster-&gt;makeComponentInstance中传递出来的。<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">status_t OMX::<span class="title function_ invoke__">allocateNode</span>(</span><br><span class="line">        <span class="keyword">const</span> <span class="type">char</span> *name, <span class="keyword">const</span> sp&lt;IOMXObserver&gt; &amp;observer, node_id *node) &#123;</span><br><span class="line">   <span class="comment">//………………………………………… </span></span><br><span class="line">    OMX_ERRORTYPE err = mMaster<span class="punctuation">-&gt;</span><span class="title function_ invoke__">makeComponentInstance</span>(</span><br><span class="line">            name, &amp;OMXNodeInstance::kCallbacks,</span><br><span class="line">            instance, &amp;handle);</span><br><span class="line">    <span class="comment">//…………………………….</span></span><br><span class="line">    instance<span class="punctuation">-&gt;</span><span class="title function_ invoke__">setHandle</span>(*node, handle);</span><br><span class="line">    <span class="comment">//……………………………..</span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">OMX_ERRORTYPE OMXMaster::makeComponentInstance(</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *name,</span><br><span class="line">        <span class="keyword">const</span> OMX_CALLBACKTYPE *callbacks,</span><br><span class="line">        OMX_PTR appData,</span><br><span class="line">        OMX_COMPONENTTYPE **component) &#123;</span><br><span class="line">    <span class="comment">//……………………………………………….</span></span><br><span class="line">    OMX_ERRORTYPE <span class="keyword">err</span> =</span><br><span class="line">        <span class="keyword">plugin</span>-&gt;makeComponentInstance(name, callbacks, appData, component);</span><br><span class="line">    mPluginByInstance.add(*component, <span class="keyword">plugin</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">err</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">OMX_ERRORTYPE <span class="title">SoftOMXPlugin::makeComponentInstance</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> <span class="type">char</span> *name,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> OMX_CALLBACKTYPE *callbacks,</span></span></span><br><span class="line"><span class="params"><span class="function">        OMX_PTR appData,</span></span></span><br><span class="line"><span class="params"><span class="function">        OMX_COMPONENTTYPE **component)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//………………………………………</span></span><br><span class="line">        sp&lt;SoftOMXComponent&gt; codec =</span><br><span class="line">            (*createSoftOMXComponent)(name, callbacks, appData, component);</span><br><span class="line">        <span class="comment">//………………………………………</span></span><br><span class="line">    <span class="keyword">return</span> OMX_ErrorInvalidComponentName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight zephir"><table><tr><td class="code"><pre><span class="line">android::SoftOMXComponent *createSoftOMXComponent(</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> OMX_CALLBACKTYPE *callbacks,</span><br><span class="line">        OMX_PTR appData, OMX_COMPONENTTYPE **component) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> android::SoftMP3(name, callbacks, appData, component);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">SoftMP3::<span class="built_in">SoftMP3</span>(</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *name,</span><br><span class="line">        <span class="type">const</span> OMX_CALLBACKTYPE *callbacks,</span><br><span class="line">        OMX_PTR appData,</span><br><span class="line">        OMX_COMPONENTTYPE **component)</span><br><span class="line">    : <span class="built_in">SimpleSoftOMXComponent</span>(name, callbacks, appData, component),</span><br><span class="line">    <span class="comment">//……………………………………………………..</span></span><br><span class="line">      <span class="built_in">mOutputPortSettingsChange</span>(NONE) &#123;</span><br><span class="line">    <span class="built_in">initPorts</span>();</span><br><span class="line">    <span class="built_in">initDecoder</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">SimpleSoftOMXComponent::SimpleSoftOMXComponent(</span><br><span class="line">        const char *<span class="keyword">name</span>,</span><br><span class="line">        const OMX_CALLBACKTYPE *callbacks,</span><br><span class="line">        OMX_PTR appData,</span><br><span class="line">        OMX_COMPONENTTYPE **component)</span><br><span class="line">    : SoftOMXComponent(<span class="keyword">name</span>, callbacks, appData, component),</span><br><span class="line">      mLooper(new ALooper),</span><br><span class="line">      mHandler(new AHandlerReflector&lt;SimpleSoftOMXComponent&gt;(this)),</span><br><span class="line">      mState(OMX_StateLoaded),</span><br><span class="line">      mTargetState(OMX_StateLoaded) &#123;</span><br><span class="line">    <span class="function"><span class="title">mLooper</span>-&gt;</span>setName(<span class="keyword">name</span>);</span><br><span class="line">    <span class="function"><span class="title">mLooper</span>-&gt;</span>registerHandler(mHandler);</span><br><span class="line">    <span class="function"><span class="title">mLooper</span>-&gt;</span>start(</span><br><span class="line">            <span class="literal">false</span>, <span class="comment">// runOnCallingThread</span></span><br><span class="line">            <span class="literal">false</span>, <span class="comment">// canCallJava</span></span><br><span class="line">            ANDROID_PRIORITY_FOREGROUND);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
从上面可以看出mHandler实际上是在SimpleSoftOMXComponent构造方法中被创建的。<br>所以我们可以在SimpleSoftOMXComponent中找到它的SendCommand方法。<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">OMX_ERRORTYPE SimpleSoftOMXComponent::sendCommand(</span><br><span class="line">        OMX_COMMANDTYPE cmd, OMX_U32 param, OMX_PTR <span class="keyword">data</span>) &#123;</span><br><span class="line">    CHECK(<span class="keyword">data</span> == NULL);</span><br><span class="line">    sp&lt;AMessage&gt; msg = new AMessage(kWhatSendCommand, mHandler);</span><br><span class="line">    <span class="function"><span class="title">msg</span>-&gt;</span>setInt32(<span class="string">&quot;cmd&quot;</span>, cmd);</span><br><span class="line">    <span class="function"><span class="title">msg</span>-&gt;</span>setInt32(<span class="string">&quot;param&quot;</span>, param);</span><br><span class="line">    <span class="function"><span class="title">msg</span>-&gt;</span>post();</span><br><span class="line">    return OMX_ErrorNone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void SimpleSoftOMXComponent::on<span class="constructor">MessageReceived(<span class="params">const</span> <span class="params">sp</span>&lt;AMessage&gt; &amp;<span class="params">msg</span>)</span> &#123;</span><br><span class="line">    Mutex::Autolock auto<span class="constructor">Lock(<span class="params">mLock</span>)</span>;</span><br><span class="line">    uint32_t msgType = msg-&gt;what<span class="literal">()</span>;</span><br><span class="line">    <span class="constructor">ALOGV(<span class="string">&quot;msgType = %d&quot;</span>, <span class="params">msgType</span>)</span>;</span><br><span class="line">    switch (msgType) &#123;</span><br><span class="line">        case kWhatSendCommand:</span><br><span class="line">        &#123;</span><br><span class="line">            int32_t cmd, param;</span><br><span class="line">            <span class="constructor">CHECK(<span class="params">msg</span>-&gt;<span class="params">findInt32</span>(<span class="string">&quot;cmd&quot;</span>, &amp;<span class="params">cmd</span>)</span>);</span><br><span class="line">            <span class="constructor">CHECK(<span class="params">msg</span>-&gt;<span class="params">findInt32</span>(<span class="string">&quot;param&quot;</span>, &amp;<span class="params">param</span>)</span>);</span><br><span class="line">            on<span class="constructor">SendCommand((OMX_COMMANDTYPE)</span>cmd, (OMX_U32)param);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//………………………………………………</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line">void SimpleSoftOMXComponent::onSendCommand(</span><br><span class="line">        OMX_COMMANDTYPE cmd, OMX_U32 <span class="built_in">param</span>) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">        <span class="keyword">case</span> OMX_CommandStateSet:</span><br><span class="line">        &#123;</span><br><span class="line">            onChangeState((OMX_STATETYPE)<span class="built_in">param</span>);</span><br><span class="line">            <span class="built_in">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> OMX_CommandPortEnable:</span><br><span class="line">        <span class="keyword">case</span> OMX_CommandPortDisable:</span><br><span class="line">        &#123;</span><br><span class="line">            onPortEnable(<span class="built_in">param</span>, cmd == OMX_CommandPortEnable);</span><br><span class="line">            <span class="built_in">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> OMX_CommandFlush:</span><br><span class="line">        &#123;</span><br><span class="line">            onPortFlush(<span class="built_in">param</span>, <span class="literal">true</span> <span class="comment">/* sendFlushComplete */</span>);</span><br><span class="line">            <span class="built_in">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            TRESPASS();</span><br><span class="line">            <span class="built_in">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">void SimpleSoftOMXComponent::<span class="keyword">on</span>ChangeState(OMX_STATETYPE <span class="keyword">state</span>) &#123;</span><br><span class="line">    // We shouldn&#x27;t be <span class="keyword">in</span> a <span class="keyword">state</span> transition already.</span><br><span class="line">    CHECK_EQ((int)mState, (int)mTargetState);</span><br><span class="line">    switch (mState) &#123;</span><br><span class="line">        case OMX_StateLoaded:</span><br><span class="line">            CHECK_EQ((int)<span class="keyword">state</span>, (int)OMX_StateIdle);</span><br><span class="line">            break;</span><br><span class="line">        case OMX_StateIdle:</span><br><span class="line">            CHECK(<span class="keyword">state</span> == OMX_StateLoaded || <span class="keyword">state</span> == OMX_StateExecuting);</span><br><span class="line">            break;</span><br><span class="line">        case OMX_StateExecuting:</span><br><span class="line">        &#123;</span><br><span class="line">            CHECK_EQ((int)<span class="keyword">state</span>, (int)OMX_StateIdle);</span><br><span class="line">            <span class="keyword">for</span> (size_t i = <span class="number">0</span>; i <span class="variable">&lt; mPorts.size(); ++i) &#123;</span></span><br><span class="line"><span class="variable">                onPortFlush(i, false /* sendFlushComplete */);</span></span><br><span class="line"><span class="variable">            &#125;</span></span><br><span class="line"><span class="variable">            mState = OMX_StateIdle;</span></span><br><span class="line"><span class="variable">            notify(OMX_EventCmdComplete, OMX_CommandStateSet, state, NULL);</span></span><br><span class="line"><span class="variable">            break;</span></span><br><span class="line"><span class="variable">        &#125;</span></span><br><span class="line"><span class="variable">        default:</span></span><br><span class="line"><span class="variable">            TRESPASS();</span></span><br><span class="line"><span class="variable">    &#125;</span></span><br><span class="line"><span class="variable">    mTargetState = state;</span></span><br><span class="line"><span class="variable">    checkTransitions();</span></span><br><span class="line"><span class="variable">&#125;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight zephir"><table><tr><td class="code"><pre><span class="line">void SimpleSoftOMXComponent::checkTransitions() &#123;</span><br><span class="line">    <span class="keyword">if</span> (mState != mTargetState) &#123;</span><br><span class="line">        <span class="keyword">bool</span> transitionComplete = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (mState == OMX_StateLoaded) &#123;</span><br><span class="line">            CHECK_EQ((<span class="keyword">int</span>)mTargetState, (<span class="keyword">int</span>)OMX_StateIdle);</span><br><span class="line">            <span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; mPorts.size(); ++i) &#123;</span><br><span class="line">                <span class="keyword">const</span> PortInfo &amp;port = mPorts.itemAt(i);</span><br><span class="line">                <span class="keyword">if</span> (port.mDef.bEnabled == OMX_FALSE) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (port.mDef.bPopulated == OMX_FALSE) &#123;</span><br><span class="line">                    transitionComplete = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mTargetState == OMX_StateLoaded) &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (transitionComplete) &#123;</span><br><span class="line">            mState = mTargetState;</span><br><span class="line">            <span class="keyword">if</span> (mState == OMX_StateLoaded) &#123;</span><br><span class="line">                onReset();</span><br><span class="line">            &#125;</span><br><span class="line">            notify(OMX_EventCmdComplete, OMX_CommandStateSet, mState, NULL);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; mPorts.size(); ++i) &#123;</span><br><span class="line">        PortInfo *port = &amp;mPorts.editItemAt(i);</span><br><span class="line">        <span class="keyword">if</span> (port-&gt;mTransition == PortInfo::DISABLING) &#123;</span><br><span class="line">            <span class="keyword">if</span> (port-&gt;mBuffers.<span class="keyword">empty</span>()) &#123;</span><br><span class="line">                ALOGV(<span class="string">&quot;Port %zu now disabled.&quot;</span>, i);</span><br><span class="line">                port-&gt;mTransition = PortInfo::NONE;</span><br><span class="line">                notify(OMX_EventCmdComplete, OMX_CommandPortDisable, i, NULL);</span><br><span class="line">                onPortEnableCompleted(i, <span class="keyword">false</span> <span class="comment">/* enabled */</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (port-&gt;mTransition == PortInfo::ENABLING) &#123;</span><br><span class="line">            <span class="keyword">if</span> (port-&gt;mDef.bPopulated == OMX_TRUE) &#123;</span><br><span class="line">                ALOGV(<span class="string">&quot;Port %zu now enabled.&quot;</span>, i);</span><br><span class="line">                port-&gt;mTransition = PortInfo::NONE;</span><br><span class="line">                port-&gt;mDef.bEnabled = OMX_TRUE;</span><br><span class="line">                notify(OMX_EventCmdComplete, OMX_CommandPortEnable, i, NULL);</span><br><span class="line">                onPortEnableCompleted(i, <span class="keyword">true</span> <span class="comment">/* enabled */</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
经过上述的层层跟踪，我们看到OMX_SendCommand(mHandle, cmd, param, NULL)实际上是完成了将idle状态设置到底层并禁止往解码器中输入解码数据。至此prepare流程分析结束，从整个大的角度来看在Prepare阶段主要做的是根据待播放的类型创建对应的解码器，并为每个解码器输入输出端口创建缓存。并且将解码器的状态设置为idle状态。<br>老样子上图作为结尾。<br><img src="/2016/07/31/Android-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E5%9F%BA%E4%BA%8EStagefright%E7%9A%84MediaPlayer%E6%92%AD%E6%94%BE%E6%A1%86%E6%9E%B6-2/26.png"></li>
</ol>
<p>这样就结束了吗？还没呢，我们上面看到的只是beginAsyncPrepare_l最后还有finishAsyncPrepare_l，这里主要完成通知上层prepare结束：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void AwesomePlayer::finish<span class="constructor">AsyncPrepare_l()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mIsAsyncPrepare) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mVideoSource<span class="operator"> == </span>NULL) &#123;</span><br><span class="line">            notify<span class="constructor">Listener_l(MEDIA_SET_VIDEO_SIZE, 0, 0)</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            notify<span class="constructor">VideoSize_l()</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        notify<span class="constructor">Listener_l(MEDIA_PREPARED)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mPrepareResult = OK;</span><br><span class="line">    modify<span class="constructor">Flags((PREPARING|PREPARE_CANCELLED|PREPARING_CONNECTED)</span>, CLEAR);</span><br><span class="line">    modify<span class="constructor">Flags(PREPARED, SET)</span>;</span><br><span class="line">    mAsyncPrepareEvent = NULL;</span><br><span class="line">    mPreparedCondition.broadcast<span class="literal">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mAudioTearDown) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mPrepareResult<span class="operator"> == </span>OK) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mExtractorFlags &amp; MediaExtractor::CAN_SEEK) &#123;</span><br><span class="line">                seek<span class="constructor">To_l(<span class="params">mAudioTearDownPosition</span>)</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mAudioTearDownWasPlaying) &#123;</span><br><span class="line">                modify<span class="constructor">Flags(CACHE_UNDERRUN, CLEAR)</span>;</span><br><span class="line">                play<span class="constructor">_l()</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mAudioTearDown = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们重点看下notifyListener_l(MEDIA_PREPARED);</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void AwesomePlayer::notify<span class="constructor">Listener_l(<span class="params">int</span> <span class="params">msg</span>, <span class="params">int</span> <span class="params">ext1</span>, <span class="params">int</span> <span class="params">ext2</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ((mListener != NULL)<span class="operator"> &amp;&amp; </span>!mAudioTearDown) &#123;</span><br><span class="line">        sp&lt;MediaPlayerBase&gt; listener = mListener.promote<span class="literal">()</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (listener != NULL) &#123;</span><br><span class="line">            listener-&gt;send<span class="constructor">Event(<span class="params">msg</span>, <span class="params">ext1</span>, <span class="params">ext2</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大家还记得下面这张图吧，我们从这张图上可以很明显看出整个调用的结束点为EventHandler<br><img src="/2016/07/31/Android-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E5%9F%BA%E4%BA%8EStagefright%E7%9A%84MediaPlayer%E6%92%AD%E6%94%BE%E6%A1%86%E6%9E%B6-2/27.png"><br>整个上层的处理很简单就是先判断下是否有注册mOnPreparedListener如果有则调用onPrepared方法，将后续工作交给开发者处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> MEDIA_PREPARED:</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        scanInternalSubtitleTracks();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">        <span class="comment">// send error message instead of crashing;</span></span><br><span class="line">        <span class="comment">// send error message instead of inlining a call to onError</span></span><br><span class="line">        <span class="comment">// to avoid code duplication.</span></span><br><span class="line">        <span class="type">Message</span> <span class="variable">msg2</span> <span class="operator">=</span> obtainMessage(</span><br><span class="line">                MEDIA_ERROR, MEDIA_ERROR_UNKNOWN, MEDIA_ERROR_UNSUPPORTED, <span class="literal">null</span>);</span><br><span class="line">        sendMessage(msg2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mOnPreparedListener != <span class="literal">null</span>)</span><br><span class="line">        mOnPreparedListener.onPrepared(mMediaPlayer);</span><br><span class="line">    <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure>



  
	</div>
		<footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Android-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">Android 源码分析</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/AOSP-源码/">AOSP 源码</a>
  </div>

</div>



</footer>

   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2016/08/01/Android-源码分析基于Stagefright的MediaPlayer播放框架-3/" title="Android 源码分析之基于Stagefright的MediaPlayer播放框架[4]">
  <span>
  Android 源码分析之基于Stagefright的MediaPlayer播放框架[4]</span>
</a>
</div>


<div class="next">
<a href="/2016/07/31/Android-源码分析之基于Stagefright的MediaPlayer播放框架-1/"  title="Android 源码分析之基于Stagefright的MediaPlayer播放框架[2]">
 <span>Android 源码分析之基于Stagefright的MediaPlayer播放框架[2]
</span>
</a>
</div>

</nav>

	
<section id="comments" class="comment">
	<div class="ds-thread" data-thread-key="2016/07/31/Android-源码分析基于Stagefright的MediaPlayer播放框架-2/" data-title="Android 源码分析之基于Stagefright的MediaPlayer播放框架[3]" data-url="http://yoursite.com/2016/07/31/Android-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E5%9F%BA%E4%BA%8EStagefright%E7%9A%84MediaPlayer%E6%92%AD%E6%94%BE%E6%A1%86%E6%9E%B6-2/"></div>
</section>


<section id="comments" class="comment">
  <div id="disqus_thread">
    <noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  </div>
</section>

</div>  
      <div class="openaside"><a class="navbutton" href="#" title="Show Sidebar"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">Contents</strong>
 
 <ol class="toc"><li class="toc-item toc-level-5"><a class="toc-link" href="#MediaPlayer%E6%92%AD%E6%94%BE%E6%A1%86%E6%9E%B6%E6%BA%90%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%9A"><span class="toc-number">1.</span> <span class="toc-text">MediaPlayer播放框架源代码解析：</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#Prepare%E2%80%93%E5%8A%A0%E8%BD%BD%E8%A7%A3%E7%A0%81%E5%99%A8%EF%BC%8C%E6%95%B0%E6%8D%AE%E7%BC%93%E5%AD%98%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.1.</span> <span class="toc-text">Prepare–加载解码器，数据缓存的初始化</span></a></li></ol></li></ol>
 
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="Hide Sidebar"></a></div>
<aside class="clearfix">
<div id="authorInfo">
	
		<div class="author-img"></div>		
	
	<div class="social-info" class="clearfix">
		
		
		<a href="https://github.com/tbfungeek" target="_blank" class="icon-github" title="github"></a>
		
		
		
		
		
		
		
		
		
		
		<a href="mailto:tbfungeek@163.com" target="_blank" class="icon-email" title="Email Me"></a>
		

	</div>
</div>

  
<div class="categorieslist">
	<p class="asidetitle">Categories</p>
		<ul>
		
		  
			<li><a href="/categories/Android-小经验/" title="Android 小经验">Android 小经验<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Android-源码分析/" title="Android 源码分析">Android 源码分析<sup>21</sup></a></li>
		  
		
		  
			<li><a href="/categories/Android其他/" title="Android其他">Android其他<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Android初步/" title="Android初步">Android初步<sup>21</sup></a></li>
		  
		
		  
			<li><a href="/categories/Android进阶/" title="Android进阶">Android进阶<sup>100</sup></a></li>
		  
		
		  
			<li><a href="/categories/Hexo-使用/" title="Hexo 使用">Hexo 使用<sup>10</sup></a></li>
		  
		
		  
			<li><a href="/categories/JavaScript理论/" title="JavaScript理论">JavaScript理论<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Objective-C-相关/" title="Objective C 相关">Objective C 相关<sup>24</sup></a></li>
		  
		
		  
			<li><a href="/categories/OpenCV/" title="OpenCV">OpenCV<sup>6</sup></a></li>
		  
		
		  
			<li><a href="/categories/ROS/" title="ROS">ROS<sup>9</sup></a></li>
		  
		
		  
			<li><a href="/categories/iOS-工具使用/" title="iOS 工具使用">iOS 工具使用<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/iOS-开源库分析/" title="iOS 开源库分析">iOS 开源库分析<sup>36</sup></a></li>
		  
		
		  
			<li><a href="/categories/iOS-理论基础/" title="iOS 理论基础">iOS 理论基础<sup>14</sup></a></li>
		  
		
		  
			<li><a href="/categories/iOS-进阶/" title="iOS 进阶">iOS 进阶<sup>4</sup></a></li>
		  
		
		  
			<li><a href="/categories/个人收藏/" title="个人收藏">个人收藏<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/代码规范/" title="代码规范">代码规范<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/其他/" title="其他">其他<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/博客分类目录/" title="博客分类目录">博客分类目录<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/叨叨系列/" title="叨叨系列">叨叨系列<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/开源代码分析/" title="开源代码分析">开源代码分析<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/开源库分析/" title="开源库分析">开源库分析<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/树莓派/" title="树莓派">树莓派<sup>4</sup></a></li>
		  
		
		  
			<li><a href="/categories/版本控制/" title="版本控制">版本控制<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/直播/" title="直播">直播<sup>6</sup></a></li>
		  
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">Tags</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/iOS-开源库分析/" title="iOS 开源库分析">iOS 开源库分析<sup>36</sup></a></li>
			
		
			
				<li><a href="/tags/Android-设计模式/" title="Android 设计模式">Android 设计模式<sup>29</sup></a></li>
			
		
			
				<li><a href="/tags/Objective-C-相关/" title="Objective C 相关">Objective C 相关<sup>24</sup></a></li>
			
		
			
				<li><a href="/tags/Android基础/" title="Android基础">Android基础<sup>21</sup></a></li>
			
		
			
				<li><a href="/tags/AOSP-源码/" title="AOSP 源码">AOSP 源码<sup>17</sup></a></li>
			
		
			
				<li><a href="/tags/Android-常用第三方库/" title="Android 常用第三方库">Android 常用第三方库<sup>15</sup></a></li>
			
		
			
				<li><a href="/tags/iOS-理论基础/" title="iOS 理论基础">iOS 理论基础<sup>14</sup></a></li>
			
		
			
				<li><a href="/tags/Hexo-使用/" title="Hexo 使用">Hexo 使用<sup>10</sup></a></li>
			
		
			
				<li><a href="/tags/ROS/" title="ROS">ROS<sup>9</sup></a></li>
			
		
			
				<li><a href="/tags/Android-动画进阶/" title="Android 动画进阶">Android 动画进阶<sup>8</sup></a></li>
			
		
			
				<li><a href="/tags/Android-JNI/" title="Android JNI">Android JNI<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/Android-绘图进阶/" title="Android 绘图进阶">Android 绘图进阶<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/Android性能优化/" title="Android性能优化">Android性能优化<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/Android-自动化测试/" title="Android 自动化测试">Android 自动化测试<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/OpenCV/" title="OpenCV">OpenCV<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/直播/" title="直播">直播<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/Android-开源源码/" title="Android 开源源码">Android 开源源码<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/Android-自定义View进阶/" title="Android 自定义View进阶">Android 自定义View进阶<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/树莓派/" title="树莓派">树莓派<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/iOS-进阶/" title="iOS 进阶">iOS 进阶<sup>4</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">Links</p>
    <ul>
        
          <li>
            
            	<a href="https://hexo.io" target="_blank" title="Hexo">Hexo</a>
            
          </li>
        
          <li>
            
            	<a href="https://pages.github.com/" target="_blank" title="GitHub">GitHub</a>
            
          </li>
        
          <li>
            
            	<a href="http://pf18.github.io/" target="_blank" title="PF18">PF18</a>
            
          </li>
        
          <li>
            
            	<a href="http://toutiao.io/" target="_blank" title="开发者头条">开发者头条</a>
            
          </li>
        
          <li>
            
            	<a href="http://www.jcodecraeer.com/" target="_blank" title="泡在网上的日子">泡在网上的日子</a>
            
          </li>
        
    </ul>
</div>

  


  <div class="rsspart">
	<a href="atom.xml" target="_blank" title="rss">RSS</a>
</div>

  
  <div class="tagcloudlist">
    <p class="asidetitle">Tag Cloud</p>
    <div class="tagcloudlist clearfix">
       <a href="/tags/AOSP-%E6%BA%90%E7%A0%81/" style="font-size: 17.14px;">AOSP 源码</a> <a href="/tags/Android-APK-%E7%AD%BE%E5%90%8D/" style="font-size: 10px;">Android APK 签名</a> <a href="/tags/Android-JNI/" style="font-size: 12.86px;">Android JNI</a> <a href="/tags/Android-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E8%BF%9B%E9%98%B6/" style="font-size: 10.71px;">Android 事件处理进阶</a> <a href="/tags/Android-%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6/" style="font-size: 13.57px;">Android 动画进阶</a> <a href="/tags/Android-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%80%E5%8F%91/" style="font-size: 10px;">Android 多线程开发</a> <a href="/tags/Android-%E5%B0%8F%E7%BB%8F%E9%AA%8C/" style="font-size: 10px;">Android 小经验</a> <a href="/tags/Android-%E5%B8%B8%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/" style="font-size: 16.43px;">Android 常用第三方库</a> <a href="/tags/Android-%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/" style="font-size: 10px;">Android 开发流程</a> <a href="/tags/Android-%E5%BC%80%E6%BA%90%E6%BA%90%E7%A0%81/" style="font-size: 12.14px;">Android 开源源码</a> <a href="/tags/Android-%E7%BB%98%E5%9B%BE%E8%BF%9B%E9%98%B6/" style="font-size: 12.86px;">Android 绘图进阶</a> <a href="/tags/Android-%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/" style="font-size: 12.86px;">Android 自动化测试</a> <a href="/tags/Android-%E8%87%AA%E5%AE%9A%E4%B9%89View%E8%BF%9B%E9%98%B6/" style="font-size: 12.14px;">Android 自定义View进阶</a> <a href="/tags/Android-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 19.29px;">Android 设计模式</a> <a href="/tags/Android%E5%85%B6%E4%BB%96/" style="font-size: 10px;">Android其他</a> <a href="/tags/Android%E5%9F%BA%E7%A1%80/" style="font-size: 17.86px;">Android基础</a> <a href="/tags/Android%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/" style="font-size: 10px;">Android开发流程</a> <a href="/tags/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" style="font-size: 12.86px;">Android性能优化</a> <a href="/tags/Android%E6%B7%B7%E6%B7%86%E6%8A%80%E6%9C%AF/" style="font-size: 10px;">Android混淆技术</a> <a href="/tags/Android%E8%B4%A8%E9%87%8F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/" style="font-size: 11.43px;">Android质量管理工具</a> <a href="/tags/Android%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/" style="font-size: 10px;">Android逆向工程</a> <a href="/tags/Git-github/" style="font-size: 10px;">Git && github</a> <a href="/tags/Hexo-%E4%BD%BF%E7%94%A8/" style="font-size: 15px;">Hexo 使用</a> <a href="/tags/JavaScript/" style="font-size: 10px;">JavaScript</a> <a href="/tags/Linux-%E4%BD%BF%E7%94%A8/" style="font-size: 10px;">Linux 使用</a> <a href="/tags/Objective-C-%E7%9B%B8%E5%85%B3/" style="font-size: 18.57px;">Objective C 相关</a> <a href="/tags/OpenCV/" style="font-size: 12.86px;">OpenCV</a> <a href="/tags/ROS/" style="font-size: 14.29px;">ROS</a> <a href="/tags/iOS-%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/" style="font-size: 10.71px;">iOS 工具使用</a> <a href="/tags/iOS-%E5%BC%80%E6%BA%90%E5%BA%93%E5%88%86%E6%9E%90/" style="font-size: 20px;">iOS 开源库分析</a> <a href="/tags/iOS-%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/" style="font-size: 15.71px;">iOS 理论基础</a> <a href="/tags/iOS-%E8%BF%9B%E9%98%B6/" style="font-size: 12.14px;">iOS 进阶</a> <a href="/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/" style="font-size: 10px;">代码规范</a> <a href="/tags/%E5%8D%9A%E5%AE%A2%E5%88%86%E7%B1%BB%E7%9B%AE%E5%BD%95/" style="font-size: 10.71px;">博客分类目录</a> <a href="/tags/%E5%8F%A8%E5%8F%A8%E7%B3%BB%E5%88%97/" style="font-size: 10px;">叨叨系列</a> <a href="/tags/%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/" style="font-size: 11.43px;">工具的使用</a> <a href="/tags/%E5%BC%80%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/" style="font-size: 10.71px;">开源代码分析</a> <a href="/tags/%E5%BC%80%E6%BA%90%E5%BA%93%E5%88%86%E6%9E%90/" style="font-size: 10px;">开源库分析</a> <a href="/tags/%E6%9D%82%E7%B1%BB/" style="font-size: 10px;">杂类</a> <a href="/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/" style="font-size: 12.14px;">树莓派</a> <a href="/tags/%E7%9B%B4%E6%92%AD/" style="font-size: 12.86px;">直播</a> <a href="/tags/%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/" style="font-size: 10.71px;">编程技巧</a> <a href="/tags/%E7%BD%91%E7%AB%99%E6%94%B6%E8%97%8F/" style="font-size: 10px;">网站收藏</a> <a href="/tags/%E9%87%8D%E8%A6%81%E6%8E%A7%E4%BB%B6/" style="font-size: 11.43px;">重要控件</a>
    </div>
  </div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
		
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/hsihohuang/kiddochan" target="_blank" title="Kiddochan">Kiddochan</a> © 2022 
		
		<a href="/about" target="_blank" title="Edgar">Edgar</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
        getSize();
        if (myWidth >= 1024) {
          c.click();
        }
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  c.click(function(){
    ta.css('display', 'block').addClass('fadeIn');
  });
  o.click(function(){
    ta.css('display', 'none');
  });
  $(window).scroll(function(){
    ta.css("top",Math.max(140,320-$(this).scrollTop()));
  });
});
</script>




<script type="text/javascript">
  var duoshuoQuery = {short_name:"tbfungeek"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script> 


<script type="text/javascript">

var disqus_shortname = 'tbfungeek';

(function(){
  var dsq = document.createElement('script');
  dsq.type = 'text/javascript';
  dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
}());
(function(){
  var dsq = document.createElement('script');
  dsq.type = 'text/javascript';
  dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/count.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
}());
</script>






<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?7c9443b0374f1cf6b1dbb5ab84d939cb";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="Back to Top"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
</html>
