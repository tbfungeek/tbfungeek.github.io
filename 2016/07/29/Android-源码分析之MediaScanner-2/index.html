
 <!DOCTYPE HTML>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
  
    <title>Android 源码分析之MediaScanner[2] | Edgar&#39;s Blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="Edgar">
    

    
    <meta name="description" content="音频视频文件帧信息的获取上面分析的是非音频视频图像文件的扫描流程，在接下来的章节将介绍多媒体文件信息的获取，接下来的部分以MP3格式的音频文件作为分析对象进行介绍：对于MP3格式大家可以在网上找下，这里就不展开介绍了。 音频视频文件的TAG解析流程分析在doScanFile中会执行对应的判断，如果当前扫描文件为音频或者视频文件则调用processFile方法进行处理。 public Uri doS">
<meta property="og:type" content="article">
<meta property="og:title" content="Android 源码分析之MediaScanner[2]">
<meta property="og:url" content="http://yoursite.com/2016/07/29/Android-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BMediaScanner-2/index.html">
<meta property="og:site_name" content="Edgar&#39;s Blog">
<meta property="og:description" content="音频视频文件帧信息的获取上面分析的是非音频视频图像文件的扫描流程，在接下来的章节将介绍多媒体文件信息的获取，接下来的部分以MP3格式的音频文件作为分析对象进行介绍：对于MP3格式大家可以在网上找下，这里就不展开介绍了。 音频视频文件的TAG解析流程分析在doScanFile中会执行对应的判断，如果当前扫描文件为音频或者视频文件则调用processFile方法进行处理。 public Uri doS">
<meta property="og:locale">
<meta property="article:published_time" content="2016-07-29T02:40:48.000Z">
<meta property="article:modified_time" content="2016-08-05T23:38:00.000Z">
<meta property="article:author" content="Edgar">
<meta property="article:tag" content="AOSP 源码">
<meta name="twitter:card" content="summary">

    
    <link rel="alternative" href="atom.xml" title="Edgar&#39;s Blog" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/unnamed4_n_mSY_icon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/profile.png">
    <link rel="apple-touch-icon-precomposed" href="/img/profile.png">
    
    
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 6.2.0"></head>

  <body>
    <header>
      
<div>
		
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="Edgar&#39;s Blog">Edgar&#39;s Blog</a></h1>
				<h2 class="blog-motto"></h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="Menu">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
					<li>
 					
					<form class="search" action="/search/index.html" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" autocomplete="off" name="q" maxlength="20" placeholder="Search" />
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
  
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/07/29/Android-源码分析之MediaScanner-2/" title="Android 源码分析之MediaScanner[2]" itemprop="url">Android 源码分析之MediaScanner[2]</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Edgar" target="_blank" itemprop="author">Edgar</a>
		
  <p class="article-time">
    <time datetime="2016-07-29T02:40:48.000Z" itemprop="datePublished"> Published 2016-07-29</time>
    
  </p>
</header>
	<div class="article-content">
		
		<h4 id="音频视频文件帧信息的获取"><a href="#音频视频文件帧信息的获取" class="headerlink" title="音频视频文件帧信息的获取"></a>音频视频文件帧信息的获取</h4><p>上面分析的是非音频视频图像文件的扫描流程，在接下来的章节将介绍多媒体文件信息的获取，接下来的部分以MP3格式的音频文件作为分析对象进行介绍：<br>对于MP3格式大家可以在网上找下，这里就不展开介绍了。</p>
<h5 id="音频视频文件的TAG解析流程分析"><a href="#音频视频文件的TAG解析流程分析" class="headerlink" title="音频视频文件的TAG解析流程分析"></a>音频视频文件的TAG解析流程分析</h5><p>在doScanFile中会执行对应的判断，如果当前扫描文件为音频或者视频文件则调用processFile方法进行处理。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Uri <span class="title">doScanFile</span><span class="params">(<span class="type">String</span> path, <span class="type">String</span> mimeType, <span class="type">long</span> lastModified,<span class="type">long</span> fileSize, <span class="type">boolean</span> isDirectory, <span class="type">boolean</span> scanAlways, <span class="type">boolean</span> noMedia)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        FileEntry entry = <span class="built_in">beginFile</span>(path, mimeType, lastModified,</span><br><span class="line">                fileSize, isDirectory, noMedia);</span><br><span class="line">        <span class="comment">//......</span></span><br><span class="line">        <span class="keyword">if</span> (entry != null &amp;&amp; (entry.mLastModifiedChanged || scanAlways)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (noMedia) &#123;</span><br><span class="line">                <span class="comment">//.........</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//........</span></span><br><span class="line">                <span class="comment">// 如果是音频文件或者视频文件调用processFile抽取元数据</span></span><br><span class="line">                <span class="comment">// we only extract metadata for audio and video files</span></span><br><span class="line">                <span class="keyword">if</span> (isaudio || isvideo) &#123;</span><br><span class="line">                    <span class="built_in">processFile</span>(path, mimeType, <span class="keyword">this</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//.........</span></span><br><span class="line">                result = <span class="built_in">endFile</span>(entry, ringtones, notifications, alarms, music, podcasts);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (RemoteException e) &#123;</span><br><span class="line">        <span class="comment">//...................</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在doScanFile调用的processFile是native方法，<br>因此首先调用android_media_Mediascanner.cpp.中的android_media_MediaScanner_processFile方法，在该方法中就直接调用StageFrightMediaScanner的processFile方法。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">android_media_MediaScanner_processFile</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        JNIEnv *env, jobject thiz, jstring path,</span></span></span><br><span class="line"><span class="params"><span class="function">        jstring mimeType, jobject client)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MediaScanner *mp = <span class="built_in">getNativeScanner_l</span>(env, thiz);</span><br><span class="line">    <span class="comment">//........</span></span><br><span class="line">    <span class="comment">//获取MimeType</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *mimeTypeStr = (mimeType ? env-&gt;<span class="built_in">GetStringUTFChars</span>(mimeType, <span class="literal">NULL</span>) : <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//...........</span></span><br><span class="line">    <span class="function">MyMediaScannerClient <span class="title">myClient</span><span class="params">(env, client)</span></span>;</span><br><span class="line">    <span class="comment">//调用StageFrightMediaScanner的processFile方法</span></span><br><span class="line">    MediaScanResult result = mp-&gt;<span class="built_in">processFile</span>(pathStr, mimeTypeStr, myClient);</span><br><span class="line">    <span class="comment">//..........</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们先来看下getNativeScanner_l：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">static MediaScanner *get<span class="constructor">NativeScanner_l(JNIEnv<span class="operator">*</span> <span class="params">env</span>, <span class="params">jobject</span> <span class="params">thiz</span>)</span> &#123;</span><br><span class="line">    return (MediaScanner *) env-&gt;<span class="constructor">GetLongField(<span class="params">thiz</span>, <span class="params">fields</span>.<span class="params">context</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它是将fields.context转换为MediaScanner，fields.context这个是怎么来的还记得吧：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">static void</span><br><span class="line">android<span class="constructor">_media_MediaScanner_native_setup(JNIEnv <span class="operator">*</span><span class="params">env</span>, <span class="params">jobject</span> <span class="params">thiz</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="constructor">ALOGV(<span class="string">&quot;native_setup&quot;</span>)</span>;</span><br><span class="line">    MediaScanner *mp = <span class="keyword">new</span> StagefrightMediaScanner;</span><br><span class="line">    <span class="comment">//..............</span></span><br><span class="line">    env-&gt;<span class="constructor">SetLongField(<span class="params">thiz</span>, <span class="params">fields</span>.<span class="params">context</span>, (<span class="params">jlong</span>)</span>mp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以这里的getNativeScanner_l返回的是StagefrightMediaScanner<br>而在StagefrightMediaScanner的processFile方法中则直接调用MediaScannerClient类中的beginFile以及endFile方法还有StagefrightMediaScanner 的processFileInternal方法。</p>
<figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line">MediaScanResult StagefrightMediaScanner::processFile(</span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">char</span> *path, <span class="keyword">const</span> <span class="built_in">char</span> *mimeType,</span><br><span class="line">        MediaScannerClient &amp;<span class="keyword">client</span>) &#123;</span><br><span class="line">    ALOGV(<span class="string">&quot;processFile &#x27;%s&#x27;.&quot;</span>, path);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">client</span>.setLocale(locale());</span><br><span class="line">    <span class="comment">//client = MyMediaScannerClient</span></span><br><span class="line">    <span class="keyword">client</span>.beginFile();</span><br><span class="line">    MediaScanResult result = processFileInternal(path, mimeType, <span class="keyword">client</span>);</span><br><span class="line">    <span class="keyword">client</span>.endFile();</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们先来看下MyMediaScannerClient::beginFile</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> FileEntry <span class="title function_">beginFile</span><span class="params">(String path, String mimeType, <span class="type">long</span> lastModified,</span></span><br><span class="line"><span class="params">        <span class="type">long</span> fileSize, <span class="type">boolean</span> isDirectory, <span class="type">boolean</span> noMedia)</span> &#123;</span><br><span class="line">    mMimeType = mimeType;</span><br><span class="line">    mFileType = <span class="number">0</span>;</span><br><span class="line">    mFileSize = fileSize;</span><br><span class="line">    mIsDrm = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isDirectory) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!noMedia &amp;&amp; isNoMediaFile(path)) &#123;</span><br><span class="line">            noMedia = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mNoMedia = noMedia;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// try mimeType first, if it is specified</span></span><br><span class="line">        <span class="keyword">if</span> (mimeType != <span class="literal">null</span>) &#123;</span><br><span class="line">            mFileType = MediaFile.getFileTypeForMimeType(mimeType);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// if mimeType was not specified, compute file type based on file extension.</span></span><br><span class="line">        <span class="keyword">if</span> (mFileType == <span class="number">0</span>) &#123;</span><br><span class="line">            MediaFile.<span class="type">MediaFileType</span> <span class="variable">mediaFileType</span> <span class="operator">=</span> MediaFile.getFileType(path);</span><br><span class="line">            <span class="keyword">if</span> (mediaFileType != <span class="literal">null</span>) &#123;</span><br><span class="line">                mFileType = mediaFileType.fileType;</span><br><span class="line">                <span class="keyword">if</span> (mMimeType == <span class="literal">null</span>) &#123;</span><br><span class="line">                    mMimeType = mediaFileType.mimeType;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isDrmEnabled() &amp;&amp; MediaFile.isDrmFileType(mFileType)) &#123;</span><br><span class="line">            mFileType = getFileTypeFromDrm(path);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">FileEntry</span> <span class="variable">entry</span> <span class="operator">=</span> makeEntryFor(path);</span><br><span class="line">    <span class="comment">// add some slack to avoid a rounding error</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">delta</span> <span class="operator">=</span> (entry != <span class="literal">null</span>) ? (lastModified - entry.mLastModified) : <span class="number">0</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">wasModified</span> <span class="operator">=</span> delta &gt; <span class="number">1</span> || delta &lt; -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (entry == <span class="literal">null</span> || wasModified) &#123;</span><br><span class="line">        <span class="keyword">if</span> (wasModified) &#123;</span><br><span class="line">            entry.mLastModified = lastModified;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            entry = <span class="keyword">new</span> <span class="title class_">FileEntry</span>(<span class="number">0</span>, path, lastModified,</span><br><span class="line">                    (isDirectory ? MtpConstants.FORMAT_ASSOCIATION : <span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        entry.mLastModifiedChanged = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mProcessPlaylists &amp;&amp; MediaFile.isPlayListFileType(mFileType)) &#123;</span><br><span class="line">        mPlayLists.add(entry);</span><br><span class="line">        <span class="comment">// we don&#x27;t process playlists in the main scan, so return null</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// clear all the metadata</span></span><br><span class="line">    mArtist = <span class="literal">null</span>;</span><br><span class="line">    mAlbumArtist = <span class="literal">null</span>;</span><br><span class="line">    mAlbum = <span class="literal">null</span>;</span><br><span class="line">    mTitle = <span class="literal">null</span>;</span><br><span class="line">    mComposer = <span class="literal">null</span>;</span><br><span class="line">    mGenre = <span class="literal">null</span>;</span><br><span class="line">    mTrack = <span class="number">0</span>;</span><br><span class="line">    mYear = <span class="number">0</span>;</span><br><span class="line">    mDuration = <span class="number">0</span>;</span><br><span class="line">    mPath = path;</span><br><span class="line">    mLastModified = lastModified;</span><br><span class="line">    mWriter = <span class="literal">null</span>;</span><br><span class="line">    mCompilation = <span class="number">0</span>;</span><br><span class="line">    mWidth = <span class="number">0</span>;</span><br><span class="line">    mHeight = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> entry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从processFileInternal方法开始就开始获取音频视频内部的数据了，在processFileInternal中对文件的处理分如下几个部分：</p>
<ul>
<li>获取当前音频视频文件的扩展名，看是否是平台所支持的文件类型，如果为空或者不支持就返回MEDIA_SCAN_RESULT_SKIPPED。</li>
<li>根据文件扩展名判断当前扫描的文件是否是DRM文件，如果是的话则开始获取DRM的信息。DRM信息是通过调用drmManagerClient-&gt;getMetadata(&amp;tmp)方法来获取的，获取到的信息封装在DrmMetadata对象中。这部分将放在今后的DRM部分介绍。</li>
<li>获取音频视频的TAG信息：<br>这部分最重要的是如下两个方法：<br>StagefrightMetadataRetriever ::setDataSource<br>StagefrightMetadataRetriever ::extractMetadata</li>
</ul>
<p>这部分代码是比较重要的所以我们将对下面的方法进行详细介绍：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">MediaScanResult <span class="title">StagefrightMediaScanner::processFileInternal</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> * <span class="comment">/* mimeType */</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        MediaScannerClient &amp;client)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断当前文件是否有扩展名</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *extension = <span class="built_in">strrchr</span>(path, <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!extension) &#123;</span><br><span class="line">        <span class="keyword">return</span> MEDIA_SCAN_RESULT_SKIPPED;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断当前扩展名十分支持</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">FileHasAcceptableExtension</span>(extension)) &#123;</span><br><span class="line">        <span class="keyword">return</span> MEDIA_SCAN_RESULT_SKIPPED;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建媒体抽取器</span></span><br><span class="line">    <span class="function">sp&lt;MediaMetadataRetriever&gt; <span class="title">mRetriever</span><span class="params">(<span class="keyword">new</span> MediaMetadataRetriever)</span></span>;</span><br><span class="line">    <span class="comment">//打开文件</span></span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">open</span>(path, O_RDONLY | O_LARGEFILE);</span><br><span class="line">    <span class="type">status_t</span> status;</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// couldn&#x27;t open it locally, maybe the media server can?</span></span><br><span class="line">        <span class="comment">//打不开尝试从网络上获取</span></span><br><span class="line">        status = mRetriever-&gt;<span class="built_in">setDataSource</span>(<span class="literal">NULL</span> <span class="comment">/* httpService */</span>, path);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//设置数据源</span></span><br><span class="line">        status = mRetriever-&gt;<span class="built_in">setDataSource</span>(fd, <span class="number">0</span>, <span class="number">0x7ffffffffffffff</span>L);</span><br><span class="line">        <span class="built_in">close</span>(fd);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//抽取媒体头数据</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *value;</span><br><span class="line">    <span class="keyword">if</span> ((value = mRetriever-&gt;<span class="built_in">extractMetadata</span>(METADATA_KEY_MIMETYPE)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        status = client.<span class="built_in">setMimeType</span>(value);</span><br><span class="line">        <span class="keyword">if</span> (status) &#123;</span><br><span class="line">            <span class="keyword">return</span> MEDIA_SCAN_RESULT_ERROR;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">KeyMap</span> &#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *tag;</span><br><span class="line">        <span class="type">int</span> key;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> KeyMap kKeyMap[] = &#123;</span><br><span class="line">        &#123; <span class="string">&quot;tracknumber&quot;</span>, METADATA_KEY_CD_TRACK_NUMBER &#125;,</span><br><span class="line">        &#123; <span class="string">&quot;discnumber&quot;</span>, METADATA_KEY_DISC_NUMBER &#125;,</span><br><span class="line">        &#123; <span class="string">&quot;album&quot;</span>, METADATA_KEY_ALBUM &#125;,</span><br><span class="line">        &#123; <span class="string">&quot;artist&quot;</span>, METADATA_KEY_ARTIST &#125;,</span><br><span class="line">        &#123; <span class="string">&quot;albumartist&quot;</span>, METADATA_KEY_ALBUMARTIST &#125;,</span><br><span class="line">        &#123; <span class="string">&quot;composer&quot;</span>, METADATA_KEY_COMPOSER &#125;,</span><br><span class="line">        &#123; <span class="string">&quot;genre&quot;</span>, METADATA_KEY_GENRE &#125;,</span><br><span class="line">        &#123; <span class="string">&quot;title&quot;</span>, METADATA_KEY_TITLE &#125;,</span><br><span class="line">        &#123; <span class="string">&quot;year&quot;</span>, METADATA_KEY_YEAR &#125;,</span><br><span class="line">        &#123; <span class="string">&quot;duration&quot;</span>, METADATA_KEY_DURATION &#125;,</span><br><span class="line">        &#123; <span class="string">&quot;writer&quot;</span>, METADATA_KEY_WRITER &#125;,</span><br><span class="line">        &#123; <span class="string">&quot;compilation&quot;</span>, METADATA_KEY_COMPILATION &#125;,</span><br><span class="line">        &#123; <span class="string">&quot;isdrm&quot;</span>, METADATA_KEY_IS_DRM &#125;,</span><br><span class="line">        &#123; <span class="string">&quot;width&quot;</span>, METADATA_KEY_VIDEO_WIDTH &#125;,</span><br><span class="line">        &#123; <span class="string">&quot;height&quot;</span>, METADATA_KEY_VIDEO_HEIGHT &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">size_t</span> kNumEntries = <span class="built_in">sizeof</span>(kKeyMap) / <span class="built_in">sizeof</span>(kKeyMap[<span class="number">0</span>]);</span><br><span class="line">    <span class="comment">//按照kKeyMap表格的顺序从媒体文件中获取TAG并添加到client中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; kNumEntries; ++i) &#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *value;</span><br><span class="line">        <span class="keyword">if</span> ((value = mRetriever-&gt;<span class="built_in">extractMetadata</span>(kKeyMap[i].key)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            status = client.<span class="built_in">addStringTag</span>(kKeyMap[i].tag, value);</span><br><span class="line">            <span class="keyword">if</span> (status != OK) &#123;</span><br><span class="line">                <span class="keyword">return</span> MEDIA_SCAN_RESULT_ERROR;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> MEDIA_SCAN_RESULT_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们先来看下能够支持的媒体格式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">FileHasAcceptableExtension</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *extension)</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">char</span> *kValidExtensions[] = &#123;</span><br><span class="line">        <span class="string">&quot;.mp3&quot;</span>, <span class="string">&quot;.mp4&quot;</span>, <span class="string">&quot;.m4a&quot;</span>, <span class="string">&quot;.3gp&quot;</span>, <span class="string">&quot;.3gpp&quot;</span>, <span class="string">&quot;.3g2&quot;</span>, <span class="string">&quot;.3gpp2&quot;</span>,</span><br><span class="line">        <span class="string">&quot;.mpeg&quot;</span>, <span class="string">&quot;.ogg&quot;</span>, <span class="string">&quot;.mid&quot;</span>, <span class="string">&quot;.smf&quot;</span>, <span class="string">&quot;.imy&quot;</span>, <span class="string">&quot;.wma&quot;</span>, <span class="string">&quot;.aac&quot;</span>,</span><br><span class="line">        <span class="string">&quot;.wav&quot;</span>, <span class="string">&quot;.amr&quot;</span>, <span class="string">&quot;.midi&quot;</span>, <span class="string">&quot;.xmf&quot;</span>, <span class="string">&quot;.rtttl&quot;</span>, <span class="string">&quot;.rtx&quot;</span>, <span class="string">&quot;.ota&quot;</span>,</span><br><span class="line">        <span class="string">&quot;.mkv&quot;</span>, <span class="string">&quot;.mka&quot;</span>, <span class="string">&quot;.webm&quot;</span>, <span class="string">&quot;.ts&quot;</span>, <span class="string">&quot;.fl&quot;</span>, <span class="string">&quot;.flac&quot;</span>, <span class="string">&quot;.mxmf&quot;</span>,</span><br><span class="line">        <span class="string">&quot;.avi&quot;</span>, <span class="string">&quot;.mpeg&quot;</span>, <span class="string">&quot;.mpg&quot;</span>, <span class="string">&quot;.awb&quot;</span>, <span class="string">&quot;.mpga&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">size_t</span> kNumValidExtensions =</span><br><span class="line">        <span class="built_in">sizeof</span>(kValidExtensions) / <span class="built_in">sizeof</span>(kValidExtensions[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; kNumValidExtensions; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcasecmp</span>(extension, kValidExtensions[i])) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看下setDataSource，它首先会创建一个FileSource。</p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="function"><span class="keyword">void</span> <span class="title">setDataSource</span><span class="params">(FileDescriptor fd, <span class="keyword">long</span> offset, <span class="keyword">long</span> length)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IllegalArgumentException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在setDataSource中我们创建一个FileSource并将其传递到MediaExtractor::Create中根据FileSource来创建出合适的MediaExtractor</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">status_t StagefrightMetadataRetriever::set<span class="constructor">DataSource(<span class="params">int</span> <span class="params">fd</span>, <span class="params">int64_t</span> <span class="params">offset</span>, <span class="params">int64_t</span> <span class="params">length</span>)</span> &#123;</span><br><span class="line">    fd = dup(fd);</span><br><span class="line">    <span class="constructor">ALOGV(<span class="string">&quot;setDataSource(%d, %&quot;</span> PRId64 <span class="string">&quot;, %&quot;</span> PRId64 <span class="string">&quot;)&quot;</span>, <span class="params">fd</span>, <span class="params">offset</span>, <span class="params">length</span>)</span>;</span><br><span class="line">    clear<span class="constructor">Metadata()</span>;</span><br><span class="line">    mSource = <span class="keyword">new</span> <span class="constructor">FileSource(<span class="params">fd</span>, <span class="params">offset</span>, <span class="params">length</span>)</span>;</span><br><span class="line">    status_t err;</span><br><span class="line">    <span class="comment">//检查是否打开文件成功</span></span><br><span class="line">    <span class="keyword">if</span> ((err = mSource-&gt;init<span class="constructor">Check()</span>) != OK) &#123;</span><br><span class="line">        mSource.clear<span class="literal">()</span>;</span><br><span class="line">        return err;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将FileSource传入后根据FileSource的信息创建出合适的MediaExtractor</span></span><br><span class="line">    mExtractor = MediaExtractor::<span class="constructor">Create(<span class="params">mSource</span>)</span>;</span><br><span class="line">    <span class="keyword">if</span> (mExtractor<span class="operator"> == </span>NULL) &#123;</span><br><span class="line">        mSource.clear<span class="literal">()</span>;</span><br><span class="line">        return UNKNOWN_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们接下来看下是如何创建对应的MediaExtractor的，首先会先调用DataSource的sniff，在DataSource的sniff中会调用每个注册的Sniffers对其进行探测，来选出最匹配的。以mimetype形式返回。根据返回的mimetype创建MediaExtractor</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// static</span></span><br><span class="line">sp&lt;MediaExtractor&gt; <span class="title class_">MediaExtractor</span>::<span class="title function_ invoke__">Create</span>(<span class="keyword">const</span> sp&lt;DataSource&gt; &amp;source, <span class="keyword">const</span> char *mime) &#123;</span><br><span class="line">    sp&lt;AMessage&gt; meta;</span><br><span class="line">    String8 tmp;</span><br><span class="line">    <span class="keyword">if</span> (mime == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> confidence;</span><br><span class="line">        <span class="comment">//首先我们会调用DataSource的sniff</span></span><br><span class="line">        <span class="keyword">if</span> (!source-&gt;<span class="title function_ invoke__">sniff</span>(&amp;tmp, &amp;confidence, &amp;meta)) &#123;</span><br><span class="line">            <span class="title function_ invoke__">ALOGV</span>(<span class="string">&quot;FAILED to autodetect media content.&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mime = tmp.<span class="keyword">string</span>();</span><br><span class="line">        <span class="title function_ invoke__">ALOGV</span>(<span class="string">&quot;Autodetected media content as &#x27;%s&#x27; with confidence %.2f&quot;</span>,</span><br><span class="line">             mime, confidence);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> isDrm = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// DRM MIME type syntax is &quot;drm+type+original&quot; where</span></span><br><span class="line">    <span class="comment">// type is &quot;es_based&quot; or &quot;container_based&quot; and</span></span><br><span class="line">    <span class="comment">// original is the content&#x27;s cleartext MIME type</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="title function_ invoke__">strncmp</span>(mime, <span class="string">&quot;drm+&quot;</span>, <span class="number">4</span>)) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="variable constant_">char</span> *originalMime = <span class="title function_ invoke__">strchr</span>(mime+<span class="number">4</span>, <span class="string">&#x27;+&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (originalMime == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// second + not found</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ++originalMime;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="title function_ invoke__">strncmp</span>(mime, <span class="string">&quot;drm+es_based+&quot;</span>, <span class="number">13</span>)) &#123;</span><br><span class="line">            <span class="comment">// DRMExtractor sets container metadata kKeyIsDRM to 1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DRMExtractor</span>(source, originalMime);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="title function_ invoke__">strncmp</span>(mime, <span class="string">&quot;drm+container_based+&quot;</span>, <span class="number">20</span>)) &#123;</span><br><span class="line">            mime = originalMime;</span><br><span class="line">            isDrm = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MediaExtractor *ret = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="title function_ invoke__">strcasecmp</span>(mime, MEDIA_MIMETYPE_CONTAINER_MPEG4)</span><br><span class="line">            || !<span class="title function_ invoke__">strcasecmp</span>(mime, <span class="string">&quot;audio/mp4&quot;</span>)) &#123;</span><br><span class="line">        ret = <span class="keyword">new</span> <span class="title class_">MPEG4Extractor</span>(source);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="title function_ invoke__">strcasecmp</span>(mime, MEDIA_MIMETYPE_AUDIO_MPEG)) &#123;</span><br><span class="line">        ret = <span class="keyword">new</span> <span class="title class_">MP3Extractor</span>(source, meta);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="title function_ invoke__">strcasecmp</span>(mime, MEDIA_MIMETYPE_AUDIO_AMR_NB)</span><br><span class="line">            || !<span class="title function_ invoke__">strcasecmp</span>(mime, MEDIA_MIMETYPE_AUDIO_AMR_WB)) &#123;</span><br><span class="line">        ret = <span class="keyword">new</span> <span class="title class_">AMRExtractor</span>(source);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="title function_ invoke__">strcasecmp</span>(mime, MEDIA_MIMETYPE_AUDIO_FLAC)) &#123;</span><br><span class="line">        ret = <span class="keyword">new</span> <span class="title class_">FLACExtractor</span>(source);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="title function_ invoke__">strcasecmp</span>(mime, MEDIA_MIMETYPE_CONTAINER_WAV)) &#123;</span><br><span class="line">        ret = <span class="keyword">new</span> <span class="title class_">WAVExtractor</span>(source);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="title function_ invoke__">strcasecmp</span>(mime, MEDIA_MIMETYPE_CONTAINER_OGG)) &#123;</span><br><span class="line">        ret = <span class="keyword">new</span> <span class="title class_">OggExtractor</span>(source);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="title function_ invoke__">strcasecmp</span>(mime, MEDIA_MIMETYPE_CONTAINER_MATROSKA)) &#123;</span><br><span class="line">        ret = <span class="keyword">new</span> <span class="title class_">MatroskaExtractor</span>(source);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="title function_ invoke__">strcasecmp</span>(mime, MEDIA_MIMETYPE_CONTAINER_MPEG2TS)) &#123;</span><br><span class="line">        ret = <span class="keyword">new</span> <span class="title class_">MPEG2TSExtractor</span>(source);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="title function_ invoke__">strcasecmp</span>(mime, MEDIA_MIMETYPE_CONTAINER_WVM)) &#123;</span><br><span class="line">        <span class="comment">// Return now.  WVExtractor should not have the DrmFlag set in the block below.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WVMExtractor</span>(source);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="title function_ invoke__">strcasecmp</span>(mime, MEDIA_MIMETYPE_AUDIO_AAC_ADTS)) &#123;</span><br><span class="line">        ret = <span class="keyword">new</span> <span class="title class_">AACExtractor</span>(source, meta);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="title function_ invoke__">strcasecmp</span>(mime, MEDIA_MIMETYPE_CONTAINER_MPEG2PS)) &#123;</span><br><span class="line">        ret = <span class="keyword">new</span> <span class="title class_">MPEG2PSExtractor</span>(source);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="title function_ invoke__">strcasecmp</span>(mime, MEDIA_MIMETYPE_AUDIO_MIDI)) &#123;</span><br><span class="line">        ret = <span class="keyword">new</span> <span class="title class_">MidiExtractor</span>(source);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="literal">NULL</span>) &#123;</span><br><span class="line">       <span class="keyword">if</span> (isDrm) &#123;</span><br><span class="line">           ret-&gt;<span class="title function_ invoke__">setDrmFlag</span>(<span class="literal">true</span>);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           ret-&gt;<span class="title function_ invoke__">setDrmFlag</span>(<span class="literal">false</span>);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是sniff方法。</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">bool DataSource:<span class="type"></span>:sniff(String8 *mimeType, float *confidence, sp&lt;AMessage&gt; *meta) &#123;</span><br><span class="line">    *mimeType = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    *confidence = <span class="number">0.0</span>f;</span><br><span class="line">    meta-&gt;clear();</span><br><span class="line">    &#123;</span><br><span class="line">        Mutex:<span class="type"></span>:Autolock autoLock(gSnifferMutex);</span><br><span class="line">        <span class="keyword">if</span> (!gSniffersRegistered) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (List&lt;SnifferFunc&gt;:<span class="type"></span>:iterator it = gSniffers.begin();</span><br><span class="line">         it != gSniffers.end(); ++it) &#123;</span><br><span class="line">        String8 <span class="keyword">new</span><span class="type">MimeType</span>;</span><br><span class="line">        float <span class="keyword">new</span><span class="type">Confidence</span>;</span><br><span class="line">        sp&lt;AMessage&gt; <span class="keyword">new</span><span class="type">Meta</span>;</span><br><span class="line">        <span class="comment">//调用各种嗅探器的方法获取类型和可信度</span></span><br><span class="line">        <span class="keyword">if</span> ((*it)(<span class="built_in">this</span>, &amp;<span class="keyword">new</span><span class="type">MimeType</span>, &amp;<span class="keyword">new</span><span class="type">Confidence</span>, &amp;<span class="keyword">new</span><span class="type">Meta</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">new</span><span class="type">Confidence</span> &gt; *confidence) &#123;</span><br><span class="line">                *mimeType = <span class="keyword">new</span><span class="type">MimeType</span>;</span><br><span class="line">                *confidence = <span class="keyword">new</span><span class="type">Confidence</span>;</span><br><span class="line">                *meta = <span class="keyword">new</span><span class="type">Meta</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *confidence &gt; <span class="number">0.0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这些sniff是在StagefrightMetadataRetriever创建的时候注册的：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">StagefrightMetadataRetriever::<span class="constructor">StagefrightMetadataRetriever()</span></span><br><span class="line">    : m<span class="constructor">ParsedMetaData(<span class="params">false</span>)</span>,</span><br><span class="line">      m<span class="constructor">AlbumArt(NULL)</span> &#123;</span><br><span class="line">    <span class="comment">//注册默认的音频格式嗅探器</span></span><br><span class="line">    DataSource::<span class="constructor">RegisterDefaultSniffers()</span>;</span><br><span class="line">    <span class="constructor">CHECK_EQ(<span class="params">mClient</span>.<span class="params">connect</span>()</span>, (status_t)OK);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>下面是注册的sniff</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">//static</span></span><br><span class="line">void DataSource::<span class="constructor">RegisterDefaultSniffers()</span> &#123;</span><br><span class="line">    Mutex::Autolock auto<span class="constructor">Lock(<span class="params">gSnifferMutex</span>)</span>;</span><br><span class="line">    <span class="keyword">if</span> (gSniffersRegistered) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="constructor">RegisterSniffer_l(SniffMPEG4)</span>;</span><br><span class="line">    <span class="constructor">RegisterSniffer_l(SniffMatroska)</span>;</span><br><span class="line">    <span class="constructor">RegisterSniffer_l(SniffOgg)</span>;</span><br><span class="line">    <span class="constructor">RegisterSniffer_l(SniffWAV)</span>;</span><br><span class="line">    <span class="constructor">RegisterSniffer_l(SniffFLAC)</span>;</span><br><span class="line">    <span class="constructor">RegisterSniffer_l(SniffAMR)</span>;</span><br><span class="line">    <span class="constructor">RegisterSniffer_l(SniffMPEG2TS)</span>;</span><br><span class="line">    <span class="constructor">RegisterSniffer_l(SniffMP3)</span>;</span><br><span class="line">    <span class="constructor">RegisterSniffer_l(SniffAAC)</span>;</span><br><span class="line">    <span class="constructor">RegisterSniffer_l(SniffMPEG2PS)</span>;</span><br><span class="line">    <span class="constructor">RegisterSniffer_l(SniffWVM)</span>;</span><br><span class="line">    <span class="constructor">RegisterSniffer_l(SniffMidi)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">char</span> value<span class="literal">[PROPERTY<span class="identifier">_VALUE_MAX</span>]</span>;</span><br><span class="line">    <span class="keyword">if</span> (property<span class="constructor">_get(<span class="string">&quot;drm.service.enabled&quot;</span>, <span class="params">value</span>, NULL)</span><span class="operator"></span></span><br><span class="line"><span class="operator">            &amp;&amp; </span>(!strcmp(value, <span class="string">&quot;1&quot;</span>)<span class="operator"> || </span>!strcasecmp(value, <span class="string">&quot;true&quot;</span>))) &#123;</span><br><span class="line">        <span class="constructor">RegisterSniffer_l(SniffDRM)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    gSniffersRegistered = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么sniff又是怎样完成文件类型判断的任务的呢？我们看到上面的RegisterDefaultSniffers我们以MP3为例子，那么使用的sniff为SniffMP3<br>这里我们只关注MP3的sniff–SniffMP3。SniffMP3首先会调用Resync方法对音乐内容帧的帧头进行重新重定位，它会在音乐内容帧内对帧头进行搜索：每次读入1024字节的内容到待检测缓冲区，再从缓冲区中每次读取4个字节32位进行匹配，如果找到匹配的话还会读入后续的连续3个帧的帧头数据进行检测。如果4次检测均成功的话将当前位置作为音乐内容帧的起始位置返回，检测过程是通过GetMPEGAudioFrameSize方法来完成的，如果当前待检测缓冲区内数据没有匹配的则再次读入数据到缓冲区直到检测的位置达到最大检测字节数128*1024字节为止。</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">bool SniffMP3(<span class="keyword">const</span> sp&lt;DataSource&gt; &amp;source, String8 *mimeType,</span><br><span class="line">        float *confidence, sp&lt;AMessage&gt; *meta) &#123;</span><br><span class="line">    off64_t pos = <span class="number">0</span>;</span><br><span class="line">    off64_t post_id3_pos;</span><br><span class="line">    uint32_t header;</span><br><span class="line">    <span class="keyword">if</span> (!Resync(source, <span class="number">0</span>, &amp;pos, &amp;post_id3_pos, &amp;header)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *meta = <span class="keyword">new</span> AMessage;</span><br><span class="line">    <span class="function"><span class="params">(*meta)</span>-&gt;</span>setInt64(<span class="string">&quot;offset&quot;</span>, pos);</span><br><span class="line">    <span class="function"><span class="params">(*meta)</span>-&gt;</span>setInt32(<span class="string">&quot;header&quot;</span>, header);</span><br><span class="line">    <span class="function"><span class="params">(*meta)</span>-&gt;</span>setInt64(<span class="string">&quot;post-id3-offset&quot;</span>, post_id3_pos);</span><br><span class="line"></span><br><span class="line">    *mimeType = MEDIA_MIMETYPE_AUDIO_MPEG;</span><br><span class="line">    *confidence = <span class="number">0.2f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">Resync</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> sp&lt;DataSource&gt; &amp;source, <span class="type">uint32_t</span> match_header,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">off64_t</span> *inout_pos, <span class="type">off64_t</span> *post_id3_pos, <span class="type">uint32_t</span> *out_header)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (post_id3_pos != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        *post_id3_pos = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//跳过标题帧的位置开始同步。</span></span><br><span class="line">    <span class="keyword">if</span> (*inout_pos == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Skip an optional ID3 header if syncing at the very beginning</span></span><br><span class="line">        <span class="comment">// of the datasource.</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="type">uint8_t</span> id3header[<span class="number">10</span>];</span><br><span class="line">            <span class="comment">//读取头10个字节，如果不够10个字节表示存在错误返回false</span></span><br><span class="line">            <span class="keyword">if</span> (source-&gt;<span class="built_in">readAt</span>(*inout_pos, id3header, <span class="built_in">sizeof</span>(id3header))</span><br><span class="line">                    &lt; (<span class="type">ssize_t</span>)<span class="built_in">sizeof</span>(id3header)) &#123;</span><br><span class="line">                <span class="comment">// If we can&#x27;t even read these 10 bytes, we might as well bail</span></span><br><span class="line">                <span class="comment">// out, even if there _were_ 10 bytes of valid mp3 audio data...</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果头3个字节不是ID3退出该循环</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">memcmp</span>(<span class="string">&quot;ID3&quot;</span>, id3header, <span class="number">3</span>)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Skip the ID3v2 header.</span></span><br><span class="line">            <span class="comment">// 获取标签帧的长度</span></span><br><span class="line">            <span class="type">size_t</span> len =</span><br><span class="line">                ((id3header[<span class="number">6</span>] &amp; <span class="number">0x7f</span>) &lt;&lt; <span class="number">21</span>)</span><br><span class="line">                | ((id3header[<span class="number">7</span>] &amp; <span class="number">0x7f</span>) &lt;&lt; <span class="number">14</span>)</span><br><span class="line">                | ((id3header[<span class="number">8</span>] &amp; <span class="number">0x7f</span>) &lt;&lt; <span class="number">7</span>)</span><br><span class="line">                | (id3header[<span class="number">9</span>] &amp; <span class="number">0x7f</span>);</span><br><span class="line"></span><br><span class="line">            len += <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">            *inout_pos += len; <span class="comment">// inout_pos 指向音乐内容区的首地址</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">ALOGV</span>(<span class="string">&quot;skipped ID3 tag, new starting offset is %lld (0x%016llx)&quot;</span>,</span><br><span class="line">                    (<span class="type">long</span> <span class="type">long</span>)*inout_pos, (<span class="type">long</span> <span class="type">long</span>)*inout_pos);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (post_id3_pos != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            *post_id3_pos = *inout_pos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">off64_t</span> pos = *inout_pos;</span><br><span class="line">    <span class="type">bool</span> valid = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> kMaxReadBytes = <span class="number">1024</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> kMaxBytesChecked = <span class="number">128</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="type">uint8_t</span> buf[kMaxReadBytes];</span><br><span class="line">    <span class="type">ssize_t</span> bytesToRead = kMaxReadBytes;</span><br><span class="line">    <span class="type">ssize_t</span> totalBytesRead = <span class="number">0</span>;</span><br><span class="line">    <span class="type">ssize_t</span> remainingBytes = <span class="number">0</span>;</span><br><span class="line">    <span class="type">bool</span> reachEOS = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">uint8_t</span> *tmp = buf;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">//如果当前的扫描位置超过音乐内容区的kMaxBytesChecked（128K）就停止扫描</span></span><br><span class="line">        <span class="keyword">if</span> (pos &gt;= (<span class="type">off64_t</span>)(*inout_pos + kMaxBytesChecked)) &#123;</span><br><span class="line">            <span class="comment">// Don&#x27;t scan forever.</span></span><br><span class="line">            <span class="built_in">ALOGV</span>(<span class="string">&quot;giving up at offset %lld&quot;</span>, (<span class="type">long</span> <span class="type">long</span>)pos);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//加载一个缓冲区的内容。</span></span><br><span class="line">        <span class="keyword">if</span> (remainingBytes &lt; <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (reachEOS) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">memcpy</span>(buf, tmp, remainingBytes);</span><br><span class="line">                bytesToRead = kMaxReadBytes - remainingBytes;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * The next read position should start from the end of</span></span><br><span class="line"><span class="comment">                 * the last buffer, and thus should include the remaining</span></span><br><span class="line"><span class="comment">                 * bytes in the buffer.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                totalBytesRead = source-&gt;<span class="built_in">readAt</span>(pos + remainingBytes,</span><br><span class="line">                                                buf + remainingBytes,</span><br><span class="line">                                                bytesToRead);</span><br><span class="line">                <span class="keyword">if</span> (totalBytesRead &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                reachEOS = (totalBytesRead != bytesToRead);</span><br><span class="line">                totalBytesRead += remainingBytes;</span><br><span class="line">                remainingBytes = totalBytesRead;</span><br><span class="line">                tmp = buf;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从tmp缓冲区中取出头</span></span><br><span class="line">        <span class="type">uint32_t</span> header = <span class="built_in">U32_AT</span>(tmp);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (match_header != <span class="number">0</span> &amp;&amp; (header &amp; kMask) != (match_header &amp; kMask)) &#123;</span><br><span class="line">            <span class="comment">//如果帧的格式校验失败则从当前其实位置下一个位置开始获取32字节</span></span><br><span class="line">            ++pos;</span><br><span class="line">            ++tmp;</span><br><span class="line">            --remainingBytes;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">size_t</span> frame_size;</span><br><span class="line">        <span class="type">int</span> sample_rate, num_channels, bitrate;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">GetMPEGAudioFrameSize</span>(</span><br><span class="line">                    header, &amp;frame_size,</span><br><span class="line">                    &amp;sample_rate, &amp;num_channels, &amp;bitrate)) &#123;</span><br><span class="line">            ++pos;</span><br><span class="line">            ++tmp;</span><br><span class="line">            --remainingBytes;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">ALOGV</span>(<span class="string">&quot;found possible 1st frame at %lld (header = 0x%08x)&quot;</span>, (<span class="type">long</span> <span class="type">long</span>)pos, header);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We found what looks like a valid frame,</span></span><br><span class="line">        <span class="comment">// now find its successors.</span></span><br><span class="line"></span><br><span class="line">        <span class="type">off64_t</span> test_pos = pos + frame_size;</span><br><span class="line"></span><br><span class="line">        valid = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//再连续读取3三个音乐内容区的帧头进行检查，如果都正确就退出检测，将找到的音乐内容区域的位置以及音乐内容帧的帧头返回。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; ++j) &#123;</span><br><span class="line">            <span class="type">uint8_t</span> tmp[<span class="number">4</span>];</span><br><span class="line">            <span class="keyword">if</span> (source-&gt;<span class="built_in">readAt</span>(test_pos, tmp, <span class="number">4</span>) &lt; <span class="number">4</span>) &#123;</span><br><span class="line">                valid = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">uint32_t</span> test_header = <span class="built_in">U32_AT</span>(tmp);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">ALOGV</span>(<span class="string">&quot;subsequent header is %08x&quot;</span>, test_header);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((test_header &amp; kMask) != (header &amp; kMask)) &#123;</span><br><span class="line">                valid = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">size_t</span> test_frame_size;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">GetMPEGAudioFrameSize</span>(</span><br><span class="line">                        test_header, &amp;test_frame_size)) &#123;</span><br><span class="line">                valid = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">ALOGV</span>(<span class="string">&quot;found subsequent frame #%d at %lld&quot;</span>, j + <span class="number">2</span>, (<span class="type">long</span> <span class="type">long</span>)test_pos);</span><br><span class="line"></span><br><span class="line">            test_pos += test_frame_size;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (valid) &#123;</span><br><span class="line">            *inout_pos = pos;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (out_header != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                *out_header = header;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">ALOGV</span>(<span class="string">&quot;no dice, no valid sequence of frames found.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ++pos;</span><br><span class="line">        ++tmp;</span><br><span class="line">        --remainingBytes;</span><br><span class="line">    &#125; <span class="keyword">while</span> (!valid);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> valid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在MediaExtractor::Create 方法中我们通过sniff来识别当前音频的文件类型，并根据返回的mimeType以及可行度来创建具体的Extractor ，我们这里以MP3文件为例，根据sniff判断后在MediaExtractor::Create中将会创建MP3Extractor对象，在MP3Extractor构造方法中，主要是从传入的header中获取采样频率，通道数，帧大小等数据，并将其存入MetaData对象中。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">MP3Extractor::<span class="built_in">MP3Extractor</span>(</span><br><span class="line">        <span class="type">const</span> sp&lt;DataSource&gt; &amp;source, <span class="type">const</span> sp&lt;AMessage&gt; &amp;meta)</span><br><span class="line">    : <span class="built_in">mInitCheck</span>(NO_INIT),</span><br><span class="line">      <span class="built_in">mDataSource</span>(source),</span><br><span class="line">      <span class="built_in">mFirstFramePos</span>(<span class="number">-1</span>),</span><br><span class="line">      <span class="built_in">mFixedHeader</span>(<span class="number">0</span>) &#123;</span><br><span class="line">    <span class="type">off64_t</span> pos = <span class="number">0</span>;</span><br><span class="line">    <span class="type">off64_t</span> post_id3_pos;</span><br><span class="line">    <span class="type">uint32_t</span> header;</span><br><span class="line">    <span class="type">bool</span> success;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//下面这些值在SniffMP3中已经获取了</span></span><br><span class="line">    <span class="type">int64_t</span> meta_offset;<span class="comment">/*表示帧数据的偏移*/</span></span><br><span class="line">    <span class="type">uint32_t</span> meta_header;<span class="comment">/*表示帧头*/</span></span><br><span class="line">    <span class="type">int64_t</span> meta_post_id3_offset;<span class="comment">/*表示TAB帧的偏移*/</span></span><br><span class="line">    <span class="keyword">if</span> (meta != <span class="literal">NULL</span>&amp;&amp; meta-&gt;<span class="built_in">findInt64</span>(<span class="string">&quot;offset&quot;</span>, &amp;meta_offset)</span><br><span class="line">            &amp;&amp; meta-&gt;<span class="built_in">findInt32</span>(<span class="string">&quot;header&quot;</span>, (<span class="type">int32_t</span> *)&amp;meta_header)</span><br><span class="line">            &amp;&amp; meta-&gt;<span class="built_in">findInt64</span>(<span class="string">&quot;post-id3-offset&quot;</span>, &amp;meta_post_id3_offset)) &#123;</span><br><span class="line">        <span class="comment">// The sniffer has already done all the hard work for us, simply</span></span><br><span class="line">        <span class="comment">// accept its judgement.</span></span><br><span class="line">        pos = (<span class="type">off64_t</span>)meta_offset;</span><br><span class="line">        header = meta_header;</span><br><span class="line">        post_id3_pos = (<span class="type">off64_t</span>)meta_post_id3_offset;</span><br><span class="line">        success = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mFirstFramePos = pos;</span><br><span class="line">    mFixedHeader = header;</span><br><span class="line">    mMeta = <span class="keyword">new</span> MetaData;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> frame_size;</span><br><span class="line">    <span class="type">int</span> sample_rate;</span><br><span class="line">    <span class="type">int</span> num_channels;</span><br><span class="line">    <span class="type">int</span> bitrate;</span><br><span class="line">    <span class="built_in">GetMPEGAudioFrameSize</span>(header, &amp;frame_size, &amp;sample_rate, &amp;num_channels, &amp;bitrate);</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> layer = <span class="number">4</span> - ((header &gt;&gt; <span class="number">17</span>) &amp; <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (layer) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            mMeta-&gt;<span class="built_in">setCString</span>(kKeyMIMEType, MEDIA_MIMETYPE_AUDIO_MPEG_LAYER_I);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            mMeta-&gt;<span class="built_in">setCString</span>(kKeyMIMEType, MEDIA_MIMETYPE_AUDIO_MPEG_LAYER_II);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            mMeta-&gt;<span class="built_in">setCString</span>(kKeyMIMEType, MEDIA_MIMETYPE_AUDIO_MPEG);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">TRESPASS</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mMeta-&gt;<span class="built_in">setInt32</span>(kKeySampleRate, sample_rate);</span><br><span class="line">    mMeta-&gt;<span class="built_in">setInt32</span>(kKeyBitRate, bitrate * <span class="number">1000</span>);</span><br><span class="line">    mMeta-&gt;<span class="built_in">setInt32</span>(kKeyChannelCount, num_channels);</span><br><span class="line"></span><br><span class="line">    <span class="type">int64_t</span> durationUs;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (durationUs &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        mMeta-&gt;<span class="built_in">setInt64</span>(kKeyDuration, durationUs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mInitCheck = OK;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get iTunes-style gapless info if present.</span></span><br><span class="line">    <span class="comment">// When getting the id3 tag, skip the V1 tags to prevent the source cache</span></span><br><span class="line">    <span class="comment">// from being iterated to the end of the file.</span></span><br><span class="line">    <span class="function">ID3 <span class="title">id3</span><span class="params">(mDataSource, <span class="literal">true</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (id3.<span class="built_in">isValid</span>()) &#123;</span><br><span class="line">        ID3::Iterator *com = <span class="keyword">new</span> ID3::<span class="built_in">Iterator</span>(id3, <span class="string">&quot;COM&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (com-&gt;<span class="built_in">done</span>()) &#123;</span><br><span class="line">            <span class="keyword">delete</span> com;</span><br><span class="line">            com = <span class="keyword">new</span> ID3::<span class="built_in">Iterator</span>(id3, <span class="string">&quot;COMM&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!com-&gt;<span class="built_in">done</span>()) &#123;</span><br><span class="line">            String8 commentdesc;</span><br><span class="line">            String8 commentvalue;</span><br><span class="line">            com-&gt;<span class="built_in">getString</span>(&amp;commentdesc, &amp;commentvalue);</span><br><span class="line">            <span class="type">const</span> <span class="type">char</span> * desc = commentdesc.<span class="built_in">string</span>();</span><br><span class="line">            <span class="type">const</span> <span class="type">char</span> * value = commentvalue.<span class="built_in">string</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// first 3 characters are the language, which we don&#x27;t care about</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">strlen</span>(desc) &gt; <span class="number">3</span> &amp;&amp; <span class="built_in">strcmp</span>(desc + <span class="number">3</span>, <span class="string">&quot;iTunSMPB&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">int32_t</span> delay, padding;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">sscanf</span>(value, <span class="string">&quot; %*x %x %x %*x&quot;</span>, &amp;delay, &amp;padding) == <span class="number">2</span>) &#123;</span><br><span class="line">                    mMeta-&gt;<span class="built_in">setInt32</span>(kKeyEncoderDelay, delay);</span><br><span class="line">                    mMeta-&gt;<span class="built_in">setInt32</span>(kKeyEncoderPadding, padding);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            com-&gt;<span class="built_in">next</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span> com;</span><br><span class="line">        com = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到目前为止我们已经识别出了当前扫描音频文件的格式类型，并从对应的音乐内容数据帧头部（HEAD）获取到了采样率，比特率等信息，但是我们还有一部分非常重要的信息需要获取，那就是标签帧的信息，在那里记录者歌曲作者，专辑名，歌曲名，甚至专辑封面图片和内嵌歌词等信息，下面部分我们就重点介绍这些信息的获取过程。<br>我们再次回到processFileInternal方法，Tags文件的获取是在mRetriever-&gt;extractMetadata(kKeyMap[i].key)中完成的，<br>在extractMetadata方法传入的参数为要寻找的那个Tag的key，如果当前尚未对帧标签帧进行解析则先调用parseMetaData方法对Tag标签进行解析，如果已经解析过了则这时候就使用传人到keyCode 到mMetaData中进行查找，并返回的需要查找到那个Tag的值.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span> *<span class="title">StagefrightMetadataRetriever::extractMetadata</span><span class="params">(<span class="type">int</span> keyCode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mExtractor == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//调用parseMetaData()解析标签帧</span></span><br><span class="line">    <span class="keyword">if</span> (!mParsedMetaData) &#123;</span><br><span class="line">        <span class="built_in">parseMetaData</span>();</span><br><span class="line">        mParsedMetaData = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ssize_t</span> index = mMetaData.<span class="built_in">indexOfKey</span>(keyCode);</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    /将数据添加到mMetaData</span><br><span class="line">    <span class="keyword">return</span> mMetaData.<span class="built_in">valueAt</span>(index).<span class="built_in">string</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> StagefrightMetadataRetriever<span class="operator">::</span>parseMetaData() &#123;</span><br><span class="line">    <span class="comment">//获取MetaData</span></span><br><span class="line">    sp<span class="operator">&lt;</span>MetaData<span class="operator">&gt;</span> meta <span class="operator">=</span> mExtractor<span class="operator">-&gt;</span>getMetaData();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//TAG对应的map</span></span><br><span class="line">    <span class="keyword">struct</span> Map &#123;</span><br><span class="line">        int from;</span><br><span class="line">        int <span class="keyword">to</span>;</span><br><span class="line">        const char <span class="operator">*</span>name;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">static</span> const Map kMap[] <span class="operator">=</span> &#123;</span><br><span class="line">        &#123; kKeyMIMEType, METADATA_KEY_MIMETYPE, NULL &#125;,</span><br><span class="line">        &#123; kKeyCDTrackNumber, METADATA_KEY_CD_TRACK_NUMBER, <span class="string">&quot;tracknumber&quot;</span> &#125;,</span><br><span class="line">        &#123; kKeyDiscNumber, METADATA_KEY_DISC_NUMBER, <span class="string">&quot;discnumber&quot;</span> &#125;,</span><br><span class="line">        &#123; kKeyAlbum, METADATA_KEY_ALBUM, <span class="string">&quot;album&quot;</span> &#125;,</span><br><span class="line">        &#123; kKeyArtist, METADATA_KEY_ARTIST, <span class="string">&quot;artist&quot;</span> &#125;,</span><br><span class="line">        &#123; kKeyAlbumArtist, METADATA_KEY_ALBUMARTIST, <span class="string">&quot;albumartist&quot;</span> &#125;,</span><br><span class="line">        &#123; kKeyAuthor, METADATA_KEY_AUTHOR, NULL &#125;,</span><br><span class="line">        &#123; kKeyComposer, METADATA_KEY_COMPOSER, <span class="string">&quot;composer&quot;</span> &#125;,</span><br><span class="line">        &#123; kKeyDate, METADATA_KEY_DATE, NULL &#125;,</span><br><span class="line">        &#123; kKeyGenre, METADATA_KEY_GENRE, <span class="string">&quot;genre&quot;</span> &#125;,</span><br><span class="line">        &#123; kKeyTitle, METADATA_KEY_TITLE, <span class="string">&quot;title&quot;</span> &#125;,</span><br><span class="line">        &#123; kKeyYear, METADATA_KEY_YEAR, <span class="string">&quot;year&quot;</span> &#125;,</span><br><span class="line">        &#123; kKeyWriter, METADATA_KEY_WRITER, <span class="string">&quot;writer&quot;</span> &#125;,</span><br><span class="line">        &#123; kKeyCompilation, METADATA_KEY_COMPILATION, <span class="string">&quot;compilation&quot;</span> &#125;,</span><br><span class="line">        &#123; kKeyLocation, METADATA_KEY_LOCATION, NULL &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">static</span> const size_t kNumMapEntries <span class="operator">=</span> <span class="built_in">sizeof</span>(kMap) <span class="operator">/</span> <span class="built_in">sizeof</span>(kMap[<span class="number">0</span>]);</span><br><span class="line">    <span class="comment">//创建判断字符编码检测器</span></span><br><span class="line">    CharacterEncodingDetector <span class="operator">*</span>detector <span class="operator">=</span> <span class="keyword">new</span> CharacterEncodingDetector();</span><br><span class="line">    <span class="comment">//将对应的TAG添加到detector中</span></span><br><span class="line">    <span class="keyword">for</span> (size_t i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> kNumMapEntries; <span class="operator">++</span>i) &#123;</span><br><span class="line">        const char <span class="operator">*</span>value;</span><br><span class="line">        <span class="keyword">if</span> (meta<span class="operator">-&gt;</span>findCString(kMap[i].from, <span class="operator">&amp;</span>value)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (kMap[i].name) &#123;</span><br><span class="line">                <span class="comment">// add to charset detector</span></span><br><span class="line">                <span class="comment">//这里没有直接添加到mMetaData而是先添加到CharacterEncodingDetector的mNames，mValues中等待转换编码</span></span><br><span class="line">                detector<span class="operator">-&gt;</span>addTag(kMap[i].name, value);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// directly add to output list</span></span><br><span class="line">                mMetaData.add(kMap[i].<span class="keyword">to</span>, String8(value));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="operator">/*</span></span><br><span class="line">    <span class="keyword">void</span> CharacterEncodingDetector<span class="operator">::</span>addTag(const char <span class="operator">*</span>name, const char <span class="operator">*</span>value) &#123;</span><br><span class="line">        mNames.push_back(name);</span><br><span class="line">        mValues.push_back(value);</span><br><span class="line">    &#125;</span><br><span class="line">    ×<span class="operator">/</span></span><br><span class="line">    <span class="comment">//开始转化编码，这部分放在后面进行介绍</span></span><br><span class="line">    detector<span class="operator">-&gt;</span>detectAndConvert();</span><br><span class="line">    int size <span class="operator">=</span> detector<span class="operator">-&gt;</span>size();</span><br><span class="line">    <span class="keyword">if</span> (size) &#123;</span><br><span class="line">        <span class="comment">//将转换后的TAG放到mMetaData，这时候整个mMetaData存放的都是正确编码后的内容</span></span><br><span class="line">        <span class="keyword">for</span> (int i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> size; i<span class="operator">++</span>) &#123;</span><br><span class="line">            const char <span class="operator">*</span>name;</span><br><span class="line">            const char <span class="operator">*</span>value;</span><br><span class="line">            detector<span class="operator">-&gt;</span>getTag(i, <span class="operator">&amp;</span>name, <span class="operator">&amp;</span>value);</span><br><span class="line">            <span class="keyword">for</span> (size_t j <span class="operator">=</span> <span class="number">0</span>; j <span class="operator">&lt;</span> kNumMapEntries; <span class="operator">++</span>j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (kMap[j].name <span class="operator">&amp;&amp;</span> <span class="operator">!</span>strcmp(kMap[j].name, name)) &#123;</span><br><span class="line">                    mMetaData.add(kMap[j].<span class="keyword">to</span>, String8(value));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    delete detector;</span><br><span class="line"></span><br><span class="line">    const <span class="keyword">void</span> <span class="operator">*</span>data;</span><br><span class="line">    uint32_t <span class="keyword">type</span>;</span><br><span class="line">    size_t dataSize;</span><br><span class="line">    <span class="keyword">if</span> (meta<span class="operator">-&gt;</span>findData(kKeyAlbumArt, <span class="operator">&amp;</span><span class="keyword">type</span>, <span class="operator">&amp;</span>data, <span class="operator">&amp;</span>dataSize)<span class="operator">&amp;&amp;</span> mAlbumArt <span class="operator">==</span> NULL) &#123;</span><br><span class="line">        mAlbumArt <span class="operator">=</span> MediaAlbumArt<span class="operator">::</span>fromData(dataSize, data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    size_t numTracks <span class="operator">=</span> mExtractor<span class="operator">-&gt;</span>countTracks();</span><br><span class="line"></span><br><span class="line">    char tmp[<span class="number">32</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(tmp, <span class="string">&quot;%zu&quot;</span>, numTracks);</span><br><span class="line"></span><br><span class="line">    mMetaData.add(METADATA_KEY_NUM_TRACKS, String8(tmp));</span><br><span class="line"></span><br><span class="line">    float captureFps;</span><br><span class="line">    <span class="keyword">if</span> (meta<span class="operator">-&gt;</span>findFloat(kKeyCaptureFramerate, <span class="operator">&amp;</span>captureFps)) &#123;</span><br><span class="line">        <span class="built_in">sprintf</span>(tmp, <span class="string">&quot;%f&quot;</span>, captureFps);</span><br><span class="line">        mMetaData.add(METADATA_KEY_CAPTURE_FRAMERATE, String8(tmp));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool hasAudio <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    bool hasVideo <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    int32_t videoWidth <span class="operator">=</span> <span class="number">-1</span>;</span><br><span class="line">    int32_t videoHeight <span class="operator">=</span> <span class="number">-1</span>;</span><br><span class="line">    int32_t audioBitrate <span class="operator">=</span> <span class="number">-1</span>;</span><br><span class="line">    int32_t rotationAngle <span class="operator">=</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The overall duration is the duration of the longest track.</span></span><br><span class="line">    int64_t maxDurationUs <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    String8 timedTextLang;</span><br><span class="line">    <span class="keyword">for</span> (size_t i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> numTracks; <span class="operator">++</span>i) &#123;</span><br><span class="line">        sp<span class="operator">&lt;</span>MetaData<span class="operator">&gt;</span> trackMeta <span class="operator">=</span> mExtractor<span class="operator">-&gt;</span>getTrackMetaData(i);</span><br><span class="line">        int64_t durationUs;</span><br><span class="line">        <span class="keyword">if</span> (trackMeta<span class="operator">-&gt;</span>findInt64(kKeyDuration, <span class="operator">&amp;</span>durationUs)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (durationUs <span class="operator">&gt;</span> maxDurationUs) &#123;</span><br><span class="line">                maxDurationUs <span class="operator">=</span> durationUs;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        const char <span class="operator">*</span>mime;</span><br><span class="line">        <span class="keyword">if</span> (trackMeta<span class="operator">-&gt;</span>findCString(kKeyMIMEType, <span class="operator">&amp;</span>mime)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="operator">!</span>hasAudio <span class="operator">&amp;&amp;</span> <span class="operator">!</span>strncasecmp(<span class="string">&quot;audio/&quot;</span>, mime, <span class="number">6</span>)) &#123;</span><br><span class="line">                hasAudio <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (<span class="operator">!</span>trackMeta<span class="operator">-&gt;</span>findInt32(kKeyBitRate, <span class="operator">&amp;</span>audioBitrate)) &#123;</span><br><span class="line">                    audioBitrate <span class="operator">=</span> <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="operator">!</span>hasVideo <span class="operator">&amp;&amp;</span> <span class="operator">!</span>strncasecmp(<span class="string">&quot;video/&quot;</span>, mime, <span class="number">6</span>)) &#123;</span><br><span class="line">                hasVideo <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">                CHECK(trackMeta<span class="operator">-&gt;</span>findInt32(kKeyWidth, <span class="operator">&amp;</span>videoWidth));</span><br><span class="line">                CHECK(trackMeta<span class="operator">-&gt;</span>findInt32(kKeyHeight, <span class="operator">&amp;</span>videoHeight));</span><br><span class="line">                <span class="keyword">if</span> (<span class="operator">!</span>trackMeta<span class="operator">-&gt;</span>findInt32(kKeyRotation, <span class="operator">&amp;</span>rotationAngle)) &#123;</span><br><span class="line">                    rotationAngle <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="operator">!</span>strcasecmp(mime, MEDIA_MIMETYPE_TEXT_3GPP)) &#123;</span><br><span class="line">                const char <span class="operator">*</span>lang;</span><br><span class="line">                trackMeta<span class="operator">-&gt;</span>findCString(kKeyMediaLanguage, <span class="operator">&amp;</span>lang);</span><br><span class="line">                timedTextLang.append(String8(lang));</span><br><span class="line">                timedTextLang.append(String8(<span class="string">&quot;:&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// To save the language codes for all timed text tracks</span></span><br><span class="line">    <span class="comment">// If multiple text tracks present, the format will look</span></span><br><span class="line">    <span class="comment">// like &quot;eng:chi&quot;</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="operator">!</span>timedTextLang.isEmpty()) &#123;</span><br><span class="line">        mMetaData.add(METADATA_KEY_TIMED_TEXT_LANGUAGES, timedTextLang);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The duration value is a string representing the duration in ms.</span></span><br><span class="line">    <span class="built_in">sprintf</span>(tmp, <span class="string">&quot;%&quot;</span> PRId64, (maxDurationUs <span class="operator">+</span> <span class="number">500</span>) <span class="operator">/</span> <span class="number">1000</span>);</span><br><span class="line">    mMetaData.add(METADATA_KEY_DURATION, String8(tmp));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hasAudio) &#123;</span><br><span class="line">        mMetaData.add(METADATA_KEY_HAS_AUDIO, String8(<span class="string">&quot;yes&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hasVideo) &#123;</span><br><span class="line">        mMetaData.add(METADATA_KEY_HAS_VIDEO, String8(<span class="string">&quot;yes&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="built_in">sprintf</span>(tmp, <span class="string">&quot;%d&quot;</span>, videoWidth);</span><br><span class="line">        mMetaData.add(METADATA_KEY_VIDEO_WIDTH, String8(tmp));</span><br><span class="line"></span><br><span class="line">        <span class="built_in">sprintf</span>(tmp, <span class="string">&quot;%d&quot;</span>, videoHeight);</span><br><span class="line">        mMetaData.add(METADATA_KEY_VIDEO_HEIGHT, String8(tmp));</span><br><span class="line"></span><br><span class="line">        <span class="built_in">sprintf</span>(tmp, <span class="string">&quot;%d&quot;</span>, rotationAngle);</span><br><span class="line">        mMetaData.add(METADATA_KEY_VIDEO_ROTATION, String8(tmp));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (numTracks <span class="operator">==</span> <span class="number">1</span> <span class="operator">&amp;&amp;</span> hasAudio <span class="operator">&amp;&amp;</span> audioBitrate <span class="operator">&gt;=</span> <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">sprintf</span>(tmp, <span class="string">&quot;%d&quot;</span>, audioBitrate);</span><br><span class="line">        mMetaData.add(METADATA_KEY_BITRATE, String8(tmp));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        off64_t sourceSize;</span><br><span class="line">        <span class="keyword">if</span> (mSource<span class="operator">-&gt;</span>getSize(<span class="operator">&amp;</span>sourceSize) <span class="operator">==</span> OK) &#123;</span><br><span class="line">            int64_t avgBitRate <span class="operator">=</span> (int64_t)(sourceSize <span class="operator">*</span> <span class="number">8E6</span> <span class="operator">/</span> maxDurationUs);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">sprintf</span>(tmp, <span class="string">&quot;%&quot;</span> PRId64, avgBitRate);</span><br><span class="line">            mMetaData.add(METADATA_KEY_BITRATE, String8(tmp));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (numTracks <span class="operator">==</span> <span class="number">1</span>) &#123;</span><br><span class="line">        const char <span class="operator">*</span>fileMIME;</span><br><span class="line">        CHECK(meta<span class="operator">-&gt;</span>findCString(kKeyMIMEType, <span class="operator">&amp;</span>fileMIME));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="operator">!</span>strcasecmp(fileMIME, <span class="string">&quot;video/x-matroska&quot;</span>)) &#123;</span><br><span class="line">            sp<span class="operator">&lt;</span>MetaData<span class="operator">&gt;</span> trackMeta <span class="operator">=</span> mExtractor<span class="operator">-&gt;</span>getTrackMetaData(<span class="number">0</span>);</span><br><span class="line">            const char <span class="operator">*</span>trackMIME;</span><br><span class="line">            CHECK(trackMeta<span class="operator">-&gt;</span>findCString(kKeyMIMEType, <span class="operator">&amp;</span>trackMIME));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="operator">!</span>strncasecmp(<span class="string">&quot;audio/&quot;</span>, trackMIME, <span class="number">6</span>)) &#123;</span><br><span class="line">                <span class="comment">// The matroska file only contains a single audio track,</span></span><br><span class="line">                <span class="comment">// rewrite its mime type.</span></span><br><span class="line">                mMetaData.add(</span><br><span class="line">                        METADATA_KEY_MIMETYPE, String8(<span class="string">&quot;audio/x-matroska&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// To check whether the media file is drm-protected</span></span><br><span class="line">    <span class="keyword">if</span> (mExtractor<span class="operator">-&gt;</span>getDrmFlag()) &#123;</span><br><span class="line">        mMetaData.add(METADATA_KEY_IS_DRM, String8(<span class="string">&quot;1&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面代码中可以看出完成关键工作就是从Meta中取出各个TAG，经过字符编码转换后添加到mMetaData中。</p>
<p>我们看到这里不要忽略了getMetaData，getMetaData方法中通过创建用于对存储在文件头的ID3V2标签帧和存储在文件尾部的ID3V1帧进行解析的ID3对象来完成标签帧到解析，这里解析的内容包括基本的歌曲信息标签以及歌词，专辑封面等信息。想要真正了解整个解析过程我们还得继续看下ID3类的构造方法和ID3::Iterator方法。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">sp&lt;MetaData&gt; MP3Extractor::get<span class="constructor">MetaData()</span> &#123;</span><br><span class="line">    sp&lt;MetaData&gt; meta = <span class="keyword">new</span> MetaData;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mInitCheck != OK) &#123;</span><br><span class="line">        return meta;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置mimetype</span></span><br><span class="line">    meta-&gt;set<span class="constructor">CString(<span class="params">kKeyMIMEType</span>, <span class="string">&quot;audio/mpeg&quot;</span>)</span>;</span><br><span class="line">    <span class="comment">//创建id3</span></span><br><span class="line">    ID3 id3(mDataSource);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!id3.is<span class="constructor">Valid()</span>) &#123;</span><br><span class="line">        return meta;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> Map &#123;</span><br><span class="line">        <span class="built_in">int</span> key;</span><br><span class="line">        const <span class="built_in">char</span> *tag1;</span><br><span class="line">        const <span class="built_in">char</span> *tag2;</span><br><span class="line">    &#125;;</span><br><span class="line">    static const Map kMap<span class="literal">[]</span> = &#123;</span><br><span class="line">        &#123; kKeyAlbum, <span class="string">&quot;TALB&quot;</span>, <span class="string">&quot;TAL&quot;</span> &#125;,</span><br><span class="line">        &#123; kKeyArtist, <span class="string">&quot;TPE1&quot;</span>, <span class="string">&quot;TP1&quot;</span> &#125;,</span><br><span class="line">        &#123; kKeyAlbumArtist, <span class="string">&quot;TPE2&quot;</span>, <span class="string">&quot;TP2&quot;</span> &#125;,</span><br><span class="line">        &#123; kKeyComposer, <span class="string">&quot;TCOM&quot;</span>, <span class="string">&quot;TCM&quot;</span> &#125;,</span><br><span class="line">        &#123; kKeyGenre, <span class="string">&quot;TCON&quot;</span>, <span class="string">&quot;TCO&quot;</span> &#125;,</span><br><span class="line">        &#123; kKeyTitle, <span class="string">&quot;TIT2&quot;</span>, <span class="string">&quot;TT2&quot;</span> &#125;,</span><br><span class="line">        &#123; kKeyYear, <span class="string">&quot;TYE&quot;</span>, <span class="string">&quot;TYER&quot;</span> &#125;,</span><br><span class="line">        &#123; kKeyAuthor, <span class="string">&quot;TXT&quot;</span>, <span class="string">&quot;TEXT&quot;</span> &#125;,</span><br><span class="line">        &#123; kKeyCDTrackNumber, <span class="string">&quot;TRK&quot;</span>, <span class="string">&quot;TRCK&quot;</span> &#125;,</span><br><span class="line">        &#123; kKeyDiscNumber, <span class="string">&quot;TPA&quot;</span>, <span class="string">&quot;TPOS&quot;</span> &#125;,</span><br><span class="line">        &#123; kKeyCompilation, <span class="string">&quot;TCP&quot;</span>, <span class="string">&quot;TCMP&quot;</span> &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">    static const size_t kNumMapEntries = sizeof(kMap)<span class="operator"> / </span>sizeof(kMap<span class="literal">[<span class="number">0</span>]</span>);</span><br><span class="line">    <span class="comment">//获取上面提到的TAG</span></span><br><span class="line">    <span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; kNumMapEntries; ++i) &#123;</span><br><span class="line">        ID3::Iterator *it = <span class="keyword">new</span> ID3::<span class="constructor">Iterator(<span class="params">id3</span>, <span class="params">kMap</span>[<span class="params">i</span>].<span class="params">tag1</span>)</span>;</span><br><span class="line">        <span class="keyword">if</span> (it-&gt;<span class="keyword">done</span><span class="literal">()</span>) &#123;</span><br><span class="line">            delete it;</span><br><span class="line">            it = <span class="keyword">new</span> ID3::<span class="constructor">Iterator(<span class="params">id3</span>, <span class="params">kMap</span>[<span class="params">i</span>].<span class="params">tag2</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (it-&gt;<span class="keyword">done</span><span class="literal">()</span>) &#123;</span><br><span class="line">            delete it;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        String8 s;</span><br><span class="line">        it-&gt;get<span class="constructor">String(&amp;<span class="params">s</span>)</span>;</span><br><span class="line">        delete it;</span><br><span class="line">        meta-&gt;set<span class="constructor">CString(<span class="params">kMap</span>[<span class="params">i</span>].<span class="params">key</span>, <span class="params">s</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    size_t dataSize;</span><br><span class="line">    String8 mime;</span><br><span class="line">    <span class="comment">//获取专辑封面</span></span><br><span class="line">    const void *data = id3.get<span class="constructor">AlbumArt(&amp;<span class="params">dataSize</span>, &amp;<span class="params">mime</span>)</span>;</span><br><span class="line">    <span class="keyword">if</span> (data) &#123;</span><br><span class="line">        meta-&gt;set<span class="constructor">Data(<span class="params">kKeyAlbumArt</span>, MetaData::TYPE_NONE, <span class="params">data</span>, <span class="params">dataSize</span>)</span>;</span><br><span class="line">        meta-&gt;set<span class="constructor">CString(<span class="params">kKeyAlbumArtMIME</span>, <span class="params">mime</span>.<span class="params">string</span>()</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    return meta;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们先看下ID3的构造方法，在ID3方法中，会先调用parseV2，如果parseV2返回false的话会调用parseV1，也就是说ID3会首先解析位于文件头到ID3V2标签帧，如果解析失败则会尝试解析ID3V1帧。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">ID3::<span class="constructor">ID3(<span class="params">const</span> <span class="params">sp</span>&lt;DataSource&gt; &amp;<span class="params">source</span>, <span class="params">bool</span> <span class="params">ignoreV1</span>, <span class="params">off64_t</span> <span class="params">offset</span>)</span></span><br><span class="line">    : m<span class="constructor">IsValid(<span class="params">false</span>)</span>,</span><br><span class="line">      m<span class="constructor">Data(NULL)</span>,</span><br><span class="line">      m<span class="constructor">Size(0)</span>,</span><br><span class="line">      m<span class="constructor">FirstFrameOffset(0)</span>,</span><br><span class="line">      m<span class="constructor">Version(ID3_UNKNOWN)</span>,</span><br><span class="line">      m<span class="constructor">RawSize(0)</span> &#123;</span><br><span class="line">    <span class="comment">//解析ID3V2Tab内容</span></span><br><span class="line">    mIsValid = parse<span class="constructor">V2(<span class="params">source</span>, <span class="params">offset</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mIsValid<span class="operator"> &amp;&amp; </span>!ignoreV1) &#123;</span><br><span class="line">        <span class="comment">//解析ID3V1 TAB 内容</span></span><br><span class="line">        mIsValid = parse<span class="constructor">V1(<span class="params">source</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而在parseV2以及parseV1方法中实际上也还没开始解析，它们只是开辟个mData 空间将对应的TAG标签加载到mData中，后续的解析工作将会针对mData中的这些数据进行解析。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ID3::parseV2</span><span class="params">(<span class="type">const</span> sp&lt;DataSource&gt; &amp;source)</span> </span>&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">id3_header</span> &#123;</span><br><span class="line">    <span class="comment">//标签头10个字节</span></span><br><span class="line">    <span class="type">char</span> id[<span class="number">3</span>]; <span class="comment">/*必须为&quot;ID3&quot;否则认为标签不存在*/</span></span><br><span class="line">    <span class="type">uint8_t</span> version_major;  <span class="comment">/*版本号ID3V2.3就记录3*/</span></span><br><span class="line">    <span class="type">uint8_t</span> version_minor;  <span class="comment">/*副版本号此版本记录为0*/</span></span><br><span class="line">    <span class="type">uint8_t</span> flags; <span class="comment">/*存放标志的字节，这个版本只定义了三位*/</span></span><br><span class="line">    <span class="type">uint8_t</span> enc_size[<span class="number">4</span>];  <span class="comment">/*标签大小，不包括标签头的10个字节*/</span></span><br><span class="line">    &#125;;</span><br><span class="line">    id3_header header;</span><br><span class="line">    <span class="keyword">if</span> (source-&gt;<span class="built_in">readAt</span>(<span class="number">0</span>, &amp;header, <span class="built_in">sizeof</span>(header)) != (<span class="type">ssize_t</span>)<span class="built_in">sizeof</span>(header)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*必须为&quot;ID3&quot;否则认为标签不存在*/</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">memcmp</span>(header.id, <span class="string">&quot;ID3&quot;</span>, <span class="number">3</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果主版本号和副版本号都是0xff则表示错误</span></span><br><span class="line">    <span class="keyword">if</span> (header.version_major == <span class="number">0xff</span> || header.version_minor == <span class="number">0xff</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">if</span> (header.version_major == <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="comment">//如果主版本号为2</span></span><br><span class="line">     <span class="comment">//............................................</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (header.version_major == <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="comment">//如果主版本号为3</span></span><br><span class="line">        <span class="keyword">if</span> (header.flags &amp; <span class="number">0x1f</span>) &#123;</span><br><span class="line">            <span class="comment">// We only support the 3 high bits, if any of the lower bits are</span></span><br><span class="line">            <span class="comment">// set, we cannot guarantee to understand the tag format.</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (header.version_major == <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="comment">//如果主版本号为4</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//如果主版本号不是上述的则直接返回false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取标签大小</span></span><br><span class="line">    <span class="type">size_t</span> size;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">ParseSyncsafeInteger</span>(header.enc_size, &amp;size)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//static const size_t kMaxMetadataSize = 3 * 1024 * 1024;</span></span><br><span class="line">    <span class="comment">//如果大小超过3M则退出</span></span><br><span class="line">    <span class="keyword">if</span> (size &gt; kMaxMetadataSize) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//分配用于存放标签内容的空间</span></span><br><span class="line">    mData = (<span class="type">uint8_t</span> *)<span class="built_in">malloc</span>(size);</span><br><span class="line">    mSize = size;</span><br><span class="line">    mRawSize = mSize + <span class="built_in">sizeof</span>(header);</span><br><span class="line">    <span class="comment">//mRawSize 表示 标签帧大小加上 标签头大小10个字节 </span></span><br><span class="line">    <span class="comment">//读取标签帧数据</span></span><br><span class="line">    <span class="keyword">if</span> (source-&gt;<span class="built_in">readAt</span>(<span class="built_in">sizeof</span>(header), mData, mSize) != (<span class="type">ssize_t</span>)mSize) &#123;</span><br><span class="line">        <span class="built_in">free</span>(mData);</span><br><span class="line">        mData = <span class="literal">NULL</span> ;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//..........................................................</span></span><br><span class="line">    mFirstFrameOffset = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//..........................................................</span></span><br><span class="line">    <span class="keyword">if</span> (header.version_major == <span class="number">2</span>) &#123;</span><br><span class="line">        mVersion = ID3_V2_2;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (header.version_major == <span class="number">3</span>) &#123;</span><br><span class="line">        mVersion = ID3_V2_3;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">CHECK_EQ</span>(header.version_major, <span class="number">4</span>);</span><br><span class="line">        mVersion = ID3_V2_4;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ID3::parseV1</span><span class="params">(<span class="type">const</span> sp&lt;DataSource&gt; &amp;source)</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> V1_TAG_SIZE = <span class="number">128</span>;</span><br><span class="line">    <span class="type">off64_t</span> size;</span><br><span class="line">    <span class="keyword">if</span> (source-&gt;<span class="built_in">getSize</span>(&amp;size) != OK || size &lt; (<span class="type">off64_t</span>)V1_TAG_SIZE) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//分配空间</span></span><br><span class="line">    mData = (<span class="type">uint8_t</span> *)<span class="built_in">malloc</span>(V1_TAG_SIZE);</span><br><span class="line">    <span class="comment">//读取位于文件尾部128字节的V1标签帧</span></span><br><span class="line">    <span class="keyword">if</span> (source-&gt;<span class="built_in">readAt</span>(size - V1_TAG_SIZE, mData, V1_TAG_SIZE)</span><br><span class="line">            != (<span class="type">ssize_t</span>)V1_TAG_SIZE) &#123;</span><br><span class="line">        <span class="built_in">free</span>(mData);</span><br><span class="line">        mData = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">memcmp</span>(<span class="string">&quot;TAG&quot;</span>, mData, <span class="number">3</span>)) &#123;</span><br><span class="line">        <span class="built_in">free</span>(mData);</span><br><span class="line">        mData = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mSize = V1_TAG_SIZE;</span><br><span class="line">    mFirstFrameOffset = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span> (mData[V1_TAG_SIZE - <span class="number">3</span>] != <span class="number">0</span>) &#123;</span><br><span class="line">        mVersion = ID3_V1;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mVersion = ID3_V1_1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>真正的解析流程是从Iterator开始的，在Iterator中先是调用strdup(id)获取当前要获取的Tag到ID值放到mID中，接着调用findFrame找到对应到帧。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">ID3::Iterator::<span class="constructor">Iterator(<span class="params">const</span> ID3 &amp;<span class="params">parent</span>, <span class="params">const</span> <span class="params">char</span> <span class="operator">*</span><span class="params">id</span>)</span></span><br><span class="line">    : m<span class="constructor">Parent(<span class="params">parent</span>)</span>,</span><br><span class="line">      m<span class="constructor">ID(NULL)</span>,</span><br><span class="line">      m<span class="constructor">Offset(<span class="params">mParent</span>.<span class="params">mFirstFrameOffset</span>)</span>,</span><br><span class="line">      m<span class="constructor">FrameData(NULL)</span>,</span><br><span class="line">      m<span class="constructor">FrameSize(0)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (id) &#123;</span><br><span class="line">        mID = strdup(id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//找到帧对应的位置</span></span><br><span class="line">    find<span class="constructor">Frame()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在findFrame中将当前ID与存储着全部标签帧数据的mData空间中的每个帧进行对比，如果找到帧标志等于当前ID的数据的时候就退出遍历循环，这时候mID就指向要寻找标签数据的位置。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> ID3::Iterator::<span class="built_in">findFrame</span>() &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        mFrameData = <span class="literal">NULL</span>;</span><br><span class="line">        mFrameSize = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (mParent.mVersion == ID3_V2_2) &#123;</span><br><span class="line">           <span class="comment">//..................................................</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mParent.mVersion == ID3_V2_3</span><br><span class="line">                || mParent.mVersion == ID3_V2_4) &#123;</span><br><span class="line">            <span class="comment">//这是正常的MP3格式</span></span><br><span class="line">            <span class="keyword">if</span> (mOffset + <span class="number">10</span> &gt; mParent.mSize) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果头四个字节为0000则返回</span></span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">memcmp</span>(&amp;mParent.mData[mOffset], <span class="string">&quot;\0\0\0\0&quot;</span>, <span class="number">4</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">size_t</span> baseSize;</span><br><span class="line">            <span class="keyword">if</span> (mParent.mVersion == ID3_V2_4) &#123;</span><br><span class="line">                <span class="comment">//.......................................................................</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//获取标签帧的内容大小</span></span><br><span class="line">                baseSize = <span class="built_in">U32_AT</span>(&amp;mParent.mData[mOffset + <span class="number">4</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//表示包含帧头的总共大小</span></span><br><span class="line">            mFrameSize = <span class="number">10</span> + baseSize;</span><br><span class="line">            <span class="keyword">if</span> (mOffset + mFrameSize &gt; mParent.mSize) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当前标签帧的内容数据</span></span><br><span class="line">            mFrameData = &amp;mParent.mData[mOffset + <span class="number">10</span>];</span><br><span class="line">            <span class="keyword">if</span> (!mID) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将Tab 复制到id上，判断id是否等于mID如果不等则继续查找</span></span><br><span class="line">            <span class="type">char</span> id[<span class="number">5</span>];</span><br><span class="line">            <span class="built_in">memcpy</span>(id, &amp;mParent.mData[mOffset], <span class="number">4</span>);</span><br><span class="line">            id[<span class="number">4</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">            <span class="comment">//如果等于要找的ID 则退出循环，这时候mOffset 指向的是要查找帧的位置</span></span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(id, mID)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">//.................................................</span></span><br><span class="line">        &#125;</span><br><span class="line">        mOffset += mFrameSize;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获取专辑图片：<br>专辑图片的获取过程实际和获取其他TAG的方式是一样的，也是通过遍历存放ID3标签原始数据的mData空间，找到标签为”APIC”的数据，然后再将指向专辑图片的数据的首地址返回。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">void</span> *</span></span><br><span class="line"><span class="function"><span class="title">ID3::getAlbumArt</span><span class="params">(<span class="type">size_t</span> *length, String8 *mime)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    *length = <span class="number">0</span>;</span><br><span class="line">    mime-&gt;<span class="built_in">setTo</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="comment">//APIC Attached picture 定位专辑图片的位置</span></span><br><span class="line">    <span class="function">Iterator <span class="title">it</span><span class="params">(*<span class="keyword">this</span>,(mVersion == ID3_V2_3 || mVersion == ID3_V2_4) ? <span class="string">&quot;APIC&quot;</span> : <span class="string">&quot;PIC&quot;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (!it.<span class="built_in">done</span>()) &#123;</span><br><span class="line">        <span class="type">size_t</span> size;</span><br><span class="line">        <span class="comment">//指向专辑图片数据</span></span><br><span class="line">        <span class="type">const</span> <span class="type">uint8_t</span> *data = it.<span class="built_in">getData</span>(&amp;size);</span><br><span class="line">        <span class="keyword">if</span> (mVersion == ID3_V2_3 || mVersion == ID3_V2_4) &#123;</span><br><span class="line">            <span class="type">uint8_t</span> encoding = data[<span class="number">0</span>];</span><br><span class="line">            mime-&gt;<span class="built_in">setTo</span>((<span class="type">const</span> <span class="type">char</span> *)&amp;data[<span class="number">1</span>]);</span><br><span class="line">            <span class="type">size_t</span> mimeLen = <span class="built_in">strlen</span>((<span class="type">const</span> <span class="type">char</span> *)&amp;data[<span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//返回图片的类型</span></span><br><span class="line">            <span class="type">uint8_t</span> picType = data[<span class="number">1</span> + mimeLen];</span><br><span class="line">            <span class="comment">//图片描述的内容长度</span></span><br><span class="line">            <span class="type">size_t</span> descLen = <span class="built_in">StringSize</span>(&amp;data[<span class="number">2</span> + mimeLen], encoding);</span><br><span class="line">            <span class="comment">//图片的实际长度</span></span><br><span class="line">            *length = size - <span class="number">2</span> - mimeLen - descLen;</span><br><span class="line">            <span class="comment">//返回图片的地址</span></span><br><span class="line">            <span class="keyword">return</span> &amp;data[<span class="number">2</span> + mimeLen + descLen];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">//...........................................................</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述就是获取各个标签帧数据的流程，找出标签帧的值后就将可以将其取出存储到mMetaData中了。<br>我们再回到processFileInternal方法，看下接下来需要做哪些操作：它将会调用status &#x3D; client.addStringTag(kKeyMap[i].tag, value);将该Tag传递到MediaScannerClient中进行处理，那么在MediaScannerClient中会做哪些处理呢？</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">status_t MediaScannerClient::add<span class="constructor">StringTag(<span class="params">const</span> <span class="params">char</span><span class="operator">*</span> <span class="params">name</span>, <span class="params">const</span> <span class="params">char</span><span class="operator">*</span> <span class="params">value</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    handle<span class="constructor">StringTag(<span class="params">name</span>, <span class="params">value</span>)</span>;</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在MediaScanner.java中将从底层传来的对应值赋给对应的成员变量。至此就完成了音频视频文件的Tag标签的获取过程。接下来和其他普通文件的处理方式一样，就是通过MediaProvider将其存储到数据库中。从而完成媒体扫描的整个过程。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public void handle<span class="constructor">StringTag(String <span class="params">name</span>, String <span class="params">value</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (name.equals<span class="constructor">IgnoreCase(<span class="string">&quot;title&quot;</span>)</span><span class="operator"> || </span>name.starts<span class="constructor">With(<span class="string">&quot;title;&quot;</span>)</span>) &#123;</span><br><span class="line">        <span class="comment">// Don&#x27;t trim() here, to preserve the special \001 character</span></span><br><span class="line">        <span class="comment">// used to force sorting. The media provider will trim() before</span></span><br><span class="line">        <span class="comment">// inserting the title in to the database.</span></span><br><span class="line">        mTitle = value;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name.equals<span class="constructor">IgnoreCase(<span class="string">&quot;artist&quot;</span>)</span><span class="operator"> || </span>name.starts<span class="constructor">With(<span class="string">&quot;artist;&quot;</span>)</span>) &#123;</span><br><span class="line">        mArtist = value.trim<span class="literal">()</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name.equals<span class="constructor">IgnoreCase(<span class="string">&quot;albumartist&quot;</span>)</span><span class="operator"> || </span>name.starts<span class="constructor">With(<span class="string">&quot;albumartist;&quot;</span>)</span><span class="operator"></span></span><br><span class="line"><span class="operator">            || </span>name.equals<span class="constructor">IgnoreCase(<span class="string">&quot;band&quot;</span>)</span><span class="operator"> || </span>name.starts<span class="constructor">With(<span class="string">&quot;band;&quot;</span>)</span>) &#123;</span><br><span class="line">        mAlbumArtist = value.trim<span class="literal">()</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name.equals<span class="constructor">IgnoreCase(<span class="string">&quot;album&quot;</span>)</span><span class="operator"> || </span>name.starts<span class="constructor">With(<span class="string">&quot;album;&quot;</span>)</span>) &#123;</span><br><span class="line">        mAlbum = value.trim<span class="literal">()</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name.equals<span class="constructor">IgnoreCase(<span class="string">&quot;composer&quot;</span>)</span><span class="operator"> || </span>name.starts<span class="constructor">With(<span class="string">&quot;composer;&quot;</span>)</span>) &#123;</span><br><span class="line">        mComposer = value.trim<span class="literal">()</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mProcessGenres<span class="operator"> &amp;&amp;</span></span><br><span class="line"><span class="operator">            </span>(name.equals<span class="constructor">IgnoreCase(<span class="string">&quot;genre&quot;</span>)</span><span class="operator"> || </span>name.starts<span class="constructor">With(<span class="string">&quot;genre;&quot;</span>)</span>)) &#123;</span><br><span class="line">        mGenre = get<span class="constructor">GenreName(<span class="params">value</span>)</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name.equals<span class="constructor">IgnoreCase(<span class="string">&quot;year&quot;</span>)</span><span class="operator"> || </span>name.starts<span class="constructor">With(<span class="string">&quot;year;&quot;</span>)</span>) &#123;</span><br><span class="line">        mYear = parse<span class="constructor">Substring(<span class="params">value</span>, 0, 0)</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name.equals<span class="constructor">IgnoreCase(<span class="string">&quot;tracknumber&quot;</span>)</span><span class="operator"> || </span>name.starts<span class="constructor">With(<span class="string">&quot;tracknumber;&quot;</span>)</span>) &#123;</span><br><span class="line">        <span class="comment">// track number might be of the form &quot;2/12&quot;</span></span><br><span class="line">        <span class="comment">// we just read the number before the slash</span></span><br><span class="line">        <span class="built_in">int</span> num = parse<span class="constructor">Substring(<span class="params">value</span>, 0, 0)</span>;</span><br><span class="line">        mTrack = (mTrack<span class="operator"> / </span><span class="number">1000</span>)<span class="operator"> * </span><span class="number">1000</span> + num;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name.equals<span class="constructor">IgnoreCase(<span class="string">&quot;discnumber&quot;</span>)</span><span class="operator"> ||</span></span><br><span class="line"><span class="operator">            </span>name.equals(<span class="string">&quot;set&quot;</span>)<span class="operator"> || </span>name.starts<span class="constructor">With(<span class="string">&quot;set;&quot;</span>)</span>) &#123;</span><br><span class="line">        <span class="comment">// set number might be of the form &quot;1/3&quot;</span></span><br><span class="line">        <span class="comment">// we just read the number before the slash</span></span><br><span class="line">        <span class="built_in">int</span> num = parse<span class="constructor">Substring(<span class="params">value</span>, 0, 0)</span>;</span><br><span class="line">        mTrack = (num<span class="operator"> * </span><span class="number">1000</span>) + (mTrack % <span class="number">1000</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name.equals<span class="constructor">IgnoreCase(<span class="string">&quot;duration&quot;</span>)</span>) &#123;</span><br><span class="line">        mDuration = parse<span class="constructor">Substring(<span class="params">value</span>, 0, 0)</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name.equals<span class="constructor">IgnoreCase(<span class="string">&quot;writer&quot;</span>)</span><span class="operator"> || </span>name.starts<span class="constructor">With(<span class="string">&quot;writer;&quot;</span>)</span>) &#123;</span><br><span class="line">        mWriter = value.trim<span class="literal">()</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name.equals<span class="constructor">IgnoreCase(<span class="string">&quot;compilation&quot;</span>)</span>) &#123;</span><br><span class="line">        mCompilation = parse<span class="constructor">Substring(<span class="params">value</span>, 0, 0)</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name.equals<span class="constructor">IgnoreCase(<span class="string">&quot;isdrm&quot;</span>)</span>) &#123;</span><br><span class="line">        mIsDrm = (parse<span class="constructor">Substring(<span class="params">value</span>, 0, 0)</span><span class="operator"> == </span><span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name.equals<span class="constructor">IgnoreCase(<span class="string">&quot;width&quot;</span>)</span>) &#123;</span><br><span class="line">        mWidth = parse<span class="constructor">Substring(<span class="params">value</span>, 0, 0)</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name.equals<span class="constructor">IgnoreCase(<span class="string">&quot;height&quot;</span>)</span>) &#123;</span><br><span class="line">        mHeight = parse<span class="constructor">Substring(<span class="params">value</span>, 0, 0)</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//Log.v(TAG, &quot;unknown tag: &quot; + name + &quot; (&quot; + mProcessGenres + &quot;)&quot;);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此TAG的解析以及解码过程已经结束，我们最后还需要看下handleStringTag这个方法，这个方法中会将解码后的TAG如何做处理呢？<br>我们首先需要看下这个方法是如何从native层上升到Java层的，说到这个就必须考虑android_media_MediaScanner.cpp这个过渡类，在这个文件中我们可以找到handleStringTag这个方法，和其他一样在这里调用了CallVoidMethod方法进入到java层。这样java层中的handleStringTag就会被调用。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">virtual</span> status_t handle<span class="constructor">StringTag(<span class="params">const</span> <span class="params">char</span><span class="operator">*</span> <span class="params">name</span>, <span class="params">const</span> <span class="params">char</span><span class="operator">*</span> <span class="params">value</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="constructor">ALOGV(<span class="string">&quot;MediaScanner handleStringTag: name(%s) and value(%s)&quot;</span>, <span class="params">name</span>, <span class="params">value</span>)</span>;</span><br><span class="line">    jstring nameStr, valueStr;</span><br><span class="line">    <span class="keyword">if</span> ((nameStr = mEnv-&gt;<span class="constructor">NewStringUTF(<span class="params">name</span>)</span>)<span class="operator"> == </span>NULL) &#123;</span><br><span class="line">        mEnv-&gt;<span class="constructor">ExceptionClear()</span>;</span><br><span class="line">        return NO_MEMORY;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">char</span> *cleaned = NULL;</span><br><span class="line">    <span class="comment">//如果不是正常的UTF-8则将其置为？</span></span><br><span class="line">    <span class="keyword">if</span> (!is<span class="constructor">ValidUtf8(<span class="params">value</span>)</span>) &#123;</span><br><span class="line">        cleaned = strdup(value);</span><br><span class="line">        <span class="built_in">char</span> *chp = cleaned;</span><br><span class="line">        <span class="built_in">char</span> ch;</span><br><span class="line">        <span class="keyword">while</span> ((ch = *chp)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ch &amp; <span class="number">0x80</span>) &#123;</span><br><span class="line">                *chp = <span class="character">&#x27;?&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            chp++;</span><br><span class="line">        &#125;</span><br><span class="line">        value = cleaned;</span><br><span class="line">    &#125;</span><br><span class="line">    valueStr = mEnv-&gt;<span class="constructor">NewStringUTF(<span class="params">value</span>)</span>;</span><br><span class="line">    free(cleaned);</span><br><span class="line">    <span class="keyword">if</span> (valueStr<span class="operator"> == </span>NULL) &#123;</span><br><span class="line">        mEnv-&gt;<span class="constructor">DeleteLocalRef(<span class="params">nameStr</span>)</span>;</span><br><span class="line">        mEnv-&gt;<span class="constructor">ExceptionClear()</span>;</span><br><span class="line">        return NO_MEMORY;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//调用JAVA层的handleStringTag方法。</span></span><br><span class="line">    mEnv-&gt;<span class="constructor">CallVoidMethod(<span class="params">mClient</span>, <span class="params">mHandleStringTagMethodID</span>, <span class="params">nameStr</span>, <span class="params">valueStr</span>)</span>;</span><br><span class="line">    mEnv-&gt;<span class="constructor">DeleteLocalRef(<span class="params">nameStr</span>)</span>;</span><br><span class="line">    mEnv-&gt;<span class="constructor">DeleteLocalRef(<span class="params">valueStr</span>)</span>;</span><br><span class="line">    return check<span class="constructor">AndClearExceptionFromCallback(<span class="params">mEnv</span>, <span class="string">&quot;handleStringTag&quot;</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">最后还是上个图吧，虽然流程简单但是还是很杂的，容易乱：</span><br><span class="line">!<span class="literal">[]</span>(/Android-源码分析之MediaScanner-<span class="number">2.</span>md/<span class="number">1.</span>png)</span><br></pre></td></tr></table></figure>
<p>附录：帧标识的含义</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">AENC    	Audio encryption</span><br><span class="line">APIC   		Attached picture</span><br><span class="line">COMM		Comments</span><br><span class="line">COMR		Commercial</span><br><span class="line">ENCR		Encryption <span class="keyword">method</span> registration</span><br><span class="line">EQUA		Equalization</span><br><span class="line">ETCO		Event <span class="keyword">timing</span> codes</span><br><span class="line">GEOB		General encapsulated <span class="keyword">object</span></span><br><span class="line">GRID		<span class="keyword">Group</span> identification registration</span><br><span class="line">IPLS		Involved people list</span><br><span class="line">LINK		Linked information</span><br><span class="line">MCDI		Music CD identifier</span><br><span class="line">MLLT 		MPEGlocation lookup <span class="keyword">table</span></span><br><span class="line">OWNE		Ownership</span><br><span class="line">PRIV		Private</span><br><span class="line">PCNT 		Playcounter</span><br><span class="line">POPM		Popularimeter</span><br><span class="line">POSS		Position synchronisation</span><br><span class="line">RBUF		Recommended buffer size</span><br><span class="line">RVAD		Relative volume adjustment</span><br><span class="line">RVRB		Reverb</span><br><span class="line">SYLT		Synchronized lyric/<span class="type">text</span></span><br><span class="line">SYTC		Synchronized tempo codes</span><br><span class="line">TALB		Album/Movie/<span class="keyword">Show</span> title</span><br><span class="line">TBPM 		BPM(beats per minute)</span><br><span class="line">TCOM		Composer</span><br><span class="line">TCON		Content <span class="keyword">type</span></span><br><span class="line">TCOP		Copyright message</span><br><span class="line">TDAT 		<span class="type">Date</span></span><br><span class="line">TDLY		Playlist delay</span><br><span class="line">TENC		Encoded <span class="keyword">by</span></span><br><span class="line"><span class="type">TEXT</span>		Lyricist/<span class="type">Text</span> writer</span><br><span class="line">TFLT 		Filetype</span><br><span class="line"><span class="type">TIME</span> 		<span class="type">Time</span></span><br><span class="line">TIT1		Content <span class="keyword">group</span> deion</span><br><span class="line">TIT2		Title/songname/content deion</span><br><span class="line">TIT3		Subtitle/Deion refinement</span><br><span class="line">TKEY		Initial key</span><br><span class="line">TLAN		<span class="keyword">Language</span>(s)</span><br><span class="line">TLEN		Length</span><br><span class="line">TMED		Media <span class="keyword">type</span></span><br><span class="line">TOAL		Original album/movie/<span class="keyword">show</span> title</span><br><span class="line">TOFN		Original filename</span><br><span class="line">TOLY		Original lyricist(s)/<span class="type">text</span> writer(s)</span><br><span class="line">TOPE		Original artist(s)/performer(s)</span><br><span class="line">TORY		Original <span class="keyword">release</span> year</span><br><span class="line">TOWN 		Fileowner/licensee</span><br><span class="line">TPE1 		Leadperformer(s)/Soloist(s)</span><br><span class="line">TPE2		Band/orchestra/accompaniment</span><br><span class="line">TPE3		Conductor/performer refinement</span><br><span class="line">TPE4		Interpreted, remixed, <span class="keyword">or</span> otherwise modified <span class="keyword">by</span></span><br><span class="line">TPOS 		Partof a <span class="keyword">set</span></span><br><span class="line">TPUB		Publisher</span><br><span class="line">TRCK		Track number/Position <span class="keyword">in</span> <span class="keyword">set</span></span><br><span class="line">TRDA		Recording dates</span><br><span class="line">TRSN		Internet radio station <span class="type">name</span></span><br><span class="line">TRSO		Internet radio station <span class="keyword">owner</span></span><br><span class="line">TSIZ 		Size</span><br><span class="line">TSRC 		ISRC(international standard recording code)</span><br><span class="line">TSSE		Software/Hardware <span class="keyword">and</span> settings used <span class="keyword">for</span> <span class="keyword">encoding</span></span><br><span class="line">TYER		Year</span><br><span class="line">TXXX 		Userdefined <span class="type">text</span> information</span><br><span class="line">UFID		<span class="keyword">Unique</span> file identifier</span><br><span class="line"><span class="keyword">USER</span>		Terms <span class="keyword">of</span> use</span><br><span class="line">USLT		Unsychronized lyric/<span class="type">text</span> tranion</span><br><span class="line">WCOM		Commercial information</span><br><span class="line">WCOP		Copyright/Legal information</span><br><span class="line">WOAF		Official audio file webpage</span><br><span class="line">WOAR		Official artist/performer webpage</span><br><span class="line">WOAS		Official audio source webpage</span><br><span class="line">WORS		Official internet radio station homepage</span><br><span class="line">WPAY		Payment</span><br><span class="line">WPUB		Publishers official webpage</span><br><span class="line">WXXX 		Userdefined URL link</span><br></pre></td></tr></table></figure>

  
	</div>
		<footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Android-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">Android 源码分析</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/AOSP-源码/">AOSP 源码</a>
  </div>

</div>



</footer>

   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2016/07/30/Android-源码分析之MediaPlayer-一-状态机介绍/" title="Android 源码分析之MediaPlayer 一 状态机介绍">
  <span>
  Android 源码分析之MediaPlayer 一 状态机介绍</span>
</a>
</div>


<div class="next">
<a href="/2016/07/28/Android-源码分析之MediaScanner/"  title="Android-源码分析之MediaScanner[1]">
 <span>Android-源码分析之MediaScanner[1]
</span>
</a>
</div>

</nav>

	
<section id="comments" class="comment">
	<div class="ds-thread" data-thread-key="2016/07/29/Android-源码分析之MediaScanner-2/" data-title="Android 源码分析之MediaScanner[2]" data-url="http://yoursite.com/2016/07/29/Android-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BMediaScanner-2/"></div>
</section>


<section id="comments" class="comment">
  <div id="disqus_thread">
    <noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  </div>
</section>

</div>  
      <div class="openaside"><a class="navbutton" href="#" title="Show Sidebar"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">Contents</strong>
 
 <ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9F%B3%E9%A2%91%E8%A7%86%E9%A2%91%E6%96%87%E4%BB%B6%E5%B8%A7%E4%BF%A1%E6%81%AF%E7%9A%84%E8%8E%B7%E5%8F%96"><span class="toc-number">1.</span> <span class="toc-text">音频视频文件帧信息的获取</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9F%B3%E9%A2%91%E8%A7%86%E9%A2%91%E6%96%87%E4%BB%B6%E7%9A%84TAG%E8%A7%A3%E6%9E%90%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90"><span class="toc-number">1.1.</span> <span class="toc-text">音频视频文件的TAG解析流程分析</span></a></li></ol></li></ol>
 
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="Hide Sidebar"></a></div>
<aside class="clearfix">
<div id="authorInfo">
	
		<div class="author-img"></div>		
	
	<div class="social-info" class="clearfix">
		
		
		<a href="https://github.com/tbfungeek" target="_blank" class="icon-github" title="github"></a>
		
		
		
		
		
		
		
		
		
		
		<a href="mailto:tbfungeek@163.com" target="_blank" class="icon-email" title="Email Me"></a>
		

	</div>
</div>

  
<div class="categorieslist">
	<p class="asidetitle">Categories</p>
		<ul>
		
		  
			<li><a href="/categories/Android-小经验/" title="Android 小经验">Android 小经验<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Android-源码分析/" title="Android 源码分析">Android 源码分析<sup>21</sup></a></li>
		  
		
		  
			<li><a href="/categories/Android其他/" title="Android其他">Android其他<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Android初步/" title="Android初步">Android初步<sup>21</sup></a></li>
		  
		
		  
			<li><a href="/categories/Android进阶/" title="Android进阶">Android进阶<sup>100</sup></a></li>
		  
		
		  
			<li><a href="/categories/Hexo-使用/" title="Hexo 使用">Hexo 使用<sup>10</sup></a></li>
		  
		
		  
			<li><a href="/categories/JavaScript理论/" title="JavaScript理论">JavaScript理论<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Objective-C-相关/" title="Objective C 相关">Objective C 相关<sup>24</sup></a></li>
		  
		
		  
			<li><a href="/categories/OpenCV/" title="OpenCV">OpenCV<sup>6</sup></a></li>
		  
		
		  
			<li><a href="/categories/ROS/" title="ROS">ROS<sup>9</sup></a></li>
		  
		
		  
			<li><a href="/categories/iOS-工具使用/" title="iOS 工具使用">iOS 工具使用<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/iOS-开源库分析/" title="iOS 开源库分析">iOS 开源库分析<sup>36</sup></a></li>
		  
		
		  
			<li><a href="/categories/iOS-理论基础/" title="iOS 理论基础">iOS 理论基础<sup>14</sup></a></li>
		  
		
		  
			<li><a href="/categories/iOS-进阶/" title="iOS 进阶">iOS 进阶<sup>4</sup></a></li>
		  
		
		  
			<li><a href="/categories/个人收藏/" title="个人收藏">个人收藏<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/代码规范/" title="代码规范">代码规范<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/其他/" title="其他">其他<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/博客分类目录/" title="博客分类目录">博客分类目录<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/叨叨系列/" title="叨叨系列">叨叨系列<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/开源代码分析/" title="开源代码分析">开源代码分析<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/开源库分析/" title="开源库分析">开源库分析<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/树莓派/" title="树莓派">树莓派<sup>4</sup></a></li>
		  
		
		  
			<li><a href="/categories/版本控制/" title="版本控制">版本控制<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/直播/" title="直播">直播<sup>6</sup></a></li>
		  
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">Tags</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/iOS-开源库分析/" title="iOS 开源库分析">iOS 开源库分析<sup>36</sup></a></li>
			
		
			
				<li><a href="/tags/Android-设计模式/" title="Android 设计模式">Android 设计模式<sup>29</sup></a></li>
			
		
			
				<li><a href="/tags/Objective-C-相关/" title="Objective C 相关">Objective C 相关<sup>24</sup></a></li>
			
		
			
				<li><a href="/tags/Android基础/" title="Android基础">Android基础<sup>21</sup></a></li>
			
		
			
				<li><a href="/tags/AOSP-源码/" title="AOSP 源码">AOSP 源码<sup>17</sup></a></li>
			
		
			
				<li><a href="/tags/Android-常用第三方库/" title="Android 常用第三方库">Android 常用第三方库<sup>15</sup></a></li>
			
		
			
				<li><a href="/tags/iOS-理论基础/" title="iOS 理论基础">iOS 理论基础<sup>14</sup></a></li>
			
		
			
				<li><a href="/tags/Hexo-使用/" title="Hexo 使用">Hexo 使用<sup>10</sup></a></li>
			
		
			
				<li><a href="/tags/ROS/" title="ROS">ROS<sup>9</sup></a></li>
			
		
			
				<li><a href="/tags/Android-动画进阶/" title="Android 动画进阶">Android 动画进阶<sup>8</sup></a></li>
			
		
			
				<li><a href="/tags/Android-JNI/" title="Android JNI">Android JNI<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/Android-绘图进阶/" title="Android 绘图进阶">Android 绘图进阶<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/Android性能优化/" title="Android性能优化">Android性能优化<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/Android-自动化测试/" title="Android 自动化测试">Android 自动化测试<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/OpenCV/" title="OpenCV">OpenCV<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/直播/" title="直播">直播<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/Android-开源源码/" title="Android 开源源码">Android 开源源码<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/Android-自定义View进阶/" title="Android 自定义View进阶">Android 自定义View进阶<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/树莓派/" title="树莓派">树莓派<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/iOS-进阶/" title="iOS 进阶">iOS 进阶<sup>4</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">Links</p>
    <ul>
        
          <li>
            
            	<a href="https://hexo.io" target="_blank" title="Hexo">Hexo</a>
            
          </li>
        
          <li>
            
            	<a href="https://pages.github.com/" target="_blank" title="GitHub">GitHub</a>
            
          </li>
        
          <li>
            
            	<a href="http://pf18.github.io/" target="_blank" title="PF18">PF18</a>
            
          </li>
        
          <li>
            
            	<a href="http://toutiao.io/" target="_blank" title="开发者头条">开发者头条</a>
            
          </li>
        
          <li>
            
            	<a href="http://www.jcodecraeer.com/" target="_blank" title="泡在网上的日子">泡在网上的日子</a>
            
          </li>
        
    </ul>
</div>

  


  <div class="rsspart">
	<a href="atom.xml" target="_blank" title="rss">RSS</a>
</div>

  
  <div class="tagcloudlist">
    <p class="asidetitle">Tag Cloud</p>
    <div class="tagcloudlist clearfix">
       <a href="/tags/AOSP-%E6%BA%90%E7%A0%81/" style="font-size: 17.14px;">AOSP 源码</a> <a href="/tags/Android-APK-%E7%AD%BE%E5%90%8D/" style="font-size: 10px;">Android APK 签名</a> <a href="/tags/Android-JNI/" style="font-size: 12.86px;">Android JNI</a> <a href="/tags/Android-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E8%BF%9B%E9%98%B6/" style="font-size: 10.71px;">Android 事件处理进阶</a> <a href="/tags/Android-%E5%8A%A8%E7%94%BB%E8%BF%9B%E9%98%B6/" style="font-size: 13.57px;">Android 动画进阶</a> <a href="/tags/Android-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%80%E5%8F%91/" style="font-size: 10px;">Android 多线程开发</a> <a href="/tags/Android-%E5%B0%8F%E7%BB%8F%E9%AA%8C/" style="font-size: 10px;">Android 小经验</a> <a href="/tags/Android-%E5%B8%B8%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/" style="font-size: 16.43px;">Android 常用第三方库</a> <a href="/tags/Android-%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/" style="font-size: 10px;">Android 开发流程</a> <a href="/tags/Android-%E5%BC%80%E6%BA%90%E6%BA%90%E7%A0%81/" style="font-size: 12.14px;">Android 开源源码</a> <a href="/tags/Android-%E7%BB%98%E5%9B%BE%E8%BF%9B%E9%98%B6/" style="font-size: 12.86px;">Android 绘图进阶</a> <a href="/tags/Android-%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/" style="font-size: 12.86px;">Android 自动化测试</a> <a href="/tags/Android-%E8%87%AA%E5%AE%9A%E4%B9%89View%E8%BF%9B%E9%98%B6/" style="font-size: 12.14px;">Android 自定义View进阶</a> <a href="/tags/Android-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 19.29px;">Android 设计模式</a> <a href="/tags/Android%E5%85%B6%E4%BB%96/" style="font-size: 10px;">Android其他</a> <a href="/tags/Android%E5%9F%BA%E7%A1%80/" style="font-size: 17.86px;">Android基础</a> <a href="/tags/Android%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/" style="font-size: 10px;">Android开发流程</a> <a href="/tags/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" style="font-size: 12.86px;">Android性能优化</a> <a href="/tags/Android%E6%B7%B7%E6%B7%86%E6%8A%80%E6%9C%AF/" style="font-size: 10px;">Android混淆技术</a> <a href="/tags/Android%E8%B4%A8%E9%87%8F%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/" style="font-size: 11.43px;">Android质量管理工具</a> <a href="/tags/Android%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/" style="font-size: 10px;">Android逆向工程</a> <a href="/tags/Git-github/" style="font-size: 10px;">Git && github</a> <a href="/tags/Hexo-%E4%BD%BF%E7%94%A8/" style="font-size: 15px;">Hexo 使用</a> <a href="/tags/JavaScript/" style="font-size: 10px;">JavaScript</a> <a href="/tags/Linux-%E4%BD%BF%E7%94%A8/" style="font-size: 10px;">Linux 使用</a> <a href="/tags/Objective-C-%E7%9B%B8%E5%85%B3/" style="font-size: 18.57px;">Objective C 相关</a> <a href="/tags/OpenCV/" style="font-size: 12.86px;">OpenCV</a> <a href="/tags/ROS/" style="font-size: 14.29px;">ROS</a> <a href="/tags/iOS-%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/" style="font-size: 10.71px;">iOS 工具使用</a> <a href="/tags/iOS-%E5%BC%80%E6%BA%90%E5%BA%93%E5%88%86%E6%9E%90/" style="font-size: 20px;">iOS 开源库分析</a> <a href="/tags/iOS-%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/" style="font-size: 15.71px;">iOS 理论基础</a> <a href="/tags/iOS-%E8%BF%9B%E9%98%B6/" style="font-size: 12.14px;">iOS 进阶</a> <a href="/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/" style="font-size: 10px;">代码规范</a> <a href="/tags/%E5%8D%9A%E5%AE%A2%E5%88%86%E7%B1%BB%E7%9B%AE%E5%BD%95/" style="font-size: 10.71px;">博客分类目录</a> <a href="/tags/%E5%8F%A8%E5%8F%A8%E7%B3%BB%E5%88%97/" style="font-size: 10px;">叨叨系列</a> <a href="/tags/%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/" style="font-size: 11.43px;">工具的使用</a> <a href="/tags/%E5%BC%80%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/" style="font-size: 10.71px;">开源代码分析</a> <a href="/tags/%E5%BC%80%E6%BA%90%E5%BA%93%E5%88%86%E6%9E%90/" style="font-size: 10px;">开源库分析</a> <a href="/tags/%E6%9D%82%E7%B1%BB/" style="font-size: 10px;">杂类</a> <a href="/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/" style="font-size: 12.14px;">树莓派</a> <a href="/tags/%E7%9B%B4%E6%92%AD/" style="font-size: 12.86px;">直播</a> <a href="/tags/%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/" style="font-size: 10.71px;">编程技巧</a> <a href="/tags/%E7%BD%91%E7%AB%99%E6%94%B6%E8%97%8F/" style="font-size: 10px;">网站收藏</a> <a href="/tags/%E9%87%8D%E8%A6%81%E6%8E%A7%E4%BB%B6/" style="font-size: 11.43px;">重要控件</a>
    </div>
  </div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
		
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/hsihohuang/kiddochan" target="_blank" title="Kiddochan">Kiddochan</a> © 2022 
		
		<a href="/about" target="_blank" title="Edgar">Edgar</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
        getSize();
        if (myWidth >= 1024) {
          c.click();
        }
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  c.click(function(){
    ta.css('display', 'block').addClass('fadeIn');
  });
  o.click(function(){
    ta.css('display', 'none');
  });
  $(window).scroll(function(){
    ta.css("top",Math.max(140,320-$(this).scrollTop()));
  });
});
</script>




<script type="text/javascript">
  var duoshuoQuery = {short_name:"tbfungeek"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script> 


<script type="text/javascript">

var disqus_shortname = 'tbfungeek';

(function(){
  var dsq = document.createElement('script');
  dsq.type = 'text/javascript';
  dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
}());
(function(){
  var dsq = document.createElement('script');
  dsq.type = 'text/javascript';
  dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/count.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
}());
</script>






<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?7c9443b0374f1cf6b1dbb5ab84d939cb";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="Back to Top"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
</html>
